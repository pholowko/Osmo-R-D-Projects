CCS PCD C Compiler, Version 5.032, 17542               12-Mar-15 17:21

               Filename:   F:\Osmobot4PostProduction\OsmobotSDCard\ex_fat.lst

               ROM used:   35476 bytes (20%)
                           Largest free fragment is 65536
               RAM used:   2005 (12%) at main() level
                           2371 (15%) worst case
               Stack used: 72 locations
               Stack size: 96

*
00000:  GOTO    85AE
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                           fat_ex.c                              //// 
.................... ////                                                                 //// 
.................... ////    This is a neat little shell utility that resembles a DOS or  //// 
.................... //// UNIX type shell in order to manipulate files on the FAT file    //// 
.................... //// system. This is mostly for demonstration purposes on how to use //// 
.................... //// some of the basic functionality of the FAT library.             //// 
.................... ////                                                                 //// 
.................... //// Type 'help' and press enter at the console prompt to get a list //// 
.................... //// of commands.                                                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  Version History:                                               //// 
.................... ////     FEB 14th 2011                                               //// 
.................... ////        * Updated example to use Microchip's MDD library.        //// 
.................... ////        * Code will not automatically init/mount file system.    //// 
.................... ////           'mount' command must be performed to do this.         //// 
.................... ////        * You cannot use path-names when performing file         //// 
.................... ////           actions (cat, tail, append, make, del).  Instead      //// 
.................... ////           you have to be in the proper directory, and file      //// 
.................... ////           actions happen to files in that directory.            //// 
.................... ////        * 'format' command can now have 'k', 'm' or 'g' postfix  //// 
.................... ////           for size (k = 1024, m=1024*1024, etc).                //// 
.................... ////        * 'info' command added.                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... #include <24FJ256GA106.h> 
.................... //////////// Standard Header file for the PIC24FJ256GA106 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ256GA106 
*
00200:  CLR     32
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    2E,2E,00
0020E:  DATA    00,00,00
00210:  CLR     32
00212:  MOV     #21C,W3
00214:  ADD     W3,W0,W0
00216:  TBLRDL.B[W0],W0L
00218:  CLR.B   1
0021A:  RETURN  
0021C:  DATA    21,21,00
0021E:  DATA    21,45,00
00220:  DATA    52,52,00
00222:  DATA    4F,52,00
00224:  DATA    21,21,00
00226:  DATA    21,00,00
00228:  CLR     32
0022A:  MOV     #234,W3
0022C:  ADD     W3,W0,W0
0022E:  TBLRDL.B[W0],W0L
00230:  CLR.B   1
00232:  RETURN  
00234:  DATA    21,21,00
00236:  DATA    21,4E,00
00238:  DATA    4F,54,00
0023A:  DATA    20,4D,00
0023C:  DATA    4F,55,00
0023E:  DATA    4E,54,00
00240:  DATA    45,44,00
00242:  DATA    21,21,00
00244:  DATA    21,00,00
00246:  CLR     32
00248:  MOV     #20,W3
0024A:  SUB     W0,W3,W3
0024C:  BRA     C,258
0024E:  MOV     #262,W3
00250:  ADD     W3,W0,W0
00252:  TBLRDL.B[W0],W0L
00254:  CLR.B   1
00256:  RETURN  
00258:  MOV     #262,W0
0025A:  ADD     W3,W3,W3
0025C:  ADD     W3,W0,W3
0025E:  TBLRDH  [W3],W0
00260:  RETURN  
00262:  DATA    0D,0A,6F
00264:  DATA    4D,65,20
00266:  DATA    64,69,64
00268:  DATA    61,20,65
0026A:  DATA    6E,6F,6C
0026C:  DATA    74,20,65
0026E:  DATA    6D,6F,74
00270:  DATA    75,6E,65
00272:  DATA    74,65,20
00274:  DATA    64,2C,66
00276:  DATA    20,6E,69
00278:  DATA    6F,74,6C
0027A:  DATA    20,67,65
0027C:  DATA    6F,69,21
0027E:  DATA    6E,67,00
00280:  DATA    20,74,00
00282:  CLR     32
00284:  MOV     #28E,W3
00286:  ADD     W3,W0,W0
00288:  TBLRDL.B[W0],W0L
0028A:  CLR.B   1
0028C:  RETURN  
0028E:  DATA    0D,0A,00
00290:  DATA    44,65,00
00292:  DATA    6C,65,00
00294:  DATA    74,69,00
00296:  DATA    6E,67,00
00298:  DATA    20,27,00
0029A:  DATA    25,73,00
0029C:  DATA    27,3A,00
0029E:  DATA    20,00,00
002A0:  CLR     32
002A2:  MOV     #2AC,W3
002A4:  ADD     W3,W0,W0
002A6:  TBLRDL.B[W0],W0L
002A8:  CLR.B   1
002AA:  RETURN  
002AC:  DATA    45,72,00
002AE:  DATA    72,6F,00
002B0:  DATA    72,20,00
002B2:  DATA    64,65,00
002B4:  DATA    6C,65,00
002B6:  DATA    74,69,00
002B8:  DATA    6E,67,00
002BA:  DATA    20,66,00
002BC:  DATA    69,6C,00
002BE:  DATA    65,00,00
002C0:  CLR     32
002C2:  MOV     #1E,W3
002C4:  SUB     W0,W3,W3
002C6:  BRA     C,2D2
002C8:  MOV     #2DC,W3
002CA:  ADD     W3,W0,W0
002CC:  TBLRDL.B[W0],W0L
002CE:  CLR.B   1
002D0:  RETURN  
002D2:  MOV     #2DC,W0
002D4:  ADD     W3,W3,W3
002D6:  ADD     W3,W0,W3
002D8:  TBLRDH  [W3],W0
002DA:  RETURN  
002DC:  DATA    0D,0A,20
002DE:  DATA    4D,65,74
002E0:  DATA    64,69,6F
002E2:  DATA    61,20,20
002E4:  DATA    6E,6F,6D
002E6:  DATA    74,20,61
002E8:  DATA    6D,6F,6B
002EA:  DATA    75,6E,65
002EC:  DATA    74,65,20
002EE:  DATA    64,2C,66
002F0:  DATA    20,6E,69
002F2:  DATA    6F,74,6C
002F4:  DATA    20,67,65
002F6:  DATA    6F,69,21
002F8:  DATA    6E,67,00
002FA:  CLR     32
002FC:  MOV     #306,W3
002FE:  ADD     W3,W0,W0
00300:  TBLRDL.B[W0],W0L
00302:  CLR.B   1
00304:  RETURN  
00306:  DATA    77,00,00
00308:  CLR     32
0030A:  MOV     #314,W3
0030C:  ADD     W3,W0,W0
0030E:  TBLRDL.B[W0],W0L
00310:  CLR.B   1
00312:  RETURN  
00314:  DATA    45,72,00
00316:  DATA    72,6F,00
00318:  DATA    72,20,00
0031A:  DATA    28,6F,00
0031C:  DATA    70,65,00
0031E:  DATA    6E,20,00
00320:  DATA    65,72,00
00322:  DATA    72,6F,00
00324:  DATA    72,20,00
00326:  DATA    25,58,00
00328:  DATA    29,00,00
0032A:  CLR     32
0032C:  MOV     #336,W3
0032E:  ADD     W3,W0,W0
00330:  TBLRDL.B[W0],W0L
00332:  CLR.B   1
00334:  RETURN  
00336:  DATA    45,72,00
00338:  DATA    72,6F,00
0033A:  DATA    72,20,00
0033C:  DATA    28,63,00
0033E:  DATA    6C,6F,00
00340:  DATA    73,65,00
00342:  DATA    20,65,00
00344:  DATA    72,72,00
00346:  DATA    6F,72,00
00348:  DATA    20,25,00
0034A:  DATA    58,20,00
0034C:  DATA    25,58,00
0034E:  DATA    29,00,00
00350:  CLR     32
00352:  MOV     #20,W3
00354:  SUB     W0,W3,W3
00356:  BRA     C,362
00358:  MOV     #36C,W3
0035A:  ADD     W3,W0,W0
0035C:  TBLRDL.B[W0],W0L
0035E:  CLR.B   1
00360:  RETURN  
00362:  MOV     #36C,W0
00364:  ADD     W3,W3,W3
00366:  ADD     W3,W0,W3
00368:  TBLRDH  [W3],W0
0036A:  RETURN  
0036C:  DATA    0D,0A,6F
0036E:  DATA    4D,65,20
00370:  DATA    64,69,61
00372:  DATA    61,20,70
00374:  DATA    6E,6F,70
00376:  DATA    74,20,65
00378:  DATA    6D,6F,6E
0037A:  DATA    75,6E,64
0037C:  DATA    74,65,20
0037E:  DATA    64,2C,66
00380:  DATA    20,6E,69
00382:  DATA    6F,74,6C
00384:  DATA    20,67,65
00386:  DATA    6F,69,21
00388:  DATA    6E,67,00
0038A:  DATA    20,74,00
0038C:  CLR     32
0038E:  MOV     #398,W3
00390:  ADD     W3,W0,W0
00392:  TBLRDL.B[W0],W0L
00394:  CLR.B   1
00396:  RETURN  
00398:  DATA    0D,0A,00
0039A:  DATA    41,70,00
0039C:  DATA    70,65,00
0039E:  DATA    6E,64,00
003A0:  DATA    69,6E,00
003A2:  DATA    67,20,00
003A4:  DATA    27,25,00
003A6:  DATA    73,27,00
003A8:  DATA    20,74,00
003AA:  DATA    6F,20,00
003AC:  DATA    27,25,00
003AE:  DATA    73,27,00
003B0:  DATA    3A,20,00
003B2:  DATA    00,00,00
003B4:  CLR     32
003B6:  MOV     #3C0,W3
003B8:  ADD     W3,W0,W0
003BA:  TBLRDL.B[W0],W0L
003BC:  CLR.B   1
003BE:  RETURN  
003C0:  DATA    61,00,00
003C2:  CLR     32
003C4:  MOV     #3CE,W3
003C6:  ADD     W3,W0,W0
003C8:  TBLRDL.B[W0],W0L
003CA:  CLR.B   1
003CC:  RETURN  
003CE:  DATA    45,72,00
003D0:  DATA    72,6F,00
003D2:  DATA    72,20,00
003D4:  DATA    28,25,00
003D6:  DATA    58,29,00
003D8:  DATA    00,00,00
003DA:  CLR     32
003DC:  MOV     #3E6,W3
003DE:  ADD     W3,W0,W0
003E0:  TBLRDL.B[W0],W0L
003E2:  CLR.B   1
003E4:  RETURN  
003E6:  DATA    45,72,00
003E8:  DATA    72,6F,00
003EA:  DATA    72,20,00
003EC:  DATA    28,25,00
003EE:  DATA    58,20,00
003F0:  DATA    25,58,00
003F2:  DATA    29,00,00
003F4:  CLR     32
003F6:  MOV     #24,W3
003F8:  SUB     W0,W3,W3
003FA:  BRA     C,406
003FC:  MOV     #410,W3
003FE:  ADD     W3,W0,W0
00400:  TBLRDL.B[W0],W0L
00402:  CLR.B   1
00404:  RETURN  
00406:  MOV     #410,W0
00408:  ADD     W3,W3,W3
0040A:  ADD     W3,W0,W3
0040C:  TBLRDH  [W3],W0
0040E:  RETURN  
00410:  DATA    0D,0A,61
00412:  DATA    4D,65,6E
00414:  DATA    64,69,67
00416:  DATA    61,20,65
00418:  DATA    6E,6F,20
0041A:  DATA    74,20,64
0041C:  DATA    6D,6F,69
0041E:  DATA    75,6E,72
00420:  DATA    74,65,65
00422:  DATA    64,2C,63
00424:  DATA    20,6E,74
00426:  DATA    6F,74,6F
00428:  DATA    20,67,72
0042A:  DATA    6F,69,79
0042C:  DATA    6E,67,21
0042E:  DATA    20,74,00
00430:  DATA    6F,20,00
00432:  DATA    63,68,00
00434:  CLR     32
00436:  MOV     #440,W3
00438:  ADD     W3,W0,W0
0043A:  TBLRDL.B[W0],W0L
0043C:  CLR.B   1
0043E:  RETURN  
00440:  DATA    0D,0A,00
00442:  DATA    45,72,00
00444:  DATA    72,6F,00
00446:  DATA    72,20,00
00448:  DATA    63,68,00
0044A:  DATA    61,6E,00
0044C:  DATA    67,69,00
0044E:  DATA    6E,67,00
00450:  DATA    20,64,00
00452:  DATA    69,72,00
00454:  DATA    65,63,00
00456:  DATA    74,6F,00
00458:  DATA    72,79,00
0045A:  DATA    00,00,00
0045C:  CLR     32
0045E:  MOV     #24,W3
00460:  SUB     W0,W3,W3
00462:  BRA     C,46E
00464:  MOV     #478,W3
00466:  ADD     W3,W0,W0
00468:  TBLRDL.B[W0],W0L
0046A:  CLR.B   1
0046C:  RETURN  
0046E:  MOV     #478,W0
00470:  ADD     W3,W3,W3
00472:  ADD     W3,W0,W3
00474:  TBLRDH  [W3],W0
00476:  RETURN  
00478:  DATA    0D,0A,73
0047A:  DATA    4D,65,70
0047C:  DATA    64,69,6C
0047E:  DATA    61,20,61
00480:  DATA    6E,6F,79
00482:  DATA    74,20,20
00484:  DATA    6D,6F,64
00486:  DATA    75,6E,69
00488:  DATA    74,65,72
0048A:  DATA    64,2C,65
0048C:  DATA    20,6E,63
0048E:  DATA    6F,74,74
00490:  DATA    20,67,6F
00492:  DATA    6F,69,72
00494:  DATA    6E,67,79
00496:  DATA    20,74,21
00498:  DATA    6F,20,00
0049A:  DATA    64,69,00
0049C:  CLR     32
0049E:  MOV     #4A8,W3
004A0:  ADD     W3,W0,W0
004A2:  TBLRDL.B[W0],W0L
004A4:  CLR.B   1
004A6:  RETURN  
004A8:  DATA    2A,2E,00
004AA:  DATA    2A,00,00
004AC:  CLR     32
004AE:  MOV     #4B8,W3
004B0:  ADD     W3,W0,W0
004B2:  TBLRDL.B[W0],W0L
004B4:  CLR.B   1
004B6:  RETURN  
004B8:  DATA    0D,0A,00
004BA:  DATA    0A,44,00
004BC:  DATA    69,72,00
004BE:  DATA    65,63,00
004C0:  DATA    74,6F,00
004C2:  DATA    72,79,00
004C4:  DATA    20,73,00
004C6:  DATA    65,61,00
004C8:  DATA    72,63,00
004CA:  DATA    68,20,00
004CC:  DATA    63,6F,00
004CE:  DATA    6D,70,00
004D0:  DATA    6C,65,00
004D2:  DATA    74,65,00
004D4:  DATA    64,00,00
004D6:  CLR     32
004D8:  MOV     #4E2,W3
004DA:  ADD     W3,W0,W0
004DC:  TBLRDL.B[W0],W0L
004DE:  CLR.B   1
004E0:  RETURN  
004E2:  DATA    20,28,00
004E4:  DATA    46,53,00
004E6:  DATA    65,72,00
004E8:  DATA    72,6E,00
004EA:  DATA    6F,20,00
004EC:  DATA    3D,20,00
004EE:  DATA    25,75,00
004F0:  DATA    29,00,00
004F2:  CLR     32
004F4:  MOV     #4FE,W3
004F6:  ADD     W3,W0,W0
004F8:  TBLRDL.B[W0],W0L
004FA:  CLR.B   1
004FC:  RETURN  
004FE:  DATA    3C,44,00
00500:  DATA    49,52,00
00502:  DATA    3E,20,00
00504:  DATA    20,00,00
00506:  CLR     32
00508:  MOV     #512,W3
0050A:  ADD     W3,W0,W0
0050C:  TBLRDL.B[W0],W0L
0050E:  CLR.B   1
00510:  RETURN  
00512:  DATA    20,20,00
00514:  DATA    20,20,00
00516:  DATA    20,20,00
00518:  DATA    20,00,00
0051A:  CLR     32
0051C:  MOV     #22,W3
0051E:  SUB     W0,W3,W3
00520:  BRA     C,52C
00522:  MOV     #536,W3
00524:  ADD     W3,W0,W0
00526:  TBLRDL.B[W0],W0L
00528:  CLR.B   1
0052A:  RETURN  
0052C:  MOV     #536,W0
0052E:  ADD     W3,W3,W3
00530:  ADD     W3,W0,W3
00532:  TBLRDH  [W3],W0
00534:  RETURN  
00536:  DATA    0D,0A,6D
00538:  DATA    4D,65,61
0053A:  DATA    64,69,6B
0053C:  DATA    61,20,65
0053E:  DATA    6E,6F,20
00540:  DATA    74,20,64
00542:  DATA    6D,6F,69
00544:  DATA    75,6E,72
00546:  DATA    74,65,65
00548:  DATA    64,2C,63
0054A:  DATA    20,6E,74
0054C:  DATA    6F,74,6F
0054E:  DATA    20,67,72
00550:  DATA    6F,69,79
00552:  DATA    6E,67,21
00554:  DATA    20,74,00
00556:  DATA    6F,20,00
00558:  CLR     32
0055A:  MOV     #564,W3
0055C:  ADD     W3,W0,W0
0055E:  TBLRDL.B[W0],W0L
00560:  CLR.B   1
00562:  RETURN  
00564:  DATA    0D,0A,00
00566:  DATA    4D,61,00
00568:  DATA    6B,69,00
0056A:  DATA    6E,67,00
0056C:  DATA    20,64,00
0056E:  DATA    69,72,00
00570:  DATA    65,63,00
00572:  DATA    74,6F,00
00574:  DATA    72,79,00
00576:  DATA    20,27,00
00578:  DATA    25,73,00
0057A:  DATA    27,3A,00
0057C:  DATA    20,00,00
0057E:  CLR     32
00580:  MOV     #58A,W3
00582:  ADD     W3,W0,W0
00584:  TBLRDL.B[W0],W0L
00586:  CLR.B   1
00588:  RETURN  
0058A:  DATA    45,72,00
0058C:  DATA    72,6F,00
0058E:  DATA    72,20,00
00590:  DATA    63,72,00
00592:  DATA    65,61,00
00594:  DATA    74,69,00
00596:  DATA    6E,67,00
00598:  DATA    20,64,00
0059A:  DATA    69,72,00
0059C:  DATA    65,63,00
0059E:  DATA    74,6F,00
005A0:  DATA    72,79,00
005A2:  DATA    20,28,00
005A4:  DATA    46,53,00
005A6:  DATA    65,72,00
005A8:  DATA    72,6E,00
005AA:  DATA    6F,20,00
005AC:  DATA    3D,20,00
005AE:  DATA    25,75,00
005B0:  DATA    29,00,00
005B2:  CLR     32
005B4:  MOV     #24,W3
005B6:  SUB     W0,W3,W3
005B8:  BRA     C,5C4
005BA:  MOV     #5CE,W3
005BC:  ADD     W3,W0,W0
005BE:  TBLRDL.B[W0],W0L
005C0:  CLR.B   1
005C2:  RETURN  
005C4:  MOV     #5CE,W0
005C6:  ADD     W3,W3,W3
005C8:  ADD     W3,W0,W3
005CA:  TBLRDH  [W3],W0
005CC:  RETURN  
005CE:  DATA    0D,0A,6D
005D0:  DATA    4D,65,6F
005D2:  DATA    64,69,76
005D4:  DATA    61,20,65
005D6:  DATA    6E,6F,20
005D8:  DATA    74,20,64
005DA:  DATA    6D,6F,69
005DC:  DATA    75,6E,72
005DE:  DATA    74,65,65
005E0:  DATA    64,2C,63
005E2:  DATA    20,6E,74
005E4:  DATA    6F,74,6F
005E6:  DATA    20,67,72
005E8:  DATA    6F,69,79
005EA:  DATA    6E,67,21
005EC:  DATA    20,74,00
005EE:  DATA    6F,20,00
005F0:  DATA    72,65,00
005F2:  CLR     32
005F4:  MOV     #5FE,W3
005F6:  ADD     W3,W0,W0
005F8:  TBLRDL.B[W0],W0L
005FA:  CLR.B   1
005FC:  RETURN  
005FE:  DATA    0D,0A,00
00600:  DATA    52,65,00
00602:  DATA    6D,6F,00
00604:  DATA    76,69,00
00606:  DATA    6E,67,00
00608:  DATA    20,64,00
0060A:  DATA    69,72,00
0060C:  DATA    65,63,00
0060E:  DATA    74,6F,00
00610:  DATA    72,79,00
00612:  DATA    20,27,00
00614:  DATA    25,73,00
00616:  DATA    27,3A,00
00618:  DATA    20,00,00
0061A:  CLR     32
0061C:  MOV     #626,W3
0061E:  ADD     W3,W0,W0
00620:  TBLRDL.B[W0],W0L
00622:  CLR.B   1
00624:  RETURN  
00626:  DATA    45,72,00
00628:  DATA    72,6F,00
0062A:  DATA    72,20,00
0062C:  DATA    72,65,00
0062E:  DATA    6D,6F,00
00630:  DATA    76,69,00
00632:  DATA    6E,67,00
00634:  DATA    20,64,00
00636:  DATA    69,72,00
00638:  DATA    65,63,00
0063A:  DATA    74,6F,00
0063C:  DATA    72,79,00
0063E:  DATA    00,00,00
00640:  CLR     32
00642:  MOV     #20,W3
00644:  SUB     W0,W3,W3
00646:  BRA     C,652
00648:  MOV     #65C,W3
0064A:  ADD     W3,W0,W0
0064C:  TBLRDL.B[W0],W0L
0064E:  CLR.B   1
00650:  RETURN  
00652:  MOV     #65C,W0
00654:  ADD     W3,W3,W3
00656:  ADD     W3,W0,W3
00658:  TBLRDH  [W3],W0
0065A:  RETURN  
0065C:  DATA    0D,0A,6F
0065E:  DATA    4D,65,20
00660:  DATA    64,69,64
00662:  DATA    61,20,69
00664:  DATA    6E,6F,73
00666:  DATA    74,20,70
00668:  DATA    6D,6F,6C
0066A:  DATA    75,6E,61
0066C:  DATA    74,65,79
0066E:  DATA    64,2C,20
00670:  DATA    20,6E,66
00672:  DATA    6F,74,69
00674:  DATA    20,67,6C
00676:  DATA    6F,69,65
00678:  DATA    6E,67,21
0067A:  DATA    20,74,00
0067C:  CLR     32
0067E:  MOV     #688,W3
00680:  ADD     W3,W0,W0
00682:  TBLRDL.B[W0],W0L
00684:  CLR.B   1
00686:  RETURN  
00688:  DATA    72,00,00
0068A:  CLR     32
0068C:  MOV     #696,W3
0068E:  ADD     W3,W0,W0
00690:  TBLRDL.B[W0],W0L
00692:  CLR.B   1
00694:  RETURN  
00696:  DATA    0D,0A,00
00698:  DATA    45,72,00
0069A:  DATA    72,6F,00
0069C:  DATA    72,20,00
0069E:  DATA    6F,70,00
006A0:  DATA    65,6E,00
006A2:  DATA    69,6E,00
006A4:  DATA    67,20,00
006A6:  DATA    66,69,00
006A8:  DATA    6C,65,00
006AA:  DATA    20,28,00
006AC:  DATA    45,72,00
006AE:  DATA    72,6F,00
006B0:  DATA    72,20,00
006B2:  DATA    25,58,00
006B4:  DATA    29,00,00
006B6:  CLR     32
006B8:  MOV     #6C2,W3
006BA:  ADD     W3,W0,W0
006BC:  TBLRDL.B[W0],W0L
006BE:  CLR.B   1
006C0:  RETURN  
006C2:  DATA    0D,0A,00
006C4:  DATA    21,21,00
006C6:  DATA    21,20,00
006C8:  DATA    45,72,00
006CA:  DATA    72,6F,00
006CC:  DATA    72,20,00
006CE:  DATA    72,65,00
006D0:  DATA    61,64,00
006D2:  DATA    69,6E,00
006D4:  DATA    67,20,00
006D6:  DATA    66,69,00
006D8:  DATA    6C,65,00
006DA:  DATA    20,28,00
006DC:  DATA    45,72,00
006DE:  DATA    72,6F,00
006E0:  DATA    72,20,00
006E2:  DATA    25,58,00
006E4:  DATA    29,00,00
006E6:  CLR     32
006E8:  MOV     #6F2,W3
006EA:  ADD     W3,W0,W0
006EC:  TBLRDL.B[W0],W0L
006EE:  CLR.B   1
006F0:  RETURN  
006F2:  DATA    0D,0A,00
006F4:  DATA    45,72,00
006F6:  DATA    72,6F,00
006F8:  DATA    72,2C,00
006FA:  DATA    20,4D,00
006FC:  DATA    65,64,00
006FE:  DATA    69,61,00
00700:  DATA    20,6E,00
00702:  DATA    6F,74,00
00704:  DATA    20,66,00
00706:  DATA    6F,75,00
00708:  DATA    6E,64,00
0070A:  DATA    21,00,00
0070C:  CLR     32
0070E:  MOV     #22,W3
00710:  SUB     W0,W3,W3
00712:  BRA     C,71E
00714:  MOV     #728,W3
00716:  ADD     W3,W0,W0
00718:  TBLRDL.B[W0],W0L
0071A:  CLR.B   1
0071C:  RETURN  
0071E:  MOV     #728,W0
00720:  ADD     W3,W3,W3
00722:  ADD     W3,W0,W3
00724:  TBLRDH  [W3],W0
00726:  RETURN  
00728:  DATA    0D,0A,73
0072A:  DATA    4F,4B,3D
0072C:  DATA    20,28,25
0072E:  DATA    53,65,55
00730:  DATA    63,74,2C
00732:  DATA    6F,72,20
00734:  DATA    20,53,54
00736:  DATA    69,7A,79
00738:  DATA    65,3D,70
0073A:  DATA    25,4C,65
0073C:  DATA    55,2C,3D
0073E:  DATA    20,53,25
00740:  DATA    65,63,55
00742:  DATA    20,50,29
00744:  DATA    65,72,00
00746:  DATA    20,43,00
00748:  DATA    6C,75,00
0074A:  CLR     32
0074C:  MOV     #22,W3
0074E:  SUB     W0,W3,W3
00750:  BRA     C,75C
00752:  MOV     #766,W3
00754:  ADD     W3,W0,W0
00756:  TBLRDL.B[W0],W0L
00758:  CLR.B   1
0075A:  RETURN  
0075C:  MOV     #766,W0
0075E:  ADD     W3,W3,W3
00760:  ADD     W3,W0,W3
00762:  TBLRDH  [W3],W0
00764:  RETURN  
00766:  DATA    0D,0A,46
00768:  DATA    45,72,53
0076A:  DATA    72,6F,65
0076C:  DATA    72,2C,72
0076E:  DATA    20,66,72
00770:  DATA    69,6C,6E
00772:  DATA    65,20,6F
00774:  DATA    73,79,3D
00776:  DATA    73,74,25
00778:  DATA    65,6D,55
0077A:  DATA    20,6E,29
0077C:  DATA    6F,74,21
0077E:  DATA    20,6D,21
00780:  DATA    6F,75,21
00782:  DATA    6E,74,00
00784:  DATA    65,64,00
00786:  DATA    20,28,00
00788:  CLR     32
0078A:  MOV     #794,W3
0078C:  ADD     W3,W0,W0
0078E:  TBLRDL.B[W0],W0L
00790:  CLR.B   1
00792:  RETURN  
00794:  DATA    0D,0A,00
00796:  DATA    45,72,00
00798:  DATA    72,6F,00
0079A:  DATA    72,2C,00
0079C:  DATA    20,66,00
0079E:  DATA    6F,72,00
007A0:  DATA    6D,61,00
007A2:  DATA    74,74,00
007A4:  DATA    69,6E,00
007A6:  DATA    67,20,00
007A8:  DATA    64,69,00
007AA:  DATA    73,61,00
007AC:  DATA    62,6C,00
007AE:  DATA    65,64,00
007B0:  DATA    21,21,00
007B2:  DATA    21,00,00
007B4:  CLR     32
007B6:  MOV     #28,W3
007B8:  SUB     W0,W3,W3
007BA:  BRA     C,7C6
007BC:  MOV     #7D0,W3
007BE:  ADD     W3,W0,W0
007C0:  TBLRDL.B[W0],W0L
007C2:  CLR.B   1
007C4:  RETURN  
007C6:  MOV     #7D0,W0
007C8:  ADD     W3,W3,W3
007CA:  ADD     W3,W0,W3
007CC:  TBLRDH  [W3],W0
007CE:  RETURN  
007D0:  DATA    0D,0A,6E
007D2:  DATA    47,65,64
007D4:  DATA    74,74,73
007D6:  DATA    69,6E,20
007D8:  DATA    67,20,74
007DA:  DATA    6D,65,6F
007DC:  DATA    64,69,20
007DE:  DATA    61,20,6D
007E0:  DATA    69,6E,69
007E2:  DATA    66,6F,6E
007E4:  DATA    20,28,75
007E6:  DATA    74,68,74
007E8:  DATA    69,73,65
007EA:  DATA    20,6D,73
007EC:  DATA    61,79,29
007EE:  DATA    20,74,2E
007F0:  DATA    61,6B,2E
007F2:  DATA    65,20,2E
007F4:  DATA    73,65,00
007F6:  DATA    63,6F,00
007F8:  CLR     32
007FA:  MOV     #2A,W3
007FC:  SUB     W0,W3,W3
007FE:  BRA     C,80A
00800:  MOV     #814,W3
00802:  ADD     W3,W0,W0
00804:  TBLRDL.B[W0],W0L
00806:  CLR.B   1
00808:  RETURN  
0080A:  MOV     #814,W0
0080C:  ADD     W3,W3,W3
0080E:  ADD     W3,W0,W3
00810:  TBLRDH  [W3],W0
00812:  RETURN  
00814:  DATA    0D,0A,20
00816:  DATA    0A,46,74
00818:  DATA    69,6C,72
0081A:  DATA    65,20,79
0081C:  DATA    73,79,20
0081E:  DATA    73,74,6D
00820:  DATA    65,6D,6F
00822:  DATA    20,74,75
00824:  DATA    68,69,6E
00826:  DATA    6E,6B,74
00828:  DATA    73,20,69
0082A:  DATA    6D,65,6E
0082C:  DATA    64,69,67
0082E:  DATA    61,20,20
00830:  DATA    69,73,61
00832:  DATA    6E,27,67
00834:  DATA    74,20,61
00836:  DATA    6D,6F,69
00838:  DATA    75,6E,6E
0083A:  DATA    74,65,21
0083C:  DATA    64,2C,00
0083E:  CLR     32
00840:  MOV     #84A,W3
00842:  ADD     W3,W0,W0
00844:  TBLRDL.B[W0],W0L
00846:  CLR.B   1
00848:  RETURN  
0084A:  DATA    0D,0A,00
0084C:  DATA    0A,45,00
0084E:  DATA    72,72,00
00850:  DATA    6F,72,00
00852:  DATA    20,67,00
00854:  DATA    65,74,00
00856:  DATA    74,69,00
00858:  DATA    6E,67,00
0085A:  DATA    20,69,00
0085C:  DATA    6E,66,00
0085E:  DATA    6F,00,00
00860:  CLR     32
00862:  MOV     #86C,W3
00864:  ADD     W3,W0,W0
00866:  TBLRDL.B[W0],W0L
00868:  CLR.B   1
0086A:  RETURN  
0086C:  DATA    0D,0A,00
0086E:  DATA    0A,42,00
00870:  DATA    79,74,00
00872:  DATA    65,73,00
00874:  DATA    20,70,00
00876:  DATA    65,72,00
00878:  DATA    20,73,00
0087A:  DATA    65,63,00
0087C:  DATA    74,6F,00
0087E:  DATA    72,3A,00
00880:  DATA    20,25,00
00882:  DATA    4C,55,00
00884:  DATA    00,00,00
00886:  CLR     32
00888:  MOV     #892,W3
0088A:  ADD     W3,W0,W0
0088C:  TBLRDL.B[W0],W0L
0088E:  CLR.B   1
00890:  RETURN  
00892:  DATA    0D,0A,00
00894:  DATA    53,65,00
00896:  DATA    63,74,00
00898:  DATA    6F,72,00
0089A:  DATA    73,20,00
0089C:  DATA    70,65,00
0089E:  DATA    72,20,00
008A0:  DATA    63,6C,00
008A2:  DATA    75,73,00
008A4:  DATA    74,65,00
008A6:  DATA    72,3A,00
008A8:  DATA    20,25,00
008AA:  DATA    55,00,00
008AC:  CLR     32
008AE:  MOV     #8B8,W3
008B0:  ADD     W3,W0,W0
008B2:  TBLRDL.B[W0],W0L
008B4:  CLR.B   1
008B6:  RETURN  
008B8:  DATA    0D,0A,00
008BA:  DATA    54,6F,00
008BC:  DATA    74,61,00
008BE:  DATA    6C,20,00
008C0:  DATA    73,69,00
008C2:  DATA    7A,65,00
008C4:  DATA    20,6F,00
008C6:  DATA    66,20,00
008C8:  DATA    6D,65,00
008CA:  DATA    64,69,00
008CC:  DATA    61,3A,00
008CE:  DATA    20,25,00
008D0:  DATA    4C,55,00
008D2:  DATA    00,00,00
008D4:  CLR     32
008D6:  MOV     #8E0,W3
008D8:  ADD     W3,W0,W0
008DA:  TBLRDL.B[W0],W0L
008DC:  CLR.B   1
008DE:  RETURN  
008E0:  DATA    0D,0A,00
008E2:  DATA    46,72,00
008E4:  DATA    65,65,00
008E6:  DATA    20,73,00
008E8:  DATA    70,61,00
008EA:  DATA    63,65,00
008EC:  DATA    20,6F,00
008EE:  DATA    66,20,00
008F0:  DATA    6D,65,00
008F2:  DATA    64,69,00
008F4:  DATA    61,3A,00
008F6:  DATA    20,25,00
008F8:  DATA    4C,55,00
008FA:  DATA    00,00,00
008FC:  CLR     32
008FE:  MOV     #908,W3
00900:  ADD     W3,W0,W0
00902:  TBLRDL.B[W0],W0L
00904:  CLR.B   1
00906:  RETURN  
00908:  DATA    0D,0A,00
0090A:  DATA    4D,65,00
0090C:  DATA    64,69,00
0090E:  DATA    61,20,00
00910:  DATA    6E,6F,00
00912:  DATA    74,20,00
00914:  DATA    6D,6F,00
00916:  DATA    75,6E,00
00918:  DATA    74,65,00
0091A:  DATA    64,2C,00
0091C:  DATA    20,6E,00
0091E:  DATA    6F,74,00
00920:  DATA    20,67,00
00922:  DATA    65,74,00
00924:  DATA    74,69,00
00926:  DATA    6E,67,00
00928:  DATA    20,69,00
0092A:  DATA    6E,66,00
0092C:  DATA    6F,21,00
0092E:  DATA    00,00,00
00930:  CLR     32
00932:  MOV     #22,W3
00934:  SUB     W0,W3,W3
00936:  BRA     C,942
00938:  MOV     #94C,W3
0093A:  ADD     W3,W0,W0
0093C:  TBLRDL.B[W0],W0L
0093E:  CLR.B   1
00940:  RETURN  
00942:  MOV     #94C,W0
00944:  ADD     W3,W3,W3
00946:  ADD     W3,W0,W3
00948:  TBLRDH  [W3],W0
0094A:  RETURN  
0094C:  DATA    0D,0A,43
0094E:  DATA    46,41,53
00950:  DATA    54,20,20
00952:  DATA    53,68,43
00954:  DATA    65,6C,20
00956:  DATA    6C,20,43
00958:  DATA    48,65,6F
0095A:  DATA    6C,70,6D
0095C:  DATA    20,2D,70
0095E:  DATA    20,43,69
00960:  DATA    6F,6D,6C
00962:  DATA    70,69,65
00964:  DATA    6C,65,72
00966:  DATA    64,20,20
00968:  DATA    77,69,00
0096A:  DATA    74,68,00
0096C:  DATA    20,43,00
0096E:  CLR     32
00970:  MOV     #97A,W3
00972:  ADD     W3,W0,W0
00974:  TBLRDL.B[W0],W0L
00976:  CLR.B   1
00978:  RETURN  
0097A:  DATA    50,43,00
0097C:  DATA    44,20,00
0097E:  DATA    00,00,00
00980:  CLR     32
00982:  MOV     #98C,W3
00984:  ADD     W3,W0,W0
00986:  TBLRDL.B[W0],W0L
00988:  CLR.B   1
0098A:  RETURN  
0098C:  DATA    35,2E,00
0098E:  DATA    30,33,00
00990:  DATA    32,00,00
00992:  CLR     32
00994:  MOV     #34,W3
00996:  SUB     W0,W3,W3
00998:  BRA     C,9A4
0099A:  MOV     #9AE,W3
0099C:  ADD     W3,W0,W0
0099E:  TBLRDL.B[W0],W0L
009A0:  CLR.B   1
009A2:  RETURN  
009A4:  MOV     #9AE,W0
009A6:  ADD     W3,W3,W3
009A8:  ADD     W3,W0,W3
009AA:  TBLRDH  [W3],W0
009AC:  RETURN  
009AE:  DATA    0D,0A,69
009B0:  DATA    20,6D,72
009B2:  DATA    6F,75,65
009B4:  DATA    6E,74,64
009B6:  DATA    20,2D,20
009B8:  DATA    2D,2D,62
009BA:  DATA    20,69,65
009BC:  DATA    6E,69,66
009BE:  DATA    74,69,6F
009C0:  DATA    61,6C,72
009C2:  DATA    69,7A,65
009C4:  DATA    65,20,20
009C6:  DATA    61,6E,66
009C8:  DATA    64,20,69
009CA:  DATA    6D,6F,6C
009CC:  DATA    75,6E,65
009CE:  DATA    74,20,20
009D0:  DATA    66,69,61
009D2:  DATA    6C,65,63
009D4:  DATA    20,73,63
009D6:  DATA    79,73,65
009D8:  DATA    74,65,73
009DA:  DATA    6D,2E,73
009DC:  DATA    20,20,00
009DE:  DATA    72,65,00
009E0:  DATA    71,75,00
009E2:  CLR     32
009E4:  MOV     #9EE,W3
009E6:  ADD     W3,W0,W0
009E8:  TBLRDL.B[W0],W0L
009EA:  CLR.B   1
009EC:  RETURN  
009EE:  DATA    0D,0A,00
009F0:  DATA    20,64,00
009F2:  DATA    65,6C,00
009F4:  DATA    20,66,00
009F6:  DATA    69,6C,00
009F8:  DATA    65,6E,00
009FA:  DATA    61,6D,00
009FC:  DATA    65,20,00
009FE:  DATA    2D,2D,00
00A00:  DATA    2D,20,00
00A02:  DATA    44,65,00
00A04:  DATA    6C,65,00
00A06:  DATA    74,65,00
00A08:  DATA    73,20,00
00A0A:  DATA    74,68,00
00A0C:  DATA    65,20,00
00A0E:  DATA    66,69,00
00A10:  DATA    6C,65,00
00A12:  DATA    00,00,00
00A14:  CLR     32
00A16:  MOV     #1E,W3
00A18:  SUB     W0,W3,W3
00A1A:  BRA     C,A26
00A1C:  MOV     #A30,W3
00A1E:  ADD     W3,W0,W0
00A20:  TBLRDL.B[W0],W0L
00A22:  CLR.B   1
00A24:  RETURN  
00A26:  MOV     #A30,W0
00A28:  ADD     W3,W3,W3
00A2A:  ADD     W3,W0,W3
00A2C:  TBLRDH  [W3],W0
00A2E:  RETURN  
00A30:  DATA    0D,0A,6E
00A32:  DATA    20,6D,20
00A34:  DATA    61,6B,65
00A36:  DATA    65,20,6D
00A38:  DATA    66,69,70
00A3A:  DATA    6C,65,74
00A3C:  DATA    6E,61,79
00A3E:  DATA    6D,65,20
00A40:  DATA    20,2D,66
00A42:  DATA    2D,2D,69
00A44:  DATA    20,43,6C
00A46:  DATA    72,65,65
00A48:  DATA    61,74,00
00A4A:  DATA    65,73,00
00A4C:  DATA    20,61,00
00A4E:  CLR     32
00A50:  MOV     #2E,W3
00A52:  SUB     W0,W3,W3
00A54:  BRA     C,A60
00A56:  MOV     #A6A,W3
00A58:  ADD     W3,W0,W0
00A5A:  TBLRDL.B[W0],W0L
00A5C:  CLR.B   1
00A5E:  RETURN  
00A60:  MOV     #A6A,W0
00A62:  ADD     W3,W3,W3
00A64:  ADD     W3,W0,W3
00A66:  TBLRDH  [W3],W0
00A68:  RETURN  
00A6A:  DATA    0D,0A,6F
00A6C:  DATA    20,61,20
00A6E:  DATA    70,70,74
00A70:  DATA    65,6E,68
00A72:  DATA    64,20,65
00A74:  DATA    66,69,20
00A76:  DATA    6C,65,65
00A78:  DATA    6E,61,6E
00A7A:  DATA    6D,65,64
00A7C:  DATA    20,73,20
00A7E:  DATA    74,72,6F
00A80:  DATA    69,6E,66
00A82:  DATA    67,20,20
00A84:  DATA    2D,2D,74
00A86:  DATA    2D,20,68
00A88:  DATA    41,70,65
00A8A:  DATA    70,65,20
00A8C:  DATA    6E,64,66
00A8E:  DATA    73,20,69
00A90:  DATA    73,74,6C
00A92:  DATA    72,69,65
00A94:  DATA    6E,67,00
00A96:  DATA    20,74,00
00A98:  CLR     32
00A9A:  MOV     #1E,W3
00A9C:  SUB     W0,W3,W3
00A9E:  BRA     C,AAA
00AA0:  MOV     #AB4,W3
00AA2:  ADD     W3,W0,W0
00AA4:  TBLRDL.B[W0],W0L
00AA6:  CLR.B   1
00AA8:  RETURN  
00AAA:  MOV     #AB4,W0
00AAC:  ADD     W3,W3,W3
00AAE:  ADD     W3,W0,W3
00AB0:  TBLRDH  [W3],W0
00AB2:  RETURN  
00AB4:  DATA    0D,0A,6E
00AB6:  DATA    20,63,67
00AB8:  DATA    64,20,20
00ABA:  DATA    64,69,64
00ABC:  DATA    72,20,69
00ABE:  DATA    2D,2D,72
00AC0:  DATA    2D,20,65
00AC2:  DATA    43,68,63
00AC4:  DATA    61,6E,74
00AC6:  DATA    67,65,6F
00AC8:  DATA    20,74,72
00ACA:  DATA    68,65,79
00ACC:  DATA    20,77,00
00ACE:  DATA    6F,72,00
00AD0:  DATA    6B,69,00
00AD2:  CLR     32
00AD4:  MOV     #20,W3
00AD6:  SUB     W0,W3,W3
00AD8:  BRA     C,AE4
00ADA:  MOV     #AEE,W3
00ADC:  ADD     W3,W0,W0
00ADE:  TBLRDL.B[W0],W0L
00AE0:  CLR.B   1
00AE2:  RETURN  
00AE4:  MOV     #AEE,W0
00AE6:  ADD     W3,W3,W3
00AE8:  ADD     W3,W0,W3
00AEA:  TBLRDH  [W3],W0
00AEC:  RETURN  
00AEE:  DATA    0D,0A,20
00AF0:  DATA    20,64,74
00AF2:  DATA    69,72,68
00AF4:  DATA    20,2D,65
00AF6:  DATA    2D,2D,20
00AF8:  DATA    20,53,64
00AFA:  DATA    68,6F,69
00AFC:  DATA    77,73,72
00AFE:  DATA    20,74,65
00B00:  DATA    68,65,63
00B02:  DATA    20,63,74
00B04:  DATA    6F,6E,6F
00B06:  DATA    74,65,72
00B08:  DATA    6E,74,79
00B0A:  DATA    73,20,00
00B0C:  DATA    6F,66,00
00B0E:  CLR     32
00B10:  MOV     #1E,W3
00B12:  SUB     W0,W3,W3
00B14:  BRA     C,B20
00B16:  MOV     #B2A,W3
00B18:  ADD     W3,W0,W0
00B1A:  TBLRDL.B[W0],W0L
00B1C:  CLR.B   1
00B1E:  RETURN  
00B20:  MOV     #B2A,W0
00B22:  ADD     W3,W3,W3
00B24:  ADD     W3,W0,W3
00B26:  TBLRDH  [W3],W0
00B28:  RETURN  
00B2A:  DATA    0D,0A,6F
00B2C:  DATA    20,63,6E
00B2E:  DATA    61,74,74
00B30:  DATA    20,66,65
00B32:  DATA    69,6C,6E
00B34:  DATA    65,6E,74
00B36:  DATA    61,6D,20
00B38:  DATA    65,20,6F
00B3A:  DATA    2D,2D,66
00B3C:  DATA    2D,20,20
00B3E:  DATA    44,69,66
00B40:  DATA    73,70,69
00B42:  DATA    6C,61,6C
00B44:  DATA    79,73,65
00B46:  DATA    20,63,00
00B48:  CLR     32
00B4A:  MOV     #2A,W3
00B4C:  SUB     W0,W3,W3
00B4E:  BRA     C,B5A
00B50:  MOV     #B64,W3
00B52:  ADD     W3,W0,W0
00B54:  TBLRDL.B[W0],W0L
00B56:  CLR.B   1
00B58:  RETURN  
00B5A:  MOV     #B64,W0
00B5C:  ADD     W3,W3,W3
00B5E:  ADD     W3,W0,W3
00B60:  TBLRDH  [W3],W0
00B62:  RETURN  
00B64:  DATA    0D,0A,63
00B66:  DATA    20,74,68
00B68:  DATA    61,69,61
00B6A:  DATA    6C,20,72
00B6C:  DATA    66,69,61
00B6E:  DATA    6C,65,63
00B70:  DATA    6E,61,74
00B72:  DATA    6D,65,65
00B74:  DATA    20,2D,72
00B76:  DATA    2D,2D,73
00B78:  DATA    20,44,20
00B7A:  DATA    69,73,6F
00B7C:  DATA    70,6C,66
00B7E:  DATA    61,79,20
00B80:  DATA    73,20,66
00B82:  DATA    74,68,69
00B84:  DATA    65,20,6C
00B86:  DATA    6C,61,65
00B88:  DATA    73,74,00
00B8A:  DATA    20,38,00
00B8C:  DATA    30,20,00
00B8E:  CLR     32
00B90:  MOV     #B9A,W3
00B92:  ADD     W3,W0,W0
00B94:  TBLRDL.B[W0],W0L
00B96:  CLR.B   1
00B98:  RETURN  
00B9A:  DATA    0D,0A,00
00B9C:  DATA    20,6D,00
00B9E:  DATA    6B,64,00
00BA0:  DATA    69,72,00
00BA2:  DATA    20,64,00
00BA4:  DATA    69,72,00
00BA6:  DATA    20,2D,00
00BA8:  DATA    2D,2D,00
00BAA:  DATA    20,43,00
00BAC:  DATA    72,65,00
00BAE:  DATA    61,74,00
00BB0:  DATA    65,20,00
00BB2:  DATA    61,20,00
00BB4:  DATA    64,69,00
00BB6:  DATA    72,65,00
00BB8:  DATA    63,74,00
00BBA:  DATA    6F,72,00
00BBC:  DATA    79,00,00
00BBE:  CLR     32
00BC0:  MOV     #BCA,W3
00BC2:  ADD     W3,W0,W0
00BC4:  TBLRDL.B[W0],W0L
00BC6:  CLR.B   1
00BC8:  RETURN  
00BCA:  DATA    0D,0A,00
00BCC:  DATA    20,72,00
00BCE:  DATA    6D,64,00
00BD0:  DATA    69,72,00
00BD2:  DATA    20,64,00
00BD4:  DATA    69,72,00
00BD6:  DATA    20,2D,00
00BD8:  DATA    2D,2D,00
00BDA:  DATA    20,44,00
00BDC:  DATA    65,6C,00
00BDE:  DATA    65,74,00
00BE0:  DATA    65,73,00
00BE2:  DATA    20,74,00
00BE4:  DATA    68,65,00
00BE6:  DATA    20,64,00
00BE8:  DATA    69,72,00
00BEA:  DATA    65,63,00
00BEC:  DATA    74,6F,00
00BEE:  DATA    72,79,00
00BF0:  DATA    00,00,00
00BF2:  CLR     32
00BF4:  MOV     #38,W3
00BF6:  SUB     W0,W3,W3
00BF8:  BRA     C,C04
00BFA:  MOV     #C0E,W3
00BFC:  ADD     W3,W0,W0
00BFE:  TBLRDL.B[W0],W0L
00C00:  CLR.B   1
00C02:  RETURN  
00C04:  MOV     #C0E,W0
00C06:  ADD     W3,W3,W3
00C08:  ADD     W3,W0,W3
00C0A:  TBLRDH  [W3],W0
00C0C:  RETURN  
00C0E:  DATA    0D,0A,30
00C10:  DATA    20,66,39
00C12:  DATA    6F,72,31
00C14:  DATA    6D,61,32
00C16:  DATA    74,20,27
00C18:  DATA    73,69,20
00C1A:  DATA    7A,65,2D
00C1C:  DATA    20,2D,6F
00C1E:  DATA    2D,2D,72
00C20:  DATA    20,46,2D
00C22:  DATA    6F,72,20
00C24:  DATA    6D,61,27
00C26:  DATA    74,20,66
00C28:  DATA    63,61,6F
00C2A:  DATA    72,64,72
00C2C:  DATA    2E,20,6D
00C2E:  DATA    20,28,61
00C30:  DATA    45,78,74
00C32:  DATA    61,6D,20
00C34:  DATA    70,6C,35
00C36:  DATA    65,3A,31
00C38:  DATA    20,27,32
00C3A:  DATA    66,6F,4D
00C3C:  DATA    72,6D,27
00C3E:  DATA    61,74,20
00C40:  DATA    20,35,00
00C42:  DATA    33,36,00
00C44:  DATA    38,37,00
00C46:  CLR     32
00C48:  MOV     #38,W3
00C4A:  SUB     W0,W3,W3
00C4C:  BRA     C,C58
00C4E:  MOV     #C62,W3
00C50:  ADD     W3,W0,W0
00C52:  TBLRDL.B[W0],W0L
00C54:  CLR.B   1
00C56:  RETURN  
00C58:  MOV     #C62,W0
00C5A:  ADD     W3,W3,W3
00C5C:  ADD     W3,W0,W3
00C5E:  TBLRDH  [W3],W0
00C60:  RETURN  
00C62:  DATA    0D,0A,6E
00C64:  DATA    20,20,64
00C66:  DATA    20,20,20
00C68:  DATA    20,20,50
00C6A:  DATA    20,20,61
00C6C:  DATA    20,20,72
00C6E:  DATA    20,20,74
00C70:  DATA    20,20,69
00C72:  DATA    20,20,74
00C74:  DATA    20,66,69
00C76:  DATA    6F,72,6F
00C78:  DATA    6D,61,6E
00C7A:  DATA    74,73,20
00C7C:  DATA    20,61,30
00C7E:  DATA    20,35,2E
00C80:  DATA    31,32,20
00C82:  DATA    4D,42,20
00C84:  DATA    20,63,54
00C86:  DATA    61,72,68
00C88:  DATA    64,29,69
00C8A:  DATA    2E,20,73
00C8C:  DATA    20,43,20
00C8E:  DATA    72,65,69
00C90:  DATA    61,74,73
00C92:  DATA    65,73,20
00C94:  DATA    20,4D,00
00C96:  DATA    42,52,00
00C98:  DATA    20,61,00
00C9A:  CLR     32
00C9C:  MOV     #34,W3
00C9E:  SUB     W0,W3,W3
00CA0:  BRA     C,CAC
00CA2:  MOV     #CB6,W3
00CA4:  ADD     W3,W0,W0
00CA6:  TBLRDL.B[W0],W0L
00CA8:  CLR.B   1
00CAA:  RETURN  
00CAC:  MOV     #CB6,W0
00CAE:  ADD     W3,W3,W3
00CB0:  ADD     W3,W0,W3
00CB2:  TBLRDH  [W3],W0
00CB4:  RETURN  
00CB6:  DATA    0D,0A,79
00CB8:  DATA    20,20,6F
00CBA:  DATA    20,20,75
00CBC:  DATA    20,20,20
00CBE:  DATA    20,20,63
00CC0:  DATA    20,20,61
00CC2:  DATA    20,20,6E
00CC4:  DATA    20,20,20
00CC6:  DATA    20,20,75
00CC8:  DATA    20,6E,73
00CCA:  DATA    6F,74,65
00CCC:  DATA    20,72,20
00CCE:  DATA    65,63,61
00CD0:  DATA    6F,6D,20
00CD2:  DATA    6D,65,63
00CD4:  DATA    6E,64,6F
00CD6:  DATA    65,64,6D
00CD8:  DATA    20,6F,70
00CDA:  DATA    6E,20,75
00CDC:  DATA    64,65,74
00CDE:  DATA    76,69,65
00CE0:  DATA    63,65,72
00CE2:  DATA    73,20,20
00CE4:  DATA    77,68,74
00CE6:  DATA    69,63,6F
00CE8:  DATA    68,20,00
00CEA:  CLR     32
00CEC:  MOV     #2C,W3
00CEE:  SUB     W0,W3,W3
00CF0:  BRA     C,CFC
00CF2:  MOV     #D06,W3
00CF4:  ADD     W3,W0,W0
00CF6:  TBLRDL.B[W0],W0L
00CF8:  CLR.B   1
00CFA:  RETURN  
00CFC:  MOV     #D06,W0
00CFE:  ADD     W3,W3,W3
00D00:  ADD     W3,W0,W3
00D02:  TBLRDH  [W3],W0
00D04:  RETURN  
00D06:  DATA    0D,0A,20
00D08:  DATA    20,20,61
00D0A:  DATA    20,20,6E
00D0C:  DATA    20,20,20
00D0E:  DATA    20,20,53
00D10:  DATA    20,20,44
00D12:  DATA    20,20,20
00D14:  DATA    20,20,6F
00D16:  DATA    20,20,72
00D18:  DATA    20,66,20
00D1A:  DATA    6F,72,43
00D1C:  DATA    6D,61,46
00D1E:  DATA    74,20,20
00D20:  DATA    74,68,64
00D22:  DATA    65,20,65
00D24:  DATA    64,72,76
00D26:  DATA    69,76,69
00D28:  DATA    65,20,63
00D2A:  DATA    28,73,65
00D2C:  DATA    75,63,29
00D2E:  DATA    68,20,2E
00D30:  DATA    61,73,00
00D32:  CLR     32
00D34:  MOV     #38,W3
00D36:  SUB     W0,W3,W3
00D38:  BRA     C,D44
00D3A:  MOV     #D4E,W3
00D3C:  ADD     W3,W0,W0
00D3E:  TBLRDL.B[W0],W0L
00D40:  CLR.B   1
00D42:  RETURN  
00D44:  MOV     #D4E,W0
00D46:  ADD     W3,W3,W3
00D48:  ADD     W3,W0,W3
00D4A:  TBLRDH  [W3],W0
00D4C:  RETURN  
00D4E:  DATA    0D,0A,20
00D50:  DATA    20,69,43
00D52:  DATA    6E,66,61
00D54:  DATA    6F,20,6E
00D56:  DATA    2D,2D,20
00D58:  DATA    2D,20,74
00D5A:  DATA    53,68,61
00D5C:  DATA    6F,77,6B
00D5E:  DATA    20,73,65
00D60:  DATA    6F,6D,20
00D62:  DATA    65,20,73
00D64:  DATA    69,6E,65
00D66:  DATA    66,6F,76
00D68:  DATA    20,61,65
00D6A:  DATA    62,6F,72
00D6C:  DATA    75,74,61
00D6E:  DATA    20,74,6C
00D70:  DATA    68,65,20
00D72:  DATA    20,6D,73
00D74:  DATA    65,64,65
00D76:  DATA    69,61,63
00D78:  DATA    2F,66,6F
00D7A:  DATA    69,6C,6E
00D7C:  DATA    65,20,64
00D7E:  DATA    73,79,73
00D80:  DATA    73,74,21
00D82:  DATA    65,6D,00
00D84:  DATA    2E,20,00
00D86:  CLR     32
00D88:  MOV     #D92,W3
00D8A:  ADD     W3,W0,W0
00D8C:  TBLRDL.B[W0],W0L
00D8E:  CLR.B   1
00D90:  RETURN  
00D92:  DATA    0D,0A,00
00D94:  DATA    20,68,00
00D96:  DATA    65,6C,00
00D98:  DATA    70,09,00
00D9A:  DATA    59,6F,00
00D9C:  DATA    75,20,00
00D9E:  DATA    61,72,00
00DA0:  DATA    65,20,00
00DA2:  DATA    68,65,00
00DA4:  DATA    72,65,00
00DA6:  DATA    00,00,00
00DA8:  CLR     32
00DAA:  MOV     #20,W3
00DAC:  SUB     W0,W3,W3
00DAE:  BRA     C,DBA
00DB0:  MOV     #DC4,W3
00DB2:  ADD     W3,W0,W0
00DB4:  TBLRDL.B[W0],W0L
00DB6:  CLR.B   1
00DB8:  RETURN  
00DBA:  MOV     #DC4,W0
00DBC:  ADD     W3,W3,W3
00DBE:  ADD     W3,W0,W3
00DC0:  TBLRDH  [W3],W0
00DC2:  RETURN  
00DC4:  DATA    0D,0A,20
00DC6:  DATA    0A,20,69
00DC8:  DATA    50,75,74
00DCA:  DATA    74,20,20
00DCC:  DATA    61,20,68
00DCE:  DATA    70,61,61
00DD0:  DATA    72,61,73
00DD2:  DATA    6D,65,20
00DD4:  DATA    74,65,73
00DD6:  DATA    72,20,70
00DD8:  DATA    69,6E,61
00DDA:  DATA    20,71,63
00DDC:  DATA    75,6F,65
00DDE:  DATA    74,65,73
00DE0:  DATA    73,20,00
00DE2:  DATA    69,66,00
00DE4:  CLR     32
00DE6:  MOV     #DF0,W3
00DE8:  ADD     W3,W0,W0
00DEA:  TBLRDL.B[W0],W0L
00DEC:  CLR.B   1
00DEE:  RETURN  
00DF0:  DATA    6D,6F,00
00DF2:  DATA    75,6E,00
00DF4:  DATA    74,00,00
00DF6:  CLR     32
00DF8:  MOV     #E02,W3
00DFA:  ADD     W3,W0,W0
00DFC:  TBLRDL.B[W0],W0L
00DFE:  CLR.B   1
00E00:  RETURN  
00E02:  DATA    61,70,00
00E04:  DATA    70,65,00
00E06:  DATA    6E,64,00
00E08:  DATA    20,6C,00
00E0A:  DATA    6F,67,00
00E0C:  DATA    2E,74,00
00E0E:  DATA    78,74,00
00E10:  DATA    20,62,00
00E12:  DATA    75,74,00
00E14:  DATA    74,6F,00
00E16:  DATA    6E,20,00
00E18:  DATA    70,72,00
00E1A:  DATA    65,73,00
00E1C:  DATA    73,65,00
00E1E:  DATA    64,21,00
00E20:  DATA    21,00,00
00E22:  CLR     32
00E24:  MOV     #E2E,W3
00E26:  ADD     W3,W0,W0
00E28:  TBLRDL.B[W0],W0L
00E2A:  CLR.B   1
00E2C:  RETURN  
00E2E:  DATA    74,65,00
00E30:  DATA    73,74,00
00E32:  DATA    66,69,00
00E34:  DATA    6C,65,00
00E36:  DATA    2E,74,00
00E38:  DATA    78,74,00
00E3A:  DATA    00,00,00
00E3C:  CLR     32
00E3E:  MOV     #E48,W3
00E40:  ADD     W3,W0,W0
00E42:  TBLRDL.B[W0],W0L
00E44:  CLR.B   1
00E46:  RETURN  
00E48:  DATA    48,65,00
00E4A:  DATA    6C,6C,00
00E4C:  DATA    6F,20,00
00E4E:  DATA    57,6F,00
00E50:  DATA    72,6C,00
00E52:  DATA    64,00,00
00E54:  CLR     32
00E56:  MOV     #28,W3
00E58:  SUB     W0,W3,W3
00E5A:  BRA     C,E66
00E5C:  MOV     #E70,W3
00E5E:  ADD     W3,W0,W0
00E60:  TBLRDL.B[W0],W0L
00E62:  CLR.B   1
00E64:  RETURN  
00E66:  MOV     #E70,W0
00E68:  ADD     W3,W3,W3
00E6A:  ADD     W3,W0,W3
00E6C:  TBLRDH  [W3],W0
00E6E:  RETURN  
00E70:  DATA    0D,0A,74
00E72:  DATA    55,6E,20
00E74:  DATA    6B,6E,6C
00E76:  DATA    6F,77,69
00E78:  DATA    6E,20,73
00E7A:  DATA    43,6F,74
00E7C:  DATA    6D,6D,20
00E7E:  DATA    61,6E,6F
00E80:  DATA    64,20,66
00E82:  DATA    27,25,20
00E84:  DATA    73,27,63
00E86:  DATA    2C,20,6F
00E88:  DATA    75,73,6D
00E8A:  DATA    65,20,6D
00E8C:  DATA    27,68,61
00E8E:  DATA    65,6C,6E
00E90:  DATA    70,27,64
00E92:  DATA    20,74,73
00E94:  DATA    6F,20,00
00E96:  DATA    67,65,00
*
010CE:  MOV     W5,[W15++]
010D0:  MOV     #C,W5
010D2:  REPEAT  #3
010D4:  MOV     [W5++],[W15++]
010D6:  MUL.UU  W0,W2,W4
010D8:  MUL.UU  W0,W3,W6
010DA:  BCLR.B  42.0
010DC:  ADD     W6,W5,W5
010DE:  ADDC    W7,#0,W8
010E0:  MUL.UU  W1,W2,W6
010E2:  ADDC    W6,W5,W5
010E4:  ADDC    W7,W8,W8
010E6:  MUL.UU  W1,W3,W6
010E8:  ADD     W6,W8,W8
010EA:  ADDC    #0,W7
010EC:  MOV     W7,W3
010EE:  MOV     W8,W2
010F0:  MOV     W5,W1
010F2:  MOV     W4,W0
010F4:  MOV     #12,W5
010F6:  REPEAT  #3
010F8:  MOV     [--W15],[W5--]
010FA:  MOV     [--W15],W5
010FC:  RETURN  
*
01AE6:  MOV     W5,[W15++]
01AE8:  MOV     #C,W5
01AEA:  REPEAT  #3
01AEC:  MOV     [W5++],[W15++]
01AEE:  MOV     #0,W9
01AF0:  BTSC.B  43.0
01AF2:  MOV     #1,W9
01AF4:  MOV     W9,[W15++]
01AF6:  CLR     W4
01AF8:  CLR     W5
01AFA:  CLR     W6
01AFC:  CLR     W7
01AFE:  XOR     W2,W3,W8
01B00:  BRA     Z,1B24
01B02:  MOV     #20,W8
01B04:  BCLR.B  42.0
01B06:  RLC     W0,W0
01B08:  RLC     W1,W1
01B0A:  RLC     W4,W4
01B0C:  RLC     W5,W5
01B0E:  CP      W5,W3
01B10:  BRA     NZ,1B14
01B12:  CPB     W4,W2
01B14:  BRA     NC,1B1C
01B16:  SUB     W4,W2,W4
01B18:  SUBB    W5,W3,W5
01B1A:  BSET.B  42.0
01B1C:  RLC     W6,W6
01B1E:  RLC     W7,W7
01B20:  DEC     W8,W8
01B22:  BRA     NZ,1B04
01B24:  MOV     W7,W1
01B26:  MOV     W6,W0
01B28:  MOV     [--W15],W9
01B2A:  CP0     W9
01B2C:  BRA     Z,1B30
01B2E:  MOV.D   W4,W0
01B30:  MOV     #12,W5
01B32:  REPEAT  #3
01B34:  MOV     [--W15],[W5--]
01B36:  MOV     [--W15],W5
01B38:  RETURN  
*
022CA:  MOV     W6,[W15++]
022CC:  MOV     W7,[W15++]
022CE:  MOV     W8,[W15++]
022D0:  MOV     W9,[W15++]
022D2:  CLR     W4
022D4:  CLR     W5
022D6:  CLR     W6
022D8:  CLR     W7
022DA:  XOR     W2,W3,W8
022DC:  BRA     Z,2300
022DE:  MOV     #20,W8
022E0:  BCLR.B  42.0
022E2:  RLC     W0,W0
022E4:  RLC     W1,W1
022E6:  RLC     W4,W4
022E8:  RLC     W5,W5
022EA:  CP      W5,W3
022EC:  BRA     NZ,22F0
022EE:  CPB     W4,W2
022F0:  BRA     NC,22F8
022F2:  SUB     W4,W2,W4
022F4:  SUBB    W5,W3,W5
022F6:  BSET.B  42.0
022F8:  RLC     W6,W6
022FA:  RLC     W7,W7
022FC:  DEC     W8,W8
022FE:  BRA     NZ,22E0
02300:  MOV     W7,W1
02302:  MOV     W6,W0
02304:  MOV     [--W15],W9
02306:  MOV     [--W15],W8
02308:  MOV     [--W15],W7
0230A:  MOV     [--W15],W6
0230C:  RETURN  
0230E:  MOV     W5,[W15++]
02310:  MOV     #C,W5
02312:  REPEAT  #7
02314:  MOV     [W5++],[W15++]
02316:  MOV     W0,W6
02318:  MOV     W1,W7
0231A:  MOV     W4,W12
0231C:  BCLR    W4.F
0231E:  CP0     W4
02320:  BRA     NZ,2326
02322:  MOV     #0,W5
02324:  BRA     2340
02326:  SUB.B   W4L,#B,W5L
02328:  BRA     NC,233E
0232A:  MOV     #30,W0
0232C:  BTSS    W12.F
0232E:  MOV     #20,W0
02330:  BTSC.B  223.1
02332:  BRA     2330
02334:  MOV     W0,224
02336:  DEC     W5,W5
02338:  BRA     NN,2330
0233A:  MOV     #A,W5
0233C:  BRA     2340
0233E:  MOV     W4,W5
02340:  MOV     #10,W8
02342:  MOV     #0,W9
02344:  LNK     #10
02346:  MOV     W12,[W14+W8]
02348:  DEC2    W8,W8
0234A:  BRA     NN,2346
0234C:  MOV     #A,W4
0234E:  BSET    W5.E
02350:  BTSC    W12.F
02352:  BSET    W5.F
02354:  MOV     W4,[W14]
02356:  MOV     W5,[W14+#2]
02358:  MOV     W6,W0
0235A:  MOV     W7,W1
0235C:  MOV     #CA00,W2
0235E:  MOV     #3B9A,W3
02360:  MOV     #2710,W8
02362:  BCLR    W13.F
02364:  BTG     W13.F
02366:  CALL    22CA
0236A:  BTSC    W13.F
0236C:  BRA     237C
0236E:  MOV     W0,[W14+#8]
02370:  MOV     W1,[W14+#A]
02372:  MOV     W0,W2
02374:  MOV     W1,W3
02376:  MOV     [W14+#4],W0
02378:  MOV     [W14+#6],W1
0237A:  BRA     2364
0237C:  MOV     W2,[W14+#8]
0237E:  MOV     W3,[W14+#A]
02380:  MOV     W4,[W14+#4]
02382:  MOV     W5,[W14+#6]
02384:  MOV     [W14],W4
02386:  MOV     [W14+#2],W5
02388:  MOV     #30,W6
0238A:  CP0     W0
0238C:  BRA     NZ,23B0
0238E:  BTSS    W5.E
02390:  BRA     23B4
02392:  DEC     W4,W4
02394:  MOV     W4,[W14]
02396:  CP0     W4
02398:  BRA     Z,23B4
0239A:  CP.B    W4L,W5L
0239C:  BTSC.B  42.0
0239E:  BRA     23BC
023A0:  MOV     #30,W6
023A2:  CP0     W0
023A4:  BRA     NZ,23B0
023A6:  BTSS    W5.E
023A8:  BRA     23B4
023AA:  BTSS    W5.F
023AC:  MOV     #20,W6
023AE:  BRA     23B4
023B0:  BCLR    W5.E
023B2:  MOV     W5,[W14+#2]
023B4:  ADD.B   W6L,W0L,W0L
023B6:  BTSC.B  223.1
023B8:  BRA     23B6
023BA:  MOV     W0,224
023BC:  MOV     [W14+#8],W0
023BE:  MOV     [W14+#A],W1
023C0:  MOV     #A,W2
023C2:  CLR     W3
023C4:  CP      W0,#1
023C6:  BRA     Z,23CA
023C8:  BRA     2364
023CA:  ULNK    
023CC:  MOV     #1A,W5
023CE:  REPEAT  #7
023D0:  MOV     [--W15],[W5--]
023D2:  MOV     [--W15],W5
023D4:  RETURN  
023D6:  MOV     W5,[W15++]
023D8:  MOV     #C,W5
023DA:  REPEAT  #3
023DC:  MOV     [W5++],[W15++]
023DE:  MOV     W0,W7
023E0:  MOV     W4,W9
023E2:  BCLR    W4.F
023E4:  CP0     W4
023E6:  BRA     NZ,23F4
023E8:  BTSC    W9.F
023EA:  BRA     23F0
023EC:  MOV     #0,W5
023EE:  BRA     240E
023F0:  MOV     #0,W5
023F2:  BRA     240E
023F4:  SUB.B   W4L,#6,W5L
023F6:  BRA     NC,240C
023F8:  MOV     #30,W0
023FA:  BTSS    W9.F
023FC:  MOV     #20,W0
023FE:  BTSC.B  223.1
02400:  BRA     23FE
02402:  MOV     W0,224
02404:  DEC     W5,W5
02406:  BRA     NN,23FE
02408:  MOV     #5,W5
0240A:  BRA     240E
0240C:  MOV     W4,W5
0240E:  MOV     #6,W4
02410:  BSET    W5.E
02412:  BTSC    W9.F
02414:  BSET    W5.F
02416:  MOV     #2710,W8
02418:  REPEAT  #11
0241A:  DIV.U   W7,W8
0241C:  CALL    2450
02420:  MOV     W1,W7
02422:  MOV     #3E8,W8
02424:  REPEAT  #11
02426:  DIV.U   W7,W8
02428:  CALL    2450
0242C:  MOV     W1,W7
0242E:  MOV     #64,W8
02430:  REPEAT  #11
02432:  DIV.U   W7,W8
02434:  CALL    2450
02438:  MOV     W1,W7
0243A:  MOV     #A,W8
0243C:  REPEAT  #11
0243E:  DIV.U   W7,W8
02440:  CALL    2450
02444:  MOV     #30,W0
02446:  ADD.B   W1L,W0L,W0L
02448:  BTSC.B  223.1
0244A:  BRA     2448
0244C:  MOV     W0,224
0244E:  BRA     247E
02450:  MOV     #30,W6
02452:  CP0     W0
02454:  BRA     NZ,2472
02456:  BTSS    W5.E
02458:  BRA     2474
0245A:  DEC     W4,W4
0245C:  CP.B    W4L,W5L
0245E:  BRA     Z,2464
02460:  BTSC.B  42.0
02462:  RETURN  
02464:  CP0     W0
02466:  BRA     NZ,2472
02468:  BTSS    W5.E
0246A:  BRA     2474
0246C:  BTSS    W5.F
0246E:  MOV     #20,W6
02470:  BRA     2474
02472:  BCLR    W5.E
02474:  ADD.B   W6L,W0L,W0L
02476:  BTSC.B  223.1
02478:  BRA     2476
0247A:  MOV     W0,224
0247C:  RETURN  
0247E:  MOV     #12,W5
02480:  REPEAT  #3
02482:  MOV     [--W15],[W5--]
02484:  MOV     [--W15],W5
02486:  RETURN  
*
02592:  MOV     W1,[W15++]
02594:  MOV     EA8,W1
02596:  MOV.B   W0L,[W1++]
02598:  CLR.B   [W1]
0259A:  MOV     [--W15],W1
0259C:  INC     0EA8
0259E:  RETURN  
*
045F6:  MOV     W5,[W15++]
045F8:  MOV     #C,W5
045FA:  REPEAT  #3
045FC:  MOV     [W5++],[W15++]
045FE:  MOV     #0,W9
04600:  BTSC.B  43.0
04602:  MOV     #1,W9
04604:  MOV     W9,[W15++]
04606:  XOR     W1,W3,W9
04608:  BTSS    W1.F
0460A:  BRA     4612
0460C:  COM     W1,W1
0460E:  NEG     W0,W0
04610:  ADDC    W1,#0,W1
04612:  BTSS    W3.F
04614:  BRA     461C
04616:  COM     W3,W3
04618:  NEG     W2,W2
0461A:  ADDC    W3,#0,W3
0461C:  XOR     W2,W3,W4
0461E:  BRA     Z,464A
04620:  CLR     W4
04622:  CLR     W5
04624:  CLR     W6
04626:  CLR     W7
04628:  MOV     #20,W8
0462A:  BCLR.B  42.0
0462C:  RLC     W0,W0
0462E:  RLC     W1,W1
04630:  RLC     W4,W4
04632:  RLC     W5,W5
04634:  CP      W5,W3
04636:  BRA     NZ,463A
04638:  CPB     W4,W2
0463A:  BRA     NC,4642
0463C:  SUB     W4,W2,W4
0463E:  SUBB    W5,W3,W5
04640:  BSET.B  42.0
04642:  RLC     W6,W6
04644:  RLC     W7,W7
04646:  DEC     W8,W8
04648:  BRA     NZ,462A
0464A:  BTSS    W9.F
0464C:  BRA     465C
0464E:  NEG     W6,W0
04650:  BRA     Z,4654
04652:  BRA     NZ,4658
04654:  NEG     W7,W1
04656:  BRA     4662
04658:  COM     W7,W1
0465A:  BRA     4662
0465C:  MOV     W7,W1
0465E:  MOV     W6,W0
04660:  BRA     4662
04662:  MOV     [--W15],W9
04664:  CP0     W9
04666:  BRA     Z,466A
04668:  MOV.D   W4,W0
0466A:  MOV     #12,W5
0466C:  REPEAT  #3
0466E:  MOV     [--W15],[W5--]
04670:  MOV     [--W15],W5
04672:  RETURN  
*
04E3C:  MOV     W0,W3
04E3E:  SWAP    W1
04E40:  MOV.B   #5,W4L
04E42:  DEC.B   0003
04E44:  DEC.B   0008
04E46:  BRA     Z,4E6E
04E48:  MOV     W3,W0
04E4A:  SL      W3,#4,W3
04E4C:  LSR     W0,#C,W0
04E4E:  AND     #F,W0
04E50:  BRA     NZ,4E5A
04E52:  CP.B    W4L,#1
04E54:  BRA     Z,4E5A
04E56:  BTSS.B  3.7
04E58:  BRA     4E42
04E5A:  ADD     #30,W0
04E5C:  MOV     #3A,W2
04E5E:  CP      W0,W2
04E60:  BRA     NC,4E64
04E62:  ADD.B   2,W0L
04E64:  BTSC.B  223.1
04E66:  BRA     4E64
04E68:  MOV     W0,224
04E6A:  BSET.B  3.7
04E6C:  BRA     4E42
04E6E:  RETURN  
....................  
.................... #list 
....................  
.................... #define PIC24 1 
.................... #device PASS_STRINGS = IN_RAM 
.................... #DEVICE ICD=2 
.................... #device ADC=10 
.................... #device PSV=16 
.................... #device CONST=READ_ONLY 
.................... #device PASS_STRINGS=IN_RAM 
.................... #use delay( crystal=8mhz, clock=32mhz ) 
....................  
....................  
....................    #pin_select U1TX = PIN_D5 
....................    #pin_select U1RX = PIN_D4 
.................... #use rs232(UART1, baud=9600, stream=STREAM_USER_UART) 
.................... // define this to make it compatible with the ex_boot_ldr.c bootloader. 
.................... // otherwise don't define this. 
.................... //#define __USE_MDD_BOOTLOADER__ 
.................... #define MEDIA_SOFT_DETECT    //This means it uses talking to the card to see if there is a card present 
.................... //#define __DEBUG_UART 
....................  
.................... #define ALLOW_GET_DISK_PROPERTIES   //used by 'info' command 
....................  
.................... #include "ex_mdd_common.h" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// 
.................... //// ex_mdd_common.h 
.................... //// 
.................... //// Common header file for CCS's MDD examples 
.................... //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //#define HW_CCS_3V_ETHERNET 
.................... //#define HW_CCS_DSP_AUDIO    //dsPIC33FJ 
.................... //#define HW_CCS_DSP_AUDIO2   //dsPIC33EP 
.................... #define HW_CCS_PIC24USB 
....................  
....................  
....................  
.................... #if defined(HW_CCS_PIC24USB) 
....................  //  #include <24FJ256GA106.h> 
....................  
.................... //   #fuses HS,PR_PLL,NOWDT,ICSP2,PLL5  did noy like 
.................... //   #fuses HS,PR_PLL,NOWDT,ICSP2 
....................    //C30/XC16 compiler to CCS PCH compiler compatability. 
....................    //also includes the filesystem. 
....................    //since this changes some #device settings, this needs to be include 
....................    //fairly soon in the build process. 
....................    #include "filesystem\filesystem.h"  
.................... //see about.txt in filesystem/ for information 
....................  
.................... #ifndef __FILESYSTEM_H__ 
.................... #define __FILESYSTEM_H__ 
....................  
.................... // If you cannot find these files, then change your include path 
.................... // to include the "CCSIncludes" directory.  This directory contains 
.................... // files that help port code from Microchip C to CCS C. 
.................... #if defined(__PCH__) 
....................    #include <p18cxxx.h> //Microchip C18 C Compiler to CCS PCH Conversion 
.................... #elif defined(__PCD__) 
....................    #define __CONST_IS_READONLY__ //work around for a difference between how CCS and C30 treats 'const' pointers 
....................    #include <..\OsmobotSDCard\CCSIncludes\PCDxxxx.h>  //Microchip C30 C Compiler to CCS PCH Conversion 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... // pcdxxxx.h 
.................... // 
.................... // Microchip C30 to CCS conversion library. 
....................  
.................... #ifndef __PCDXXXX_H__ 
.................... #define __PCDXXXX_H__ 
....................  
.................... #case 
....................  
.................... #include "ccspics.h" 
.................... //C18/C30 defines to CCS device h mapping 
....................  
.................... #ifndef __DEFINES_TO_CCS_H__ 
.................... #define __DEFINES_TO_CCS_H__ 
....................  
.................... #define __CCS__ 
....................  
.................... #if defined(__dsPIC14000__) || (getenv("DEVICE")=="DSPIC14000") 
....................     #if !defined(__dsPIC14000__) 
....................         #define __dsPIC14000__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <14000.h> 
....................     #endif 
....................     #if !defined(__dsPIC140000__) 
....................         #define __dsPIC140000__ 
....................     #endif 
....................     #include "14000_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C242) || (getenv("DEVICE")=="PIC18C242") 
....................     #if !defined(__18C242) 
....................         #define __18C242 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C242.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C242_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C252) || (getenv("DEVICE")=="PIC18C252") 
....................     #if !defined(__18C252) 
....................         #define __18C252 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C252.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C252_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C442) || (getenv("DEVICE")=="PIC18C442") 
....................     #if !defined(__18C442) 
....................         #define __18C442 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C442.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C442_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C452) || (getenv("DEVICE")=="PIC18C452") 
....................     #if !defined(__18C452) 
....................         #define __18C452 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C452.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C452_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C601) || (getenv("DEVICE")=="PIC18C601") 
....................     #if !defined(__18C601) 
....................         #define __18C601 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C601.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C601_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C658) || (getenv("DEVICE")=="PIC18C658") 
....................     #if !defined(__18C658) 
....................         #define __18C658 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C658.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C658_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C801) || (getenv("DEVICE")=="PIC18C801") 
....................     #if !defined(__18C801) 
....................         #define __18C801 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C801.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C801_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C858) || (getenv("DEVICE")=="PIC18C858") 
....................     #if !defined(__18C858) 
....................         #define __18C858 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C858.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C858_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F1220) || (getenv("DEVICE")=="PIC18F1220") 
....................     #if !defined(__18F1220) 
....................         #define __18F1220 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F1220.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F1220_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F1230) || (getenv("DEVICE")=="PIC18F1230") 
....................     #if !defined(__18F1230) 
....................         #define __18F1230 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F1230.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F1230_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F1320) || (getenv("DEVICE")=="PIC18F1320") 
....................     #if !defined(__18F1320) 
....................         #define __18F1320 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F1320.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F1320_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F1330) || (getenv("DEVICE")=="PIC18F1330") 
....................     #if !defined(__18F1330) 
....................         #define __18F1330 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F1330.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F1330_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F13K22) || (getenv("DEVICE")=="PIC18F13K22") 
....................     #if !defined(__18F13K22) 
....................         #define __18F13K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F13K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F13K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F13K50) || (getenv("DEVICE")=="PIC18F13K50") 
....................     #if !defined(__18F13K50) 
....................         #define __18F13K50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F13K50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F13K50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F14K22) || (getenv("DEVICE")=="PIC18F14K22") 
....................     #if !defined(__18F14K22) 
....................         #define __18F14K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F14K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F14K22_registers.h" 
.................... #endif 
....................  
.................... /* 
.................... #if defined(__18F14K50-ICD) || (getenv("DEVICE")=="PIC18F14K50-ICD") 
....................     #if !defined(__18F14K50-ICD) 
....................         #define __18F14K50-ICD 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F14K50-ICD.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F14K50-ICD_registers.h" 
.................... #endif 
.................... */ 
....................  
.................... #if defined(__18F14K50) || (getenv("DEVICE")=="PIC18F14K50") 
....................     #if !defined(__18F14K50) 
....................         #define __18F14K50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F14K50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F14K50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2220) || (getenv("DEVICE")=="PIC18F2220") 
....................     #if !defined(__18F2220) 
....................         #define __18F2220 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2220.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2220_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2221) || (getenv("DEVICE")=="PIC18F2221") 
....................     #if !defined(__18F2221) 
....................         #define __18F2221 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2221.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2221_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2320) || (getenv("DEVICE")=="PIC18F2320") 
....................     #if !defined(__18F2320) 
....................         #define __18F2320 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2320.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2320_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2321) || (getenv("DEVICE")=="PIC18F2321") 
....................     #if !defined(__18F2321) 
....................         #define __18F2321 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2321.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2321_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2331) || (getenv("DEVICE")=="PIC18F2331") 
....................     #if !defined(__18F2331) 
....................         #define __18F2331 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2331.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2331_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F23K20) || (getenv("DEVICE")=="PIC18F23K20") 
....................     #if !defined(__18F23K20) 
....................         #define __18F23K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F23K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F23K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F23K22) || (getenv("DEVICE")=="PIC18F23K22") 
....................     #if !defined(__18F23K22) 
....................         #define __18F23K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F23K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F23K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2410) || (getenv("DEVICE")=="PIC18F2410") 
....................     #if !defined(__18F2410) 
....................         #define __18F2410 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2410.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2410_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F242) || (getenv("DEVICE")=="PIC18F242") 
....................     #if !defined(__18F242) 
....................         #define __18F242 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F242.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F242_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2420) || (getenv("DEVICE")=="PIC18F2420") 
....................     #if !defined(__18F2420) 
....................         #define __18F2420 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2420.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2420_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2423) || (getenv("DEVICE")=="PIC18F2423") 
....................     #if !defined(__18F2423) 
....................         #define __18F2423 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2423.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2423_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2431) || (getenv("DEVICE")=="PIC18F2431") 
....................     #if !defined(__18F2431) 
....................         #define __18F2431 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2431.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2431_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2439) || (getenv("DEVICE")=="PIC18F2439") 
....................     #if !defined(__18F2439) 
....................         #define __18F2439 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2439.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2439_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2450) || (getenv("DEVICE")=="PIC18F2450") 
....................     #if !defined(__18F2450) 
....................         #define __18F2450 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2450.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2450_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2455) || (getenv("DEVICE")=="PIC18F2455") 
....................     #if !defined(__18F2455) 
....................         #define __18F2455 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2455.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2455_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2458) || (getenv("DEVICE")=="PIC18F2458") 
....................     #if !defined(__18F2458) 
....................         #define __18F2458 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2458.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2458_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F248) || (getenv("DEVICE")=="PIC18F248") 
....................     #if !defined(__18F248) 
....................         #define __18F248 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F248.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F248_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2480) || (getenv("DEVICE")=="PIC18F2480") 
....................     #if !defined(__18F2480) 
....................         #define __18F2480 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2480.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2480_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24J10) || (getenv("DEVICE")=="PIC18F24J10") 
....................     #if !defined(__18F24J10) 
....................         #define __18F24J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24J11) || (getenv("DEVICE")=="PIC18F24J11") 
....................     #if !defined(__18F24J11) 
....................         #define __18F24J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24J50) || (getenv("DEVICE")=="PIC18F24J50") 
....................     #if !defined(__18F24J50) 
....................         #define __18F24J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24K20) || (getenv("DEVICE")=="PIC18F24K20") 
....................     #if !defined(__18F24K20) 
....................         #define __18F24K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24K22) || (getenv("DEVICE")=="PIC18F24K22") 
....................     #if !defined(__18F24K22) 
....................         #define __18F24K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24K50) || (getenv("DEVICE")=="PIC18F24K50") 
....................     #if !defined(__18F24K50) 
....................         #define __18F24K50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24K50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24K50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2510) || (getenv("DEVICE")=="PIC18F2510") 
....................     #if !defined(__18F2510) 
....................         #define __18F2510 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2510.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2515) || (getenv("DEVICE")=="PIC18F2515") 
....................     #if !defined(__18F2515) 
....................         #define __18F2515 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2515.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2515_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F252) || (getenv("DEVICE")=="PIC18F252") 
....................     #if !defined(__18F252) 
....................         #define __18F252 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F252.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F252_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2520) || (getenv("DEVICE")=="PIC18F2520") 
....................     #if !defined(__18F2520) 
....................         #define __18F2520 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2520.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2520_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2523) || (getenv("DEVICE")=="PIC18F2523") 
....................     #if !defined(__18F2523) 
....................         #define __18F2523 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2523.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2523_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2525) || (getenv("DEVICE")=="PIC18F2525") 
....................     #if !defined(__18F2525) 
....................         #define __18F2525 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2525.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2525_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2539) || (getenv("DEVICE")=="PIC18F2539") 
....................     #if !defined(__18F2539) 
....................         #define __18F2539 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2539.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2539_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2550) || (getenv("DEVICE")=="PIC18F2550") 
....................     #if !defined(__18F2550) 
....................         #define __18F2550 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2550.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2550_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2553) || (getenv("DEVICE")=="PIC18F2553") 
....................     #if !defined(__18F2553) 
....................         #define __18F2553 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2553.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2553_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F258) || (getenv("DEVICE")=="PIC18F258") 
....................     #if !defined(__18F258) 
....................         #define __18F258 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F258.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F258_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2580) || (getenv("DEVICE")=="PIC18F2580") 
....................     #if !defined(__18F2580) 
....................         #define __18F2580 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2580.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2580_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2585) || (getenv("DEVICE")=="PIC18F2585") 
....................     #if !defined(__18F2585) 
....................         #define __18F2585 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2585.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2585_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25J10) || (getenv("DEVICE")=="PIC18F25J10") 
....................     #if !defined(__18F25J10) 
....................         #define __18F25J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25J11) || (getenv("DEVICE")=="PIC18F25J11") 
....................     #if !defined(__18F25J11) 
....................         #define __18F25J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25J50) || (getenv("DEVICE")=="PIC18F25J50") 
....................     #if !defined(__18F25J50) 
....................         #define __18F25J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25K20) || (getenv("DEVICE")=="PIC18F25K20") 
....................     #if !defined(__18F25K20) 
....................         #define __18F25K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25K22) || (getenv("DEVICE")=="PIC18F25K22") 
....................     #if !defined(__18F25K22) 
....................         #define __18F25K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25K50) || (getenv("DEVICE")=="PIC18F25K50") 
....................     #if !defined(__18F25K50) 
....................         #define __18F25K50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25K50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25K50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25K80) || (getenv("DEVICE")=="PIC18F25K80") 
....................     #if !defined(__18F25K80) 
....................         #define __18F25K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2610) || (getenv("DEVICE")=="PIC18F2610") 
....................     #if !defined(__18F2610) 
....................         #define __18F2610 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2610.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2610_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2620) || (getenv("DEVICE")=="PIC18F2620") 
....................     #if !defined(__18F2620) 
....................         #define __18F2620 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2620.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2680) || (getenv("DEVICE")=="PIC18F2680") 
....................     #if !defined(__18F2680) 
....................         #define __18F2680 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2680.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2680_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2682) || (getenv("DEVICE")=="PIC18F2682") 
....................     #if !defined(__18F2682) 
....................         #define __18F2682 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2682.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2682_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2685) || (getenv("DEVICE")=="PIC18F2685") 
....................     #if !defined(__18F2685) 
....................         #define __18F2685 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2685.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2685_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26J11) || (getenv("DEVICE")=="PIC18F26J11") 
....................     #if !defined(__18F26J11) 
....................         #define __18F26J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26J13) || (getenv("DEVICE")=="PIC18F26J13") 
....................     #if !defined(__18F26J13) 
....................         #define __18F26J13 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26J13.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26J13_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26J50) || (getenv("DEVICE")=="PIC18F26J50") 
....................     #if !defined(__18F26J50) 
....................         #define __18F26J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26J53) || (getenv("DEVICE")=="PIC18F26J53") 
....................     #if !defined(__18F26J53) 
....................         #define __18F26J53 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26J53.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26J53_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26K20) || (getenv("DEVICE")=="PIC18F26K20") 
....................     #if !defined(__18F26K20) 
....................         #define __18F26K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26K22) || (getenv("DEVICE")=="PIC18F26K22") 
....................     #if !defined(__18F26K22) 
....................         #define __18F26K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26K80) || (getenv("DEVICE")=="PIC18F26K80") 
....................     #if !defined(__18F26K80) 
....................         #define __18F26K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F27J13) || (getenv("DEVICE")=="PIC18F27J13") 
....................     #if !defined(__18F27J13) 
....................         #define __18F27J13 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F27J13.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F27J13_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F27J53) || (getenv("DEVICE")=="PIC18F27J53") 
....................     #if !defined(__18F27J53) 
....................         #define __18F27J53 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F27J53.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F27J53_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4220) || (getenv("DEVICE")=="PIC18F4220") 
....................     #if !defined(__18F4220) 
....................         #define __18F4220 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4220.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4220_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4221) || (getenv("DEVICE")=="PIC18F4221") 
....................     #if !defined(__18F4221) 
....................         #define __18F4221 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4221.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4221_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4320) || (getenv("DEVICE")=="PIC18F4320") 
....................     #if !defined(__18F4320) 
....................         #define __18F4320 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4320.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4320_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4321) || (getenv("DEVICE")=="PIC18F4321") 
....................     #if !defined(__18F4321) 
....................         #define __18F4321 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4321.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4321_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4331) || (getenv("DEVICE")=="PIC18F4331") 
....................     #if !defined(__18F4331) 
....................         #define __18F4331 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4331.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4331_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F43K20) || (getenv("DEVICE")=="PIC18F43K20") 
....................     #if !defined(__18F43K20) 
....................         #define __18F43K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F43K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F43K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F43K22) || (getenv("DEVICE")=="PIC18F43K22") 
....................     #if !defined(__18F43K22) 
....................         #define __18F43K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F43K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F43K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4410) || (getenv("DEVICE")=="PIC18F4410") 
....................     #if !defined(__18F4410) 
....................         #define __18F4410 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4410.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4410_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F442) || (getenv("DEVICE")=="PIC18F442") 
....................     #if !defined(__18F442) 
....................         #define __18F442 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F442.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F442_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4420) || (getenv("DEVICE")=="PIC18F4420") 
....................     #if !defined(__18F4420) 
....................         #define __18F4420 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4420.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4420_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4423) || (getenv("DEVICE")=="PIC18F4423") 
....................     #if !defined(__18F4423) 
....................         #define __18F4423 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4423.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4423_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4431) || (getenv("DEVICE")=="PIC18F4431") 
....................     #if !defined(__18F4431) 
....................         #define __18F4431 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4431.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4431_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4439) || (getenv("DEVICE")=="PIC18F4439") 
....................     #if !defined(__18F4439) 
....................         #define __18F4439 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4439.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4439_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4450) || (getenv("DEVICE")=="PIC18F4450") 
....................     #if !defined(__18F4450) 
....................         #define __18F4450 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4450.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4450_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4455) || (getenv("DEVICE")=="PIC18F4455") 
....................     #if !defined(__18F4455) 
....................         #define __18F4455 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4455.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4455_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4458) || (getenv("DEVICE")=="PIC18F4458") 
....................     #if !defined(__18F4458) 
....................         #define __18F4458 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4458.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4458_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F448) || (getenv("DEVICE")=="PIC18F448") 
....................     #if !defined(__18F448) 
....................         #define __18F448 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F448.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F448_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4480) || (getenv("DEVICE")=="PIC18F4480") 
....................     #if !defined(__18F4480) 
....................         #define __18F4480 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4480.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4480_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F44J10) || (getenv("DEVICE")=="PIC18F44J10") 
....................     #if !defined(__18F44J10) 
....................         #define __18F44J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F44J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F44J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F44J11) || (getenv("DEVICE")=="PIC18F44J11") 
....................     #if !defined(__18F44J11) 
....................         #define __18F44J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F44J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F44J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F44J50) || (getenv("DEVICE")=="PIC18F44J50") 
....................     #if !defined(__18F44J50) 
....................         #define __18F44J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F44J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F44J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F44K20) || (getenv("DEVICE")=="PIC18F44K20") 
....................     #if !defined(__18F44K20) 
....................         #define __18F44K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F44K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F44K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F44K22) || (getenv("DEVICE")=="PIC18F44K22") 
....................     #if !defined(__18F44K22) 
....................         #define __18F44K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F44K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F44K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4510) || (getenv("DEVICE")=="PIC18F4510") 
....................     #if !defined(__18F4510) 
....................         #define __18F4510 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4510.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4515) || (getenv("DEVICE")=="PIC18F4515") 
....................     #if !defined(__18F4515) 
....................         #define __18F4515 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4515.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4515_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F452) || (getenv("DEVICE")=="PIC18F452") 
....................     #if !defined(__18F452) 
....................         #define __18F452 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F452.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F452_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4520) || (getenv("DEVICE")=="PIC18F4520") 
....................     #if !defined(__18F4520) 
....................         #define __18F4520 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4520.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4520_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4523) || (getenv("DEVICE")=="PIC18F4523") 
....................     #if !defined(__18F4523) 
....................         #define __18F4523 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4523.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4523_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4525) || (getenv("DEVICE")=="PIC18F4525") 
....................     #if !defined(__18F4525) 
....................         #define __18F4525 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4525.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4525_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4539) || (getenv("DEVICE")=="PIC18F4539") 
....................     #if !defined(__18F4539) 
....................         #define __18F4539 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4539.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4539_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4550) || (getenv("DEVICE")=="PIC18F4550") 
....................     #if !defined(__18F4550) 
....................         #define __18F4550 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4550.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4550_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4553) || (getenv("DEVICE")=="PIC18F4553") 
....................     #if !defined(__18F4553) 
....................         #define __18F4553 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4553.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4553_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F458) || (getenv("DEVICE")=="PIC18F458") 
....................     #if !defined(__18F458) 
....................         #define __18F458 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F458.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F458_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4580) || (getenv("DEVICE")=="PIC18F4580") 
....................     #if !defined(__18F4580) 
....................         #define __18F4580 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4580.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4580_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4585) || (getenv("DEVICE")=="PIC18F4585") 
....................     #if !defined(__18F4585) 
....................         #define __18F4585 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4585.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4585_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45J10) || (getenv("DEVICE")=="PIC18F45J10") 
....................     #if !defined(__18F45J10) 
....................         #define __18F45J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45J11) || (getenv("DEVICE")=="PIC18F45J11") 
....................     #if !defined(__18F45J11) 
....................         #define __18F45J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45J50) || (getenv("DEVICE")=="PIC18F45J50") 
....................     #if !defined(__18F45J50) 
....................         #define __18F45J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45K20) || (getenv("DEVICE")=="PIC18F45K20") 
....................     #if !defined(__18F45K20) 
....................         #define __18F45K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45K22) || (getenv("DEVICE")=="PIC18F45K22") 
....................     #if !defined(__18F45K22) 
....................         #define __18F45K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45K50) || (getenv("DEVICE")=="PIC18F45K50") 
....................     #if !defined(__18F45K50) 
....................         #define __18F45K50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45K50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45K50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45K80) || (getenv("DEVICE")=="PIC18F45K80") 
....................     #if !defined(__18F45K80) 
....................         #define __18F45K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4610) || (getenv("DEVICE")=="PIC18F4610") 
....................     #if !defined(__18F4610) 
....................         #define __18F4610 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4610.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4610_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4620) || (getenv("DEVICE")=="PIC18F4620") 
....................     #if !defined(__18F4620) 
....................         #define __18F4620 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4620.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4680) || (getenv("DEVICE")=="PIC18F4680") 
....................     #if !defined(__18F4680) 
....................         #define __18F4680 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4680.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4680_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4682) || (getenv("DEVICE")=="PIC18F4682") 
....................     #if !defined(__18F4682) 
....................         #define __18F4682 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4682.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4682_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4685) || (getenv("DEVICE")=="PIC18F4685") 
....................     #if !defined(__18F4685) 
....................         #define __18F4685 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4685.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4685_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46J11) || (getenv("DEVICE")=="PIC18F46J11") 
....................     #if !defined(__18F46J11) 
....................         #define __18F46J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46J13) || (getenv("DEVICE")=="PIC18F46J13") 
....................     #if !defined(__18F46J13) 
....................         #define __18F46J13 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46J13.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46J13_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46J50) || (getenv("DEVICE")=="PIC18F46J50") 
....................     #if !defined(__18F46J50) 
....................         #define __18F46J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46J53) || (getenv("DEVICE")=="PIC18F46J53") 
....................     #if !defined(__18F46J53) 
....................         #define __18F46J53 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46J53.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46J53_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46K20) || (getenv("DEVICE")=="PIC18F46K20") 
....................     #if !defined(__18F46K20) 
....................         #define __18F46K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46K22) || (getenv("DEVICE")=="PIC18F46K22") 
....................     #if !defined(__18F46K22) 
....................         #define __18F46K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46K80) || (getenv("DEVICE")=="PIC18F46K80") 
....................     #if !defined(__18F46K80) 
....................         #define __18F46K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F47J13) || (getenv("DEVICE")=="PIC18F47J13") 
....................     #if !defined(__18F47J13) 
....................         #define __18F47J13 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F47J13.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F47J13_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F47J53) || (getenv("DEVICE")=="PIC18F47J53") 
....................     #if !defined(__18F47J53) 
....................         #define __18F47J53 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F47J53.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F47J53_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6310) || (getenv("DEVICE")=="PIC18F6310") 
....................     #if !defined(__18F6310) 
....................         #define __18F6310 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6310.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6390) || (getenv("DEVICE")=="PIC18F6390") 
....................     #if !defined(__18F6390) 
....................         #define __18F6390 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6390.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6390_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6393) || (getenv("DEVICE")=="PIC18F6393") 
....................     #if !defined(__18F6393) 
....................         #define __18F6393 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6393.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6393_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F63J11) || (getenv("DEVICE")=="PIC18F63J11") 
....................     #if !defined(__18F63J11) 
....................         #define __18F63J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F63J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F63J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F63J90) || (getenv("DEVICE")=="PIC18F63J90") 
....................     #if !defined(__18F63J90) 
....................         #define __18F63J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F63J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F63J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6410) || (getenv("DEVICE")=="PIC18F6410") 
....................     #if !defined(__18F6410) 
....................         #define __18F6410 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6410.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6410_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6490) || (getenv("DEVICE")=="PIC18F6490") 
....................     #if !defined(__18F6490) 
....................         #define __18F6490 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6490.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6490_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6493) || (getenv("DEVICE")=="PIC18F6493") 
....................     #if !defined(__18F6493) 
....................         #define __18F6493 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6493.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6493_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F64J11) || (getenv("DEVICE")=="PIC18F64J11") 
....................     #if !defined(__18F64J11) 
....................         #define __18F64J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F64J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F64J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F64J90) || (getenv("DEVICE")=="PIC18F64J90") 
....................     #if !defined(__18F64J90) 
....................         #define __18F64J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F64J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F64J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6520) || (getenv("DEVICE")=="PIC18F6520") 
....................     #if !defined(__18F6520) 
....................         #define __18F6520 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6520.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6520_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6525) || (getenv("DEVICE")=="PIC18F6525") 
....................     #if !defined(__18F6525) 
....................         #define __18F6525 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6525.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6525_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6527) || (getenv("DEVICE")=="PIC18F6527") 
....................     #if !defined(__18F6527) 
....................         #define __18F6527 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6527.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6527_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6585) || (getenv("DEVICE")=="PIC18F6585") 
....................     #if !defined(__18F6585) 
....................         #define __18F6585 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6585.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6585_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J10) || (getenv("DEVICE")=="PIC18F65J10") 
....................     #if !defined(__18F65J10) 
....................         #define __18F65J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J11) || (getenv("DEVICE")=="PIC18F65J11") 
....................     #if !defined(__18F65J11) 
....................         #define __18F65J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J15) || (getenv("DEVICE")=="PIC18F65J15") 
....................     #if !defined(__18F65J15) 
....................         #define __18F65J15 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J15.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J15_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J50) || (getenv("DEVICE")=="PIC18F65J50") 
....................     #if !defined(__18F65J50) 
....................         #define __18F65J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J90) || (getenv("DEVICE")=="PIC18F65J90") 
....................     #if !defined(__18F65J90) 
....................         #define __18F65J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J94) || (getenv("DEVICE")=="PIC18F65J94") 
....................     #if !defined(__18F65J94) 
....................         #define __18F65J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65K22) || (getenv("DEVICE")=="PIC18F65K22") 
....................     #if !defined(__18F65K22) 
....................         #define __18F65K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65K80) || (getenv("DEVICE")=="PIC18F65K80") 
....................     #if !defined(__18F65K80) 
....................         #define __18F65K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65K90) || (getenv("DEVICE")=="PIC18F65K90") 
....................     #if !defined(__18F65K90) 
....................         #define __18F65K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6620) || (getenv("DEVICE")=="PIC18F6620") 
....................     #if !defined(__18F6620) 
....................         #define __18F6620 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6620.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6621) || (getenv("DEVICE")=="PIC18F6621") 
....................     #if !defined(__18F6621) 
....................         #define __18F6621 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6621.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6621_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6622) || (getenv("DEVICE")=="PIC18F6622") 
....................     #if !defined(__18F6622) 
....................         #define __18F6622 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6622.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6622_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6627) || (getenv("DEVICE")=="PIC18F6627") 
....................     #if !defined(__18F6627) 
....................         #define __18F6627 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6627.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6627_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6628) || (getenv("DEVICE")=="PIC18F6628") 
....................     #if !defined(__18F6628) 
....................         #define __18F6628 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6628.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6628_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6680) || (getenv("DEVICE")=="PIC18F6680") 
....................     #if !defined(__18F6680) 
....................         #define __18F6680 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6680.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6680_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J10) || (getenv("DEVICE")=="PIC18F66J10") 
....................     #if !defined(__18F66J10) 
....................         #define __18F66J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J11) || (getenv("DEVICE")=="PIC18F66J11") 
....................     #if !defined(__18F66J11) 
....................         #define __18F66J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J15) || (getenv("DEVICE")=="PIC18F66J15") 
....................     #if !defined(__18F66J15) 
....................         #define __18F66J15 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J15.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J15_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J16) || (getenv("DEVICE")=="PIC18F66J16") 
....................     #if !defined(__18F66J16) 
....................         #define __18F66J16 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J16.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J16_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J50) || (getenv("DEVICE")=="PIC18F66J50") 
....................     #if !defined(__18F66J50) 
....................         #define __18F66J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J55) || (getenv("DEVICE")=="PIC18F66J55") 
....................     #if !defined(__18F66J55) 
....................         #define __18F66J55 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J55.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J55_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J60) || (getenv("DEVICE")=="PIC18F66J60") 
....................     #if !defined(__18F66J60) 
....................         #define __18F66J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J65) || (getenv("DEVICE")=="PIC18F66J65") 
....................     #if !defined(__18F66J65) 
....................         #define __18F66J65 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J65.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J65_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J90) || (getenv("DEVICE")=="PIC18F66J90") 
....................     #if !defined(__18F66J90) 
....................         #define __18F66J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J93) || (getenv("DEVICE")=="PIC18F66J93") 
....................     #if !defined(__18F66J93) 
....................         #define __18F66J93 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J93.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J93_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J94) || (getenv("DEVICE")=="PIC18F66J94") 
....................     #if !defined(__18F66J94) 
....................         #define __18F66J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J99) || (getenv("DEVICE")=="PIC18F66J99") 
....................     #if !defined(__18F66J99) 
....................         #define __18F66J99 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J99.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J99_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66K22) || (getenv("DEVICE")=="PIC18F66K22") 
....................     #if !defined(__18F66K22) 
....................         #define __18F66K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66K80) || (getenv("DEVICE")=="PIC18F66K80") 
....................     #if !defined(__18F66K80) 
....................         #define __18F66K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66K90) || (getenv("DEVICE")=="PIC18F66K90") 
....................     #if !defined(__18F66K90) 
....................         #define __18F66K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6720) || (getenv("DEVICE")=="PIC18F6720") 
....................     #if !defined(__18F6720) 
....................         #define __18F6720 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6720.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6720_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6722) || (getenv("DEVICE")=="PIC18F6722") 
....................     #if !defined(__18F6722) 
....................         #define __18F6722 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6722.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6722_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6723) || (getenv("DEVICE")=="PIC18F6723") 
....................     #if !defined(__18F6723) 
....................         #define __18F6723 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6723.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6723_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J10) || (getenv("DEVICE")=="PIC18F67J10") 
....................     #if !defined(__18F67J10) 
....................         #define __18F67J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J11) || (getenv("DEVICE")=="PIC18F67J11") 
....................     #if !defined(__18F67J11) 
....................         #define __18F67J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J50) || (getenv("DEVICE")=="PIC18F67J50") 
....................     #if !defined(__18F67J50) 
....................         #define __18F67J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J60) || (getenv("DEVICE")=="PIC18F67J60") 
....................     #if !defined(__18F67J60) 
....................         #define __18F67J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J90) || (getenv("DEVICE")=="PIC18F67J90") 
....................     #if !defined(__18F67J90) 
....................         #define __18F67J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J93) || (getenv("DEVICE")=="PIC18F67J93") 
....................     #if !defined(__18F67J93) 
....................         #define __18F67J93 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J93.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J93_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J94) || (getenv("DEVICE")=="PIC18F67J94") 
....................     #if !defined(__18F67J94) 
....................         #define __18F67J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67K22) || (getenv("DEVICE")=="PIC18F67K22") 
....................     #if !defined(__18F67K22) 
....................         #define __18F67K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67K90) || (getenv("DEVICE")=="PIC18F67K90") 
....................     #if !defined(__18F67K90) 
....................         #define __18F67K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8310) || (getenv("DEVICE")=="PIC18F8310") 
....................     #if !defined(__18F8310) 
....................         #define __18F8310 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8310.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8390) || (getenv("DEVICE")=="PIC18F8390") 
....................     #if !defined(__18F8390) 
....................         #define __18F8390 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8390.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8390_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8393) || (getenv("DEVICE")=="PIC18F8393") 
....................     #if !defined(__18F8393) 
....................         #define __18F8393 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8393.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8393_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F83J11) || (getenv("DEVICE")=="PIC18F83J11") 
....................     #if !defined(__18F83J11) 
....................         #define __18F83J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F83J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F83J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F83J90) || (getenv("DEVICE")=="PIC18F83J90") 
....................     #if !defined(__18F83J90) 
....................         #define __18F83J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F83J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F83J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8410) || (getenv("DEVICE")=="PIC18F8410") 
....................     #if !defined(__18F8410) 
....................         #define __18F8410 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8410.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8410_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8490) || (getenv("DEVICE")=="PIC18F8490") 
....................     #if !defined(__18F8490) 
....................         #define __18F8490 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8490.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8490_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8493) || (getenv("DEVICE")=="PIC18F8493") 
....................     #if !defined(__18F8493) 
....................         #define __18F8493 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8493.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8493_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F84J11) || (getenv("DEVICE")=="PIC18F84J11") 
....................     #if !defined(__18F84J11) 
....................         #define __18F84J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F84J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F84J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F84J90) || (getenv("DEVICE")=="PIC18F84J90") 
....................     #if !defined(__18F84J90) 
....................         #define __18F84J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F84J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F84J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8520) || (getenv("DEVICE")=="PIC18F8520") 
....................     #if !defined(__18F8520) 
....................         #define __18F8520 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8520.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8520_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8525) || (getenv("DEVICE")=="PIC18F8525") 
....................     #if !defined(__18F8525) 
....................         #define __18F8525 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8525.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8525_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8527) || (getenv("DEVICE")=="PIC18F8527") 
....................     #if !defined(__18F8527) 
....................         #define __18F8527 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8527.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8527_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8585) || (getenv("DEVICE")=="PIC18F8585") 
....................     #if !defined(__18F8585) 
....................         #define __18F8585 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8585.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8585_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J10) || (getenv("DEVICE")=="PIC18F85J10") 
....................     #if !defined(__18F85J10) 
....................         #define __18F85J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J11) || (getenv("DEVICE")=="PIC18F85J11") 
....................     #if !defined(__18F85J11) 
....................         #define __18F85J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J15) || (getenv("DEVICE")=="PIC18F85J15") 
....................     #if !defined(__18F85J15) 
....................         #define __18F85J15 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J15.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J15_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J50) || (getenv("DEVICE")=="PIC18F85J50") 
....................     #if !defined(__18F85J50) 
....................         #define __18F85J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J90) || (getenv("DEVICE")=="PIC18F85J90") 
....................     #if !defined(__18F85J90) 
....................         #define __18F85J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J94) || (getenv("DEVICE")=="PIC18F85J94") 
....................     #if !defined(__18F85J94) 
....................         #define __18F85J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85K22) || (getenv("DEVICE")=="PIC18F85K22") 
....................     #if !defined(__18F85K22) 
....................         #define __18F85K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85K90) || (getenv("DEVICE")=="PIC18F85K90") 
....................     #if !defined(__18F85K90) 
....................         #define __18F85K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8620) || (getenv("DEVICE")=="PIC18F8620") 
....................     #if !defined(__18F8620) 
....................         #define __18F8620 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8620.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8621) || (getenv("DEVICE")=="PIC18F8621") 
....................     #if !defined(__18F8621) 
....................         #define __18F8621 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8621.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8621_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8622) || (getenv("DEVICE")=="PIC18F8622") 
....................     #if !defined(__18F8622) 
....................         #define __18F8622 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8622.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8622_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8627) || (getenv("DEVICE")=="PIC18F8627") 
....................     #if !defined(__18F8627) 
....................         #define __18F8627 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8627.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8627_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8628) || (getenv("DEVICE")=="PIC18F8628") 
....................     #if !defined(__18F8628) 
....................         #define __18F8628 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8628.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8628_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8680) || (getenv("DEVICE")=="PIC18F8680") 
....................     #if !defined(__18F8680) 
....................         #define __18F8680 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8680.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8680_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J10) || (getenv("DEVICE")=="PIC18F86J10") 
....................     #if !defined(__18F86J10) 
....................         #define __18F86J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J11) || (getenv("DEVICE")=="PIC18F86J11") 
....................     #if !defined(__18F86J11) 
....................         #define __18F86J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J15) || (getenv("DEVICE")=="PIC18F86J15") 
....................     #if !defined(__18F86J15) 
....................         #define __18F86J15 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J15.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J15_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J16) || (getenv("DEVICE")=="PIC18F86J16") 
....................     #if !defined(__18F86J16) 
....................         #define __18F86J16 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J16.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J16_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J50) || (getenv("DEVICE")=="PIC18F86J50") 
....................     #if !defined(__18F86J50) 
....................         #define __18F86J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J55) || (getenv("DEVICE")=="PIC18F86J55") 
....................     #if !defined(__18F86J55) 
....................         #define __18F86J55 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J55.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J55_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J60) || (getenv("DEVICE")=="PIC18F86J60") 
....................     #if !defined(__18F86J60) 
....................         #define __18F86J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J65) || (getenv("DEVICE")=="PIC18F86J65") 
....................     #if !defined(__18F86J65) 
....................         #define __18F86J65 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J65.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J65_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J72) || (getenv("DEVICE")=="PIC18F86J72") 
....................     #if !defined(__18F86J72) 
....................         #define __18F86J72 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J72.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J72_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J90) || (getenv("DEVICE")=="PIC18F86J90") 
....................     #if !defined(__18F86J90) 
....................         #define __18F86J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J93) || (getenv("DEVICE")=="PIC18F86J93") 
....................     #if !defined(__18F86J93) 
....................         #define __18F86J93 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J93.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J93_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J94) || (getenv("DEVICE")=="PIC18F86J94") 
....................     #if !defined(__18F86J94) 
....................         #define __18F86J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J99) || (getenv("DEVICE")=="PIC18F86J99") 
....................     #if !defined(__18F86J99) 
....................         #define __18F86J99 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J99.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J99_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86K22) || (getenv("DEVICE")=="PIC18F86K22") 
....................     #if !defined(__18F86K22) 
....................         #define __18F86K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86K90) || (getenv("DEVICE")=="PIC18F86K90") 
....................     #if !defined(__18F86K90) 
....................         #define __18F86K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8720) || (getenv("DEVICE")=="PIC18F8720") 
....................     #if !defined(__18F8720) 
....................         #define __18F8720 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8720.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8720_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8722) || (getenv("DEVICE")=="PIC18F8722") 
....................     #if !defined(__18F8722) 
....................         #define __18F8722 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8722.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8722_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8723) || (getenv("DEVICE")=="PIC18F8723") 
....................     #if !defined(__18F8723) 
....................         #define __18F8723 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8723.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8723_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J10) || (getenv("DEVICE")=="PIC18F87J10") 
....................     #if !defined(__18F87J10) 
....................         #define __18F87J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J11) || (getenv("DEVICE")=="PIC18F87J11") 
....................     #if !defined(__18F87J11) 
....................         #define __18F87J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J50) || (getenv("DEVICE")=="PIC18F87J50") 
....................     #if !defined(__18F87J50) 
....................         #define __18F87J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J60) || (getenv("DEVICE")=="PIC18F87J60") 
....................     #if !defined(__18F87J60) 
....................         #define __18F87J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J72) || (getenv("DEVICE")=="PIC18F87J72") 
....................     #if !defined(__18F87J72) 
....................         #define __18F87J72 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J72.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J72_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J90) || (getenv("DEVICE")=="PIC18F87J90") 
....................     #if !defined(__18F87J90) 
....................         #define __18F87J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J93) || (getenv("DEVICE")=="PIC18F87J93") 
....................     #if !defined(__18F87J93) 
....................         #define __18F87J93 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J93.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J93_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J94) || (getenv("DEVICE")=="PIC18F87J94") 
....................     #if !defined(__18F87J94) 
....................         #define __18F87J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87K22) || (getenv("DEVICE")=="PIC18F87K22") 
....................     #if !defined(__18F87K22) 
....................         #define __18F87K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87K90) || (getenv("DEVICE")=="PIC18F87K90") 
....................     #if !defined(__18F87K90) 
....................         #define __18F87K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F95J94) || (getenv("DEVICE")=="PIC18F95J94") 
....................     #if !defined(__18F95J94) 
....................         #define __18F95J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F95J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F95J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F96J60) || (getenv("DEVICE")=="PIC18F96J60") 
....................     #if !defined(__18F96J60) 
....................         #define __18F96J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F96J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F96J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F96J65) || (getenv("DEVICE")=="PIC18F96J65") 
....................     #if !defined(__18F96J65) 
....................         #define __18F96J65 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F96J65.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F96J65_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F96J94) || (getenv("DEVICE")=="PIC18F96J94") 
....................     #if !defined(__18F96J94) 
....................         #define __18F96J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F96J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F96J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F96J99) || (getenv("DEVICE")=="PIC18F96J99") 
....................     #if !defined(__18F96J99) 
....................         #define __18F96J99 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F96J99.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F96J99_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || (getenv("DEVICE")=="PIC18F97J60") 
....................     #if !defined(__18F97J60) 
....................         #define __18F97J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F97J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F97J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F97J94) || (getenv("DEVICE")=="PIC18F97J94") 
....................     #if !defined(__18F97J94) 
....................         #define __18F97J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F97J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F97J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC19111__) || (getenv("DEVICE")=="DSPIC19111") 
....................     #if !defined(__dsPIC19111__) 
....................         #define __dsPIC19111__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <19111.h> 
....................     #endif 
....................     #if !defined(__dsPIC191111__) 
....................         #define __dsPIC191111__ 
....................     #endif 
....................     #include "19111_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128GP202__) || (getenv("DEVICE")=="PIC24EP128GP202") 
....................     #if !defined(__PIC24EP128GP202__) 
....................         #define __PIC24EP128GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128GP204__) || (getenv("DEVICE")=="PIC24EP128GP204") 
....................     #if !defined(__PIC24EP128GP204__) 
....................         #define __PIC24EP128GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128GP206__) || (getenv("DEVICE")=="PIC24EP128GP206") 
....................     #if !defined(__PIC24EP128GP206__) 
....................         #define __PIC24EP128GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128MC202__) || (getenv("DEVICE")=="PIC24EP128MC202") 
....................     #if !defined(__PIC24EP128MC202__) 
....................         #define __PIC24EP128MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128MC202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128MC204__) || (getenv("DEVICE")=="PIC24EP128MC204") 
....................     #if !defined(__PIC24EP128MC204__) 
....................         #define __PIC24EP128MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128MC204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128MC206__) || (getenv("DEVICE")=="PIC24EP128MC206") 
....................     #if !defined(__PIC24EP128MC206__) 
....................         #define __PIC24EP128MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128MC206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256GP202__) || (getenv("DEVICE")=="PIC24EP256GP202") 
....................     #if !defined(__PIC24EP256GP202__) 
....................         #define __PIC24EP256GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256GP204__) || (getenv("DEVICE")=="PIC24EP256GP204") 
....................     #if !defined(__PIC24EP256GP204__) 
....................         #define __PIC24EP256GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256GP206__) || (getenv("DEVICE")=="PIC24EP256GP206") 
....................     #if !defined(__PIC24EP256GP206__) 
....................         #define __PIC24EP256GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256GU810__) || (getenv("DEVICE")=="PIC24EP256GU810") 
....................     #if !defined(__PIC24EP256GU810__) 
....................         #define __PIC24EP256GU810__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256GU810.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256GU810_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256GU814__) || (getenv("DEVICE")=="PIC24EP256GU814") 
....................     #if !defined(__PIC24EP256GU814__) 
....................         #define __PIC24EP256GU814__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256GU814.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256GU814_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256MC202__) || (getenv("DEVICE")=="PIC24EP256MC202") 
....................     #if !defined(__PIC24EP256MC202__) 
....................         #define __PIC24EP256MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256MC202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256MC204__) || (getenv("DEVICE")=="PIC24EP256MC204") 
....................     #if !defined(__PIC24EP256MC204__) 
....................         #define __PIC24EP256MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256MC204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256MC206__) || (getenv("DEVICE")=="PIC24EP256MC206") 
....................     #if !defined(__PIC24EP256MC206__) 
....................         #define __PIC24EP256MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256MC206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32GP202__) || (getenv("DEVICE")=="PIC24EP32GP202") 
....................     #if !defined(__PIC24EP32GP202__) 
....................         #define __PIC24EP32GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32GP203__) || (getenv("DEVICE")=="PIC24EP32GP203") 
....................     #if !defined(__PIC24EP32GP203__) 
....................         #define __PIC24EP32GP203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32GP203.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32GP203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32GP204__) || (getenv("DEVICE")=="PIC24EP32GP204") 
....................     #if !defined(__PIC24EP32GP204__) 
....................         #define __PIC24EP32GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32MC202__) || (getenv("DEVICE")=="PIC24EP32MC202") 
....................     #if !defined(__PIC24EP32MC202__) 
....................         #define __PIC24EP32MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32MC202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32MC203__) || (getenv("DEVICE")=="PIC24EP32MC203") 
....................     #if !defined(__PIC24EP32MC203__) 
....................         #define __PIC24EP32MC203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32MC203.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32MC203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32MC204__) || (getenv("DEVICE")=="PIC24EP32MC204") 
....................     #if !defined(__PIC24EP32MC204__) 
....................         #define __PIC24EP32MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32MC204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP512GP806__) || (getenv("DEVICE")=="PIC24EP512GP806") 
....................     #if !defined(__PIC24EP512GP806__) 
....................         #define __PIC24EP512GP806__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP512GP806.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP512GP806_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP512GU810__) || (getenv("DEVICE")=="PIC24EP512GU810") 
....................     #if !defined(__PIC24EP512GU810__) 
....................         #define __PIC24EP512GU810__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP512GU810.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP512GU810_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP512GU814__) || (getenv("DEVICE")=="PIC24EP512GU814") 
....................     #if !defined(__PIC24EP512GU814__) 
....................         #define __PIC24EP512GU814__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP512GU814.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP512GU814_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64GP202__) || (getenv("DEVICE")=="PIC24EP64GP202") 
....................     #if !defined(__PIC24EP64GP202__) 
....................         #define __PIC24EP64GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64GP203__) || (getenv("DEVICE")=="PIC24EP64GP203") 
....................     #if !defined(__PIC24EP64GP203__) 
....................         #define __PIC24EP64GP203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64GP203.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64GP203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64GP204__) || (getenv("DEVICE")=="PIC24EP64GP204") 
....................     #if !defined(__PIC24EP64GP204__) 
....................         #define __PIC24EP64GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64GP206__) || (getenv("DEVICE")=="PIC24EP64GP206") 
....................     #if !defined(__PIC24EP64GP206__) 
....................         #define __PIC24EP64GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64MC202__) || (getenv("DEVICE")=="PIC24EP64MC202") 
....................     #if !defined(__PIC24EP64MC202__) 
....................         #define __PIC24EP64MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64MC202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64MC203__) || (getenv("DEVICE")=="PIC24EP64MC203") 
....................     #if !defined(__PIC24EP64MC203__) 
....................         #define __PIC24EP64MC203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64MC203.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64MC203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64MC204__) || (getenv("DEVICE")=="PIC24EP64MC204") 
....................     #if !defined(__PIC24EP64MC204__) 
....................         #define __PIC24EP64MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64MC204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64MC206__) || (getenv("DEVICE")=="PIC24EP64MC206") 
....................     #if !defined(__PIC24EP64MC206__) 
....................         #define __PIC24EP64MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64MC206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F04KA200__) || (getenv("DEVICE")=="PIC24F04KA200") 
....................     #if !defined(__PIC24F04KA200__) 
....................         #define __PIC24F04KA200__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F04KA200.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F04KA200_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F04KA201__) || (getenv("DEVICE")=="PIC24F04KA201") 
....................     #if !defined(__PIC24F04KA201__) 
....................         #define __PIC24F04KA201__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F04KA201.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F04KA201_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F04KL100__) || (getenv("DEVICE")=="PIC24F04KL100") 
....................     #if !defined(__PIC24F04KL100__) 
....................         #define __PIC24F04KL100__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F04KL100.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F04KL100_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F04KL101__) || (getenv("DEVICE")=="PIC24F04KL101") 
....................     #if !defined(__PIC24F04KL101__) 
....................         #define __PIC24F04KL101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F04KL101.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F04KL101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KA101__) || (getenv("DEVICE")=="PIC24F08KA101") 
....................     #if !defined(__PIC24F08KA101__) 
....................         #define __PIC24F08KA101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KA101.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F08KA101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KA102__) || (getenv("DEVICE")=="PIC24F08KA102") 
....................     #if !defined(__PIC24F08KA102__) 
....................         #define __PIC24F08KA102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KA102.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F08KA102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL200__) || (getenv("DEVICE")=="PIC24F08KL200") 
....................     #if !defined(__PIC24F08KL200__) 
....................         #define __PIC24F08KL200__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL200.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL200_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL201__) || (getenv("DEVICE")=="PIC24F08KL201") 
....................     #if !defined(__PIC24F08KL201__) 
....................         #define __PIC24F08KL201__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL201.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL201_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL301__) || (getenv("DEVICE")=="PIC24F08KL301") 
....................     #if !defined(__PIC24F08KL301__) 
....................         #define __PIC24F08KL301__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL301.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL301_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL302__) || (getenv("DEVICE")=="PIC24F08KL302") 
....................     #if !defined(__PIC24F08KL302__) 
....................         #define __PIC24F08KL302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL302.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL401__) || (getenv("DEVICE")=="PIC24F08KL401") 
....................     #if !defined(__PIC24F08KL401__) 
....................         #define __PIC24F08KL401__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL401.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL401_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL402__) || (getenv("DEVICE")=="PIC24F08KL402") 
....................     #if !defined(__PIC24F08KL402__) 
....................         #define __PIC24F08KL402__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL402.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL402_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KM101__) || (getenv("DEVICE")=="PIC24F08KM101") 
....................     #if !defined(__PIC24F08KM101__) 
....................         #define __PIC24F08KM101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KM101.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KM101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KM102__) || (getenv("DEVICE")=="PIC24F08KM102") 
....................     #if !defined(__PIC24F08KM102__) 
....................         #define __PIC24F08KM102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KM102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KM102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KM202__) || (getenv("DEVICE")=="PIC24F08KM202") 
....................     #if !defined(__PIC24F08KM202__) 
....................         #define __PIC24F08KM202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KM202.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KM202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KM204__) || (getenv("DEVICE")=="PIC24F08KM204") 
....................     #if !defined(__PIC24F08KM204__) 
....................         #define __PIC24F08KM204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KM204.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KM204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KA101__) || (getenv("DEVICE")=="PIC24F16KA101") 
....................     #if !defined(__PIC24F16KA101__) 
....................         #define __PIC24F16KA101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KA101.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F16KA101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KA102__) || (getenv("DEVICE")=="PIC24F16KA102") 
....................     #if !defined(__PIC24F16KA102__) 
....................         #define __PIC24F16KA102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KA102.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F16KA102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KA301__) || (getenv("DEVICE")=="PIC24F16KA301") 
....................     #if !defined(__PIC24F16KA301__) 
....................         #define __PIC24F16KA301__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KA301.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F16KA301_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KA302__) || (getenv("DEVICE")=="PIC24F16KA302") 
....................     #if !defined(__PIC24F16KA302__) 
....................         #define __PIC24F16KA302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KA302.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F16KA302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KA304__) || (getenv("DEVICE")=="PIC24F16KA304") 
....................     #if !defined(__PIC24F16KA304__) 
....................         #define __PIC24F16KA304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KA304.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F16KA304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KL401__) || (getenv("DEVICE")=="PIC24F16KL401") 
....................     #if !defined(__PIC24F16KL401__) 
....................         #define __PIC24F16KL401__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KL401.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KL401_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KL402__) || (getenv("DEVICE")=="PIC24F16KL402") 
....................     #if !defined(__PIC24F16KL402__) 
....................         #define __PIC24F16KL402__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KL402.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KL402_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KM102__) || (getenv("DEVICE")=="PIC24F16KM102") 
....................     #if !defined(__PIC24F16KM102__) 
....................         #define __PIC24F16KM102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KM102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KM102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KM104__) || (getenv("DEVICE")=="PIC24F16KM104") 
....................     #if !defined(__PIC24F16KM104__) 
....................         #define __PIC24F16KM104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KM104.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KM104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KM202__) || (getenv("DEVICE")=="PIC24F16KM202") 
....................     #if !defined(__PIC24F16KM202__) 
....................         #define __PIC24F16KM202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KM202.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KM202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KM204__) || (getenv("DEVICE")=="PIC24F16KM204") 
....................     #if !defined(__PIC24F16KM204__) 
....................         #define __PIC24F16KM204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KM204.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KM204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F32KA301__) || (getenv("DEVICE")=="PIC24F32KA301") 
....................     #if !defined(__PIC24F32KA301__) 
....................         #define __PIC24F32KA301__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F32KA301.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F32KA301_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F32KA302__) || (getenv("DEVICE")=="PIC24F32KA302") 
....................     #if !defined(__PIC24F32KA302__) 
....................         #define __PIC24F32KA302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F32KA302.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F32KA302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F32KA304__) || (getenv("DEVICE")=="PIC24F32KA304") 
....................     #if !defined(__PIC24F32KA304__) 
....................         #define __PIC24F32KA304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F32KA304.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F32KA304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128DA106__) || (getenv("DEVICE")=="PIC24FJ128DA106") 
....................     #if !defined(__PIC24FJ128DA106__) 
....................         #define __PIC24FJ128DA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128DA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128DA106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128DA110__) || (getenv("DEVICE")=="PIC24FJ128DA110") 
....................     #if !defined(__PIC24FJ128DA110__) 
....................         #define __PIC24FJ128DA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128DA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128DA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128DA206__) || (getenv("DEVICE")=="PIC24FJ128DA206") 
....................     #if !defined(__PIC24FJ128DA206__) 
....................         #define __PIC24FJ128DA206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128DA206.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128DA206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128DA210__) || (getenv("DEVICE")=="PIC24FJ128DA210") 
....................     #if !defined(__PIC24FJ128DA210__) 
....................         #define __PIC24FJ128DA210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128DA210.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128DA210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA006__) || (getenv("DEVICE")=="PIC24FJ128GA006") 
....................     #if !defined(__PIC24FJ128GA006__) 
....................         #define __PIC24FJ128GA006__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA006.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA006_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA008__) || (getenv("DEVICE")=="PIC24FJ128GA008") 
....................     #if !defined(__PIC24FJ128GA008__) 
....................         #define __PIC24FJ128GA008__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA008.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA008_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA010__) || (getenv("DEVICE")=="PIC24FJ128GA010") 
....................     #if !defined(__PIC24FJ128GA010__) 
....................         #define __PIC24FJ128GA010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA010.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA106__) || (getenv("DEVICE")=="PIC24FJ128GA106") 
....................     #if !defined(__PIC24FJ128GA106__) 
....................         #define __PIC24FJ128GA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA108__) || (getenv("DEVICE")=="PIC24FJ128GA108") 
....................     #if !defined(__PIC24FJ128GA108__) 
....................         #define __PIC24FJ128GA108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA110__) || (getenv("DEVICE")=="PIC24FJ128GA110") 
....................     #if !defined(__PIC24FJ128GA110__) 
....................         #define __PIC24FJ128GA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA306__) || (getenv("DEVICE")=="PIC24FJ128GA306") 
....................     #if !defined(__PIC24FJ128GA306__) 
....................         #define __PIC24FJ128GA306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA306.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA308__) || (getenv("DEVICE")=="PIC24FJ128GA308") 
....................     #if !defined(__PIC24FJ128GA308__) 
....................         #define __PIC24FJ128GA308__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA308.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA308_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA310__) || (getenv("DEVICE")=="PIC24FJ128GA310") 
....................     #if !defined(__PIC24FJ128GA310__) 
....................         #define __PIC24FJ128GA310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA310.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GB106__) || (getenv("DEVICE")=="PIC24FJ128GB106") 
....................     #if !defined(__PIC24FJ128GB106__) 
....................         #define __PIC24FJ128GB106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GB106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GB106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GB108__) || (getenv("DEVICE")=="PIC24FJ128GB108") 
....................     #if !defined(__PIC24FJ128GB108__) 
....................         #define __PIC24FJ128GB108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GB108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GB108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GB110__) || (getenv("DEVICE")=="PIC24FJ128GB110") 
....................     #if !defined(__PIC24FJ128GB110__) 
....................         #define __PIC24FJ128GB110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GB110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GB110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GB206__) || (getenv("DEVICE")=="PIC24FJ128GB206") 
....................     #if !defined(__PIC24FJ128GB206__) 
....................         #define __PIC24FJ128GB206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GB206.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GB206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GB210__) || (getenv("DEVICE")=="PIC24FJ128GB210") 
....................     #if !defined(__PIC24FJ128GB210__) 
....................         #define __PIC24FJ128GB210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GB210.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GB210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ16GA002__) || (getenv("DEVICE")=="PIC24FJ16GA002") 
....................     #if !defined(__PIC24FJ16GA002__) 
....................         #define __PIC24FJ16GA002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ16GA002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ16GA002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ16GA004__) || (getenv("DEVICE")=="PIC24FJ16GA004") 
....................     #if !defined(__PIC24FJ16GA004__) 
....................         #define __PIC24FJ16GA004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ16GA004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ16GA004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ16MC101__) || (getenv("DEVICE")=="PIC24FJ16MC101") 
....................     #if !defined(__PIC24FJ16MC101__) 
....................         #define __PIC24FJ16MC101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ16MC101.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ16MC101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ16MC102__) || (getenv("DEVICE")=="PIC24FJ16MC102") 
....................     #if !defined(__PIC24FJ16MC102__) 
....................         #define __PIC24FJ16MC102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ16MC102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ16MC102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GA106__) || (getenv("DEVICE")=="PIC24FJ192GA106") 
....................     #if !defined(__PIC24FJ192GA106__) 
....................         #define __PIC24FJ192GA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GA106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GA108__) || (getenv("DEVICE")=="PIC24FJ192GA108") 
....................     #if !defined(__PIC24FJ192GA108__) 
....................         #define __PIC24FJ192GA108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GA108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GA108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GA110__) || (getenv("DEVICE")=="PIC24FJ192GA110") 
....................     #if !defined(__PIC24FJ192GA110__) 
....................         #define __PIC24FJ192GA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GB106__) || (getenv("DEVICE")=="PIC24FJ192GB106") 
....................     #if !defined(__PIC24FJ192GB106__) 
....................         #define __PIC24FJ192GB106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GB106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GB106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GB108__) || (getenv("DEVICE")=="PIC24FJ192GB108") 
....................     #if !defined(__PIC24FJ192GB108__) 
....................         #define __PIC24FJ192GB108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GB108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GB108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GB110__) || (getenv("DEVICE")=="PIC24FJ192GB110") 
....................     #if !defined(__PIC24FJ192GB110__) 
....................         #define __PIC24FJ192GB110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GB110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GB110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256DA106__) || (getenv("DEVICE")=="PIC24FJ256DA106") 
....................     #if !defined(__PIC24FJ256DA106__) 
....................         #define __PIC24FJ256DA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256DA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256DA106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256DA110__) || (getenv("DEVICE")=="PIC24FJ256DA110") 
....................     #if !defined(__PIC24FJ256DA110__) 
....................         #define __PIC24FJ256DA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256DA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256DA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256DA206__) || (getenv("DEVICE")=="PIC24FJ256DA206") 
....................     #if !defined(__PIC24FJ256DA206__) 
....................         #define __PIC24FJ256DA206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256DA206.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256DA206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256DA210__) || (getenv("DEVICE")=="PIC24FJ256DA210") 
....................     #if !defined(__PIC24FJ256DA210__) 
....................         #define __PIC24FJ256DA210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256DA210.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256DA210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GA106__) || (getenv("DEVICE")=="PIC24FJ256GA106") 
....................     #if !defined(__PIC24FJ256GA106__) 
....................         #define __PIC24FJ256GA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GA106_registers.h" 
.................... #word WREG0 = 0x000 
....................  
.................... #word WREG1 = 0x002 
....................  
.................... #word WREG2 = 0x004 
....................  
.................... #word WREG3 = 0x006 
....................  
.................... #word WREG4 = 0x008 
....................  
.................... #word WREG5 = 0x00A 
....................  
.................... #word WREG6 = 0x00C 
....................  
.................... #word WREG7 = 0x00E 
....................  
.................... #word WREG8 = 0x010 
....................  
.................... #word WREG9 = 0x012 
....................  
.................... #word WREG10 = 0x014 
....................  
.................... #word WREG11 = 0x016 
....................  
.................... #word WREG12 = 0x018 
....................  
.................... #word WREG13 = 0x01A 
....................  
.................... #word WREG14 = 0x01C 
....................  
.................... #word WREG15 = 0x01E 
....................  
.................... #word SPLIM = 0x020 
....................  
.................... #word PC = 0x02E 
....................  
.................... #word DSRPAG = 0x032 
....................  
.................... #word DSWPAG = 0x034 
....................  
.................... #word RCOUNT = 0x036 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int C:1; 
....................          unsigned int Z:1; 
....................          unsigned int OV:1; 
....................          unsigned int N:1; 
....................          unsigned int RA:1; 
....................          unsigned int IPL0:3; 
....................          unsigned int DC:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int IPL:3; 
....................       }; 
.................... } SRBITS; 
.................... SRBITS SRbits; 
.................... #word SRbits = 0x042 
.................... #word SR = 0x042 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :2; 
....................    unsigned int RES:1; 
....................    unsigned int IPL3:1; 
.................... } CORCONBITS; 
.................... CORCONBITS CORCONbits; 
.................... #word CORCONbits = 0x044 
.................... #word CORCON = 0x044 
....................  
.................... #word DISICNT = 0x052 
....................  
.................... #word TBLPAG = 0x054 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN0PDE:1; 
....................    unsigned int CN1PDE:1; 
....................    unsigned int CN2PDE:1; 
....................    unsigned int CN3PDE:1; 
....................    unsigned int CN4PDE:1; 
....................    unsigned int CN5PDE:1; 
....................    unsigned int CN6PDE:1; 
....................    unsigned int CN7PDE:1; 
....................    unsigned int CN8PDE:1; 
....................    unsigned int CN9PDE:1; 
....................    unsigned int CN10PDE:1; 
....................    unsigned int CN11PDE:1; 
....................    unsigned int CN12PDE:1; 
....................    unsigned int CN13PDE:1; 
....................    unsigned int CN14PDE:1; 
....................    unsigned int CN15PDE:1; 
.................... } CNPD1BITS; 
.................... CNPD1BITS CNPD1bits; 
.................... #word CNPD1bits = 0x056 
.................... #word CNPD1 = 0x056 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN16PDE:1; 
....................    unsigned int CN17PDE:1; 
....................    unsigned int CN18PDE:1; 
....................    unsigned int :3; 
....................    unsigned int CN22PDE:1; 
....................    unsigned int CN23PDE:1; 
....................    unsigned int CN24PDE:1; 
....................    unsigned int CN25PDE:1; 
....................    unsigned int CN26PDE:1; 
....................    unsigned int CN27PDE:1; 
....................    unsigned int CN28PDE:1; 
....................    unsigned int CN29PDE:1; 
....................    unsigned int CN30PDE:1; 
....................    unsigned int CN31PDE:1; 
.................... } CNPD2BITS; 
.................... CNPD2BITS CNPD2bits; 
.................... #word CNPD2bits = 0x058 
.................... #word CNPD2 = 0x058 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN32PDE:1; 
.................... } CNPD3BITS; 
.................... CNPD3BITS CNPD3bits; 
.................... #word CNPD3bits = 0x05A 
.................... #word CNPD3 = 0x05A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int CN49PDE:1; 
....................    unsigned int CN50PDE:1; 
....................    unsigned int CN51PDE:1; 
....................    unsigned int CN52PDE:1; 
....................    unsigned int CN53PDE:1; 
....................    unsigned int CN54PDE:1; 
....................    unsigned int CN55PDE:1; 
....................    unsigned int CN56PDE:1; 
....................    unsigned int :1; 
....................    unsigned int CN58PDE:1; 
....................    unsigned int CN59PDE:1; 
....................    unsigned int CN60PDE:1; 
....................    unsigned int CN61PDE:1; 
....................    unsigned int CN62PDE:1; 
....................    unsigned int CN63PDE:1; 
.................... } CNPD4BITS; 
.................... CNPD4BITS CNPD4bits; 
.................... #word CNPD4bits = 0x05C 
.................... #word CNPD4 = 0x05C 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN64PDE:1; 
....................    unsigned int CN65PDE:1; 
....................    unsigned int :2; 
....................    unsigned int CN68PDE:1; 
....................    unsigned int CN69PDE:1; 
....................    unsigned int :1; 
....................    unsigned int CN71PDE:1; 
.................... } CNPD5BITS; 
.................... CNPD5BITS CNPD5bits; 
.................... #word CNPD5bits = 0x05E 
.................... #word CNPD5 = 0x05E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :3; 
....................    unsigned int CN83PDE:1; 
....................    unsigned int CN84PDE:1; 
.................... } CNPD6BITS; 
.................... CNPD6BITS CNPD6bits; 
.................... #word CNPD6bits = 0x060 
.................... #word CNPD6 = 0x060 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN0IE:1; 
....................    unsigned int CN1IE:1; 
....................    unsigned int CN2IE:1; 
....................    unsigned int CN3IE:1; 
....................    unsigned int CN4IE:1; 
....................    unsigned int CN5IE:1; 
....................    unsigned int CN6IE:1; 
....................    unsigned int CN7IE:1; 
....................    unsigned int CN8IE:1; 
....................    unsigned int CN9IE:1; 
....................    unsigned int CN10IE:1; 
....................    unsigned int CN11IE:1; 
....................    unsigned int CN12IE:1; 
....................    unsigned int CN13IE:1; 
....................    unsigned int CN14IE:1; 
....................    unsigned int CN15IE:1; 
.................... } CNEN1BITS; 
.................... CNEN1BITS CNEN1bits; 
.................... #word CNEN1bits = 0x062 
.................... #word CNEN1 = 0x062 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN16IE:1; 
....................    unsigned int CN17IE:1; 
....................    unsigned int CN18IE:1; 
....................    unsigned int :3; 
....................    unsigned int CN22IE:1; 
....................    unsigned int CN23IE:1; 
....................    unsigned int CN24IE:1; 
....................    unsigned int CN25IE:1; 
....................    unsigned int CN26IE:1; 
....................    unsigned int CN27IE:1; 
....................    unsigned int CN28IE:1; 
....................    unsigned int CN29IE:1; 
....................    unsigned int CN30IE:1; 
....................    unsigned int CN31IE:1; 
.................... } CNEN2BITS; 
.................... CNEN2BITS CNEN2bits; 
.................... #word CNEN2bits = 0x064 
.................... #word CNEN2 = 0x064 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN32IE:1; 
.................... } CNEN3BITS; 
.................... CNEN3BITS CNEN3bits; 
.................... #word CNEN3bits = 0x066 
.................... #word CNEN3 = 0x066 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int CN49IE:1; 
....................    unsigned int CN50IE:1; 
....................    unsigned int CN51IE:1; 
....................    unsigned int CN52IE:1; 
....................    unsigned int CN53IE:1; 
....................    unsigned int CN54IE:1; 
....................    unsigned int CN55IE:1; 
....................    unsigned int CN56IE:1; 
....................    unsigned int :1; 
....................    unsigned int CN58IE:1; 
....................    unsigned int CN59IE:1; 
....................    unsigned int CN60IE:1; 
....................    unsigned int CN61IE:1; 
....................    unsigned int CN62IE:1; 
....................    unsigned int CN63IE:1; 
.................... } CNEN4BITS; 
.................... CNEN4BITS CNEN4bits; 
.................... #word CNEN4bits = 0x068 
.................... #word CNEN4 = 0x068 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN64IE:1; 
....................    unsigned int CN65IE:1; 
....................    unsigned int :2; 
....................    unsigned int CN68IE:1; 
....................    unsigned int CN69IE:1; 
....................    unsigned int :1; 
....................    unsigned int CN71IE:1; 
.................... } CNEN5BITS; 
.................... CNEN5BITS CNEN5bits; 
.................... #word CNEN5bits = 0x06A 
.................... #word CNEN5 = 0x06A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :3; 
....................    unsigned int CN83IE:1; 
....................    unsigned int CN84IE:1; 
.................... } CNEN6BITS; 
.................... CNEN6BITS CNEN6bits; 
.................... #word CNEN6bits = 0x06C 
.................... #word CNEN6 = 0x06C 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN0PUE:1; 
....................    unsigned int CN1PUE:1; 
....................    unsigned int CN2PUE:1; 
....................    unsigned int CN3PUE:1; 
....................    unsigned int CN4PUE:1; 
....................    unsigned int CN5PUE:1; 
....................    unsigned int CN6PUE:1; 
....................    unsigned int CN7PUE:1; 
....................    unsigned int CN8PUE:1; 
....................    unsigned int CN9PUE:1; 
....................    unsigned int CN10PUE:1; 
....................    unsigned int CN11PUE:1; 
....................    unsigned int CN12PUE:1; 
....................    unsigned int CN13PUE:1; 
....................    unsigned int CN14PUE:1; 
....................    unsigned int CN15PUE:1; 
.................... } CNPU1BITS; 
.................... CNPU1BITS CNPU1bits; 
.................... #word CNPU1bits = 0x06E 
.................... #word CNPU1 = 0x06E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN16PUE:1; 
....................    unsigned int CN17PUE:1; 
....................    unsigned int CN18PUE:1; 
....................    unsigned int :3; 
....................    unsigned int CN22PUE:1; 
....................    unsigned int CN23PUE:1; 
....................    unsigned int CN24PUE:1; 
....................    unsigned int CN25PUE:1; 
....................    unsigned int CN26PUE:1; 
....................    unsigned int CN27PUE:1; 
....................    unsigned int CN28PUE:1; 
....................    unsigned int CN29PUE:1; 
....................    unsigned int CN30PUE:1; 
....................    unsigned int CN31PUE:1; 
.................... } CNPU2BITS; 
.................... CNPU2BITS CNPU2bits; 
.................... #word CNPU2bits = 0x070 
.................... #word CNPU2 = 0x070 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN32PUE:1; 
.................... } CNPU3BITS; 
.................... CNPU3BITS CNPU3bits; 
.................... #word CNPU3bits = 0x072 
.................... #word CNPU3 = 0x072 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int CN49PUE:1; 
....................    unsigned int CN50PUE:1; 
....................    unsigned int CN51PUE:1; 
....................    unsigned int CN52PUE:1; 
....................    unsigned int CN53PUE:1; 
....................    unsigned int CN54PUE:1; 
....................    unsigned int CN55PUE:1; 
....................    unsigned int CN56PUE:1; 
....................    unsigned int :1; 
....................    unsigned int CN58PUE:1; 
....................    unsigned int CN59PUE:1; 
....................    unsigned int CN60PUE:1; 
....................    unsigned int CN61PUE:1; 
....................    unsigned int CN62PUE:1; 
....................    unsigned int CN63PUE:1; 
.................... } CNPU4BITS; 
.................... CNPU4BITS CNPU4bits; 
.................... #word CNPU4bits = 0x074 
.................... #word CNPU4 = 0x074 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN64PUE:1; 
....................    unsigned int CN65PUE:1; 
....................    unsigned int :2; 
....................    unsigned int CN68PUE:1; 
....................    unsigned int CN69PUE:1; 
....................    unsigned int :1; 
....................    unsigned int CN71PUE:1; 
.................... } CNPU5BITS; 
.................... CNPU5BITS CNPU5bits; 
.................... #word CNPU5bits = 0x076 
.................... #word CNPU5 = 0x076 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :3; 
....................    unsigned int CN83PUE:1; 
....................    unsigned int CN84PUE:1; 
.................... } CNPU6BITS; 
.................... CNPU6BITS CNPU6bits; 
.................... #word CNPU6bits = 0x078 
.................... #word CNPU6 = 0x078 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int OSCFAIL:1; 
....................    unsigned int STKERR:1; 
....................    unsigned int ADDRERR:1; 
....................    unsigned int MATHERR:1; 
....................    unsigned int :10; 
....................    unsigned int NSTDIS:1; 
.................... } INTCON1BITS; 
.................... INTCON1BITS INTCON1bits; 
.................... #word INTCON1bits = 0x080 
.................... #word INTCON1 = 0x080 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int INT0EP:1; 
....................    unsigned int INT1EP:1; 
....................    unsigned int INT2EP:1; 
....................    unsigned int INT3EP:1; 
....................    unsigned int INT4EP:1; 
....................    unsigned int :9; 
....................    unsigned int DISI:1; 
....................    unsigned int ALTIVT:1; 
.................... } INTCON2BITS; 
.................... INTCON2BITS INTCON2bits; 
.................... #word INTCON2bits = 0x082 
.................... #word INTCON2 = 0x082 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int INT0IF:1; 
....................    unsigned int IC1IF:1; 
....................    unsigned int OC1IF:1; 
....................    unsigned int T1IF:1; 
....................    unsigned int :1; 
....................    unsigned int IC2IF:1; 
....................    unsigned int OC2IF:1; 
....................    unsigned int T2IF:1; 
....................    unsigned int T3IF:1; 
....................    unsigned int SPF1IF:1; 
....................    unsigned int SPI1IF:1; 
....................    unsigned int U1RXIF:1; 
....................    unsigned int U1TXIF:1; 
....................    unsigned int AD1IF:1; 
.................... } IFS0BITS; 
.................... IFS0BITS IFS0bits; 
.................... #word IFS0bits = 0x084 
.................... #word IFS0 = 0x084 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SI2C1IF:1; 
....................    unsigned int MI2C1IF:1; 
....................    unsigned int CMIF:1; 
....................    unsigned int CNIF:1; 
....................    unsigned int INT1IF:1; 
....................    unsigned int :1; 
....................    unsigned int IC7IF:1; 
....................    unsigned int IC8IF:1; 
....................    unsigned int :1; 
....................    unsigned int OC3IF:1; 
....................    unsigned int OC4IF:1; 
....................    unsigned int T4IF:1; 
....................    unsigned int T5IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int U2RXIF:1; 
....................    unsigned int U2TXIF:1; 
.................... } IFS1BITS; 
.................... IFS1BITS IFS1bits; 
.................... #word IFS1bits = 0x086 
.................... #word IFS1 = 0x086 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPF2IF:1; 
....................    unsigned int SPI2IF:1; 
....................    unsigned int :3; 
....................    unsigned int IC3IF:1; 
....................    unsigned int IC4IF:1; 
....................    unsigned int IC5IF:1; 
....................    unsigned int IC6IF:1; 
....................    unsigned int OC5IF:1; 
....................    unsigned int OC6IF:1; 
....................    unsigned int OC7IF:1; 
....................    unsigned int OC8IF:1; 
....................    unsigned int PMPIF:1; 
.................... } IFS2BITS; 
.................... IFS2BITS IFS2bits; 
.................... #word IFS2bits = 0x088 
.................... #word IFS2 = 0x088 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int SI2C2IF:1; 
....................    unsigned int MI2C2IF:1; 
....................    unsigned int :2; 
....................    unsigned int INT3IF:1; 
....................    unsigned int INT4IF:1; 
....................    unsigned int :7; 
....................    unsigned int RTCIF:1; 
.................... } IFS3BITS; 
.................... IFS3BITS IFS3bits; 
.................... #word IFS3bits = 0x08A 
.................... #word IFS3 = 0x08A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int U1ERIF:1; 
....................    unsigned int U2ERIF:1; 
....................    unsigned int CRCIF:1; 
....................    unsigned int :4; 
....................    unsigned int LVDIF:1; 
....................    unsigned int :4; 
....................    unsigned int CTMUIF:1; 
.................... } IFS4BITS; 
.................... IFS4BITS IFS4bits; 
.................... #word IFS4bits = 0x08C 
.................... #word IFS4 = 0x08C 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int U3ERIF:1; 
....................    unsigned int U3RXIF:1; 
....................    unsigned int U3TXIF:1; 
....................    unsigned int SI2C3IF:1; 
....................    unsigned int MI2C3IF:1; 
....................    unsigned int USB1IF:1; 
....................    unsigned int U4ERIF:1; 
....................    unsigned int U4RXIF:1; 
....................    unsigned int U4TXIF:1; 
....................    unsigned int SPF3IF:1; 
....................    unsigned int SPI3IF:1; 
....................    unsigned int OC9IF:1; 
....................    unsigned int IC9IF:1; 
.................... } IFS5BITS; 
.................... IFS5BITS IFS5bits; 
.................... #word IFS5bits = 0x08E 
.................... #word IFS5 = 0x08E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int INT0IE:1; 
....................    unsigned int IC1IE:1; 
....................    unsigned int OC1IE:1; 
....................    unsigned int T1IE:1; 
....................    unsigned int :1; 
....................    unsigned int IC2IE:1; 
....................    unsigned int OC2IE:1; 
....................    unsigned int T2IE:1; 
....................    unsigned int T3IE:1; 
....................    unsigned int SPF1IE:1; 
....................    unsigned int SPI1IE:1; 
....................    unsigned int U1RXIE:1; 
....................    unsigned int U1TXIE:1; 
....................    unsigned int AD1IE:1; 
.................... } IEC0BITS; 
.................... IEC0BITS IEC0bits; 
.................... #word IEC0bits = 0x094 
.................... #word IEC0 = 0x094 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SI2C1IE:1; 
....................    unsigned int MI2C1IE:1; 
....................    unsigned int CMIE:1; 
....................    unsigned int CNIE:1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int :1; 
....................    unsigned int IC7IE:1; 
....................    unsigned int IC8IE:1; 
....................    unsigned int :1; 
....................    unsigned int OC3IE:1; 
....................    unsigned int OC4IE:1; 
....................    unsigned int T4IE:1; 
....................    unsigned int T5IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int U2RXIE:1; 
....................    unsigned int U2TXIE:1; 
.................... } IEC1BITS; 
.................... IEC1BITS IEC1bits; 
.................... #word IEC1bits = 0x096 
.................... #word IEC1 = 0x096 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPF2IE:1; 
....................    unsigned int SPI2IE:1; 
....................    unsigned int :3; 
....................    unsigned int IC3IE:1; 
....................    unsigned int IC4IE:1; 
....................    unsigned int IC5IE:1; 
....................    unsigned int IC6IE:1; 
....................    unsigned int OC5IE:1; 
....................    unsigned int OC6IE:1; 
....................    unsigned int OC7IE:1; 
....................    unsigned int OC8IE:1; 
....................    unsigned int PMPIE:1; 
.................... } IEC2BITS; 
.................... IEC2BITS IEC2bits; 
.................... #word IEC2bits = 0x098 
.................... #word IEC2 = 0x098 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int SI2C2IE:1; 
....................    unsigned int MI2C2IE:1; 
....................    unsigned int :2; 
....................    unsigned int INT3IE:1; 
....................    unsigned int INT4IE:1; 
....................    unsigned int :7; 
....................    unsigned int RTCIE:1; 
.................... } IEC3BITS; 
.................... IEC3BITS IEC3bits; 
.................... #word IEC3bits = 0x09A 
.................... #word IEC3 = 0x09A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int U1ERIE:1; 
....................    unsigned int U2ERIE:1; 
....................    unsigned int CRCIE:1; 
....................    unsigned int :4; 
....................    unsigned int LVDIE:1; 
....................    unsigned int :4; 
....................    unsigned int CTMUIE:1; 
.................... } IEC4BITS; 
.................... IEC4BITS IEC4bits; 
.................... #word IEC4bits = 0x09C 
.................... #word IEC4 = 0x09C 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int U3ERIE:1; 
....................    unsigned int U3RXIE:1; 
....................    unsigned int U3TXIE:1; 
....................    unsigned int SI2C3IE:1; 
....................    unsigned int MI2C3IE:1; 
....................    unsigned int USB1IE:1; 
....................    unsigned int U4ERIE:1; 
....................    unsigned int U4RXIE:1; 
....................    unsigned int U4TXIE:1; 
....................    unsigned int SPF3IE:1; 
....................    unsigned int SPI3IE:1; 
....................    unsigned int OC9IE:1; 
....................    unsigned int IC9IE:1; 
.................... } IEC5BITS; 
.................... IEC5BITS IEC5bits; 
.................... #word IEC5bits = 0x09E 
.................... #word IEC5 = 0x09E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int INT0IP0:3; 
....................          unsigned int :1; 
....................          unsigned int IC1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int T1IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int INT0IP:3; 
....................          unsigned int :1; 
....................          unsigned int IC1IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC1IP:3; 
....................          unsigned int :1; 
....................          unsigned int T1IP:3; 
....................       }; 
.................... } IPC0BITS; 
.................... IPC0BITS IPC0bits; 
.................... #word IPC0bits = 0x0A4 
.................... #word IPC0 = 0x0A4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int IC2IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC2IP0:3; 
....................          unsigned int :1; 
....................          unsigned int T2IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int IC2IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC2IP:3; 
....................          unsigned int :1; 
....................          unsigned int T2IP:3; 
....................       }; 
.................... } IPC1BITS; 
.................... IPC1BITS IPC1bits; 
.................... #word IPC1bits = 0x0A6 
.................... #word IPC1 = 0x0A6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int T3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int SPF1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int SPI1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int U1RXIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int T3IP:3; 
....................          unsigned int :1; 
....................          unsigned int SPF1IP:3; 
....................          unsigned int :1; 
....................          unsigned int SPI1IP:3; 
....................          unsigned int :1; 
....................          unsigned int U1RXIP:3; 
....................       }; 
.................... } IPC2BITS; 
.................... IPC2BITS IPC2bits; 
.................... #word IPC2bits = 0x0A8 
.................... #word IPC2 = 0x0A8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int U1TXIP0:3; 
....................          unsigned int :1; 
....................          unsigned int AD1IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int U1TXIP:3; 
....................          unsigned int :1; 
....................          unsigned int AD1IP:3; 
....................       }; 
.................... } IPC3BITS; 
.................... IPC3BITS IPC3bits; 
.................... #word IPC3bits = 0x0AA 
.................... #word IPC3 = 0x0AA 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SI2C1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int CMIP0:3; 
....................          unsigned int :1; 
....................          unsigned int CNIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int SI2C1IP:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C1IP:3; 
....................          unsigned int :1; 
....................          unsigned int CMIP:3; 
....................          unsigned int :1; 
....................          unsigned int CNIP:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int SI2C1P0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C1P0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int SI2C1P:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C1P:3; 
....................       }; 
.................... } IPC4BITS; 
.................... IPC4BITS IPC4bits; 
.................... #word IPC4bits = 0x0AC 
.................... #word IPC4 = 0x0AC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int INT1IP0:3; 
....................          unsigned int :5; 
....................          unsigned int IC7IP0:3; 
....................          unsigned int :1; 
....................          unsigned int IC8IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int INT1IP:3; 
....................          unsigned int :5; 
....................          unsigned int IC7IP:3; 
....................          unsigned int :1; 
....................          unsigned int IC8IP:3; 
....................       }; 
.................... } IPC5BITS; 
.................... IPC5BITS IPC5bits; 
.................... #word IPC5bits = 0x0AE 
.................... #word IPC5 = 0x0AE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int OC3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC4IP0:3; 
....................          unsigned int :1; 
....................          unsigned int T4IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int OC3IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC4IP:3; 
....................          unsigned int :1; 
....................          unsigned int T4IP:3; 
....................       }; 
.................... } IPC6BITS; 
.................... IPC6BITS IPC6bits; 
.................... #word IPC6bits = 0x0B0 
.................... #word IPC6 = 0x0B0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int T5IP0:3; 
....................          unsigned int :1; 
....................          unsigned int INT2IP0:3; 
....................          unsigned int :1; 
....................          unsigned int U2RXIP0:3; 
....................          unsigned int :1; 
....................          unsigned int U2TXIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int T5IP:3; 
....................          unsigned int :1; 
....................          unsigned int INT2IP:3; 
....................          unsigned int :1; 
....................          unsigned int U2RXIP:3; 
....................          unsigned int :1; 
....................          unsigned int U2TXIP:3; 
....................       }; 
.................... } IPC7BITS; 
.................... IPC7BITS IPC7bits; 
.................... #word IPC7bits = 0x0B2 
.................... #word IPC7 = 0x0B2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SPF2IP0:3; 
....................          unsigned int :1; 
....................          unsigned int SPI2IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int SPF2IP:3; 
....................          unsigned int :1; 
....................          unsigned int SPI2IP:3; 
....................       }; 
.................... } IPC8BITS; 
.................... IPC8BITS IPC8bits; 
.................... #word IPC8bits = 0x0B4 
.................... #word IPC8 = 0x0B4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int IC3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int IC4IP0:3; 
....................          unsigned int :1; 
....................          unsigned int IC5IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int IC3IP:3; 
....................          unsigned int :1; 
....................          unsigned int IC4IP:3; 
....................          unsigned int :1; 
....................          unsigned int IC5IP:3; 
....................       }; 
.................... } IPC9BITS; 
.................... IPC9BITS IPC9bits; 
.................... #word IPC9bits = 0x0B6 
.................... #word IPC9 = 0x0B6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IC6IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC5IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC6IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC7IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int IC6IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC5IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC6IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC7IP:3; 
....................       }; 
.................... } IPC10BITS; 
.................... IPC10BITS IPC10bits; 
.................... #word IPC10bits = 0x0B8 
.................... #word IPC10 = 0x0B8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OC8IP0:3; 
....................          unsigned int :1; 
....................          unsigned int PMPIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int OC8IP:3; 
....................          unsigned int :1; 
....................          unsigned int PMPIP:3; 
....................       }; 
.................... } IPC11BITS; 
.................... IPC11BITS IPC11bits; 
.................... #word IPC11bits = 0x0BA 
.................... #word IPC11 = 0x0BA 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int SI2C2IP0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C2IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int SI2C2IP:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C2IP:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int SI2C2P0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C2P0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int SI2C2P:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C2P:3; 
....................       }; 
.................... } IPC12BITS; 
.................... IPC12BITS IPC12bits; 
.................... #word IPC12bits = 0x0BC 
.................... #word IPC12 = 0x0BC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int INT3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int INT4IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int INT3IP:3; 
....................          unsigned int :1; 
....................          unsigned int INT4IP:3; 
....................       }; 
.................... } IPC13BITS; 
.................... IPC13BITS IPC13bits; 
.................... #word IPC13bits = 0x0BE 
.................... #word IPC13 = 0x0BE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int RTCIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int RTCIP:3; 
....................       }; 
.................... } IPC15BITS; 
.................... IPC15BITS IPC15bits; 
.................... #word IPC15bits = 0x0C2 
.................... #word IPC15 = 0x0C2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int U1ERIP0:3; 
....................          unsigned int :1; 
....................          unsigned int U2ERIP0:3; 
....................          unsigned int :1; 
....................          unsigned int CRCIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int U1ERIP:3; 
....................          unsigned int :1; 
....................          unsigned int U2ERIP:3; 
....................          unsigned int :1; 
....................          unsigned int CRCIP:3; 
....................       }; 
.................... } IPC16BITS; 
.................... IPC16BITS IPC16bits; 
.................... #word IPC16bits = 0x0C4 
.................... #word IPC16 = 0x0C4 
....................  
.................... #word IPC18 = 0x0C8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int CTMUIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int CTMUIP:3; 
....................       }; 
.................... } IPC19BITS; 
.................... IPC19BITS IPC19bits; 
.................... #word IPC19bits = 0x0CA 
.................... #word IPC19 = 0x0CA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int U3ERIP0:3; 
....................          unsigned int :1; 
....................          unsigned int U3RXIP0:3; 
....................          unsigned int :1; 
....................          unsigned int U3TXIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int U3ERIP:3; 
....................          unsigned int :1; 
....................          unsigned int U3RXIP:3; 
....................          unsigned int :1; 
....................          unsigned int U3TXIP:3; 
....................       }; 
.................... } IPC20BITS; 
.................... IPC20BITS IPC20bits; 
.................... #word IPC20bits = 0x0CC 
.................... #word IPC20 = 0x0CC 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SI2C3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int USB1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int U4ERIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int SI2C3IP:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C3IP:3; 
....................          unsigned int :1; 
....................          unsigned int USB1IP:3; 
....................          unsigned int :1; 
....................          unsigned int U4ERIP:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int SI2C3P0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C3P0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int SI2C3P:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C3P:3; 
....................       }; 
.................... } IPC21BITS; 
.................... IPC21BITS IPC21bits; 
.................... #word IPC21bits = 0x0CE 
.................... #word IPC21 = 0x0CE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int U4RXIP0:3; 
....................          unsigned int :1; 
....................          unsigned int U4TXIP0:3; 
....................          unsigned int :1; 
....................          unsigned int SPF3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int SPI3IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int U4RXIP:3; 
....................          unsigned int :1; 
....................          unsigned int U4TXIP:3; 
....................          unsigned int :1; 
....................          unsigned int SPF3IP:3; 
....................          unsigned int :1; 
....................          unsigned int SPI3IP:3; 
....................       }; 
.................... } IPC22BITS; 
.................... IPC22BITS IPC22bits; 
.................... #word IPC22bits = 0x0D0 
.................... #word IPC22 = 0x0D0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OC9IP0:3; 
....................          unsigned int :1; 
....................          unsigned int IC9IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int OC9IP:3; 
....................          unsigned int :1; 
....................          unsigned int IC9IP:3; 
....................       }; 
.................... } IPC23BITS; 
.................... IPC23BITS IPC23bits; 
.................... #word IPC23bits = 0x0D2 
.................... #word IPC23 = 0x0D2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int VECNUM0:7; 
....................          unsigned int :1; 
....................          unsigned int ILR0:4; 
....................          unsigned int :1; 
....................          unsigned int VHOLD:1; 
....................          unsigned int :1; 
....................          unsigned int CPUIRQ:1; 
....................       }; 
....................       struct { 
....................          unsigned int VECNUM:7; 
....................          unsigned int :1; 
....................          unsigned int ILR:4; 
....................       }; 
.................... } INTTREGBITS; 
.................... INTTREGBITS INTTREGbits; 
.................... #word INTTREGbits = 0x0E0 
.................... #word INTTREG = 0x0E0 
....................  
.................... #word TMR1 = 0x100 
....................  
.................... #word PR1 = 0x102 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int TCS:1; 
....................          unsigned int TSYNC:1; 
....................          unsigned int :1; 
....................          unsigned int TCKPS0:2; 
....................          unsigned int TGATE:1; 
....................          unsigned int :6; 
....................          unsigned int TSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int TON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int TCKPS:2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } T1CONBITS; 
.................... T1CONBITS T1CONbits; 
.................... #word T1CONbits = 0x104 
.................... #word T1CON = 0x104 
....................  
.................... #word TMR2 = 0x106 
....................  
.................... #word TMR3HLD = 0x108 
....................  
.................... #word TMR3 = 0x10A 
....................  
.................... #word PR2 = 0x10C 
....................  
.................... #word PR3 = 0x10E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int TCS:1; 
....................          unsigned int :1; 
....................          unsigned int T32:1; 
....................          unsigned int TCKPS0:2; 
....................          unsigned int TGATE:1; 
....................          unsigned int :6; 
....................          unsigned int TSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int TON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int TCKPS:2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } T2CONBITS; 
.................... T2CONBITS T2CONbits; 
.................... #word T2CONbits = 0x110 
.................... #word T2CON = 0x110 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int TCS:1; 
....................          unsigned int :2; 
....................          unsigned int TCKPS0:2; 
....................          unsigned int TGATE:1; 
....................          unsigned int :6; 
....................          unsigned int TSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int TON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :2; 
....................          unsigned int TCKPS:2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } T3CONBITS; 
.................... T3CONBITS T3CONbits; 
.................... #word T3CONbits = 0x112 
.................... #word T3CON = 0x112 
....................  
.................... #word TMR4 = 0x114 
....................  
.................... #word TMR5HLD = 0x116 
....................  
.................... #word TMR5 = 0x118 
....................  
.................... #word PR4 = 0x11A 
....................  
.................... #word PR5 = 0x11C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int TCS:1; 
....................          unsigned int :1; 
....................          unsigned int T45:1; 
....................          unsigned int TCKPS0:2; 
....................          unsigned int TGATE:1; 
....................          unsigned int :6; 
....................          unsigned int TSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int TON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int TCKPS:2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } T4CONBITS; 
.................... T4CONBITS T4CONbits; 
.................... #word T4CONbits = 0x11E 
.................... #word T4CON = 0x11E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int TCS:1; 
....................          unsigned int :2; 
....................          unsigned int TCKPS0:2; 
....................          unsigned int TGATE:1; 
....................          unsigned int :6; 
....................          unsigned int TSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int TON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :2; 
....................          unsigned int TCKPS:2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } T5CONBITS; 
.................... T5CONBITS T5CONbits; 
.................... #word T5CONbits = 0x120 
.................... #word T5CON = 0x120 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC1CON1BITS; 
.................... IC1CON1BITS IC1CON1bits; 
.................... #word IC1CON1bits = 0x140 
.................... #word IC1CON1 = 0x140 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC1CON2BITS; 
.................... IC1CON2BITS IC1CON2bits; 
.................... #word IC1CON2bits = 0x142 
.................... #word IC1CON2 = 0x142 
....................  
.................... #word IC1BUF = 0x144 
....................  
.................... #word IC1TMR = 0x146 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC2CON1BITS; 
.................... IC2CON1BITS IC2CON1bits; 
.................... #word IC2CON1bits = 0x148 
.................... #word IC2CON1 = 0x148 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC2CON2BITS; 
.................... IC2CON2BITS IC2CON2bits; 
.................... #word IC2CON2bits = 0x14A 
.................... #word IC2CON2 = 0x14A 
....................  
.................... #word IC2BUF = 0x14C 
....................  
.................... #word IC2TMR = 0x14E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC3CON1BITS; 
.................... IC3CON1BITS IC3CON1bits; 
.................... #word IC3CON1bits = 0x150 
.................... #word IC3CON1 = 0x150 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC3CON2BITS; 
.................... IC3CON2BITS IC3CON2bits; 
.................... #word IC3CON2bits = 0x152 
.................... #word IC3CON2 = 0x152 
....................  
.................... #word IC3BUF = 0x154 
....................  
.................... #word IC3TMR = 0x156 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC4CON1BITS; 
.................... IC4CON1BITS IC4CON1bits; 
.................... #word IC4CON1bits = 0x158 
.................... #word IC4CON1 = 0x158 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC4CON2BITS; 
.................... IC4CON2BITS IC4CON2bits; 
.................... #word IC4CON2bits = 0x15A 
.................... #word IC4CON2 = 0x15A 
....................  
.................... #word IC4BUF = 0x15C 
....................  
.................... #word IC4TMR = 0x15E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC5CON1BITS; 
.................... IC5CON1BITS IC5CON1bits; 
.................... #word IC5CON1bits = 0x160 
.................... #word IC5CON1 = 0x160 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC5CON2BITS; 
.................... IC5CON2BITS IC5CON2bits; 
.................... #word IC5CON2bits = 0x162 
.................... #word IC5CON2 = 0x162 
....................  
.................... #word IC5BUF = 0x164 
....................  
.................... #word IC5TMR = 0x166 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC6CON1BITS; 
.................... IC6CON1BITS IC6CON1bits; 
.................... #word IC6CON1bits = 0x168 
.................... #word IC6CON1 = 0x168 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC6CON2BITS; 
.................... IC6CON2BITS IC6CON2bits; 
.................... #word IC6CON2bits = 0x16A 
.................... #word IC6CON2 = 0x16A 
....................  
.................... #word IC6BUF = 0x16C 
....................  
.................... #word IC6TMR = 0x16E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC7CON1BITS; 
.................... IC7CON1BITS IC7CON1bits; 
.................... #word IC7CON1bits = 0x170 
.................... #word IC7CON1 = 0x170 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC7CON2BITS; 
.................... IC7CON2BITS IC7CON2bits; 
.................... #word IC7CON2bits = 0x172 
.................... #word IC7CON2 = 0x172 
....................  
.................... #word IC7BUF = 0x174 
....................  
.................... #word IC7TMR = 0x176 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC8CON1BITS; 
.................... IC8CON1BITS IC8CON1bits; 
.................... #word IC8CON1bits = 0x178 
.................... #word IC8CON1 = 0x178 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC8CON2BITS; 
.................... IC8CON2BITS IC8CON2bits; 
.................... #word IC8CON2bits = 0x17A 
.................... #word IC8CON2 = 0x17A 
....................  
.................... #word IC8BUF = 0x17C 
....................  
.................... #word IC8TMR = 0x17E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC9CON1BITS; 
.................... IC9CON1BITS IC9CON1bits; 
.................... #word IC9CON1bits = 0x180 
.................... #word IC9CON1 = 0x180 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC9CON2BITS; 
.................... IC9CON2BITS IC9CON2bits; 
.................... #word IC9CON2bits = 0x182 
.................... #word IC9CON2 = 0x182 
....................  
.................... #word IC9BUF = 0x184 
....................  
.................... #word IC9TMR = 0x186 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC1CON1BITS; 
.................... OC1CON1BITS OC1CON1bits; 
.................... #word OC1CON1bits = 0x190 
.................... #word OC1CON1 = 0x190 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC1CON2BITS; 
.................... OC1CON2BITS OC1CON2bits; 
.................... #word OC1CON2bits = 0x192 
.................... #word OC1CON2 = 0x192 
....................  
.................... #word OC1RS = 0x194 
....................  
.................... #word OC1R = 0x196 
....................  
.................... #word OC1TMR = 0x198 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC2CON1BITS; 
.................... OC2CON1BITS OC2CON1bits; 
.................... #word OC2CON1bits = 0x19A 
.................... #word OC2CON1 = 0x19A 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC2CON2BITS; 
.................... OC2CON2BITS OC2CON2bits; 
.................... #word OC2CON2bits = 0x19C 
.................... #word OC2CON2 = 0x19C 
....................  
.................... #word OC2RS = 0x19E 
....................  
.................... #word OC2R = 0x1A0 
....................  
.................... #word OC2TMR = 0x1A2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC3CON1BITS; 
.................... OC3CON1BITS OC3CON1bits; 
.................... #word OC3CON1bits = 0x1A4 
.................... #word OC3CON1 = 0x1A4 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC3CON2BITS; 
.................... OC3CON2BITS OC3CON2bits; 
.................... #word OC3CON2bits = 0x1A6 
.................... #word OC3CON2 = 0x1A6 
....................  
.................... #word OC3RS = 0x1A8 
....................  
.................... #word OC3R = 0x1AA 
....................  
.................... #word OC3TMR = 0x1AC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC4CON1BITS; 
.................... OC4CON1BITS OC4CON1bits; 
.................... #word OC4CON1bits = 0x1AE 
.................... #word OC4CON1 = 0x1AE 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC4CON2BITS; 
.................... OC4CON2BITS OC4CON2bits; 
.................... #word OC4CON2bits = 0x1B0 
.................... #word OC4CON2 = 0x1B0 
....................  
.................... #word OC4RS = 0x1B2 
....................  
.................... #word OC4R = 0x1B4 
....................  
.................... #word OC4TMR = 0x1B6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC5CON1BITS; 
.................... OC5CON1BITS OC5CON1bits; 
.................... #word OC5CON1bits = 0x1B8 
.................... #word OC5CON1 = 0x1B8 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC5CON2BITS; 
.................... OC5CON2BITS OC5CON2bits; 
.................... #word OC5CON2bits = 0x1BA 
.................... #word OC5CON2 = 0x1BA 
....................  
.................... #word OC5RS = 0x1BC 
....................  
.................... #word OC5R = 0x1BE 
....................  
.................... #word OC5TMR = 0x1C0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC6CON1BITS; 
.................... OC6CON1BITS OC6CON1bits; 
.................... #word OC6CON1bits = 0x1C2 
.................... #word OC6CON1 = 0x1C2 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC6CON2BITS; 
.................... OC6CON2BITS OC6CON2bits; 
.................... #word OC6CON2bits = 0x1C4 
.................... #word OC6CON2 = 0x1C4 
....................  
.................... #word OC6RS = 0x1C6 
....................  
.................... #word OC6R = 0x1C8 
....................  
.................... #word OC6TMR = 0x1CA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC7CON1BITS; 
.................... OC7CON1BITS OC7CON1bits; 
.................... #word OC7CON1bits = 0x1CC 
.................... #word OC7CON1 = 0x1CC 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC7CON2BITS; 
.................... OC7CON2BITS OC7CON2bits; 
.................... #word OC7CON2bits = 0x1CE 
.................... #word OC7CON2 = 0x1CE 
....................  
.................... #word OC7RS = 0x1D0 
....................  
.................... #word OC7R = 0x1D2 
....................  
.................... #word OC7TMR = 0x1D4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC8CON1BITS; 
.................... OC8CON1BITS OC8CON1bits; 
.................... #word OC8CON1bits = 0x1D6 
.................... #word OC8CON1 = 0x1D6 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC8CON2BITS; 
.................... OC8CON2BITS OC8CON2bits; 
.................... #word OC8CON2bits = 0x1D8 
.................... #word OC8CON2 = 0x1D8 
....................  
.................... #word OC8RS = 0x1DA 
....................  
.................... #word OC8R = 0x1DC 
....................  
.................... #word OC8TMR = 0x1DE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC9CON1BITS; 
.................... OC9CON1BITS OC9CON1bits; 
.................... #word OC9CON1bits = 0x1E0 
.................... #word OC9CON1 = 0x1E0 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC9CON2BITS; 
.................... OC9CON2BITS OC9CON2bits; 
.................... #word OC9CON2bits = 0x1E2 
.................... #word OC9CON2 = 0x1E2 
....................  
.................... #word OC9RS = 0x1E4 
....................  
.................... #word OC9R = 0x1E6 
....................  
.................... #word OC9TMR = 0x1E8 
....................  
.................... #word I2C1RCV = 0x200 
....................  
.................... #word I2C1TRN = 0x202 
....................  
.................... #word I2C1BRG = 0x204 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int STREN:1; 
....................    unsigned int GCEN:1; 
....................    unsigned int SMEN:1; 
....................    unsigned int DISSLW:1; 
....................    unsigned int A10M:1; 
....................    unsigned int IPMIEN:1; 
....................    unsigned int SCLREL:1; 
....................    unsigned int I2CSIDL:1; 
....................    unsigned int :1; 
....................    unsigned int I2CEN:1; 
.................... } I2C1CONBITS; 
.................... I2C1CONBITS I2C1CONbits; 
.................... #word I2C1CONbits = 0x206 
.................... #word I2C1CON = 0x206 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int TBF:1; 
....................          unsigned int RBF:1; 
....................          unsigned int R:1; 
....................          unsigned int S:1; 
....................          unsigned int P:1; 
....................          unsigned int D:1; 
....................          unsigned int I2COV:1; 
....................          unsigned int IWCOL:1; 
....................          unsigned int ADD10:1; 
....................          unsigned int GCSTAT:1; 
....................          unsigned int BCL:1; 
....................          unsigned int :3; 
....................          unsigned int TRSTAT:1; 
....................          unsigned int ACKSTAT:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int R_W:1; 
....................          unsigned int :2; 
....................          unsigned int D_A:1; 
....................       }; 
....................    }; 
.................... } I2C1STATBITS; 
.................... I2C1STATBITS I2C1STATbits; 
.................... #word I2C1STATbits = 0x208 
.................... #word I2C1STAT = 0x208 
....................  
.................... #word I2C1ADD = 0x20A 
....................  
.................... #word I2C1MSK = 0x20C 
....................  
.................... #word I2C2RCV = 0x210 
....................  
.................... #word I2C2TRN = 0x212 
....................  
.................... #word I2C2BRG = 0x214 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int STREN:1; 
....................    unsigned int GCEN:1; 
....................    unsigned int SMEN:1; 
....................    unsigned int DISSLW:1; 
....................    unsigned int A10M:1; 
....................    unsigned int IPMIEN:1; 
....................    unsigned int SCLREL:1; 
....................    unsigned int I2CSIDL:1; 
....................    unsigned int :1; 
....................    unsigned int I2CEN:1; 
.................... } I2C2CONBITS; 
.................... I2C2CONBITS I2C2CONbits; 
.................... #word I2C2CONbits = 0x216 
.................... #word I2C2CON = 0x216 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int TBF:1; 
....................          unsigned int RBF:1; 
....................          unsigned int R:1; 
....................          unsigned int S:1; 
....................          unsigned int P:1; 
....................          unsigned int D:1; 
....................          unsigned int I2COV:1; 
....................          unsigned int IWCOL:1; 
....................          unsigned int ADD10:1; 
....................          unsigned int GCSTAT:1; 
....................          unsigned int BCL:1; 
....................          unsigned int :3; 
....................          unsigned int TRSTAT:1; 
....................          unsigned int ACKSTAT:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int R_W:1; 
....................          unsigned int :2; 
....................          unsigned int D_A:1; 
....................       }; 
....................    }; 
.................... } I2C2STATBITS; 
.................... I2C2STATBITS I2C2STATbits; 
.................... #word I2C2STATbits = 0x218 
.................... #word I2C2STAT = 0x218 
....................  
.................... #word I2C2ADD = 0x21A 
....................  
.................... #word I2C2MSK = 0x21C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int STSEL:1; 
....................          unsigned int PDSEL0:2; 
....................          unsigned int BRGH:1; 
....................          unsigned int RXINV:1; 
....................          unsigned int ABAUD:1; 
....................          unsigned int LPBACK:1; 
....................          unsigned int WAKE:1; 
....................          unsigned int UEN0:2; 
....................          unsigned int :1; 
....................          unsigned int RTSMD:1; 
....................          unsigned int IREN:1; 
....................          unsigned int USIDL:1; 
....................          unsigned int :1; 
....................          unsigned int UARTEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int PDSEL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int UEN:2; 
....................       }; 
.................... } U1MODEBITS; 
.................... U1MODEBITS U1MODEbits; 
.................... #word U1MODEbits = 0x220 
.................... #word U1MODE = 0x220 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXDA:1; 
....................          unsigned int OERR:1; 
....................          unsigned int FERR:1; 
....................          unsigned int PERR:1; 
....................          unsigned int RIDLE:1; 
....................          unsigned int ADDEN:1; 
....................          unsigned int URXISEL0:2; 
....................          unsigned int TRMT:1; 
....................          unsigned int UTXBF:1; 
....................          unsigned int UTXEN:1; 
....................          unsigned int UTXBRK:1; 
....................          unsigned int :1; 
....................          unsigned int UTXISEL0:1; 
....................          unsigned int UTXINV:1; 
....................          unsigned int UTXISEL1:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int URXISEL:2; 
....................       }; 
.................... } U1STABITS; 
.................... U1STABITS U1STAbits; 
.................... #word U1STAbits = 0x222 
.................... #word U1STA = 0x222 
....................  
.................... #word U1TXREG = 0x224 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int UTXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int UTXREG:9; 
....................       }; 
.................... } U1TXREGBITS; 
.................... U1TXREGBITS U1TXREGbits; 
.................... #word U1TXREGbits = 0x224 
.................... #word U1TXREG = 0x224 
....................  
.................... #word U1RXREG = 0x226 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int URXREG:9; 
....................       }; 
.................... } U1RXREGBITS; 
.................... U1RXREGBITS U1RXREGbits; 
.................... #word U1RXREGbits = 0x226 
.................... #word U1RXREG = 0x226 
....................  
.................... #word U1BRG = 0x228 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int STSEL:1; 
....................          unsigned int PDSEL0:2; 
....................          unsigned int BRGH:1; 
....................          unsigned int RXINV:1; 
....................          unsigned int ABAUD:1; 
....................          unsigned int LPBACK:1; 
....................          unsigned int WAKE:1; 
....................          unsigned int UEN0:2; 
....................          unsigned int :1; 
....................          unsigned int RTSMD:1; 
....................          unsigned int IREN:1; 
....................          unsigned int USIDL:1; 
....................          unsigned int :1; 
....................          unsigned int UARTEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int PDSEL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int UEN:2; 
....................       }; 
.................... } U2MODEBITS; 
.................... U2MODEBITS U2MODEbits; 
.................... #word U2MODEbits = 0x230 
.................... #word U2MODE = 0x230 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXDA:1; 
....................          unsigned int OERR:1; 
....................          unsigned int FERR:1; 
....................          unsigned int PERR:1; 
....................          unsigned int RIDLE:1; 
....................          unsigned int ADDEN:1; 
....................          unsigned int URXISEL0:2; 
....................          unsigned int TRMT:1; 
....................          unsigned int UTXBF:1; 
....................          unsigned int UTXEN:1; 
....................          unsigned int UTXBRK:1; 
....................          unsigned int :1; 
....................          unsigned int UTXISEL0:1; 
....................          unsigned int UTXINV:1; 
....................          unsigned int UTXISEL1:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int URXISEL:2; 
....................       }; 
.................... } U2STABITS; 
.................... U2STABITS U2STAbits; 
.................... #word U2STAbits = 0x232 
.................... #word U2STA = 0x232 
....................  
.................... #word U2TXREG = 0x234 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int UTXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int UTXREG:9; 
....................       }; 
.................... } U2TXREGBITS; 
.................... U2TXREGBITS U2TXREGbits; 
.................... #word U2TXREGbits = 0x234 
.................... #word U2TXREG = 0x234 
....................  
.................... #word U2RXREG = 0x236 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int URXREG:9; 
....................       }; 
.................... } U2RXREGBITS; 
.................... U2RXREGBITS U2RXREGbits; 
.................... #word U2RXREGbits = 0x236 
.................... #word U2RXREG = 0x236 
....................  
.................... #word U2BRG = 0x238 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SPIRBF:1; 
....................          unsigned int SPITBF:1; 
....................          unsigned int SISEL0:3; 
....................          unsigned int SRXMPT:1; 
....................          unsigned int SPIROV:1; 
....................          unsigned int SRMPT:1; 
....................          unsigned int SPIBEC0:3; 
....................          unsigned int :2; 
....................          unsigned int SPISIDL:1; 
....................          unsigned int :1; 
....................          unsigned int SPIEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SISEL:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SPIBEC:3; 
....................          unsigned int :2; 
....................       }; 
.................... } SPI1STATBITS; 
.................... SPI1STATBITS SPI1STATbits; 
.................... #word SPI1STATbits = 0x240 
.................... #word SPI1STAT = 0x240 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PPRE0:2; 
....................          unsigned int SPRE0:3; 
....................          unsigned int MSTEN:1; 
....................          unsigned int CKP:1; 
....................          unsigned int SSEN:1; 
....................          unsigned int CKE:1; 
....................          unsigned int SMP:1; 
....................          unsigned int MODE16:1; 
....................          unsigned int DISSDO:1; 
....................          unsigned int DISSCK:1; 
....................       }; 
....................       struct { 
....................          unsigned int PPRE:2; 
....................          unsigned int SPRE:3; 
....................       }; 
.................... } SPI1CON1BITS; 
.................... SPI1CON1BITS SPI1CON1bits; 
.................... #word SPI1CON1bits = 0x242 
.................... #word SPI1CON1 = 0x242 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPIBEN:1; 
....................    unsigned int SPIFE:1; 
....................    unsigned int :11; 
....................    unsigned int SPIFPOL:1; 
....................    unsigned int SPIFSD:1; 
....................    unsigned int FRMEN:1; 
.................... } SPI1CON2BITS; 
.................... SPI1CON2BITS SPI1CON2bits; 
.................... #word SPI1CON2bits = 0x244 
.................... #word SPI1CON2 = 0x244 
....................  
.................... #word SPI1BUF = 0x248 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int STSEL:1; 
....................          unsigned int PDSEL0:2; 
....................          unsigned int BRGH:1; 
....................          unsigned int RXINV:1; 
....................          unsigned int ABAUD:1; 
....................          unsigned int LPBACK:1; 
....................          unsigned int WAKE:1; 
....................          unsigned int UEN0:2; 
....................          unsigned int :1; 
....................          unsigned int RTSMD:1; 
....................          unsigned int IREN:1; 
....................          unsigned int USIDL:1; 
....................          unsigned int :1; 
....................          unsigned int UARTEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int PDSEL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int UEN:2; 
....................       }; 
.................... } U3MODEBITS; 
.................... U3MODEBITS U3MODEbits; 
.................... #word U3MODEbits = 0x250 
.................... #word U3MODE = 0x250 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXDA:1; 
....................          unsigned int OERR:1; 
....................          unsigned int FERR:1; 
....................          unsigned int PERR:1; 
....................          unsigned int RIDLE:1; 
....................          unsigned int ADDEN:1; 
....................          unsigned int URXISEL0:2; 
....................          unsigned int TRMT:1; 
....................          unsigned int UTXBF:1; 
....................          unsigned int UTXEN:1; 
....................          unsigned int UTXBRK:1; 
....................          unsigned int :1; 
....................          unsigned int UTXISEL0:1; 
....................          unsigned int UTXINV:1; 
....................          unsigned int UTXISEL1:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int URXISEL:2; 
....................       }; 
.................... } U3STABITS; 
.................... U3STABITS U3STAbits; 
.................... #word U3STAbits = 0x252 
.................... #word U3STA = 0x252 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int UTXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int UTXREG:9; 
....................       }; 
.................... } U3TXREGBITS; 
.................... U3TXREGBITS U3TXREGbits; 
.................... #word U3TXREGbits = 0x254 
.................... #word U3TXREG = 0x254 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int URXREG:9; 
....................       }; 
.................... } U3RXREGBITS; 
.................... U3RXREGBITS U3RXREGbits; 
.................... #word U3RXREGbits = 0x256 
.................... #word U3RXREG = 0x256 
....................  
.................... #word U3BRG = 0x258 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SPIRBF:1; 
....................          unsigned int SPITBF:1; 
....................          unsigned int SISEL0:3; 
....................          unsigned int SRXMPT:1; 
....................          unsigned int SPIROV:1; 
....................          unsigned int SRMPT:1; 
....................          unsigned int SPIBEC0:3; 
....................          unsigned int :2; 
....................          unsigned int SPISIDL:1; 
....................          unsigned int :1; 
....................          unsigned int SPIEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SISEL:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SPIBEC:3; 
....................          unsigned int :2; 
....................       }; 
.................... } SPI2STATBITS; 
.................... SPI2STATBITS SPI2STATbits; 
.................... #word SPI2STATbits = 0x260 
.................... #word SPI2STAT = 0x260 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PPRE0:2; 
....................          unsigned int SPRE0:3; 
....................          unsigned int MSTEN:1; 
....................          unsigned int CKP:1; 
....................          unsigned int SSEN:1; 
....................          unsigned int CKE:1; 
....................          unsigned int SMP:1; 
....................          unsigned int MODE16:1; 
....................          unsigned int DISSDO:1; 
....................          unsigned int DISSCK:1; 
....................       }; 
....................       struct { 
....................          unsigned int PPRE:2; 
....................          unsigned int SPRE:3; 
....................       }; 
.................... } SPI2CON1BITS; 
.................... SPI2CON1BITS SPI2CON1bits; 
.................... #word SPI2CON1bits = 0x262 
.................... #word SPI2CON1 = 0x262 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPIBEN:1; 
....................    unsigned int SPIFE:1; 
....................    unsigned int :11; 
....................    unsigned int SPIFPOL:1; 
....................    unsigned int SPIFSD:1; 
....................    unsigned int FRMEN:1; 
.................... } SPI2CON2BITS; 
.................... SPI2CON2BITS SPI2CON2bits; 
.................... #word SPI2CON2bits = 0x264 
.................... #word SPI2CON2 = 0x264 
....................  
.................... #word SPI2BUF = 0x268 
....................  
.................... #word I2C3RCV = 0x270 
....................  
.................... #word I2C3TRN = 0x272 
....................  
.................... #word I2C3BRG = 0x274 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int STREN:1; 
....................    unsigned int GCEN:1; 
....................    unsigned int SMEN:1; 
....................    unsigned int DISSLW:1; 
....................    unsigned int A10M:1; 
....................    unsigned int IPMIEN:1; 
....................    unsigned int SCLREL:1; 
....................    unsigned int I2CSIDL:1; 
....................    unsigned int :1; 
....................    unsigned int I2CEN:1; 
.................... } I2C3CONBITS; 
.................... I2C3CONBITS I2C3CONbits; 
.................... #word I2C3CONbits = 0x276 
.................... #word I2C3CON = 0x276 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int TBF:1; 
....................          unsigned int RBF:1; 
....................          unsigned int R:1; 
....................          unsigned int S:1; 
....................          unsigned int P:1; 
....................          unsigned int D:1; 
....................          unsigned int I2COV:1; 
....................          unsigned int IWCOL:1; 
....................          unsigned int ADD10:1; 
....................          unsigned int GCSTAT:1; 
....................          unsigned int BCL:1; 
....................          unsigned int :3; 
....................          unsigned int TRSTAT:1; 
....................          unsigned int ACKSTAT:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int R_W:1; 
....................          unsigned int :2; 
....................          unsigned int D_A:1; 
....................       }; 
....................    }; 
.................... } I2C3STATBITS; 
.................... I2C3STATBITS I2C3STATbits; 
.................... #word I2C3STATbits = 0x278 
.................... #word I2C3STAT = 0x278 
....................  
.................... #word I2C3ADD = 0x27A 
....................  
.................... #word I2C3MSK = 0x27C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SPIRBF:1; 
....................          unsigned int SPITBF:1; 
....................          unsigned int SISEL0:3; 
....................          unsigned int SRXMPT:1; 
....................          unsigned int SPIROV:1; 
....................          unsigned int SRMPT:1; 
....................          unsigned int SPIBEC0:3; 
....................          unsigned int :2; 
....................          unsigned int SPISIDL:1; 
....................          unsigned int :1; 
....................          unsigned int SPIEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SISEL:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SPIBEC:3; 
....................          unsigned int :2; 
....................       }; 
.................... } SPI3STATBITS; 
.................... SPI3STATBITS SPI3STATbits; 
.................... #word SPI3STATbits = 0x280 
.................... #word SPI3STAT = 0x280 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PPRE0:2; 
....................          unsigned int SPRE0:3; 
....................          unsigned int MSTEN:1; 
....................          unsigned int CKP:1; 
....................          unsigned int SSEN:1; 
....................          unsigned int CKE:1; 
....................          unsigned int SMP:1; 
....................          unsigned int MODE16:1; 
....................          unsigned int DISSDO:1; 
....................          unsigned int DISSCK:1; 
....................       }; 
....................       struct { 
....................          unsigned int PPRE:2; 
....................          unsigned int SPRE:3; 
....................       }; 
.................... } SPI3CON1BITS; 
.................... SPI3CON1BITS SPI3CON1bits; 
.................... #word SPI3CON1bits = 0x282 
.................... #word SPI3CON1 = 0x282 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPIBEN:1; 
....................    unsigned int SPIFE:1; 
....................    unsigned int :11; 
....................    unsigned int SPIFPOL:1; 
....................    unsigned int SPIFSD:1; 
....................    unsigned int FRMEN:1; 
.................... } SPI3CON2BITS; 
.................... SPI3CON2BITS SPI3CON2bits; 
.................... #word SPI3CON2bits = 0x284 
.................... #word SPI3CON2 = 0x284 
....................  
.................... #word SPI3BUF = 0x288 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int STSEL:1; 
....................          unsigned int PDSEL0:2; 
....................          unsigned int BRGH:1; 
....................          unsigned int RXINV:1; 
....................          unsigned int ABAUD:1; 
....................          unsigned int LPBACK:1; 
....................          unsigned int WAKE:1; 
....................          unsigned int UEN0:2; 
....................          unsigned int :1; 
....................          unsigned int RTSMD:1; 
....................          unsigned int IREN:1; 
....................          unsigned int USIDL:1; 
....................          unsigned int :1; 
....................          unsigned int UARTEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int PDSEL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int UEN:2; 
....................       }; 
.................... } U4MODEBITS; 
.................... U4MODEBITS U4MODEbits; 
.................... #word U4MODEbits = 0x2B0 
.................... #word U4MODE = 0x2B0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXDA:1; 
....................          unsigned int OERR:1; 
....................          unsigned int FERR:1; 
....................          unsigned int PERR:1; 
....................          unsigned int RIDLE:1; 
....................          unsigned int ADDEN:1; 
....................          unsigned int URXISEL0:2; 
....................          unsigned int TRMT:1; 
....................          unsigned int UTXBF:1; 
....................          unsigned int UTXEN:1; 
....................          unsigned int UTXBRK:1; 
....................          unsigned int :1; 
....................          unsigned int UTXISEL0:1; 
....................          unsigned int UTXINV:1; 
....................          unsigned int UTXISEL1:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int URXISEL:2; 
....................       }; 
.................... } U4STABITS; 
.................... U4STABITS U4STAbits; 
.................... #word U4STAbits = 0x2B2 
.................... #word U4STA = 0x2B2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int UTXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int UTXREG:9; 
....................       }; 
.................... } U4TXREGBITS; 
.................... U4TXREGBITS U4TXREGbits; 
.................... #word U4TXREGbits = 0x2B4 
.................... #word U4TXREG = 0x2B4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int URXREG:9; 
....................       }; 
.................... } U4RXREGBITS; 
.................... U4RXREGBITS U4RXREGbits; 
.................... #word U4RXREGbits = 0x2B6 
.................... #word U4RXREG = 0x2B6 
....................  
.................... #word U4BRG = 0x2B8 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
....................    unsigned int TRISB8:1; 
....................    unsigned int TRISB9:1; 
....................    unsigned int TRISB10:1; 
....................    unsigned int TRISB11:1; 
....................    unsigned int TRISB12:1; 
....................    unsigned int TRISB13:1; 
....................    unsigned int TRISB14:1; 
....................    unsigned int TRISB15:1; 
.................... } TRISBBITS; 
.................... TRISBBITS TRISBbits; 
.................... #word TRISBbits = 0x2C8 
.................... #word TRISB = 0x2C8 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
....................    unsigned int RB8:1; 
....................    unsigned int RB9:1; 
....................    unsigned int RB10:1; 
....................    unsigned int RB11:1; 
....................    unsigned int RB12:1; 
....................    unsigned int RB13:1; 
....................    unsigned int RB14:1; 
....................    unsigned int RB15:1; 
.................... } PORTBBITS; 
.................... PORTBBITS PORTBbits; 
.................... #word PORTBbits = 0x2CA 
.................... #word PORTB = 0x2CA 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
....................    unsigned int LATB8:1; 
....................    unsigned int LATB9:1; 
....................    unsigned int LATB10:1; 
....................    unsigned int LATB11:1; 
....................    unsigned int LATB12:1; 
....................    unsigned int LATB13:1; 
....................    unsigned int LATB14:1; 
....................    unsigned int LATB15:1; 
.................... } LATBBITS; 
.................... LATBBITS LATBbits; 
.................... #word LATBbits = 0x2CC 
.................... #word LATB = 0x2CC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ODB0:16; 
....................       }; 
....................       struct { 
....................          unsigned int ODB:16; 
....................       }; 
.................... } ODCBBITS; 
.................... ODCBBITS ODCBbits; 
.................... #word ODCBbits = 0x2CE 
.................... #word ODCB = 0x2CE 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
....................    unsigned int TRISC8:1; 
....................    unsigned int TRISC9:1; 
....................    unsigned int TRISC10:1; 
....................    unsigned int TRISC11:1; 
....................    unsigned int TRISC12:1; 
....................    unsigned int TRISC13:1; 
....................    unsigned int TRISC14:1; 
....................    unsigned int TRISC15:1; 
.................... } TRISCBITS; 
.................... TRISCBITS TRISCbits; 
.................... #word TRISCbits = 0x2D0 
.................... #word TRISC = 0x2D0 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
....................    unsigned int RC8:1; 
....................    unsigned int RC9:1; 
....................    unsigned int RC10:1; 
....................    unsigned int RC11:1; 
....................    unsigned int RC12:1; 
....................    unsigned int RC13:1; 
....................    unsigned int RC14:1; 
....................    unsigned int RC15:1; 
.................... } PORTCBITS; 
.................... PORTCBITS PORTCbits; 
.................... #word PORTCbits = 0x2D2 
.................... #word PORTC = 0x2D2 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
....................    unsigned int LATC8:1; 
....................    unsigned int LATC9:1; 
....................    unsigned int LATC10:1; 
....................    unsigned int LATC11:1; 
....................    unsigned int LATC12:1; 
....................    unsigned int LATC13:1; 
....................    unsigned int LATC14:1; 
....................    unsigned int LATC15:1; 
.................... } LATCBITS; 
.................... LATCBITS LATCbits; 
.................... #word LATCbits = 0x2D4 
.................... #word LATC = 0x2D4 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :12; 
....................    unsigned int ODC12:4; 
.................... } ODCCBITS; 
.................... ODCCBITS ODCCbits; 
.................... #word ODCCbits = 0x2D6 
.................... #word ODCC = 0x2D6 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
....................    unsigned int TRISD8:1; 
....................    unsigned int TRISD9:1; 
....................    unsigned int TRISD10:1; 
....................    unsigned int TRISD11:1; 
....................    unsigned int TRISD12:1; 
....................    unsigned int TRISD13:1; 
....................    unsigned int TRISD14:1; 
....................    unsigned int TRISD15:1; 
.................... } TRISDBITS; 
.................... TRISDBITS TRISDbits; 
.................... #word TRISDbits = 0x2D8 
.................... #word TRISD = 0x2D8 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
....................    unsigned int RD8:1; 
....................    unsigned int RD9:1; 
....................    unsigned int RD10:1; 
....................    unsigned int RD11:1; 
....................    unsigned int RD12:1; 
....................    unsigned int RD13:1; 
....................    unsigned int RD14:1; 
....................    unsigned int RD15:1; 
.................... } PORTDBITS; 
.................... PORTDBITS PORTDbits; 
.................... #word PORTDbits = 0x2DA 
.................... #word PORTD = 0x2DA 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
....................    unsigned int LATD8:1; 
....................    unsigned int LATD9:1; 
....................    unsigned int LATD10:1; 
....................    unsigned int LATD11:1; 
....................    unsigned int LATD12:1; 
....................    unsigned int LATD13:1; 
....................    unsigned int LATD14:1; 
....................    unsigned int LATD15:1; 
.................... } LATDBITS; 
.................... LATDBITS LATDbits; 
.................... #word LATDbits = 0x2DC 
.................... #word LATD = 0x2DC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ODD0:12; 
....................       }; 
....................       struct { 
....................          unsigned int ODD:12; 
....................       }; 
.................... } ODCDBITS; 
.................... ODCDBITS ODCDbits; 
.................... #word ODCDbits = 0x2DE 
.................... #word ODCD = 0x2DE 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int TRISE3:1; 
....................    unsigned int TRISE4:1; 
....................    unsigned int TRISE5:1; 
....................    unsigned int TRISE6:1; 
....................    unsigned int TRISE7:1; 
....................    unsigned int TRISE8:1; 
....................    unsigned int TRISE9:1; 
....................    unsigned int TRISE10:1; 
....................    unsigned int TRISE11:1; 
....................    unsigned int TRISE12:1; 
....................    unsigned int TRISE13:1; 
....................    unsigned int TRISE14:1; 
....................    unsigned int TRISE15:1; 
.................... } TRISEBITS; 
.................... TRISEBITS TRISEbits; 
.................... #word TRISEbits = 0x2E0 
.................... #word TRISE = 0x2E0 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RE0:1; 
....................    unsigned int RE1:1; 
....................    unsigned int RE2:1; 
....................    unsigned int RE3:1; 
....................    unsigned int RE4:1; 
....................    unsigned int RE5:1; 
....................    unsigned int RE6:1; 
....................    unsigned int RE7:1; 
....................    unsigned int RE8:1; 
....................    unsigned int RE9:1; 
....................    unsigned int RE10:1; 
....................    unsigned int RE11:1; 
....................    unsigned int RE12:1; 
....................    unsigned int RE13:1; 
....................    unsigned int RE14:1; 
....................    unsigned int RE15:1; 
.................... } PORTEBITS; 
.................... PORTEBITS PORTEbits; 
.................... #word PORTEbits = 0x2E2 
.................... #word PORTE = 0x2E2 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
....................    unsigned int LATE8:1; 
....................    unsigned int LATE9:1; 
....................    unsigned int LATE10:1; 
....................    unsigned int LATE11:1; 
....................    unsigned int LATE12:1; 
....................    unsigned int LATE13:1; 
....................    unsigned int LATE14:1; 
....................    unsigned int LATE15:1; 
.................... } LATEBITS; 
.................... LATEBITS LATEbits; 
.................... #word LATEbits = 0x2E4 
.................... #word LATE = 0x2E4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ODE0:8; 
....................       }; 
....................       struct { 
....................          unsigned int ODE:8; 
....................       }; 
.................... } ODCEBITS; 
.................... ODCEBITS ODCEbits; 
.................... #word ODCEbits = 0x2E6 
.................... #word ODCE = 0x2E6 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISF0:1; 
....................    unsigned int TRISF1:1; 
....................    unsigned int TRISF2:1; 
....................    unsigned int TRISF3:1; 
....................    unsigned int TRISF4:1; 
....................    unsigned int TRISF5:1; 
....................    unsigned int TRISF6:1; 
....................    unsigned int TRISF7:1; 
....................    unsigned int TRISF8:1; 
....................    unsigned int TRISF9:1; 
....................    unsigned int TRISF10:1; 
....................    unsigned int TRISF11:1; 
....................    unsigned int TRISF12:1; 
....................    unsigned int TRISF13:1; 
....................    unsigned int TRISF14:1; 
....................    unsigned int TRISF15:1; 
.................... } TRISFBITS; 
.................... TRISFBITS TRISFbits; 
.................... #word TRISFbits = 0x2E8 
.................... #word TRISF = 0x2E8 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RF0:1; 
....................    unsigned int RF1:1; 
....................    unsigned int RF2:1; 
....................    unsigned int RF3:1; 
....................    unsigned int RF4:1; 
....................    unsigned int RF5:1; 
....................    unsigned int RF6:1; 
....................    unsigned int RF7:1; 
....................    unsigned int RF8:1; 
....................    unsigned int RF9:1; 
....................    unsigned int RF10:1; 
....................    unsigned int RF11:1; 
....................    unsigned int RF12:1; 
....................    unsigned int RF13:1; 
....................    unsigned int RF14:1; 
....................    unsigned int RF15:1; 
.................... } PORTFBITS; 
.................... PORTFBITS PORTFbits; 
.................... #word PORTFbits = 0x2EA 
.................... #word PORTF = 0x2EA 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATF0:1; 
....................    unsigned int LATF1:1; 
....................    unsigned int LATF2:1; 
....................    unsigned int LATF3:1; 
....................    unsigned int LATF4:1; 
....................    unsigned int LATF5:1; 
....................    unsigned int LATF6:1; 
....................    unsigned int LATF7:1; 
....................    unsigned int LATF8:1; 
....................    unsigned int LATF9:1; 
....................    unsigned int LATF10:1; 
....................    unsigned int LATF11:1; 
....................    unsigned int LATF12:1; 
....................    unsigned int LATF13:1; 
....................    unsigned int LATF14:1; 
....................    unsigned int LATF15:1; 
.................... } LATFBITS; 
.................... LATFBITS LATFbits; 
.................... #word LATFbits = 0x2EC 
.................... #word LATF = 0x2EC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ODF0:2; 
....................          unsigned int :1; 
....................          unsigned int ODF3:3; 
....................          unsigned int :1; 
....................          unsigned int ODF7:1; 
....................       }; 
....................       struct { 
....................          unsigned int ODF00:2; 
....................          unsigned int :1; 
....................          unsigned int ODF03:3; 
....................       }; 
.................... } ODCFBITS; 
.................... ODCFBITS ODCFbits; 
.................... #word ODCFbits = 0x2EE 
.................... #word ODCF = 0x2EE 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISG0:1; 
....................    unsigned int TRISG1:1; 
....................    unsigned int TRISG2:1; 
....................    unsigned int TRISG3:1; 
....................    unsigned int TRISG4:1; 
....................    unsigned int TRISG5:1; 
....................    unsigned int TRISG6:1; 
....................    unsigned int TRISG7:1; 
....................    unsigned int TRISG8:1; 
....................    unsigned int TRISG9:1; 
....................    unsigned int TRISG10:1; 
....................    unsigned int TRISG11:1; 
....................    unsigned int TRISG12:1; 
....................    unsigned int TRISG13:1; 
....................    unsigned int TRISG14:1; 
....................    unsigned int TRISG15:1; 
.................... } TRISGBITS; 
.................... TRISGBITS TRISGbits; 
.................... #word TRISGbits = 0x2F0 
.................... #word TRISG = 0x2F0 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RG0:1; 
....................    unsigned int RG1:1; 
....................    unsigned int RG2:1; 
....................    unsigned int RG3:1; 
....................    unsigned int RG4:1; 
....................    unsigned int RG5:1; 
....................    unsigned int RG6:1; 
....................    unsigned int RG7:1; 
....................    unsigned int RG8:1; 
....................    unsigned int RG9:1;   
....................    unsigned int RG10:1; 
....................    unsigned int RG11:1; 
....................    unsigned int RG12:1; 
....................    unsigned int RG13:1; 
....................    unsigned int RG14:1; 
....................    unsigned int RG15:1; 
.................... } PORTGBITS; 
.................... PORTGBITS PORTGbits; 
.................... #word PORTGbits = 0x2F2 
.................... #word PORTG = 0x2F2 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATG0:1; 
....................    unsigned int LATG1:1; 
....................    unsigned int LATG2:1; 
....................    unsigned int LATG3:1; 
....................    unsigned int LATG4:1; 
....................    unsigned int LATG5:1; 
....................    unsigned int LATG6:1; 
....................    unsigned int LATG7:1; 
....................    unsigned int LATG8:1; 
....................    unsigned int LATG9:1; 
....................    unsigned int LATG10:1; 
....................    unsigned int LATG11:1; 
....................    unsigned int LATG12:1; 
....................    unsigned int LATG13:1; 
....................    unsigned int LATG14:1; 
....................    unsigned int LATG15:1; 
.................... } LATGBITS; 
.................... LATGBITS LATGbits; 
.................... #word LATGbits = 0x2F4 
.................... #word LATG = 0x2F4 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :2; 
....................    unsigned int ODG2:2; 
....................    unsigned int :2; 
....................    unsigned int ODG6:4; 
.................... } ODCGBITS; 
.................... ODCGBITS ODCGbits; 
.................... #word ODCGbits = 0x2F6 
.................... #word ODCG = 0x2F6 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int PMPTTL:1; 
....................          unsigned int RTSECSEL:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int RTSECSEL0:1; 
....................       }; 
....................    }; 
.................... } PADCFG1BITS; 
.................... PADCFG1BITS PADCFG1bits; 
.................... #word PADCFG1bits = 0x2FC 
.................... #word PADCFG1 = 0x2FC 
....................  
.................... #word ADC1BUF0 = 0x300 
....................  
.................... #word ADC1BUF1 = 0x302 
....................  
.................... #word ADC1BUF2 = 0x304 
....................  
.................... #word ADC1BUF3 = 0x306 
....................  
.................... #word ADC1BUF4 = 0x308 
....................  
.................... #word ADC1BUF5 = 0x30A 
....................  
.................... #word ADC1BUF6 = 0x30C 
....................  
.................... #word ADC1BUF7 = 0x30E 
....................  
.................... #word ADC1BUF8 = 0x310 
....................  
.................... #word ADC1BUF9 = 0x312 
....................  
.................... #word ADC1BUFA = 0x314 
....................  
.................... #word ADC1BUFB = 0x316 
....................  
.................... #word ADC1BUFC = 0x318 
....................  
.................... #word ADC1BUFD = 0x31A 
....................  
.................... #word ADC1BUFE = 0x31C 
....................  
.................... #word ADC1BUFF = 0x31E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int DONE:1; 
....................          unsigned int SAMP:1; 
....................          unsigned int ASAM:1; 
....................          unsigned int :2; 
....................          unsigned int SSRC0:3; 
....................          unsigned int FORM0:2; 
....................          unsigned int :3; 
....................          unsigned int ADSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int ADON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :2; 
....................          unsigned int SSRC:3; 
....................          unsigned int FORM:2; 
....................          unsigned int :3; 
....................       }; 
.................... } AD1CON1BITS; 
.................... AD1CON1BITS AD1CON1bits; 
.................... #word AD1CON1bits = 0x320 
.................... #word AD1CON1 = 0x320 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ALTS:1; 
....................          unsigned int BUFM:1; 
....................          unsigned int SMPI0:5; 
....................          unsigned int BUFS:1; 
....................          unsigned int :2; 
....................          unsigned int CSCNA:1; 
....................          unsigned int :2; 
....................          unsigned int VCFG0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SMPI:5; 
....................          unsigned int :1; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :2; 
....................          unsigned int VCFG:3; 
....................       }; 
.................... } AD1CON2BITS; 
.................... AD1CON2BITS AD1CON2bits; 
.................... #word AD1CON2bits = 0x322 
.................... #word AD1CON2 = 0x322 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ADCS0:8; 
....................          unsigned int SAMC0:5; 
....................          unsigned int :2; 
....................          unsigned int ADRC:1; 
....................       }; 
....................       struct { 
....................          unsigned int ADCS:8; 
....................          unsigned int SAMC:5; 
....................          unsigned int :2; 
....................       }; 
.................... } AD1CON3BITS; 
.................... AD1CON3BITS AD1CON3bits; 
.................... #word AD1CON3bits = 0x324 
.................... #word AD1CON3 = 0x324 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CH0SA0:5; 
....................          unsigned int :2; 
....................          unsigned int CH0NA:1; 
....................          unsigned int CH0SB0:5; 
....................          unsigned int :2; 
....................          unsigned int CH0NB:1; 
....................       }; 
....................       struct { 
....................          unsigned int CH0SA:5; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int CH0SB:5; 
....................          unsigned int :2; 
....................       }; 
.................... } AD1CHSBITS; 
.................... AD1CHSBITS AD1CHSbits; 
.................... #word AD1CHSbits = 0x328 
.................... #word AD1CHS = 0x328 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :8; 
....................    unsigned int CSSL24:4; 
.................... } AD1CSSHBITS; 
.................... AD1CSSHBITS AD1CSSHbits; 
.................... #word AD1CSSHbits = 0x32E 
.................... #word AD1CSSH = 0x32E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CSSL0:16; 
....................       }; 
....................       struct { 
....................          unsigned int CSSL:16; 
....................       }; 
.................... } AD1CSSLBITS; 
.................... AD1CSSLBITS AD1CSSLbits; 
.................... #word AD1CSSLbits = 0x330 
.................... #word AD1CSSL = 0x330 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EDG1STAT:1; 
....................          unsigned int EDG2STAT:1; 
....................          unsigned int EDG1SEL0:2; 
....................          unsigned int EDG1POL:1; 
....................          unsigned int EDG2SEL0:2; 
....................          unsigned int EDG2POL:1; 
....................          unsigned int CTTRIG:1; 
....................          unsigned int IDISSEN:1; 
....................          unsigned int EDGSEQEN:1; 
....................          unsigned int EDGEN:1; 
....................          unsigned int TGEN:1; 
....................          unsigned int CTMUSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int CTMUEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int EDG1SEL:2; 
....................          unsigned int :1; 
....................          unsigned int EDG2SEL:2; 
....................       }; 
.................... } CTMUCONBITS; 
.................... CTMUCONBITS CTMUCONbits; 
.................... #word CTMUCONbits = 0x33C 
.................... #word CTMUCON = 0x33C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int IRNG0:2; 
....................          unsigned int ITRIM0:6; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int IRNG:2; 
....................          unsigned int ITRIM:6; 
....................       }; 
.................... } CTMUICONBITS; 
.................... CTMUICONBITS CTMUICONbits; 
.................... #word CTMUICONbits = 0x33E 
.................... #word CTMUICON = 0x33E 
....................  
.................... #word ADC1BUF10 = 0x340 
....................  
.................... #word ADC1BUF11 = 0x342 
....................  
.................... #word ADC1BUF12 = 0x344 
....................  
.................... #word ADC1BUF13 = 0x346 
....................  
.................... #word ADC1BUF14 = 0x348 
....................  
.................... #word ADC1BUF15 = 0x34A 
....................  
.................... #word ADC1BUF16 = 0x34C 
....................  
.................... #word ADC1BUF17 = 0x34E 
....................  
.................... #word ADC1BUF18 = 0x350 
....................  
.................... #word ADC1BUF19 = 0x352 
....................  
.................... #word ADC1BUF1A = 0x354 
....................  
.................... #word ADC1BUF1B = 0x356 
....................  
.................... #word ADC1BUF1C = 0x358 
....................  
.................... #word ADC1BUF1D = 0x35A 
....................  
.................... #word ADC1BUF1E = 0x35C 
....................  
.................... #word ADC1BUF1F = 0x35E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int VBUSVDIF:1; 
....................    unsigned int :1; 
....................    unsigned int SESENDIF:1; 
....................    unsigned int SESVDIF:1; 
....................    unsigned int ACTVIF:1; 
....................    unsigned int LSTATEIF:1; 
....................    unsigned int T1MSECIF:1; 
....................    unsigned int IDIF:1; 
.................... } U1OTGIRBITS; 
.................... U1OTGIRBITS U1OTGIRbits; 
.................... #word U1OTGIRbits = 0x480 
.................... #word U1OTGIR = 0x480 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int VBUSVDIE:1; 
....................    unsigned int :1; 
....................    unsigned int SESENDIE:1; 
....................    unsigned int SESVDIE:1; 
....................    unsigned int ACTVIE:1; 
....................    unsigned int LSTATEIE:1; 
....................    unsigned int T1MSECIE:1; 
....................    unsigned int IDIE:1; 
.................... } U1OTGIEBITS; 
.................... U1OTGIEBITS U1OTGIEbits; 
.................... #word U1OTGIEbits = 0x482 
.................... #word U1OTGIE = 0x482 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int VBUSVD:1; 
....................    unsigned int :1; 
....................    unsigned int SESEND:1; 
....................    unsigned int SESVD:1; 
....................    unsigned int :1; 
....................    unsigned int LSTATE:1; 
....................    unsigned int :1; 
....................    unsigned int ID:1; 
.................... } U1OTGSTATBITS; 
.................... U1OTGSTATBITS U1OTGSTATbits; 
.................... #word U1OTGSTATbits = 0x484 
.................... #word U1OTGSTAT = 0x484 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int VBUSDIS:1; 
....................    unsigned int VBUSCHG:1; 
....................    unsigned int OTGEN:1; 
....................    unsigned int VBUSON:1; 
....................    unsigned int DMPULDWN:1; 
....................    unsigned int DPPULDWN:1; 
....................    unsigned int DMPULUP:1; 
....................    unsigned int DPPULUP:1; 
.................... } U1OTGCONBITS; 
.................... U1OTGCONBITS U1OTGCONbits; 
.................... #word U1OTGCONbits = 0x486 
.................... #word U1OTGCON = 0x486 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int USBPWR:1; 
....................          unsigned int USUSPND:1; 
....................          unsigned int :2; 
....................          unsigned int USLPGRD:1; 
....................          unsigned int :2; 
....................          unsigned int UACTPND:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int USUSPEND:1; 
....................       }; 
....................    }; 
.................... } U1PWRCBITS; 
.................... U1PWRCBITS U1PWRCbits; 
.................... #word U1PWRCbits = 0x488 
.................... #word U1PWRC = 0x488 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int URSTIF:1; 
....................          unsigned int UERRIF:1; 
....................          unsigned int SOFIF:1; 
....................          unsigned int TRNIF:1; 
....................          unsigned int IDLEIF:1; 
....................          unsigned int RESUMEIF:1; 
....................          unsigned int ATTACHIF:1; 
....................          unsigned int STALLIF:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int DETACHIF:1; 
....................       }; 
....................    }; 
.................... } U1IRBITS; 
.................... U1IRBITS U1IRbits; 
.................... #word U1IRbits = 0x48A 
.................... #word U1IR = 0x48A 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int URSTIE:1; 
....................          unsigned int UERRIE:1; 
....................          unsigned int SOFIE:1; 
....................          unsigned int TRNIE:1; 
....................          unsigned int IDLEIE:1; 
....................          unsigned int RESUMEIE:1; 
....................          unsigned int ATTACHIE:1; 
....................          unsigned int STALLIE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int DETACHIE:1; 
....................       }; 
....................    }; 
.................... } U1IEBITS; 
.................... U1IEBITS U1IEbits; 
.................... #word U1IEbits = 0x48C 
.................... #word U1IE = 0x48C 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int PIDEF:1; 
....................          unsigned int CRC5EF:1; 
....................          unsigned int CRC16EF:1; 
....................          unsigned int DFN8EF:1; 
....................          unsigned int BTOEF:1; 
....................          unsigned int DMAEF:1; 
....................          unsigned int :1; 
....................          unsigned int BTSEF:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int EOFEF:1; 
....................       }; 
....................    }; 
.................... } U1EIRBITS; 
.................... U1EIRBITS U1EIRbits; 
.................... #word U1EIRbits = 0x48E 
.................... #word U1EIR = 0x48E 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int PIDEE:1; 
....................          unsigned int CRC5EE:1; 
....................          unsigned int CRC16EE:1; 
....................          unsigned int DFN8EE:1; 
....................          unsigned int BTOEE:1; 
....................          unsigned int DMAEE:1; 
....................          unsigned int :1; 
....................          unsigned int BTSEE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int EOFEE:1; 
....................       }; 
....................    }; 
.................... } U1EIEBITS; 
.................... U1EIEBITS U1EIEbits; 
.................... #word U1EIEbits = 0x490 
.................... #word U1EIE = 0x490 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int PPBI:1; 
....................          unsigned int DIR:1; 
....................          unsigned int ENDPT0:4; 
....................       }; 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ENDPT:4; 
....................       }; 
.................... } U1STATBITS; 
.................... U1STATBITS U1STATbits; 
.................... #word U1STATbits = 0x492 
.................... #word U1STAT = 0x492 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int USBEN:1; 
....................          unsigned int PPBRST:1; 
....................          unsigned int RESUME:1; 
....................          unsigned int HOSTEN:1; 
....................          unsigned int USBRST:1; 
....................          unsigned int PKTDIS:1; 
....................          unsigned int SE0:1; 
....................          unsigned int JSTATE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int SOFEN:1; 
....................          unsigned int :3; 
....................          unsigned int RESET:1; 
....................          unsigned int TOKBUSY:1; 
....................       }; 
....................    }; 
.................... } U1CONBITS; 
.................... U1CONBITS U1CONbits; 
.................... #word U1CONbits = 0x494 
.................... #word U1CON = 0x494 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int DEVADDR0:7; 
....................          unsigned int LOWSPDEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int DEVADDR:7; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :7; 
....................          unsigned int LSPDEN:1; 
....................       }; 
....................    }; 
.................... } U1ADDRBITS; 
.................... U1ADDRBITS U1ADDRbits; 
.................... #word U1ADDRbits = 0x496 
.................... #word U1ADDR = 0x496 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int BDTPTRL0:7; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int BDTPTRL:7; 
....................       }; 
.................... } U1BDTP1BITS; 
.................... U1BDTP1BITS U1BDTP1bits; 
.................... #word U1BDTP1bits = 0x498 
.................... #word U1BDTP1 = 0x498 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int FRM0:8; 
....................       }; 
....................       struct { 
....................          unsigned int FRM:8; 
....................       }; 
.................... } U1FRMLBITS; 
.................... U1FRMLBITS U1FRMLbits; 
.................... #word U1FRMLbits = 0x49A 
.................... #word U1FRML = 0x49A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int FRM8:3; 
.................... } U1FRMHBITS; 
.................... U1FRMHBITS U1FRMHbits; 
.................... #word U1FRMHbits = 0x49C 
.................... #word U1FRMH = 0x49C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EP0:4; 
....................          unsigned int PID0:4; 
....................       }; 
....................       struct { 
....................          unsigned int EP:4; 
....................          unsigned int PID:4; 
....................       }; 
.................... } U1TOKBITS; 
.................... U1TOKBITS U1TOKbits; 
.................... #word U1TOKbits = 0x49E 
.................... #word U1TOK = 0x49E 
....................  
.................... #word U1SOF = 0x4A0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CNT0:8; 
....................       }; 
....................       struct { 
....................          unsigned int CNT:8; 
....................       }; 
.................... } U1SOFBITS; 
.................... U1SOFBITS U1SOFbits; 
.................... #word U1SOFbits = 0x4A0 
.................... #word U1SOF = 0x4A0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PPB0:2; 
....................          unsigned int :2; 
....................          unsigned int USBSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int UOEMON:1; 
....................          unsigned int UTEYE:1; 
....................       }; 
....................       struct { 
....................          unsigned int PPB:2; 
....................          unsigned int :2; 
....................       }; 
.................... } U1CNFG1BITS; 
.................... U1CNFG1BITS U1CNFG1bits; 
.................... #word U1CNFG1bits = 0x4A6 
.................... #word U1CNFG1 = 0x4A6 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int UTRDIS:1; 
....................    unsigned int UVCMPDIS:1; 
....................    unsigned int UVBUSDIS:1; 
....................    unsigned int EXTI2CEN:1; 
....................    unsigned int PUVBUS:1; 
....................    unsigned int UVCMPSEL:1; 
.................... } U1CNFG2BITS; 
.................... U1CNFG2BITS U1CNFG2bits; 
.................... #word U1CNFG2bits = 0x4A8 
.................... #word U1CNFG2 = 0x4A8 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................          unsigned int :1; 
....................          unsigned int RETRYDIS:1; 
....................          unsigned int LSPD:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................          unsigned int :3; 
....................          unsigned int LOWSPD:1; 
....................       }; 
....................    }; 
.................... } U1EP0BITS; 
.................... U1EP0BITS U1EP0bits; 
.................... #word U1EP0bits = 0x4AA 
.................... #word U1EP0 = 0x4AA 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP1BITS; 
.................... U1EP1BITS U1EP1bits; 
.................... #word U1EP1bits = 0x4AC 
.................... #word U1EP1 = 0x4AC 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP2BITS; 
.................... U1EP2BITS U1EP2bits; 
.................... #word U1EP2bits = 0x4AE 
.................... #word U1EP2 = 0x4AE 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP3BITS; 
.................... U1EP3BITS U1EP3bits; 
.................... #word U1EP3bits = 0x4B0 
.................... #word U1EP3 = 0x4B0 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP4BITS; 
.................... U1EP4BITS U1EP4bits; 
.................... #word U1EP4bits = 0x4B2 
.................... #word U1EP4 = 0x4B2 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP5BITS; 
.................... U1EP5BITS U1EP5bits; 
.................... #word U1EP5bits = 0x4B4 
.................... #word U1EP5 = 0x4B4 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP6BITS; 
.................... U1EP6BITS U1EP6bits; 
.................... #word U1EP6bits = 0x4B6 
.................... #word U1EP6 = 0x4B6 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP7BITS; 
.................... U1EP7BITS U1EP7bits; 
.................... #word U1EP7bits = 0x4B8 
.................... #word U1EP7 = 0x4B8 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP8BITS; 
.................... U1EP8BITS U1EP8bits; 
.................... #word U1EP8bits = 0x4BA 
.................... #word U1EP8 = 0x4BA 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP9BITS; 
.................... U1EP9BITS U1EP9bits; 
.................... #word U1EP9bits = 0x4BC 
.................... #word U1EP9 = 0x4BC 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP10BITS; 
.................... U1EP10BITS U1EP10bits; 
.................... #word U1EP10bits = 0x4BE 
.................... #word U1EP10 = 0x4BE 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP11BITS; 
.................... U1EP11BITS U1EP11bits; 
.................... #word U1EP11bits = 0x4C0 
.................... #word U1EP11 = 0x4C0 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP12BITS; 
.................... U1EP12BITS U1EP12bits; 
.................... #word U1EP12bits = 0x4C2 
.................... #word U1EP12 = 0x4C2 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP13BITS; 
.................... U1EP13BITS U1EP13bits; 
.................... #word U1EP13bits = 0x4C4 
.................... #word U1EP13 = 0x4C4 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP14BITS; 
.................... U1EP14BITS U1EP14bits; 
.................... #word U1EP14bits = 0x4C6 
.................... #word U1EP14 = 0x4C6 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP15BITS; 
.................... U1EP15BITS U1EP15bits; 
.................... #word U1EP15bits = 0x4C8 
.................... #word U1EP15 = 0x4C8 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int PER0:8; 
....................          unsigned int DC0:8; 
....................       }; 
....................       struct { 
....................          unsigned int PER:8; 
....................          unsigned int DC:8; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int USBRS0:8; 
....................          unsigned int USBR0:8; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int USBRS:8; 
....................          unsigned int USBR:8; 
....................       }; 
.................... } U1PWMRRSBITS; 
.................... U1PWMRRSBITS U1PWMRRSbits; 
.................... #word U1PWMRRSbits = 0x4CC 
.................... #word U1PWMRRS = 0x4CC 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :8; 
....................    unsigned int CNTEN:1; 
....................    unsigned int PWMPOL:1; 
....................    unsigned int :5; 
....................    unsigned int PWMEN:1; 
.................... } U1PWMCONBITS; 
.................... U1PWMCONBITS U1PWMCONbits; 
.................... #word U1PWMCONbits = 0x4CE 
.................... #word U1PWMCON = 0x4CE 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int VBGEN:1; 
....................    unsigned int VBG2EN:1; 
....................    unsigned int VBG6EN:1; 
.................... } ANCFGBITS; 
.................... ANCFGBITS ANCFGbits; 
.................... #word ANCFGbits = 0x4DE 
.................... #word ANCFG = 0x4DE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ANSB0:16; 
....................       }; 
....................       struct { 
....................          unsigned int ANSB:16; 
....................       }; 
.................... } ANSBBITS; 
.................... ANSBBITS ANSBbits; 
.................... #word ANSBbits = 0x4E2 
.................... #word ANSB = 0x4E2 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :13; 
....................    unsigned int ANSC13:2; 
.................... } ANSCBITS; 
.................... ANSCBITS ANSCbits; 
.................... #word ANSCbits = 0x4E4 
.................... #word ANSC = 0x4E4 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :6; 
....................    unsigned int ANSD6:2; 
.................... } ANSDBITS; 
.................... ANSDBITS ANSDbits; 
.................... #word ANSDbits = 0x4E6 
.................... #word ANSD = 0x4E6 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int ANSF0:1; 
.................... } ANSFBITS; 
.................... ANSFBITS ANSFbits; 
.................... #word ANSFbits = 0x4EA 
.................... #word ANSF = 0x4EA 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :6; 
....................    unsigned int ANSG6:4; 
.................... } ANSGBITS; 
.................... ANSGBITS ANSGbits; 
.................... #word ANSGbits = 0x4EC 
.................... #word ANSG = 0x4EC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IRQM0:2; 
....................          unsigned int BUSKEEP:1; 
....................          unsigned int :1; 
....................          unsigned int ALMODE:1; 
....................          unsigned int ALP:1; 
....................          unsigned int CSF0:2; 
....................          unsigned int MODE0:2; 
....................          unsigned int :1; 
....................          unsigned int ADRMUX0:2; 
....................          unsigned int PSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int PMPEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int IRQM:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int CSF:2; 
....................          unsigned int MODE:2; 
....................          unsigned int :1; 
....................          unsigned int ADRMUX:2; 
....................       }; 
.................... } PMCON1BITS; 
.................... PMCON1BITS PMCON1bits; 
.................... #word PMCON1bits = 0x600 
.................... #word PMCON1 = 0x600 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int RADDR0:8; 
....................          unsigned int :4; 
....................          unsigned int TIMEOUT:1; 
....................          unsigned int ERROR:1; 
....................          unsigned int :1; 
....................          unsigned int BUSY:1; 
....................       }; 
....................       struct { 
....................          unsigned int RADDR:8; 
....................          unsigned int :4; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int RADDR16:4; 
....................          unsigned int RADDR20:4; 
....................       }; 
....................    }; 
.................... } PMCON2BITS; 
.................... PMCON2BITS PMCON2bits; 
.................... #word PMCON2bits = 0x602 
.................... #word PMCON2 = 0x602 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RES0:7; 
....................          unsigned int :1; 
....................          unsigned int AWAITE:1; 
....................          unsigned int AWAITM0:2; 
....................          unsigned int :1; 
....................          unsigned int PTBE0EN:1; 
....................          unsigned int PTBE1EN:1; 
....................          unsigned int PTRDEN:1; 
....................          unsigned int PTWREN:1; 
....................       }; 
....................       struct { 
....................          unsigned int RES:7; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int AWAITM:2; 
....................       }; 
.................... } PMCON3BITS; 
.................... PMCON3BITS PMCON3bits; 
.................... #word PMCON3bits = 0x604 
.................... #word PMCON3 = 0x604 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PTEN0:16; 
....................       }; 
....................       struct { 
....................          unsigned int PTEN:16; 
....................       }; 
.................... } PMCON4BITS; 
.................... PMCON4BITS PMCON4bits; 
.................... #word PMCON4bits = 0x606 
.................... #word PMCON4 = 0x606 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int PTSZ0:2; 
....................          unsigned int ACKP:1; 
....................          unsigned int SM:1; 
....................          unsigned int RDSP:1; 
....................          unsigned int WRSP:1; 
....................          unsigned int :1; 
....................          unsigned int BEP:1; 
....................          unsigned int CSPTEN:1; 
....................          unsigned int CSP:1; 
....................          unsigned int CSDIS:1; 
....................       }; 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int PTSZ:2; 
....................       }; 
.................... } PMCS1CFBITS; 
.................... PMCS1CFBITS PMCS1CFbits; 
.................... #word PMCS1CFbits = 0x608 
.................... #word PMCS1CF = 0x608 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :3; 
....................    unsigned int BASE11:1; 
....................    unsigned int :3; 
....................    unsigned int BASE15:5; 
....................    unsigned int BASE20:4; 
.................... } PMCS1BSBITS; 
.................... PMCS1BSBITS PMCS1BSbits; 
.................... #word PMCS1BSbits = 0x60A 
.................... #word PMCS1BS = 0x60A 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int DWAITE0:2; 
....................          unsigned int DWAITM0:4; 
....................          unsigned int DWAITB0:2; 
....................          unsigned int :6; 
....................          unsigned int ACKM0:2; 
....................       }; 
....................       struct { 
....................          unsigned int DWAITE:2; 
....................          unsigned int DWAITM:4; 
....................          unsigned int DWAITB:2; 
....................          unsigned int :6; 
....................          unsigned int ACKM:2; 
....................       }; 
.................... } PMCS1MDBITS; 
.................... PMCS1MDBITS PMCS1MDbits; 
.................... #word PMCS1MDbits = 0x60C 
.................... #word PMCS1MD = 0x60C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int PTSZ0:2; 
....................          unsigned int ACKP:1; 
....................          unsigned int SM:1; 
....................          unsigned int RDSP:1; 
....................          unsigned int WRSP:1; 
....................          unsigned int :1; 
....................          unsigned int BEP:1; 
....................          unsigned int CSPTEN:1; 
....................          unsigned int CSP:1; 
....................          unsigned int CSDIS:1; 
....................       }; 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int PTSZ:2; 
....................       }; 
.................... } PMCS2CFBITS; 
.................... PMCS2CFBITS PMCS2CFbits; 
.................... #word PMCS2CFbits = 0x60E 
.................... #word PMCS2CF = 0x60E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :3; 
....................    unsigned int BASE11:1; 
....................    unsigned int :3; 
....................    unsigned int BASE15:5; 
....................    unsigned int BASE20:4; 
.................... } PMCS2BSBITS; 
.................... PMCS2BSBITS PMCS2BSbits; 
.................... #word PMCS2BSbits = 0x610 
.................... #word PMCS2BS = 0x610 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int DWAITE0:2; 
....................          unsigned int DWAITM0:4; 
....................          unsigned int DWAITB0:2; 
....................          unsigned int :6; 
....................          unsigned int ACKM0:2; 
....................       }; 
....................       struct { 
....................          unsigned int DWAITE:2; 
....................          unsigned int DWAITM:4; 
....................          unsigned int DWAITB:2; 
....................          unsigned int :6; 
....................          unsigned int ACKM:2; 
....................       }; 
.................... } PMCS2MDBITS; 
.................... PMCS2MDBITS PMCS2MDbits; 
.................... #word PMCS2MDbits = 0x612 
.................... #word PMCS2MD = 0x612 
....................  
.................... #word PMDOUT1 = 0x614 
....................  
.................... #word PMDOUT2 = 0x616 
....................  
.................... #word PMDIN1 = 0x618 
....................  
.................... #word PMDIN2 = 0x61A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int OB0E:1; 
....................    unsigned int OB1E:1; 
....................    unsigned int OB2E:1; 
....................    unsigned int OB3E:1; 
....................    unsigned int :2; 
....................    unsigned int OBUF:1; 
....................    unsigned int OBE:1; 
....................    unsigned int IB0F:1; 
....................    unsigned int IB1F:1; 
....................    unsigned int IB2F:1; 
....................    unsigned int IB3F:1; 
....................    unsigned int :2; 
....................    unsigned int IBOV:1; 
....................    unsigned int IBF:1; 
.................... } PMSTATBITS; 
.................... PMSTATBITS PMSTATbits; 
.................... #word PMSTATbits = 0x61C 
.................... #word PMSTAT = 0x61C 
....................  
.................... #word ALRMVAL = 0x620 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ARPT0:8; 
....................          unsigned int ALRMPTR0:2; 
....................          unsigned int AMASK0:4; 
....................          unsigned int CHIME:1; 
....................          unsigned int ALRMEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int ARPT:8; 
....................          unsigned int ALRMPTR:2; 
....................          unsigned int AMASK:4; 
....................       }; 
.................... } ALCFGRPTBITS; 
.................... ALCFGRPTBITS ALCFGRPTbits; 
.................... #word ALCFGRPTbits = 0x622 
.................... #word ALCFGRPT = 0x622 
....................  
.................... #word RTCVAL = 0x624 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CAL0:1; 
....................          unsigned int CAL1:1; 
....................          unsigned int CAL2:1; 
....................          unsigned int CAL3:1; 
....................          unsigned int CAL4:1; 
....................          unsigned int CAL5:1; 
....................          unsigned int CAL6:1; 
....................          unsigned int CAL7:1; 
....................          unsigned int RTCPTR0:1; 
....................          unsigned int RTCPTR1:1; 
....................          unsigned int RTCOE:1; 
....................          unsigned int HALFSEC:1; 
....................          unsigned int RTCSYNC:1; 
....................          unsigned int RTCWREN:1; 
....................          unsigned int :1; 
....................          unsigned int RTCEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int CAL:8; 
....................          unsigned int RTCPTR:2; 
....................       }; 
.................... } RCFGCALBITS; 
.................... RCFGCALBITS RCFGCALbits; 
.................... #word RCFGCALbits = 0x626 
.................... #word RCFGCAL = 0x626 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
....................    unsigned int C3OUT:1; 
....................    unsigned int :5; 
....................    unsigned int C1EVT:1; 
....................    unsigned int C2EVT:1; 
....................    unsigned int C3EVT:1; 
....................    unsigned int :4; 
....................    unsigned int CMIDL:1; 
.................... } CMSTATBITS; 
.................... CMSTATBITS CMSTATbits; 
.................... #word CMSTATbits = 0x630 
.................... #word CMSTAT = 0x630 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CVR0:4; 
....................          unsigned int CVRSS:1; 
....................          unsigned int CVRR:1; 
....................          unsigned int CVROE:1; 
....................          unsigned int CVREN:1; 
....................          unsigned int CVREFM0:2; 
....................          unsigned int CVREFP:1; 
....................       }; 
....................       struct { 
....................          unsigned int CVR:4; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int CVREFM:2; 
....................       }; 
.................... } CVRCONBITS; 
.................... CVRCONBITS CVRCONbits; 
.................... #word CVRCONbits = 0x632 
.................... #word CVRCON = 0x632 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int CCH0:2; 
....................          unsigned int :2; 
....................          unsigned int CREF:1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL0:2; 
....................          unsigned int COUT:1; 
....................          unsigned int CEVT:1; 
....................          unsigned int :3; 
....................          unsigned int CPOL:1; 
....................          unsigned int COE:1; 
....................          unsigned int CON:1; 
....................       }; 
....................       struct { 
....................          unsigned int CCH:2; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int CEN:1; 
....................       }; 
....................    }; 
.................... } CM1CONBITS; 
.................... CM1CONBITS CM1CONbits; 
.................... #word CM1CONbits = 0x634 
.................... #word CM1CON = 0x634 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int CCH0:2; 
....................          unsigned int :2; 
....................          unsigned int CREF:1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL0:2; 
....................          unsigned int COUT:1; 
....................          unsigned int CEVT:1; 
....................          unsigned int :3; 
....................          unsigned int CPOL:1; 
....................          unsigned int COE:1; 
....................          unsigned int CON:1; 
....................       }; 
....................       struct { 
....................          unsigned int CCH:2; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int CEN:1; 
....................       }; 
....................    }; 
.................... } CM2CONBITS; 
.................... CM2CONBITS CM2CONbits; 
.................... #word CM2CONbits = 0x636 
.................... #word CM2CON = 0x636 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int CCH0:2; 
....................          unsigned int :2; 
....................          unsigned int CREF:1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL0:2; 
....................          unsigned int COUT:1; 
....................          unsigned int CEVT:1; 
....................          unsigned int :3; 
....................          unsigned int CPOL:1; 
....................          unsigned int COE:1; 
....................          unsigned int CON:1; 
....................       }; 
....................       struct { 
....................          unsigned int CCH:2; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int CEN:1; 
....................       }; 
....................    }; 
.................... } CM3CONBITS; 
.................... CM3CONBITS CM3CONbits; 
.................... #word CM3CONbits = 0x638 
.................... #word CM3CON = 0x638 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int LENDIAN:1; 
....................          unsigned int CRCGO:1; 
....................          unsigned int CRCISEL:1; 
....................          unsigned int CRCMPT:1; 
....................          unsigned int CRCFUL:1; 
....................          unsigned int VWORD0:5; 
....................          unsigned int CSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int CRCEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int VWORD:5; 
....................       }; 
.................... } CRCCON1BITS; 
.................... CRCCON1BITS CRCCON1bits; 
.................... #word CRCCON1bits = 0x640 
.................... #word CRCCON1 = 0x640 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PLEN0:5; 
....................          unsigned int :3; 
....................          unsigned int DWIDTH0:5; 
....................       }; 
....................       struct { 
....................          unsigned int PLEN:5; 
....................          unsigned int :3; 
....................          unsigned int DWIDTH:5; 
....................       }; 
.................... } CRCCON2BITS; 
.................... CRCCON2BITS CRCCON2bits; 
.................... #word CRCCON2bits = 0x642 
.................... #word CRCCON2 = 0x642 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int X1:15; 
.................... } CRCXORLBITS; 
.................... CRCXORLBITS CRCXORLbits; 
.................... #word CRCXORLbits = 0x644 
.................... #word CRCXORL = 0x644 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int X16:4; 
....................    unsigned int X20:10; 
....................    unsigned int X30:2; 
.................... } CRCXORHBITS; 
.................... CRCXORHBITS CRCXORHbits; 
.................... #word CRCXORHbits = 0x646 
.................... #word CRCXORH = 0x646 
....................  
.................... #word CRCDAT = 0x648 
....................  
.................... #word CRCWDAT = 0x64C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int INT1R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int INT1R:6; 
....................       }; 
.................... } RPINR0BITS; 
.................... RPINR0BITS RPINR0bits; 
.................... #word RPINR0bits = 0x680 
.................... #word RPINR0 = 0x680 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int INT2R0:6; 
....................          unsigned int :2; 
....................          unsigned int INT3R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int INT2R:6; 
....................          unsigned int :2; 
....................          unsigned int INT3R:6; 
....................       }; 
.................... } RPINR1BITS; 
.................... RPINR1BITS RPINR1bits; 
.................... #word RPINR1bits = 0x682 
.................... #word RPINR1 = 0x682 
....................  
.................... #word RPINR2 = 0x684 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int T2CKR0:6; 
....................          unsigned int :2; 
....................          unsigned int T3CKR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int T2CKR:6; 
....................          unsigned int :2; 
....................          unsigned int T3CKR:6; 
....................       }; 
.................... } RPINR3BITS; 
.................... RPINR3BITS RPINR3bits; 
.................... #word RPINR3bits = 0x686 
.................... #word RPINR3 = 0x686 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int T4CKR0:6; 
....................          unsigned int :2; 
....................          unsigned int T5CKR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int T4CKR:6; 
....................          unsigned int :2; 
....................          unsigned int T5CKR:6; 
....................       }; 
.................... } RPINR4BITS; 
.................... RPINR4BITS RPINR4bits; 
.................... #word RPINR4bits = 0x688 
.................... #word RPINR4 = 0x688 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IC1R0:6; 
....................          unsigned int :2; 
....................          unsigned int IC2R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int IC1R:6; 
....................          unsigned int :2; 
....................          unsigned int IC2R:6; 
....................       }; 
.................... } RPINR7BITS; 
.................... RPINR7BITS RPINR7bits; 
.................... #word RPINR7bits = 0x68E 
.................... #word RPINR7 = 0x68E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IC3R0:6; 
....................          unsigned int :2; 
....................          unsigned int IC4R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int IC3R:6; 
....................          unsigned int :2; 
....................          unsigned int IC4R:6; 
....................       }; 
.................... } RPINR8BITS; 
.................... RPINR8BITS RPINR8bits; 
.................... #word RPINR8bits = 0x690 
.................... #word RPINR8 = 0x690 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IC5R0:6; 
....................          unsigned int :2; 
....................          unsigned int IC6R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int IC5R:6; 
....................          unsigned int :2; 
....................          unsigned int IC6R:6; 
....................       }; 
.................... } RPINR9BITS; 
.................... RPINR9BITS RPINR9bits; 
.................... #word RPINR9bits = 0x692 
.................... #word RPINR9 = 0x692 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IC7R0:6; 
....................          unsigned int :2; 
....................          unsigned int IC8R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int IC7R:6; 
....................          unsigned int :2; 
....................          unsigned int IC8R:6; 
....................       }; 
.................... } RPINR10BITS; 
.................... RPINR10BITS RPINR10bits; 
.................... #word RPINR10bits = 0x694 
.................... #word RPINR10 = 0x694 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCFAR0:6; 
....................          unsigned int :2; 
....................          unsigned int OCFBR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int OCFAR:6; 
....................          unsigned int :2; 
....................          unsigned int OCFBR:6; 
....................       }; 
.................... } RPINR11BITS; 
.................... RPINR11BITS RPINR11bits; 
.................... #word RPINR11bits = 0x696 
.................... #word RPINR11 = 0x696 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int IC9R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int IC9R:6; 
....................       }; 
.................... } RPINR15BITS; 
.................... RPINR15BITS RPINR15bits; 
.................... #word RPINR15bits = 0x69E 
.................... #word RPINR15 = 0x69E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int U3RXR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int U3RXR:6; 
....................       }; 
.................... } RPINR17BITS; 
.................... RPINR17BITS RPINR17bits; 
.................... #word RPINR17bits = 0x6A2 
.................... #word RPINR17 = 0x6A2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int U1RXR0:6; 
....................          unsigned int :2; 
....................          unsigned int U1CTSR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int U1RXR:6; 
....................          unsigned int :2; 
....................          unsigned int U1CTSR:6; 
....................       }; 
.................... } RPINR18BITS; 
.................... RPINR18BITS RPINR18bits; 
.................... #word RPINR18bits = 0x6A4 
.................... #word RPINR18 = 0x6A4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int U2RXR0:6; 
....................          unsigned int :2; 
....................          unsigned int U2CTSR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int U2RXR:6; 
....................          unsigned int :2; 
....................          unsigned int U2CTSR:6; 
....................       }; 
.................... } RPINR19BITS; 
.................... RPINR19BITS RPINR19bits; 
.................... #word RPINR19bits = 0x6A6 
.................... #word RPINR19 = 0x6A6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SDI1R0:6; 
....................          unsigned int :2; 
....................          unsigned int SCK1R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int SDI1R:6; 
....................          unsigned int :2; 
....................          unsigned int SCK1R:6; 
....................       }; 
.................... } RPINR20BITS; 
.................... RPINR20BITS RPINR20bits; 
.................... #word RPINR20bits = 0x6A8 
.................... #word RPINR20 = 0x6A8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SS1R0:6; 
....................          unsigned int :2; 
....................          unsigned int U3CTSR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int SS1R:6; 
....................          unsigned int :2; 
....................          unsigned int U3CTSR:6; 
....................       }; 
.................... } RPINR21BITS; 
.................... RPINR21BITS RPINR21bits; 
.................... #word RPINR21bits = 0x6AA 
.................... #word RPINR21 = 0x6AA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SDI2R0:6; 
....................          unsigned int :2; 
....................          unsigned int SCK2R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int SDI2R:6; 
....................          unsigned int :2; 
....................          unsigned int SCK2R:6; 
....................       }; 
.................... } RPINR22BITS; 
.................... RPINR22BITS RPINR22bits; 
.................... #word RPINR22bits = 0x6AC 
.................... #word RPINR22 = 0x6AC 
....................  
.................... #word RPINR23 = 0x6AE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int U4RXR0:6; 
....................          unsigned int :2; 
....................          unsigned int U4CTSR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int U4RXR:6; 
....................          unsigned int :2; 
....................          unsigned int U4CTSR:6; 
....................       }; 
.................... } RPINR27BITS; 
.................... RPINR27BITS RPINR27bits; 
.................... #word RPINR27bits = 0x6B6 
.................... #word RPINR27 = 0x6B6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SDI3R0:6; 
....................          unsigned int :2; 
....................          unsigned int SCK3R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int SDI3R:6; 
....................          unsigned int :2; 
....................          unsigned int SCK3R:6; 
....................       }; 
.................... } RPINR28BITS; 
.................... RPINR28BITS RPINR28bits; 
.................... #word RPINR28bits = 0x6B8 
.................... #word RPINR28 = 0x6B8 
....................  
.................... #word RPINR29 = 0x6BA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP0R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP1R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP0R:6; 
....................          unsigned int :2; 
....................          unsigned int RP1R:6; 
....................       }; 
.................... } RPOR0BITS; 
.................... RPOR0BITS RPOR0bits; 
.................... #word RPOR0bits = 0x6C0 
.................... #word RPOR0 = 0x6C0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP2R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP3R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP2R:6; 
....................          unsigned int :2; 
....................          unsigned int RP3R:6; 
....................       }; 
.................... } RPOR1BITS; 
.................... RPOR1BITS RPOR1bits; 
.................... #word RPOR1bits = 0x6C2 
.................... #word RPOR1 = 0x6C2 
....................  
.................... #word RPOR2 = 0x6C4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP6R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP7R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP6R:6; 
....................          unsigned int :2; 
....................          unsigned int RP7R:6; 
....................       }; 
.................... } RPOR3BITS; 
.................... RPOR3BITS RPOR3bits; 
.................... #word RPOR3bits = 0x6C6 
.................... #word RPOR3 = 0x6C6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP8R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP9R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP8R:6; 
....................          unsigned int :2; 
....................          unsigned int RP9R:6; 
....................       }; 
.................... } RPOR4BITS; 
.................... RPOR4BITS RPOR4bits; 
.................... #word RPOR4bits = 0x6C8 
.................... #word RPOR4 = 0x6C8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP10R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP11R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP10R:6; 
....................          unsigned int :2; 
....................          unsigned int RP11R:6; 
....................       }; 
.................... } RPOR5BITS; 
.................... RPOR5BITS RPOR5bits; 
.................... #word RPOR5bits = 0x6CA 
.................... #word RPOR5 = 0x6CA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP12R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP13R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP12R:6; 
....................          unsigned int :2; 
....................          unsigned int RP13R:6; 
....................       }; 
.................... } RPOR6BITS; 
.................... RPOR6BITS RPOR6bits; 
.................... #word RPOR6bits = 0x6CC 
.................... #word RPOR6 = 0x6CC 
....................  
.................... #word RPOR7 = 0x6CE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP16R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP17R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP16R:6; 
....................          unsigned int :2; 
....................          unsigned int RP17R:6; 
....................       }; 
.................... } RPOR8BITS; 
.................... RPOR8BITS RPOR8bits; 
.................... #word RPOR8bits = 0x6D0 
.................... #word RPOR8 = 0x6D0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP18R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP19R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP18R:6; 
....................          unsigned int :2; 
....................          unsigned int RP19R:6; 
....................       }; 
.................... } RPOR9BITS; 
.................... RPOR9BITS RPOR9bits; 
.................... #word RPOR9bits = 0x6D2 
.................... #word RPOR9 = 0x6D2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP20R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP21R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP20R:6; 
....................          unsigned int :2; 
....................          unsigned int RP21R:6; 
....................       }; 
.................... } RPOR10BITS; 
.................... RPOR10BITS RPOR10bits; 
.................... #word RPOR10bits = 0x6D4 
.................... #word RPOR10 = 0x6D4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP22R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP23R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP22R:6; 
....................          unsigned int :2; 
....................          unsigned int RP23R:6; 
....................       }; 
.................... } RPOR11BITS; 
.................... RPOR11BITS RPOR11bits; 
.................... #word RPOR11bits = 0x6D6 
.................... #word RPOR11 = 0x6D6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP24R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP25R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP24R:6; 
....................          unsigned int :2; 
....................          unsigned int RP25R:6; 
....................       }; 
.................... } RPOR12BITS; 
.................... RPOR12BITS RPOR12bits; 
.................... #word RPOR12bits = 0x6D8 
.................... #word RPOR12 = 0x6D8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP26R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP27R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP26R:6; 
....................          unsigned int :2; 
....................          unsigned int RP27R:6; 
....................       }; 
.................... } RPOR13BITS; 
.................... RPOR13BITS RPOR13bits; 
.................... #word RPOR13bits = 0x6DA 
.................... #word RPOR13 = 0x6DA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP28R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP29R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP28R:6; 
....................          unsigned int :2; 
....................          unsigned int RP29R:6; 
....................       }; 
.................... } RPOR14BITS; 
.................... RPOR14BITS RPOR14bits; 
.................... #word RPOR14bits = 0x6DC 
.................... #word RPOR14 = 0x6DC 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int POR:1; 
....................          unsigned int BOR:1; 
....................          unsigned int IDLE:1; 
....................          unsigned int SLEEP:1; 
....................          unsigned int WDTO:1; 
....................          unsigned int SWDTEN:1; 
....................          unsigned int SWR:1; 
....................          unsigned int EXTR:1; 
....................          unsigned int VREGS:1; 
....................          unsigned int CM:1; 
....................          unsigned int :4; 
....................          unsigned int IOPUWR:1; 
....................          unsigned int TRAPR:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int PMSLP:1; 
....................       }; 
....................    }; 
.................... } RCONBITS; 
.................... RCONBITS RCONbits; 
.................... #word RCONbits = 0x740 
.................... #word RCON = 0x740 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int OSWEN:1; 
....................          unsigned int SOSCEN:1; 
....................          unsigned int POSCEN:1; 
....................          unsigned int CF:1; 
....................          unsigned int :1; 
....................          unsigned int LOCK:1; 
....................          unsigned int IOLOCK:1; 
....................          unsigned int CLKLOCK:1; 
....................          unsigned int NOSC0:3; 
....................          unsigned int :1; 
....................          unsigned int COSC0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int NOSC:3; 
....................          unsigned int :1; 
....................          unsigned int COSC:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int LPOSCEN:1; 
....................       }; 
....................    }; 
.................... } OSCCONBITS; 
.................... OSCCONBITS OSCCONbits; 
.................... #word OSCCONbits = 0x742 
.................... #word OSCCON = 0x742 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int PLLEN:1; 
....................          unsigned int CPDIV0:2; 
....................          unsigned int RCDIV0:3; 
....................          unsigned int DOZEN:1; 
....................          unsigned int DOZE0:3; 
....................          unsigned int ROI:1; 
....................       }; 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int :1; 
....................          unsigned int CPDIV:2; 
....................          unsigned int RCDIV:3; 
....................          unsigned int :1; 
....................          unsigned int DOZE:3; 
....................       }; 
.................... } CLKDIVBITS; 
.................... CLKDIVBITS CLKDIVbits; 
.................... #word CLKDIVbits = 0x744 
.................... #word CLKDIV = 0x744 
....................  
.................... #word OSCTUN = 0x748 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int RODIV0:4; 
....................          unsigned int ROSEL:1; 
....................          unsigned int ROSSLP:1; 
....................          unsigned int :1; 
....................          unsigned int ROEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int RODIV:4; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int ROON:1; 
....................       }; 
....................    }; 
.................... } REFOCONBITS; 
.................... REFOCONBITS REFOCONbits; 
.................... #word REFOCONbits = 0x74E 
.................... #word REFOCON = 0x74E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int NVMOP0:4; 
....................          unsigned int :2; 
....................          unsigned int ERASE:1; 
....................          unsigned int :6; 
....................          unsigned int WRERR:1; 
....................          unsigned int WREN:1; 
....................          unsigned int WR:1; 
....................       }; 
....................       struct { 
....................          unsigned int NVMOP:4; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } NVMCONBITS; 
.................... NVMCONBITS NVMCONbits; 
.................... #word NVMCONbits = 0x760 
.................... #word NVMCON = 0x760 
....................  
.................... #word NVMKEY = 0x766 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int ADC1MD:1; 
....................    unsigned int :2; 
....................    unsigned int SPI1MD:1; 
....................    unsigned int SPI2MD:1; 
....................    unsigned int U1MD:1; 
....................    unsigned int U2MD:1; 
....................    unsigned int I2C1MD:1; 
....................    unsigned int :3; 
....................    unsigned int T1MD:1; 
....................    unsigned int T2MD:1; 
....................    unsigned int T3MD:1; 
....................    unsigned int T4MD:1; 
....................    unsigned int T5MD:1; 
.................... } PMD1BITS; 
.................... PMD1BITS PMD1bits; 
.................... #word PMD1bits = 0x770 
.................... #word PMD1 = 0x770 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int OC1MD:1; 
....................    unsigned int OC2MD:1; 
....................    unsigned int OC3MD:1; 
....................    unsigned int OC4MD:1; 
....................    unsigned int OC5MD:1; 
....................    unsigned int OC6MD:1; 
....................    unsigned int OC7MD:1; 
....................    unsigned int OC8MD:1; 
....................    unsigned int IC1MD:1; 
....................    unsigned int IC2MD:1; 
....................    unsigned int IC3MD:1; 
....................    unsigned int IC4MD:1; 
....................    unsigned int IC5MD:1; 
....................    unsigned int IC6MD:1; 
....................    unsigned int IC7MD:1; 
....................    unsigned int IC8MD:1; 
.................... } PMD2BITS; 
.................... PMD2BITS PMD2bits; 
.................... #word PMD2bits = 0x772 
.................... #word PMD2 = 0x772 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int I2C2MD:1; 
....................          unsigned int I2C3MD:1; 
....................          unsigned int U3MD:1; 
....................          unsigned int :3; 
....................          unsigned int CRCMD:1; 
....................          unsigned int PMPMD:1; 
....................          unsigned int RTCCMD:1; 
....................          unsigned int CMPMD:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :7; 
....................          unsigned int CRCPMD:1; 
....................       }; 
....................    }; 
.................... } PMD3BITS; 
.................... PMD3BITS PMD3bits; 
.................... #word PMD3bits = 0x774 
.................... #word PMD3 = 0x774 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int USB1MD:1; 
....................    unsigned int LVDMD:1; 
....................    unsigned int CTMUMD:1; 
....................    unsigned int REFOMD:1; 
....................    unsigned int :1; 
....................    unsigned int U4MD:1; 
....................    unsigned int UPWMMD:1; 
.................... } PMD4BITS; 
.................... PMD4BITS PMD4bits; 
.................... #word PMD4bits = 0x776 
.................... #word PMD4 = 0x776 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int OC9MD:1; 
....................    unsigned int :7; 
....................    unsigned int IC9MD:1; 
.................... } PMD5BITS; 
.................... PMD5BITS PMD5bits; 
.................... #word PMD5bits = 0x778 
.................... #word PMD5 = 0x778 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPI3MD:1; 
.................... } PMD6BITS; 
.................... PMD6BITS PMD6bits; 
.................... #word PMD6bits = 0x77A 
.................... #word PMD6 = 0x77A 
....................  
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GA108__) || (getenv("DEVICE")=="PIC24FJ256GA108") 
....................     #if !defined(__PIC24FJ256GA108__) 
....................         #define __PIC24FJ256GA108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GA108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GA108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GA110__) || (getenv("DEVICE")=="PIC24FJ256GA110") 
....................     #if !defined(__PIC24FJ256GA110__) 
....................         #define __PIC24FJ256GA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GB106__) || (getenv("DEVICE")=="PIC24FJ256GB106") 
....................     #if !defined(__PIC24FJ256GB106__) 
....................         #define __PIC24FJ256GB106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GB106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GB106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GB108__) || (getenv("DEVICE")=="PIC24FJ256GB108") 
....................     #if !defined(__PIC24FJ256GB108__) 
....................         #define __PIC24FJ256GB108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GB108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GB108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GB110__) || (getenv("DEVICE")=="PIC24FJ256GB110") 
....................     #if !defined(__PIC24FJ256GB110__) 
....................         #define __PIC24FJ256GB110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GB110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GB110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GB206__) || (getenv("DEVICE")=="PIC24FJ256GB206") 
....................     #if !defined(__PIC24FJ256GB206__) 
....................         #define __PIC24FJ256GB206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GB206.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GB206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GB210__) || (getenv("DEVICE")=="PIC24FJ256GB210") 
....................     #if !defined(__PIC24FJ256GB210__) 
....................         #define __PIC24FJ256GB210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GB210.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GB210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GA002__) || (getenv("DEVICE")=="PIC24FJ32GA002") 
....................     #if !defined(__PIC24FJ32GA002__) 
....................         #define __PIC24FJ32GA002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GA002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GA002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GA004__) || (getenv("DEVICE")=="PIC24FJ32GA004") 
....................     #if !defined(__PIC24FJ32GA004__) 
....................         #define __PIC24FJ32GA004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GA004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GA004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GA102__) || (getenv("DEVICE")=="PIC24FJ32GA102") 
....................     #if !defined(__PIC24FJ32GA102__) 
....................         #define __PIC24FJ32GA102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GA102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GA102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GA104__) || (getenv("DEVICE")=="PIC24FJ32GA104") 
....................     #if !defined(__PIC24FJ32GA104__) 
....................         #define __PIC24FJ32GA104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GA104.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GA104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GB002__) || (getenv("DEVICE")=="PIC24FJ32GB002") 
....................     #if !defined(__PIC24FJ32GB002__) 
....................         #define __PIC24FJ32GB002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GB002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GB002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GB004__) || (getenv("DEVICE")=="PIC24FJ32GB004") 
....................     #if !defined(__PIC24FJ32GB004__) 
....................         #define __PIC24FJ32GB004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GB004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GB004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ48GA002__) || (getenv("DEVICE")=="PIC24FJ48GA002") 
....................     #if !defined(__PIC24FJ48GA002__) 
....................         #define __PIC24FJ48GA002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ48GA002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ48GA002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ48GA004__) || (getenv("DEVICE")=="PIC24FJ48GA004") 
....................     #if !defined(__PIC24FJ48GA004__) 
....................         #define __PIC24FJ48GA004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ48GA004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ48GA004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA002__) || (getenv("DEVICE")=="PIC24FJ64GA002") 
....................     #if !defined(__PIC24FJ64GA002__) 
....................         #define __PIC24FJ64GA002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA004__) || (getenv("DEVICE")=="PIC24FJ64GA004") 
....................     #if !defined(__PIC24FJ64GA004__) 
....................         #define __PIC24FJ64GA004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA006__) || (getenv("DEVICE")=="PIC24FJ64GA006") 
....................     #if !defined(__PIC24FJ64GA006__) 
....................         #define __PIC24FJ64GA006__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA006.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA006_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA008__) || (getenv("DEVICE")=="PIC24FJ64GA008") 
....................     #if !defined(__PIC24FJ64GA008__) 
....................         #define __PIC24FJ64GA008__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA008.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA008_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA010__) || (getenv("DEVICE")=="PIC24FJ64GA010") 
....................     #if !defined(__PIC24FJ64GA010__) 
....................         #define __PIC24FJ64GA010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA010.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA102__) || (getenv("DEVICE")=="PIC24FJ64GA102") 
....................     #if !defined(__PIC24FJ64GA102__) 
....................         #define __PIC24FJ64GA102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA104__) || (getenv("DEVICE")=="PIC24FJ64GA104") 
....................     #if !defined(__PIC24FJ64GA104__) 
....................         #define __PIC24FJ64GA104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA104.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA106__) || (getenv("DEVICE")=="PIC24FJ64GA106") 
....................     #if !defined(__PIC24FJ64GA106__) 
....................         #define __PIC24FJ64GA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA108__) || (getenv("DEVICE")=="PIC24FJ64GA108") 
....................     #if !defined(__PIC24FJ64GA108__) 
....................         #define __PIC24FJ64GA108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA110__) || (getenv("DEVICE")=="PIC24FJ64GA110") 
....................     #if !defined(__PIC24FJ64GA110__) 
....................         #define __PIC24FJ64GA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA306__) || (getenv("DEVICE")=="PIC24FJ64GA306") 
....................     #if !defined(__PIC24FJ64GA306__) 
....................         #define __PIC24FJ64GA306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA306.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA308__) || (getenv("DEVICE")=="PIC24FJ64GA308") 
....................     #if !defined(__PIC24FJ64GA308__) 
....................         #define __PIC24FJ64GA308__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA308.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA308_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA310__) || (getenv("DEVICE")=="PIC24FJ64GA310") 
....................     #if !defined(__PIC24FJ64GA310__) 
....................         #define __PIC24FJ64GA310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA310.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GB002__) || (getenv("DEVICE")=="PIC24FJ64GB002") 
....................     #if !defined(__PIC24FJ64GB002__) 
....................         #define __PIC24FJ64GB002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GB002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GB002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GB004__) || (getenv("DEVICE")=="PIC24FJ64GB004") 
....................     #if !defined(__PIC24FJ64GB004__) 
....................         #define __PIC24FJ64GB004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GB004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GB004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GB106__) || (getenv("DEVICE")=="PIC24FJ64GB106") 
....................     #if !defined(__PIC24FJ64GB106__) 
....................         #define __PIC24FJ64GB106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GB106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GB106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GB108__) || (getenv("DEVICE")=="PIC24FJ64GB108") 
....................     #if !defined(__PIC24FJ64GB108__) 
....................         #define __PIC24FJ64GB108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GB108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GB108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GB110__) || (getenv("DEVICE")=="PIC24FJ64GB110") 
....................     #if !defined(__PIC24FJ64GB110__) 
....................         #define __PIC24FJ64GB110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GB110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GB110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ96GA006__) || (getenv("DEVICE")=="PIC24FJ96GA006") 
....................     #if !defined(__PIC24FJ96GA006__) 
....................         #define __PIC24FJ96GA006__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ96GA006.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ96GA006_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ96GA008__) || (getenv("DEVICE")=="PIC24FJ96GA008") 
....................     #if !defined(__PIC24FJ96GA008__) 
....................         #define __PIC24FJ96GA008__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ96GA008.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ96GA008_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ96GA010__) || (getenv("DEVICE")=="PIC24FJ96GA010") 
....................     #if !defined(__PIC24FJ96GA010__) 
....................         #define __PIC24FJ96GA010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ96GA010.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ96GA010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV08KM101__) || (getenv("DEVICE")=="PIC24FV08KM101") 
....................     #if !defined(__PIC24FV08KM101__) 
....................         #define __PIC24FV08KM101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV08KM101.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV08KM101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV08KM102__) || (getenv("DEVICE")=="PIC24FV08KM102") 
....................     #if !defined(__PIC24FV08KM102__) 
....................         #define __PIC24FV08KM102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV08KM102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV08KM102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV08KM202__) || (getenv("DEVICE")=="PIC24FV08KM202") 
....................     #if !defined(__PIC24FV08KM202__) 
....................         #define __PIC24FV08KM202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV08KM202.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV08KM202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV08KM204__) || (getenv("DEVICE")=="PIC24FV08KM204") 
....................     #if !defined(__PIC24FV08KM204__) 
....................         #define __PIC24FV08KM204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV08KM204.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV08KM204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KA301__) || (getenv("DEVICE")=="PIC24FV16KA301") 
....................     #if !defined(__PIC24FV16KA301__) 
....................         #define __PIC24FV16KA301__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KA301.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV16KA301_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KA302__) || (getenv("DEVICE")=="PIC24FV16KA302") 
....................     #if !defined(__PIC24FV16KA302__) 
....................         #define __PIC24FV16KA302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KA302.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV16KA302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KA304__) || (getenv("DEVICE")=="PIC24FV16KA304") 
....................     #if !defined(__PIC24FV16KA304__) 
....................         #define __PIC24FV16KA304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KA304.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV16KA304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KM102__) || (getenv("DEVICE")=="PIC24FV16KM102") 
....................     #if !defined(__PIC24FV16KM102__) 
....................         #define __PIC24FV16KM102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KM102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV16KM102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KM104__) || (getenv("DEVICE")=="PIC24FV16KM104") 
....................     #if !defined(__PIC24FV16KM104__) 
....................         #define __PIC24FV16KM104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KM104.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV16KM104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KM202__) || (getenv("DEVICE")=="PIC24FV16KM202") 
....................     #if !defined(__PIC24FV16KM202__) 
....................         #define __PIC24FV16KM202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KM202.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV16KM202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KM204__) || (getenv("DEVICE")=="PIC24FV16KM204") 
....................     #if !defined(__PIC24FV16KM204__) 
....................         #define __PIC24FV16KM204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KM204.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV16KM204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV32KA301__) || (getenv("DEVICE")=="PIC24FV32KA301") 
....................     #if !defined(__PIC24FV32KA301__) 
....................         #define __PIC24FV32KA301__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV32KA301.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV32KA301_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV32KA302__) || (getenv("DEVICE")=="PIC24FV32KA302") 
....................     #if !defined(__PIC24FV32KA302__) 
....................         #define __PIC24FV32KA302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV32KA302.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV32KA302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV32KA304__) || (getenv("DEVICE")=="PIC24FV32KA304") 
....................     #if !defined(__PIC24FV32KA304__) 
....................         #define __PIC24FV32KA304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV32KA304.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV32KA304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP202__) || (getenv("DEVICE")=="PIC24HJ128GP202") 
....................     #if !defined(__PIC24HJ128GP202__) 
....................         #define __PIC24HJ128GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP204__) || (getenv("DEVICE")=="PIC24HJ128GP204") 
....................     #if !defined(__PIC24HJ128GP204__) 
....................         #define __PIC24HJ128GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP206__) || (getenv("DEVICE")=="PIC24HJ128GP206") 
....................     #if !defined(__PIC24HJ128GP206__) 
....................         #define __PIC24HJ128GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP206A__) || (getenv("DEVICE")=="PIC24HJ128GP206A") 
....................     #if !defined(__PIC24HJ128GP206A__) 
....................         #define __PIC24HJ128GP206A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP206A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP206A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP210__) || (getenv("DEVICE")=="PIC24HJ128GP210") 
....................     #if !defined(__PIC24HJ128GP210__) 
....................         #define __PIC24HJ128GP210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP210.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP210A__) || (getenv("DEVICE")=="PIC24HJ128GP210A") 
....................     #if !defined(__PIC24HJ128GP210A__) 
....................         #define __PIC24HJ128GP210A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP210A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP210A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP306__) || (getenv("DEVICE")=="PIC24HJ128GP306") 
....................     #if !defined(__PIC24HJ128GP306__) 
....................         #define __PIC24HJ128GP306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP306.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP306A__) || (getenv("DEVICE")=="PIC24HJ128GP306A") 
....................     #if !defined(__PIC24HJ128GP306A__) 
....................         #define __PIC24HJ128GP306A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP306A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP306A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP310__) || (getenv("DEVICE")=="PIC24HJ128GP310") 
....................     #if !defined(__PIC24HJ128GP310__) 
....................         #define __PIC24HJ128GP310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP310.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP310A__) || (getenv("DEVICE")=="PIC24HJ128GP310A") 
....................     #if !defined(__PIC24HJ128GP310A__) 
....................         #define __PIC24HJ128GP310A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP310A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP310A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP502__) || (getenv("DEVICE")=="PIC24HJ128GP502") 
....................     #if !defined(__PIC24HJ128GP502__) 
....................         #define __PIC24HJ128GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP502.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP504__) || (getenv("DEVICE")=="PIC24HJ128GP504") 
....................     #if !defined(__PIC24HJ128GP504__) 
....................         #define __PIC24HJ128GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP504.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP506__) || (getenv("DEVICE")=="PIC24HJ128GP506") 
....................     #if !defined(__PIC24HJ128GP506__) 
....................         #define __PIC24HJ128GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP506.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP506A__) || (getenv("DEVICE")=="PIC24HJ128GP506A") 
....................     #if !defined(__PIC24HJ128GP506A__) 
....................         #define __PIC24HJ128GP506A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP506A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP506A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP510__) || (getenv("DEVICE")=="PIC24HJ128GP510") 
....................     #if !defined(__PIC24HJ128GP510__) 
....................         #define __PIC24HJ128GP510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP510.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP510A__) || (getenv("DEVICE")=="PIC24HJ128GP510A") 
....................     #if !defined(__PIC24HJ128GP510A__) 
....................         #define __PIC24HJ128GP510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP510A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ12GP201__) || (getenv("DEVICE")=="PIC24HJ12GP201") 
....................     #if !defined(__PIC24HJ12GP201__) 
....................         #define __PIC24HJ12GP201__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ12GP201.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ12GP201_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ12GP202__) || (getenv("DEVICE")=="PIC24HJ12GP202") 
....................     #if !defined(__PIC24HJ12GP202__) 
....................         #define __PIC24HJ12GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ12GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ12GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ16GP304__) || (getenv("DEVICE")=="PIC24HJ16GP304") 
....................     #if !defined(__PIC24HJ16GP304__) 
....................         #define __PIC24HJ16GP304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ16GP304.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ16GP304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP206__) || (getenv("DEVICE")=="PIC24HJ256GP206") 
....................     #if !defined(__PIC24HJ256GP206__) 
....................         #define __PIC24HJ256GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP206A__) || (getenv("DEVICE")=="PIC24HJ256GP206A") 
....................     #if !defined(__PIC24HJ256GP206A__) 
....................         #define __PIC24HJ256GP206A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP206A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP206A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP210__) || (getenv("DEVICE")=="PIC24HJ256GP210") 
....................     #if !defined(__PIC24HJ256GP210__) 
....................         #define __PIC24HJ256GP210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP210.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP210A__) || (getenv("DEVICE")=="PIC24HJ256GP210A") 
....................     #if !defined(__PIC24HJ256GP210A__) 
....................         #define __PIC24HJ256GP210A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP210A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP210A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP610__) || (getenv("DEVICE")=="PIC24HJ256GP610") 
....................     #if !defined(__PIC24HJ256GP610__) 
....................         #define __PIC24HJ256GP610__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP610.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP610_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP610A__) || (getenv("DEVICE")=="PIC24HJ256GP610A") 
....................     #if !defined(__PIC24HJ256GP610A__) 
....................         #define __PIC24HJ256GP610A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP610A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP610A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ32GP202__) || (getenv("DEVICE")=="PIC24HJ32GP202") 
....................     #if !defined(__PIC24HJ32GP202__) 
....................         #define __PIC24HJ32GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ32GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ32GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ32GP204__) || (getenv("DEVICE")=="PIC24HJ32GP204") 
....................     #if !defined(__PIC24HJ32GP204__) 
....................         #define __PIC24HJ32GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ32GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ32GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ32GP302__) || (getenv("DEVICE")=="PIC24HJ32GP302") 
....................     #if !defined(__PIC24HJ32GP302__) 
....................         #define __PIC24HJ32GP302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ32GP302.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ32GP302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ32GP304__) || (getenv("DEVICE")=="PIC24HJ32GP304") 
....................     #if !defined(__PIC24HJ32GP304__) 
....................         #define __PIC24HJ32GP304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ32GP304.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ32GP304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP202__) || (getenv("DEVICE")=="PIC24HJ64GP202") 
....................     #if !defined(__PIC24HJ64GP202__) 
....................         #define __PIC24HJ64GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP204__) || (getenv("DEVICE")=="PIC24HJ64GP204") 
....................     #if !defined(__PIC24HJ64GP204__) 
....................         #define __PIC24HJ64GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP206__) || (getenv("DEVICE")=="PIC24HJ64GP206") 
....................     #if !defined(__PIC24HJ64GP206__) 
....................         #define __PIC24HJ64GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP206A__) || (getenv("DEVICE")=="PIC24HJ64GP206A") 
....................     #if !defined(__PIC24HJ64GP206A__) 
....................         #define __PIC24HJ64GP206A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP206A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP206A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP210__) || (getenv("DEVICE")=="PIC24HJ64GP210") 
....................     #if !defined(__PIC24HJ64GP210__) 
....................         #define __PIC24HJ64GP210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP210.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP210A__) || (getenv("DEVICE")=="PIC24HJ64GP210A") 
....................     #if !defined(__PIC24HJ64GP210A__) 
....................         #define __PIC24HJ64GP210A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP210A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP210A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP502__) || (getenv("DEVICE")=="PIC24HJ64GP502") 
....................     #if !defined(__PIC24HJ64GP502__) 
....................         #define __PIC24HJ64GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP502.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP504__) || (getenv("DEVICE")=="PIC24HJ64GP504") 
....................     #if !defined(__PIC24HJ64GP504__) 
....................         #define __PIC24HJ64GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP504.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP506__) || (getenv("DEVICE")=="PIC24HJ64GP506") 
....................     #if !defined(__PIC24HJ64GP506__) 
....................         #define __PIC24HJ64GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP506.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP506A__) || (getenv("DEVICE")=="PIC24HJ64GP506A") 
....................     #if !defined(__PIC24HJ64GP506A__) 
....................         #define __PIC24HJ64GP506A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP506A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP506A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP510__) || (getenv("DEVICE")=="PIC24HJ64GP510") 
....................     #if !defined(__PIC24HJ64GP510__) 
....................         #define __PIC24HJ64GP510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP510.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP510A__) || (getenv("DEVICE")=="PIC24HJ64GP510A") 
....................     #if !defined(__PIC24HJ64GP510A__) 
....................         #define __PIC24HJ64GP510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP510A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F1010__) || (getenv("DEVICE")=="DSPIC30F1010") 
....................     #if !defined(__dsPIC30F1010__) 
....................         #define __dsPIC30F1010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F1010.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F1010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F2010__) || (getenv("DEVICE")=="DSPIC30F2010") 
....................     #if !defined(__dsPIC30F2010__) 
....................         #define __dsPIC30F2010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F2010.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F2010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F2011__) || (getenv("DEVICE")=="DSPIC30F2011") 
....................     #if !defined(__dsPIC30F2011__) 
....................         #define __dsPIC30F2011__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F2011.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F2011_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F2012__) || (getenv("DEVICE")=="DSPIC30F2012") 
....................     #if !defined(__dsPIC30F2012__) 
....................         #define __dsPIC30F2012__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F2012.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F2012_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F2020__) || (getenv("DEVICE")=="DSPIC30F2020") 
....................     #if !defined(__dsPIC30F2020__) 
....................         #define __dsPIC30F2020__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F2020.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F2020_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F2023__) || (getenv("DEVICE")=="DSPIC30F2023") 
....................     #if !defined(__dsPIC30F2023__) 
....................         #define __dsPIC30F2023__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F2023.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F2023_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F3010__) || (getenv("DEVICE")=="DSPIC30F3010") 
....................     #if !defined(__dsPIC30F3010__) 
....................         #define __dsPIC30F3010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F3010.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F3010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F3011__) || (getenv("DEVICE")=="DSPIC30F3011") 
....................     #if !defined(__dsPIC30F3011__) 
....................         #define __dsPIC30F3011__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F3011.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F3011_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F3012__) || (getenv("DEVICE")=="DSPIC30F3012") 
....................     #if !defined(__dsPIC30F3012__) 
....................         #define __dsPIC30F3012__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F3012.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F3012_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F3013__) || (getenv("DEVICE")=="DSPIC30F3013") 
....................     #if !defined(__dsPIC30F3013__) 
....................         #define __dsPIC30F3013__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F3013.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F3013_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F3014__) || (getenv("DEVICE")=="DSPIC30F3014") 
....................     #if !defined(__dsPIC30F3014__) 
....................         #define __dsPIC30F3014__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F3014.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F3014_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F4011__) || (getenv("DEVICE")=="DSPIC30F4011") 
....................     #if !defined(__dsPIC30F4011__) 
....................         #define __dsPIC30F4011__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F4011.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F4011_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F4012__) || (getenv("DEVICE")=="DSPIC30F4012") 
....................     #if !defined(__dsPIC30F4012__) 
....................         #define __dsPIC30F4012__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F4012.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F4012_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F4013__) || (getenv("DEVICE")=="DSPIC30F4013") 
....................     #if !defined(__dsPIC30F4013__) 
....................         #define __dsPIC30F4013__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F4013.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F4013_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F5011__) || (getenv("DEVICE")=="DSPIC30F5011") 
....................     #if !defined(__dsPIC30F5011__) 
....................         #define __dsPIC30F5011__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F5011.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F5011_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F5013__) || (getenv("DEVICE")=="DSPIC30F5013") 
....................     #if !defined(__dsPIC30F5013__) 
....................         #define __dsPIC30F5013__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F5013.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F5013_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F5015__) || (getenv("DEVICE")=="DSPIC30F5015") 
....................     #if !defined(__dsPIC30F5015__) 
....................         #define __dsPIC30F5015__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F5015.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F5015_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F5016__) || (getenv("DEVICE")=="DSPIC30F5016") 
....................     #if !defined(__dsPIC30F5016__) 
....................         #define __dsPIC30F5016__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F5016.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F5016_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6010__) || (getenv("DEVICE")=="DSPIC30F6010") 
....................     #if !defined(__dsPIC30F6010__) 
....................         #define __dsPIC30F6010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6010.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6010A__) || (getenv("DEVICE")=="DSPIC30F6010A") 
....................     #if !defined(__dsPIC30F6010A__) 
....................         #define __dsPIC30F6010A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6010A.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6010A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6011__) || (getenv("DEVICE")=="DSPIC30F6011") 
....................     #if !defined(__dsPIC30F6011__) 
....................         #define __dsPIC30F6011__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6011.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6011_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6011A__) || (getenv("DEVICE")=="DSPIC30F6011A") 
....................     #if !defined(__dsPIC30F6011A__) 
....................         #define __dsPIC30F6011A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6011A.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6011A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6012__) || (getenv("DEVICE")=="DSPIC30F6012") 
....................     #if !defined(__dsPIC30F6012__) 
....................         #define __dsPIC30F6012__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6012.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6012_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6012A__) || (getenv("DEVICE")=="DSPIC30F6012A") 
....................     #if !defined(__dsPIC30F6012A__) 
....................         #define __dsPIC30F6012A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6012A.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6012A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6013__) || (getenv("DEVICE")=="DSPIC30F6013") 
....................     #if !defined(__dsPIC30F6013__) 
....................         #define __dsPIC30F6013__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6013.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6013_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6013A__) || (getenv("DEVICE")=="DSPIC30F6013A") 
....................     #if !defined(__dsPIC30F6013A__) 
....................         #define __dsPIC30F6013A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6013A.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6013A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6014__) || (getenv("DEVICE")=="DSPIC30F6014") 
....................     #if !defined(__dsPIC30F6014__) 
....................         #define __dsPIC30F6014__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6014.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6014_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6014A__) || (getenv("DEVICE")=="DSPIC30F6014A") 
....................     #if !defined(__dsPIC30F6014A__) 
....................         #define __dsPIC30F6014A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6014A.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6014A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6015__) || (getenv("DEVICE")=="DSPIC30F6015") 
....................     #if !defined(__dsPIC30F6015__) 
....................         #define __dsPIC30F6015__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6015.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6015_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM304__) || (getenv("DEVICE")=="DSPIC33EP128GM304") 
....................     #if !defined(__dsPIC33EP128GM304__) 
....................         #define __dsPIC33EP128GM304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM306__) || (getenv("DEVICE")=="DSPIC33EP128GM306") 
....................     #if !defined(__dsPIC33EP128GM306__) 
....................         #define __dsPIC33EP128GM306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM306.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM310__) || (getenv("DEVICE")=="DSPIC33EP128GM310") 
....................     #if !defined(__dsPIC33EP128GM310__) 
....................         #define __dsPIC33EP128GM310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM310.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM604__) || (getenv("DEVICE")=="DSPIC33EP128GM604") 
....................     #if !defined(__dsPIC33EP128GM604__) 
....................         #define __dsPIC33EP128GM604__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM604.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM604_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM706__) || (getenv("DEVICE")=="DSPIC33EP128GM706") 
....................     #if !defined(__dsPIC33EP128GM706__) 
....................         #define __dsPIC33EP128GM706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM710__) || (getenv("DEVICE")=="DSPIC33EP128GM710") 
....................     #if !defined(__dsPIC33EP128GM710__) 
....................         #define __dsPIC33EP128GM710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GP502__) || (getenv("DEVICE")=="DSPIC33EP128GP502") 
....................     #if !defined(__dsPIC33EP128GP502__) 
....................         #define __dsPIC33EP128GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GP502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GP504__) || (getenv("DEVICE")=="DSPIC33EP128GP504") 
....................     #if !defined(__dsPIC33EP128GP504__) 
....................         #define __dsPIC33EP128GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GP504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GP506__) || (getenv("DEVICE")=="DSPIC33EP128GP506") 
....................     #if !defined(__dsPIC33EP128GP506__) 
....................         #define __dsPIC33EP128GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GP506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC202__) || (getenv("DEVICE")=="DSPIC33EP128MC202") 
....................     #if !defined(__dsPIC33EP128MC202__) 
....................         #define __dsPIC33EP128MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC204__) || (getenv("DEVICE")=="DSPIC33EP128MC204") 
....................     #if !defined(__dsPIC33EP128MC204__) 
....................         #define __dsPIC33EP128MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC206__) || (getenv("DEVICE")=="DSPIC33EP128MC206") 
....................     #if !defined(__dsPIC33EP128MC206__) 
....................         #define __dsPIC33EP128MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC206.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC502__) || (getenv("DEVICE")=="DSPIC33EP128MC502") 
....................     #if !defined(__dsPIC33EP128MC502__) 
....................         #define __dsPIC33EP128MC502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC504__) || (getenv("DEVICE")=="DSPIC33EP128MC504") 
....................     #if !defined(__dsPIC33EP128MC504__) 
....................         #define __dsPIC33EP128MC504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC506__) || (getenv("DEVICE")=="DSPIC33EP128MC506") 
....................     #if !defined(__dsPIC33EP128MC506__) 
....................         #define __dsPIC33EP128MC506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM304__) || (getenv("DEVICE")=="DSPIC33EP256GM304") 
....................     #if !defined(__dsPIC33EP256GM304__) 
....................         #define __dsPIC33EP256GM304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM306__) || (getenv("DEVICE")=="DSPIC33EP256GM306") 
....................     #if !defined(__dsPIC33EP256GM306__) 
....................         #define __dsPIC33EP256GM306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM306.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM310__) || (getenv("DEVICE")=="DSPIC33EP256GM310") 
....................     #if !defined(__dsPIC33EP256GM310__) 
....................         #define __dsPIC33EP256GM310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM310.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM604__) || (getenv("DEVICE")=="DSPIC33EP256GM604") 
....................     #if !defined(__dsPIC33EP256GM604__) 
....................         #define __dsPIC33EP256GM604__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM604.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM604_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM706__) || (getenv("DEVICE")=="DSPIC33EP256GM706") 
....................     #if !defined(__dsPIC33EP256GM706__) 
....................         #define __dsPIC33EP256GM706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM710__) || (getenv("DEVICE")=="DSPIC33EP256GM710") 
....................     #if !defined(__dsPIC33EP256GM710__) 
....................         #define __dsPIC33EP256GM710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GP502__) || (getenv("DEVICE")=="DSPIC33EP256GP502") 
....................     #if !defined(__dsPIC33EP256GP502__) 
....................         #define __dsPIC33EP256GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GP502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GP504__) || (getenv("DEVICE")=="DSPIC33EP256GP504") 
....................     #if !defined(__dsPIC33EP256GP504__) 
....................         #define __dsPIC33EP256GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GP504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GP506__) || (getenv("DEVICE")=="DSPIC33EP256GP506") 
....................     #if !defined(__dsPIC33EP256GP506__) 
....................         #define __dsPIC33EP256GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GP506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC202__) || (getenv("DEVICE")=="DSPIC33EP256MC202") 
....................     #if !defined(__dsPIC33EP256MC202__) 
....................         #define __dsPIC33EP256MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC204__) || (getenv("DEVICE")=="DSPIC33EP256MC204") 
....................     #if !defined(__dsPIC33EP256MC204__) 
....................         #define __dsPIC33EP256MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC206__) || (getenv("DEVICE")=="DSPIC33EP256MC206") 
....................     #if !defined(__dsPIC33EP256MC206__) 
....................         #define __dsPIC33EP256MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC206.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC502__) || (getenv("DEVICE")=="DSPIC33EP256MC502") 
....................     #if !defined(__dsPIC33EP256MC502__) 
....................         #define __dsPIC33EP256MC502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC504__) || (getenv("DEVICE")=="DSPIC33EP256MC504") 
....................     #if !defined(__dsPIC33EP256MC504__) 
....................         #define __dsPIC33EP256MC504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC506__) || (getenv("DEVICE")=="DSPIC33EP256MC506") 
....................     #if !defined(__dsPIC33EP256MC506__) 
....................         #define __dsPIC33EP256MC506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MU806__) || (getenv("DEVICE")=="DSPIC33EP256MU806") 
....................     #if !defined(__dsPIC33EP256MU806__) 
....................         #define __dsPIC33EP256MU806__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MU806.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MU806_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MU810__) || (getenv("DEVICE")=="DSPIC33EP256MU810") 
....................     #if !defined(__dsPIC33EP256MU810__) 
....................         #define __dsPIC33EP256MU810__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MU810.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MU810_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MU814__) || (getenv("DEVICE")=="DSPIC33EP256MU814") 
....................     #if !defined(__dsPIC33EP256MU814__) 
....................         #define __dsPIC33EP256MU814__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MU814.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MU814_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32GP502__) || (getenv("DEVICE")=="DSPIC33EP32GP502") 
....................     #if !defined(__dsPIC33EP32GP502__) 
....................         #define __dsPIC33EP32GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32GP502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32GP503__) || (getenv("DEVICE")=="DSPIC33EP32GP503") 
....................     #if !defined(__dsPIC33EP32GP503__) 
....................         #define __dsPIC33EP32GP503__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32GP503.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32GP503_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32GP504__) || (getenv("DEVICE")=="DSPIC33EP32GP504") 
....................     #if !defined(__dsPIC33EP32GP504__) 
....................         #define __dsPIC33EP32GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32GP504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC202__) || (getenv("DEVICE")=="DSPIC33EP32MC202") 
....................     #if !defined(__dsPIC33EP32MC202__) 
....................         #define __dsPIC33EP32MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC203__) || (getenv("DEVICE")=="DSPIC33EP32MC203") 
....................     #if !defined(__dsPIC33EP32MC203__) 
....................         #define __dsPIC33EP32MC203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC203.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC204__) || (getenv("DEVICE")=="DSPIC33EP32MC204") 
....................     #if !defined(__dsPIC33EP32MC204__) 
....................         #define __dsPIC33EP32MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC502__) || (getenv("DEVICE")=="DSPIC33EP32MC502") 
....................     #if !defined(__dsPIC33EP32MC502__) 
....................         #define __dsPIC33EP32MC502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC503__) || (getenv("DEVICE")=="DSPIC33EP32MC503") 
....................     #if !defined(__dsPIC33EP32MC503__) 
....................         #define __dsPIC33EP32MC503__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC503.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC503_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC504__) || (getenv("DEVICE")=="DSPIC33EP32MC504") 
....................     #if !defined(__dsPIC33EP32MC504__) 
....................         #define __dsPIC33EP32MC504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM304__) || (getenv("DEVICE")=="DSPIC33EP512GM304") 
....................     #if !defined(__dsPIC33EP512GM304__) 
....................         #define __dsPIC33EP512GM304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM306__) || (getenv("DEVICE")=="DSPIC33EP512GM306") 
....................     #if !defined(__dsPIC33EP512GM306__) 
....................         #define __dsPIC33EP512GM306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM306.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM310__) || (getenv("DEVICE")=="DSPIC33EP512GM310") 
....................     #if !defined(__dsPIC33EP512GM310__) 
....................         #define __dsPIC33EP512GM310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM310.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM604__) || (getenv("DEVICE")=="DSPIC33EP512GM604") 
....................     #if !defined(__dsPIC33EP512GM604__) 
....................         #define __dsPIC33EP512GM604__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM604.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM604_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM706__) || (getenv("DEVICE")=="DSPIC33EP512GM706") 
....................     #if !defined(__dsPIC33EP512GM706__) 
....................         #define __dsPIC33EP512GM706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM710__) || (getenv("DEVICE")=="DSPIC33EP512GM710") 
....................     #if !defined(__dsPIC33EP512GM710__) 
....................         #define __dsPIC33EP512GM710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GP806__) || (getenv("DEVICE")=="DSPIC33EP512GP806") 
....................     #if !defined(__dsPIC33EP512GP806__) 
....................         #define __dsPIC33EP512GP806__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GP806.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GP806_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512MC806__) || (getenv("DEVICE")=="DSPIC33EP512MC806") 
....................     #if !defined(__dsPIC33EP512MC806__) 
....................         #define __dsPIC33EP512MC806__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512MC806.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512MC806_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512MU810__) || (getenv("DEVICE")=="DSPIC33EP512MU810") 
....................     #if !defined(__dsPIC33EP512MU810__) 
....................         #define __dsPIC33EP512MU810__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512MU810.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512MU810_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512MU814__) || (getenv("DEVICE")=="DSPIC33EP512MU814") 
....................     #if !defined(__dsPIC33EP512MU814__) 
....................         #define __dsPIC33EP512MU814__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512MU814.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512MU814_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64GP502__) || (getenv("DEVICE")=="DSPIC33EP64GP502") 
....................     #if !defined(__dsPIC33EP64GP502__) 
....................         #define __dsPIC33EP64GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64GP502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64GP503__) || (getenv("DEVICE")=="DSPIC33EP64GP503") 
....................     #if !defined(__dsPIC33EP64GP503__) 
....................         #define __dsPIC33EP64GP503__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64GP503.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64GP503_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64GP504__) || (getenv("DEVICE")=="DSPIC33EP64GP504") 
....................     #if !defined(__dsPIC33EP64GP504__) 
....................         #define __dsPIC33EP64GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64GP504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64GP506__) || (getenv("DEVICE")=="DSPIC33EP64GP506") 
....................     #if !defined(__dsPIC33EP64GP506__) 
....................         #define __dsPIC33EP64GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64GP506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC202__) || (getenv("DEVICE")=="DSPIC33EP64MC202") 
....................     #if !defined(__dsPIC33EP64MC202__) 
....................         #define __dsPIC33EP64MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC203__) || (getenv("DEVICE")=="DSPIC33EP64MC203") 
....................     #if !defined(__dsPIC33EP64MC203__) 
....................         #define __dsPIC33EP64MC203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC203.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC204__) || (getenv("DEVICE")=="DSPIC33EP64MC204") 
....................     #if !defined(__dsPIC33EP64MC204__) 
....................         #define __dsPIC33EP64MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC206__) || (getenv("DEVICE")=="DSPIC33EP64MC206") 
....................     #if !defined(__dsPIC33EP64MC206__) 
....................         #define __dsPIC33EP64MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC206.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC502__) || (getenv("DEVICE")=="DSPIC33EP64MC502") 
....................     #if !defined(__dsPIC33EP64MC502__) 
....................         #define __dsPIC33EP64MC502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC503__) || (getenv("DEVICE")=="DSPIC33EP64MC503") 
....................     #if !defined(__dsPIC33EP64MC503__) 
....................         #define __dsPIC33EP64MC503__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC503.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC503_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC504__) || (getenv("DEVICE")=="DSPIC33EP64MC504") 
....................     #if !defined(__dsPIC33EP64MC504__) 
....................         #define __dsPIC33EP64MC504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC506__) || (getenv("DEVICE")=="DSPIC33EP64MC506") 
....................     #if !defined(__dsPIC33EP64MC506__) 
....................         #define __dsPIC33EP64MC506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS001__) || (getenv("DEVICE")=="DSPIC33FJ06GS001") 
....................     #if !defined(__dsPIC33FJ06GS001__) 
....................         #define __dsPIC33FJ06GS001__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS001.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS001_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS101__) || (getenv("DEVICE")=="DSPIC33FJ06GS101") 
....................     #if !defined(__dsPIC33FJ06GS101__) 
....................         #define __dsPIC33FJ06GS101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS101.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS101A__) || (getenv("DEVICE")=="DSPIC33FJ06GS101A") 
....................     #if !defined(__dsPIC33FJ06GS101A__) 
....................         #define __dsPIC33FJ06GS101A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS101A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS101A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS102__) || (getenv("DEVICE")=="DSPIC33FJ06GS102") 
....................     #if !defined(__dsPIC33FJ06GS102__) 
....................         #define __dsPIC33FJ06GS102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS102.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS102A__) || (getenv("DEVICE")=="DSPIC33FJ06GS102A") 
....................     #if !defined(__dsPIC33FJ06GS102A__) 
....................         #define __dsPIC33FJ06GS102A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS102A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS102A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS202__) || (getenv("DEVICE")=="DSPIC33FJ06GS202") 
....................     #if !defined(__dsPIC33FJ06GS202__) 
....................         #define __dsPIC33FJ06GS202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS202A__) || (getenv("DEVICE")=="DSPIC33FJ06GS202A") 
....................     #if !defined(__dsPIC33FJ06GS202A__) 
....................         #define __dsPIC33FJ06GS202A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS202A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS202A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ09GS302__) || (getenv("DEVICE")=="DSPIC33FJ09GS302") 
....................     #if !defined(__dsPIC33FJ09GS302__) 
....................         #define __dsPIC33FJ09GS302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ09GS302.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ09GS302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP202__) || (getenv("DEVICE")=="DSPIC33FJ128GP202") 
....................     #if !defined(__dsPIC33FJ128GP202__) 
....................         #define __dsPIC33FJ128GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP204__) || (getenv("DEVICE")=="DSPIC33FJ128GP204") 
....................     #if !defined(__dsPIC33FJ128GP204__) 
....................         #define __dsPIC33FJ128GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP206__) || (getenv("DEVICE")=="DSPIC33FJ128GP206") 
....................     #if !defined(__dsPIC33FJ128GP206__) 
....................         #define __dsPIC33FJ128GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP206.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP206A__) || (getenv("DEVICE")=="DSPIC33FJ128GP206A") 
....................     #if !defined(__dsPIC33FJ128GP206A__) 
....................         #define __dsPIC33FJ128GP206A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP206A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP206A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP306__) || (getenv("DEVICE")=="DSPIC33FJ128GP306") 
....................     #if !defined(__dsPIC33FJ128GP306__) 
....................         #define __dsPIC33FJ128GP306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP306.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP306A__) || (getenv("DEVICE")=="DSPIC33FJ128GP306A") 
....................     #if !defined(__dsPIC33FJ128GP306A__) 
....................         #define __dsPIC33FJ128GP306A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP306A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP306A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP310__) || (getenv("DEVICE")=="DSPIC33FJ128GP310") 
....................     #if !defined(__dsPIC33FJ128GP310__) 
....................         #define __dsPIC33FJ128GP310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP310.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP310A__) || (getenv("DEVICE")=="DSPIC33FJ128GP310A") 
....................     #if !defined(__dsPIC33FJ128GP310A__) 
....................         #define __dsPIC33FJ128GP310A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP310A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP310A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP706__) || (getenv("DEVICE")=="DSPIC33FJ128GP706") 
....................     #if !defined(__dsPIC33FJ128GP706__) 
....................         #define __dsPIC33FJ128GP706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP706A__) || (getenv("DEVICE")=="DSPIC33FJ128GP706A") 
....................     #if !defined(__dsPIC33FJ128GP706A__) 
....................         #define __dsPIC33FJ128GP706A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP706A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP706A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP708__) || (getenv("DEVICE")=="DSPIC33FJ128GP708") 
....................     #if !defined(__dsPIC33FJ128GP708__) 
....................         #define __dsPIC33FJ128GP708__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP708.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP708_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP708A__) || (getenv("DEVICE")=="DSPIC33FJ128GP708A") 
....................     #if !defined(__dsPIC33FJ128GP708A__) 
....................         #define __dsPIC33FJ128GP708A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP708A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP708A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP710__) || (getenv("DEVICE")=="DSPIC33FJ128GP710") 
....................     #if !defined(__dsPIC33FJ128GP710__) 
....................         #define __dsPIC33FJ128GP710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP710A__) || (getenv("DEVICE")=="DSPIC33FJ128GP710A") 
....................     #if !defined(__dsPIC33FJ128GP710A__) 
....................         #define __dsPIC33FJ128GP710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP802__) || (getenv("DEVICE")=="DSPIC33FJ128GP802") 
....................     #if !defined(__dsPIC33FJ128GP802__) 
....................         #define __dsPIC33FJ128GP802__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP802.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP802_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP804__) || (getenv("DEVICE")=="DSPIC33FJ128GP804") 
....................     #if !defined(__dsPIC33FJ128GP804__) 
....................         #define __dsPIC33FJ128GP804__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP804.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP804_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC202__) || (getenv("DEVICE")=="DSPIC33FJ128MC202") 
....................     #if !defined(__dsPIC33FJ128MC202__) 
....................         #define __dsPIC33FJ128MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC204__) || (getenv("DEVICE")=="DSPIC33FJ128MC204") 
....................     #if !defined(__dsPIC33FJ128MC204__) 
....................         #define __dsPIC33FJ128MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC506__) || (getenv("DEVICE")=="DSPIC33FJ128MC506") 
....................     #if !defined(__dsPIC33FJ128MC506__) 
....................         #define __dsPIC33FJ128MC506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC506A__) || (getenv("DEVICE")=="DSPIC33FJ128MC506A") 
....................     #if !defined(__dsPIC33FJ128MC506A__) 
....................         #define __dsPIC33FJ128MC506A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC506A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC506A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC510__) || (getenv("DEVICE")=="DSPIC33FJ128MC510") 
....................     #if !defined(__dsPIC33FJ128MC510__) 
....................         #define __dsPIC33FJ128MC510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC510.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC510A__) || (getenv("DEVICE")=="DSPIC33FJ128MC510A") 
....................     #if !defined(__dsPIC33FJ128MC510A__) 
....................         #define __dsPIC33FJ128MC510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC510A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC706__) || (getenv("DEVICE")=="DSPIC33FJ128MC706") 
....................     #if !defined(__dsPIC33FJ128MC706__) 
....................         #define __dsPIC33FJ128MC706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC706A__) || (getenv("DEVICE")=="DSPIC33FJ128MC706A") 
....................     #if !defined(__dsPIC33FJ128MC706A__) 
....................         #define __dsPIC33FJ128MC706A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC706A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC706A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC708__) || (getenv("DEVICE")=="DSPIC33FJ128MC708") 
....................     #if !defined(__dsPIC33FJ128MC708__) 
....................         #define __dsPIC33FJ128MC708__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC708.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC708_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC708A__) || (getenv("DEVICE")=="DSPIC33FJ128MC708A") 
....................     #if !defined(__dsPIC33FJ128MC708A__) 
....................         #define __dsPIC33FJ128MC708A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC708A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC708A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC710__) || (getenv("DEVICE")=="DSPIC33FJ128MC710") 
....................     #if !defined(__dsPIC33FJ128MC710__) 
....................         #define __dsPIC33FJ128MC710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC710A__) || (getenv("DEVICE")=="DSPIC33FJ128MC710A") 
....................     #if !defined(__dsPIC33FJ128MC710A__) 
....................         #define __dsPIC33FJ128MC710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC802__) || (getenv("DEVICE")=="DSPIC33FJ128MC802") 
....................     #if !defined(__dsPIC33FJ128MC802__) 
....................         #define __dsPIC33FJ128MC802__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC802.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC802_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC804__) || (getenv("DEVICE")=="DSPIC33FJ128MC804") 
....................     #if !defined(__dsPIC33FJ128MC804__) 
....................         #define __dsPIC33FJ128MC804__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC804.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC804_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ12GP201__) || (getenv("DEVICE")=="DSPIC33FJ12GP201") 
....................     #if !defined(__dsPIC33FJ12GP201__) 
....................         #define __dsPIC33FJ12GP201__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ12GP201.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ12GP201_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ12GP202__) || (getenv("DEVICE")=="DSPIC33FJ12GP202") 
....................     #if !defined(__dsPIC33FJ12GP202__) 
....................         #define __dsPIC33FJ12GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ12GP202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ12GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ12MC201__) || (getenv("DEVICE")=="DSPIC33FJ12MC201") 
....................     #if !defined(__dsPIC33FJ12MC201__) 
....................         #define __dsPIC33FJ12MC201__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ12MC201.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ12MC201_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ12MC202__) || (getenv("DEVICE")=="DSPIC33FJ12MC202") 
....................     #if !defined(__dsPIC33FJ12MC202__) 
....................         #define __dsPIC33FJ12MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ12MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ12MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GP101__) || (getenv("DEVICE")=="DSPIC33FJ16GP101") 
....................     #if !defined(__dsPIC33FJ16GP101__) 
....................         #define __dsPIC33FJ16GP101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GP101.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GP101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GP102__) || (getenv("DEVICE")=="DSPIC33FJ16GP102") 
....................     #if !defined(__dsPIC33FJ16GP102__) 
....................         #define __dsPIC33FJ16GP102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GP102.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GP102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GP304__) || (getenv("DEVICE")=="DSPIC33FJ16GP304") 
....................     #if !defined(__dsPIC33FJ16GP304__) 
....................         #define __dsPIC33FJ16GP304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GP304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GP304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GS402__) || (getenv("DEVICE")=="DSPIC33FJ16GS402") 
....................     #if !defined(__dsPIC33FJ16GS402__) 
....................         #define __dsPIC33FJ16GS402__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GS402.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GS402_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GS404__) || (getenv("DEVICE")=="DSPIC33FJ16GS404") 
....................     #if !defined(__dsPIC33FJ16GS404__) 
....................         #define __dsPIC33FJ16GS404__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GS404.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GS404_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GS502__) || (getenv("DEVICE")=="DSPIC33FJ16GS502") 
....................     #if !defined(__dsPIC33FJ16GS502__) 
....................         #define __dsPIC33FJ16GS502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GS502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GS502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GS504__) || (getenv("DEVICE")=="DSPIC33FJ16GS504") 
....................     #if !defined(__dsPIC33FJ16GS504__) 
....................         #define __dsPIC33FJ16GS504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GS504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GS504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16MC101__) || (getenv("DEVICE")=="DSPIC33FJ16MC101") 
....................     #if !defined(__dsPIC33FJ16MC101__) 
....................         #define __dsPIC33FJ16MC101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16MC101.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16MC101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16MC102__) || (getenv("DEVICE")=="DSPIC33FJ16MC102") 
....................     #if !defined(__dsPIC33FJ16MC102__) 
....................         #define __dsPIC33FJ16MC102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16MC102.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16MC102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16MC304__) || (getenv("DEVICE")=="DSPIC33FJ16MC304") 
....................     #if !defined(__dsPIC33FJ16MC304__) 
....................         #define __dsPIC33FJ16MC304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16MC304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16MC304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP506__) || (getenv("DEVICE")=="DSPIC33FJ256GP506") 
....................     #if !defined(__dsPIC33FJ256GP506__) 
....................         #define __dsPIC33FJ256GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP506A__) || (getenv("DEVICE")=="DSPIC33FJ256GP506A") 
....................     #if !defined(__dsPIC33FJ256GP506A__) 
....................         #define __dsPIC33FJ256GP506A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP506A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP506A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP510__) || (getenv("DEVICE")=="DSPIC33FJ256GP510") 
....................     #if !defined(__dsPIC33FJ256GP510__) 
....................         #define __dsPIC33FJ256GP510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP510.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP510A__) || (getenv("DEVICE")=="DSPIC33FJ256GP510A") 
....................     #if !defined(__dsPIC33FJ256GP510A__) 
....................         #define __dsPIC33FJ256GP510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP510A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP710__) || (getenv("DEVICE")=="DSPIC33FJ256GP710") 
....................     #if !defined(__dsPIC33FJ256GP710__) 
....................         #define __dsPIC33FJ256GP710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP710A__) || (getenv("DEVICE")=="DSPIC33FJ256GP710A") 
....................     #if !defined(__dsPIC33FJ256GP710A__) 
....................         #define __dsPIC33FJ256GP710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256MC510__) || (getenv("DEVICE")=="DSPIC33FJ256MC510") 
....................     #if !defined(__dsPIC33FJ256MC510__) 
....................         #define __dsPIC33FJ256MC510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256MC510.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256MC510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256MC510A__) || (getenv("DEVICE")=="DSPIC33FJ256MC510A") 
....................     #if !defined(__dsPIC33FJ256MC510A__) 
....................         #define __dsPIC33FJ256MC510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256MC510A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256MC510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256MC710__) || (getenv("DEVICE")=="DSPIC33FJ256MC710") 
....................     #if !defined(__dsPIC33FJ256MC710__) 
....................         #define __dsPIC33FJ256MC710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256MC710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256MC710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256MC710A__) || (getenv("DEVICE")=="DSPIC33FJ256MC710A") 
....................     #if !defined(__dsPIC33FJ256MC710A__) 
....................         #define __dsPIC33FJ256MC710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256MC710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256MC710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP101__) || (getenv("DEVICE")=="DSPIC33FJ32GP101") 
....................     #if !defined(__dsPIC33FJ32GP101__) 
....................         #define __dsPIC33FJ32GP101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP101.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP102__) || (getenv("DEVICE")=="DSPIC33FJ32GP102") 
....................     #if !defined(__dsPIC33FJ32GP102__) 
....................         #define __dsPIC33FJ32GP102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP102.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP104__) || (getenv("DEVICE")=="DSPIC33FJ32GP104") 
....................     #if !defined(__dsPIC33FJ32GP104__) 
....................         #define __dsPIC33FJ32GP104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP104.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP202__) || (getenv("DEVICE")=="DSPIC33FJ32GP202") 
....................     #if !defined(__dsPIC33FJ32GP202__) 
....................         #define __dsPIC33FJ32GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP204__) || (getenv("DEVICE")=="DSPIC33FJ32GP204") 
....................     #if !defined(__dsPIC33FJ32GP204__) 
....................         #define __dsPIC33FJ32GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP302__) || (getenv("DEVICE")=="DSPIC33FJ32GP302") 
....................     #if !defined(__dsPIC33FJ32GP302__) 
....................         #define __dsPIC33FJ32GP302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP302.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP304__) || (getenv("DEVICE")=="DSPIC33FJ32GP304") 
....................     #if !defined(__dsPIC33FJ32GP304__) 
....................         #define __dsPIC33FJ32GP304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GS406__) || (getenv("DEVICE")=="DSPIC33FJ32GS406") 
....................     #if !defined(__dsPIC33FJ32GS406__) 
....................         #define __dsPIC33FJ32GS406__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GS406.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GS406_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GS606__) || (getenv("DEVICE")=="DSPIC33FJ32GS606") 
....................     #if !defined(__dsPIC33FJ32GS606__) 
....................         #define __dsPIC33FJ32GS606__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GS606.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GS606_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GS608__) || (getenv("DEVICE")=="DSPIC33FJ32GS608") 
....................     #if !defined(__dsPIC33FJ32GS608__) 
....................         #define __dsPIC33FJ32GS608__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GS608.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GS608_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GS610__) || (getenv("DEVICE")=="DSPIC33FJ32GS610") 
....................     #if !defined(__dsPIC33FJ32GS610__) 
....................         #define __dsPIC33FJ32GS610__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GS610.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GS610_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC101__) || (getenv("DEVICE")=="DSPIC33FJ32MC101") 
....................     #if !defined(__dsPIC33FJ32MC101__) 
....................         #define __dsPIC33FJ32MC101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC101.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC102__) || (getenv("DEVICE")=="DSPIC33FJ32MC102") 
....................     #if !defined(__dsPIC33FJ32MC102__) 
....................         #define __dsPIC33FJ32MC102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC102.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC104__) || (getenv("DEVICE")=="DSPIC33FJ32MC104") 
....................     #if !defined(__dsPIC33FJ32MC104__) 
....................         #define __dsPIC33FJ32MC104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC104.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC202__) || (getenv("DEVICE")=="DSPIC33FJ32MC202") 
....................     #if !defined(__dsPIC33FJ32MC202__) 
....................         #define __dsPIC33FJ32MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC204__) || (getenv("DEVICE")=="DSPIC33FJ32MC204") 
....................     #if !defined(__dsPIC33FJ32MC204__) 
....................         #define __dsPIC33FJ32MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC302__) || (getenv("DEVICE")=="DSPIC33FJ32MC302") 
....................     #if !defined(__dsPIC33FJ32MC302__) 
....................         #define __dsPIC33FJ32MC302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC302.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC304__) || (getenv("DEVICE")=="DSPIC33FJ32MC304") 
....................     #if !defined(__dsPIC33FJ32MC304__) 
....................         #define __dsPIC33FJ32MC304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP202__) || (getenv("DEVICE")=="DSPIC33FJ64GP202") 
....................     #if !defined(__dsPIC33FJ64GP202__) 
....................         #define __dsPIC33FJ64GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP204__) || (getenv("DEVICE")=="DSPIC33FJ64GP204") 
....................     #if !defined(__dsPIC33FJ64GP204__) 
....................         #define __dsPIC33FJ64GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP206__) || (getenv("DEVICE")=="DSPIC33FJ64GP206") 
....................     #if !defined(__dsPIC33FJ64GP206__) 
....................         #define __dsPIC33FJ64GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP206.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP206A__) || (getenv("DEVICE")=="DSPIC33FJ64GP206A") 
....................     #if !defined(__dsPIC33FJ64GP206A__) 
....................         #define __dsPIC33FJ64GP206A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP206A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP206A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP306__) || (getenv("DEVICE")=="DSPIC33FJ64GP306") 
....................     #if !defined(__dsPIC33FJ64GP306__) 
....................         #define __dsPIC33FJ64GP306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP306.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP306A__) || (getenv("DEVICE")=="DSPIC33FJ64GP306A") 
....................     #if !defined(__dsPIC33FJ64GP306A__) 
....................         #define __dsPIC33FJ64GP306A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP306A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP306A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP310__) || (getenv("DEVICE")=="DSPIC33FJ64GP310") 
....................     #if !defined(__dsPIC33FJ64GP310__) 
....................         #define __dsPIC33FJ64GP310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP310.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP310A__) || (getenv("DEVICE")=="DSPIC33FJ64GP310A") 
....................     #if !defined(__dsPIC33FJ64GP310A__) 
....................         #define __dsPIC33FJ64GP310A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP310A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP310A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP706__) || (getenv("DEVICE")=="DSPIC33FJ64GP706") 
....................     #if !defined(__dsPIC33FJ64GP706__) 
....................         #define __dsPIC33FJ64GP706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP706A__) || (getenv("DEVICE")=="DSPIC33FJ64GP706A") 
....................     #if !defined(__dsPIC33FJ64GP706A__) 
....................         #define __dsPIC33FJ64GP706A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP706A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP706A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP708__) || (getenv("DEVICE")=="DSPIC33FJ64GP708") 
....................     #if !defined(__dsPIC33FJ64GP708__) 
....................         #define __dsPIC33FJ64GP708__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP708.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP708_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP708A__) || (getenv("DEVICE")=="DSPIC33FJ64GP708A") 
....................     #if !defined(__dsPIC33FJ64GP708A__) 
....................         #define __dsPIC33FJ64GP708A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP708A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP708A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP710__) || (getenv("DEVICE")=="DSPIC33FJ64GP710") 
....................     #if !defined(__dsPIC33FJ64GP710__) 
....................         #define __dsPIC33FJ64GP710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP710A__) || (getenv("DEVICE")=="DSPIC33FJ64GP710A") 
....................     #if !defined(__dsPIC33FJ64GP710A__) 
....................         #define __dsPIC33FJ64GP710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP802__) || (getenv("DEVICE")=="DSPIC33FJ64GP802") 
....................     #if !defined(__dsPIC33FJ64GP802__) 
....................         #define __dsPIC33FJ64GP802__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP802.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP802_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP804__) || (getenv("DEVICE")=="DSPIC33FJ64GP804") 
....................     #if !defined(__dsPIC33FJ64GP804__) 
....................         #define __dsPIC33FJ64GP804__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP804.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP804_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GS406__) || (getenv("DEVICE")=="DSPIC33FJ64GS406") 
....................     #if !defined(__dsPIC33FJ64GS406__) 
....................         #define __dsPIC33FJ64GS406__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GS406.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GS406_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GS606__) || (getenv("DEVICE")=="DSPIC33FJ64GS606") 
....................     #if !defined(__dsPIC33FJ64GS606__) 
....................         #define __dsPIC33FJ64GS606__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GS606.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GS606_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GS608__) || (getenv("DEVICE")=="DSPIC33FJ64GS608") 
....................     #if !defined(__dsPIC33FJ64GS608__) 
....................         #define __dsPIC33FJ64GS608__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GS608.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GS608_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GS610__) || (getenv("DEVICE")=="DSPIC33FJ64GS610") 
....................     #if !defined(__dsPIC33FJ64GS610__) 
....................         #define __dsPIC33FJ64GS610__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GS610.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GS610_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC202__) || (getenv("DEVICE")=="DSPIC33FJ64MC202") 
....................     #if !defined(__dsPIC33FJ64MC202__) 
....................         #define __dsPIC33FJ64MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC204__) || (getenv("DEVICE")=="DSPIC33FJ64MC204") 
....................     #if !defined(__dsPIC33FJ64MC204__) 
....................         #define __dsPIC33FJ64MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC506__) || (getenv("DEVICE")=="DSPIC33FJ64MC506") 
....................     #if !defined(__dsPIC33FJ64MC506__) 
....................         #define __dsPIC33FJ64MC506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC506A__) || (getenv("DEVICE")=="DSPIC33FJ64MC506A") 
....................     #if !defined(__dsPIC33FJ64MC506A__) 
....................         #define __dsPIC33FJ64MC506A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC506A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC506A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC508__) || (getenv("DEVICE")=="DSPIC33FJ64MC508") 
....................     #if !defined(__dsPIC33FJ64MC508__) 
....................         #define __dsPIC33FJ64MC508__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC508.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC508_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC508A__) || (getenv("DEVICE")=="DSPIC33FJ64MC508A") 
....................     #if !defined(__dsPIC33FJ64MC508A__) 
....................         #define __dsPIC33FJ64MC508A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC508A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC508A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC510__) || (getenv("DEVICE")=="DSPIC33FJ64MC510") 
....................     #if !defined(__dsPIC33FJ64MC510__) 
....................         #define __dsPIC33FJ64MC510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC510.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC510A__) || (getenv("DEVICE")=="DSPIC33FJ64MC510A") 
....................     #if !defined(__dsPIC33FJ64MC510A__) 
....................         #define __dsPIC33FJ64MC510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC510A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC706__) || (getenv("DEVICE")=="DSPIC33FJ64MC706") 
....................     #if !defined(__dsPIC33FJ64MC706__) 
....................         #define __dsPIC33FJ64MC706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC706A__) || (getenv("DEVICE")=="DSPIC33FJ64MC706A") 
....................     #if !defined(__dsPIC33FJ64MC706A__) 
....................         #define __dsPIC33FJ64MC706A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC706A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC706A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC710__) || (getenv("DEVICE")=="DSPIC33FJ64MC710") 
....................     #if !defined(__dsPIC33FJ64MC710__) 
....................         #define __dsPIC33FJ64MC710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC710A__) || (getenv("DEVICE")=="DSPIC33FJ64MC710A") 
....................     #if !defined(__dsPIC33FJ64MC710A__) 
....................         #define __dsPIC33FJ64MC710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC802__) || (getenv("DEVICE")=="DSPIC33FJ64MC802") 
....................     #if !defined(__dsPIC33FJ64MC802__) 
....................         #define __dsPIC33FJ64MC802__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC802.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC802_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC804__) || (getenv("DEVICE")=="DSPIC33FJ64MC804") 
....................     #if !defined(__dsPIC33FJ64MC804__) 
....................         #define __dsPIC33FJ64MC804__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC804.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC804_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC81010__) || (getenv("DEVICE")=="DSPIC81010") 
....................     #if !defined(__dsPIC81010__) 
....................         #define __dsPIC81010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <81010.h> 
....................     #endif 
....................     #if !defined(__dsPIC810100__) 
....................         #define __dsPIC810100__ 
....................     #endif 
....................     #include "81010_registers.h" 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //#device PSV=16   this is done sooner in the code 
.................... /* 
.................... #if defined(__CONST_IS_READONLY__) 
....................    #device CONST=READ_ONLY 
.................... #else 
....................    //this is normally how C30 operates 
....................    #device CONST=ROM 
.................... #endif 
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... */ 
....................  
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #zero_ram 
.................... #zero_local_ram 
....................  
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
.................... #undef BYTE 
.................... #endif 
....................  
.................... #if defined(BOOLEAN) 
.................... #undef BOOLEAN 
.................... #endif 
....................  
.................... #define GetSystemClock()       getenv("CLOCK") 
.................... #define GetInstructionClock()  (GetSystemClock()/2) 
.................... #define GetPeripheralClock()   (GetSystemClock()/2) 
....................  
.................... //#define Reset()            reset_cpu()   //not needed, this is defined in Microchip's Compiler.h 
.................... //#define FAR                        //not needed, this is defined in Microchip's Compiler.h 
....................  
.................... #define ClrWdt()         restart_wdt() 
....................  
.................... #define Nop()            delay_cycles(1) 
....................  
.................... //#warning need eds support 
.................... #define __eds__ 
....................  
.................... #define __prog__  rom 
....................  
.................... #define __C30__ 
....................  
.................... #define __CCS_STDLIB_DYNAMIC_MEMORY__ 
....................  
.................... #endif 
....................  
.................... #else 
....................    #error PIC18 or dsPIC/PIC24 support ONLY 
.................... #endif 
....................  
.................... #include "HardwareProfile.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        HardwareProfile.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _MDD_HARDWAREPROFILE_H_ 
.................... #define _MDD_HARDWAREPROFILE_H_ 
....................  
.................... /*********************************************************************/ 
.................... /******************* Pin and Register Definitions ********************/ 
.................... /*********************************************************************/ 
....................  
.................... /* SD Card definitions: Change these to fit your application when using 
....................    an SD-card-based physical layer                                   */ 
....................  
.................... #if defined(HW_CCS_PIC24USB) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
.................... // ccs dsp analog board with sd connector 
....................  
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
.................... //        #define GetSystemClock() getenv("CLOCK") 
.................... //        #define GetPeripheralClock()    GetSystemClock() 
....................  //       #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATGbits.LATG8      //pin_G8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISGbits.TRISG8 
....................  
.................... //This is the old setup  December 30, 2014 
....................         // Description: SD-SPI Chip Select Output bit 
....................         //#define SD_CS            LATBbits.LATB14      //pin_b14 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         //#define SD_CS_TRIS          TRISBbits.TRISB14 
....................  
....................         #define SD_CD            PORTBbits.RB12      //pin_b12 
....................         #define SD_CD_TRIS       TRISBbits.TRISB12 
....................  
....................          //NO SD_WE_TRIS         
....................          int1 SD_WE_TRIS; 
....................          int1 SD_WE=0; 
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI1CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI1STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI1BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI1STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI1STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI1CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI1STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The main SPI control register 
....................         //#define SPICON1             SPI2CON1 
....................         // Description: The SPI status register 
....................         //#define SPISTAT             SPI2STAT 
....................         // Description: The SPI Buffer 
....................         //#define SPIBUF              SPI2BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         //#define SPISTAT_RBF         SPI2STATbits.SPIRBF 
....................         //#define SPISTAT_TBF         SPI2STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         //#define SPICON1bits         SPI2CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         //#define SPISTATbits         SPI2STATbits 
....................         // Description: The enable bit for the SPI module 
....................         //#define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................  
....................        // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISFbits.TRISF3 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISFbits.TRISF6 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISFbits.TRISF2 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         //#define SPICLOCK            TRISGbits.TRISG6 
....................         // Description: The TRIS bit for the SDI pin 
....................         //#define SPIIN               TRISGbits.TRISG7 
....................         // Description: The TRIS bit for the SDO pin 
....................         //#define SPIOUT              TRISGbits.TRISG8 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #include "FSConfig.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSconfig.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Dependencies:    None 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _FS_DEF_ 
.................... #define _FS_DEF_ 
....................  
.................... //#include "Compiler.h" 
.................... #include "HardwareProfile.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        HardwareProfile.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _MDD_HARDWAREPROFILE_H_ 
.................... #define _MDD_HARDWAREPROFILE_H_ 
....................  
.................... /*********************************************************************/ 
.................... /******************* Pin and Register Definitions ********************/ 
.................... /*********************************************************************/ 
....................  
.................... /* SD Card definitions: Change these to fit your application when using 
....................    an SD-card-based physical layer                                   */ 
....................  
.................... #if defined(HW_CCS_PIC24USB) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
.................... // ccs dsp analog board with sd connector 
....................  
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
.................... //        #define GetSystemClock() getenv("CLOCK") 
.................... //        #define GetPeripheralClock()    GetSystemClock() 
....................  //       #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATGbits.LATG8      //pin_G8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISGbits.TRISG8 
....................  
.................... //This is the old setup  December 30, 2014 
....................         // Description: SD-SPI Chip Select Output bit 
....................         //#define SD_CS            LATBbits.LATB14      //pin_b14 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         //#define SD_CS_TRIS          TRISBbits.TRISB14 
....................  
....................         #define SD_CD            PORTBbits.RB12      //pin_b12 
....................         #define SD_CD_TRIS       TRISBbits.TRISB12 
....................  
....................          //NO SD_WE_TRIS         
....................          int1 SD_WE_TRIS; 
....................          int1 SD_WE=0; 
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI1CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI1STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI1BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI1STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI1STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI1CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI1STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The main SPI control register 
....................         //#define SPICON1             SPI2CON1 
....................         // Description: The SPI status register 
....................         //#define SPISTAT             SPI2STAT 
....................         // Description: The SPI Buffer 
....................         //#define SPIBUF              SPI2BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         //#define SPISTAT_RBF         SPI2STATbits.SPIRBF 
....................         //#define SPISTAT_TBF         SPI2STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         //#define SPICON1bits         SPI2CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         //#define SPISTATbits         SPI2STATbits 
....................         // Description: The enable bit for the SPI module 
....................         //#define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................  
....................        // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISFbits.TRISF3 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISFbits.TRISF6 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISFbits.TRISF2 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         //#define SPICLOCK            TRISGbits.TRISG6 
....................         // Description: The TRIS bit for the SDI pin 
....................         //#define SPIIN               TRISGbits.TRISG7 
....................         // Description: The TRIS bit for the SDO pin 
....................         //#define SPIOUT              TRISGbits.TRISG8 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // something to do with long filenames. 
.................... //#define SUPPORT_LFN 
....................  
.................... // Summary: A macro indicating the maximum number of concurrently open files 
.................... // Description: The FS_MAX_FILES_OPEN #define is only applicable when dynamic memory allocation is not used (FS_DYNAMIC_MEM is not defined). 
.................... //              This macro defines the maximum number of open files at any given time.  The amount of RAM used by FSFILE objects will 
.................... //              be equal to the size of an FSFILE object multipled by this macro value.  This value should be kept as small as possible 
.................... //              as dictated by the application.  This will reduce memory usage. 
.................... #define FS_MAX_FILES_OPEN    1 
....................  
....................  
.................... // if defined, MDD will be configured to use SST25 flash device. this definition 
.................... // should also define the size of the SST25 flash device. 
.................... // if not defined, will use SD card. 
.................... // #define  USE_SST25_INTERFACE  ((unsigned int32)2*1024*1024) 
....................  
.................... // Summary: A macro defining the size of a sector 
.................... // Description: The MEDIA_SECTOR_SIZE macro will define the size of a sector on the FAT file system.  This value must equal 512 bytes, 
.................... //              1024 bytes, 2048 bytes, or 4096 bytes.  The value of a sector will usually be 512 bytes. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define MEDIA_SECTOR_SIZE       4096   //erase size of SST25 flash device 
.................... #else 
.................... #define MEDIA_SECTOR_SIZE       512 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* *******************************************************************************************************/ 
.................... /************** Compiler options to enable/Disable Features based on user's application ******************/ 
.................... /* *******************************************************************************************************/ 
....................  
....................  
.................... // Summary: A macro to enable/disable file search functions. 
.................... // Description: The ALLOW_FILESEARCH definition can be commented out to disable file search functions in the library.  This will 
.................... //              prevent the use of the FindFirst and FindNext functions and reduce code size. 
.................... #define ALLOW_FILESEARCH 
....................  
.................... // Summary: A macro to enable/disable write functionality 
.................... // Description: The ALLOW_WRITES definition can be commented out to disable all operations that write to the device.  This will 
.................... //              greatly reduce code size. 
.................... #define ALLOW_WRITES 
....................  
....................  
.................... // Summary: A macro to enable/disable format functionality 
.................... // Description: The ALLOW_FORMATS definition can be commented out to disable formatting functionality.  This will prevent the use of 
.................... //              the FSformat function.  If formats are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define ALLOW_FORMATS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable directory operations. 
.................... // Description: The ALLOW_DIRS definition can be commented out to disable all directory functionality.  This will reduce code size. 
.................... //              If directories are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES in order to use 
.................... //              the FSmkdir or FSrmdir functions. 
.................... #define ALLOW_DIRS 
....................  
.................... // Summary: A macro to enable/disable PIC18 ROM functions. 
.................... // Description: The ALLOW_PGMFUNCTIONS definition can be commented out to disable all PIC18 functions that allow the user to pass string 
.................... //              arguments in ROM (denoted by the suffix -pgm).  Note that this functionality must be disabled when not using PIC18. 
.................... #if !defined(__CCS__) 
.................... #define ALLOW_PGMFUNCTIONS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable the FSfprintf function. 
.................... // Description: The ALLOW_FSFPRINTF definition can be commented out to disable the FSfprintf function.  This will save code space.  Note that 
.................... //              if FSfprintf is enabled and the PIC18 architecture is used, integer promotions must be enabled in the Project->Build Options 
.................... //              menu.  Write operations must be enabled to use FSfprintf. 
.................... //#define ALLOW_FSFPRINTF 
....................  
.................... // CCS added this config option to disable FAT12 to prevent recursion. 
.................... //__CCS__ added by ccs 
.................... //#define SUPPORT_FAT12 
....................  
.................... // Summary: A macro to enable/disable FAT32 support. 
.................... // Description: The SUPPORT_FAT32 definition can be commented out to disable support for FAT32 functionality.  This will save a small amount 
.................... //              of code space. 
.................... #define SUPPORT_FAT32 
....................  
....................  
....................  
.................... /**************************************************************************************************/ 
.................... // Select a method for updating file timestamps 
.................... /**************************************************************************************************/ 
....................  
.................... // Summary: A macro to enable RTCC based timestamp generation 
.................... // Description: The USEREALTIMECLOCK macro will configure the code to automatically 
.................... //              generate timestamp information for files from the RTCC module. The user 
.................... //              must enable and configure the RTCC module before creating or modifying 
.................... //              files.                                                                  
.................... //#define USEREALTIMECLOCK 
....................  
.................... // Summary: A macro to enable manual timestamp generation 
.................... // Description: The USERDEFINEDCLOCK macro will allow the user to manually set 
.................... //              timestamp information using the SetClockVars function. The user will 
.................... //              need to set the time variables immediately before creating or closing a 
.................... //              file or directory.                                                     
.................... #define USERDEFINEDCLOCK 
....................  
.................... // Summary: A macro to enable don't-care timestamp generation 
.................... // Description: The INCREMENTTIMESTAMP macro will set the create time of a file to a 
.................... //              static value and increment it when a file is updated. This timestamp 
.................... //              generation method should only be used in applications where file times 
.................... //              are not necessary.                                                     
.................... //#define INCREMENTTIMESTAMP 
....................  
....................  
.................... #ifdef __18CXX 
....................    #ifdef USEREALTIMECLOCK 
....................       #error Not all PIC18 devices have a Real-time clock and calander module 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    #ifndef __18CXX 
....................       #error The pgm functions are unneccessary when not using PIC18 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef USEREALTIMECLOCK 
....................     #ifndef USERDEFINEDCLOCK 
....................         #ifndef INCREMENTTIMESTAMP 
....................             #error Please enable USEREALTIMECLOCK, USERDEFINEDCLOCK, or INCREMENTTIMESTAMP 
....................         #endif 
....................     #endif 
.................... #endif 
....................  
.................... /************************************************************************/ 
.................... // Set this preprocessor option to '1' to use dynamic FSFILE object allocation.  It will 
.................... // be necessary to allocate a heap when dynamically allocating FSFILE objects. 
.................... // Set this option to '0' to use static FSFILE object allocation. 
.................... /************************************************************************/ 
....................  
.................... //#if 1  //from mirochip 
.................... #if defined(__PCH__) //__CCS__ 
....................     // Summary: A macro indicating that FSFILE objects will be allocated dynamically 
....................     // Description: The FS_DYNAMIC_MEM macro will cause FSFILE objects to be allocated from a dynamic heap.  If it is undefined, 
....................     //              the file objects will be allocated using a static array. 
....................    //#define FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................         // Description: Function pointer to a dynamic memory allocation function 
....................       #define FS_malloc   SRAMalloc 
....................         // Description: Function pointer to a dynamic memory free function 
....................       #define FS_free      SRAMfree 
....................    #else 
....................       #define FS_malloc   malloc 
....................       #define FS_free      free 
....................    #endif 
.................... #elif defined(__CCS__) 
....................    #error/warning Not using FS_DYNAMIC_MEM for PCD compiler 
.................... #endif 
....................  
....................  
.................... #ifdef __18CXX 
....................     /* Define the locations for the dataBuffer and FATbuffer; PLEASE CHECK THE LINKER FILE */ 
....................     #define DATA_BUFFER_ADDRESS      0x700 
....................     #define FAT_BUFFER_ADDRESS       0x900 
.................... #endif 
....................  
....................  
.................... // Function definitions 
.................... // Associate the physical layer functions with the correct physical layer 
.................... #ifdef USE_SD_INTERFACE_WITH_SPI       // SD-SPI.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_SDSPI_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_SDSPI_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_SDSPI_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_SDSPI_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_SDSPI_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_SDSPI_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_SDSPI_WriteProtectState 
....................  
....................     // Description: Function pointer to the Read Capacity Physical Layer function 
....................     #define MDD_ReadCapacity        MDD_SDSPI_ReadCapacity 
....................  
....................     // Description: Function pointer to the Read Sector Size Physical Layer Function 
....................     #define MDD_ReadSectorSize      MDD_SDSPI_ReadSectorSize 
....................  
.................... #elif defined USE_CF_INTERFACE_WITH_PMP       // CF-PMP.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFPMP_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFPMP_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFPMP_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFPMP_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFPMP_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFPMP_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFPMP_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFPMP_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFPMP_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFPMP_CFread 
....................  
.................... #elif defined USE_MANUAL_CF_INTERFACE         // CF-Bit transaction.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFBT_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFBT_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFBT_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFBT_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFBT_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFBT_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFBT_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFBT_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFBT_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFBT_CFread 
....................  
.................... #elif defined USE_USB_INTERFACE               // USB host MSD library 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     USBHostMSDSCSIMediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         USBHostMSDSCSIMediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          USBHostMSDSCSISectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         USBHostMSDSCSISectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO();               
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       USBHostMSDSCSIMediaReset 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   USBHostMSDSCSIWriteProtectState 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #include "MDD File System\FSIO.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSIO.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  *                  FSconfig.h 
....................  *                  FSDefs.h 
....................  *                  stddef.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.4.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  FS_DOT_H 
.................... #define  FS_DOT_H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "../FSconfig.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSconfig.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Dependencies:    None 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _FS_DEF_ 
.................... #define _FS_DEF_ 
....................  
.................... //#include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // something to do with long filenames. 
.................... //#define SUPPORT_LFN 
....................  
.................... // Summary: A macro indicating the maximum number of concurrently open files 
.................... // Description: The FS_MAX_FILES_OPEN #define is only applicable when dynamic memory allocation is not used (FS_DYNAMIC_MEM is not defined). 
.................... //              This macro defines the maximum number of open files at any given time.  The amount of RAM used by FSFILE objects will 
.................... //              be equal to the size of an FSFILE object multipled by this macro value.  This value should be kept as small as possible 
.................... //              as dictated by the application.  This will reduce memory usage. 
.................... #define FS_MAX_FILES_OPEN    1 
....................  
....................  
.................... // if defined, MDD will be configured to use SST25 flash device. this definition 
.................... // should also define the size of the SST25 flash device. 
.................... // if not defined, will use SD card. 
.................... // #define  USE_SST25_INTERFACE  ((unsigned int32)2*1024*1024) 
....................  
.................... // Summary: A macro defining the size of a sector 
.................... // Description: The MEDIA_SECTOR_SIZE macro will define the size of a sector on the FAT file system.  This value must equal 512 bytes, 
.................... //              1024 bytes, 2048 bytes, or 4096 bytes.  The value of a sector will usually be 512 bytes. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define MEDIA_SECTOR_SIZE       4096   //erase size of SST25 flash device 
.................... #else 
.................... #define MEDIA_SECTOR_SIZE       512 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* *******************************************************************************************************/ 
.................... /************** Compiler options to enable/Disable Features based on user's application ******************/ 
.................... /* *******************************************************************************************************/ 
....................  
....................  
.................... // Summary: A macro to enable/disable file search functions. 
.................... // Description: The ALLOW_FILESEARCH definition can be commented out to disable file search functions in the library.  This will 
.................... //              prevent the use of the FindFirst and FindNext functions and reduce code size. 
.................... #define ALLOW_FILESEARCH 
....................  
.................... // Summary: A macro to enable/disable write functionality 
.................... // Description: The ALLOW_WRITES definition can be commented out to disable all operations that write to the device.  This will 
.................... //              greatly reduce code size. 
.................... #define ALLOW_WRITES 
....................  
....................  
.................... // Summary: A macro to enable/disable format functionality 
.................... // Description: The ALLOW_FORMATS definition can be commented out to disable formatting functionality.  This will prevent the use of 
.................... //              the FSformat function.  If formats are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define ALLOW_FORMATS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable directory operations. 
.................... // Description: The ALLOW_DIRS definition can be commented out to disable all directory functionality.  This will reduce code size. 
.................... //              If directories are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES in order to use 
.................... //              the FSmkdir or FSrmdir functions. 
.................... #define ALLOW_DIRS 
....................  
.................... // Summary: A macro to enable/disable PIC18 ROM functions. 
.................... // Description: The ALLOW_PGMFUNCTIONS definition can be commented out to disable all PIC18 functions that allow the user to pass string 
.................... //              arguments in ROM (denoted by the suffix -pgm).  Note that this functionality must be disabled when not using PIC18. 
.................... #if !defined(__CCS__) 
.................... #define ALLOW_PGMFUNCTIONS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable the FSfprintf function. 
.................... // Description: The ALLOW_FSFPRINTF definition can be commented out to disable the FSfprintf function.  This will save code space.  Note that 
.................... //              if FSfprintf is enabled and the PIC18 architecture is used, integer promotions must be enabled in the Project->Build Options 
.................... //              menu.  Write operations must be enabled to use FSfprintf. 
.................... //#define ALLOW_FSFPRINTF 
....................  
.................... // CCS added this config option to disable FAT12 to prevent recursion. 
.................... //__CCS__ added by ccs 
.................... //#define SUPPORT_FAT12 
....................  
.................... // Summary: A macro to enable/disable FAT32 support. 
.................... // Description: The SUPPORT_FAT32 definition can be commented out to disable support for FAT32 functionality.  This will save a small amount 
.................... //              of code space. 
.................... #define SUPPORT_FAT32 
....................  
....................  
....................  
.................... /**************************************************************************************************/ 
.................... // Select a method for updating file timestamps 
.................... /**************************************************************************************************/ 
....................  
.................... // Summary: A macro to enable RTCC based timestamp generation 
.................... // Description: The USEREALTIMECLOCK macro will configure the code to automatically 
.................... //              generate timestamp information for files from the RTCC module. The user 
.................... //              must enable and configure the RTCC module before creating or modifying 
.................... //              files.                                                                  
.................... //#define USEREALTIMECLOCK 
....................  
.................... // Summary: A macro to enable manual timestamp generation 
.................... // Description: The USERDEFINEDCLOCK macro will allow the user to manually set 
.................... //              timestamp information using the SetClockVars function. The user will 
.................... //              need to set the time variables immediately before creating or closing a 
.................... //              file or directory.                                                     
.................... #define USERDEFINEDCLOCK 
....................  
.................... // Summary: A macro to enable don't-care timestamp generation 
.................... // Description: The INCREMENTTIMESTAMP macro will set the create time of a file to a 
.................... //              static value and increment it when a file is updated. This timestamp 
.................... //              generation method should only be used in applications where file times 
.................... //              are not necessary.                                                     
.................... //#define INCREMENTTIMESTAMP 
....................  
....................  
.................... #ifdef __18CXX 
....................    #ifdef USEREALTIMECLOCK 
....................       #error Not all PIC18 devices have a Real-time clock and calander module 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    #ifndef __18CXX 
....................       #error The pgm functions are unneccessary when not using PIC18 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef USEREALTIMECLOCK 
....................     #ifndef USERDEFINEDCLOCK 
....................         #ifndef INCREMENTTIMESTAMP 
....................             #error Please enable USEREALTIMECLOCK, USERDEFINEDCLOCK, or INCREMENTTIMESTAMP 
....................         #endif 
....................     #endif 
.................... #endif 
....................  
.................... /************************************************************************/ 
.................... // Set this preprocessor option to '1' to use dynamic FSFILE object allocation.  It will 
.................... // be necessary to allocate a heap when dynamically allocating FSFILE objects. 
.................... // Set this option to '0' to use static FSFILE object allocation. 
.................... /************************************************************************/ 
....................  
.................... //#if 1  //from mirochip 
.................... #if defined(__PCH__) //__CCS__ 
....................     // Summary: A macro indicating that FSFILE objects will be allocated dynamically 
....................     // Description: The FS_DYNAMIC_MEM macro will cause FSFILE objects to be allocated from a dynamic heap.  If it is undefined, 
....................     //              the file objects will be allocated using a static array. 
....................    //#define FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................         // Description: Function pointer to a dynamic memory allocation function 
....................       #define FS_malloc   SRAMalloc 
....................         // Description: Function pointer to a dynamic memory free function 
....................       #define FS_free      SRAMfree 
....................    #else 
....................       #define FS_malloc   malloc 
....................       #define FS_free      free 
....................    #endif 
.................... #elif defined(__CCS__) 
....................    #error/warning Not using FS_DYNAMIC_MEM for PCD compiler 
.................... #endif 
....................  
....................  
.................... #ifdef __18CXX 
....................     /* Define the locations for the dataBuffer and FATbuffer; PLEASE CHECK THE LINKER FILE */ 
....................     #define DATA_BUFFER_ADDRESS      0x700 
....................     #define FAT_BUFFER_ADDRESS       0x900 
.................... #endif 
....................  
....................  
.................... // Function definitions 
.................... // Associate the physical layer functions with the correct physical layer 
.................... #ifdef USE_SD_INTERFACE_WITH_SPI       // SD-SPI.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_SDSPI_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_SDSPI_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_SDSPI_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_SDSPI_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_SDSPI_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_SDSPI_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_SDSPI_WriteProtectState 
....................  
....................     // Description: Function pointer to the Read Capacity Physical Layer function 
....................     #define MDD_ReadCapacity        MDD_SDSPI_ReadCapacity 
....................  
....................     // Description: Function pointer to the Read Sector Size Physical Layer Function 
....................     #define MDD_ReadSectorSize      MDD_SDSPI_ReadSectorSize 
....................  
.................... #elif defined USE_CF_INTERFACE_WITH_PMP       // CF-PMP.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFPMP_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFPMP_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFPMP_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFPMP_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFPMP_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFPMP_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFPMP_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFPMP_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFPMP_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFPMP_CFread 
....................  
.................... #elif defined USE_MANUAL_CF_INTERFACE         // CF-Bit transaction.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFBT_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFBT_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFBT_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFBT_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFBT_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFBT_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFBT_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFBT_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFBT_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFBT_CFread 
....................  
.................... #elif defined USE_USB_INTERFACE               // USB host MSD library 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     USBHostMSDSCSIMediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         USBHostMSDSCSIMediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          USBHostMSDSCSISectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         USBHostMSDSCSISectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO();               
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       USBHostMSDSCSIMediaReset 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   USBHostMSDSCSIWriteProtectState 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "FSDefs.h"  
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSDefs.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.2.4 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  _FSDEF__H 
.................... #define  _FSDEF__H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
....................  
.................... // Summary: An enumeration used for various error codes. 
.................... // Description: The CETYPE enumeration is used to indicate different error conditions during device operation. 
.................... typedef enum _CETYPE 
.................... { 
....................     CE_GOOD = 0,                    // No error 
....................     CE_ERASE_FAIL,                  // An erase failed 
....................     CE_NOT_PRESENT,                 // No device was present 
....................     CE_NOT_FORMATTED,               // The disk is of an unsupported format 
....................     CE_BAD_PARTITION,               // The boot record is bad 
....................     CE_UNSUPPORTED_FS,              // The file system type is unsupported 
....................     CE_INIT_ERROR,                  // An initialization error has occured 
....................     CE_NOT_INIT,                    // An operation was performed on an uninitialized device 
....................     CE_BAD_SECTOR_READ,             // A bad read of a sector occured 
....................     CE_WRITE_ERROR,                 // Could not write to a sector 
....................     CE_INVALID_CLUSTER,             // Invalid cluster value > maxcls 
....................     CE_FILE_NOT_FOUND,              // Could not find the file on the device 
....................     CE_DIR_NOT_FOUND,               // Could not find the directory 
....................     CE_BAD_FILE,                    // File is corrupted 
....................     CE_DONE,                        // No more files in this directory 
....................     CE_COULD_NOT_GET_CLUSTER,       // Could not load/allocate next cluster in file 
....................     CE_FILENAME_2_LONG,             // A specified file name is too long to use 
....................     CE_FILENAME_EXISTS,             // A specified filename already exists on the device 
....................     CE_INVALID_FILENAME,            // Invalid file name 
....................     CE_DELETE_DIR,                  // The user tried to delete a directory with FSremove 
....................     CE_DIR_FULL,                    // All root dir entry are taken 
....................     CE_DISK_FULL,                   // All clusters in partition are taken 
....................     CE_DIR_NOT_EMPTY,               // This directory is not empty yet, remove files before deleting 
....................     CE_NONSUPPORTED_SIZE,           // The disk is too big to format as FAT16 
....................     CE_WRITE_PROTECTED,             // Card is write protected 
....................     CE_FILENOTOPENED,               // File not opened for the write 
....................     CE_SEEK_ERROR,                  // File location could not be changed successfully 
....................     CE_BADCACHEREAD,                // Bad cache read 
....................     CE_CARDFAT32,                   // FAT 32 - card not supported 
....................     CE_READONLY,                    // The file is read-only 
....................     CE_WRITEONLY,                   // The file is write-only 
....................     CE_INVALID_ARGUMENT,            // Invalid argument 
....................     CE_TOO_MANY_FILES_OPEN,         // Too many files are already open 
....................     CE_UNSUPPORTED_SECTOR_SIZE,     // Unsupported sector size 
....................     CE_EOF = 61 
.................... } CETYPE; 
....................  
....................  
.................... // Summary: A macro indicating a dir entry was found 
.................... // Description: The FOUND macro indicates that a directory entry was found in the specified position 
.................... #define FOUND       0 
....................  
.................... // Summary: A macro indicating no dir entry was found 
.................... // Description: The NOT_FOUND macro indicates that the specified directory entry to load was deleted 
.................... #define NOT_FOUND   1 
....................  
.................... // Summary: A macro indicating that no more files were found 
.................... // Description: The NO_MORE macro indicates that there are no more directory entries to search for 
.................... #define NO_MORE     2 
....................  
....................  
....................  
.................... // Summary: A macro indicating the device is formatted with FAT12 
.................... // Description: The FAT12 macro is used to indicate that the file system on the device being accessed is a FAT12 file system. 
.................... #define FAT12       1 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT16 
.................... // Description: The FAT16 macro is used to indicate that the file system on the device being accessed is a FAT16 file system. 
.................... #define FAT16       2 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT32 
.................... // Description: The FAT32 macro is used to indicate that the file system on the device being accessed is a FAT32 file system. 
.................... #define FAT32       3 
....................  
....................  
....................  
.................... // Summary: A read-only attribute macro 
.................... // Description: A macro for the read-only attribute.  A file with this attribute should not be written to.  Note that this 
.................... //              attribute will not actually prevent a write to the file; that functionality is operating-system dependant.  The 
.................... //              user should take care not to write to a read-only file. 
.................... #define ATTR_READ_ONLY      0x01 
....................  
.................... // Summary: A hidden attribute macro 
.................... // Description: A macro for the hidden attribute.  A file with this attribute may be hidden from the user, depending on the 
.................... //              implementation of the operating system. 
.................... #define ATTR_HIDDEN         0x02 
....................  
.................... // Summary: A system attribute macro 
.................... // Description: A macro for the system attribute.  A file with this attribute is used by the operating system, and should not be 
.................... //              modified.  Note that this attribute will not actually prevent a write to the file. 
.................... #define ATTR_SYSTEM         0x04 
....................  
.................... // Summary: A volume attribute macro 
.................... // Description: A macro for the volume attribute.  If the first directory entry in the root directory has the volume attribute set, 
.................... //              the device will use the name in that directory entry as the volume name. 
.................... #define ATTR_VOLUME         0x08 
....................  
.................... // Summary: A macro for the attributes for a long-file name entry 
.................... // Description: A macro for the long-name attributes.  If a directory entry is used in a long-file name implementation, it will have 
.................... //              all four lower bits set.  This indicates that any software that does not support long file names should ignore that 
.................... //              entry. 
.................... #define ATTR_LONG_NAME      0x0f 
....................  
.................... // Summary: A directory attribute macro 
.................... // Description: A macro for the directory attribute.  If a directory entry has this attribute set, the file it points to is a directory- 
.................... //              type file, and will contain directory entries that point to additional directories or files. 
.................... #define ATTR_DIRECTORY      0x10 
....................  
.................... // Summary: An archive attribute macro 
.................... // Description: A macro for the archive attribute.  This attribute will indicate to some archiving programs that the file with this 
.................... //              attribute needs to be backed up.  Most operating systems create files with the archive attribute set. 
.................... #define ATTR_ARCHIVE        0x20 
....................  
.................... // Summary: A macro for all attributes 
.................... // Description: A macro for all attributes.  The search functions in this library require an argument that determines which attributes 
.................... //              a file is allowed to have in order to be found.  If ATTR_MASK is specified as this argument, any file may be found, regardless 
.................... //              of its attributes. 
.................... #define ATTR_MASK           0x3f 
....................  
....................  
....................  
.................... // Summary: A macro to indicate an empty FAT entry 
.................... // Description: The CLUSTER_EMPTY value is used to indicate that a FAT entry and it's corresponding cluster are available. 
.................... #define CLUSTER_EMPTY               0x0000  
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT12 
.................... // Description: The LAST_CLUSTER_FAT12 macro is used when reading the FAT to indicate that the next FAT12 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT12          0xff8 
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT16 
.................... // Description: The LAST_CLUSTER_FAT16 macro is used when reading the FAT to indicate that the next FAT16 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT16          0xfff8 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT12 
.................... // Description: The END_CLUSTER_FAT12 value is used as a comparison in FAT12 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT12           0xFF7 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT16 
.................... // Description: The END_CLUSTER_FAT16 value is used as a comparison in FAT16 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT16           0xFFF7 
....................  
.................... // Summary: A macro to indicate the failure of the ReadFAT function 
.................... // Description: The CLUSTER_FAIL_FAT16 macro is used by the ReadFAT function to indicate that an error occured reading a FAT12 or FAT16 
.................... //              file allocation table.  Note that since '0xFFF8' is used for the last cluster return value in the FAT16 implementation 
.................... //              the end-of-file value '0xFFFF' can be used to indicate an error condition. 
.................... #define CLUSTER_FAIL_FAT16          0xFFFF 
....................  
....................  
....................  
.................... #ifdef SUPPORT_FAT32 
....................     // Summary: A macro to indicate the last cluster value for FAT32 
....................     // Description: The LAST_CLUSTER_FAT32 macro is used when reading the FAT to indicate that the next FAT32 entry for a file contains 
....................     //              the end-of-file value. 
....................     #define LAST_CLUSTER_FAT32      0x0FFFFFF8 
....................  
....................     // Summary: A macro to indicate the last allocatable cluster for FAT32 
....................     // Description: The END_CLUSTER_FAT32 value is used as a comparison in FAT32 to determine that the firmware has reached the end of 
....................     //              the range of allowed allocatable clusters. 
....................     #define END_CLUSTER_FAT32       0x0FFFFFF7 
....................  
....................     // Summary: A macro to indicate the failure of the ReadFAT function 
....................     // Description: The CLUSTER_FAIL_FAT32 macro is used by the ReadFAT function to indicate that an error occured reading a FAT32 
....................     //              file allocation able. 
....................     #define CLUSTER_FAIL_FAT32      0x0FFFFFFF 
....................  
.................... #endif 
....................  
.................... // Summary: A macro indicating the number of bytes in a directory entry. 
.................... // Description: The NUMBER_OF_BYTES_IN_DIR_ENTRY macro represents the number of bytes in one directory entry.  It is used to calculate 
.................... //              the number of sectors in the root directory based on information in the boot sector. 
.................... #define NUMBER_OF_BYTES_IN_DIR_ENTRY    32 
....................  
....................  
....................  
.................... // Summary: A macro for a deleted dir entry marker. 
.................... // Description: The DIR_DEL macro is used to mark a directory entry as deleted.  When a file is deleted, this value will replace the 
.................... //              first character in the file name, and will indicate that the file the entry points to was deleted. 
.................... #define DIR_DEL             0xE5 
....................  
.................... // Summary: A macro for the last dir entry marker. 
.................... // Description: The DIR_EMPTY macro is used to indicate the last entry in a directory.  Since entries in use cannot start with a 0 and 
.................... //              deleted entries start with the DIR_DEL character, a 0 will mark the end of the in-use or previously used group of 
.................... //              entries in a directory 
.................... #define DIR_EMPTY           0 
....................  
....................  
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name 
.................... // Description: The DIR_NAMESIZE macro is used when validing the name portion of 8.3 filenames 
.................... #define DIR_NAMESIZE        8 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file extension 
.................... // Description: The DIR_EXTENSION macro is used when validating the extension portion of 8.3 filenames 
.................... #define DIR_EXTENSION       3 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name and extension 
.................... // Description: The DIR_NAMECOMP macro is used when validating 8.3 filenames 
.................... #define DIR_NAMECOMP        (DIR_NAMESIZE+DIR_EXTENSION) 
....................  
....................  
....................  
.................... // Summary: A macro to write a byte to RAM 
.................... // Description: The RAMwrite macro is used to write a byte of data to a RAM array 
.................... #define RAMwrite( a, f, d) *(a+f) = d 
....................  
.................... // Summary: A macro to read a byte from RAM 
.................... // Description: The RAMread macro is used to read a byte of data from a RAM array 
.................... #define RAMread( a, f)  *(a+f) 
....................  
.................... // Summary: A macro to read a 16-bit word from RAM 
.................... // Description: The RAMreadW macro is used to read two bytes of data from a RAM array 
.................... #define RAMreadW( a, f) *(WORD *)(a+f) 
....................  
.................... // Summary: A macro to read a 32-bit word from RAM 
.................... // Description: The RAMreadD macro is used to read four bytes of data from a RAM array 
.................... #define RAMreadD( a, f) *(DWORD *)(a+f) 
....................  
....................  
....................  
.................... #ifndef EOF 
....................     // Summary: Indicates error conditions or end-of-file conditions 
....................     // Description: The EOF macro is used to indicate error conditions in some function calls.  It is also used to indicate 
....................     //              that the end-of-file has been reached. 
....................     #define EOF             ((int)-1) 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing information about the device. 
.................... // Description: The DISK structure contains information about the device being accessed. 
.................... typedef struct 
.................... {  
....................     BYTE    *   buffer;         // Address of the global data buffer used to read and write file information 
....................     DWORD       firsts;         // Logical block address of the first sector of the FAT partition on the device 
....................     DWORD       fat;            // Logical block address of the FAT 
....................     DWORD       root;           // Logical block address of the root directory 
....................     DWORD       data;           // Logical block address of the data section of the device. 
....................     WORD        maxroot;        // The maximum number of entries in the root directory. 
....................     DWORD       maxcls;         // The maximum number of clusters in the partition. 
....................     DWORD       sectorSize;     // The size of a sector in bytes 
....................     DWORD       fatsize;        // The number of sectors in the FAT 
....................     BYTE        fatcopy;        // The number of copies of the FAT in the partition 
....................     BYTE        SecPerClus;     // The number of sectors per cluster in the data region 
....................     BYTE        type;           // The file system type of the partition (FAT12, FAT16 or FAT32) 
....................     BYTE        mount;          // Device mount flag (TRUE if disk was mounted successfully, FALSE otherwise) 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... } __attribute__ ((packed)) DISK; 
.................... #else 
.................... } DISK; 
.................... #endif 
....................  
....................  
.................... #if defined(__18CXX) && !defined(__CCS__) 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef unsigned short long SWORD; 
.................... #else 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef struct 
....................     { 
....................         unsigned char array[3]; 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) SWORD; 
.................... #else 
....................     } SWORD; 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT12 file system (in the boot sector) 
.................... // Description: The _BPB_FAT12 structure provides a layout of the "bios parameter block" in the boot sector of a FAT12 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BPS;               // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD BootSec_ResrvSec;          // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD BootSec_RootDirEnts;       // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD BootSec_SPF;               // Number of sectors per FAT 
....................     WORD BootSec_SPT;               // Number of sectors per track 
....................     WORD BootSec_HeadCnt;           // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD  BootSec_Reserved;        // Reserved space 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved2;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination    
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT12; 
.................... #else 
....................     } _BPB_FAT12; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT16 file system (in the boot sector) 
.................... // Description: The _BPB_FAT16 structure provides a layout of the "bios parameter block" in the boot sector of a FAT16 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD  BootSec_BPS;              // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD  BootSec_ResrvSec;         // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD  BootSec_RootDirEnts;      // Number of root directory entries 
....................     WORD  BootSec_TotSec16;         // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD  BootSec_SPF;              // Number of sectors per FAT 
....................     WORD  BootSec_SPT;              // Number of sectors per track 
....................     WORD  BootSec_HeadCnt;          // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved;         // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination      
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT16; 
.................... #else 
....................     } _BPB_FAT16; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT32 file system (in the boot sector) 
.................... // Description: The _BPB_FAT32 structure provides a layout of the "bios parameter block" in the boot sector of a FAT32 partition. 
.................... typedef struct { 
....................     SWORD BootSec_jmpBoot;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BytsPerSec;        // Number of bytes per sector 
....................     BYTE  BootSec_SecPerClus;       // Number of sectors per cluster 
....................     WORD BootSec_RsvdSecCnt;        // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_NumFATs;          // Number of FATs on the partition 
....................     WORD BootSec_RootEntCnt;        // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_Media;            // Media descriptor 
....................     WORD BootSec_FATSz16;           // Number of sectors per FAT 
....................     WORD BootSec_SecPerTrk;         // Number of sectors per track 
....................     WORD BootSec_NumHeads;          // Number of heads 
....................     DWORD BootSec_HiddSec;          // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     DWORD BootSec_FATSz32;          // Sectors per FAT (32 bits) 
....................     WORD BootSec_ExtFlags;          // Presently active FAT. Defined by bits 0-3 if bit 7 is 1. 
....................     WORD BootSec_FSVers;            // FAT32 filesystem version.  Should be 0:0 
....................     DWORD BootSec_RootClus;         // Start cluster of the root directory (should be 2) 
....................     WORD BootSec_FSInfo;            // File system information 
....................     WORD BootSec_BkBootSec;         // Backup boot sector address. 
....................     BYTE  BootSec_Reserved[12];     // Reserved space 
....................     BYTE  BootSec_DrvNum;           // Drive number 
....................     BYTE  BootSec_Reserved1;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLab[11];       // Volume Label 
....................     BYTE  BootSec_FilSysType[8];    // File system type in ASCII.  Not used for determination   
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT32; 
.................... #else 
....................     } _BPB_FAT32; 
.................... #endif 
....................  
....................  
.................... // Description: A macro for the boot sector bytes per sector value offset 
.................... #define BSI_BPS            11 
....................  
.................... // Description: A macro for the boot sector sector per cluster value offset 
.................... #define BSI_SPC            13 
....................  
.................... // Description: A macro for the boot sector reserved sector count value offset 
.................... #define BSI_RESRVSEC       14 
....................  
.................... // Description: A macro for the boot sector FAT count value offset 
.................... #define BSI_FATCOUNT       16 
....................  
.................... // Description: A macro for the boot sector root directory entry count value offset 
.................... #define BSI_ROOTDIRENTS    17 
....................  
.................... // Description: A macro for the boot sector 16-bit total sector count value offset 
.................... #define BSI_TOTSEC16       19 
....................  
.................... // Description: A macro for the boot sector sectors per FAT value offset 
.................... #define BSI_SPF            22 
....................  
.................... // Description: A macro for the boot sector 32-bit total sector count value offset 
.................... #define BSI_TOTSEC32       32 
....................  
.................... // Description: A macro for the boot sector boot signature offset 
.................... #define BSI_BOOTSIG        38 
....................  
.................... // Description: A macro for the boot sector file system type string offset 
.................... #define BSI_FSTYPE         54 
....................  
.................... // Description: A macro for the boot sector 32-bit sector per FAT value offset 
.................... #define  BSI_FATSZ32       36 
....................  
.................... // Description: A macro for the boot sector start cluster of root directory value offset 
.................... #define  BSI_ROOTCLUS      44 
....................  
.................... // Description: A macro for the FAT32 boot sector boot signature offset 
.................... #define  BSI_FAT32_BOOTSIG 66 
....................  
.................... // Description: A macro for the FAT32 boot sector file system type string offset 
.................... #define  BSI_FAT32_FSTYPE  82 
....................  
....................  
....................  
.................... // Summary: A partition table entry structure. 
.................... // Description: The PTE_MBR structure contains values found in a partition table entry in the MBR of a device. 
.................... typedef struct 
.................... { 
....................     BYTE      PTE_BootDes;            // The boot descriptor (should be 0x00 in a non-bootable device) 
....................     SWORD     PTE_FrstPartSect;       // The cylinder-head-sector address of the first sector of the partition 
....................     BYTE      PTE_FSDesc;             // The file system descriptor 
....................     SWORD     PTE_LstPartSect;        // The cylinder-head-sector address of the last sector of the partition 
....................     DWORD     PTE_FrstSect;           // The logical block address of the first sector of the partition 
....................     DWORD     PTE_NumSect;            // The number of sectors in a partition 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) PTE_MBR; 
.................... #else 
....................     } PTE_MBR; 
.................... #endif 
....................  
....................  
.................... // Summary: A structure of the organization of a master boot record. 
.................... // Description: The _PT_MBR structure has the same form as a master boot record.  When the MBR is loaded from the device, it will 
.................... //              be cast as a _PT_MBR structure so the MBR elements can be accessed. 
.................... typedef struct 
.................... { 
....................     BYTE        ConsChkRtn[446];        // Boot code 
....................     PTE_MBR     Partition0;             // The first partition table entry 
....................     PTE_MBR     Partition1;             // The second partition table entry 
....................     PTE_MBR     Partition2;             // The third partition table entry 
....................     PTE_MBR     Partition3;             // The fourth partition table entry 
....................     BYTE        Signature0;             // MBR signature code - equal to 0x55 
....................     BYTE        Signature1;             // MBR signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... }__attribute__((packed)) _PT_MBR; 
.................... #else 
.................... }_PT_MBR; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _PT_MBR structure 
.................... // Description: The PT_MBR pointer points to a _PT_MBR structure. 
.................... typedef _PT_MBR *  PT_MBR; 
....................  
....................  
....................  
.................... // Summary: A structure of the organization of a boot sector. 
.................... // Description: The _BootSec structure has the same form as a boot sector.  When the boot sector is loaded from the device, it will 
.................... //              be cast as a _BootSec structure so the boot sector elements can be accessed. 
.................... typedef struct 
.................... { 
....................     // A union of different bios parameter blocks 
....................     union 
....................     { 
....................         _BPB_FAT32  FAT_32; 
....................         _BPB_FAT16  FAT_16; 
....................         _BPB_FAT12  FAT_12; 
....................     }FAT; 
....................     BYTE    Reserved[512-sizeof(_BPB_FAT32)-2]; // Reserved space 
....................     BYTE    Signature0;         // Boot sector signature code - equal to 0x55 
....................     BYTE    Signature1;         // Boot sector signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BootSec; 
.................... #else 
....................     } _BootSec; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _BootSec structure 
.................... // Description: The BootSec pointer points to a _BootSec structure. 
.................... typedef _BootSec * BootSec; 
....................  
....................  
....................  
.................... // Summary: A macro indicating the offset for the master boot record 
.................... // Description: FO_MBR is a macro that indicates the addresss of the master boot record on the device.  When the device is initialized 
.................... //              this sector will be read 
.................... #define FO_MBR          0L 
....................  
....................  
....................  
.................... // Summary: A macro for the first boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_0 macro is used to determine that the first byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_0     0x55 
....................  
.................... // Summary: A macro for the second boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_1 macro is used to determine that the second byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_1     0xAA 
....................  
....................  
.................... typedef struct  
.................... { 
....................     BYTE    errorCode; 
....................     union  
....................     { 
....................         BYTE    value; 
....................         struct  
....................         { 
....................             BYTE    sectorSize  : 1; 
....................             BYTE    maxLUN      : 1; 
....................         }   bits; 
....................     } validityFlags; 
....................      
....................     WORD    sectorSize; 
....................     BYTE    maxLUN; 
.................... } MEDIA_INFORMATION; 
....................  
.................... typedef enum 
.................... { 
....................     MEDIA_NO_ERROR,                     // No errors 
....................     MEDIA_DEVICE_NOT_PRESENT,           // The requested device is not present 
....................     MEDIA_CANNOT_INITIALIZE             // Cannot initialize media 
.................... } MEDIA_ERRORS;                 
....................  
....................  
.................... #endif 
....................  
.................... #include "stddef.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... #ifdef USE_SD_INTERFACE_WITH_SPI 
....................     #include    "SD-SPI.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        SD-SPI.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  *                  FSconfig.h 
....................  *                  FSDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the "Company") for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef SDMMC_H 
.................... #define SDMMC_H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "../FSconfig.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSconfig.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Dependencies:    None 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _FS_DEF_ 
.................... #define _FS_DEF_ 
....................  
.................... //#include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // something to do with long filenames. 
.................... //#define SUPPORT_LFN 
....................  
.................... // Summary: A macro indicating the maximum number of concurrently open files 
.................... // Description: The FS_MAX_FILES_OPEN #define is only applicable when dynamic memory allocation is not used (FS_DYNAMIC_MEM is not defined). 
.................... //              This macro defines the maximum number of open files at any given time.  The amount of RAM used by FSFILE objects will 
.................... //              be equal to the size of an FSFILE object multipled by this macro value.  This value should be kept as small as possible 
.................... //              as dictated by the application.  This will reduce memory usage. 
.................... #define FS_MAX_FILES_OPEN    1 
....................  
....................  
.................... // if defined, MDD will be configured to use SST25 flash device. this definition 
.................... // should also define the size of the SST25 flash device. 
.................... // if not defined, will use SD card. 
.................... // #define  USE_SST25_INTERFACE  ((unsigned int32)2*1024*1024) 
....................  
.................... // Summary: A macro defining the size of a sector 
.................... // Description: The MEDIA_SECTOR_SIZE macro will define the size of a sector on the FAT file system.  This value must equal 512 bytes, 
.................... //              1024 bytes, 2048 bytes, or 4096 bytes.  The value of a sector will usually be 512 bytes. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define MEDIA_SECTOR_SIZE       4096   //erase size of SST25 flash device 
.................... #else 
.................... #define MEDIA_SECTOR_SIZE       512 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* *******************************************************************************************************/ 
.................... /************** Compiler options to enable/Disable Features based on user's application ******************/ 
.................... /* *******************************************************************************************************/ 
....................  
....................  
.................... // Summary: A macro to enable/disable file search functions. 
.................... // Description: The ALLOW_FILESEARCH definition can be commented out to disable file search functions in the library.  This will 
.................... //              prevent the use of the FindFirst and FindNext functions and reduce code size. 
.................... #define ALLOW_FILESEARCH 
....................  
.................... // Summary: A macro to enable/disable write functionality 
.................... // Description: The ALLOW_WRITES definition can be commented out to disable all operations that write to the device.  This will 
.................... //              greatly reduce code size. 
.................... #define ALLOW_WRITES 
....................  
....................  
.................... // Summary: A macro to enable/disable format functionality 
.................... // Description: The ALLOW_FORMATS definition can be commented out to disable formatting functionality.  This will prevent the use of 
.................... //              the FSformat function.  If formats are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define ALLOW_FORMATS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable directory operations. 
.................... // Description: The ALLOW_DIRS definition can be commented out to disable all directory functionality.  This will reduce code size. 
.................... //              If directories are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES in order to use 
.................... //              the FSmkdir or FSrmdir functions. 
.................... #define ALLOW_DIRS 
....................  
.................... // Summary: A macro to enable/disable PIC18 ROM functions. 
.................... // Description: The ALLOW_PGMFUNCTIONS definition can be commented out to disable all PIC18 functions that allow the user to pass string 
.................... //              arguments in ROM (denoted by the suffix -pgm).  Note that this functionality must be disabled when not using PIC18. 
.................... #if !defined(__CCS__) 
.................... #define ALLOW_PGMFUNCTIONS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable the FSfprintf function. 
.................... // Description: The ALLOW_FSFPRINTF definition can be commented out to disable the FSfprintf function.  This will save code space.  Note that 
.................... //              if FSfprintf is enabled and the PIC18 architecture is used, integer promotions must be enabled in the Project->Build Options 
.................... //              menu.  Write operations must be enabled to use FSfprintf. 
.................... //#define ALLOW_FSFPRINTF 
....................  
.................... // CCS added this config option to disable FAT12 to prevent recursion. 
.................... //__CCS__ added by ccs 
.................... //#define SUPPORT_FAT12 
....................  
.................... // Summary: A macro to enable/disable FAT32 support. 
.................... // Description: The SUPPORT_FAT32 definition can be commented out to disable support for FAT32 functionality.  This will save a small amount 
.................... //              of code space. 
.................... #define SUPPORT_FAT32 
....................  
....................  
....................  
.................... /**************************************************************************************************/ 
.................... // Select a method for updating file timestamps 
.................... /**************************************************************************************************/ 
....................  
.................... // Summary: A macro to enable RTCC based timestamp generation 
.................... // Description: The USEREALTIMECLOCK macro will configure the code to automatically 
.................... //              generate timestamp information for files from the RTCC module. The user 
.................... //              must enable and configure the RTCC module before creating or modifying 
.................... //              files.                                                                  
.................... //#define USEREALTIMECLOCK 
....................  
.................... // Summary: A macro to enable manual timestamp generation 
.................... // Description: The USERDEFINEDCLOCK macro will allow the user to manually set 
.................... //              timestamp information using the SetClockVars function. The user will 
.................... //              need to set the time variables immediately before creating or closing a 
.................... //              file or directory.                                                     
.................... #define USERDEFINEDCLOCK 
....................  
.................... // Summary: A macro to enable don't-care timestamp generation 
.................... // Description: The INCREMENTTIMESTAMP macro will set the create time of a file to a 
.................... //              static value and increment it when a file is updated. This timestamp 
.................... //              generation method should only be used in applications where file times 
.................... //              are not necessary.                                                     
.................... //#define INCREMENTTIMESTAMP 
....................  
....................  
.................... #ifdef __18CXX 
....................    #ifdef USEREALTIMECLOCK 
....................       #error Not all PIC18 devices have a Real-time clock and calander module 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    #ifndef __18CXX 
....................       #error The pgm functions are unneccessary when not using PIC18 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef USEREALTIMECLOCK 
....................     #ifndef USERDEFINEDCLOCK 
....................         #ifndef INCREMENTTIMESTAMP 
....................             #error Please enable USEREALTIMECLOCK, USERDEFINEDCLOCK, or INCREMENTTIMESTAMP 
....................         #endif 
....................     #endif 
.................... #endif 
....................  
.................... /************************************************************************/ 
.................... // Set this preprocessor option to '1' to use dynamic FSFILE object allocation.  It will 
.................... // be necessary to allocate a heap when dynamically allocating FSFILE objects. 
.................... // Set this option to '0' to use static FSFILE object allocation. 
.................... /************************************************************************/ 
....................  
.................... //#if 1  //from mirochip 
.................... #if defined(__PCH__) //__CCS__ 
....................     // Summary: A macro indicating that FSFILE objects will be allocated dynamically 
....................     // Description: The FS_DYNAMIC_MEM macro will cause FSFILE objects to be allocated from a dynamic heap.  If it is undefined, 
....................     //              the file objects will be allocated using a static array. 
....................    //#define FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................         // Description: Function pointer to a dynamic memory allocation function 
....................       #define FS_malloc   SRAMalloc 
....................         // Description: Function pointer to a dynamic memory free function 
....................       #define FS_free      SRAMfree 
....................    #else 
....................       #define FS_malloc   malloc 
....................       #define FS_free      free 
....................    #endif 
.................... #elif defined(__CCS__) 
....................    #error/warning Not using FS_DYNAMIC_MEM for PCD compiler 
.................... #endif 
....................  
....................  
.................... #ifdef __18CXX 
....................     /* Define the locations for the dataBuffer and FATbuffer; PLEASE CHECK THE LINKER FILE */ 
....................     #define DATA_BUFFER_ADDRESS      0x700 
....................     #define FAT_BUFFER_ADDRESS       0x900 
.................... #endif 
....................  
....................  
.................... // Function definitions 
.................... // Associate the physical layer functions with the correct physical layer 
.................... #ifdef USE_SD_INTERFACE_WITH_SPI       // SD-SPI.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_SDSPI_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_SDSPI_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_SDSPI_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_SDSPI_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_SDSPI_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_SDSPI_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_SDSPI_WriteProtectState 
....................  
....................     // Description: Function pointer to the Read Capacity Physical Layer function 
....................     #define MDD_ReadCapacity        MDD_SDSPI_ReadCapacity 
....................  
....................     // Description: Function pointer to the Read Sector Size Physical Layer Function 
....................     #define MDD_ReadSectorSize      MDD_SDSPI_ReadSectorSize 
....................  
.................... #elif defined USE_CF_INTERFACE_WITH_PMP       // CF-PMP.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFPMP_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFPMP_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFPMP_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFPMP_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFPMP_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFPMP_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFPMP_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFPMP_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFPMP_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFPMP_CFread 
....................  
.................... #elif defined USE_MANUAL_CF_INTERFACE         // CF-Bit transaction.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFBT_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFBT_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFBT_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFBT_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFBT_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFBT_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFBT_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFBT_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFBT_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFBT_CFread 
....................  
.................... #elif defined USE_USB_INTERFACE               // USB host MSD library 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     USBHostMSDSCSIMediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         USBHostMSDSCSIMediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          USBHostMSDSCSISectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         USBHostMSDSCSISectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO();               
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       USBHostMSDSCSIMediaReset 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   USBHostMSDSCSIWriteProtectState 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "FSDefs.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSDefs.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.2.4 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  _FSDEF__H 
.................... #define  _FSDEF__H 
....................  
.................... #include "../GenericTypeDefs.h" 
....................  
.................... // Summary: An enumeration used for various error codes. 
.................... // Description: The CETYPE enumeration is used to indicate different error conditions during device operation. 
.................... typedef enum _CETYPE 
.................... { 
....................     CE_GOOD = 0,                    // No error 
....................     CE_ERASE_FAIL,                  // An erase failed 
....................     CE_NOT_PRESENT,                 // No device was present 
....................     CE_NOT_FORMATTED,               // The disk is of an unsupported format 
....................     CE_BAD_PARTITION,               // The boot record is bad 
....................     CE_UNSUPPORTED_FS,              // The file system type is unsupported 
....................     CE_INIT_ERROR,                  // An initialization error has occured 
....................     CE_NOT_INIT,                    // An operation was performed on an uninitialized device 
....................     CE_BAD_SECTOR_READ,             // A bad read of a sector occured 
....................     CE_WRITE_ERROR,                 // Could not write to a sector 
....................     CE_INVALID_CLUSTER,             // Invalid cluster value > maxcls 
....................     CE_FILE_NOT_FOUND,              // Could not find the file on the device 
....................     CE_DIR_NOT_FOUND,               // Could not find the directory 
....................     CE_BAD_FILE,                    // File is corrupted 
....................     CE_DONE,                        // No more files in this directory 
....................     CE_COULD_NOT_GET_CLUSTER,       // Could not load/allocate next cluster in file 
....................     CE_FILENAME_2_LONG,             // A specified file name is too long to use 
....................     CE_FILENAME_EXISTS,             // A specified filename already exists on the device 
....................     CE_INVALID_FILENAME,            // Invalid file name 
....................     CE_DELETE_DIR,                  // The user tried to delete a directory with FSremove 
....................     CE_DIR_FULL,                    // All root dir entry are taken 
....................     CE_DISK_FULL,                   // All clusters in partition are taken 
....................     CE_DIR_NOT_EMPTY,               // This directory is not empty yet, remove files before deleting 
....................     CE_NONSUPPORTED_SIZE,           // The disk is too big to format as FAT16 
....................     CE_WRITE_PROTECTED,             // Card is write protected 
....................     CE_FILENOTOPENED,               // File not opened for the write 
....................     CE_SEEK_ERROR,                  // File location could not be changed successfully 
....................     CE_BADCACHEREAD,                // Bad cache read 
....................     CE_CARDFAT32,                   // FAT 32 - card not supported 
....................     CE_READONLY,                    // The file is read-only 
....................     CE_WRITEONLY,                   // The file is write-only 
....................     CE_INVALID_ARGUMENT,            // Invalid argument 
....................     CE_TOO_MANY_FILES_OPEN,         // Too many files are already open 
....................     CE_UNSUPPORTED_SECTOR_SIZE,     // Unsupported sector size 
....................     CE_EOF = 61 
.................... } CETYPE; 
....................  
....................  
.................... // Summary: A macro indicating a dir entry was found 
.................... // Description: The FOUND macro indicates that a directory entry was found in the specified position 
.................... #define FOUND       0 
....................  
.................... // Summary: A macro indicating no dir entry was found 
.................... // Description: The NOT_FOUND macro indicates that the specified directory entry to load was deleted 
.................... #define NOT_FOUND   1 
....................  
.................... // Summary: A macro indicating that no more files were found 
.................... // Description: The NO_MORE macro indicates that there are no more directory entries to search for 
.................... #define NO_MORE     2 
....................  
....................  
....................  
.................... // Summary: A macro indicating the device is formatted with FAT12 
.................... // Description: The FAT12 macro is used to indicate that the file system on the device being accessed is a FAT12 file system. 
.................... #define FAT12       1 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT16 
.................... // Description: The FAT16 macro is used to indicate that the file system on the device being accessed is a FAT16 file system. 
.................... #define FAT16       2 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT32 
.................... // Description: The FAT32 macro is used to indicate that the file system on the device being accessed is a FAT32 file system. 
.................... #define FAT32       3 
....................  
....................  
....................  
.................... // Summary: A read-only attribute macro 
.................... // Description: A macro for the read-only attribute.  A file with this attribute should not be written to.  Note that this 
.................... //              attribute will not actually prevent a write to the file; that functionality is operating-system dependant.  The 
.................... //              user should take care not to write to a read-only file. 
.................... #define ATTR_READ_ONLY      0x01 
....................  
.................... // Summary: A hidden attribute macro 
.................... // Description: A macro for the hidden attribute.  A file with this attribute may be hidden from the user, depending on the 
.................... //              implementation of the operating system. 
.................... #define ATTR_HIDDEN         0x02 
....................  
.................... // Summary: A system attribute macro 
.................... // Description: A macro for the system attribute.  A file with this attribute is used by the operating system, and should not be 
.................... //              modified.  Note that this attribute will not actually prevent a write to the file. 
.................... #define ATTR_SYSTEM         0x04 
....................  
.................... // Summary: A volume attribute macro 
.................... // Description: A macro for the volume attribute.  If the first directory entry in the root directory has the volume attribute set, 
.................... //              the device will use the name in that directory entry as the volume name. 
.................... #define ATTR_VOLUME         0x08 
....................  
.................... // Summary: A macro for the attributes for a long-file name entry 
.................... // Description: A macro for the long-name attributes.  If a directory entry is used in a long-file name implementation, it will have 
.................... //              all four lower bits set.  This indicates that any software that does not support long file names should ignore that 
.................... //              entry. 
.................... #define ATTR_LONG_NAME      0x0f 
....................  
.................... // Summary: A directory attribute macro 
.................... // Description: A macro for the directory attribute.  If a directory entry has this attribute set, the file it points to is a directory- 
.................... //              type file, and will contain directory entries that point to additional directories or files. 
.................... #define ATTR_DIRECTORY      0x10 
....................  
.................... // Summary: An archive attribute macro 
.................... // Description: A macro for the archive attribute.  This attribute will indicate to some archiving programs that the file with this 
.................... //              attribute needs to be backed up.  Most operating systems create files with the archive attribute set. 
.................... #define ATTR_ARCHIVE        0x20 
....................  
.................... // Summary: A macro for all attributes 
.................... // Description: A macro for all attributes.  The search functions in this library require an argument that determines which attributes 
.................... //              a file is allowed to have in order to be found.  If ATTR_MASK is specified as this argument, any file may be found, regardless 
.................... //              of its attributes. 
.................... #define ATTR_MASK           0x3f 
....................  
....................  
....................  
.................... // Summary: A macro to indicate an empty FAT entry 
.................... // Description: The CLUSTER_EMPTY value is used to indicate that a FAT entry and it's corresponding cluster are available. 
.................... #define CLUSTER_EMPTY               0x0000  
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT12 
.................... // Description: The LAST_CLUSTER_FAT12 macro is used when reading the FAT to indicate that the next FAT12 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT12          0xff8 
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT16 
.................... // Description: The LAST_CLUSTER_FAT16 macro is used when reading the FAT to indicate that the next FAT16 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT16          0xfff8 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT12 
.................... // Description: The END_CLUSTER_FAT12 value is used as a comparison in FAT12 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT12           0xFF7 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT16 
.................... // Description: The END_CLUSTER_FAT16 value is used as a comparison in FAT16 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT16           0xFFF7 
....................  
.................... // Summary: A macro to indicate the failure of the ReadFAT function 
.................... // Description: The CLUSTER_FAIL_FAT16 macro is used by the ReadFAT function to indicate that an error occured reading a FAT12 or FAT16 
.................... //              file allocation table.  Note that since '0xFFF8' is used for the last cluster return value in the FAT16 implementation 
.................... //              the end-of-file value '0xFFFF' can be used to indicate an error condition. 
.................... #define CLUSTER_FAIL_FAT16          0xFFFF 
....................  
....................  
....................  
.................... #ifdef SUPPORT_FAT32 
....................     // Summary: A macro to indicate the last cluster value for FAT32 
....................     // Description: The LAST_CLUSTER_FAT32 macro is used when reading the FAT to indicate that the next FAT32 entry for a file contains 
....................     //              the end-of-file value. 
....................     #define LAST_CLUSTER_FAT32      0x0FFFFFF8 
....................  
....................     // Summary: A macro to indicate the last allocatable cluster for FAT32 
....................     // Description: The END_CLUSTER_FAT32 value is used as a comparison in FAT32 to determine that the firmware has reached the end of 
....................     //              the range of allowed allocatable clusters. 
....................     #define END_CLUSTER_FAT32       0x0FFFFFF7 
....................  
....................     // Summary: A macro to indicate the failure of the ReadFAT function 
....................     // Description: The CLUSTER_FAIL_FAT32 macro is used by the ReadFAT function to indicate that an error occured reading a FAT32 
....................     //              file allocation able. 
....................     #define CLUSTER_FAIL_FAT32      0x0FFFFFFF 
....................  
.................... #endif 
....................  
.................... // Summary: A macro indicating the number of bytes in a directory entry. 
.................... // Description: The NUMBER_OF_BYTES_IN_DIR_ENTRY macro represents the number of bytes in one directory entry.  It is used to calculate 
.................... //              the number of sectors in the root directory based on information in the boot sector. 
.................... #define NUMBER_OF_BYTES_IN_DIR_ENTRY    32 
....................  
....................  
....................  
.................... // Summary: A macro for a deleted dir entry marker. 
.................... // Description: The DIR_DEL macro is used to mark a directory entry as deleted.  When a file is deleted, this value will replace the 
.................... //              first character in the file name, and will indicate that the file the entry points to was deleted. 
.................... #define DIR_DEL             0xE5 
....................  
.................... // Summary: A macro for the last dir entry marker. 
.................... // Description: The DIR_EMPTY macro is used to indicate the last entry in a directory.  Since entries in use cannot start with a 0 and 
.................... //              deleted entries start with the DIR_DEL character, a 0 will mark the end of the in-use or previously used group of 
.................... //              entries in a directory 
.................... #define DIR_EMPTY           0 
....................  
....................  
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name 
.................... // Description: The DIR_NAMESIZE macro is used when validing the name portion of 8.3 filenames 
.................... #define DIR_NAMESIZE        8 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file extension 
.................... // Description: The DIR_EXTENSION macro is used when validating the extension portion of 8.3 filenames 
.................... #define DIR_EXTENSION       3 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name and extension 
.................... // Description: The DIR_NAMECOMP macro is used when validating 8.3 filenames 
.................... #define DIR_NAMECOMP        (DIR_NAMESIZE+DIR_EXTENSION) 
....................  
....................  
....................  
.................... // Summary: A macro to write a byte to RAM 
.................... // Description: The RAMwrite macro is used to write a byte of data to a RAM array 
.................... #define RAMwrite( a, f, d) *(a+f) = d 
....................  
.................... // Summary: A macro to read a byte from RAM 
.................... // Description: The RAMread macro is used to read a byte of data from a RAM array 
.................... #define RAMread( a, f)  *(a+f) 
....................  
.................... // Summary: A macro to read a 16-bit word from RAM 
.................... // Description: The RAMreadW macro is used to read two bytes of data from a RAM array 
.................... #define RAMreadW( a, f) *(WORD *)(a+f) 
....................  
.................... // Summary: A macro to read a 32-bit word from RAM 
.................... // Description: The RAMreadD macro is used to read four bytes of data from a RAM array 
.................... #define RAMreadD( a, f) *(DWORD *)(a+f) 
....................  
....................  
....................  
.................... #ifndef EOF 
....................     // Summary: Indicates error conditions or end-of-file conditions 
....................     // Description: The EOF macro is used to indicate error conditions in some function calls.  It is also used to indicate 
....................     //              that the end-of-file has been reached. 
....................     #define EOF             ((int)-1) 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing information about the device. 
.................... // Description: The DISK structure contains information about the device being accessed. 
.................... typedef struct 
.................... {  
....................     BYTE    *   buffer;         // Address of the global data buffer used to read and write file information 
....................     DWORD       firsts;         // Logical block address of the first sector of the FAT partition on the device 
....................     DWORD       fat;            // Logical block address of the FAT 
....................     DWORD       root;           // Logical block address of the root directory 
....................     DWORD       data;           // Logical block address of the data section of the device. 
....................     WORD        maxroot;        // The maximum number of entries in the root directory. 
....................     DWORD       maxcls;         // The maximum number of clusters in the partition. 
....................     DWORD       sectorSize;     // The size of a sector in bytes 
....................     DWORD       fatsize;        // The number of sectors in the FAT 
....................     BYTE        fatcopy;        // The number of copies of the FAT in the partition 
....................     BYTE        SecPerClus;     // The number of sectors per cluster in the data region 
....................     BYTE        type;           // The file system type of the partition (FAT12, FAT16 or FAT32) 
....................     BYTE        mount;          // Device mount flag (TRUE if disk was mounted successfully, FALSE otherwise) 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... } __attribute__ ((packed)) DISK; 
.................... #else 
.................... } DISK; 
.................... #endif 
....................  
....................  
.................... #if defined(__18CXX) && !defined(__CCS__) 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef unsigned short long SWORD; 
.................... #else 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef struct 
....................     { 
....................         unsigned char array[3]; 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) SWORD; 
.................... #else 
....................     } SWORD; 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT12 file system (in the boot sector) 
.................... // Description: The _BPB_FAT12 structure provides a layout of the "bios parameter block" in the boot sector of a FAT12 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BPS;               // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD BootSec_ResrvSec;          // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD BootSec_RootDirEnts;       // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD BootSec_SPF;               // Number of sectors per FAT 
....................     WORD BootSec_SPT;               // Number of sectors per track 
....................     WORD BootSec_HeadCnt;           // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD  BootSec_Reserved;        // Reserved space 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved2;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination    
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT12; 
.................... #else 
....................     } _BPB_FAT12; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT16 file system (in the boot sector) 
.................... // Description: The _BPB_FAT16 structure provides a layout of the "bios parameter block" in the boot sector of a FAT16 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD  BootSec_BPS;              // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD  BootSec_ResrvSec;         // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD  BootSec_RootDirEnts;      // Number of root directory entries 
....................     WORD  BootSec_TotSec16;         // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD  BootSec_SPF;              // Number of sectors per FAT 
....................     WORD  BootSec_SPT;              // Number of sectors per track 
....................     WORD  BootSec_HeadCnt;          // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved;         // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination      
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT16; 
.................... #else 
....................     } _BPB_FAT16; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT32 file system (in the boot sector) 
.................... // Description: The _BPB_FAT32 structure provides a layout of the "bios parameter block" in the boot sector of a FAT32 partition. 
.................... typedef struct { 
....................     SWORD BootSec_jmpBoot;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BytsPerSec;        // Number of bytes per sector 
....................     BYTE  BootSec_SecPerClus;       // Number of sectors per cluster 
....................     WORD BootSec_RsvdSecCnt;        // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_NumFATs;          // Number of FATs on the partition 
....................     WORD BootSec_RootEntCnt;        // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_Media;            // Media descriptor 
....................     WORD BootSec_FATSz16;           // Number of sectors per FAT 
....................     WORD BootSec_SecPerTrk;         // Number of sectors per track 
....................     WORD BootSec_NumHeads;          // Number of heads 
....................     DWORD BootSec_HiddSec;          // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     DWORD BootSec_FATSz32;          // Sectors per FAT (32 bits) 
....................     WORD BootSec_ExtFlags;          // Presently active FAT. Defined by bits 0-3 if bit 7 is 1. 
....................     WORD BootSec_FSVers;            // FAT32 filesystem version.  Should be 0:0 
....................     DWORD BootSec_RootClus;         // Start cluster of the root directory (should be 2) 
....................     WORD BootSec_FSInfo;            // File system information 
....................     WORD BootSec_BkBootSec;         // Backup boot sector address. 
....................     BYTE  BootSec_Reserved[12];     // Reserved space 
....................     BYTE  BootSec_DrvNum;           // Drive number 
....................     BYTE  BootSec_Reserved1;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLab[11];       // Volume Label 
....................     BYTE  BootSec_FilSysType[8];    // File system type in ASCII.  Not used for determination   
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT32; 
.................... #else 
....................     } _BPB_FAT32; 
.................... #endif 
....................  
....................  
.................... // Description: A macro for the boot sector bytes per sector value offset 
.................... #define BSI_BPS            11 
....................  
.................... // Description: A macro for the boot sector sector per cluster value offset 
.................... #define BSI_SPC            13 
....................  
.................... // Description: A macro for the boot sector reserved sector count value offset 
.................... #define BSI_RESRVSEC       14 
....................  
.................... // Description: A macro for the boot sector FAT count value offset 
.................... #define BSI_FATCOUNT       16 
....................  
.................... // Description: A macro for the boot sector root directory entry count value offset 
.................... #define BSI_ROOTDIRENTS    17 
....................  
.................... // Description: A macro for the boot sector 16-bit total sector count value offset 
.................... #define BSI_TOTSEC16       19 
....................  
.................... // Description: A macro for the boot sector sectors per FAT value offset 
.................... #define BSI_SPF            22 
....................  
.................... // Description: A macro for the boot sector 32-bit total sector count value offset 
.................... #define BSI_TOTSEC32       32 
....................  
.................... // Description: A macro for the boot sector boot signature offset 
.................... #define BSI_BOOTSIG        38 
....................  
.................... // Description: A macro for the boot sector file system type string offset 
.................... #define BSI_FSTYPE         54 
....................  
.................... // Description: A macro for the boot sector 32-bit sector per FAT value offset 
.................... #define  BSI_FATSZ32       36 
....................  
.................... // Description: A macro for the boot sector start cluster of root directory value offset 
.................... #define  BSI_ROOTCLUS      44 
....................  
.................... // Description: A macro for the FAT32 boot sector boot signature offset 
.................... #define  BSI_FAT32_BOOTSIG 66 
....................  
.................... // Description: A macro for the FAT32 boot sector file system type string offset 
.................... #define  BSI_FAT32_FSTYPE  82 
....................  
....................  
....................  
.................... // Summary: A partition table entry structure. 
.................... // Description: The PTE_MBR structure contains values found in a partition table entry in the MBR of a device. 
.................... typedef struct 
.................... { 
....................     BYTE      PTE_BootDes;            // The boot descriptor (should be 0x00 in a non-bootable device) 
....................     SWORD     PTE_FrstPartSect;       // The cylinder-head-sector address of the first sector of the partition 
....................     BYTE      PTE_FSDesc;             // The file system descriptor 
....................     SWORD     PTE_LstPartSect;        // The cylinder-head-sector address of the last sector of the partition 
....................     DWORD     PTE_FrstSect;           // The logical block address of the first sector of the partition 
....................     DWORD     PTE_NumSect;            // The number of sectors in a partition 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) PTE_MBR; 
.................... #else 
....................     } PTE_MBR; 
.................... #endif 
....................  
....................  
.................... // Summary: A structure of the organization of a master boot record. 
.................... // Description: The _PT_MBR structure has the same form as a master boot record.  When the MBR is loaded from the device, it will 
.................... //              be cast as a _PT_MBR structure so the MBR elements can be accessed. 
.................... typedef struct 
.................... { 
....................     BYTE        ConsChkRtn[446];        // Boot code 
....................     PTE_MBR     Partition0;             // The first partition table entry 
....................     PTE_MBR     Partition1;             // The second partition table entry 
....................     PTE_MBR     Partition2;             // The third partition table entry 
....................     PTE_MBR     Partition3;             // The fourth partition table entry 
....................     BYTE        Signature0;             // MBR signature code - equal to 0x55 
....................     BYTE        Signature1;             // MBR signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... }__attribute__((packed)) _PT_MBR; 
.................... #else 
.................... }_PT_MBR; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _PT_MBR structure 
.................... // Description: The PT_MBR pointer points to a _PT_MBR structure. 
.................... typedef _PT_MBR *  PT_MBR; 
....................  
....................  
....................  
.................... // Summary: A structure of the organization of a boot sector. 
.................... // Description: The _BootSec structure has the same form as a boot sector.  When the boot sector is loaded from the device, it will 
.................... //              be cast as a _BootSec structure so the boot sector elements can be accessed. 
.................... typedef struct 
.................... { 
....................     // A union of different bios parameter blocks 
....................     union 
....................     { 
....................         _BPB_FAT32  FAT_32; 
....................         _BPB_FAT16  FAT_16; 
....................         _BPB_FAT12  FAT_12; 
....................     }FAT; 
....................     BYTE    Reserved[512-sizeof(_BPB_FAT32)-2]; // Reserved space 
....................     BYTE    Signature0;         // Boot sector signature code - equal to 0x55 
....................     BYTE    Signature1;         // Boot sector signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BootSec; 
.................... #else 
....................     } _BootSec; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _BootSec structure 
.................... // Description: The BootSec pointer points to a _BootSec structure. 
.................... typedef _BootSec * BootSec; 
....................  
....................  
....................  
.................... // Summary: A macro indicating the offset for the master boot record 
.................... // Description: FO_MBR is a macro that indicates the addresss of the master boot record on the device.  When the device is initialized 
.................... //              this sector will be read 
.................... #define FO_MBR          0L 
....................  
....................  
....................  
.................... // Summary: A macro for the first boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_0 macro is used to determine that the first byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_0     0x55 
....................  
.................... // Summary: A macro for the second boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_1 macro is used to determine that the second byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_1     0xAA 
....................  
....................  
.................... typedef struct  
.................... { 
....................     BYTE    errorCode; 
....................     union  
....................     { 
....................         BYTE    value; 
....................         struct  
....................         { 
....................             BYTE    sectorSize  : 1; 
....................             BYTE    maxLUN      : 1; 
....................         }   bits; 
....................     } validityFlags; 
....................      
....................     WORD    sectorSize; 
....................     BYTE    maxLUN; 
.................... } MEDIA_INFORMATION; 
....................  
.................... typedef enum 
.................... { 
....................     MEDIA_NO_ERROR,                     // No errors 
....................     MEDIA_DEVICE_NOT_PRESENT,           // The requested device is not present 
....................     MEDIA_CANNOT_INITIALIZE             // Cannot initialize media 
.................... } MEDIA_ERRORS;                 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #ifdef __18CXX 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 4x prescale divider 
....................     #define   SYNC_MODE_FAST    0x00 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 16x prescale divider 
....................     #define   SYNC_MODE_MED     0x01 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 64x prescale divider 
....................     #define   SYNC_MODE_SLOW    0x02 
.................... #elif defined __PIC32MX__ 
....................     // Description: This macro is used to initialize a PIC32 SPI module 
....................     #define   SYNC_MODE_FAST    0x3E 
....................     // Description: This macro is used to initialize a PIC32 SPI module 
....................     #define   SYNC_MODE_SLOW    0x3C 
.................... #else 
....................     // Description: This macro indicates the SPI enable bit for 16-bit PICs 
....................     #ifndef MASTER_ENABLE_ON 
....................         #define  MASTER_ENABLE_ON       0x0020 
....................     #endif 
....................  
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module 
....................     #ifndef SYNC_MODE_FAST 
....................         #define   SYNC_MODE_FAST    0x3E 
....................     #endif 
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module 
....................     #ifndef SYNC_MODE_SLOW 
....................         #define   SYNC_MODE_SLOW    0x3C 
....................     #endif 
....................  
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module secondary prescaler 
....................     #ifndef SEC_PRESCAL_1_1 
....................         #define  SEC_PRESCAL_1_1        0x001c 
....................     #endif 
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module primary prescaler 
....................     #ifndef PRI_PRESCAL_1_1 
....................         #define  PRI_PRESCAL_1_1        0x0003 
....................     #endif 
.................... #endif 
....................  
....................  
....................  
.................... /*****************************************************************/ 
.................... /*                  Strcutures and defines                       */ 
.................... /*****************************************************************/ 
....................  
....................  
.................... // Description: This macro represents an SD card start single data block token (used for single block writes) 
.................... #define DATA_START_TOKEN            0xFE 
....................  
.................... // Description: This macro represents an SD card start multi-block data token (used for multi-block writes) 
.................... #define DATA_START_MULTI_BLOCK_TOKEN    0xFC 
....................  
.................... // Description: This macro represents an SD card stop transmission token.  This is used when finishing a multi block write sequence. 
.................... #define DATA_STOP_TRAN_TOKEN        0xFD 
....................  
.................... // Description: This macro represents an SD card data accepted token 
.................... #define DATA_ACCEPTED               0x05 
....................  
.................... // Description: This macro indicates that the SD card expects to transmit or receive more data 
.................... #define MOREDATA    !0 
....................  
.................... // Description: This macro indicates that the SD card does not expect to transmit or receive more data 
.................... #define NODATA      0 
....................  
.................... // Description: This macro represents a floating SPI bus condition 
.................... #define MMC_FLOATING_BUS    0xFF 
....................  
.................... // Description: This macro represents a bad SD card response byte 
.................... #define MMC_BAD_RESPONSE    MMC_FLOATING_BUS 
....................  
.................... // The SDMMC Commands 
....................  
.................... // Description: This macro defines the command code to reset the SD card 
.................... #define     cmdGO_IDLE_STATE        0 
.................... // Description: This macro defines the command code to initialize the SD card 
.................... #define     cmdSEND_OP_COND         1         
.................... // Description: This macro defined the command code to check for sector addressing 
.................... #define     cmdSEND_IF_COND         8 
.................... // Description: This macro defines the command code to get the Card Specific Data 
.................... #define     cmdSEND_CSD             9 
.................... // Description: This macro defines the command code to get the Card Information 
.................... #define     cmdSEND_CID             10 
.................... // Description: This macro defines the command code to stop transmission during a multi-block read 
.................... #define     cmdSTOP_TRANSMISSION    12 
.................... // Description: This macro defines the command code to get the card status information 
.................... #define     cmdSEND_STATUS          13 
.................... // Description: This macro defines the command code to set the block length of the card 
.................... #define     cmdSET_BLOCKLEN         16 
.................... // Description: This macro defines the command code to read one block from the card 
.................... #define     cmdREAD_SINGLE_BLOCK    17 
.................... // Description: This macro defines the command code to read multiple blocks from the card 
.................... #define     cmdREAD_MULTI_BLOCK     18 
.................... // Description: This macro defines the command code to tell the media how many blocks to pre-erase (for faster multi-block writes to follow) 
.................... //Note: This is an "application specific" command.  This tells the media how many blocks to pre-erase for the subsequent WRITE_MULTI_BLOCK 
.................... #define     cmdSET_WR_BLK_ERASE_COUNT   23 
.................... // Description: This macro defines the command code to write one block to the card 
.................... #define     cmdWRITE_SINGLE_BLOCK   24     
.................... // Description: This macro defines the command code to write multiple blocks to the card 
.................... #define     cmdWRITE_MULTI_BLOCK    25 
.................... // Description: This macro defines the command code to set the address of the start of an erase operation 
.................... #define     cmdTAG_SECTOR_START     32 
.................... // Description: This macro defines the command code to set the address of the end of an erase operation 
.................... #define     cmdTAG_SECTOR_END       33 
.................... // Description: This macro defines the command code to erase all previously selected blocks 
.................... #define     cmdERASE                38 
.................... //Description: This macro defines the command code to intitialize an SD card and provide the CSD register value. 
.................... //Note: this is an "application specific" command (specific to SD cards) and must be preceded by cmdAPP_CMD. 
.................... #define     cmdSD_SEND_OP_COND      41 
.................... // Description: This macro defines the command code to begin application specific command inputs 
.................... #define     cmdAPP_CMD              55 
.................... // Description: This macro defines the command code to get the OCR register information from the card 
.................... #define     cmdREAD_OCR             58 
.................... // Description: This macro defines the command code to disable CRC checking 
.................... #define     cmdCRC_ON_OFF           59 
....................  
....................  
.................... // Description: Enumeration of different SD response types 
.................... typedef enum 
.................... { 
....................     R1,     // R1 type response 
....................     R1b,    // R1b type response 
....................     R2,     // R2 type response 
....................     R3,     // R3 type response  
....................     R7      // R7 type response  
.................... }RESP; 
....................  
.................... // Summary: SD card command data structure 
.................... // Description: The typMMC_CMD structure is used to create a command table of information needed for each relevant SD command 
.................... typedef struct 
.................... { 
....................     BYTE      CmdCode;          // The command code 
....................     BYTE      CRC;              // The CRC value for that command 
....................     RESP    responsetype;       // The response type 
....................     BYTE    moredataexpected;   // Set to MOREDATA or NODATA, depending on whether more data is expected or not 
.................... } typMMC_CMD; 
....................  
....................  
.................... // Summary: An SD command packet 
.................... // Description: This union represents different ways to access an SD card command packet 
.................... typedef union 
.................... { 
....................     // This structure allows array-style access of command bytes 
....................     struct 
....................     { 
....................         #ifdef __18CXX 
....................             BYTE field[6];      // BYTE array 
....................         #else 
....................             BYTE field[7]; 
....................         #endif 
....................     }; 
....................     // This structure allows byte-wise access of packet command bytes 
....................     struct 
....................     { 
....................         BYTE crc;               // The CRC byte 
....................         #if defined __C30__ 
....................             BYTE c30filler;     // Filler space (since bitwise declarations can't cross a WORD boundary) 
....................         #elif defined __C32__ 
....................             BYTE c32filler[3];  // Filler space (since bitwise declarations can't cross a DWORD boundary) 
....................         #endif 
....................          
....................         BYTE addr0;             // Address byte 0 
....................         BYTE addr1;             // Address byte 1 
....................         BYTE addr2;             // Address byte 2 
....................         BYTE addr3;             // Address byte 3 
....................         BYTE cmd;               // Command code byte 
....................     }; 
....................     // This structure allows bitwise access to elements of the command bytes 
....................     struct 
....................     { 
....................         BYTE  END_BIT:1;        // Packet end bit 
....................         BYTE  CRC7:7;           // CRC value 
....................         DWORD     address;      // Address 
....................         BYTE  CMD_INDEX:6;      // Command code 
....................         BYTE  TRANSMIT_BIT:1;   // Transmit bit 
....................         BYTE  START_BIT:1;      // Packet start bit 
....................     }; 
.................... } CMD_PACKET; 
....................  
....................  
.................... // Summary: The format of an R1 type response 
.................... // Description: This union represents different ways to access an SD card R1 type response packet. 
.................... typedef union 
.................... { 
....................     BYTE _byte;                         // Byte-wise access 
....................     // This structure allows bitwise access of the response 
....................     struct 
....................     { 
....................         unsigned IN_IDLE_STATE:1;       // Card is in idle state 
....................         unsigned ERASE_RESET:1;         // Erase reset flag 
....................         unsigned ILLEGAL_CMD:1;         // Illegal command flag 
....................         unsigned CRC_ERR:1;             // CRC error flag 
....................         unsigned ERASE_SEQ_ERR:1;       // Erase sequence error flag 
....................         unsigned ADDRESS_ERR:1;         // Address error flag 
....................         unsigned PARAM_ERR:1;           // Parameter flag    
....................         unsigned B7:1;                  // Unused bit 7 
....................     }; 
.................... } RESPONSE_1; 
....................  
.................... // Summary: The format of an R2 type response 
.................... // Description: This union represents different ways to access an SD card R2 type response packet 
.................... typedef union 
.................... { 
....................     WORD _word; 
....................     struct 
....................     { 
....................         BYTE      _byte0; 
....................         BYTE      _byte1; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned IN_IDLE_STATE:1; 
....................         unsigned ERASE_RESET:1; 
....................         unsigned ILLEGAL_CMD:1; 
....................         unsigned CRC_ERR:1; 
....................         unsigned ERASE_SEQ_ERR:1; 
....................         unsigned ADDRESS_ERR:1; 
....................         unsigned PARAM_ERR:1; 
....................         unsigned B7:1; 
....................         unsigned CARD_IS_LOCKED:1; 
....................         unsigned WP_ERASE_SKIP_LK_FAIL:1; 
....................         unsigned ERROR:1; 
....................         unsigned CC_ERROR:1; 
....................         unsigned CARD_ECC_FAIL:1; 
....................         unsigned WP_VIOLATION:1; 
....................         unsigned ERASE_PARAM:1; 
....................         unsigned OUTRANGE_CSD_OVERWRITE:1; 
....................     }; 
.................... } RESPONSE_2; 
....................  
.................... // Summary: The format of an R7 or R3 type response 
.................... // Description: This union represents different ways to access an SD card R7 type response packet. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         BYTE _byte;                         // Byte-wise access 
....................         union 
....................         { 
....................             //Note: The SD card argument response field is 32-bit, big endian format. 
....................             //However, the C compiler stores 32-bit values in little endian in RAM. 
....................             //When writing to the _returnVal/argument bytes, make sure to byte 
....................             //swap the order from which it arrived over the SPI from the SD card. 
....................             DWORD _returnVal; 
....................             struct 
....................             { 
....................                 BYTE _byte0; 
....................                 BYTE _byte1; 
....................                 BYTE _byte2; 
....................                 BYTE _byte3; 
....................             };     
....................         }argument;     
....................     } bytewise; 
....................     // This structure allows bitwise access of the response 
....................     struct 
....................     { 
....................         struct 
....................         { 
....................             unsigned IN_IDLE_STATE:1;       // Card is in idle state 
....................             unsigned ERASE_RESET:1;         // Erase reset flag 
....................             unsigned ILLEGAL_CMD:1;         // Illegal command flag 
....................             unsigned CRC_ERR:1;             // CRC error flag 
....................             unsigned ERASE_SEQ_ERR:1;       // Erase sequence error flag 
....................             unsigned ADDRESS_ERR:1;         // Address error flag 
....................             unsigned PARAM_ERR:1;           // Parameter flag    
....................             unsigned B7:1;                  // Unused bit 7 
....................         }bits; 
....................         DWORD _returnVal; 
....................     } bitwise; 
.................... } RESPONSE_7; 
....................  
.................... // Summary: A union of responses from an SD card 
.................... // Description: The MMC_RESPONSE union represents any of the possible responses that an SD card can return after 
.................... //              being issued a command. 
.................... typedef union 
.................... { 
....................     RESPONSE_1  r1;   
....................     RESPONSE_2  r2; 
....................     RESPONSE_7  r7; 
.................... }MMC_RESPONSE; 
....................  
....................  
.................... // Summary: A description of the card specific data register 
.................... // Description: This union represents different ways to access information in a packet with SD card CSD informaiton.  For more 
.................... //              information on the CSD register, consult an SD card user's manual. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         DWORD _u320; 
....................         DWORD _u321; 
....................         DWORD _u322; 
....................         DWORD _u323; 
....................     }; 
....................     struct 
....................     { 
....................         BYTE _byte[16]; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned NOT_USED           :1; 
....................         unsigned CRC                :7; 
....................         unsigned ECC                :2; 
....................         unsigned FILE_FORMAT        :2; 
....................         unsigned TMP_WRITE_PROTECT  :1; 
....................         unsigned PERM_WRITE_PROTECT :1; 
....................         unsigned COPY               :1; 
....................         unsigned FILE_FORMAT_GRP    :1; 
....................         unsigned RESERVED_1         :5; 
....................         unsigned WRITE_BL_PARTIAL   :1; 
....................         unsigned WRITE_BL_LEN_L     :2; 
....................         unsigned WRITE_BL_LEN_H     :2; 
....................         unsigned R2W_FACTOR         :3; 
....................         unsigned DEFAULT_ECC        :2; 
....................         unsigned WP_GRP_ENABLE      :1; 
....................         unsigned WP_GRP_SIZE        :5; 
....................         unsigned ERASE_GRP_SIZE_L   :3; 
....................         unsigned ERASE_GRP_SIZE_H   :2; 
....................         unsigned SECTOR_SIZE        :5; 
....................         unsigned C_SIZE_MULT_L      :1; 
....................         unsigned C_SIZE_MULT_H      :2; 
....................         unsigned VDD_W_CURR_MAX     :3; 
....................         unsigned VDD_W_CUR_MIN      :3; 
....................         unsigned VDD_R_CURR_MAX     :3; 
....................         unsigned VDD_R_CURR_MIN     :3; 
....................         unsigned C_SIZE_L           :2; 
....................         unsigned C_SIZE_H           :8; 
....................         unsigned C_SIZE_U           :2; 
....................         unsigned RESERVED_2         :2; 
....................         unsigned DSR_IMP            :1; 
....................         unsigned READ_BLK_MISALIGN  :1; 
....................         unsigned WRITE_BLK_MISALIGN :1; 
....................         unsigned READ_BL_PARTIAL    :1; 
....................         unsigned READ_BL_LEN        :4; 
....................         unsigned CCC_L              :4; 
....................         unsigned CCC_H              :8; 
....................         unsigned TRAN_SPEED         :8; 
....................         unsigned NSAC               :8; 
....................         unsigned TAAC               :8; 
....................         unsigned RESERVED_3         :2; 
....................         unsigned SPEC_VERS          :4; 
....................         unsigned CSD_STRUCTURE      :2; 
....................     }; 
.................... } CSD; 
....................  
....................  
.................... // Summary: A description of the card information register 
.................... // Description: This union represents different ways to access information in a packet with SD card CID register informaiton.  For more 
.................... //              information on the CID register, consult an SD card user's manual. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         DWORD _u320; 
....................         DWORD _u321; 
....................         DWORD _u322; 
....................         DWORD _u323; 
....................     }; 
....................     struct 
....................     { 
....................         BYTE _byte[16]; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned    NOT_USED            :1; 
....................         unsigned    CRC                 :7; 
....................         unsigned    MDT                 :8; 
....................         DWORD       PSN; 
....................         unsigned    PRV                 :8; 
....................         char        PNM[6]; 
....................         WORD        OID; 
....................         unsigned    MID                 :8; 
....................     }; 
.................... } CID; 
....................  
.................... #ifndef FALSE 
....................     #define FALSE   0 
.................... #endif 
.................... #ifndef TRUE 
....................     #define TRUE    !FALSE 
.................... #endif 
....................  
.................... #define INPUT   1 
.................... #define OUTPUT  0 
....................  
....................  
.................... // Description: A delay prescaler 
.................... #define DELAY_PRESCALER   (BYTE)      8 
....................  
.................... // Description: An approximation of the number of cycles per delay loop of overhead 
.................... #define DELAY_OVERHEAD    (BYTE)      5 
....................  
.................... // Description: An approximate calculation of how many times to loop to delay 1 ms in the Delayms function 
.................... #define MILLISECDELAY   (WORD)      ((GetInstructionClock()/DELAY_PRESCALER/(WORD)1000) - DELAY_OVERHEAD) 
....................  
....................  
.................... // Desription: Media Response Delay Timeouts  
.................... #define NCR_TIMEOUT     (WORD)20        //Byte times before command response is expected (must be at least 8) 
.................... #define NAC_TIMEOUT     (DWORD)0x40000  //SPI byte times we should wait when performing read operations (should be at least 100ms for SD cards) 
.................... #define WRITE_TIMEOUT   (DWORD)0xA0000  //SPI byte times to wait before timing out when the media is performing a write operation (should be at least 250ms for SD cards). 
....................  
.................... // Summary: An enumeration of SD commands 
.................... // Description: This enumeration corresponds to the position of each command in the sdmmc_cmdtable array 
.................... //              These macros indicate to the SendMMCCmd function which element of the sdmmc_cmdtable array 
.................... //              to retrieve command code information from. 
.................... typedef enum 
.................... { 
....................     GO_IDLE_STATE, 
....................     SEND_OP_COND, 
....................     SEND_IF_COND, 
....................     SEND_CSD, 
....................     SEND_CID, 
....................     STOP_TRANSMISSION, 
....................     SEND_STATUS, 
....................     SET_BLOCKLEN, 
....................     READ_SINGLE_BLOCK, 
....................     READ_MULTI_BLOCK, 
....................     WRITE_SINGLE_BLOCK, 
....................     WRITE_MULTI_BLOCK, 
....................     TAG_SECTOR_START, 
....................     TAG_SECTOR_END, 
....................     ERASE, 
....................     APP_CMD, 
....................     READ_OCR, 
....................     CRC_ON_OFF, 
....................     SD_SEND_OP_COND, 
....................     SET_WR_BLK_ERASE_COUNT 
.................... }sdmmc_cmd; 
....................  
....................  
.................... #define SD_MODE_NORMAL  0 
.................... #define SD_MODE_HC      1 
....................  
....................  
.................... //Definition for a structure used when calling either MDD_SDSPI_AsyncReadTasks()  
.................... //function, or the MDD_SDSPI_AsyncWriteTasks() function. 
.................... typedef struct 
.................... { 
....................     WORD wNumBytes;         //Number of bytes to attempt to read or write in the next call to MDD_SDSPI_AsyncReadTasks() or MDD_SDSPI_AsyncWriteTasks.  May be updated between calls to the handler. 
....................     DWORD dwBytesRemaining; //Should be initialized to the total number of bytes that you wish to read or write.  This value is allowed to be greater than a single block size of the media. 
....................     BYTE* pBuffer;          //Pointer to where the read/written bytes should be copied to/from.  May be updated between calls to the handler function. 
....................     DWORD dwAddress;        //Starting block address to read or to write to on the media.  Should only get initialized, do not modify after that. 
....................     BYTE bStateVariable;    //State machine variable.  Should get initialized to ASYNC_READ_QUEUED or ASYNC_WRITE_QUEUED to start an operation.  After that, do not modify until the read or write is complete. 
.................... }ASYNC_IO;    
....................  
....................  
.................... //Response codes for the MDD_SDSPI_AsyncReadTasks() function. 
.................... //#define ASYNC_READ_COMPLETE             0x00 
.................... #define ASYNC_READ_BUSY                 0x01 
.................... //#define ASYNC_READ_NEW_PACKET_READY     0x02 
.................... //#define ASYNC_READ_ERROR                0xFF 
....................  
.................... //MDD_SDSPI_AsyncReadTasks() state machine variable values.  These are used internally to SD-SPI.c. 
.................... #define ASYNC_READ_COMPLETE             0x00 
.................... #define ASYNC_READ_QUEUED               0x01    //Initialize to this to start a read sequence 
.................... #define ASYNC_READ_WAIT_START_TOKEN     0x03 
.................... #define ASYNC_READ_NEW_PACKET_READY     0x02 
.................... #define ASYNC_READ_ABORT                0xFE 
.................... #define ASYNC_READ_ERROR                0xFF 
....................  
.................... //Possible return values when calling MDD_SDSPI_AsyncWriteTasks() 
.................... //#define ASYNC_WRITE_COMPLETE        0x00 
.................... #define ASYNC_WRITE_SEND_PACKET     0x02 
.................... #define ASYNC_WRITE_BUSY            0x03 
.................... //#define ASYNC_WRITE_ERROR           0xFF 
....................  
.................... //MDD_SDSPI_AsyncWriteTasks() state machine variable values.  These are used internally to SD-SPI.c. 
.................... #define ASYNC_WRITE_COMPLETE            0x00 
.................... #define ASYNC_WRITE_QUEUED              0x01    //Initialize to this to start a write sequence 
.................... #define ASYNC_WRITE_TRANSMIT_PACKET     0x02 
.................... #define ASYNC_WRITE_MEDIA_BUSY          0x03 
.................... #define ASYNC_STOP_TOKEN_SENT_WAIT_BUSY 0x04 
.................... #define ASYNC_WRITE_ABORT               0xFE 
.................... #define ASYNC_WRITE_ERROR               0xFF 
....................  
....................  
.................... //Constants 
.................... #define MEDIA_BLOCK_SIZE            512u  //Should always be 512 for v1 and v2 devices. 
.................... #define WRITE_RESPONSE_TOKEN_MASK   0x1F  //Bit mask to AND with the write token response byte from the media, to clear the don't care bits. 
....................  
....................  
....................  
.................... /***************************************************************************/ 
.................... /*                               Macros                                    */ 
.................... /***************************************************************************/ 
....................  
.................... // Description: A macro to send clock cycles to dummy-read the CRC 
.................... #define mReadCRC()              WriteSPIM(0xFF);WriteSPIM(0xFF); 
....................  
.................... // Description: A macro to send clock cycles to dummy-write the CRC 
.................... #define mSendCRC()              WriteSPIM(0xFF);WriteSPIM(0xFF); 
....................  
.................... // Description: A macro to send 8 clock cycles for SD timing requirements 
.................... #define mSend8ClkCycles()       WriteSPIM(0xFF); 
....................  
.................... /*****************************************************************************/ 
.................... /*                                 Public Prototypes                         */ 
.................... /*****************************************************************************/ 
....................  
.................... //These are the public API functions provided by SD-SPI.c 
.................... BYTE MDD_SDSPI_MediaDetect(void); 
.................... MEDIA_INFORMATION * MDD_SDSPI_MediaInitialize(void); 
.................... DWORD MDD_SDSPI_ReadCapacity(void); 
.................... WORD MDD_SDSPI_ReadSectorSize(void); 
.................... void MDD_SDSPI_InitIO(void); 
.................... BYTE MDD_SDSPI_SectorRead(DWORD sector_addr, BYTE* buffer); 
.................... BYTE MDD_SDSPI_SectorWrite(DWORD sector_addr, BYTE* buffer, BYTE allowWriteToZero); 
.................... BYTE MDD_SDSPI_AsyncReadTasks(ASYNC_IO*); 
.................... BYTE MDD_SDSPI_AsyncWriteTasks(ASYNC_IO*); 
.................... BYTE MDD_SDSPI_WriteProtectState(void); 
.................... BYTE MDD_SDSPI_ShutdownMedia(void); 
....................  
....................  
.................... #if defined __C30__ || defined __C32__ 
....................     extern BYTE ReadByte( BYTE* pBuffer, WORD index ); 
....................     extern WORD ReadWord( BYTE* pBuffer, WORD index ); 
....................     extern DWORD ReadDWord( BYTE* pBuffer, WORD index ); 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #endif 
.................... #ifdef USE_CF_INTERFACE_WITH_PMP 
....................     #include    "CF-PMP.h" 
.................... #endif 
.................... #ifdef USE_MANUAL_CF_INTERFACE 
....................     #include    "CF- Bit transaction.h" 
.................... #endif 
.................... #ifdef USE_USB_INTERFACE 
....................     #include    "usb_host_msd_scsi.h" 
.................... #endif 
.................... #ifdef USE_INTERNAL_FLASH 
....................     #include    "Internal Flash.h" 
.................... #endif 
....................  
....................  
.................... /*******************************************************************/ 
.................... /*                     Strunctures and defines                     */ 
.................... /*******************************************************************/ 
....................  
.................... #ifndef FALSE 
....................     // Summary: False value 
....................     // Description:  This macro will indicate that a condition is false. 
....................     #define FALSE   0 
.................... #endif 
.................... #ifndef TRUE 
....................     // Summary: True value 
....................     // Description: This macro will indicate that a condition is true. 
....................     #define TRUE    !FALSE  // True value 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #ifndef SEEK_SET 
....................     // Summary: Macro for the FSfseek SEEK_SET base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed  
....................     //              relative to the beginning of the file. 
....................     #define SEEK_SET 0 
....................  
.................... #endif 
.................... #ifndef SEEK_CUR 
....................  
....................     // Summary: Macro for the FSfseek SEEK_CUR base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the current location of the file 
....................     #define SEEK_CUR 1 
....................  
.................... #endif 
.................... #ifndef SEEK_END 
....................  
....................     // Summary: Macro for the FSfseek SEEK_END base location 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the end of the file.  For this macro, the offset value will be subtracted from 
....................     //              the end location of the file by default. 
....................     #define SEEK_END 2 
....................  
.................... #endif 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file. 
.................... #define FS_APPEND   "a" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file. 
.................... #define FS_WRITE    "w" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file. 
.................... #define FS_READ "r" 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file 
.................... //              or read from the file. 
.................... #define FS_APPENDPLUS   "a+" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file or read from the file. 
.................... #define FS_WRITEPLUS    "w+" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file or write to the file. 
.................... #define FS_READPLUS     "r+" 
....................  
.................... #ifndef intmax_t 
....................     #ifdef __PIC24F__ 
....................         // Summary: A data type indicating the maximum integer size in an architecture 
....................         // Description: The intmax_t data type refers to the maximum-sized data type on any given architecture.  This 
....................         //              data type can be specified as a format specifier size specification for the FSfprintf function. 
....................         #define intmax_t long long 
....................     #elif defined __PIC24H__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC30F__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC33F__ 
....................         #define intmax_t long long 
....................     #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary:  Indicates flag conditions for a file object 
.................... // Description: The FILEFLAGS structure is used to indicate conditions in a file.  It contains three flags: 'write' indicates 
.................... //              that the file was opened in a mode that allows writes, 'read' indicates that the file was opened in a mode 
.................... //              that allows reads, and 'FileWriteEOF' indicates that additional data that is written to the file will increase 
.................... //              the file size. 
.................... typedef struct 
.................... { 
....................     unsigned    write :1;           // Indicates a file was opened in a mode that allows writes 
....................     unsigned    read :1;            // Indicates a file was opened in a mode that allows reads 
....................     unsigned    FileWriteEOF :1;    // Indicates the current position in a file is at the end of the file 
.................... }FILEFLAGS; 
....................  
....................  
....................  
.................... // Summary: Indicates how to search for file entries in the FILEfind function 
.................... // Description: The values in the SEARCH_TYPE enumeration are used internally by the library to indicate how the FILEfind function 
.................... //              how to perform a search.  The 'LOOK_FOR_EMPTY_ENTRY' value indicates that FILEfind should search for an empty file entry. 
.................... //              The 'LOOK_FOR_MATCHING_ENTRY' value indicates that FILEfind should search for an entry that matches the FSFILE object 
.................... //              that was passed into the FILEfind function. 
.................... typedef enum{ 
....................     LOOK_FOR_EMPTY_ENTRY = 0, 
....................     LOOK_FOR_MATCHING_ENTRY 
.................... } SEARCH_TYPE; 
....................  
....................  
....................  
.................... // Summary: Macro indicating the length of a 8.3 file name 
.................... // Description: The TOTAL_FILE_SIZE_8P3 macro indicates the maximum number of characters in an 8.3 file name.  This value includes 
.................... //              8 characters for the name, three for the extentsion, and 1 for the radix ('.') 
.................... #define TOTAL_FILE_SIZE_8P3             (8+3+1) 
.................... #define TOTAL_FILE_SIZE                 TOTAL_FILE_SIZE_8P3 
....................  
.................... // Summary: Macro indicating the max length of a LFN file name 
.................... // Description: The MAX_FILE_NAME_LENGTH_LFN macro indicates the maximum number of characters in an LFN file name. 
.................... #define MAX_FILE_NAME_LENGTH_LFN             256 
....................  
.................... // Summary: A mask that indicates the limit of directory entries in a sector 
.................... // Description: The MASK_MAX_FILE_ENTRY_LIMIT_BITS is used to indicate to the Cache_File_Entry function that a new sector needs to 
.................... //              be loaded. 
.................... #define MASK_MAX_FILE_ENTRY_LIMIT_BITS          0x0f 
....................  
.................... // Summary: Value used for shift operations to calculate the sector offset in a directory 
.................... // Description: The VALUE_BASED_ON_ENTRIES_PER_CLUSTER macro is used to calculate sector offsets for directories.  The position of the 
.................... //              entry is shifted by 4 bits (divided by 16, since there are 16 entries in a sector) to calculate how many sectors a 
.................... //              specified entry is offset from the beginning of the directory. 
.................... #define VALUE_BASED_ON_ENTRIES_PER_CLUSTER      4 
....................  
.................... // Summary: A value that will indicate that a dotdot directory entry points to the root. 
.................... // Description: The VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT macro is used as an absolute address when writing information to a dotdot entry 
.................... //              in a newly created directory.  If a dotdot entry points to the root directory, it's cluster value must be set to 0, 
.................... //              regardless of the actual cluster number of the root directory. 
.................... #define VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT     0 
....................  
.................... // Summary: MAcro indicating the length of an 8.3 file name in a directory entry 
.................... // Description: The FILE_NAME_SIZE_8P3 macro indicates the number of characters that an 8.3 file name will take up when packed in 
.................... //              a directory entry.  This value includes 8 characters for the name and 3 for the extension.  Note that the radix is not 
.................... //              stored in the directory entry. 
.................... #define FILE_NAME_SIZE_8P3           11 
.................... #define FILE_NAME_SIZE               FILE_NAME_SIZE_8P3 
....................  
....................  
.................... // Summary: Contains file information and is used to indicate which file to access. 
.................... // Description: The FSFILE structure is used to hold file information for an open file as it's being modified or accessed.  A pointer to  
.................... //              an open file's FSFILE structure will be passeed to any library function that will modify that file. 
.................... typedef struct 
.................... { 
....................     DISK    *       dsk;            // Pointer to a DISK structure 
....................     DWORD           cluster;        // The first cluster of the file 
....................     DWORD           ccls;           // The current cluster of the file 
....................     WORD            sec;            // The current sector in the current cluster of the file 
....................     WORD            pos;            // The position in the current sector 
....................     DWORD           seek;           // The absolute position in the file 
....................     DWORD           size;           // The size of the file 
....................     FILEFLAGS       flags;          // A structure containing file flags 
....................     WORD            time;           // The file's last update time 
....................     WORD            date;           // The file's last update date 
....................     char            name[FILE_NAME_SIZE_8P3];       // The short name of the file 
....................    #ifdef SUPPORT_LFN 
....................        BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNptr;           // Pointer to long file name in UTF16 format 
....................       unsigned short int utf16LFNlength;          // LFN length in terms of words excluding the NULL word at the last. 
....................    #endif 
....................     WORD            entry;          // The position of the file's directory entry in it's directory 
....................     WORD            chk;            // File structure checksum 
....................     WORD            attributes;     // The file attributes 
....................     DWORD           dirclus;        // The base cluster of the file's directory 
....................     DWORD           dirccls;        // The current cluster of the file's directory 
.................... } FSFILE; 
....................  
.................... /* Summary: Possible results of the FSGetDiskProperties() function. 
.................... ** Description: See the FSGetDiskProperties() function for more information. 
.................... */ 
.................... typedef enum 
.................... { 
....................     FS_GET_PROPERTIES_NO_ERRORS = 0, 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED, 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE, 
....................     FS_GET_PROPERTIES_STILL_WORKING = 0xFF 
.................... } FS_DISK_ERRORS; 
....................  
....................  
.................... /* Summary: Contains the disk search information, intermediate values, and results 
.................... ** Description: This structure is used in conjunction with the FSGetDiskProperties() 
.................... **              function.  See that function for more information about the usage. 
.................... */ 
.................... typedef struct 
.................... { 
....................     DISK *  disk;           /* pointer to the disk we are searching */ 
....................     BOOL    new_request;    /* is this a new request or a continued request */ 
....................     FS_DISK_ERRORS properties_status;  /* status of the last call of the function */ 
....................  
....................     struct 
....................     { 
....................         BYTE disk_format;           /* disk format: FAT12, FAT16, FAT32 */ 
....................         WORD sector_size;           /* sector size of the drive */ 
....................         BYTE sectors_per_cluster;   /* number of sectors per cluster */ 
....................         DWORD total_clusters;       /* the number of total clusters on the drive */ 
....................         DWORD free_clusters;        /* the number of free (unused) clusters on drive */ 
....................     } results;                      /* the results of the current search */ 
....................  
....................     struct 
....................     { 
....................         DWORD   c;      
....................         DWORD   curcls; 
....................         DWORD   EndClusterLimit; 
....................         DWORD   ClusterFailValue; 
....................     } private;      /* intermediate values used to continue searches.  This 
....................                          member should be used only by the FSGetDiskProperties() 
....................                          function */ 
....................  
.................... } FS_DISK_PROPERTIES; 
....................  
.................... // Summary: A structure used for searching for files on a device. 
.................... // Description: The SearchRec structure is used when searching for file on a device.  It contains parameters that will be loaded with 
.................... //              file information when a file is found.  It also contains the parameters that the user searched for, allowing further 
.................... //              searches to be perfomed in the same directory for additional files that meet the specified criteria. 
.................... typedef struct 
.................... { 
....................     char            filename[FILE_NAME_SIZE_8P3 + 2];   // The name of the file that has been found 
....................     unsigned char   attributes;                     // The attributes of the file that has been found 
....................     unsigned long   filesize;                       // The size of the file that has been found 
....................     unsigned long   timestamp;                      // The last modified time of the file that has been found (create time for directories) 
....................    #ifdef SUPPORT_LFN 
....................       BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNfound;          // Pointer to long file name found in UTF16 format 
....................       unsigned short int utf16LFNfoundLength;     // LFN Found length in terms of words including the NULL word at the last. 
....................    #endif 
....................     unsigned int    entry;                          // The directory entry of the last file found that matches the specified attributes. (Internal use only) 
....................     char            searchname[FILE_NAME_SIZE_8P3 + 2]; // The 8.3 format name specified when the user began the search. (Internal use only) 
....................     unsigned char   searchattr;                     // The attributes specified when the user began the search. (Internal use only) 
....................     unsigned long   cwdclus;                        // The directory that this search was performed in. (Internal use only) 
....................     unsigned char   initialized;                    // Check to determine if the structure was initialized by FindFirst (Internal use only) 
.................... } SearchRec; 
....................  
....................  
.................... /*************************************************************************** 
.................... * Prototypes                                                               * 
.................... ***************************************************************************/ 
....................  
....................  
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     int FSInit(void) 
....................   Summary: 
....................     Function to initialize the device. 
....................   Conditions: 
....................     The physical device should be connected to the microcontroller. 
....................   Input: 
....................     None 
....................   Return Values: 
....................     TRUE -  Initialization successful 
....................     FALSE - Initialization unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function initializes the file system stack & the interfacing device. 
....................     Initializes the static or dynamic memory slots for holding file 
....................     structures. Initializes the device with the DISKmount function. Loads  
....................     MBR and boot sector information. Initializes the current working 
....................     directory to the root directory for the device if directory support 
....................     is enabled. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... int FSInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * FSfopen (const char * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with ascii input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will open a ascii name file or directory on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * FSfopen(const char * fileName, const char *mode); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * wFSfopen (const unsigned short int * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * wFSfopen(const unsigned short int * fileName, const char *mode); 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................  
.................... /****************************************************************************** 
....................   Function: 
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode) 
....................   Summary: 
....................     Opens a file on PIC18 Microcontrollers where 'fileName' ROM string is given 
....................     in Ascii format. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to be opened (ROM) 
....................     mode -      The mode the file will be opened in (ROM) 
....................   Return Values: 
....................     FSFILE * - A pointer to the file object 
....................     NULL -     File could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file on PIC18 Microcontrollers where 'fileName' ROM string 
....................     is given in Ascii format.The FSfopenpgm function will copy a PIC18 ROM fileName and 
....................     mode argument into RAM arrays, and then pass those arrays to the FSfopen function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   ******************************************************************************/ 
....................  
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode); 
....................  
....................  
.................... /************************************************************************************** 
....................   Function: 
....................     int FindFirstpgm (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Find a file named with a ROM string on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName -  The name of the file to be found (ROM) 
....................     attr -      The attributes of the file to be found 
....................     rec -       Pointer to a search record to store the file info in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the given parameters was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirstpgm call on passed SearchRec object 
....................     will be lost.The FSerrno variable will be changed. 
....................   Description: 
....................     This function finds a file named with 'fileName' on PIC18. The FindFirstpgm 
....................     function will copy a PIC18 ROM fileName argument into a RAM array, and then 
....................     pass that array to the FindFirst function. 
....................   Remarks: 
....................     Call FindFirstpgm or FindFirst before calling FindNext. 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************************/ 
....................  
....................     int FindFirstpgm (const rom char * fileName, unsigned int attr, SearchRec * rec); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdirpgm (const rom char * path) 
....................   Summary: 
....................     Changes the CWD to the input path on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to (ROM) 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the CWD to the input path on PIC18.The FSchdirpgm function 
....................     passes a PIC18 ROM path pointer to the chdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM 
....................   **************************************************************************/ 
....................  
....................     int FSchdirpgm (const rom char * path); 
....................  
....................     #ifdef ALLOW_WRITES 
....................  
....................  
.................... /************************************************************* 
....................   Function: 
....................     int FSremovepgm (const rom char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC18 device 
....................   Conditions: 
....................     File not opened; file exists 
....................   Input: 
....................     fileName -  The name of the file to be deleted (ROM) 
....................   Return Values: 
....................     0 -  File was removed successfully 
....................     -1 - File could not be removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC18 device.The FSremovepgm function will copy a 
....................     PIC18 ROM fileName argument into a RAM array, and then pass that array 
....................     to the FSremove function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   *************************************************************/ 
....................  
....................         int FSremovepgm (const rom char * fileName); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdirpgm (const rom char * path) 
....................   Summary: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create (ROM) 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices.'FSmkdirpgm' creates the directories as per the input 
....................     string path.This function doesn't move the current working 
....................     directory setting. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arugments in ROM 
....................   **************************************************************************/ 
....................  
....................         int FSmkdirpgm (const rom char * path); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdirpgm (const rom char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     path -      The path of the directory to remove (ROM) 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................     This function deletes the directory as specified in the path. 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************/ 
....................  
....................         int FSrmdirpgm (const rom char * path, unsigned char rmsubdirs); 
....................  
....................  
.................... /***************************************************************** 
....................   Function: 
....................     int FSrenamepgm(const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the file with the ascii ROM string(PIC18) 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file (in ROM) 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -  File renamed successfully 
....................     -1 - File could not be renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the file with the ascii ROM string(PIC18).The Fsrenamepgm 
....................     function will copy the rom fileName specified by the user into a  
....................     RAM array and pass that array into the FSrename function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM.                        
....................   *****************************************************************/ 
....................  
....................         int FSrenamepgm (const rom char * fileName, FSFILE * fo); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************ 
....................   Function: 
....................     int FSfclose(FSFILE *fo) 
....................   Summary: 
....................     Update file information and free FSFILE objects 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to the file to close 
....................   Return Values: 
....................     0 -   File closed successfully  
....................     EOF - Error closing the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will update the directory entry for the  
....................     file pointed to by 'fo' with the information contained 
....................     in 'fo,' including the new file size and attributes. 
....................     Timestamp information will also be loaded based on the 
....................     method selected by the user and written to the entry 
....................     as the last modified time and date.  The file entry will 
....................     then be written to the device.  Finally, the memory 
....................     used for the specified file object will be freed from 
....................     the dynamic heap or the array of FSFILE objects. 
....................   Remarks: 
....................     A function to flush data to the device without closing the 
....................     file can be created by removing the portion of this 
....................     function that frees the memory and the line that clears 
....................     the write flag. 
....................   ************************************************************/ 
....................  
.................... int FSfclose(FSFILE *fo); 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     void FSrewind (FSFILE * fo) 
....................   Summary: 
....................     Set the current position in a file to the beginning 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The FSrewind funciton will reset the position of the 
....................     specified file to the beginning of the file.  This 
....................     functionality is faster than using FSfseek to reset 
....................     the position in the file. 
....................   Remarks: 
....................     None. 
....................   *********************************************************/ 
....................  
.................... void FSrewind (FSFILE *fo); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Read data from a file 
....................   Conditions: 
....................     File is opened in a read mode 
....................   Input: 
....................     ptr -     Destination buffer for read bytes 
....................     size -    Size of units in bytes 
....................     n -       Number of units to be read 
....................     stream -  File to be read from 
....................   Return: 
....................     size_t - number of units read 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfread function will read data from the specified file.  First, 
....................     the appropriate sector of the file is loaded.  Then, data is read into 
....................     the specified buffer until the specified number of bytes have been read. 
....................     When a cluster boundary is reached, a new cluster will be loaded.  The 
....................     parameters 'size' and 'n' indicate how much data to read.  'Size' 
....................     refers to the size of one object to read (in bytes), and 'n' will refer  
....................     to the number of these objects to read.  The value returned will be equal  
....................     to 'n' unless an error occured or the user tried to read beyond the end 
....................     of the file. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream); 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FSfseek(FSFILE *stream, long offset, int whence) 
....................   Summary: 
....................     Change the current position in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     stream -    Pointer to file structure 
....................     offset -    Offset from base location 
....................     whence -     
....................            - SEEK_SET -  Seek from start of file 
....................            - SEEK_CUR -  Seek from current location 
....................            - SEEK_END -  Seek from end of file (subtract offset) 
....................   Return Values: 
....................     0 -  Operation successful  
....................     -1 - Operation unsuccesful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfseek function will change the current position in the file to 
....................     one specified by the user.  First, an absolute offset is calculated 
....................     using the offset and base location passed in by the user.  Then, the 
....................     position variables are updated, and the sector number that corresponds 
....................     to the new location.  That sector is then loaded.  If the offset 
....................     falls exactly on a cluster boundary, a new cluster will be allocated 
....................     to the file and the position will be set to the first byte of that 
....................     cluster. 
....................   Remarks: 
....................     None                                                                
....................   **********************************************************************/ 
....................  
.................... int FSfseek(FSFILE *stream, long offset, int whence); 
....................  
....................  
.................... /******************************************************************* 
....................   Function: 
....................     long FSftell (FSFILE * fo) 
....................   Summary: 
....................     Determine the current location in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return: Current location in the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     The FSftell function will return the current position in the 
....................     file pointed to by 'fo' by returning the 'seek' variable in the 
....................     FSFILE object, which is used to keep track of the absolute 
....................     location of the current position in the file. 
....................   Remarks: 
....................     None                                                             
....................   *******************************************************************/ 
....................  
.................... long FSftell(FSFILE *fo); 
....................  
....................  
.................... /**************************************************** 
....................   Function: 
....................     int FSfeof( FSFILE * stream ) 
....................   Summary: 
....................     Indicate whether the current file position is at the end 
....................   Conditions: 
....................     File is open in a read mode 
....................   Input: 
....................     stream -  Pointer to the target file 
....................   Return Values: 
....................     Non-Zero - EOF reached  
....................     0 - Not at end of File 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfeof function will indicate that the end-of- 
....................     file has been reached for the specified file by 
....................     comparing the absolute location in the file to the 
....................     size of the file. 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... int FSfeof( FSFILE * stream ); 
....................  
....................  
.................... #ifdef ALLOW_FORMATS 
.................... /******************************************************************* 
....................   Function: 
....................     int FSformat (char mode, long int serialNumber, char * volumeID) 
....................   Summary: 
....................     Formats a device 
....................   Conditions: 
....................     The device must possess a valid master boot record. 
....................   Input: 
....................     mode -          - 0 - Just erase the FAT and root 
....................                     - 1 - Create a new boot sector 
....................     serialNumber -  Serial number to write to the card 
....................     volumeID -      Name of the card 
....................   Return Values: 
....................     0 -    Format was successful 
....................     EOF -  Format was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSformat function can be used to create a new boot sector 
....................     on a device, based on the information in the master boot record. 
....................     This function will first initialize the I/O pins and the device, 
....................     and then attempts to read the master boot record.  If the MBR 
....................     cannot be loaded successfully, the function will fail.  Next, if 
....................     the 'mode' argument is specified as '0' the existing boot sector 
....................     information will be loaded.  If the 'mode' argument is '1' an 
....................     entirely new boot sector will be constructed using the disk 
....................     values from the master boot record.  Once the boot sector has 
....................     been successfully loaded/created, the locations of the FAT and 
....................     root will be loaded from it, and they will be completely 
....................     erased.  If the user has specified a volumeID parameter, a  
....................     VOLUME attribute entry will be created in the root directory 
....................     to name the device. 
....................  
....................     FAT12, FAT16 and FAT32 formatting are supported. 
....................  
....................     Based on the number of sectors, the format function automatically 
....................     compute the smallest possible value for the cluster size in order to 
....................     accommodate the physical size of the media. In this case, if a media  
....................     with a big capacity is formatted, the format function may take a very 
....................     long time to write all the FAT tables.  
....................  
....................     Therefore, the FORMAT_SECTORS_PER_CLUSTER macro may be used to  
....................     specify the exact cluster size (in multiples of sector size). This  
....................     macro can be defined in FSconfig.h 
....................  
....................   Remarks: 
....................     Only devices with a sector size of 512 bytes are supported by the  
....................     format function                       
....................   *******************************************************************/ 
....................  
.................... int FSformat (char mode, long int serialNumber, char * volumeID); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_WRITES 
.................... /*************************************************************************** 
....................   Function: 
....................     int FSattrib (FSFILE * file, unsigned char attributes) 
....................   Summary: 
....................     Change the attributes of a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     file -        Pointer to file structure 
....................     attributes -  The attributes to set for the file 
....................                -  Attribute -      Value - Indications  
....................                -  ATTR_READ_ONLY - 0x01  - The read-only attribute 
....................                -  ATTR_HIDDEN -    0x02  - The hidden attribute  
....................                -  ATTR_SYSTEM -    0x04  - The system attribute  
....................                -  ATTR_ARCHIVE -   0x20  - The archive attribute 
....................   Return Values: 
....................     0 -  Attribute change was successful  
....................     -1 - Attribute change was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSattrib funciton will set the attributes of the specified file 
....................     to the attributes passed in by the user.  This function will load the 
....................     file entry, replace the attributes with the ones specified, and write 
....................     the attributes back.  If the specified file is a directory, the 
....................     directory attribute will be preserved. 
....................   Remarks: 
....................     None                                                                 
....................   ***************************************************************************/ 
....................  
.................... int FSattrib (FSFILE * file, unsigned char attributes); 
....................  
....................  
.................... /*************************************************************** 
....................   Function: 
....................     int FSrename (const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices. 
....................     First, it will search through the current working directory to ensure the 
....................     specified new filename is not already in use. If it isn't, the new filename 
....................     will be written to the file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None                                                         
....................   ***************************************************************/ 
....................  
.................... int FSrename (const char * fileName, FSFILE * fo); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*************************************************************** 
....................   Function: 
....................     int wFSrename (const rom unsigned short int * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices. First, it will search through the current 
....................     working directory to ensure the specified new UTF16 filename is not 
....................     already in use.  If it isn't, the new filename will be written to the 
....................     file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None 
....................   ***************************************************************/ 
....................  
.................... int wFSrename (const unsigned short int * fileName, FSFILE * fo); 
.................... #endif 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     int FSremove (const char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed  
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................     The FSremove function will attempt to find the specified file with the FILEfind 
....................     function.  If the file is found, it will be erased using the FILEerase function. 
....................     The user can also provide ascii alias name of the ascii long file name as the 
....................     input to this function to get it erased from the memory. 
....................   Remarks: 
....................     None                                        
....................   **********************************************************************/ 
....................  
.................... int FSremove (const char * fileName); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     int wFSremove (const unsigned short int * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed 
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................     The wFSremove function will attempt to find the specified UTF16 file 
....................     name with the FILEfind function. If the file is found, it will be erased 
....................     using the FILEerase function. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int wFSremove (const unsigned short int * fileName); 
.................... #endif 
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Write data to a file 
....................   Conditions: 
....................     File opened in FS_WRITE, FS_APPEND, FS_WRITE+, FS_APPEND+, FS_READ+ mode 
....................   Input: 
....................     data_to_write -     Pointer to source buffer 
....................     size -              Size of units in bytes 
....................     n -                 Number of units to transfer 
....................     stream -            Pointer to file structure 
....................   Return: 
....................     size_t - number of units written 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfwrite function will write data to a file.  First, the sector that 
....................     corresponds to the current position in the file will be loaded (if it hasn't 
....................     already been cached in the global data buffer).  Data will then be written to 
....................     the device from the specified buffer until the specified amount has been written. 
....................     If the end of a cluster is reached, the next cluster will be loaded, unless 
....................     the end-of-file flag for the specified file has been set.  If it has, a new 
....................     cluster will be allocated to the file.  Finally, the new position and filesize 
....................     will be stored in the FSFILE object.  The parameters 'size' and 'n' indicate how  
....................     much data to write.  'Size' refers to the size of one object to write (in bytes),  
....................     and 'n' will refer to the number of these objects to write.  The value returned  
....................     will be equal  to 'n' unless an error occured. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************************/ 
....................  
.................... size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream); 
....................  
.................... #endif 
....................  
.................... #ifdef ALLOW_DIRS 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdir (char * path) 
....................   Summary: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC). 
....................     The FSchdir function passes a RAM pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSchdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSchdir (unsigned short int * path) 
....................   Summary: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC).The FSchdir function passes a RAM 
....................     pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSchdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************** 
....................   Function: 
....................     char * FSgetcwd (char * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in Ascii format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in Ascii format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * FSgetcwd (char * path, int numbchars); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************** 
....................   Function: 
....................     char * wFSgetcwd (unsigned short int * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in UTF16 format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in UTF16 format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * wFSgetcwd (unsigned short int * path, int numbchars); 
.................... #endif 
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdir (char * path) 
....................   Summary: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSmkdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSmkdir (unsigned short int * path) 
....................   Summary: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSmkdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdir (char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int FSrmdir (char * path, unsigned char rmsubdirs); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs) 
....................   Summary: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs); 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................  
....................  
.................... /*********************************************************************************************************** 
....................   Function: 
....................     int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second) 
....................   Summary: 
....................     Manually set timestamp variables 
....................   Conditions: 
....................     USERDEFINEDCLOCK macro defined in FSconfig.h. 
....................   Input: 
....................     year -     The year (1980\-2107) 
....................     month -   The month (1\-12) 
....................     day -     The day of the month (1\-31) 
....................     hour -    The hour (0\-23) 
....................     minute -  The minute (0\-59) 
....................     second -  The second (0\-59) 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     Modifies global timing variables 
....................   Description: 
....................     Lets the user manually set the timing variables.  The values passed in will be converted to the format 
....................     used by the FAT timestamps. 
....................   Remarks: 
....................     Call this before creating a file or directory (set create time) and 
....................     before closing a file (set last access time, last modified time)                                         
....................   ***********************************************************************************************************/ 
....................  
.................... int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_FILESEARCH 
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................     The FindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*********************************************************************************** 
....................   Function: 
....................     int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous wFindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent wFindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................     The wFindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec); 
.................... #endif 
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FindNext (SearchRec * rec) 
....................   Summary: 
....................     Sequential search function 
....................   Conditions: 
....................     None 
....................   Input: 
....................     rec -  The structure to store the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No additional files matching the specified criteria were found 
....................   Side Effects: 
....................     Search criteria from previous FindNext call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     The FindNext function performs the same function as the FindFirst 
....................     funciton, except it does not copy any search parameters into the 
....................     SearchRec structure (only info about found files) and it begins 
....................     searching at the last directory entry offset at which a file was 
....................     found, rather than at the beginning of the current working 
....................     directory.If the return value of the function is 0 then "utf16LFNfoundLength" 
....................     indicates whether the file found was long file name or short file 
....................     name(8P3 format). The "utf16LFNfoundLength" is non-zero for long file name 
....................     and is zero for 8P3 format."utf16LFNfound" points to the address of long  
....................     file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling this function 
....................   **********************************************************************/ 
....................  
.................... int FindNext (SearchRec * rec);  
.................... #endif 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int FSfprintf (FSFILE * fptr, const char * fmt, ...) 
....................     // PIC18 
....................     int FSfpritnf (FSFILE * fptr, const rom char * fmt, ...) 
....................   Summary: 
....................     Function to write formatted strings to a file 
....................   Conditions: 
....................     For PIC18, integer promotion must be enabled in the project build 
....................     options menu.  File opened in a write mode. 
....................   Input: 
....................     fptr - A pointer to the file to write to. 
....................     fmt -  A string of characters and format specifiers to write to 
....................            the file 
....................     ... -  Additional arguments inserted in the string by format 
....................            specifiers 
....................   Returns: 
....................     The number of characters written to the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Writes a specially formatted string to a file. 
....................   Remarks: 
....................     Consult AN1045 for a full description of how to use format 
....................     specifiers.         
....................   **********************************************************************/ 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................     #ifdef __18CXX 
....................         int FSfprintf (FSFILE *fptr, const rom char *fmt, ...); 
....................     #else 
....................         int FSfprintf (FSFILE *fptr, const char * fmt, ...); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSerror (void) 
....................   Summary: 
....................     Return an error code for the last function call 
....................   Conditions: 
....................     The return value depends on the last function called. 
....................   Input: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Return Values: 
....................     FSInit       -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The physical media could not be initialized 
....................                  - CE_BAD_SECTOR_READ        The MBR or the boot sector could not be 
....................                                               read correctly 
....................                  - CE_BAD_PARITION           The MBR signature code was incorrect. 
....................                  - CE_NOT_FORMATTED          The boot sector signature code was incorrect or 
....................                                               indicates an invalid number of bytes per sector.  
....................                  - CE_CARDFAT32              The physical media is FAT32 type (only an error  
....................                                               when FAT32 support is disabled).  
....................                  - CE_UNSUPPORTED_FS         The device is formatted with an unsupported file  
....................                                               system (not FAT12 or 16). 
....................     FSfopen      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The device has not been initialized.  
....................                  - CE_TOO_MANY_FILES_OPEN    The function could not allocate any  
....................                                               additional file information to the array  
....................                                               of FSFILE structures or the heap.  
....................                  - CE_INVALID_FILENAME       The file name argument was invalid. 
....................                  - CE_INVALID_ARGUMENT       The user attempted to open a directory in a  
....................                                               write mode or specified an invalid mode argument.  
....................                  - CE_FILE_NOT_FOUND         The specified file (which was to be opened in read  
....................                                               mode) does not exist on the device.  
....................                  - CE_BADCACHEREAD           A read from the device failed. 
....................                  - CE_ERASE_FAIL             The existing file could not be erased (when opening  
....................                                               a file in FS_WRITE mode).  
....................                  - CE_DIR_FULL               The directory is full.  
....................                  - CE_DISK_FULL              The data memory section is full.  
....................                  - CE_WRITE_ERROR            A write to the device failed.  
....................                  - CE_SEEK_ERROR             The current position in the file could not be set to  
....................                                               the end (when the file was opened in FS_APPEND mode). 
....................     FSfclose     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer or the new file 
....................                                               entry information could not be written to the device. 
....................                  - CE_BADCACHEREAD           The file entry information could not be cached 
....................     FSfread      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITEONLY              The file was opened in a write-only mode. 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device.  
....................                  - CE_BAD_SECTOR_READ        The data sector could not be read.  
....................                  - CE_EOF                    The end of the file was reached. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be loaded. 
....................     FSfwrite     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_READONLY               The file was opened in a read-only mode.  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected. 
....................                  - CE_WRITE_ERROR            There was an error writing data to the device. 
....................                  - CE_BADCACHEREAD           The data sector to be modified could not be read from 
....................                                               the device.  
....................                  - CE_DISK_FULL              All data clusters on the device are in use. 
....................     FSfseek      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device.  
....................                  - CE_INVALID_ARGUMENT       The specified offset exceeds the size of the file.  
....................                  - CE_BADCACHEREAD           The sector that contains the new current position  
....................                                               could not be loaded. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be  
....................                                               loaded/allocated. 
....................     FSftell      -  
....................                  - CE_GOOD                   No Error 
....................     FSattrib     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The attribute argument was invalid.  
....................                  - CE_BADCACHEREAD           The existing file entry information could not be  
....................                                               loaded.  
....................                  - CE_WRITE_ERROR            The file entry information could not be written to  
....................                                               the device. 
....................     FSrename     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_FILENOTOPENED          A null file pointer was passed into the function.  
....................                  - CE_INVALID_FILENAME       The file name passed into the function was invalid.  
....................                  - CE_BADCACHEREAD           A read from the device failed.  
....................                  - CE_FILENAME_EXISTS        A file with the specified name already exists.  
....................                  - CE_WRITE_ERROR            The new file entry data could not be written to the  
....................                                               device. 
....................     FSfeof       - 
....................                  - CE_GOOD                   No Error 
....................     FSformat     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The device could not be initialized.  
....................                  - CE_BADCACHEREAD           The master boot record or boot sector could not be  
....................                                               loaded successfully.  
....................                  - CE_INVALID_ARGUMENT       The user selected to create their own boot sector on  
....................                                               a device that has no master boot record, or the mode  
....................                                               argument was invalid.  
....................                  - CE_WRITE_ERROR            The updated MBR/Boot sector could not be written to  
....................                                               the device. 
....................                  - CE_BAD_PARTITION          The calculated number of sectors per clusters was  
....................                                               invalid.  
....................                  - CE_NONSUPPORTED_SIZE      The card has too many sectors to be formatted as  
....................                                               FAT12 or FAT16. 
....................     FSremove     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         The specified file could not be found. 
....................                  - CE_ERASE_FAIL             The file could not be erased. 
....................     FSchdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed or the user tried to  
....................                                               change to a non-directory file. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_FOUND          Could not find a directory in the path. 
....................     FSgetcwd     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The user passed a 0-length buffer into the function. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the current working directory. 
....................     FSmkdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed. 
....................                  - CE_BADCACHEREAD           Could not successfully change to a recently created  
....................                                               directory to store its dir entry information, or  
....................                                               could not cache directory entry information.  
....................                  - CE_INVALID_FILENAME       One or more of the directory names has an invalid  
....................                                               format.  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device or the dot/dotdot entries could  
....................                                               not be written to a newly created directory. 
....................                  - CE_DIR_FULL               There are no available dir entries in the CWD. 
....................                  - CE_DISK_FULL              There are no available clusters in the data region of  
....................                                               the device.     
....................     FSrmdir      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_DIR_NOT_FOUND          The directory specified could not be found or the  
....................                                               function could not change to a subdirectory within  
....................                                               the directory to be deleted (when recursive delete is  
....................                                               enabled). 
....................                  - CE_INVALID_ARGUMENT       The user tried to remove the CWD or root directory.  
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_EMPTY          The directory to be deleted was not empty and  
....................                                               recursive subdirectory removal was disabled.  
....................                  - CE_ERASE_FAIL             The directory or one of the directories or files  
....................                                               within it could not be deleted.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the CWD. 
....................     SetClockVars - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The time values passed into the function were  
....................                                               invalid.     
....................     FindFirst    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found.  
....................                  - CE_BADCACHEREAD           The file information for the file that was found  
....................                                               could not be cached. 
....................     FindNext     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The SearchRec object was not initialized by a call to  
....................                                               FindFirst.  
....................                  - CE_INVALID_ARGUMENT       The SearchRec object was initialized in a different  
....................                                               directory from the CWD. 
....................                  - CE_INVALID_FILENAME       The filename is invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found. 
....................     FSfprintf    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            Characters could not be written to the file.                                                    
....................   Description: 
....................     The FSerror function will return the FSerrno variable.  This global 
....................     variable will have been set to an error value during the last call of a 
....................     library function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... int FSerror (void); 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     int FSCreateMBR (unsigned long firstSector, unsigned long numSectors) 
....................   Summary: 
....................     Creates a master boot record 
....................   Conditions: 
....................     The I/O pins for the device have been initialized by the InitIO function. 
....................   Input: 
....................     firstSector -  The first sector of the partition on the device (cannot 
....................                    be 0; that's the MBR) 
....................     numSectors -   The number of sectors available in memory (including the 
....................                    MBR) 
....................   Return Values: 
....................     0 -   MBR was created successfully 
....................     EOF - MBR could not be created 
....................   Side Effects: 
....................     None 
....................   Description:   
....................     This function can be used to create a master boot record for a device.  Note 
....................     that this function should not be used on a device that is already formatted 
....................     with a master boot record (i.e. most SD cards, CF cards, USB keys).  This 
....................     function will fill the global data buffer with appropriate partition information 
....................     for a FAT partition with a type determined by the number of sectors available 
....................     to the partition.  It will then write the MBR information to the first sector 
....................     on the device.  This function should be followed by a call to FSformat, which 
....................     will create a boot sector, root dir, and FAT appropriate the the information 
....................     contained in the new master boot record.  Note that FSformat only supports 
....................     FAT12 and FAT16 formatting at this time, and so cannot be used to format a 
....................     device with more than 0x3FFD5F sectors. 
....................   Remarks: 
....................     This function can damage the device being used, and should not be called 
....................     unless the user is sure about the size of the device and the first sector value. 
....................   *********************************************************************************/ 
....................  
.................... int FSCreateMBR (unsigned long firstSector, unsigned long numSectors); 
....................  
....................  
.................... #ifdef ALLOW_GET_DISK_PROPERTIES 
.................... /********************************************************************************* 
....................   Function: 
....................     void FSGetDiskProperties(FS_DISK_PROPERTIES* properties) 
....................   Summary: 
....................     Allows user to get the disk properties (size of disk, free space, etc) 
....................   Conditions: 
....................     1) ALLOW_GET_DISK_PROPERTIES must be defined in FSconfig.h 
....................     2) a FS_DISK_PROPERTIES object must be created before the function is called 
....................     3) the new_request member of the FS_DISK_PROPERTIES object must be set before 
....................         calling the function for the first time.  This will start a new search. 
....................     4) this function should not be called while there is a file open.  Close all 
....................         files before calling this function. 
....................   Input: 
....................     properties - a pointer to a FS_DISK_PROPERTIES object where the results should 
....................       be stored. 
....................   Return Values: 
....................     This function returns void.  The properties_status of the previous call of  
....................       this function is located in the properties.status field.  This field has  
....................       the following possible values: 
....................  
....................     FS_GET_PROPERTIES_NO_ERRORS - operation completed without error.  Results 
....................       are in the properties object passed into the function. 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED - there is no mounted disk.  Results in 
....................       properties object is not valid 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE - there was a failure trying to read a  
....................       cluster from the drive.  The results in the properties object is a partial 
....................       result up until the point of the failure. 
....................     FS_GET_PROPERTIES_STILL_WORKING - the search for free sectors is still in 
....................       process.  Continue calling this function with the same properties pointer  
....................       until either the function completes or until the partial results meets the 
....................       application needs.  The properties object contains the partial results of 
....................       the search and can be used by the application.   
....................   Side Effects: 
....................     Can cause errors if called when files are open.  Close all files before 
....................     calling this function. 
....................  
....................     Calling this function without setting the new_request member on the first 
....................     call can result in undefined behavior and results. 
....................  
....................     Calling this function after a result is returned other than 
....................     FS_GET_PROPERTIES_STILL_WORKING can result in undefined behavior and results. 
....................   Description:   
....................     This function returns the information about the mounted drive.  The results  
....................     member of the properties object passed into the function is populated with  
....................     the information about the drive.     
....................  
....................     Before starting a new request, the new_request member of the properties 
....................     input parameter should be set to TRUE.  This will initiate a new search 
....................     request. 
....................  
....................     This function will return before the search is complete with partial results. 
....................     All of the results except the free_clusters will be correct after the first 
....................     call.  The free_clusters will contain the number of free clusters found up 
....................     until that point, thus the free_clusters result will continue to grow until 
....................     the entire drive is searched.  If an application only needs to know that a  
....................     certain number of bytes is available and doesn't need to know the total free  
....................     size, then this function can be called until the required free size is 
....................     verified.  To continue a search, pass a pointer to the same FS_DISK_PROPERTIES 
....................     object that was passed in to create the search. 
....................  
....................     A new search request sould be made once this function has returned a value  
....................     other than FS_GET_PROPERTIES_STILL_WORKING.  Continuing a completed search 
....................     can result in undefined behavior or results. 
....................  
....................     Typical Usage: 
....................     <code> 
....................     FS_DISK_PROPERTIES disk_properties; 
....................  
....................     disk_properties.new_request = TRUE; 
....................  
....................     do 
....................     { 
....................         FSGetDiskProperties(&disk_properties); 
....................     } while (disk_properties.properties_status == FS_GET_PROPERTIES_STILL_WORKING); 
....................     </code> 
....................  
....................     results.disk_format - contains the format of the drive.  Valid results are  
....................       FAT12(1), FAT16(2), or FAT32(3). 
....................  
....................     results.sector_size - the sector size of the mounted drive.  Valid values are 
....................       512, 1024, 2048, and 4096. 
....................  
....................     results.sectors_per_cluster - the number sectors per cluster. 
....................  
....................     results.total_clusters - the number of total clusters on the drive.  This  
....................       can be used to calculate the total disk size (total_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................     results.free_clusters - the number of free (unallocated) clusters on the drive. 
....................       This can be used to calculate the total free disk size (free_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................   Remarks: 
....................     PIC24F size estimates: 
....................       Flash - 400 bytes (-Os setting) 
....................  
....................     PIC24F speed estimates: 
....................       Search takes approximately 7 seconds per Gigabyte of drive space.  Speed 
....................         will vary based on the number of sectors per cluster and the sector size. 
....................   *********************************************************************************/ 
.................... void FSGetDiskProperties(FS_DISK_PROPERTIES* properties); 
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE FILEget_next_cluster(FSFILE *fo, DWORD n) 
....................   Summary: 
....................     Step through a chain of clusters 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fo - The file to get the next cluster of 
....................     n -  Number of links in the FAT cluster chain to jump through 
....................   Return Values: 
....................     CE_GOOD - Operation successful 
....................     CE_BAD_SECTOR_READ - A bad read occured of a sector 
....................     CE_INVALID_CLUSTER - Invalid cluster value \> maxcls 
....................     CE_FAT_EOF - Fat attempt to read beyond EOF 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will load 'n' proximate clusters for a file from 
....................     the FAT on the device.  It will stop checking for clusters if the 
....................     ReadFAT function returns an error, if it reaches the last cluster in 
....................     a file, or if the device tries to read beyond the last cluster used 
....................     by the device. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... BYTE FILEget_next_cluster(FSFILE *fo, DWORD n); 
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
....................  //  #use fast_io(ALL) 
....................  
....................  //  #use delay(clock=32M) 
.................... //#use delay( crystal=8mhz, clock=32mhz ) 
....................  
.................... //   #pin_select U1TX = PIN_D5 
.................... //   #pin_select U1RX = PIN_D4 
....................     
....................    //hardwareprofile.h is using spi2 for sd card, so pin select those 
....................   // #pin_select SDI2 = PIN_F5 
....................   // #pin_select SDO2 = PIN_B15 
....................   // #pin_select SCK2OUT = PIN_F4 
....................  
....................    #pin_select SDI1 = PIN_F6 
....................    #pin_select SDO1 = PIN_F2 
....................    #pin_select SCK1OUT = PIN_F3 
....................  
....................  
....................  
.................... //   #pin_select SDI2 = PIN_F6 
.................... //   #pin_select SDO2 = PIN_F2 
.................... //   #pin_select SCK2OUT = PIN_F3 
....................  
....................    #define AN_HOST_VOLTAGE 2 
....................    #define AN_POT          0 
....................  
.................... //   #define MY_ANALOG_PORTS (sAN2 | sAN0) 
....................     
.................... //   #define MY_ADC_SETUP    (ADC_CLOCK_INTERNAL|ADC_TAD_MUL_2) 
....................     
.................... //  #use rs232(UART1, baud=9600, stream=STREAM_USER_UART) 
....................    #define PIN_SDPOWER  PIN_G9 
.................... //   #define PIN_LED1  PIN_B11 
.................... //   #define PIN_LED2  PIN_B10 
.................... //   #define PIN_LED3  PIN_B9 
....................  
.................... //   #define GREEN_LED    PIN_B11 
.................... //   #define YELLOW_LED   PIN_B10 
.................... //   #define RED_LED      PIN_B9 
....................     
.................... //   #define LED_ON(x)    output_high(x) 
.................... //   #define LED_OFF(x)   output_low(x) 
....................     
.................... //   #define BUTTON_PRESSED()   !input(PIN_F0) 
.................... #endif 
....................  
.................... #if defined(__DEBUG_UART) 
....................    // these are microchip's style debugs 
....................    #define InitUART() 
....................    #define PrintROMASCIIStringUART(s)  fprintf(STREAM_USER_UART, s) 
....................    void PrintRAMBytesUART(char *p, unsigned int16 n)  
....................    { 
....................       while(n--) 
....................       { 
....................          fprintf(STREAM_USER_UART, "%X ", *p++); 
....................       } 
....................    } 
....................    #define UARTSendLineFeedCarriageReturn() fprintf(STREAM_USER_UART, "\r\n") 
.................... #endif 
....................  
.................... #if 0 
....................    #warning CCS Debugs Enabled 
....................     
....................   #if defined(__PCH__)  //uart1 
....................    #bit UART_TBE=getenv("BIT:TX1IF") 
....................    //#define WAIT_FOR_TX()   while(!UART_TBE) 
....................    #define WAIT_FOR_TX() 
....................   #else  //uart2 
....................    #word U2STA=getenv("SFR:U2STA") 
....................    #bit U2STA_TRMT=U2STA.8 
....................    #define UART_TBE  U2STA_TRMT 
....................    #define WAIT_FOR_TX()   while(!UART_TBE) 
....................   #endif 
....................        
....................    // application level debugs 
....................    #define DEBUG_STR(str, x) printf("\r\n"); printf("%s", str); printf(" 0x%LX", x); WAIT_FOR_TX() 
....................    #define DEBUG_STR2(str1, str2) printf("\r\n%s '%s'", str1, str2); WAIT_FOR_TX() 
....................     
....................    // library level debugs 
....................    #define DEBUG_FS_STR(str, x) printf("\r\n"); printf("%s", str); printf(" 0x%LX", x); WAIT_FOR_TX() 
....................    #define DEBUG_FS_STR2(str1, str2) printf("\r\n%s '%s'", str1, str2); WAIT_FOR_TX() 
....................     
....................    void DEBUG_FS_ARRAY(unsigned int8 *p, unsigned int16 len) 
....................    { 
....................       unsigned int16 i=0; 
....................       while(i < len) 
....................       { 
....................          if ((i%32) == 0) 
....................             printf("\r\n0x%LX: ", i); 
....................          printf("%02X", *p++); 
....................          i++; 
....................       } 
....................    } 
.................... #endif 
....................  
.................... #if defined(DEBUG_STR) 
.................... #include <pcd_traps.c> 
.................... #endif 
....................  
.................... #ifndef HW_INIT 
.................... #define HW_INIT() 
.................... #endif 
....................  
.................... //#if defined(__PCD__) 
.................... #if 0 
....................    #define DEBUG_SPI()  printf("\r\n0x260=%LX 0x262=%LX 0x264=%LX\r\n", (unsigned int16*)*0x260, (unsigned int16*)*0x262, (unsigned int16*)*0x264); 
.................... #else 
....................    #define DEBUG_SPI() 
.................... #endif 
....................  
.................... // disable application level debug macros if not defined 
.................... #ifndef DEBUG_STR 
....................  #define DEBUG_STR(str, x) 
....................  #define DEBUG_STR2(str1, str2) 
.................... #endif 
....................  
.................... // disable library level debug macros if not defined 
.................... #ifndef DEBUG_FS_STR 
....................  #define DEBUG_FS_STR(str, x) 
....................  #define DEBUG_FS_STR2(str1, str2) 
....................  #define DEBUG_FS_ARRAY(p, len) 
.................... #endif 
....................  
.................... #if defined(__USE_MDD_BOOTLOADER__) 
.................... #include "ex_mdd_boot.h" 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "filesystem\filesystem.c" 
.................... //see about.txt in filesystem/ for information 
....................  
.................... #ifndef __FILESYSTEM_C__ 
.................... #define __FILESYSTEM_C__ 
....................  
.................... #include "FSConfig.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSconfig.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Dependencies:    None 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _FS_DEF_ 
.................... #define _FS_DEF_ 
....................  
.................... //#include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // something to do with long filenames. 
.................... //#define SUPPORT_LFN 
....................  
.................... // Summary: A macro indicating the maximum number of concurrently open files 
.................... // Description: The FS_MAX_FILES_OPEN #define is only applicable when dynamic memory allocation is not used (FS_DYNAMIC_MEM is not defined). 
.................... //              This macro defines the maximum number of open files at any given time.  The amount of RAM used by FSFILE objects will 
.................... //              be equal to the size of an FSFILE object multipled by this macro value.  This value should be kept as small as possible 
.................... //              as dictated by the application.  This will reduce memory usage. 
.................... #define FS_MAX_FILES_OPEN    1 
....................  
....................  
.................... // if defined, MDD will be configured to use SST25 flash device. this definition 
.................... // should also define the size of the SST25 flash device. 
.................... // if not defined, will use SD card. 
.................... // #define  USE_SST25_INTERFACE  ((unsigned int32)2*1024*1024) 
....................  
.................... // Summary: A macro defining the size of a sector 
.................... // Description: The MEDIA_SECTOR_SIZE macro will define the size of a sector on the FAT file system.  This value must equal 512 bytes, 
.................... //              1024 bytes, 2048 bytes, or 4096 bytes.  The value of a sector will usually be 512 bytes. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define MEDIA_SECTOR_SIZE       4096   //erase size of SST25 flash device 
.................... #else 
.................... #define MEDIA_SECTOR_SIZE       512 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* *******************************************************************************************************/ 
.................... /************** Compiler options to enable/Disable Features based on user's application ******************/ 
.................... /* *******************************************************************************************************/ 
....................  
....................  
.................... // Summary: A macro to enable/disable file search functions. 
.................... // Description: The ALLOW_FILESEARCH definition can be commented out to disable file search functions in the library.  This will 
.................... //              prevent the use of the FindFirst and FindNext functions and reduce code size. 
.................... #define ALLOW_FILESEARCH 
....................  
.................... // Summary: A macro to enable/disable write functionality 
.................... // Description: The ALLOW_WRITES definition can be commented out to disable all operations that write to the device.  This will 
.................... //              greatly reduce code size. 
.................... #define ALLOW_WRITES 
....................  
....................  
.................... // Summary: A macro to enable/disable format functionality 
.................... // Description: The ALLOW_FORMATS definition can be commented out to disable formatting functionality.  This will prevent the use of 
.................... //              the FSformat function.  If formats are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define ALLOW_FORMATS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable directory operations. 
.................... // Description: The ALLOW_DIRS definition can be commented out to disable all directory functionality.  This will reduce code size. 
.................... //              If directories are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES in order to use 
.................... //              the FSmkdir or FSrmdir functions. 
.................... #define ALLOW_DIRS 
....................  
.................... // Summary: A macro to enable/disable PIC18 ROM functions. 
.................... // Description: The ALLOW_PGMFUNCTIONS definition can be commented out to disable all PIC18 functions that allow the user to pass string 
.................... //              arguments in ROM (denoted by the suffix -pgm).  Note that this functionality must be disabled when not using PIC18. 
.................... #if !defined(__CCS__) 
.................... #define ALLOW_PGMFUNCTIONS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable the FSfprintf function. 
.................... // Description: The ALLOW_FSFPRINTF definition can be commented out to disable the FSfprintf function.  This will save code space.  Note that 
.................... //              if FSfprintf is enabled and the PIC18 architecture is used, integer promotions must be enabled in the Project->Build Options 
.................... //              menu.  Write operations must be enabled to use FSfprintf. 
.................... //#define ALLOW_FSFPRINTF 
....................  
.................... // CCS added this config option to disable FAT12 to prevent recursion. 
.................... //__CCS__ added by ccs 
.................... //#define SUPPORT_FAT12 
....................  
.................... // Summary: A macro to enable/disable FAT32 support. 
.................... // Description: The SUPPORT_FAT32 definition can be commented out to disable support for FAT32 functionality.  This will save a small amount 
.................... //              of code space. 
.................... #define SUPPORT_FAT32 
....................  
....................  
....................  
.................... /**************************************************************************************************/ 
.................... // Select a method for updating file timestamps 
.................... /**************************************************************************************************/ 
....................  
.................... // Summary: A macro to enable RTCC based timestamp generation 
.................... // Description: The USEREALTIMECLOCK macro will configure the code to automatically 
.................... //              generate timestamp information for files from the RTCC module. The user 
.................... //              must enable and configure the RTCC module before creating or modifying 
.................... //              files.                                                                  
.................... //#define USEREALTIMECLOCK 
....................  
.................... // Summary: A macro to enable manual timestamp generation 
.................... // Description: The USERDEFINEDCLOCK macro will allow the user to manually set 
.................... //              timestamp information using the SetClockVars function. The user will 
.................... //              need to set the time variables immediately before creating or closing a 
.................... //              file or directory.                                                     
.................... #define USERDEFINEDCLOCK 
....................  
.................... // Summary: A macro to enable don't-care timestamp generation 
.................... // Description: The INCREMENTTIMESTAMP macro will set the create time of a file to a 
.................... //              static value and increment it when a file is updated. This timestamp 
.................... //              generation method should only be used in applications where file times 
.................... //              are not necessary.                                                     
.................... //#define INCREMENTTIMESTAMP 
....................  
....................  
.................... #ifdef __18CXX 
....................    #ifdef USEREALTIMECLOCK 
....................       #error Not all PIC18 devices have a Real-time clock and calander module 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    #ifndef __18CXX 
....................       #error The pgm functions are unneccessary when not using PIC18 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef USEREALTIMECLOCK 
....................     #ifndef USERDEFINEDCLOCK 
....................         #ifndef INCREMENTTIMESTAMP 
....................             #error Please enable USEREALTIMECLOCK, USERDEFINEDCLOCK, or INCREMENTTIMESTAMP 
....................         #endif 
....................     #endif 
.................... #endif 
....................  
.................... /************************************************************************/ 
.................... // Set this preprocessor option to '1' to use dynamic FSFILE object allocation.  It will 
.................... // be necessary to allocate a heap when dynamically allocating FSFILE objects. 
.................... // Set this option to '0' to use static FSFILE object allocation. 
.................... /************************************************************************/ 
....................  
.................... //#if 1  //from mirochip 
.................... #if defined(__PCH__) //__CCS__ 
....................     // Summary: A macro indicating that FSFILE objects will be allocated dynamically 
....................     // Description: The FS_DYNAMIC_MEM macro will cause FSFILE objects to be allocated from a dynamic heap.  If it is undefined, 
....................     //              the file objects will be allocated using a static array. 
....................    //#define FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................         // Description: Function pointer to a dynamic memory allocation function 
....................       #define FS_malloc   SRAMalloc 
....................         // Description: Function pointer to a dynamic memory free function 
....................       #define FS_free      SRAMfree 
....................    #else 
....................       #define FS_malloc   malloc 
....................       #define FS_free      free 
....................    #endif 
.................... #elif defined(__CCS__) 
....................    #error/warning Not using FS_DYNAMIC_MEM for PCD compiler 
.................... #endif 
....................  
....................  
.................... #ifdef __18CXX 
....................     /* Define the locations for the dataBuffer and FATbuffer; PLEASE CHECK THE LINKER FILE */ 
....................     #define DATA_BUFFER_ADDRESS      0x700 
....................     #define FAT_BUFFER_ADDRESS       0x900 
.................... #endif 
....................  
....................  
.................... // Function definitions 
.................... // Associate the physical layer functions with the correct physical layer 
.................... #ifdef USE_SD_INTERFACE_WITH_SPI       // SD-SPI.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_SDSPI_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_SDSPI_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_SDSPI_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_SDSPI_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_SDSPI_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_SDSPI_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_SDSPI_WriteProtectState 
....................  
....................     // Description: Function pointer to the Read Capacity Physical Layer function 
....................     #define MDD_ReadCapacity        MDD_SDSPI_ReadCapacity 
....................  
....................     // Description: Function pointer to the Read Sector Size Physical Layer Function 
....................     #define MDD_ReadSectorSize      MDD_SDSPI_ReadSectorSize 
....................  
.................... #elif defined USE_CF_INTERFACE_WITH_PMP       // CF-PMP.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFPMP_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFPMP_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFPMP_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFPMP_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFPMP_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFPMP_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFPMP_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFPMP_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFPMP_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFPMP_CFread 
....................  
.................... #elif defined USE_MANUAL_CF_INTERFACE         // CF-Bit transaction.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFBT_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFBT_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFBT_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFBT_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFBT_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFBT_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFBT_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFBT_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFBT_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFBT_CFread 
....................  
.................... #elif defined USE_USB_INTERFACE               // USB host MSD library 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     USBHostMSDSCSIMediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         USBHostMSDSCSIMediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          USBHostMSDSCSISectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         USBHostMSDSCSISectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO();               
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       USBHostMSDSCSIMediaReset 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   USBHostMSDSCSIWriteProtectState 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #if defined(USE_SST25_INTERFACE) 
.................... #include "sst25vf_mdd.c" 
.................... #endif 
....................  
.................... #if defined(FS_DYNAMIC_MEM) 
....................  #if defined(__PCH__) 
....................   #include "salloc.c" 
....................  #else 
....................   #include <stdlibm.h> 
....................  #endif 
.................... #endif 
....................  
.................... #include "fsio.c" 
.................... /****************************************************************************** 
.................... * 
.................... *               Microchip Memory Disk Drive File System 
.................... * 
.................... ****************************************************************************** 
.................... * FileName:           FSIO.c 
.................... * Dependencies:       GenericTypeDefs.h 
.................... *                     FSIO.h 
.................... *                     Physical interface include file (SD-SPI.h, CF-PMP.h, ...) 
.................... *                     string.h 
.................... *                     stdlib.h 
.................... *                     FSDefs.h 
.................... *                     ctype.h 
.................... *                     salloc.h 
.................... * Processor:          PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
.................... * Compiler:           C18/C30/C32 
.................... * Company:            Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * The software supplied herewith by Microchip Technology Incorporated 
.................... * (the Company) for its PICmicro Microcontroller is intended and 
.................... * supplied to you, the Companys customer, for use solely and 
.................... * exclusively on Microchip PICmicro Microcontroller products. The 
.................... * software is owned by the Company and/or its supplier, and is 
.................... * protected under applicable copyright laws. All rights are reserved. 
.................... * Any use in violation of the foregoing restrictions may subject the 
.................... * user to criminal sanctions under applicable laws, as well as to 
.................... * civil liability for the breach of the terms and conditions of this 
.................... * license. 
.................... * 
.................... * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
.................... * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
.................... * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
.................... * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
.................... * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
.................... * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
.................... * 
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev     Description 
....................   -----   ----------- 
....................   1.2.5   Fixed bug that prevented writes to alternate FAT tables 
....................           Fixed bug that prevented FAT being updated when media is re-inserted 
....................  
....................   1.2.6   Fixed bug that resulted in a bus error when attempts to read a invalid memory region 
....................           Fixed bug that prevented the Windows Explorer to show the Date Creation field for directories 
....................  
....................   x.x.x   Fixed issue on some USB drives where the information written 
....................             to the drive is cached in a RAM for 500ms before it is 
....................             written to the flash unless the sector is accessed again. 
....................           Add some error recovery for FAT32 systems when there is 
....................             corruption in the boot sector. 
....................  
....................   1.3.0   Modified to support Long File Name(LFN) format 
....................   1.3.4   1) Initialized some of the local variables to default values 
....................              to remove non-critical compiler warnings for code sanitation. 
....................           2) The sector size of the media device is obtained from the MBR of media.So, 
....................              instead of using the hard coded macro "DIRENTRIES_PER_SECTOR", the variables 
....................              "dirEntriesPerSector" & "disk->sectorSize" are used in the code. Refer 
....................              "Cache_File_Entry","EraseCluster" & "writeDotEntries" fucntions to see 
....................              the change. 
....................   1.3.6   1) The function "FILEget_next_cluster" is made public. 
....................           2) Modified "FILEfind" function such that when using 8.3 format 
....................              the file searches are not considered as case sensitive. 
....................           3) In function 'CacheTime', the variables 'ptr1' & 'ptr0' are not used 
....................              when compiled for PIC32. So there definitions were removed for PIC32. 
....................           4) Modified "rmdirhelper", "FormatDirName" & "writeDotEntries" functions 
....................              to remove non-critical warnings during compilation. 
....................           5) Updated comments in most of the function header blocks. 
....................   1.4.0   1) While creating files in LFN format with file name length as 13,26,39,52...etc(multiples of 13), 
....................              MDD library was creating incorrect directory entries. To fix this issue, 
....................              functions "FILEfind", "CreateFileEntry", "Alias_LFN_Object", "FormatFileName", 
....................              "FormatDirName", "FSgetcwd", "GetPreviousEntry" & "rmdirhelper" were modified. 
....................              Now "utf16LFNlength" variable part of "FSFILE" structure, indicates LFN length 
....................              excluding the NULL word at the last. 
....................           2) When creating large number of files in LFN format, some files were not getting created in disk. 
....................              To fix this issue,function "FILEfind" was modified. 
....................           3) Modified "FSformat" function to initialize "disk->sectorSize" to default value. 
....................           4) Modified "CreateFileEntry" & "FindEmptyEntries" functions to remove unnecessary 
....................              assignments & optimize the code. 
....................           5) Modified "FSfopen" function to prevent creating an empty file in the directory, when SD card 
....................              is write protected. 
....................           6) Variable "entry" in "writeDotEntries" function is made volatile & properly typecasted 
....................              in it's usage. 
....................           7) Modified "FSFopen" function so that when you try to open a file that doesn't exist on the disk, 
....................              variable "FSerrno" is assigned to CE_FILE_NOT_FOUND. 
....................   1.4.2   1) Minor Modification in "CreateFileEntry" function to fix a bug for file name lengths of 
....................              26,39....characters (multiples of 13) 
....................           2) Fixed the LoadMBR() function to scan all of the MBR entries and return success on the first 
....................              supported drive or fail after the 4 table entries. 
.................... ********************************************************************/ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *					dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *					Microchip C30 v3.01 or higher 
....................  *					Microchip C18 v3.13 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006	Original, copied from old Compiler.h 
....................  * 11/07/2007	Reorganized and simplified 
....................  * 03/31/2010	Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__PCH__) 
....................    #include <p18cxxx.h> 
.................... #elif defined(__PCD__) 
....................    #include <..\OsmobotSDCard\CCSIncludes\PCDxxxx.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... // pcdxxxx.h 
.................... // 
.................... // Microchip C30 to CCS conversion library. 
....................  
.................... #ifndef __PCDXXXX_H__ 
.................... #define __PCDXXXX_H__ 
....................  
.................... #case 
....................  
.................... #include "ccspics.h" 
....................  
.................... //#device PSV=16   this is done sooner in the code 
.................... /* 
.................... #if defined(__CONST_IS_READONLY__) 
....................    #device CONST=READ_ONLY 
.................... #else 
....................    //this is normally how C30 operates 
....................    #device CONST=ROM 
.................... #endif 
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... */ 
....................  
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #zero_ram 
.................... #zero_local_ram 
....................  
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
.................... #undef BYTE 
.................... #endif 
....................  
.................... #if defined(BOOLEAN) 
.................... #undef BOOLEAN 
.................... #endif 
....................  
.................... #define GetSystemClock()       getenv("CLOCK") 
.................... #define GetInstructionClock()  (GetSystemClock()/2) 
.................... #define GetPeripheralClock()   (GetSystemClock()/2) 
....................  
.................... //#define Reset()            reset_cpu()   //not needed, this is defined in Microchip's Compiler.h 
.................... //#define FAR                        //not needed, this is defined in Microchip's Compiler.h 
....................  
.................... #define ClrWdt()         restart_wdt() 
....................  
.................... #define Nop()            delay_cycles(1) 
....................  
.................... //#warning need eds support 
.................... #define __eds__ 
....................  
.................... #define __prog__  rom 
....................  
.................... #define __C30__ 
....................  
.................... #define __CCS_STDLIB_DYNAMIC_MEMORY__ 
....................  
.................... #endif 
....................  
.................... #elif defined(__18CXX) && !defined(HI_TECH_C)	 
.................... 	// PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)	 
.................... 	// PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
.................... 	#if !defined(__18CXX) 
.................... 		#define __18CXX 
.................... 	#endif 
....................     #define COMPILER_HITECH_PICC18 
.................... 	#include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p30fxxxx.h> 
.................... #elif defined(__C30__)		// Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p30sim.h> 
.................... 	// Define some useful inline assembly functions which are normally in the  
.................... 	// processor header files, but absent from the generic p30sim.h file. 
.................... 	#if !defined(Nop) 
.................... 		#define Nop()    __builtin_nop() 
.................... 		#define ClrWdt() {__asm__ volatile ("clrwdt");} 
.................... 		#define Sleep()  {__asm__ volatile ("pwrsav #0");} 
.................... 		#define Idle()   {__asm__ volatile ("pwrsav #1");} 
.................... 	#endif 
.................... #elif defined(__PIC32MX__)	// Microchip C32 compiler 
.................... 	#if !defined(__C32__) 
.................... 		#define __C32__ 
.................... 	#endif 
....................     #define COMPILER_MPLAB_C32 
.................... 	#include <p32xxxx.h> 
.................... 	#include <plib.h> 
.................... #else 
.................... 	#error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
*
040AC:  MOV     W5,[W15++]
.................... { 
....................   unsigned char *s; 
040AE:  CLR     1050
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
040B0:  PUSH    104A
040B2:  POP     1050
040B4:  CP0     104E
040B6:  BRA     Z,40D0
040B8:  MOV     104C,W0
040BA:  CP0.B   [W0]
040BC:  BRA     Z,40D0
....................      *s++ = *s2++; 
040BE:  MOV     1050,W0
040C0:  INC     1050
040C2:  MOV     W0,W5
040C4:  MOV     104C,W0
040C6:  INC     104C
040C8:  MOV.B   [W0],[W5]
040CA:  DEC     104E
040CC:  GOTO    40B4
....................   for (; n > 0; n--) 
040D0:  CP0     104E
040D2:  BRA     Z,40E2
....................      *s++ = '\0'; 
040D4:  MOV     1050,W0
040D6:  INC     1050
040D8:  MOV     W0,W5
040DA:  CLR.B   [W5]
040DC:  DEC     104E
040DE:  GOTO    40D0
....................  
....................   return(s1); 
040E2:  PUSH    104A
040E4:  POP     0
040E6:  MOV     [--W15],W5
040E8:  RETURN  
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
*
05AD2:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *sc1, *sc2; 
05AD4:  CLR     FEC
05AD6:  CLR     FEE
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
05AD8:  PUSH    FE8
05ADA:  POP     FEC
05ADC:  MOV     FEC,W0
05ADE:  CP0.B   [W0]
05AE0:  BRA     Z,5B0C
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
05AE2:  PUSH    FEA
05AE4:  POP     FEE
05AE6:  MOV     FEE,W0
05AE8:  CP0.B   [W0]
05AEA:  BRA     Z,5B06
....................          if (*sc1 == *sc2) 
05AEC:  MOV     FEC,W0
05AEE:  MOV.B   [W0],W5L
05AF0:  MOV     FEE,W0
05AF2:  MOV     W0,W4
05AF4:  MOV.B   [W4],W0L
05AF6:  CP.B    W5L,W0L
05AF8:  BRA     NZ,5B00
....................             return(sc1); 
05AFA:  PUSH    FEC
05AFC:  POP     0
05AFE:  BRA     5B0E
05B00:  INC     0FEE
05B02:  GOTO    5AE6
05B06:  INC     0FEC
05B08:  GOTO    5ADC
....................    return(0); 
05B0C:  CLR     0
05B0E:  MOV     [--W15],W5
05B10:  RETURN  
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
*
05A84:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *sc1, *sc2; 
05A86:  CLR     FEC
05A88:  CLR     FEE
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
05A8A:  PUSH    FE8
05A8C:  POP     FEC
05A8E:  MOV     FEC,W0
05A90:  CP0.B   [W0]
05A92:  BRA     Z,5AC8
....................       for (sc2 = s2; ; sc2++) 
05A94:  PUSH    FEA
05A96:  POP     FEE
....................     if (*sc2 == '\0') 
05A98:  MOV     FEE,W0
05A9A:  CP0.B   [W0]
05A9C:  BRA     NZ,5AAA
....................        return(sc1 - s1); 
05A9E:  MOV     FEC,W4
05AA0:  MOV     FE8,W3
05AA2:  SUB     W4,W3,W0
05AA4:  BRA     5ACE
05AA6:  GOTO    5ABC
....................          else if (*sc1 == *sc2) 
05AAA:  MOV     FEC,W0
05AAC:  MOV.B   [W0],W5L
05AAE:  MOV     FEE,W0
05AB0:  MOV     W0,W4
05AB2:  MOV.B   [W4],W0L
05AB4:  CP.B    W5L,W0L
05AB6:  BRA     NZ,5ABC
....................             break; 
05AB8:  GOTO    5AC2
05ABC:  INC     0FEE
05ABE:  GOTO    5A98
05AC2:  INC     0FEC
05AC4:  GOTO    5A8E
....................    return(sc1 - s1); 
05AC8:  MOV     FEC,W4
05ACA:  MOV     FE8,W3
05ACC:  SUB     W4,W3,W0
05ACE:  MOV     [--W15],W5
05AD0:  RETURN  
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
*
05B12:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *beg, *end; 
05B14:  CLR     FE0
05B16:  CLR     FE2
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
05B18:  CP0     FDC
05B1A:  BRA     Z,5B22
05B1C:  MOV     FDC,W0
05B1E:  GOTO    5B24
05B22:  MOV     85C,W0
05B24:  MOV     W0,FE0
....................    beg += strspn(beg, s2); 
05B26:  PUSH    FE0
05B28:  POP     FE8
05B2A:  PUSH    FDE
05B2C:  POP     FEA
05B2E:  CALL    5A84
05B32:  MOV.B   W0L,W5L
05B34:  ZE      W5,W5
05B36:  CLR.B   B
05B38:  MOV.B   W5L,W0L
05B3A:  ADD     FE0
....................    if (*beg == '\0') 
05B3C:  MOV     FE0,W0
05B3E:  CP0.B   [W0]
05B40:  BRA     NZ,5B4C
....................    { 
....................       *save = beg; 
05B42:  MOV     85C,W5
05B44:  MOV     FE0,W0
05B46:  MOV.B   W0L,[W5+#0]
....................       return(0); 
05B48:  CLR     0
05B4A:  BRA     5B6E
....................    } 
....................    end = strpbrk(beg, s2); 
05B4C:  PUSH    FE0
05B4E:  POP     FE8
05B50:  PUSH    FDE
05B52:  POP     FEA
05B54:  CALL    5AD2
05B58:  MOV     W0,FE2
....................    if (*end != '\0') 
05B5A:  MOV     FE2,W0
05B5C:  CP0.B   [W0]
05B5E:  BRA     Z,5B66
....................    { 
....................       *end = '\0'; 
05B60:  MOV     FE2,W5
05B62:  CLR.B   [W5]
....................       end++; 
05B64:  INC     0FE2
....................    } 
....................    save = end; 
05B66:  PUSH    FE2
05B68:  POP     85C
....................    return(beg); 
05B6A:  PUSH    FE0
05B6C:  POP     0
05B6E:  MOV     [--W15],W5
05B70:  RETURN  
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
*
025A8:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *sc; 
025AA:  CLR     1092
....................  
....................    for (sc = s; *sc != 0; sc++); 
025AC:  PUSH    1090
025AE:  POP     1092
025B0:  MOV     1092,W0
025B2:  CP0.B   [W0]
025B4:  BRA     Z,25BC
025B6:  INC     1092
025B8:  GOTO    25B0
....................    return(sc - s); 
025BC:  MOV     1092,W4
025BE:  MOV     1090,W3
025C0:  SUB     W4,W3,W0
025C2:  MOV     W0,0
025C4:  MOV     [--W15],W5
025C6:  RETURN  
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
*
05BDA:  MOV     W5,[W15++]
05BDC:  MOV     W6,[W15++]
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
05BDE:  MOV     FDC,W0
05BE0:  MOV.B   [W0],W5L
05BE2:  MOV     FDE,W0
05BE4:  MOV     W0,W4
05BE6:  MOV.B   [W4],W0L
05BE8:  CP.B    W5L,W0L
05BEA:  BRA     Z,5C50
05BEC:  MOV     FDC,W0
05BEE:  MOV.B   [W0],W5L
05BF0:  MOV     #41,W4
05BF2:  CP.B    W4L,W5L
05BF4:  BRA     GTU,5BFE
05BF6:  MOV     #5A,W4
05BF8:  CP.B    W4L,W5L
05BFA:  BRA     NC,5BFE
05BFC:  BRA     5C0A
05BFE:  MOV     #61,W4
05C00:  CP.B    W4L,W5L
05C02:  BRA     GTU,5C64
05C04:  MOV     #7A,W4
05C06:  CP.B    W4L,W5L
05C08:  BRA     NC,5C64
05C0A:  MOV     FDE,W0
05C0C:  MOV.B   [W0],W5L
05C0E:  MOV     #41,W4
05C10:  CP.B    W4L,W5L
05C12:  BRA     GTU,5C1C
05C14:  MOV     #5A,W4
05C16:  CP.B    W4L,W5L
05C18:  BRA     NC,5C1C
05C1A:  BRA     5C28
05C1C:  MOV     #61,W4
05C1E:  CP.B    W4L,W5L
05C20:  BRA     GTU,5C64
05C22:  MOV     #7A,W4
05C24:  CP.B    W4L,W5L
05C26:  BRA     NC,5C64
05C28:  MOV     FDC,W0
05C2A:  MOV.B   [W0],W5L
05C2C:  MOV     FDE,W0
05C2E:  MOV.B   [W0],W4L
05C30:  CLR.B   9
05C32:  MOV     #20,W3
05C34:  ADD     W4,W3,W0
05C36:  CLR.B   B
05C38:  CP      W5,W0
05C3A:  BRA     Z,5C50
05C3C:  MOV     FDE,W0
05C3E:  MOV.B   [W0],W5L
05C40:  MOV     FDC,W0
05C42:  MOV.B   [W0],W4L
05C44:  CLR.B   9
05C46:  MOV     #20,W3
05C48:  ADD     W4,W3,W0
05C4A:  CLR.B   B
05C4C:  CP      W5,W0
05C4E:  BRA     NZ,5C64
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
05C50:  MOV     FDC,W0
05C52:  CP0.B   [W0]
05C54:  BRA     NZ,5C5A
....................        return(0); 
05C56:  CLR.B   0
05C58:  BRA     5C7A
05C5A:  MOV     FDC,W0
05C5C:  INC     0FDC
05C5E:  INC     0FDE
05C60:  GOTO    5BDE
....................  return((*s1 < *s2) ? -1: 1); 
05C64:  MOV     FDC,W0
05C66:  MOV.B   [W0],W5L
05C68:  MOV     FDE,W0
05C6A:  MOV     W0,W4
05C6C:  MOV.B   [W4],W0L
05C6E:  CP.B    W5L,W0L
05C70:  BRA     C,5C78
05C72:  SETM.B  W0
05C74:  GOTO    5C7A
05C78:  MOV.B   #1,W0L
05C7A:  MOV     [--W15],W6
05C7C:  MOV     [--W15],W5
05C7E:  RETURN  
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = beg; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = beg; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PIC32MX__) 
.................... 	#define PTR_BASE		unsigned long 
.................... 	#define ROM_PTR_BASE	unsigned long 
.................... #elif defined(__C30__) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
.................... 	#define memcmppgm2ram(a,b,c)	memcmp(a,b,c) 
.................... 	#define strcmppgm2ram(a,b)		strcmp(a,b) 
.................... 	#define memcpypgm2ram(a,b,c)	memcpy(a,b,c) 
.................... 	#define strcpypgm2ram(a,b)		strcpy(a,b) 
.................... 	#define strncpypgm2ram(a,b,c)	strncpy(a,b,c) 
.................... 	#define strstrrampgm(a,b)		strstr(a,b) 
.................... 	#define	strlenpgm(a)			strlen(a) 
.................... 	#define strchrpgm(a,b)			strchr(a,b) 
.................... 	#define strcatpgm2ram(a,b)		strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
.................... 	#define	__attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
.................... 	// Microchip C18 specific defines 
.................... 	#if defined(COMPILER_MPLAB_C18) 
.................... 	    #define ROM                 	rom 
.................... 	#endif 
.................... 	 
.................... 	// HI TECH PICC-18 specific defines 
.................... 	#if defined(COMPILER_HITECH_PICC18) 
.................... 	    #define ROM                 	const 
.................... 		#define rom 
.................... 	    #define Nop()               	asm("NOP"); 
.................... 		#define ClrWdt()				asm("CLRWDT"); 
.................... 	    #define Reset()					asm("RESET"); 
.................... 	#endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
.................... 	#define	ROM						const 
....................  
.................... 	// 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
.................... 	#if defined(__C30__) 
.................... 		#define Reset()				asm("reset") 
....................         #define FAR                 __attribute__((far)) 
.................... 	#endif 
....................  
.................... 	// 32-bit specific defines (PIC32) 
.................... 	#if defined(__PIC32MX__) 
.................... 		#define persistent 
.................... 		#define far 
....................         #define FAR 
.................... 		#define Reset()				SoftReset() 
.................... 		#define ClrWdt()			(WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
.................... 		// MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
.................... 		// Nop() function. However, version 1.05 has Nop() declared as _nop(). 
.................... 		#if !defined(Nop) && (__C32_VERSION__ <= 104) 
.................... 			#define Nop()				asm("nop") 
.................... 		#endif 
.................... 	#endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "MDD File System/FSIO.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSIO.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  *                  FSconfig.h 
....................  *                  FSDefs.h 
....................  *                  stddef.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.4.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  FS_DOT_H 
.................... #define  FS_DOT_H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... #include "../FSconfig.h" 
.................... #include "FSDefs.h"  
.................... #include "stddef.h" 
....................  
.................... #ifdef USE_SD_INTERFACE_WITH_SPI 
....................     #include    "SD-SPI.h" 
.................... #endif 
.................... #ifdef USE_CF_INTERFACE_WITH_PMP 
....................     #include    "CF-PMP.h" 
.................... #endif 
.................... #ifdef USE_MANUAL_CF_INTERFACE 
....................     #include    "CF- Bit transaction.h" 
.................... #endif 
.................... #ifdef USE_USB_INTERFACE 
....................     #include    "usb_host_msd_scsi.h" 
.................... #endif 
.................... #ifdef USE_INTERNAL_FLASH 
....................     #include    "Internal Flash.h" 
.................... #endif 
....................  
....................  
.................... /*******************************************************************/ 
.................... /*                     Strunctures and defines                     */ 
.................... /*******************************************************************/ 
....................  
.................... #ifndef FALSE 
....................     // Summary: False value 
....................     // Description:  This macro will indicate that a condition is false. 
....................     #define FALSE   0 
.................... #endif 
.................... #ifndef TRUE 
....................     // Summary: True value 
....................     // Description: This macro will indicate that a condition is true. 
....................     #define TRUE    !FALSE  // True value 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #ifndef SEEK_SET 
....................     // Summary: Macro for the FSfseek SEEK_SET base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed  
....................     //              relative to the beginning of the file. 
....................     #define SEEK_SET 0 
....................  
.................... #endif 
.................... #ifndef SEEK_CUR 
....................  
....................     // Summary: Macro for the FSfseek SEEK_CUR base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the current location of the file 
....................     #define SEEK_CUR 1 
....................  
.................... #endif 
.................... #ifndef SEEK_END 
....................  
....................     // Summary: Macro for the FSfseek SEEK_END base location 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the end of the file.  For this macro, the offset value will be subtracted from 
....................     //              the end location of the file by default. 
....................     #define SEEK_END 2 
....................  
.................... #endif 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file. 
.................... #define FS_APPEND   "a" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file. 
.................... #define FS_WRITE    "w" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file. 
.................... #define FS_READ "r" 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file 
.................... //              or read from the file. 
.................... #define FS_APPENDPLUS   "a+" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file or read from the file. 
.................... #define FS_WRITEPLUS    "w+" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file or write to the file. 
.................... #define FS_READPLUS     "r+" 
....................  
.................... #ifndef intmax_t 
....................     #ifdef __PIC24F__ 
....................         // Summary: A data type indicating the maximum integer size in an architecture 
....................         // Description: The intmax_t data type refers to the maximum-sized data type on any given architecture.  This 
....................         //              data type can be specified as a format specifier size specification for the FSfprintf function. 
....................         #define intmax_t long long 
....................     #elif defined __PIC24H__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC30F__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC33F__ 
....................         #define intmax_t long long 
....................     #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary:  Indicates flag conditions for a file object 
.................... // Description: The FILEFLAGS structure is used to indicate conditions in a file.  It contains three flags: 'write' indicates 
.................... //              that the file was opened in a mode that allows writes, 'read' indicates that the file was opened in a mode 
.................... //              that allows reads, and 'FileWriteEOF' indicates that additional data that is written to the file will increase 
.................... //              the file size. 
.................... typedef struct 
.................... { 
....................     unsigned    write :1;           // Indicates a file was opened in a mode that allows writes 
....................     unsigned    read :1;            // Indicates a file was opened in a mode that allows reads 
....................     unsigned    FileWriteEOF :1;    // Indicates the current position in a file is at the end of the file 
.................... }FILEFLAGS; 
....................  
....................  
....................  
.................... // Summary: Indicates how to search for file entries in the FILEfind function 
.................... // Description: The values in the SEARCH_TYPE enumeration are used internally by the library to indicate how the FILEfind function 
.................... //              how to perform a search.  The 'LOOK_FOR_EMPTY_ENTRY' value indicates that FILEfind should search for an empty file entry. 
.................... //              The 'LOOK_FOR_MATCHING_ENTRY' value indicates that FILEfind should search for an entry that matches the FSFILE object 
.................... //              that was passed into the FILEfind function. 
.................... typedef enum{ 
....................     LOOK_FOR_EMPTY_ENTRY = 0, 
....................     LOOK_FOR_MATCHING_ENTRY 
.................... } SEARCH_TYPE; 
....................  
....................  
....................  
.................... // Summary: Macro indicating the length of a 8.3 file name 
.................... // Description: The TOTAL_FILE_SIZE_8P3 macro indicates the maximum number of characters in an 8.3 file name.  This value includes 
.................... //              8 characters for the name, three for the extentsion, and 1 for the radix ('.') 
.................... #define TOTAL_FILE_SIZE_8P3             (8+3+1) 
.................... #define TOTAL_FILE_SIZE                 TOTAL_FILE_SIZE_8P3 
....................  
.................... // Summary: Macro indicating the max length of a LFN file name 
.................... // Description: The MAX_FILE_NAME_LENGTH_LFN macro indicates the maximum number of characters in an LFN file name. 
.................... #define MAX_FILE_NAME_LENGTH_LFN             256 
....................  
.................... // Summary: A mask that indicates the limit of directory entries in a sector 
.................... // Description: The MASK_MAX_FILE_ENTRY_LIMIT_BITS is used to indicate to the Cache_File_Entry function that a new sector needs to 
.................... //              be loaded. 
.................... #define MASK_MAX_FILE_ENTRY_LIMIT_BITS          0x0f 
....................  
.................... // Summary: Value used for shift operations to calculate the sector offset in a directory 
.................... // Description: The VALUE_BASED_ON_ENTRIES_PER_CLUSTER macro is used to calculate sector offsets for directories.  The position of the 
.................... //              entry is shifted by 4 bits (divided by 16, since there are 16 entries in a sector) to calculate how many sectors a 
.................... //              specified entry is offset from the beginning of the directory. 
.................... #define VALUE_BASED_ON_ENTRIES_PER_CLUSTER      4 
....................  
.................... // Summary: A value that will indicate that a dotdot directory entry points to the root. 
.................... // Description: The VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT macro is used as an absolute address when writing information to a dotdot entry 
.................... //              in a newly created directory.  If a dotdot entry points to the root directory, it's cluster value must be set to 0, 
.................... //              regardless of the actual cluster number of the root directory. 
.................... #define VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT     0 
....................  
.................... // Summary: MAcro indicating the length of an 8.3 file name in a directory entry 
.................... // Description: The FILE_NAME_SIZE_8P3 macro indicates the number of characters that an 8.3 file name will take up when packed in 
.................... //              a directory entry.  This value includes 8 characters for the name and 3 for the extension.  Note that the radix is not 
.................... //              stored in the directory entry. 
.................... #define FILE_NAME_SIZE_8P3           11 
.................... #define FILE_NAME_SIZE               FILE_NAME_SIZE_8P3 
....................  
....................  
.................... // Summary: Contains file information and is used to indicate which file to access. 
.................... // Description: The FSFILE structure is used to hold file information for an open file as it's being modified or accessed.  A pointer to  
.................... //              an open file's FSFILE structure will be passeed to any library function that will modify that file. 
.................... typedef struct 
.................... { 
....................     DISK    *       dsk;            // Pointer to a DISK structure 
....................     DWORD           cluster;        // The first cluster of the file 
....................     DWORD           ccls;           // The current cluster of the file 
....................     WORD            sec;            // The current sector in the current cluster of the file 
....................     WORD            pos;            // The position in the current sector 
....................     DWORD           seek;           // The absolute position in the file 
....................     DWORD           size;           // The size of the file 
....................     FILEFLAGS       flags;          // A structure containing file flags 
....................     WORD            time;           // The file's last update time 
....................     WORD            date;           // The file's last update date 
....................     char            name[FILE_NAME_SIZE_8P3];       // The short name of the file 
....................    #ifdef SUPPORT_LFN 
....................        BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNptr;           // Pointer to long file name in UTF16 format 
....................       unsigned short int utf16LFNlength;          // LFN length in terms of words excluding the NULL word at the last. 
....................    #endif 
....................     WORD            entry;          // The position of the file's directory entry in it's directory 
....................     WORD            chk;            // File structure checksum 
....................     WORD            attributes;     // The file attributes 
....................     DWORD           dirclus;        // The base cluster of the file's directory 
....................     DWORD           dirccls;        // The current cluster of the file's directory 
.................... } FSFILE; 
....................  
.................... /* Summary: Possible results of the FSGetDiskProperties() function. 
.................... ** Description: See the FSGetDiskProperties() function for more information. 
.................... */ 
.................... typedef enum 
.................... { 
....................     FS_GET_PROPERTIES_NO_ERRORS = 0, 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED, 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE, 
....................     FS_GET_PROPERTIES_STILL_WORKING = 0xFF 
.................... } FS_DISK_ERRORS; 
....................  
....................  
.................... /* Summary: Contains the disk search information, intermediate values, and results 
.................... ** Description: This structure is used in conjunction with the FSGetDiskProperties() 
.................... **              function.  See that function for more information about the usage. 
.................... */ 
.................... typedef struct 
.................... { 
....................     DISK *  disk;           /* pointer to the disk we are searching */ 
....................     BOOL    new_request;    /* is this a new request or a continued request */ 
....................     FS_DISK_ERRORS properties_status;  /* status of the last call of the function */ 
....................  
....................     struct 
....................     { 
....................         BYTE disk_format;           /* disk format: FAT12, FAT16, FAT32 */ 
....................         WORD sector_size;           /* sector size of the drive */ 
....................         BYTE sectors_per_cluster;   /* number of sectors per cluster */ 
....................         DWORD total_clusters;       /* the number of total clusters on the drive */ 
....................         DWORD free_clusters;        /* the number of free (unused) clusters on drive */ 
....................     } results;                      /* the results of the current search */ 
....................  
....................     struct 
....................     { 
....................         DWORD   c;      
....................         DWORD   curcls; 
....................         DWORD   EndClusterLimit; 
....................         DWORD   ClusterFailValue; 
....................     } private;      /* intermediate values used to continue searches.  This 
....................                          member should be used only by the FSGetDiskProperties() 
....................                          function */ 
....................  
.................... } FS_DISK_PROPERTIES; 
....................  
.................... // Summary: A structure used for searching for files on a device. 
.................... // Description: The SearchRec structure is used when searching for file on a device.  It contains parameters that will be loaded with 
.................... //              file information when a file is found.  It also contains the parameters that the user searched for, allowing further 
.................... //              searches to be perfomed in the same directory for additional files that meet the specified criteria. 
.................... typedef struct 
.................... { 
....................     char            filename[FILE_NAME_SIZE_8P3 + 2];   // The name of the file that has been found 
....................     unsigned char   attributes;                     // The attributes of the file that has been found 
....................     unsigned long   filesize;                       // The size of the file that has been found 
....................     unsigned long   timestamp;                      // The last modified time of the file that has been found (create time for directories) 
....................    #ifdef SUPPORT_LFN 
....................       BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNfound;          // Pointer to long file name found in UTF16 format 
....................       unsigned short int utf16LFNfoundLength;     // LFN Found length in terms of words including the NULL word at the last. 
....................    #endif 
....................     unsigned int    entry;                          // The directory entry of the last file found that matches the specified attributes. (Internal use only) 
....................     char            searchname[FILE_NAME_SIZE_8P3 + 2]; // The 8.3 format name specified when the user began the search. (Internal use only) 
....................     unsigned char   searchattr;                     // The attributes specified when the user began the search. (Internal use only) 
....................     unsigned long   cwdclus;                        // The directory that this search was performed in. (Internal use only) 
....................     unsigned char   initialized;                    // Check to determine if the structure was initialized by FindFirst (Internal use only) 
.................... } SearchRec; 
....................  
....................  
.................... /*************************************************************************** 
.................... * Prototypes                                                               * 
.................... ***************************************************************************/ 
....................  
....................  
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     int FSInit(void) 
....................   Summary: 
....................     Function to initialize the device. 
....................   Conditions: 
....................     The physical device should be connected to the microcontroller. 
....................   Input: 
....................     None 
....................   Return Values: 
....................     TRUE -  Initialization successful 
....................     FALSE - Initialization unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function initializes the file system stack & the interfacing device. 
....................     Initializes the static or dynamic memory slots for holding file 
....................     structures. Initializes the device with the DISKmount function. Loads  
....................     MBR and boot sector information. Initializes the current working 
....................     directory to the root directory for the device if directory support 
....................     is enabled. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... int FSInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * FSfopen (const char * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with ascii input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will open a ascii name file or directory on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * FSfopen(const char * fileName, const char *mode); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * wFSfopen (const unsigned short int * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * wFSfopen(const unsigned short int * fileName, const char *mode); 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................  
.................... /****************************************************************************** 
....................   Function: 
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode) 
....................   Summary: 
....................     Opens a file on PIC18 Microcontrollers where 'fileName' ROM string is given 
....................     in Ascii format. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to be opened (ROM) 
....................     mode -      The mode the file will be opened in (ROM) 
....................   Return Values: 
....................     FSFILE * - A pointer to the file object 
....................     NULL -     File could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file on PIC18 Microcontrollers where 'fileName' ROM string 
....................     is given in Ascii format.The FSfopenpgm function will copy a PIC18 ROM fileName and 
....................     mode argument into RAM arrays, and then pass those arrays to the FSfopen function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   ******************************************************************************/ 
....................  
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode); 
....................  
....................  
.................... /************************************************************************************** 
....................   Function: 
....................     int FindFirstpgm (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Find a file named with a ROM string on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName -  The name of the file to be found (ROM) 
....................     attr -      The attributes of the file to be found 
....................     rec -       Pointer to a search record to store the file info in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the given parameters was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirstpgm call on passed SearchRec object 
....................     will be lost.The FSerrno variable will be changed. 
....................   Description: 
....................     This function finds a file named with 'fileName' on PIC18. The FindFirstpgm 
....................     function will copy a PIC18 ROM fileName argument into a RAM array, and then 
....................     pass that array to the FindFirst function. 
....................   Remarks: 
....................     Call FindFirstpgm or FindFirst before calling FindNext. 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************************/ 
....................  
....................     int FindFirstpgm (const rom char * fileName, unsigned int attr, SearchRec * rec); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdirpgm (const rom char * path) 
....................   Summary: 
....................     Changes the CWD to the input path on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to (ROM) 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the CWD to the input path on PIC18.The FSchdirpgm function 
....................     passes a PIC18 ROM path pointer to the chdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM 
....................   **************************************************************************/ 
....................  
....................     int FSchdirpgm (const rom char * path); 
....................  
....................     #ifdef ALLOW_WRITES 
....................  
....................  
.................... /************************************************************* 
....................   Function: 
....................     int FSremovepgm (const rom char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC18 device 
....................   Conditions: 
....................     File not opened; file exists 
....................   Input: 
....................     fileName -  The name of the file to be deleted (ROM) 
....................   Return Values: 
....................     0 -  File was removed successfully 
....................     -1 - File could not be removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC18 device.The FSremovepgm function will copy a 
....................     PIC18 ROM fileName argument into a RAM array, and then pass that array 
....................     to the FSremove function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   *************************************************************/ 
....................  
....................         int FSremovepgm (const rom char * fileName); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdirpgm (const rom char * path) 
....................   Summary: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create (ROM) 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices.'FSmkdirpgm' creates the directories as per the input 
....................     string path.This function doesn't move the current working 
....................     directory setting. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arugments in ROM 
....................   **************************************************************************/ 
....................  
....................         int FSmkdirpgm (const rom char * path); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdirpgm (const rom char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     path -      The path of the directory to remove (ROM) 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................     This function deletes the directory as specified in the path. 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************/ 
....................  
....................         int FSrmdirpgm (const rom char * path, unsigned char rmsubdirs); 
....................  
....................  
.................... /***************************************************************** 
....................   Function: 
....................     int FSrenamepgm(const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the file with the ascii ROM string(PIC18) 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file (in ROM) 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -  File renamed successfully 
....................     -1 - File could not be renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the file with the ascii ROM string(PIC18).The Fsrenamepgm 
....................     function will copy the rom fileName specified by the user into a  
....................     RAM array and pass that array into the FSrename function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM.                        
....................   *****************************************************************/ 
....................  
....................         int FSrenamepgm (const rom char * fileName, FSFILE * fo); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************ 
....................   Function: 
....................     int FSfclose(FSFILE *fo) 
....................   Summary: 
....................     Update file information and free FSFILE objects 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to the file to close 
....................   Return Values: 
....................     0 -   File closed successfully  
....................     EOF - Error closing the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will update the directory entry for the  
....................     file pointed to by 'fo' with the information contained 
....................     in 'fo,' including the new file size and attributes. 
....................     Timestamp information will also be loaded based on the 
....................     method selected by the user and written to the entry 
....................     as the last modified time and date.  The file entry will 
....................     then be written to the device.  Finally, the memory 
....................     used for the specified file object will be freed from 
....................     the dynamic heap or the array of FSFILE objects. 
....................   Remarks: 
....................     A function to flush data to the device without closing the 
....................     file can be created by removing the portion of this 
....................     function that frees the memory and the line that clears 
....................     the write flag. 
....................   ************************************************************/ 
....................  
.................... int FSfclose(FSFILE *fo); 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     void FSrewind (FSFILE * fo) 
....................   Summary: 
....................     Set the current position in a file to the beginning 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The FSrewind funciton will reset the position of the 
....................     specified file to the beginning of the file.  This 
....................     functionality is faster than using FSfseek to reset 
....................     the position in the file. 
....................   Remarks: 
....................     None. 
....................   *********************************************************/ 
....................  
.................... void FSrewind (FSFILE *fo); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Read data from a file 
....................   Conditions: 
....................     File is opened in a read mode 
....................   Input: 
....................     ptr -     Destination buffer for read bytes 
....................     size -    Size of units in bytes 
....................     n -       Number of units to be read 
....................     stream -  File to be read from 
....................   Return: 
....................     size_t - number of units read 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfread function will read data from the specified file.  First, 
....................     the appropriate sector of the file is loaded.  Then, data is read into 
....................     the specified buffer until the specified number of bytes have been read. 
....................     When a cluster boundary is reached, a new cluster will be loaded.  The 
....................     parameters 'size' and 'n' indicate how much data to read.  'Size' 
....................     refers to the size of one object to read (in bytes), and 'n' will refer  
....................     to the number of these objects to read.  The value returned will be equal  
....................     to 'n' unless an error occured or the user tried to read beyond the end 
....................     of the file. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream); 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FSfseek(FSFILE *stream, long offset, int whence) 
....................   Summary: 
....................     Change the current position in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     stream -    Pointer to file structure 
....................     offset -    Offset from base location 
....................     whence -     
....................            - SEEK_SET -  Seek from start of file 
....................            - SEEK_CUR -  Seek from current location 
....................            - SEEK_END -  Seek from end of file (subtract offset) 
....................   Return Values: 
....................     0 -  Operation successful  
....................     -1 - Operation unsuccesful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfseek function will change the current position in the file to 
....................     one specified by the user.  First, an absolute offset is calculated 
....................     using the offset and base location passed in by the user.  Then, the 
....................     position variables are updated, and the sector number that corresponds 
....................     to the new location.  That sector is then loaded.  If the offset 
....................     falls exactly on a cluster boundary, a new cluster will be allocated 
....................     to the file and the position will be set to the first byte of that 
....................     cluster. 
....................   Remarks: 
....................     None                                                                
....................   **********************************************************************/ 
....................  
.................... int FSfseek(FSFILE *stream, long offset, int whence); 
....................  
....................  
.................... /******************************************************************* 
....................   Function: 
....................     long FSftell (FSFILE * fo) 
....................   Summary: 
....................     Determine the current location in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return: Current location in the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     The FSftell function will return the current position in the 
....................     file pointed to by 'fo' by returning the 'seek' variable in the 
....................     FSFILE object, which is used to keep track of the absolute 
....................     location of the current position in the file. 
....................   Remarks: 
....................     None                                                             
....................   *******************************************************************/ 
....................  
.................... long FSftell(FSFILE *fo); 
....................  
....................  
.................... /**************************************************** 
....................   Function: 
....................     int FSfeof( FSFILE * stream ) 
....................   Summary: 
....................     Indicate whether the current file position is at the end 
....................   Conditions: 
....................     File is open in a read mode 
....................   Input: 
....................     stream -  Pointer to the target file 
....................   Return Values: 
....................     Non-Zero - EOF reached  
....................     0 - Not at end of File 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfeof function will indicate that the end-of- 
....................     file has been reached for the specified file by 
....................     comparing the absolute location in the file to the 
....................     size of the file. 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... int FSfeof( FSFILE * stream ); 
....................  
....................  
.................... #ifdef ALLOW_FORMATS 
.................... /******************************************************************* 
....................   Function: 
....................     int FSformat (char mode, long int serialNumber, char * volumeID) 
....................   Summary: 
....................     Formats a device 
....................   Conditions: 
....................     The device must possess a valid master boot record. 
....................   Input: 
....................     mode -          - 0 - Just erase the FAT and root 
....................                     - 1 - Create a new boot sector 
....................     serialNumber -  Serial number to write to the card 
....................     volumeID -      Name of the card 
....................   Return Values: 
....................     0 -    Format was successful 
....................     EOF -  Format was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSformat function can be used to create a new boot sector 
....................     on a device, based on the information in the master boot record. 
....................     This function will first initialize the I/O pins and the device, 
....................     and then attempts to read the master boot record.  If the MBR 
....................     cannot be loaded successfully, the function will fail.  Next, if 
....................     the 'mode' argument is specified as '0' the existing boot sector 
....................     information will be loaded.  If the 'mode' argument is '1' an 
....................     entirely new boot sector will be constructed using the disk 
....................     values from the master boot record.  Once the boot sector has 
....................     been successfully loaded/created, the locations of the FAT and 
....................     root will be loaded from it, and they will be completely 
....................     erased.  If the user has specified a volumeID parameter, a  
....................     VOLUME attribute entry will be created in the root directory 
....................     to name the device. 
....................  
....................     FAT12, FAT16 and FAT32 formatting are supported. 
....................  
....................     Based on the number of sectors, the format function automatically 
....................     compute the smallest possible value for the cluster size in order to 
....................     accommodate the physical size of the media. In this case, if a media  
....................     with a big capacity is formatted, the format function may take a very 
....................     long time to write all the FAT tables.  
....................  
....................     Therefore, the FORMAT_SECTORS_PER_CLUSTER macro may be used to  
....................     specify the exact cluster size (in multiples of sector size). This  
....................     macro can be defined in FSconfig.h 
....................  
....................   Remarks: 
....................     Only devices with a sector size of 512 bytes are supported by the  
....................     format function                       
....................   *******************************************************************/ 
....................  
.................... int FSformat (char mode, long int serialNumber, char * volumeID); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_WRITES 
.................... /*************************************************************************** 
....................   Function: 
....................     int FSattrib (FSFILE * file, unsigned char attributes) 
....................   Summary: 
....................     Change the attributes of a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     file -        Pointer to file structure 
....................     attributes -  The attributes to set for the file 
....................                -  Attribute -      Value - Indications  
....................                -  ATTR_READ_ONLY - 0x01  - The read-only attribute 
....................                -  ATTR_HIDDEN -    0x02  - The hidden attribute  
....................                -  ATTR_SYSTEM -    0x04  - The system attribute  
....................                -  ATTR_ARCHIVE -   0x20  - The archive attribute 
....................   Return Values: 
....................     0 -  Attribute change was successful  
....................     -1 - Attribute change was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSattrib funciton will set the attributes of the specified file 
....................     to the attributes passed in by the user.  This function will load the 
....................     file entry, replace the attributes with the ones specified, and write 
....................     the attributes back.  If the specified file is a directory, the 
....................     directory attribute will be preserved. 
....................   Remarks: 
....................     None                                                                 
....................   ***************************************************************************/ 
....................  
.................... int FSattrib (FSFILE * file, unsigned char attributes); 
....................  
....................  
.................... /*************************************************************** 
....................   Function: 
....................     int FSrename (const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices. 
....................     First, it will search through the current working directory to ensure the 
....................     specified new filename is not already in use. If it isn't, the new filename 
....................     will be written to the file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None                                                         
....................   ***************************************************************/ 
....................  
.................... int FSrename (const char * fileName, FSFILE * fo); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*************************************************************** 
....................   Function: 
....................     int wFSrename (const rom unsigned short int * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices. First, it will search through the current 
....................     working directory to ensure the specified new UTF16 filename is not 
....................     already in use.  If it isn't, the new filename will be written to the 
....................     file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None 
....................   ***************************************************************/ 
....................  
.................... int wFSrename (const unsigned short int * fileName, FSFILE * fo); 
.................... #endif 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     int FSremove (const char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed  
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................     The FSremove function will attempt to find the specified file with the FILEfind 
....................     function.  If the file is found, it will be erased using the FILEerase function. 
....................     The user can also provide ascii alias name of the ascii long file name as the 
....................     input to this function to get it erased from the memory. 
....................   Remarks: 
....................     None                                        
....................   **********************************************************************/ 
....................  
.................... int FSremove (const char * fileName); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     int wFSremove (const unsigned short int * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed 
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................     The wFSremove function will attempt to find the specified UTF16 file 
....................     name with the FILEfind function. If the file is found, it will be erased 
....................     using the FILEerase function. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int wFSremove (const unsigned short int * fileName); 
.................... #endif 
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Write data to a file 
....................   Conditions: 
....................     File opened in FS_WRITE, FS_APPEND, FS_WRITE+, FS_APPEND+, FS_READ+ mode 
....................   Input: 
....................     data_to_write -     Pointer to source buffer 
....................     size -              Size of units in bytes 
....................     n -                 Number of units to transfer 
....................     stream -            Pointer to file structure 
....................   Return: 
....................     size_t - number of units written 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfwrite function will write data to a file.  First, the sector that 
....................     corresponds to the current position in the file will be loaded (if it hasn't 
....................     already been cached in the global data buffer).  Data will then be written to 
....................     the device from the specified buffer until the specified amount has been written. 
....................     If the end of a cluster is reached, the next cluster will be loaded, unless 
....................     the end-of-file flag for the specified file has been set.  If it has, a new 
....................     cluster will be allocated to the file.  Finally, the new position and filesize 
....................     will be stored in the FSFILE object.  The parameters 'size' and 'n' indicate how  
....................     much data to write.  'Size' refers to the size of one object to write (in bytes),  
....................     and 'n' will refer to the number of these objects to write.  The value returned  
....................     will be equal  to 'n' unless an error occured. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************************/ 
....................  
.................... size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream); 
....................  
.................... #endif 
....................  
.................... #ifdef ALLOW_DIRS 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdir (char * path) 
....................   Summary: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC). 
....................     The FSchdir function passes a RAM pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSchdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSchdir (unsigned short int * path) 
....................   Summary: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC).The FSchdir function passes a RAM 
....................     pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSchdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************** 
....................   Function: 
....................     char * FSgetcwd (char * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in Ascii format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in Ascii format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * FSgetcwd (char * path, int numbchars); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************** 
....................   Function: 
....................     char * wFSgetcwd (unsigned short int * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in UTF16 format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in UTF16 format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * wFSgetcwd (unsigned short int * path, int numbchars); 
.................... #endif 
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdir (char * path) 
....................   Summary: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSmkdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSmkdir (unsigned short int * path) 
....................   Summary: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSmkdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdir (char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int FSrmdir (char * path, unsigned char rmsubdirs); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs) 
....................   Summary: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs); 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................  
....................  
.................... /*********************************************************************************************************** 
....................   Function: 
....................     int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second) 
....................   Summary: 
....................     Manually set timestamp variables 
....................   Conditions: 
....................     USERDEFINEDCLOCK macro defined in FSconfig.h. 
....................   Input: 
....................     year -     The year (1980\-2107) 
....................     month -   The month (1\-12) 
....................     day -     The day of the month (1\-31) 
....................     hour -    The hour (0\-23) 
....................     minute -  The minute (0\-59) 
....................     second -  The second (0\-59) 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     Modifies global timing variables 
....................   Description: 
....................     Lets the user manually set the timing variables.  The values passed in will be converted to the format 
....................     used by the FAT timestamps. 
....................   Remarks: 
....................     Call this before creating a file or directory (set create time) and 
....................     before closing a file (set last access time, last modified time)                                         
....................   ***********************************************************************************************************/ 
....................  
.................... int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_FILESEARCH 
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................     The FindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*********************************************************************************** 
....................   Function: 
....................     int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous wFindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent wFindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................     The wFindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec); 
.................... #endif 
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FindNext (SearchRec * rec) 
....................   Summary: 
....................     Sequential search function 
....................   Conditions: 
....................     None 
....................   Input: 
....................     rec -  The structure to store the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No additional files matching the specified criteria were found 
....................   Side Effects: 
....................     Search criteria from previous FindNext call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     The FindNext function performs the same function as the FindFirst 
....................     funciton, except it does not copy any search parameters into the 
....................     SearchRec structure (only info about found files) and it begins 
....................     searching at the last directory entry offset at which a file was 
....................     found, rather than at the beginning of the current working 
....................     directory.If the return value of the function is 0 then "utf16LFNfoundLength" 
....................     indicates whether the file found was long file name or short file 
....................     name(8P3 format). The "utf16LFNfoundLength" is non-zero for long file name 
....................     and is zero for 8P3 format."utf16LFNfound" points to the address of long  
....................     file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling this function 
....................   **********************************************************************/ 
....................  
.................... int FindNext (SearchRec * rec);  
.................... #endif 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int FSfprintf (FSFILE * fptr, const char * fmt, ...) 
....................     // PIC18 
....................     int FSfpritnf (FSFILE * fptr, const rom char * fmt, ...) 
....................   Summary: 
....................     Function to write formatted strings to a file 
....................   Conditions: 
....................     For PIC18, integer promotion must be enabled in the project build 
....................     options menu.  File opened in a write mode. 
....................   Input: 
....................     fptr - A pointer to the file to write to. 
....................     fmt -  A string of characters and format specifiers to write to 
....................            the file 
....................     ... -  Additional arguments inserted in the string by format 
....................            specifiers 
....................   Returns: 
....................     The number of characters written to the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Writes a specially formatted string to a file. 
....................   Remarks: 
....................     Consult AN1045 for a full description of how to use format 
....................     specifiers.         
....................   **********************************************************************/ 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................     #ifdef __18CXX 
....................         int FSfprintf (FSFILE *fptr, const rom char *fmt, ...); 
....................     #else 
....................         int FSfprintf (FSFILE *fptr, const char * fmt, ...); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSerror (void) 
....................   Summary: 
....................     Return an error code for the last function call 
....................   Conditions: 
....................     The return value depends on the last function called. 
....................   Input: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Return Values: 
....................     FSInit       -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The physical media could not be initialized 
....................                  - CE_BAD_SECTOR_READ        The MBR or the boot sector could not be 
....................                                               read correctly 
....................                  - CE_BAD_PARITION           The MBR signature code was incorrect. 
....................                  - CE_NOT_FORMATTED          The boot sector signature code was incorrect or 
....................                                               indicates an invalid number of bytes per sector.  
....................                  - CE_CARDFAT32              The physical media is FAT32 type (only an error  
....................                                               when FAT32 support is disabled).  
....................                  - CE_UNSUPPORTED_FS         The device is formatted with an unsupported file  
....................                                               system (not FAT12 or 16). 
....................     FSfopen      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The device has not been initialized.  
....................                  - CE_TOO_MANY_FILES_OPEN    The function could not allocate any  
....................                                               additional file information to the array  
....................                                               of FSFILE structures or the heap.  
....................                  - CE_INVALID_FILENAME       The file name argument was invalid. 
....................                  - CE_INVALID_ARGUMENT       The user attempted to open a directory in a  
....................                                               write mode or specified an invalid mode argument.  
....................                  - CE_FILE_NOT_FOUND         The specified file (which was to be opened in read  
....................                                               mode) does not exist on the device.  
....................                  - CE_BADCACHEREAD           A read from the device failed. 
....................                  - CE_ERASE_FAIL             The existing file could not be erased (when opening  
....................                                               a file in FS_WRITE mode).  
....................                  - CE_DIR_FULL               The directory is full.  
....................                  - CE_DISK_FULL              The data memory section is full.  
....................                  - CE_WRITE_ERROR            A write to the device failed.  
....................                  - CE_SEEK_ERROR             The current position in the file could not be set to  
....................                                               the end (when the file was opened in FS_APPEND mode). 
....................     FSfclose     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer or the new file 
....................                                               entry information could not be written to the device. 
....................                  - CE_BADCACHEREAD           The file entry information could not be cached 
....................     FSfread      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITEONLY              The file was opened in a write-only mode. 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device.  
....................                  - CE_BAD_SECTOR_READ        The data sector could not be read.  
....................                  - CE_EOF                    The end of the file was reached. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be loaded. 
....................     FSfwrite     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_READONLY               The file was opened in a read-only mode.  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected. 
....................                  - CE_WRITE_ERROR            There was an error writing data to the device. 
....................                  - CE_BADCACHEREAD           The data sector to be modified could not be read from 
....................                                               the device.  
....................                  - CE_DISK_FULL              All data clusters on the device are in use. 
....................     FSfseek      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device.  
....................                  - CE_INVALID_ARGUMENT       The specified offset exceeds the size of the file.  
....................                  - CE_BADCACHEREAD           The sector that contains the new current position  
....................                                               could not be loaded. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be  
....................                                               loaded/allocated. 
....................     FSftell      -  
....................                  - CE_GOOD                   No Error 
....................     FSattrib     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The attribute argument was invalid.  
....................                  - CE_BADCACHEREAD           The existing file entry information could not be  
....................                                               loaded.  
....................                  - CE_WRITE_ERROR            The file entry information could not be written to  
....................                                               the device. 
....................     FSrename     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_FILENOTOPENED          A null file pointer was passed into the function.  
....................                  - CE_INVALID_FILENAME       The file name passed into the function was invalid.  
....................                  - CE_BADCACHEREAD           A read from the device failed.  
....................                  - CE_FILENAME_EXISTS        A file with the specified name already exists.  
....................                  - CE_WRITE_ERROR            The new file entry data could not be written to the  
....................                                               device. 
....................     FSfeof       - 
....................                  - CE_GOOD                   No Error 
....................     FSformat     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The device could not be initialized.  
....................                  - CE_BADCACHEREAD           The master boot record or boot sector could not be  
....................                                               loaded successfully.  
....................                  - CE_INVALID_ARGUMENT       The user selected to create their own boot sector on  
....................                                               a device that has no master boot record, or the mode  
....................                                               argument was invalid.  
....................                  - CE_WRITE_ERROR            The updated MBR/Boot sector could not be written to  
....................                                               the device. 
....................                  - CE_BAD_PARTITION          The calculated number of sectors per clusters was  
....................                                               invalid.  
....................                  - CE_NONSUPPORTED_SIZE      The card has too many sectors to be formatted as  
....................                                               FAT12 or FAT16. 
....................     FSremove     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         The specified file could not be found. 
....................                  - CE_ERASE_FAIL             The file could not be erased. 
....................     FSchdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed or the user tried to  
....................                                               change to a non-directory file. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_FOUND          Could not find a directory in the path. 
....................     FSgetcwd     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The user passed a 0-length buffer into the function. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the current working directory. 
....................     FSmkdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed. 
....................                  - CE_BADCACHEREAD           Could not successfully change to a recently created  
....................                                               directory to store its dir entry information, or  
....................                                               could not cache directory entry information.  
....................                  - CE_INVALID_FILENAME       One or more of the directory names has an invalid  
....................                                               format.  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device or the dot/dotdot entries could  
....................                                               not be written to a newly created directory. 
....................                  - CE_DIR_FULL               There are no available dir entries in the CWD. 
....................                  - CE_DISK_FULL              There are no available clusters in the data region of  
....................                                               the device.     
....................     FSrmdir      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_DIR_NOT_FOUND          The directory specified could not be found or the  
....................                                               function could not change to a subdirectory within  
....................                                               the directory to be deleted (when recursive delete is  
....................                                               enabled). 
....................                  - CE_INVALID_ARGUMENT       The user tried to remove the CWD or root directory.  
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_EMPTY          The directory to be deleted was not empty and  
....................                                               recursive subdirectory removal was disabled.  
....................                  - CE_ERASE_FAIL             The directory or one of the directories or files  
....................                                               within it could not be deleted.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the CWD. 
....................     SetClockVars - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The time values passed into the function were  
....................                                               invalid.     
....................     FindFirst    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found.  
....................                  - CE_BADCACHEREAD           The file information for the file that was found  
....................                                               could not be cached. 
....................     FindNext     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The SearchRec object was not initialized by a call to  
....................                                               FindFirst.  
....................                  - CE_INVALID_ARGUMENT       The SearchRec object was initialized in a different  
....................                                               directory from the CWD. 
....................                  - CE_INVALID_FILENAME       The filename is invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found. 
....................     FSfprintf    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            Characters could not be written to the file.                                                    
....................   Description: 
....................     The FSerror function will return the FSerrno variable.  This global 
....................     variable will have been set to an error value during the last call of a 
....................     library function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... int FSerror (void); 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     int FSCreateMBR (unsigned long firstSector, unsigned long numSectors) 
....................   Summary: 
....................     Creates a master boot record 
....................   Conditions: 
....................     The I/O pins for the device have been initialized by the InitIO function. 
....................   Input: 
....................     firstSector -  The first sector of the partition on the device (cannot 
....................                    be 0; that's the MBR) 
....................     numSectors -   The number of sectors available in memory (including the 
....................                    MBR) 
....................   Return Values: 
....................     0 -   MBR was created successfully 
....................     EOF - MBR could not be created 
....................   Side Effects: 
....................     None 
....................   Description:   
....................     This function can be used to create a master boot record for a device.  Note 
....................     that this function should not be used on a device that is already formatted 
....................     with a master boot record (i.e. most SD cards, CF cards, USB keys).  This 
....................     function will fill the global data buffer with appropriate partition information 
....................     for a FAT partition with a type determined by the number of sectors available 
....................     to the partition.  It will then write the MBR information to the first sector 
....................     on the device.  This function should be followed by a call to FSformat, which 
....................     will create a boot sector, root dir, and FAT appropriate the the information 
....................     contained in the new master boot record.  Note that FSformat only supports 
....................     FAT12 and FAT16 formatting at this time, and so cannot be used to format a 
....................     device with more than 0x3FFD5F sectors. 
....................   Remarks: 
....................     This function can damage the device being used, and should not be called 
....................     unless the user is sure about the size of the device and the first sector value. 
....................   *********************************************************************************/ 
....................  
.................... int FSCreateMBR (unsigned long firstSector, unsigned long numSectors); 
....................  
....................  
.................... #ifdef ALLOW_GET_DISK_PROPERTIES 
.................... /********************************************************************************* 
....................   Function: 
....................     void FSGetDiskProperties(FS_DISK_PROPERTIES* properties) 
....................   Summary: 
....................     Allows user to get the disk properties (size of disk, free space, etc) 
....................   Conditions: 
....................     1) ALLOW_GET_DISK_PROPERTIES must be defined in FSconfig.h 
....................     2) a FS_DISK_PROPERTIES object must be created before the function is called 
....................     3) the new_request member of the FS_DISK_PROPERTIES object must be set before 
....................         calling the function for the first time.  This will start a new search. 
....................     4) this function should not be called while there is a file open.  Close all 
....................         files before calling this function. 
....................   Input: 
....................     properties - a pointer to a FS_DISK_PROPERTIES object where the results should 
....................       be stored. 
....................   Return Values: 
....................     This function returns void.  The properties_status of the previous call of  
....................       this function is located in the properties.status field.  This field has  
....................       the following possible values: 
....................  
....................     FS_GET_PROPERTIES_NO_ERRORS - operation completed without error.  Results 
....................       are in the properties object passed into the function. 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED - there is no mounted disk.  Results in 
....................       properties object is not valid 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE - there was a failure trying to read a  
....................       cluster from the drive.  The results in the properties object is a partial 
....................       result up until the point of the failure. 
....................     FS_GET_PROPERTIES_STILL_WORKING - the search for free sectors is still in 
....................       process.  Continue calling this function with the same properties pointer  
....................       until either the function completes or until the partial results meets the 
....................       application needs.  The properties object contains the partial results of 
....................       the search and can be used by the application.   
....................   Side Effects: 
....................     Can cause errors if called when files are open.  Close all files before 
....................     calling this function. 
....................  
....................     Calling this function without setting the new_request member on the first 
....................     call can result in undefined behavior and results. 
....................  
....................     Calling this function after a result is returned other than 
....................     FS_GET_PROPERTIES_STILL_WORKING can result in undefined behavior and results. 
....................   Description:   
....................     This function returns the information about the mounted drive.  The results  
....................     member of the properties object passed into the function is populated with  
....................     the information about the drive.     
....................  
....................     Before starting a new request, the new_request member of the properties 
....................     input parameter should be set to TRUE.  This will initiate a new search 
....................     request. 
....................  
....................     This function will return before the search is complete with partial results. 
....................     All of the results except the free_clusters will be correct after the first 
....................     call.  The free_clusters will contain the number of free clusters found up 
....................     until that point, thus the free_clusters result will continue to grow until 
....................     the entire drive is searched.  If an application only needs to know that a  
....................     certain number of bytes is available and doesn't need to know the total free  
....................     size, then this function can be called until the required free size is 
....................     verified.  To continue a search, pass a pointer to the same FS_DISK_PROPERTIES 
....................     object that was passed in to create the search. 
....................  
....................     A new search request sould be made once this function has returned a value  
....................     other than FS_GET_PROPERTIES_STILL_WORKING.  Continuing a completed search 
....................     can result in undefined behavior or results. 
....................  
....................     Typical Usage: 
....................     <code> 
....................     FS_DISK_PROPERTIES disk_properties; 
....................  
....................     disk_properties.new_request = TRUE; 
....................  
....................     do 
....................     { 
....................         FSGetDiskProperties(&disk_properties); 
....................     } while (disk_properties.properties_status == FS_GET_PROPERTIES_STILL_WORKING); 
....................     </code> 
....................  
....................     results.disk_format - contains the format of the drive.  Valid results are  
....................       FAT12(1), FAT16(2), or FAT32(3). 
....................  
....................     results.sector_size - the sector size of the mounted drive.  Valid values are 
....................       512, 1024, 2048, and 4096. 
....................  
....................     results.sectors_per_cluster - the number sectors per cluster. 
....................  
....................     results.total_clusters - the number of total clusters on the drive.  This  
....................       can be used to calculate the total disk size (total_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................     results.free_clusters - the number of free (unallocated) clusters on the drive. 
....................       This can be used to calculate the total free disk size (free_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................   Remarks: 
....................     PIC24F size estimates: 
....................       Flash - 400 bytes (-Os setting) 
....................  
....................     PIC24F speed estimates: 
....................       Search takes approximately 7 seconds per Gigabyte of drive space.  Speed 
....................         will vary based on the number of sectors per cluster and the sector size. 
....................   *********************************************************************************/ 
.................... void FSGetDiskProperties(FS_DISK_PROPERTIES* properties); 
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE FILEget_next_cluster(FSFILE *fo, DWORD n) 
....................   Summary: 
....................     Step through a chain of clusters 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fo - The file to get the next cluster of 
....................     n -  Number of links in the FAT cluster chain to jump through 
....................   Return Values: 
....................     CE_GOOD - Operation successful 
....................     CE_BAD_SECTOR_READ - A bad read occured of a sector 
....................     CE_INVALID_CLUSTER - Invalid cluster value \> maxcls 
....................     CE_FAT_EOF - Fat attempt to read beyond EOF 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will load 'n' proximate clusters for a file from 
....................     the FAT on the device.  It will stop checking for clusters if the 
....................     ReadFAT function returns an error, if it reaches the last cluster in 
....................     a file, or if the device tries to read beyond the last cluster used 
....................     by the device. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... BYTE FILEget_next_cluster(FSFILE *fo, DWORD n); 
....................  
.................... #endif 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "string.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = beg; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "ctype.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include "MDD File System/FSDefs.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSDefs.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.2.4 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  _FSDEF__H 
.................... #define  _FSDEF__H 
....................  
.................... #include "../GenericTypeDefs.h" 
....................  
.................... // Summary: An enumeration used for various error codes. 
.................... // Description: The CETYPE enumeration is used to indicate different error conditions during device operation. 
.................... typedef enum _CETYPE 
.................... { 
....................     CE_GOOD = 0,                    // No error 
....................     CE_ERASE_FAIL,                  // An erase failed 
....................     CE_NOT_PRESENT,                 // No device was present 
....................     CE_NOT_FORMATTED,               // The disk is of an unsupported format 
....................     CE_BAD_PARTITION,               // The boot record is bad 
....................     CE_UNSUPPORTED_FS,              // The file system type is unsupported 
....................     CE_INIT_ERROR,                  // An initialization error has occured 
....................     CE_NOT_INIT,                    // An operation was performed on an uninitialized device 
....................     CE_BAD_SECTOR_READ,             // A bad read of a sector occured 
....................     CE_WRITE_ERROR,                 // Could not write to a sector 
....................     CE_INVALID_CLUSTER,             // Invalid cluster value > maxcls 
....................     CE_FILE_NOT_FOUND,              // Could not find the file on the device 
....................     CE_DIR_NOT_FOUND,               // Could not find the directory 
....................     CE_BAD_FILE,                    // File is corrupted 
....................     CE_DONE,                        // No more files in this directory 
....................     CE_COULD_NOT_GET_CLUSTER,       // Could not load/allocate next cluster in file 
....................     CE_FILENAME_2_LONG,             // A specified file name is too long to use 
....................     CE_FILENAME_EXISTS,             // A specified filename already exists on the device 
....................     CE_INVALID_FILENAME,            // Invalid file name 
....................     CE_DELETE_DIR,                  // The user tried to delete a directory with FSremove 
....................     CE_DIR_FULL,                    // All root dir entry are taken 
....................     CE_DISK_FULL,                   // All clusters in partition are taken 
....................     CE_DIR_NOT_EMPTY,               // This directory is not empty yet, remove files before deleting 
....................     CE_NONSUPPORTED_SIZE,           // The disk is too big to format as FAT16 
....................     CE_WRITE_PROTECTED,             // Card is write protected 
....................     CE_FILENOTOPENED,               // File not opened for the write 
....................     CE_SEEK_ERROR,                  // File location could not be changed successfully 
....................     CE_BADCACHEREAD,                // Bad cache read 
....................     CE_CARDFAT32,                   // FAT 32 - card not supported 
....................     CE_READONLY,                    // The file is read-only 
....................     CE_WRITEONLY,                   // The file is write-only 
....................     CE_INVALID_ARGUMENT,            // Invalid argument 
....................     CE_TOO_MANY_FILES_OPEN,         // Too many files are already open 
....................     CE_UNSUPPORTED_SECTOR_SIZE,     // Unsupported sector size 
....................     CE_EOF = 61 
.................... } CETYPE; 
....................  
....................  
.................... // Summary: A macro indicating a dir entry was found 
.................... // Description: The FOUND macro indicates that a directory entry was found in the specified position 
.................... #define FOUND       0 
....................  
.................... // Summary: A macro indicating no dir entry was found 
.................... // Description: The NOT_FOUND macro indicates that the specified directory entry to load was deleted 
.................... #define NOT_FOUND   1 
....................  
.................... // Summary: A macro indicating that no more files were found 
.................... // Description: The NO_MORE macro indicates that there are no more directory entries to search for 
.................... #define NO_MORE     2 
....................  
....................  
....................  
.................... // Summary: A macro indicating the device is formatted with FAT12 
.................... // Description: The FAT12 macro is used to indicate that the file system on the device being accessed is a FAT12 file system. 
.................... #define FAT12       1 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT16 
.................... // Description: The FAT16 macro is used to indicate that the file system on the device being accessed is a FAT16 file system. 
.................... #define FAT16       2 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT32 
.................... // Description: The FAT32 macro is used to indicate that the file system on the device being accessed is a FAT32 file system. 
.................... #define FAT32       3 
....................  
....................  
....................  
.................... // Summary: A read-only attribute macro 
.................... // Description: A macro for the read-only attribute.  A file with this attribute should not be written to.  Note that this 
.................... //              attribute will not actually prevent a write to the file; that functionality is operating-system dependant.  The 
.................... //              user should take care not to write to a read-only file. 
.................... #define ATTR_READ_ONLY      0x01 
....................  
.................... // Summary: A hidden attribute macro 
.................... // Description: A macro for the hidden attribute.  A file with this attribute may be hidden from the user, depending on the 
.................... //              implementation of the operating system. 
.................... #define ATTR_HIDDEN         0x02 
....................  
.................... // Summary: A system attribute macro 
.................... // Description: A macro for the system attribute.  A file with this attribute is used by the operating system, and should not be 
.................... //              modified.  Note that this attribute will not actually prevent a write to the file. 
.................... #define ATTR_SYSTEM         0x04 
....................  
.................... // Summary: A volume attribute macro 
.................... // Description: A macro for the volume attribute.  If the first directory entry in the root directory has the volume attribute set, 
.................... //              the device will use the name in that directory entry as the volume name. 
.................... #define ATTR_VOLUME         0x08 
....................  
.................... // Summary: A macro for the attributes for a long-file name entry 
.................... // Description: A macro for the long-name attributes.  If a directory entry is used in a long-file name implementation, it will have 
.................... //              all four lower bits set.  This indicates that any software that does not support long file names should ignore that 
.................... //              entry. 
.................... #define ATTR_LONG_NAME      0x0f 
....................  
.................... // Summary: A directory attribute macro 
.................... // Description: A macro for the directory attribute.  If a directory entry has this attribute set, the file it points to is a directory- 
.................... //              type file, and will contain directory entries that point to additional directories or files. 
.................... #define ATTR_DIRECTORY      0x10 
....................  
.................... // Summary: An archive attribute macro 
.................... // Description: A macro for the archive attribute.  This attribute will indicate to some archiving programs that the file with this 
.................... //              attribute needs to be backed up.  Most operating systems create files with the archive attribute set. 
.................... #define ATTR_ARCHIVE        0x20 
....................  
.................... // Summary: A macro for all attributes 
.................... // Description: A macro for all attributes.  The search functions in this library require an argument that determines which attributes 
.................... //              a file is allowed to have in order to be found.  If ATTR_MASK is specified as this argument, any file may be found, regardless 
.................... //              of its attributes. 
.................... #define ATTR_MASK           0x3f 
....................  
....................  
....................  
.................... // Summary: A macro to indicate an empty FAT entry 
.................... // Description: The CLUSTER_EMPTY value is used to indicate that a FAT entry and it's corresponding cluster are available. 
.................... #define CLUSTER_EMPTY               0x0000  
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT12 
.................... // Description: The LAST_CLUSTER_FAT12 macro is used when reading the FAT to indicate that the next FAT12 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT12          0xff8 
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT16 
.................... // Description: The LAST_CLUSTER_FAT16 macro is used when reading the FAT to indicate that the next FAT16 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT16          0xfff8 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT12 
.................... // Description: The END_CLUSTER_FAT12 value is used as a comparison in FAT12 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT12           0xFF7 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT16 
.................... // Description: The END_CLUSTER_FAT16 value is used as a comparison in FAT16 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT16           0xFFF7 
....................  
.................... // Summary: A macro to indicate the failure of the ReadFAT function 
.................... // Description: The CLUSTER_FAIL_FAT16 macro is used by the ReadFAT function to indicate that an error occured reading a FAT12 or FAT16 
.................... //              file allocation table.  Note that since '0xFFF8' is used for the last cluster return value in the FAT16 implementation 
.................... //              the end-of-file value '0xFFFF' can be used to indicate an error condition. 
.................... #define CLUSTER_FAIL_FAT16          0xFFFF 
....................  
....................  
....................  
.................... #ifdef SUPPORT_FAT32 
....................     // Summary: A macro to indicate the last cluster value for FAT32 
....................     // Description: The LAST_CLUSTER_FAT32 macro is used when reading the FAT to indicate that the next FAT32 entry for a file contains 
....................     //              the end-of-file value. 
....................     #define LAST_CLUSTER_FAT32      0x0FFFFFF8 
....................  
....................     // Summary: A macro to indicate the last allocatable cluster for FAT32 
....................     // Description: The END_CLUSTER_FAT32 value is used as a comparison in FAT32 to determine that the firmware has reached the end of 
....................     //              the range of allowed allocatable clusters. 
....................     #define END_CLUSTER_FAT32       0x0FFFFFF7 
....................  
....................     // Summary: A macro to indicate the failure of the ReadFAT function 
....................     // Description: The CLUSTER_FAIL_FAT32 macro is used by the ReadFAT function to indicate that an error occured reading a FAT32 
....................     //              file allocation able. 
....................     #define CLUSTER_FAIL_FAT32      0x0FFFFFFF 
....................  
.................... #endif 
....................  
.................... // Summary: A macro indicating the number of bytes in a directory entry. 
.................... // Description: The NUMBER_OF_BYTES_IN_DIR_ENTRY macro represents the number of bytes in one directory entry.  It is used to calculate 
.................... //              the number of sectors in the root directory based on information in the boot sector. 
.................... #define NUMBER_OF_BYTES_IN_DIR_ENTRY    32 
....................  
....................  
....................  
.................... // Summary: A macro for a deleted dir entry marker. 
.................... // Description: The DIR_DEL macro is used to mark a directory entry as deleted.  When a file is deleted, this value will replace the 
.................... //              first character in the file name, and will indicate that the file the entry points to was deleted. 
.................... #define DIR_DEL             0xE5 
....................  
.................... // Summary: A macro for the last dir entry marker. 
.................... // Description: The DIR_EMPTY macro is used to indicate the last entry in a directory.  Since entries in use cannot start with a 0 and 
.................... //              deleted entries start with the DIR_DEL character, a 0 will mark the end of the in-use or previously used group of 
.................... //              entries in a directory 
.................... #define DIR_EMPTY           0 
....................  
....................  
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name 
.................... // Description: The DIR_NAMESIZE macro is used when validing the name portion of 8.3 filenames 
.................... #define DIR_NAMESIZE        8 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file extension 
.................... // Description: The DIR_EXTENSION macro is used when validating the extension portion of 8.3 filenames 
.................... #define DIR_EXTENSION       3 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name and extension 
.................... // Description: The DIR_NAMECOMP macro is used when validating 8.3 filenames 
.................... #define DIR_NAMECOMP        (DIR_NAMESIZE+DIR_EXTENSION) 
....................  
....................  
....................  
.................... // Summary: A macro to write a byte to RAM 
.................... // Description: The RAMwrite macro is used to write a byte of data to a RAM array 
.................... #define RAMwrite( a, f, d) *(a+f) = d 
....................  
.................... // Summary: A macro to read a byte from RAM 
.................... // Description: The RAMread macro is used to read a byte of data from a RAM array 
.................... #define RAMread( a, f)  *(a+f) 
....................  
.................... // Summary: A macro to read a 16-bit word from RAM 
.................... // Description: The RAMreadW macro is used to read two bytes of data from a RAM array 
.................... #define RAMreadW( a, f) *(WORD *)(a+f) 
....................  
.................... // Summary: A macro to read a 32-bit word from RAM 
.................... // Description: The RAMreadD macro is used to read four bytes of data from a RAM array 
.................... #define RAMreadD( a, f) *(DWORD *)(a+f) 
....................  
....................  
....................  
.................... #ifndef EOF 
....................     // Summary: Indicates error conditions or end-of-file conditions 
....................     // Description: The EOF macro is used to indicate error conditions in some function calls.  It is also used to indicate 
....................     //              that the end-of-file has been reached. 
....................     #define EOF             ((int)-1) 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing information about the device. 
.................... // Description: The DISK structure contains information about the device being accessed. 
.................... typedef struct 
.................... {  
....................     BYTE    *   buffer;         // Address of the global data buffer used to read and write file information 
....................     DWORD       firsts;         // Logical block address of the first sector of the FAT partition on the device 
....................     DWORD       fat;            // Logical block address of the FAT 
....................     DWORD       root;           // Logical block address of the root directory 
....................     DWORD       data;           // Logical block address of the data section of the device. 
....................     WORD        maxroot;        // The maximum number of entries in the root directory. 
....................     DWORD       maxcls;         // The maximum number of clusters in the partition. 
....................     DWORD       sectorSize;     // The size of a sector in bytes 
....................     DWORD       fatsize;        // The number of sectors in the FAT 
....................     BYTE        fatcopy;        // The number of copies of the FAT in the partition 
....................     BYTE        SecPerClus;     // The number of sectors per cluster in the data region 
....................     BYTE        type;           // The file system type of the partition (FAT12, FAT16 or FAT32) 
....................     BYTE        mount;          // Device mount flag (TRUE if disk was mounted successfully, FALSE otherwise) 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... } __attribute__ ((packed)) DISK; 
.................... #else 
.................... } DISK; 
.................... #endif 
....................  
....................  
.................... #if defined(__18CXX) && !defined(__CCS__) 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef unsigned short long SWORD; 
.................... #else 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef struct 
....................     { 
....................         unsigned char array[3]; 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) SWORD; 
.................... #else 
....................     } SWORD; 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT12 file system (in the boot sector) 
.................... // Description: The _BPB_FAT12 structure provides a layout of the "bios parameter block" in the boot sector of a FAT12 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BPS;               // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD BootSec_ResrvSec;          // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD BootSec_RootDirEnts;       // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD BootSec_SPF;               // Number of sectors per FAT 
....................     WORD BootSec_SPT;               // Number of sectors per track 
....................     WORD BootSec_HeadCnt;           // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD  BootSec_Reserved;        // Reserved space 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved2;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination    
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT12; 
.................... #else 
....................     } _BPB_FAT12; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT16 file system (in the boot sector) 
.................... // Description: The _BPB_FAT16 structure provides a layout of the "bios parameter block" in the boot sector of a FAT16 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD  BootSec_BPS;              // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD  BootSec_ResrvSec;         // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD  BootSec_RootDirEnts;      // Number of root directory entries 
....................     WORD  BootSec_TotSec16;         // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD  BootSec_SPF;              // Number of sectors per FAT 
....................     WORD  BootSec_SPT;              // Number of sectors per track 
....................     WORD  BootSec_HeadCnt;          // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved;         // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination      
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT16; 
.................... #else 
....................     } _BPB_FAT16; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT32 file system (in the boot sector) 
.................... // Description: The _BPB_FAT32 structure provides a layout of the "bios parameter block" in the boot sector of a FAT32 partition. 
.................... typedef struct { 
....................     SWORD BootSec_jmpBoot;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BytsPerSec;        // Number of bytes per sector 
....................     BYTE  BootSec_SecPerClus;       // Number of sectors per cluster 
....................     WORD BootSec_RsvdSecCnt;        // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_NumFATs;          // Number of FATs on the partition 
....................     WORD BootSec_RootEntCnt;        // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_Media;            // Media descriptor 
....................     WORD BootSec_FATSz16;           // Number of sectors per FAT 
....................     WORD BootSec_SecPerTrk;         // Number of sectors per track 
....................     WORD BootSec_NumHeads;          // Number of heads 
....................     DWORD BootSec_HiddSec;          // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     DWORD BootSec_FATSz32;          // Sectors per FAT (32 bits) 
....................     WORD BootSec_ExtFlags;          // Presently active FAT. Defined by bits 0-3 if bit 7 is 1. 
....................     WORD BootSec_FSVers;            // FAT32 filesystem version.  Should be 0:0 
....................     DWORD BootSec_RootClus;         // Start cluster of the root directory (should be 2) 
....................     WORD BootSec_FSInfo;            // File system information 
....................     WORD BootSec_BkBootSec;         // Backup boot sector address. 
....................     BYTE  BootSec_Reserved[12];     // Reserved space 
....................     BYTE  BootSec_DrvNum;           // Drive number 
....................     BYTE  BootSec_Reserved1;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLab[11];       // Volume Label 
....................     BYTE  BootSec_FilSysType[8];    // File system type in ASCII.  Not used for determination   
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT32; 
.................... #else 
....................     } _BPB_FAT32; 
.................... #endif 
....................  
....................  
.................... // Description: A macro for the boot sector bytes per sector value offset 
.................... #define BSI_BPS            11 
....................  
.................... // Description: A macro for the boot sector sector per cluster value offset 
.................... #define BSI_SPC            13 
....................  
.................... // Description: A macro for the boot sector reserved sector count value offset 
.................... #define BSI_RESRVSEC       14 
....................  
.................... // Description: A macro for the boot sector FAT count value offset 
.................... #define BSI_FATCOUNT       16 
....................  
.................... // Description: A macro for the boot sector root directory entry count value offset 
.................... #define BSI_ROOTDIRENTS    17 
....................  
.................... // Description: A macro for the boot sector 16-bit total sector count value offset 
.................... #define BSI_TOTSEC16       19 
....................  
.................... // Description: A macro for the boot sector sectors per FAT value offset 
.................... #define BSI_SPF            22 
....................  
.................... // Description: A macro for the boot sector 32-bit total sector count value offset 
.................... #define BSI_TOTSEC32       32 
....................  
.................... // Description: A macro for the boot sector boot signature offset 
.................... #define BSI_BOOTSIG        38 
....................  
.................... // Description: A macro for the boot sector file system type string offset 
.................... #define BSI_FSTYPE         54 
....................  
.................... // Description: A macro for the boot sector 32-bit sector per FAT value offset 
.................... #define  BSI_FATSZ32       36 
....................  
.................... // Description: A macro for the boot sector start cluster of root directory value offset 
.................... #define  BSI_ROOTCLUS      44 
....................  
.................... // Description: A macro for the FAT32 boot sector boot signature offset 
.................... #define  BSI_FAT32_BOOTSIG 66 
....................  
.................... // Description: A macro for the FAT32 boot sector file system type string offset 
.................... #define  BSI_FAT32_FSTYPE  82 
....................  
....................  
....................  
.................... // Summary: A partition table entry structure. 
.................... // Description: The PTE_MBR structure contains values found in a partition table entry in the MBR of a device. 
.................... typedef struct 
.................... { 
....................     BYTE      PTE_BootDes;            // The boot descriptor (should be 0x00 in a non-bootable device) 
....................     SWORD     PTE_FrstPartSect;       // The cylinder-head-sector address of the first sector of the partition 
....................     BYTE      PTE_FSDesc;             // The file system descriptor 
....................     SWORD     PTE_LstPartSect;        // The cylinder-head-sector address of the last sector of the partition 
....................     DWORD     PTE_FrstSect;           // The logical block address of the first sector of the partition 
....................     DWORD     PTE_NumSect;            // The number of sectors in a partition 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) PTE_MBR; 
.................... #else 
....................     } PTE_MBR; 
.................... #endif 
....................  
....................  
.................... // Summary: A structure of the organization of a master boot record. 
.................... // Description: The _PT_MBR structure has the same form as a master boot record.  When the MBR is loaded from the device, it will 
.................... //              be cast as a _PT_MBR structure so the MBR elements can be accessed. 
.................... typedef struct 
.................... { 
....................     BYTE        ConsChkRtn[446];        // Boot code 
....................     PTE_MBR     Partition0;             // The first partition table entry 
....................     PTE_MBR     Partition1;             // The second partition table entry 
....................     PTE_MBR     Partition2;             // The third partition table entry 
....................     PTE_MBR     Partition3;             // The fourth partition table entry 
....................     BYTE        Signature0;             // MBR signature code - equal to 0x55 
....................     BYTE        Signature1;             // MBR signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... }__attribute__((packed)) _PT_MBR; 
.................... #else 
.................... }_PT_MBR; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _PT_MBR structure 
.................... // Description: The PT_MBR pointer points to a _PT_MBR structure. 
.................... typedef _PT_MBR *  PT_MBR; 
....................  
....................  
....................  
.................... // Summary: A structure of the organization of a boot sector. 
.................... // Description: The _BootSec structure has the same form as a boot sector.  When the boot sector is loaded from the device, it will 
.................... //              be cast as a _BootSec structure so the boot sector elements can be accessed. 
.................... typedef struct 
.................... { 
....................     // A union of different bios parameter blocks 
....................     union 
....................     { 
....................         _BPB_FAT32  FAT_32; 
....................         _BPB_FAT16  FAT_16; 
....................         _BPB_FAT12  FAT_12; 
....................     }FAT; 
....................     BYTE    Reserved[512-sizeof(_BPB_FAT32)-2]; // Reserved space 
....................     BYTE    Signature0;         // Boot sector signature code - equal to 0x55 
....................     BYTE    Signature1;         // Boot sector signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BootSec; 
.................... #else 
....................     } _BootSec; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _BootSec structure 
.................... // Description: The BootSec pointer points to a _BootSec structure. 
.................... typedef _BootSec * BootSec; 
....................  
....................  
....................  
.................... // Summary: A macro indicating the offset for the master boot record 
.................... // Description: FO_MBR is a macro that indicates the addresss of the master boot record on the device.  When the device is initialized 
.................... //              this sector will be read 
.................... #define FO_MBR          0L 
....................  
....................  
....................  
.................... // Summary: A macro for the first boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_0 macro is used to determine that the first byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_0     0x55 
....................  
.................... // Summary: A macro for the second boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_1 macro is used to determine that the second byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_1     0xAA 
....................  
....................  
.................... typedef struct  
.................... { 
....................     BYTE    errorCode; 
....................     union  
....................     { 
....................         BYTE    value; 
....................         struct  
....................         { 
....................             BYTE    sectorSize  : 1; 
....................             BYTE    maxLUN      : 1; 
....................         }   bits; 
....................     } validityFlags; 
....................      
....................     WORD    sectorSize; 
....................     BYTE    maxLUN; 
.................... } MEDIA_INFORMATION; 
....................  
.................... typedef enum 
.................... { 
....................     MEDIA_NO_ERROR,                     // No errors 
....................     MEDIA_DEVICE_NOT_PRESENT,           // The requested device is not present 
....................     MEDIA_CANNOT_INITIALIZE             // Cannot initialize media 
.................... } MEDIA_ERRORS;                 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_FSFPRINTF 
.................... #include "stdarg.h" 
.................... #endif 
....................  
.................... #ifdef FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................       #include "salloc.h" 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef ALLOW_WRITES 
....................    #ifdef ALLOW_FORMATS 
....................       #error Write functions must be enabled to use the format function 
....................    #endif 
....................    #ifdef ALLOW_FSFPRINTF 
....................       #error Write functions must be enabled to use the FSfprintf function 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef USEREALTIMECLOCK 
....................     #ifdef USERDEFINEDCLOCK 
....................         #error Please select only one timestamp clocking mode in FSconfig.h 
....................     #endif 
....................     #ifdef INCREMENTTIMESTAMP 
....................         #error Please select only one timestamp clocking mode in FSconfig.h 
....................     #endif 
.................... #elif defined USERDEFINEDCLOCK 
....................     #ifdef INCREMENTTIMESTAMP 
....................         #error Please select only one timestamp clocking mode in FSconfig.h 
....................     #endif 
.................... #endif 
.................... /*****************************************************************************/ 
.................... /*                         Global Variables                                  */ 
.................... /*****************************************************************************/ 
....................  
.................... #ifndef FS_DYNAMIC_MEM 
....................     FSFILE  gFileArray[FS_MAX_FILES_OPEN];      // Array that contains file information (static allocation) 
....................     BYTE    gFileSlotOpen[FS_MAX_FILES_OPEN];   // Array that indicates which elements of gFileArray are available for use 
....................    #ifdef SUPPORT_LFN 
....................       // Array that stores long file name (static allocation) 
....................       unsigned short int lfnData[FS_MAX_FILES_OPEN][257]; 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef SUPPORT_LFN 
....................    #ifdef ALLOW_FILESEARCH 
....................       // Array that stores long file name for File Search operation (static allocation) 
....................       unsigned short int recordSearchName[257]; 
....................       unsigned short int recordFoundName[257]; 
....................       unsigned short int recordSearchLength; 
....................    #endif 
....................    unsigned short int fileFoundString[261]; 
.................... #endif 
....................  
.................... #if defined(USEREALTIMECLOCK) || defined(USERDEFINEDCLOCK) 
.................... // Timing variables 
.................... BYTE    gTimeCrtMS;     // Global time variable (for timestamps) used to indicate create time (milliseconds) 
.................... WORD    gTimeCrtTime;   // Global time variable (for timestamps) used to indicate create time 
.................... WORD    gTimeCrtDate;   // Global time variable (for timestamps) used to indicate create date 
.................... WORD    gTimeAccDate;   // Global time variable (for timestamps) used to indicate last access date 
.................... WORD    gTimeWrtTime;   // Global time variable (for timestamps) used to indicate last update time 
.................... WORD    gTimeWrtDate;   // Global time variable (for timestamps) used to indicate last update date 
.................... #endif 
....................  
.................... DWORD       gLastFATSectorRead = 0xFFFFFFFF;    // Global variable indicating which FAT sector was read last 
.................... BYTE        gNeedFATWrite = FALSE;              // Global variable indicating that there is information that needs to be written to the FAT 
.................... FSFILE  *   gBufferOwner = NULL;                // Global variable indicating which file is using the data buffer 
.................... DWORD       gLastDataSectorRead = 0xFFFFFFFF;   // Global variable indicating which data sector was read last 
.................... BYTE        gNeedDataWrite = FALSE;             // Global variable indicating that there is information that needs to be written to the data section 
.................... BYTE        nextClusterIsLast = FALSE;          // Global variable indicating that the entries in a directory align with a cluster boundary 
....................  
.................... BYTE    gBufferZeroed = FALSE;      // Global variable indicating that the data buffer contains all zeros 
....................  
.................... DWORD   FatRootDirClusterValue;     // Global variable containing the cluster number of the root dir (0 for FAT12/16) 
....................  
.................... BYTE    FSerrno;                    // Global error variable.  Set to one of many error codes after each function call. 
....................  
.................... DWORD   TempClusterCalc;            // Global variable used to store the calculated value of the cluster of a specified sector. 
.................... BYTE    dirCleared;                 // Global variable used by the "recursive" FSrmdir function to indicate that all subdirectories and files have been deleted from the target directory. 
.................... BYTE    recache = FALSE;            // Global variable used by the "recursive" FSrmdir function to indicate that additional cache reads are needed. 
.................... FSFILE  tempCWDobj;                 // Global variable used to preserve the current working directory information. 
.................... FSFILE  gFileTemp;                  // Global variable used for file operations. 
....................  
.................... FSFILE   cwd;               // Global current working directory 
.................... FSFILE * cwdptr = &cwd;     // Pointer to the current working directory 
....................  
.................... #ifdef __18CXX 
....................     #pragma udata dataBuffer = DATA_BUFFER_ADDRESS 
....................     BYTE gDataBuffer[MEDIA_SECTOR_SIZE];    // The global data sector buffer 
....................     #pragma udata FATBuffer = FAT_BUFFER_ADDRESS 
....................     BYTE gFATBuffer[MEDIA_SECTOR_SIZE];     // The global FAT sector buffer 
....................     #pragma udata 
.................... #endif 
....................  
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................     BYTE __attribute__ ((aligned(4)))   gDataBuffer[MEDIA_SECTOR_SIZE];     // The global data sector buffer 
....................     BYTE __attribute__ ((aligned(4)))   gFATBuffer[MEDIA_SECTOR_SIZE];      // The global FAT sector buffer 
.................... #endif 
....................  
.................... DISK gDiskData;         // Global structure containing device information. 
....................  
.................... /* Global Variables to handle ASCII & UTF16 file operations */ 
.................... char *asciiFilename; 
.................... unsigned short int fileNameLength; 
.................... #ifdef SUPPORT_LFN 
....................    unsigned short int *utf16Filename; 
....................    BOOL   utfModeFileName = FALSE; 
....................    BOOL   twoByteMode = FALSE; 
.................... #endif 
.................... /************************************************************************/ 
.................... /*                        Structures and defines                        */ 
.................... /************************************************************************/ 
....................  
.................... // Directory entry structure 
.................... typedef struct 
.................... { 
....................     char      DIR_Name[DIR_NAMESIZE];           // File name 
....................     char      DIR_Extension[DIR_EXTENSION];     // File extension 
....................     BYTE      DIR_Attr;                         // File attributes 
....................     BYTE      DIR_NTRes;                        // Reserved byte 
....................     BYTE      DIR_CrtTimeTenth;                 // Create time (millisecond field) 
....................     WORD      DIR_CrtTime;                      // Create time (second, minute, hour field) 
....................     WORD      DIR_CrtDate;                      // Create date 
....................     WORD      DIR_LstAccDate;                   // Last access date 
....................     WORD      DIR_FstClusHI;                    // High word of the entry's first cluster number 
....................     WORD      DIR_WrtTime;                      // Last update time 
....................     WORD      DIR_WrtDate;                      // Last update date 
....................     WORD      DIR_FstClusLO;                    // Low word of the entry's first cluster number 
....................     DWORD     DIR_FileSize;                     // The 32-bit file size 
.................... }_DIRENTRY; 
....................  
.................... typedef _DIRENTRY * DIRENTRY;                   // A pointer to a directory entry structure 
....................  
.................... #define DIRECTORY 0x12          // Value indicating that the CreateFileEntry function will be creating a directory 
....................  
.................... #define DIRENTRIES_PER_SECTOR   (MEDIA_SECTOR_SIZE / 32)        // The number of directory entries in a sector 
....................  
.................... // Maximum number of UTF16 words in single Root directory entry 
.................... #define MAX_UTF16_CHARS_IN_LFN_ENTRY      (BYTE)13 
....................  
.................... // Long File Name Entry 
.................... typedef struct 
.................... { 
....................    BYTE LFN_SequenceNo;   // Sequence number, 
....................    BYTE LFN_Part1[10];    // File name part 1 
....................    BYTE LFN_Attribute;    // File attribute 
....................    BYTE LFN_Type;      // LFN Type 
....................    BYTE LFN_Checksum;     // Checksum 
....................    unsigned short int LFN_Part2[6];    // File name part 2 
....................    unsigned short int LFN_Reserved2;   // Reserved for future use 
....................    unsigned short int LFN_Part3[2];     // File name part 3 
.................... }LFN_ENTRY; 
....................  
.................... /* Summary: Possible type of file or directory name. 
.................... ** Description: See the FormatFileName() & FormatDirName() function for more information. 
.................... */ 
.................... typedef enum 
.................... { 
....................     NAME_8P3_ASCII_CAPS_TYPE, 
....................     NAME_8P3_ASCII_MIXED_TYPE, 
....................     NAME_8P3_UTF16_TYPE, // SUBTYPES OF 8P3 UTF16 TYPE 
....................        NAME_8P3_UTF16_ASCII_CAPS_TYPE, 
....................        NAME_8P3_UTF16_ASCII_MIXED_TYPE, 
....................        NAME_8P3_UTF16_NONASCII_TYPE, 
....................     NAME_LFN_TYPE, 
....................     NAME_ERROR 
.................... } FILE_DIR_NAME_TYPE; 
....................  
.................... // internal errors 
.................... #define CE_FAT_EOF            60   // Error that indicates an attempt to read FAT entries beyond the end of the file 
.................... //#define CE_EOF                61   // Error that indicates that the end of the file has been reached 
....................  
.................... typedef FSFILE   * FILEOBJ;         // Pointer to an FSFILE object 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................  
.................... #define _FLAG_MINUS 0x1             // FSfprintf minus flag indicator 
.................... #define _FLAG_PLUS  0x2             // FSfprintf plus flag indicator 
.................... #define _FLAG_SPACE 0x4             // FSfprintf space flag indicator 
.................... #define _FLAG_OCTO  0x8             // FSfprintf octothorpe (hash mark) flag indicator 
.................... #define _FLAG_ZERO  0x10            // FSfprintf zero flag indicator 
.................... #define _FLAG_SIGNED 0x80           // FSfprintf signed flag indicator 
....................  
.................... #ifdef __18CXX 
....................     #define _FMT_UNSPECIFIED 0      // FSfprintf unspecified argument size flag 
....................     #define _FMT_LONG 1             // FSfprintf 32-bit argument size flag 
....................     #define _FMT_SHRTLONG 2         // FSfprintf 24-bit argument size flag 
....................     #define _FMT_BYTE   3           // FSfprintf 8-bit argument size flag 
.................... #else 
....................     #define _FMT_UNSPECIFIED 0      // FSfprintf unspecified argument size flag 
....................     #define _FMT_LONGLONG 1         // FSfprintf 64-bit argument size flag 
....................     #define _FMT_LONG 2             // FSfprintf 32-bit argument size flag 
....................     #define _FMT_BYTE 3             // FSfprintf 8-bit argument size flag 
.................... #endif 
....................  
.................... #ifdef __18CXX 
....................     static const rom char s_digits[] = "0123456789abcdef";      // FSfprintf table of conversion digits 
.................... #else 
....................     static const char s_digits[] = "0123456789abcdef";          // FSfprintf table of conversion digits 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /************************************************************************************/ 
.................... /*                               Prototypes                                         */ 
.................... /************************************************************************************/ 
....................  
.................... DWORD ReadFAT (DISK *dsk, DWORD ccls); 
.................... DIRENTRY Cache_File_Entry( FILEOBJ fo, WORD * curEntry, BYTE ForceRead); 
.................... BYTE Fill_File_Object(FILEOBJ fo, WORD *fHandle); 
.................... DWORD Cluster2Sector(DISK * disk, DWORD cluster); 
.................... DIRENTRY LoadDirAttrib(FILEOBJ fo, WORD *fHandle); 
.................... #ifdef INCREMENTTIMESTAMP 
....................     void IncrementTimeStamp(DIRENTRY dir); 
.................... #elif defined USEREALTIMECLOCK 
....................     void CacheTime (void); 
.................... #endif 
....................  
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................     BYTE ReadByte( BYTE* pBuffer, WORD index ); 
....................     WORD ReadWord( BYTE* pBuffer, WORD index ); 
....................     DWORD ReadDWord( BYTE* pBuffer, WORD index ); 
.................... #endif 
....................  
.................... void FileObjectCopy(FILEOBJ foDest,FILEOBJ foSource); 
.................... FILE_DIR_NAME_TYPE ValidateChars(BYTE mode); 
.................... BYTE FormatFileName( const char* fileName, FILEOBJ fptr, BYTE mode); 
.................... CETYPE FILEfind( FILEOBJ foDest, FILEOBJ foCompareTo, BYTE cmd, BYTE mode); 
.................... CETYPE FILEopen (FILEOBJ fo, WORD *fHandle, char type); 
.................... #if defined(SUPPORT_LFN) 
.................... BOOL Alias_LFN_Object(FILEOBJ fo); 
.................... BYTE Fill_LFN_Object(FILEOBJ fo, LFN_ENTRY *lfno, WORD *fHandle); 
.................... #endif 
....................  
.................... // Write functions 
.................... #ifdef ALLOW_WRITES 
....................     BYTE Write_File_Entry( FILEOBJ fo, WORD * curEntry); 
....................     BYTE flushData (void); 
....................     CETYPE FILEerase( FILEOBJ fo, WORD *fHandle, BYTE EraseClusters); 
....................     BYTE FILEallocate_new_cluster( FILEOBJ fo, BYTE mode); 
....................     BYTE FAT_erase_cluster_chain (DWORD cluster, DISK * dsk); 
....................     DWORD FATfindEmptyCluster(FILEOBJ fo); 
....................     BYTE FindEmptyEntries(FILEOBJ fo, WORD *fHandle); 
....................     BYTE PopulateEntries(FILEOBJ fo, WORD *fHandle, BYTE mode); 
....................     CETYPE FILECreateHeadCluster( FILEOBJ fo, DWORD *cluster); 
....................     BYTE EraseCluster(DISK *disk, DWORD cluster); 
....................     CETYPE CreateFirstCluster(FILEOBJ fo); 
....................     DWORD WriteFAT (DISK *dsk, DWORD ccls, DWORD value, BYTE forceWrite); 
....................     CETYPE CreateFileEntry(FILEOBJ fo, WORD *fHandle, BYTE mode, BOOL createFirstCluster); 
.................... #endif 
....................  
.................... // Directory functions 
.................... #ifdef ALLOW_DIRS 
....................     BYTE GetPreviousEntry (FSFILE * fo); 
....................     BYTE FormatDirName (char * string,FILEOBJ fptr, BYTE mode); 
....................     int CreateDIR (char * path); 
....................     BYTE writeDotEntries (DISK * dsk, DWORD dotAddress, DWORD dotdotAddress); 
....................     int eraseDir (char * path); 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     #ifdef ALLOW_WRITES 
....................         int mkdirhelper (BYTE mode, char * ramptr, const rom char * romptr); 
....................         int rmdirhelper (BYTE mode, char * ramptr, const rom char * romptr, unsigned char rmsubdirs); 
....................     #endif 
.................... int chdirhelper (BYTE mode, char * ramptr, const rom char * romptr); 
.................... #else 
....................     #ifdef ALLOW_WRITES 
....................         int mkdirhelper (BYTE mode, char * ramptr, char * romptr); 
....................         int rmdirhelper (BYTE mode, char * ramptr, char * romptr, unsigned char rmsubdirs); 
....................     #endif 
....................     int chdirhelper (BYTE mode, char * ramptr, char * romptr); 
.................... #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................     #ifdef __18CXX 
....................         int FSvfprintf (auto FSFILE *handle, auto const rom char *formatString, auto va_list ap); 
....................     #else 
....................         int FSvfprintf (FSFILE *handle, const char *formatString, va_list ap); 
....................     #endif 
....................     int FSputc (char c, FSFILE * file); 
....................     unsigned char str_put_n_chars (FSFILE * handle, unsigned char n, char c); 
.................... #endif 
....................  
.................... BYTE DISKmount( DISK *dsk); 
.................... BYTE LoadMBR(DISK *dsk); 
.................... BYTE LoadBootSector(DISK *dsk); 
.................... DWORD GetFullClusterNumber(DIRENTRY entry); 
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     int FSInit(void) 
....................   Summary: 
....................     Function to initialize the device. 
....................   Conditions: 
....................     The physical device should be connected to the microcontroller. 
....................   Input: 
....................     None 
....................   Return Values: 
....................     TRUE -  Initialization successful 
....................     FALSE - Initialization unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function initializes the file system stack & the interfacing device. 
....................     Initializes the static or dynamic memory slots for holding file 
....................     structures. Initializes the device with the DISKmount function. Loads 
....................     MBR and boot sector information. Initializes the current working 
....................     directory to the root directory for the device if directory support 
....................     is enabled. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... int FSInit(void) 
*
021DC:  MOV     W5,[W15++]
.................... { 
....................     int fIndex; 
021DE:  CLR     FCC
.................... #ifndef FS_DYNAMIC_MEM 
....................     for( fIndex = 0; fIndex < FS_MAX_FILES_OPEN; fIndex++ ) 
021E0:  CLR     FCC
021E2:  MOV     FCC,W4
021E4:  CP      W4,#1
021E6:  BRA     GE,21F8
....................         gFileSlotOpen[fIndex] = TRUE; 
021E8:  MOV     #85B,W4
021EA:  MOV     FCC,W3
021EC:  ADD     W3,W4,W5
021EE:  MOV.B   #1,W0L
021F0:  MOV.B   W0L,[W5]
021F2:  INC     0FCC
021F4:  GOTO    21E2
.................... #else 
....................     #ifdef __18CXX 
....................         SRAMInitHeap(); 
....................     #endif 
.................... #endif 
....................  
....................     gBufferZeroed = FALSE; 
021F8:  CLR.B   8B0
....................     gNeedFATWrite = FALSE; 
021FA:  CLR.B   899
....................     gLastFATSectorRead = 0xFFFFFFFF; 
021FC:  SETM    8A4
021FE:  SETM    8A6
....................     gLastDataSectorRead = 0xFFFFFFFF; 
02200:  SETM    8AA
02202:  SETM    8AC
....................  
....................     MDD_InitIO(); 
02204:  CALL    EB2
....................  
....................     if(DISKmount(&gDiskData) == CE_GOOD) 
02208:  MOV     #D60,W5
0220A:  MOV     W5,FD2
0220C:  CALL    211A
02210:  CP0.B   W0L
02212:  BRA     NZ,22C4
....................     { 
....................     // Initialize the current working directory to the root 
.................... #ifdef ALLOW_DIRS 
....................         cwdptr->dsk = &gDiskData; 
02214:  MOV     95E,W4
02216:  ADD     W4,#0,W4
02218:  MOV     W4,W0
0221A:  MOV     W0,W5
0221C:  MOV.B   #60,W0L
0221E:  MOV.B   W0L,[W5]
02220:  MOV.B   #D,W0L
02222:  MOV.B   W0L,[W5+#1]
....................         cwdptr->sec = 0; 
02224:  MOV     #A,W0
02226:  ADD     95E,W0
02228:  MOV     W0,W5
0222A:  CLR.B   [W5]
0222C:  MOV.B   #0,W0L
0222E:  MOV.B   W0L,[W5+#1]
....................         cwdptr->pos = 0; 
02230:  MOV     #C,W0
02232:  ADD     95E,W0
02234:  MOV     W0,W5
02236:  CLR.B   [W5]
02238:  MOV.B   #0,W0L
0223A:  MOV.B   W0L,[W5+#1]
....................         cwdptr->seek = 0; 
0223C:  MOV     #E,W0
0223E:  ADD     95E,W0
02240:  MOV     W0,W5
02242:  CLR.B   [W5]
02244:  MOV.B   #0,W0L
02246:  MOV.B   W0L,[W5+#1]
02248:  MOV.B   #0,W0L
0224A:  MOV.B   W0L,[W5+#2]
0224C:  MOV.B   #0,W0L
0224E:  MOV.B   W0L,[W5+#3]
....................         cwdptr->size = 0; 
02250:  MOV     #12,W0
02252:  ADD     95E,W0
02254:  MOV     W0,W5
02256:  CLR.B   [W5]
02258:  MOV.B   #0,W0L
0225A:  MOV.B   W0L,[W5+#1]
0225C:  MOV.B   #0,W0L
0225E:  MOV.B   W0L,[W5+#2]
02260:  MOV.B   #0,W0L
02262:  MOV.B   W0L,[W5+#3]
....................         cwdptr->name[0] = '\\'; 
02264:  MOV     #1C,W0
02266:  ADD     95E,W0
02268:  MOV     W0,W5
0226A:  MOV.B   #5C,W0L
0226C:  MOV.B   W0L,[W5]
....................         for (fIndex = 1; fIndex < 11; fIndex++) 
0226E:  MOV     #1,W4
02270:  MOV     W4,FCC
02272:  MOV     FCC,W4
02274:  CP      W4,#B
02276:  BRA     GE,228A
....................         { 
....................             cwdptr->name[fIndex] = 0x20; 
02278:  MOV     #1C,W0
0227A:  ADD     FCC,W0
0227C:  MOV     95E,W4
0227E:  ADD     W0,W4,W5
02280:  MOV.B   #20,W0L
02282:  MOV.B   W0L,[W5]
02284:  INC     0FCC
02286:  GOTO    2272
....................         } 
....................         cwdptr->entry = 0; 
0228A:  MOV     #28,W0
0228C:  ADD     95E,W0
0228E:  MOV     W0,W5
02290:  CLR.B   [W5]
02292:  MOV.B   #0,W0L
02294:  MOV.B   W0L,[W5+#1]
....................         cwdptr->attributes = ATTR_DIRECTORY; 
02296:  MOV     #2C,W0
02298:  ADD     95E,W0
0229A:  MOV     W0,W5
0229C:  MOV.B   #10,W0L
0229E:  MOV.B   W0L,[W5]
022A0:  MOV.B   #0,W0L
022A2:  MOV.B   W0L,[W5+#1]
....................         // "FatRootDirClusterValue" indicates the root 
....................         cwdptr->dirclus = FatRootDirClusterValue; 
022A4:  MOV     #2E,W0
022A6:  ADD     95E,W0
022A8:  MOV     W0,W5
022AA:  MOV     #8B2,W4
022AC:  MOV     [W4++],[W5++]
022AE:  MOV     [W4++],[W5++]
....................         cwdptr->dirccls = FatRootDirClusterValue; 
022B0:  MOV     #32,W0
022B2:  ADD     95E,W0
022B4:  MOV     W0,W5
022B6:  MOV     #8B2,W4
022B8:  MOV     [W4++],[W5++]
022BA:  MOV     [W4++],[W5++]
....................    #if defined(SUPPORT_LFN) 
....................       // Initialize default values for LFN support 
....................         cwdptr->AsciiEncodingType = TRUE; 
....................         cwdptr->utf16LFNlength = 0x0000; 
....................    #endif 
.................... #endif 
....................  
....................         FSerrno = 0; 
022BC:  CLR.B   8B1
....................         return TRUE; 
022BE:  MOV     #1,W4
022C0:  MOV     W4,0
022C2:  BRA     22C6
....................     } 
....................  
....................     return FALSE; 
022C4:  CLR     0
022C6:  MOV     [--W15],W5
022C8:  RETURN  
.................... } 
....................  
....................  
.................... /******************************************************************************** 
....................   Function: 
....................     CETYPE FILEfind (FILEOBJ foDest, FILEOBJ foCompareTo, BYTE cmd, BYTE mode) 
....................   Summary 
....................     Finds a file on the device 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     foDest -       FSFILE object containing information of the file found 
....................     foCompareTo -  FSFILE object containing the name/attr of the file to be 
....................                    found 
....................     cmd - 
....................         -          LOOK_FOR_EMPTY_ENTRY: Search for empty entry. 
....................         -          LOOK_FOR_MATCHING_ENTRY: Search for matching entry. 
....................     mode - 
....................          -         0: Match file exactly with default attributes. 
....................          -         1: Match file to user-specified attributes. 
....................   Return Values: 
....................     CE_GOOD -            File found. 
....................     CE_FILE_NOT_FOUND -  File not found. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The FILEfind function will sequentially cache directory entries within 
....................     the current working directory into the foDest FSFILE object.  If the cmd 
....................     parameter is specified as LOOK_FOR_EMPTY_ENTRY the search will continue 
....................     until an empty directory entry is found. If the cmd parameter is specified 
....................     as LOOK_FOR_MATCHING_ENTRY these entries will be compared to the foCompareTo 
....................     object until a match is found or there are no more entries in the current 
....................     working directory. If the mode is specified a '0' the attributes of the FSFILE 
....................     entries are irrelevant. If the mode is specified as '1' the attributes of the 
....................     foDest entry must match the attributes specified in the foCompareTo file and 
....................     partial string search characters may bypass portions of the comparison. 
....................   Remarks: 
....................     None 
....................   ********************************************************************************/ 
....................  
.................... CETYPE FILEfind( FILEOBJ foDest, FILEOBJ foCompareTo, BYTE cmd, BYTE mode) 
*
036BE:  MOV     W5,[W15++]
*
036C8:  MOV     [W0],[W15++]
036CA:  POP     1066
036CC:  MOV.B   #B,W0L
036CE:  MOV.B   W0L,1068
.................... { 
....................     WORD   attrib, compareAttrib; 
*
036C0:  CLR     1062
036C2:  CLR     1064
036C4:  MOV     #28,W0
036C6:  ADD     105C,W0
....................     WORD   fHandle = foDest->entry;                  // current entry counter 
....................     CETYPE   statusB = CE_FILE_NOT_FOUND; 
....................     BYTE   character,test,state,index; 
*
036D0:  CLR.B   1069
036D2:  CLR.B   106A
036D4:  CLR.B   106B
036D6:  CLR.B   106C
....................  
....................    #if defined(SUPPORT_LFN) 
....................  
....................     LFN_ENTRY lfnObject;   // Long File Name Object 
....................    unsigned char *dst = (unsigned char *)&fileFoundString[0]; 
....................    unsigned short int *templfnPtr = (unsigned short int *)foCompareTo -> utf16LFNptr; 
....................    UINT16_VAL tempShift; 
....................    short int   fileCompareLfnIndex,fileFoundLfnIndex = 0,fileFoundMaxLfnIndex = 0,lfnCountIndex,fileFoundLength = 0; 
....................    BOOL  lfnFirstCheck = FALSE,foundSFN,foundLFN,fileFoundDotPosition = FALSE,fileCompareDotPosition; 
....................    BYTE  lfnCompareMaxSequenceNum = 0,lfnFoundMaxSequenceNum,reminder = 0; 
....................    char  tempDst[13]; 
....................    fileNameLength = foCompareTo->utf16LFNlength; 
....................  
....................    // If 'fileNameLength' is non zero then it means that file name is of LFN format. 
....................    // If 'fileNameLength' is zero then it means that file name is of 8.3 format 
....................    if(fileNameLength) 
....................    { 
....................       // Find out the number of root entries for the given LFN 
....................       reminder = fileNameLength % MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................       index = fileNameLength/MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................       if(reminder || (fileNameLength < MAX_UTF16_CHARS_IN_LFN_ENTRY)) 
....................       { 
....................          index++; 
....................       } 
....................  
....................       // The maximum sequence number of the LFN 
....................       lfnCompareMaxSequenceNum = index; 
....................    } 
....................    #endif 
....................  
....................                                               #ifdef __DEBUG_UART   
....................                                                 PrintROMASCIIStringUART("FILEfind foCompareTo="); 
....................                                                 PrintRAMBytesUART(((unsigned char*)foCompareTo->name), 13); 
....................                                                #endif  
....................  
....................     // reset the cluster 
....................     foDest->dirccls = foDest->dirclus; 
036D8:  MOV     #32,W0
036DA:  ADD     105C,W0
036DC:  MOV     W0,W5
036DE:  MOV     #2E,W0
036E0:  ADD     105C,W0
036E2:  MOV     [W0++],[W5++]
036E4:  MOV     [W0++],[W5++]
....................    // Attribute to be compared as per application layer request 
....................     compareAttrib = 0xFFFF ^ foCompareTo->attributes; 
036E6:  MOV     #2C,W0
036E8:  ADD     105E,W0
036EA:  MOV     W0,W4
036EC:  MOV     [W4],W0
036EE:  MOV     W0,W4
036F0:  MOV     #FFFF,W0
036F2:  XOR     W0,W4,W0
036F4:  MOV     W0,1064
....................  
....................     if (fHandle == 0) 
036F6:  CP0     1066
036F8:  BRA     NZ,3718
....................     { 
....................         if (Cache_File_Entry(foDest, &fHandle, TRUE) == NULL) 
036FA:  MOV.B   #1,W0L
036FC:  MOV.B   W0L,1086
036FE:  PUSH    105C
03700:  POP     1082
03702:  MOV     #1066,W4
03704:  MOV     W4,1084
03706:  CALL    31E4
0370A:  MOV     W0,W5
0370C:  CP0     W5
0370E:  BRA     NZ,3714
....................         { 
....................             statusB = CE_BADCACHEREAD; 
03710:  MOV.B   #1B,W0L
03712:  MOV.B   W0L,1068
....................         } 
....................     } 
03714:  GOTO    373A
....................     else 
....................     { 
....................       // Maximum 16 entries possible 
....................         if ((fHandle & MASK_MAX_FILE_ENTRY_LIMIT_BITS) != 0) 
03718:  MOV     1066,W0
0371A:  AND     W0,#F,W5
0371C:  CP0     W5
0371E:  BRA     Z,373A
....................         { 
....................             if (Cache_File_Entry (foDest, &fHandle, TRUE) == NULL) 
03720:  MOV.B   #1,W0L
03722:  MOV.B   W0L,1086
03724:  PUSH    105C
03726:  POP     1082
03728:  MOV     #1066,W4
0372A:  MOV     W4,1084
0372C:  CALL    31E4
03730:  MOV     W0,W5
03732:  CP0     W5
03734:  BRA     NZ,373A
....................             { 
....................                 statusB = CE_BADCACHEREAD; 
03736:  MOV.B   #1B,W0L
03738:  MOV.B   W0L,1068
....................             } 
....................         } 
....................     } 
....................  
....................     if (statusB != CE_BADCACHEREAD) 
0373A:  MOV     1068,W4
0373C:  CP.B    W4L,#1B
0373E:  BRA     Z,395C
....................     { 
....................         // Loop until you reach the end or find the file 
....................         while(1) 
....................         { 
....................             if(statusB != CE_GOOD) //First time entry always here 
03740:  CP0.B   1068
03742:  BRA     Z,3762
....................             { 
....................             #if defined(SUPPORT_LFN) 
....................                foundSFN = FALSE; 
....................                foundLFN = FALSE; 
....................  
....................                    state = Fill_LFN_Object(foDest,&lfnObject,&fHandle); 
....................             #else 
....................                    state = Fill_File_Object(foDest, &fHandle); 
03744:  PUSH    105C
03746:  POP     1072
03748:  MOV     #1066,W4
0374A:  MOV     W4,1074
0374C:  CALL    34D8
03750:  MOV.B   W0L,106B
....................             #endif 
....................  
....................                 if(state == NO_MORE) // Reached the end of available files. Comparision over and file not found so quit. 
03752:  MOV     106A,W4
03754:  LSR     W4,#8,W4
03756:  CP.B    W4L,#2
03758:  BRA     NZ,375E
....................                 { 
....................                     break; 
0375A:  GOTO    395C
....................                 } 
....................             } 
0375E:  GOTO    3766
....................             else // statusB == CE_GOOD then exit 
....................             { 
....................                 break; // Code below intializes"statusB = CE_GOOD;" so, if no problem in the filled file, Exit the while loop. 
03762:  GOTO    395C
....................             } 
....................  
....................             if(state == FOUND) // Validate the correct matching of filled file data with the required(to be found) one. 
03766:  CP0.B   106B
03768:  BRA     NZ,3950
....................             { 
....................             #if defined(SUPPORT_LFN) 
....................  
....................             if(lfnObject.LFN_Attribute != ATTR_LONG_NAME) 
....................             { 
....................                lfnFirstCheck = FALSE; 
....................  
....................                *dst = lfnObject.LFN_SequenceNo; 
....................                for(index = 0;index < 10;index++) 
....................                   dst[index + 1] = lfnObject.LFN_Part1[index]; 
....................                foundSFN = TRUE; 
....................             } 
....................             else 
....................             { 
....................                if(lfnObject.LFN_SequenceNo & 0x40) 
....................                { 
....................                   lfnFoundMaxSequenceNum = lfnObject.LFN_SequenceNo & 0x1F; 
....................  
....................                   if((mode == 0x00) && ((fileNameLength && (lfnFoundMaxSequenceNum != lfnCompareMaxSequenceNum)) || 
....................                      (!fileNameLength && (lfnFoundMaxSequenceNum != 0x01)))) 
....................                   { 
.................... //                     fHandle = fHandle + lfnFoundMaxSequenceNum + 1; 
....................                      fHandle++; 
....................                      continue; 
....................                   } 
....................  
....................                   fileFoundLfnIndex = (lfnObject.LFN_SequenceNo & 0xBF) * MAX_UTF16_CHARS_IN_LFN_ENTRY - 1; 
....................                   fileCompareLfnIndex = fileFoundLfnIndex; 
....................  
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part3[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part3[0]; 
....................  
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[5]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[4]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[3]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[2]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[0]; 
....................  
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[8]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[9]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[6]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[7]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[4]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[5]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[2]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[3]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[0]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................  
....................  
....................                   fileFoundLength = fileCompareLfnIndex + 1; 
....................                   for(index = 1;index <= MAX_UTF16_CHARS_IN_LFN_ENTRY;index++) 
....................                   { 
....................                      if(fileFoundString[fileFoundLfnIndex + index] == 0x0000) 
....................                         fileFoundLength = fileFoundLfnIndex + index; 
....................                   } 
....................  
....................                   if(mode == 0x00) 
....................                   { 
....................                      if((fileNameLength != fileFoundLength) && fileNameLength) 
....................                      { 
.................... //                        fHandle = fHandle + lfnFoundMaxSequenceNum + 1; 
....................                         fHandle++; 
....................                         continue; 
....................                      } 
....................                   } 
....................  
....................                   fileFoundMaxLfnIndex = fileFoundLength - 1; 
....................                   lfnFirstCheck = TRUE; 
....................                } 
....................                else if(lfnFirstCheck == TRUE) 
....................                { 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part3[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part3[0]; 
....................  
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[5]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[4]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[3]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[2]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[0]; 
....................  
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[8]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[9]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[6]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[7]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[4]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[5]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[2]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[3]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[0]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                } 
....................                else 
....................                   { 
....................                      fHandle++; 
....................                   continue; 
....................                } 
....................  
....................                   if(fileFoundLfnIndex > 0) 
....................                   { 
....................                      fHandle++; 
....................                   continue; 
....................                } 
....................  
....................                foundLFN = TRUE; 
....................             } 
....................  
....................             lfnFirstCheck = FALSE; 
....................             statusB = CE_GOOD; 
....................                  switch (mode) 
....................                  { 
....................                      case 0: 
....................  
....................                      // Copy the contents of any SFN found to temporary string 
....................                      // for future comparision tests 
....................                      for(index = 0;index < FILE_NAME_SIZE_8P3;index++) 
....................                         tempDst[index] = dst[index]; 
....................  
....................                      // Try to deduce the original name from the found SFN 
....................                      if(dst[8] != ' ') 
....................                      { 
....................                         for(index = 0;index < 8;index++) 
....................                         { 
....................                            if(dst[index] == ' ') 
....................                               break; 
....................                         } 
....................                         tempDst[index++] = '.'; 
....................                         tempDst[index++] = dst[8]; 
....................  
....................                         if(dst[9] != ' ') 
....................                            tempDst[index++] = dst[9]; 
....................                         else 
....................                            tempDst[index++] = 0x00; 
....................  
....................                         if(dst[10] != ' ') 
....................                            tempDst[index++] = dst[10]; 
....................                         else 
....................                            tempDst[index++] = 0x00; 
....................                      } 
....................                            else 
....................                      { 
....................                               for(index = 0;index < 8;index++) 
....................                         { 
....................                            if(tempDst[index] == ' ') 
....................                               break; 
....................                         } 
....................                      } 
....................  
....................                      // Terminate the string using the NULL value 
....................                      tempDst[index] = 0x00; 
....................  
....................                             if(fileNameLength) 
....................                             { 
....................                               if(foundLFN) 
....................                               { 
....................                                  // see if we are a volume id or hidden, ignore 
....................                                  // search for one. if status = TRUE we found one 
....................                                  for(fileCompareLfnIndex = 0;fileCompareLfnIndex < fileNameLength;fileCompareLfnIndex++) 
....................                                  { 
....................                                 if(foCompareTo -> AsciiEncodingType) 
....................                                 { 
....................                                            // get the source character 
....................                                            character = (BYTE)templfnPtr[fileCompareLfnIndex]; 
....................                                            // get the destination character 
....................                                            test = (BYTE)fileFoundString[fileCompareLfnIndex]; 
....................                                            if((fileFoundString[fileCompareLfnIndex] > 0xFF) || (tolower(character) != tolower(test))) 
....................                                            { 
....................                                              statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                              break; 
....................                                            } 
....................                                 } 
....................                                 else 
....................                                 { 
....................                                    if(templfnPtr[fileCompareLfnIndex] != fileFoundString[fileCompareLfnIndex]) 
....................                                    { 
....................                                            statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                                    } 
....................                                 } 
....................                                  }// for loop 
....................                         } 
....................                         else if(foundSFN && foCompareTo -> AsciiEncodingType) 
....................                         { 
....................                                  if(strlen(tempDst) != fileNameLength) 
....................                                     statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                  else 
....................                                  { 
....................                                     for(fileCompareLfnIndex = 0;fileCompareLfnIndex < fileNameLength;fileCompareLfnIndex++) 
....................                                     { 
....................                                        // get the source character 
....................                                        character = (BYTE)templfnPtr[fileCompareLfnIndex]; 
....................                                        // get the destination character 
....................                                        test = tempDst[fileCompareLfnIndex]; 
....................                                        if(tolower(character) != tolower(test)) 
....................                                        { 
....................                                           statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                           break; 
....................                                        } 
....................                                     }// for loop 
....................                            } 
....................                         } 
....................                         else 
....................                         { 
....................                                  statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                         } 
....................                      } 
....................                      else 
....................                             { 
....................                              if(foundLFN) 
....................                              { 
....................                                  if(strlen(tempDst) != fileFoundLength) 
....................                                     statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                  else 
....................                                  { 
....................                                     for(fileCompareLfnIndex = 0;fileCompareLfnIndex < fileFoundLength;fileCompareLfnIndex++) 
....................                                     { 
....................                                        // get the source character 
....................                                        character = (BYTE)fileFoundString[fileCompareLfnIndex]; 
....................                                        // get the destination character 
....................                                        test = tempDst[fileCompareLfnIndex]; 
....................                                        if((fileFoundString[fileCompareLfnIndex] > 0xFF) || (tolower(character) != tolower(test))) 
....................                                        { 
....................                                           statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                           break; 
....................                                        } 
....................                                     }// for loop 
....................                            } 
....................                              } 
....................                              else 
....................                              { 
....................                                  // search for one. if status = TRUE we found one 
....................                                  for(index = 0; index < DIR_NAMECOMP; index++) 
....................                                  { 
....................                                      // get the source character 
....................                                      character = dst[index]; 
....................                                      // get the destination character 
....................                                      test = foCompareTo->name[index]; 
....................                                      if(tolower(character) != tolower(test)) 
....................                                      { 
....................                                          statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                          break; 
....................                                      } 
....................                                  }// for loop 
....................                         } 
....................                      } 
....................                            break; 
....................  
....................                      case 1: 
....................                      if(fileNameLength) 
....................                             { 
....................                         fileFoundDotPosition = FALSE; 
....................                         if(foundLFN) 
....................                         { 
....................                            lfnCountIndex = fileFoundMaxLfnIndex; 
....................                            while(lfnCountIndex > 0) 
....................                            { 
....................                               if(fileFoundString[lfnCountIndex] == '.') 
....................                               { 
....................                                  fileFoundDotPosition = TRUE; 
....................                                  lfnCountIndex--; 
....................                                  break; 
....................                               } 
....................                               lfnCountIndex--; 
....................                            } 
....................  
....................                            if(fileFoundDotPosition == FALSE) 
....................                               lfnCountIndex = fileFoundMaxLfnIndex; 
....................                         } 
....................                         else 
....................                         { 
....................                            if(dst[DIR_NAMESIZE] != ' ') 
....................                               fileFoundDotPosition = TRUE; 
....................                            lfnCountIndex = DIR_NAMESIZE - 1; 
....................                         } 
....................  
....................                         fileFoundLfnIndex = fileNameLength - 1; 
....................                         fileCompareDotPosition = FALSE; 
....................                         while(fileFoundLfnIndex > 0) 
....................                         { 
....................                            if(templfnPtr[fileFoundLfnIndex] == '.') 
....................                            { 
....................                               fileCompareDotPosition = TRUE; 
....................                               fileFoundLfnIndex--; 
....................                               break; 
....................                            } 
....................                            fileFoundLfnIndex--; 
....................                         } 
....................                         if(fileCompareDotPosition == FALSE) 
....................                            fileFoundLfnIndex = fileNameLength - 1; 
....................  
....................                                // Check for attribute match 
....................                                for(fileCompareLfnIndex = 0;;) 
....................                                { 
....................                                   if (templfnPtr[fileCompareLfnIndex] == '*') 
....................                                      break; 
....................  
....................                            if(fileCompareLfnIndex > lfnCountIndex) 
....................                                    { 
....................                                       statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                                    } 
....................  
....................                                   if (templfnPtr[fileCompareLfnIndex] != '?') 
....................                                   { 
....................                                 if(foCompareTo -> AsciiEncodingType) 
....................                                 { 
....................                                          // get the source character 
....................                                          character = (BYTE)templfnPtr[fileCompareLfnIndex]; 
....................                                          // get the destination character 
....................                                          if(foundLFN) 
....................                                             test = (BYTE)fileFoundString[fileCompareLfnIndex]; 
....................                                  else 
....................                                             test = dst[fileCompareLfnIndex]; 
....................  
....................                                  if((foundLFN && (fileFoundString[fileCompareLfnIndex] > 0xFF)) || 
....................                                             (tolower(character) != tolower(test))) 
....................                                          { 
....................                                             statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                             break; 
....................                                          } 
....................                                 } 
....................                                 else 
....................                                 { 
....................                                    if((templfnPtr[fileCompareLfnIndex] != fileFoundString[fileCompareLfnIndex]) || foundSFN) 
....................                                    { 
....................                                             statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                                    } 
....................                                 } 
....................                                   } 
....................  
....................                                    fileCompareLfnIndex++; 
....................                                    if(fileCompareLfnIndex > fileFoundLfnIndex) 
....................                                     { 
....................                                         if(fileCompareLfnIndex <= lfnCountIndex) 
....................                                         { 
....................                                          statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                               } 
....................                                         break; 
....................                            } 
....................                                }// for loop 
....................  
....................                         if(fileCompareDotPosition == FALSE) 
....................                         { 
....................                            if(fileFoundDotPosition == TRUE) 
....................                                    { 
....................                                       statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                    } 
....................                            break; 
....................                         } 
....................                         else 
....................                         { 
....................                            if(fileFoundDotPosition == FALSE) 
....................                                    { 
....................                                       statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                                    } 
....................  
....................                            if(foundLFN) 
....................                               lfnCountIndex = lfnCountIndex + 2; 
....................                            else 
....................                               lfnCountIndex = DIR_NAMESIZE; 
....................                         } 
....................  
....................                                // Check for attribute match 
....................                                for(fileCompareLfnIndex = fileFoundLfnIndex + 2;;) 
....................                                { 
....................                                   if (templfnPtr[fileCompareLfnIndex] == '*') 
....................                                      break; 
....................  
....................                            if((foundLFN && (lfnCountIndex > fileFoundMaxLfnIndex)) || (foundSFN && (lfnCountIndex == 11))) 
....................                            { 
....................                                       statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                            } 
....................  
....................                                   if (templfnPtr[fileCompareLfnIndex] != '?') 
....................                                   { 
....................                                 if(foCompareTo -> AsciiEncodingType) 
....................                                 { 
....................                                           // get the source character 
....................                                           character = (BYTE)templfnPtr[fileCompareLfnIndex]; 
....................                                           // get the destination character 
....................                                          if(foundLFN) 
....................                                             test = (BYTE)fileFoundString[lfnCountIndex]; 
....................                                  else 
....................                                             test = dst[lfnCountIndex]; 
....................                                  if((foundLFN && (fileFoundString[lfnCountIndex] > 0xFF)) || 
....................                                             (tolower(character) != tolower(test))) 
....................                                          { 
....................                                             statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                             break; 
....................                                          } 
....................                                 } 
....................                                 else 
....................                                 { 
....................                                    if((templfnPtr[fileCompareLfnIndex] != fileFoundString[lfnCountIndex]) || foundSFN) 
....................                                    { 
....................                                             statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                                    } 
....................                                 } 
....................                                   } 
....................                                    lfnCountIndex++; 
....................                                    fileCompareLfnIndex++; 
....................                                    if(fileCompareLfnIndex == fileNameLength) 
....................                                     { 
....................                                         if((foundLFN && (lfnCountIndex <= fileFoundMaxLfnIndex)) || (foundSFN && (lfnCountIndex < 11) && (dst[lfnCountIndex] != ' '))) 
....................                                         { 
....................                                          statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                               } 
....................                                         break; 
....................                            } 
....................                                }// for loop 
....................                      } 
....................                      else 
....................                      { 
....................                              /* We got something */ 
....................                                if(foundLFN) 
....................                                { 
....................                            fileCompareLfnIndex = fileFoundMaxLfnIndex; 
....................                            fileFoundDotPosition = FALSE; 
....................                            while(fileCompareLfnIndex > 0) 
....................                            { 
....................                               if(fileFoundString[fileCompareLfnIndex] == '.') 
....................                               { 
....................                                  fileFoundDotPosition = TRUE; 
....................                                  fileCompareLfnIndex--; 
....................                                  break; 
....................                               } 
....................                               fileCompareLfnIndex--; 
....................                            } 
....................  
....................                            if(fileFoundDotPosition == FALSE) 
....................                               fileCompareLfnIndex = fileFoundMaxLfnIndex; 
....................                         } 
....................                         else 
....................                            fileCompareLfnIndex = DIR_NAMESIZE - 1;   // Short File name last char position 
....................  
....................                                 if (foCompareTo->name[0] != '*')   //If "*" is passed for comparion as 1st char then don't proceed. Go back, file alreay found. 
....................                                 { 
....................                                     for (index = 0;;) 
....................                                     { 
....................                                         if(foundLFN) 
....................                                         { 
....................                                            if((fileFoundString[index] > 0xFF) || (index > fileCompareLfnIndex)) 
....................                                            { 
....................                                                statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                                break; 
....................                                  } 
....................                               } 
....................  
....................                                         // Get the source character 
....................                                      if(foundLFN) 
....................                                         character = (BYTE)fileFoundString[index]; 
....................                               else 
....................                                         character = dst[index]; 
....................  
....................                                         // Get the destination character 
....................                                         test = foCompareTo->name[index]; 
....................                                         if (test == '*') 
....................                                             break; 
....................                                         if (test != '?') 
....................                                         { 
....................                                             if(tolower(character) != tolower(test)) 
....................                                             { 
....................                                                 statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                                 break; 
....................                                             } 
....................                                         } 
....................  
....................                                       index++; 
....................                                       if(index == DIR_NAMESIZE) 
....................                                        { 
....................                                            if(foundLFN && (index <= fileCompareLfnIndex)) 
....................                                            { 
....................                                                statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                  } 
....................                                             break; 
....................                               } 
....................                                     } 
....................                                 } 
....................  
....................                                 // Before calling this "FILEfind" fn, "formatfilename" must be called. Hence, extn always starts from position "8". 
....................                                 if ((foCompareTo->name[8] != '*') && (statusB == CE_GOOD)) 
....................                                 { 
....................                                     if(foundLFN) 
....................                                     { 
....................                               if(foCompareTo->name[8] == ' ') 
....................                               { 
....................                                  if(fileFoundDotPosition == TRUE) 
....................                                            { 
....................                                                statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                  } 
....................                                  break; 
....................                               } 
....................                               else 
....................                               { 
....................                                  if(fileFoundDotPosition == FALSE) 
....................                                  { 
....................                                                statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                     break; 
....................                                  } 
....................                               } 
....................                               fileCompareLfnIndex = fileCompareLfnIndex + 2; 
....................                            } 
....................                            else 
....................                               fileCompareLfnIndex = DIR_NAMESIZE; 
....................  
....................                                     for (index = 8;;) 
....................                                     { 
....................                                         if(foundLFN) 
....................                                         { 
....................                                            if((fileFoundString[fileCompareLfnIndex] > 0xFF) || (fileCompareLfnIndex > fileFoundMaxLfnIndex)) 
....................                                            { 
....................                                                statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                                break; 
....................                                  } 
....................                               } 
....................                                         // Get the destination character 
....................                                         test = foCompareTo->name[index]; 
....................                                         // Get the source character 
....................                                      if(foundLFN) 
....................                                         character = (BYTE)fileFoundString[fileCompareLfnIndex++]; 
....................                               else 
....................                                         character = dst[fileCompareLfnIndex++]; 
....................  
....................                                         if (test == '*') 
....................                                             break; 
....................                                         if (test != '?') 
....................                                         { 
....................                                             if(tolower(character) != tolower(test)) 
....................                                             { 
....................                                                 statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                                 break; 
....................                                             } 
....................                                         } 
....................  
....................                               index++; 
....................                               if(index == DIR_NAMECOMP) 
....................                               { 
....................                                  if(foundLFN && (fileCompareLfnIndex <= fileFoundMaxLfnIndex)) 
....................                                     statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                  break; 
....................                               } 
....................                                     } 
....................                                 } 
....................                      } 
....................                             break; 
....................               } 
....................  
....................             // If the comparision of each character in LFN is completed 
....................             if(statusB == CE_GOOD) 
....................             { 
....................                if(foundLFN) 
....................                   fHandle++; 
....................  
....................                    state = Fill_File_Object(foDest, &fHandle); 
....................  
....................                if(foundLFN) 
....................                   fHandle--; 
....................  
....................                      /* We got something get the attributes */ 
....................                      attrib = foDest->attributes; 
....................  
....................                      attrib &= ATTR_MASK; 
....................  
....................                      switch (mode) 
....................                      { 
....................                          case 0: 
....................                              // see if we are a volume id or hidden, ignore 
....................                              if(attrib == ATTR_VOLUME) 
....................                                  statusB = CE_FILE_NOT_FOUND; 
....................                              break; 
....................  
....................                          case 1: 
....................                              // Check for attribute match 
....................                              if ((attrib & compareAttrib) != 0) 
....................                                  statusB = CE_FILE_NOT_FOUND; // Indicate the already filled file data is correct and go back 
....................                              if(foundLFN) 
....................                                 foDest->utf16LFNlength = fileFoundLength; 
....................                              else 
....................                         foDest->utf16LFNlength = 0; 
....................                              break; 
....................                      } 
....................             } 
....................             #else 
....................             { 
....................                       /* We got something */ 
....................                       // get the attributes 
....................                       attrib = foDest->attributes; 
0376A:  MOV     #2C,W0
0376C:  ADD     105C,W0
0376E:  MOV     [W0],[W15++]
03770:  POP     1062
....................  
....................                       attrib &= ATTR_MASK; 
03772:  MOV     1062,W4
03774:  AND     #3F,W4
03776:  MOV     W4,1062
....................                       switch (mode) 
03778:  MOV.B   1061,W0L
0377A:  CLR.B   1
0377C:  XOR     #0,W0
0377E:  BRA     Z,3786
03780:  XOR     #1,W0
03782:  BRA     Z,380C
03784:  BRA     394C
....................                       { 
....................                           case 0: 
....................                               // see if we are a volume id or hidden, ignore 
....................                               if(attrib != ATTR_VOLUME) 
03786:  MOV     1062,W4
03788:  CP      W4,#8
0378A:  BRA     Z,3808
....................                               { 
....................                                   statusB = CE_GOOD; 
0378C:  CLR.B   1068
....................                                   character = (BYTE)'m'; // random value 
0378E:  MOV.B   #6D,W0L
03790:  MOV.B   W0L,1069
....................  
....................                                   // search for one. if status = TRUE we found one 
....................                                   for(index = 0; index < DIR_NAMECOMP; index++) 
03792:  CLR.B   106C
03794:  MOV     106C,W4
03796:  CP.B    W4L,#B
03798:  BRA     C,3808
....................                                   { 
....................                                       // get the source character 
....................                                       character = foDest->name[index]; 
0379A:  MOV     #1C,W0
0379C:  ADD.B   106C,W0L
0379E:  ZE      W0,W0
037A0:  CLR.B   1
037A2:  MOV     105C,W4
037A4:  ADD     W0,W4,W0
037A6:  MOV     W0,[W15++]
037A8:  MOV.B   [W0],W0L
037AA:  MOV.B   W0L,1069
037AC:  MOV     [--W15],W0
....................                                       // get the destination character 
....................                                       test = foCompareTo->name[index]; 
037AE:  MOV     #1C,W0
037B0:  ADD.B   106C,W0L
037B2:  ZE      W0,W0
037B4:  CLR.B   1
037B6:  MOV     105E,W4
037B8:  ADD     W0,W4,W0
037BA:  MOV     106A,W4
037BC:  MOV.B   [W0+#0],W4L
037BE:  MOV     W4,106A
....................                                       if(tolower(character) != tolower(test)) 
037C0:  MOV     1068,W4
037C2:  LSR     W4,#8,W4
037C4:  MOV     #41,W3
037C6:  CP.B    W3L,W4L
037C8:  BRA     GTU,37DA
037CA:  MOV     1068,W4
037CC:  LSR     W4,#8,W4
037CE:  MOV     #5A,W3
037D0:  CP.B    W3L,W4L
037D2:  BRA     NC,37DA
037D4:  MOV.B   1069,W0L
037D6:  IOR.B   #20,W0L
037D8:  BRA     37DC
037DA:  MOV.B   1069,W0L
037DC:  MOV.B   W0L,W5L
037DE:  MOV     106A,W4
037E0:  MOV     #41,W3
037E2:  CP.B    W3L,W4L
037E4:  BRA     GTU,37F4
037E6:  MOV     106A,W4
037E8:  MOV     #5A,W3
037EA:  CP.B    W3L,W4L
037EC:  BRA     NC,37F4
037EE:  MOV.B   106A,W0L
037F0:  IOR.B   #20,W0L
037F2:  BRA     37F6
037F4:  MOV.B   106A,W0L
037F6:  CP.B    W5L,W0L
037F8:  BRA     Z,3802
....................                                       { 
....................                                           statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
037FA:  MOV.B   #B,W0L
037FC:  MOV.B   W0L,1068
....................                                           break; 
037FE:  GOTO    3808
....................                                       } 
03802:  INC.B   106C
03804:  GOTO    3794
....................                                   }// for loop 
....................                               } // not dir nor vol 
....................                               break; 
03808:  GOTO    394C
....................  
....................                           case 1: 
....................                               // Check for attribute match 
....................                               if (((attrib & compareAttrib) == 0) && (attrib != ATTR_LONG_NAME)) 
0380C:  MOV     1062,W0
0380E:  AND     1064,W0
03810:  MOV     W0,W5
03812:  CP0     W5
03814:  BRA     NZ,3948
03816:  MOV     1062,W4
03818:  CP      W4,#F
0381A:  BRA     Z,3948
....................                               { 
....................                                               #ifdef __DEBUG_UART   
....................                                                 PrintROMASCIIStringUART(" CHK_foCompareTo="); 
....................                                                 PrintRAMBytesUART(((unsigned char*)foCompareTo->name), 13); 
....................                                                 PrintROMASCIIStringUART(" foGot="); 
....................                                                 PrintRAMBytesUART(((unsigned char*)foDest->name), 13); 
....................                                                #endif   
....................                                                 
....................                                   statusB = CE_GOOD;                 // Indicate the already filled file data is correct and go back 
0381C:  CLR.B   1068
....................                                   character = (BYTE)'m';             // random value 
0381E:  MOV.B   #6D,W0L
03820:  MOV.B   W0L,1069
....................                                   if (foCompareTo->name[0] != '*')   //If "*" is passed for comparion as 1st char then don't proceed. Go back, file alreay found. 
03822:  MOV     #1C,W0
03824:  ADD     105E,W0
03826:  MOV.B   [W0],W4L
03828:  XOR.B   #2A,W4L
0382A:  BRA     Z,38B2
....................                                   { 
....................                                       for (index = 0; index < DIR_NAMESIZE; index++) 
0382C:  CLR.B   106C
0382E:  MOV     106C,W4
03830:  CP.B    W4L,#8
03832:  BRA     C,38B2
....................                                       { 
....................                                           // Get the source character 
....................                                           character = foDest->name[index]; 
03834:  MOV     #1C,W0
03836:  ADD.B   106C,W0L
03838:  ZE      W0,W0
0383A:  CLR.B   1
0383C:  MOV     105C,W4
0383E:  ADD     W0,W4,W0
03840:  MOV     W0,[W15++]
03842:  MOV.B   [W0],W0L
03844:  MOV.B   W0L,1069
03846:  MOV     [--W15],W0
....................                                           // Get the destination character 
....................                                           test = foCompareTo->name[index]; 
03848:  MOV     #1C,W0
0384A:  ADD.B   106C,W0L
0384C:  ZE      W0,W0
0384E:  CLR.B   1
03850:  MOV     105E,W4
03852:  ADD     W0,W4,W0
03854:  MOV     106A,W4
03856:  MOV.B   [W0+#0],W4L
03858:  MOV     W4,106A
....................                                           if (test == '*') 
0385A:  MOV     106A,W4
0385C:  XOR.B   #2A,W4L
0385E:  BRA     NZ,3864
....................                                               break; 
03860:  GOTO    38B2
....................                                           if (test != '?') 
03864:  MOV     106A,W4
03866:  XOR.B   #3F,W4L
03868:  BRA     Z,38AC
....................                                           { 
....................                                               if(tolower(character) != tolower(test)) 
0386A:  MOV     1068,W4
0386C:  LSR     W4,#8,W4
0386E:  MOV     #41,W3
03870:  CP.B    W3L,W4L
03872:  BRA     GTU,3884
03874:  MOV     1068,W4
03876:  LSR     W4,#8,W4
03878:  MOV     #5A,W3
0387A:  CP.B    W3L,W4L
0387C:  BRA     NC,3884
0387E:  MOV.B   1069,W0L
03880:  IOR.B   #20,W0L
03882:  BRA     3886
03884:  MOV.B   1069,W0L
03886:  MOV.B   W0L,W5L
03888:  MOV     106A,W4
0388A:  MOV     #41,W3
0388C:  CP.B    W3L,W4L
0388E:  BRA     GTU,389E
03890:  MOV     106A,W4
03892:  MOV     #5A,W3
03894:  CP.B    W3L,W4L
03896:  BRA     NC,389E
03898:  MOV.B   106A,W0L
0389A:  IOR.B   #20,W0L
0389C:  BRA     38A0
0389E:  MOV.B   106A,W0L
038A0:  CP.B    W5L,W0L
038A2:  BRA     Z,38AC
....................                                               { 
....................                                               #ifdef __DEBUG_UART   
....................                                                 PrintROMASCIIStringUART(" !NAMEMATCH!"); 
....................                                                #endif 
....................                                                   statusB = CE_FILE_NOT_FOUND; // it's not a match 
038A4:  MOV.B   #B,W0L
038A6:  MOV.B   W0L,1068
....................                                                   break; 
038A8:  GOTO    38B2
....................                                               } 
....................                                           } 
038AC:  INC.B   106C
038AE:  GOTO    382E
....................                                       } 
....................                                   } 
....................  
....................                                   // Before calling this "FILEfind" fn, "formatfilename" must be called. Hence, extn always starts from position "8".                                  
....................                                   if ((foCompareTo->name[8] != '*') && (statusB == CE_GOOD)) 
038B2:  MOV     #24,W0
038B4:  ADD     105E,W0
038B6:  MOV.B   [W0],W4L
038B8:  XOR.B   #2A,W4L
038BA:  BRA     Z,3948
038BC:  CP0.B   1068
038BE:  BRA     NZ,3948
....................                                   { 
....................                                       for (index = 8; index < DIR_NAMECOMP; index++) 
038C0:  MOV.B   #8,W0L
038C2:  MOV.B   W0L,106C
038C4:  MOV     106C,W4
038C6:  CP.B    W4L,#B
038C8:  BRA     C,3948
....................                                       { 
....................                                           // Get the source character 
....................                                           character = foDest->name[index]; 
038CA:  MOV     #1C,W0
038CC:  ADD.B   106C,W0L
038CE:  ZE      W0,W0
038D0:  CLR.B   1
038D2:  MOV     105C,W4
038D4:  ADD     W0,W4,W0
038D6:  MOV     W0,[W15++]
038D8:  MOV.B   [W0],W0L
038DA:  MOV.B   W0L,1069
038DC:  MOV     [--W15],W0
....................                                           // Get the destination character 
....................                                           test = foCompareTo->name[index]; 
038DE:  MOV     #1C,W0
038E0:  ADD.B   106C,W0L
038E2:  ZE      W0,W0
038E4:  CLR.B   1
038E6:  MOV     105E,W4
038E8:  ADD     W0,W4,W0
038EA:  MOV     106A,W4
038EC:  MOV.B   [W0+#0],W4L
038EE:  MOV     W4,106A
....................                                           if (test == '*') 
038F0:  MOV     106A,W4
038F2:  XOR.B   #2A,W4L
038F4:  BRA     NZ,38FA
....................                                               break; 
038F6:  GOTO    3948
....................                                           if (test != '?') 
038FA:  MOV     106A,W4
038FC:  XOR.B   #3F,W4L
038FE:  BRA     Z,3942
....................                                           { 
....................                                               if(tolower(character) != tolower(test)) 
03900:  MOV     1068,W4
03902:  LSR     W4,#8,W4
03904:  MOV     #41,W3
03906:  CP.B    W3L,W4L
03908:  BRA     GTU,391A
0390A:  MOV     1068,W4
0390C:  LSR     W4,#8,W4
0390E:  MOV     #5A,W3
03910:  CP.B    W3L,W4L
03912:  BRA     NC,391A
03914:  MOV.B   1069,W0L
03916:  IOR.B   #20,W0L
03918:  BRA     391C
0391A:  MOV.B   1069,W0L
0391C:  MOV.B   W0L,W5L
0391E:  MOV     106A,W4
03920:  MOV     #41,W3
03922:  CP.B    W3L,W4L
03924:  BRA     GTU,3934
03926:  MOV     106A,W4
03928:  MOV     #5A,W3
0392A:  CP.B    W3L,W4L
0392C:  BRA     NC,3934
0392E:  MOV.B   106A,W0L
03930:  IOR.B   #20,W0L
03932:  BRA     3936
03934:  MOV.B   106A,W0L
03936:  CP.B    W5L,W0L
03938:  BRA     Z,3942
....................                                               { 
....................                                               #ifdef __DEBUG_UART   
....................                                                 PrintROMASCIIStringUART(" !EXTMATCH!"); 
....................                                                #endif                                               
....................                                                   statusB = CE_FILE_NOT_FOUND; // it's not a match 
0393A:  MOV.B   #B,W0L
0393C:  MOV.B   W0L,1068
....................                                                   break; 
0393E:  GOTO    3948
....................                                               } 
....................                                           } 
03942:  INC.B   106C
03944:  GOTO    38C4
....................                                       } 
....................                                   } 
....................  
....................                               } // Attribute match 
....................  
....................                               break; 
03948:  GOTO    394C
....................                       } 
....................                } 
....................               #endif 
....................             } // not found 
0394C:  GOTO    3956
....................             else 
....................             { 
....................             #if defined(SUPPORT_LFN) 
....................                lfnFirstCheck = FALSE; 
....................             #endif 
....................                 /*** looking for an empty/re-usable entry ***/ 
....................                 if ( cmd == LOOK_FOR_EMPTY_ENTRY) 
03950:  CP0.B   1060
03952:  BRA     NZ,3956
....................                     statusB = CE_GOOD; 
03954:  CLR.B   1068
....................             } // found or not 
....................  
....................          #if defined(SUPPORT_LFN) 
.................... //            if(foundLFN) 
.................... //            fHandle = fHandle + 2; 
.................... //             fHandle++; 
.................... //         else 
....................          #endif 
....................                // increment it no matter what happened 
....................                fHandle++; 
03956:  INC     1066
03958:  GOTO    3740
....................  
....................         }// while 
....................     } 
....................      
....................                                               #ifdef __DEBUG_UART   
....................                                                 PrintROMASCIIStringUART("FILEfind2 foCompareTo="); 
....................                                                 PrintRAMBytesUART(((unsigned char*)foCompareTo->name), 13); 
....................                                                #endif  
....................      
....................  
....................     return(statusB); 
0395C:  MOV.B   1068,W0L
0395E:  MOV.B   W0L,0
03960:  MOV     [--W15],W5
03962:  RETURN  
.................... } // FILEFind 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     CETYPE FILEopen (FILEOBJ fo, WORD *fHandle, char type) 
....................   Summary: 
....................     Loads file information from the device 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -       File to be opened 
....................     fHandle -  Location of file 
....................     type - 
....................          -     FS_WRITE -  Create a new file or replace an existing file 
....................          -     FS_READ -   Read data from an existing file 
....................          -     FS_APPEND - Append data to an existing file 
....................   Return Values: 
....................     CE_GOOD -            FILEopen successful 
....................     CE_NOT_INIT -        Device is not yet initialized 
....................     CE_FILE_NOT_FOUND -  Could not find the file on the device 
....................     CE_BAD_SECTOR_READ - A bad read of a sector occured 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache a directory entry in the directory specified 
....................     by the dirclus parameter of hte FSFILE object 'fo.'  The offset of the 
....................     entry in the directory is specified by fHandle.  Once the directory entry 
....................     has been loaded, the first sector of the file can be loaded using the 
....................     cluster value specified in the directory entry. The type argument will 
....................     specify the mode the files will be opened in.  This will allow this 
....................     function to set the correct read/write flags for the file. 
....................   Remarks: 
....................     If the mode the file is being opened in is a plus mode (e.g. FS_READ+) the 
....................     flags will be modified further in the FSfopen function. 
....................   **************************************************************************/ 
....................  
.................... CETYPE FILEopen (FILEOBJ fo, WORD *fHandle, char type) 
*
04454:  MOV     W5,[W15++]
04456:  MOV     W6,[W15++]
*
04460:  CLR.B   1066
.................... { 
....................     DISK   *dsk;      //Disk structure 
*
04458:  CLR     1060
....................     BYTE    r;               //Result of search for file 
0445A:  CLR.B   105F
....................     DWORD    l;               //lba of first sector of first cluster 
0445C:  CLR     1062
0445E:  CLR     1064
....................     CETYPE    error = CE_GOOD; 
....................  
....................     dsk = (DISK *)(fo->dsk); 
*
04462:  MOV     105A,W4
04464:  ADD     W4,#0,W4
04466:  MOV     W4,W0
04468:  MOV     [W0],[W15++]
0446A:  POP     1060
....................     if (dsk->mount == FALSE) 
0446C:  MOV     #23,W4
0446E:  MOV     1060,W3
04470:  ADD     W3,W4,W0
04472:  MOV     #A,W1
04474:  MOV     W0,W2
04476:  MOV.B   [W2++],[W1++]
04478:  CP0.B   W5L
0447A:  BRA     NZ,4484
....................     { 
....................         error = CE_NOT_INIT; 
0447C:  MOV.B   #7,W0L
0447E:  MOV.B   W0L,1066
....................     } 
04480:  GOTO    45EC
....................     else 
....................     { 
....................         // load the sector 
....................         fo->dirccls = fo->dirclus; 
04484:  MOV     #32,W0
04486:  ADD     105A,W0
04488:  MOV     W0,W5
0448A:  MOV     #2E,W0
0448C:  ADD     105A,W0
0448E:  MOV     [W0++],[W5++]
04490:  MOV     [W0++],[W5++]
....................         // Cache no matter what if it's the first entry 
....................         if (*fHandle == 0) 
04492:  MOV     105C,W0
04494:  MOV     [W0],W5
04496:  CP0     W5
04498:  BRA     NZ,44B8
....................         { 
....................             if (Cache_File_Entry(fo, fHandle, TRUE) == NULL) 
0449A:  MOV.B   #1,W0L
0449C:  MOV.B   W0L,1086
0449E:  PUSH    105A
044A0:  POP     1082
044A2:  PUSH    105C
044A4:  POP     1084
044A6:  CALL    31E4
044AA:  MOV     W0,W5
044AC:  CP0     W5
044AE:  BRA     NZ,44B4
....................             { 
....................                 error = CE_BADCACHEREAD; 
044B0:  MOV.B   #1B,W0L
044B2:  MOV.B   W0L,1066
....................             } 
....................         } 
044B4:  GOTO    44DC
....................         else 
....................         { 
....................             // If it's not the first, only cache it if it's 
....................             // not divisible by the number of entries per sector 
....................             // If it is, Fill_File_Object will cache it 
....................             if ((*fHandle & 0xf) != 0) 
044B8:  MOV     105C,W0
044BA:  MOV     [W0],W5
044BC:  AND     W5,#F,W5
044BE:  CP0     W5
044C0:  BRA     Z,44DC
....................             { 
....................                 if (Cache_File_Entry (fo, fHandle, TRUE) == NULL) 
044C2:  MOV.B   #1,W0L
044C4:  MOV.B   W0L,1086
044C6:  PUSH    105A
044C8:  POP     1082
044CA:  PUSH    105C
044CC:  POP     1084
044CE:  CALL    31E4
044D2:  MOV     W0,W5
044D4:  CP0     W5
044D6:  BRA     NZ,44DC
....................                 { 
....................                     error = CE_BADCACHEREAD; 
044D8:  MOV.B   #1B,W0L
044DA:  MOV.B   W0L,1066
....................                 } 
....................             } 
....................         } 
....................  
....................         // Fill up the File Object with the information pointed to by fHandle 
....................         r = Fill_File_Object(fo, fHandle); 
044DC:  PUSH    105A
044DE:  POP     1072
044E0:  PUSH    105C
044E2:  POP     1074
044E4:  CALL    34D8
044E8:  MOV.B   W0L,105F
....................         if (r != FOUND) 
044EA:  CP0.B   105F
044EC:  BRA     Z,44F6
....................             error = CE_FILE_NOT_FOUND; 
044EE:  MOV.B   #B,W0L
044F0:  MOV.B   W0L,1066
044F2:  GOTO    45EC
....................         else 
....................         { 
....................             fo->seek = 0;               // first byte in file 
044F6:  MOV     #E,W0
044F8:  ADD     105A,W0
044FA:  MOV     W0,W5
044FC:  CLR.B   [W5]
044FE:  MOV.B   #0,W0L
04500:  MOV.B   W0L,[W5+#1]
04502:  MOV.B   #0,W0L
04504:  MOV.B   W0L,[W5+#2]
04506:  MOV.B   #0,W0L
04508:  MOV.B   W0L,[W5+#3]
....................             fo->ccls = fo->cluster;     // first cluster 
0450A:  MOV     #6,W0
0450C:  ADD     105A,W0
0450E:  MOV     W0,W5
04510:  MOV     #2,W0
04512:  ADD     105A,W0
04514:  MOV     [W0++],[W5++]
04516:  MOV     [W0++],[W5++]
....................             fo->sec = 0;                // first sector in the cluster 
04518:  MOV     #A,W0
0451A:  ADD     105A,W0
0451C:  MOV     W0,W5
0451E:  CLR.B   [W5]
04520:  MOV.B   #0,W0L
04522:  MOV.B   W0L,[W5+#1]
....................             fo->pos = 0;                // first byte in sector/cluster 
04524:  MOV     #C,W0
04526:  ADD     105A,W0
04528:  MOV     W0,W5
0452A:  CLR.B   [W5]
0452C:  MOV.B   #0,W0L
0452E:  MOV.B   W0L,[W5+#1]
....................  
....................             if  ( r == NOT_FOUND) 
04530:  MOV     105E,W4
04532:  LSR     W4,#8,W4
04534:  CP.B    W4L,#1
04536:  BRA     NZ,4540
....................             { 
....................                 error = CE_FILE_NOT_FOUND; 
04538:  MOV.B   #B,W0L
0453A:  MOV.B   W0L,1066
....................             } 
0453C:  GOTO    45AA
....................             else 
....................             { 
....................                 // Determine the lba of the selected sector and load 
....................                 l = Cluster2Sector(dsk,fo->ccls); 
04540:  MOV     #6,W0
04542:  ADD     105A,W0
04544:  MOV     #A,W4
04546:  MOV     [W0++],[W4++]
04548:  MOV     [W0++],[W4++]
0454A:  PUSH    1060
0454C:  POP     10B0
0454E:  MOV     W5,10B2
04550:  MOV     W6,10B4
04552:  CALL    308C
04556:  MOV     W0,1062
04558:  MOV     W1,1064
.................... #ifdef ALLOW_WRITES 
....................                 if (gNeedDataWrite) 
0455A:  CP0.B   8AE
0455C:  BRA     Z,456C
....................                     if (flushData()) 
0455E:  CALL    3170
04562:  CP0.B   W0L
04564:  BRA     Z,456C
....................                         return CE_WRITE_ERROR; 
04566:  MOV.B   #9,W0L
04568:  MOV.B   W0L,0
0456A:  BRA     45F0
.................... #endif 
....................                 gBufferOwner = fo; 
0456C:  PUSH    105A
0456E:  POP     8A8
....................                 if (gLastDataSectorRead != l) 
04570:  MOV     8AA,W0
04572:  CP      1062
04574:  BRA     NZ,457C
04576:  MOV     8AC,W0
04578:  CP      1064
0457A:  BRA     Z,45AA
....................                 { 
....................                     gBufferZeroed = FALSE; 
0457C:  CLR.B   8B0
....................                     if ( !MDD_SectorRead( l, dsk->buffer)) 
0457E:  MOV     1060,W4
04580:  ADD     W4,#0,W4
04582:  MOV     W4,W0
04584:  MOV     #A,W1
04586:  MOV     W0,W2
04588:  REPEAT  #1
0458A:  MOV.B   [W2++],[W1++]
0458C:  PUSH    1062
0458E:  POP     10F2
04590:  PUSH    1064
04592:  POP     10F4
04594:  MOV     W5,10F6
04596:  CALL    1722
0459A:  CP0.B   W0L
0459C:  BRA     NZ,45A2
....................                         error = CE_BAD_SECTOR_READ; 
0459E:  MOV.B   #8,W0L
045A0:  MOV.B   W0L,1066
....................                     gLastDataSectorRead = l; 
045A2:  PUSH    1062
045A4:  POP     8AA
045A6:  PUSH    1064
045A8:  POP     8AC
....................                 } 
....................             } // -- found 
....................  
....................             fo->flags.FileWriteEOF = FALSE; 
045AA:  MOV     #16,W0
045AC:  ADD     105A,W0
045AE:  MOV     W0,W5
045B0:  MOV     #FB,W4
045B2:  AND.B   W4L,[W5],[W5]
....................             // Set flag for operation type 
.................... #ifdef ALLOW_WRITES 
....................             if ((type == 'w') || (type == 'a')) 
045B4:  MOV     105E,W4
045B6:  XOR.B   #77,W4L
045B8:  BRA     Z,45C0
045BA:  MOV     105E,W4
045BC:  XOR.B   #61,W4L
045BE:  BRA     NZ,45D8
....................             { 
....................                 fo->flags.write = 1;   //write or append 
045C0:  MOV     #16,W0
045C2:  ADD     105A,W0
045C4:  MOV     W0,W5
045C6:  MOV     #1,W4
045C8:  IOR.B    W4L,  [W5],[W5]
....................                 fo->flags.read = 0; 
045CA:  MOV     #16,W0
045CC:  ADD     105A,W0
045CE:  MOV     W0,W5
045D0:  MOV     #FD,W4
045D2:  AND.B   W4L,[W5],[W5]
....................             } 
045D4:  GOTO    45EC
....................             else 
....................             { 
.................... #endif 
....................                 fo->flags.write = 0;   //read 
045D8:  MOV     #16,W0
045DA:  ADD     105A,W0
045DC:  MOV     W0,W5
045DE:  MOV     #FE,W4
045E0:  AND.B   W4L,[W5],[W5]
....................                 fo->flags.read = 1; 
045E2:  MOV     #16,W0
045E4:  ADD     105A,W0
045E6:  MOV     W0,W5
045E8:  MOV     #2,W4
045EA:  IOR.B    W4L,  [W5],[W5]
.................... #ifdef ALLOW_WRITES 
....................             } // -- flags 
.................... #endif 
....................         } // -- r = Found 
....................     } // -- Mounted 
....................     return (error); 
045EC:  MOV.B   1066,W0L
045EE:  MOV.B   W0L,0
045F0:  MOV     [--W15],W6
045F2:  MOV     [--W15],W5
045F4:  RETURN  
.................... } // -- FILEopen 
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE FILEget_next_cluster(FSFILE *fo, DWORD n) 
....................   Summary: 
....................     Step through a chain of clusters 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fo - The file to get the next cluster of 
....................     n -  Number of links in the FAT cluster chain to jump through 
....................   Return Values: 
....................     CE_GOOD - Operation successful 
....................     CE_BAD_SECTOR_READ - A bad read occured of a sector 
....................     CE_INVALID_CLUSTER - Invalid cluster value \> maxcls 
....................     CE_FAT_EOF - Fat attempt to read beyond EOF 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will load 'n' proximate clusters for a file from 
....................     the FAT on the device.  It will stop checking for clusters if the 
....................     ReadFAT function returns an error, if it reaches the last cluster in 
....................     a file, or if the device tries to read beyond the last cluster used 
....................     by the device. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... BYTE FILEget_next_cluster(FSFILE *fo, DWORD n) 
*
04674:  MOV     W5,[W15++]
04676:  MOV     W6,[W15++]
*
04688:  CLR.B   1066
.................... { 
....................     DWORD         c, c2, ClusterFailValue, LastClustervalue; 
*
04678:  CLR     1056
0467A:  CLR     1058
0467C:  CLR     105A
0467E:  CLR     105C
04680:  CLR     105E
04682:  CLR     1060
04684:  CLR     1062
04686:  CLR     1064
....................     BYTE          error = CE_GOOD; 
....................     DISK *      disk; 
*
0468A:  CLR     1068
....................  
....................     disk = fo->dsk; 
0468C:  MOV     1050,W4
0468E:  ADD     W4,#0,W4
04690:  MOV     W4,W0
04692:  MOV     [W0],[W15++]
04694:  POP     1068
....................  
....................     /* Settings based on FAT type */ 
....................     switch (disk->type) 
04696:  MOV     #22,W4
04698:  MOV     1068,W3
0469A:  ADD     W3,W4,W0
0469C:  MOV     #A,W1
0469E:  MOV     W0,W2
046A0:  MOV.B   [W2++],[W1++]
046A2:  MOV.B   W5L,W0L
046A4:  CLR.B   1
046A6:  XOR     #3,W0
046A8:  BRA     Z,46B0
046AA:  XOR     #1,W0
046AC:  BRA     Z,46C2
046AE:  BRA     46C2
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             LastClustervalue = LAST_CLUSTER_FAT32; 
046B0:  MOV     #FFF8,W4
046B2:  MOV     W4,1062
046B4:  MOV     #FFF,W4
046B6:  MOV     W4,1064
....................             ClusterFailValue  = CLUSTER_FAIL_FAT32; 
046B8:  SETM    105E
046BA:  MOV     #FFF,W4
046BC:  MOV     W4,1060
....................             break; 
046BE:  GOTO    46D0
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
....................             LastClustervalue = LAST_CLUSTER_FAT12; 
....................             ClusterFailValue  = CLUSTER_FAIL_FAT16; 
....................             break; 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             LastClustervalue = LAST_CLUSTER_FAT16; 
046C2:  MOV     #FFF8,W4
046C4:  MOV     W4,1062
046C6:  CLR     1064
....................             ClusterFailValue  = CLUSTER_FAIL_FAT16; 
046C8:  SETM    105E
046CA:  CLR     1060
....................             break; 
046CC:  GOTO    46D0
....................     } 
....................  
....................     // loop n times 
....................     do 
....................     { 
....................         // get the next cluster link from FAT 
....................         c2 = fo->ccls; 
046D0:  MOV     #6,W0
046D2:  ADD     1050,W0
046D4:  MOV     #105A,W4
046D6:  MOV     [W0++],[W4++]
046D8:  MOV     [W0++],[W4++]
....................         if ( (c = ReadFAT( disk, c2)) == ClusterFailValue) 
046DA:  PUSH    1068
046DC:  POP     10A2
046DE:  PUSH    105A
046E0:  POP     10A4
046E2:  PUSH    105C
046E4:  POP     10A6
046E6:  CALL    2ECC
046EA:  MOV     W0,1056
046EC:  MOV     W1,1058
046EE:  MOV     1056,W0
046F0:  CP      105E
046F2:  BRA     NZ,4702
046F4:  MOV     1058,W0
046F6:  CP      1060
046F8:  BRA     NZ,4702
....................             error = CE_BAD_SECTOR_READ; 
046FA:  MOV.B   #8,W0L
046FC:  MOV.B   W0L,1066
046FE:  GOTO    4738
....................         else 
....................         { 
....................             // check if cluster value is valid 
....................             if ( c >= disk->maxcls) 
04702:  MOV     1068,W4
04704:  ADD     W4,#14,W4
04706:  MOV     W4,W0
04708:  MOV     #A,W1
0470A:  MOV     W0,W2
0470C:  REPEAT  #3
0470E:  MOV.B   [W2++],[W1++]
04710:  MOV     1058,W4
04712:  CP      W4,W6
04714:  BRA     NC,4722
04716:  BRA     GTU,471E
04718:  MOV     1056,W4
0471A:  CP      W4,W5
0471C:  BRA     NC,4722
....................             { 
....................                 error = CE_INVALID_CLUSTER; 
0471E:  MOV.B   #A,W0L
04720:  MOV.B   W0L,1066
....................             } 
....................  
....................             // compare against max value of a cluster in FAT 
....................             // return if eof 
....................             if ( c >= LastClustervalue)    // check against eof 
04722:  MOV     1064,W0
04724:  MOV     1058,W4
04726:  CP      W4,W0
04728:  BRA     NC,4738
0472A:  BRA     GTU,4734
0472C:  MOV     1062,W0
0472E:  MOV     1056,W4
04730:  CP      W4,W0
04732:  BRA     NC,4738
....................             { 
....................                 error = CE_FAT_EOF; 
04734:  MOV.B   #3C,W0L
04736:  MOV.B   W0L,1066
....................             } 
....................         } 
....................  
....................         // update the FSFILE structure 
....................         fo->ccls = c; 
04738:  MOV     #6,W0
0473A:  ADD     1050,W0
0473C:  MOV     W0,W5
0473E:  MOV     #1056,W4
04740:  MOV     [W4++],[W5++]
04742:  MOV     [W4++],[W5++]
....................  
....................     } while ((--n > 0) && (error == CE_GOOD));// loop end 
04744:  DEC     1052
04746:  BTSS.B  42.0
04748:  DEC     1054
0474A:  CP0     1052
0474C:  BRA     NZ,4752
0474E:  CP0     1054
04750:  BRA     Z,4756
04752:  CP0.B   1066
04754:  BRA     Z,46D0
....................  
....................     return(error); 
04756:  MOV.B   1066,W0L
04758:  MOV.B   W0L,0
0475A:  MOV     [--W15],W6
0475C:  MOV     [--W15],W5
0475E:  RETURN  
.................... } // get next cluster 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     BYTE DISKmount ( DISK *dsk) 
....................   Summary: 
....................     Initialies the device and loads MBR and boot sector information 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -  The disk structure to be initialized. 
....................   Return Values: 
....................     CE_GOOD -       Disk mounted 
....................     CE_INIT_ERROR - Initialization error has occured 
....................     CE_UNSUPPORTED_SECTOR_SIZE - Media sector size bigger than 
....................                 MEDIA_SECTOR_SIZE as defined in FSconfig.h. 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will use the function pointed to by the MDD_MediaInitialize 
....................     function pointer to initialize the device (if any initialization is 
....................     required).  It then attempts to load the master boot record with the 
....................     LoadMBR function and the boot sector with the LoadBootSector function. 
....................     These two functions will be used to initialize a global DISK structure 
....................     that will be used when accessing file information in the future. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... BYTE DISKmount( DISK *dsk) 
*
0211A:  MOV     W5,[W15++]
0211C:  MOV     W6,[W15++]
0211E:  MOV     W7,[W15++]
02120:  CLR.B   FD4
.................... { 
....................     BYTE                error = CE_GOOD; 
....................     MEDIA_INFORMATION   *mediaInformation; 
02122:  CLR     FD6
....................  
....................     dsk->mount = FALSE; // default invalid 
02124:  MOV     #23,W4
02126:  MOV     FD2,W3
02128:  ADD     W3,W4,W0
0212A:  MOV     W0,W5
0212C:  CLR.B   W6
0212E:  MOV     W5,W1
02130:  MOV     #C,W2
02132:  MOV.B   [W2++],[W1++]
....................     dsk->buffer = gDataBuffer;    // assign buffer 
02134:  MOV     FD2,W4
02136:  ADD     W4,#0,W4
02138:  MOV     W4,W0
0213A:  MOV     W0,W5
0213C:  MOV     #960,W6
0213E:  MOV     W5,W1
02140:  MOV     #C,W2
02142:  REPEAT  #1
02144:  MOV.B   [W2++],[W1++]
....................  
....................     // Initialize the device 
....................     mediaInformation = MDD_MediaInitialize(); 
02146:  CALL    10FE
0214A:  MOV     W0,FD6
....................     if (mediaInformation->errorCode != MEDIA_NO_ERROR) 
0214C:  MOV     #0,W0
0214E:  ADD     FD6,W0
02150:  CP0.B   [W0]
02152:  BRA     Z,2160
....................     { 
....................         error = CE_INIT_ERROR; 
02154:  MOV.B   #6,W0L
02156:  MOV.B   W0L,FD4
....................         FSerrno = CE_INIT_ERROR; 
02158:  MOV.B   #6,W0L
0215A:  MOV.B   W0L,8B1
....................     } 
0215C:  GOTO    21D0
....................     else 
....................     { 
....................         // If the media initialization routine determined the sector size, 
....................         // check it and make sure we can support it. 
....................         if (mediaInformation->validityFlags.bits.sectorSize) 
02160:  MOV     #1,W0
02162:  ADD     FD6,W0
02164:  MOV.B   [W0],W4L
02166:  BTSS    W4.0
02168:  BRA     21A4
....................         { 
....................          dsk->sectorSize = mediaInformation->sectorSize; 
0216A:  MOV     FD2,W4
0216C:  ADD     W4,#18,W4
0216E:  MOV     W4,W0
02170:  MOV     W0,W5
02172:  MOV     #2,W0
02174:  ADD     FD6,W0
02176:  MOV     W0,W4
02178:  MOV     [W4],W0
0217A:  MOV     W0,W6
0217C:  MOV     #0,W7
0217E:  MOV     W5,W1
02180:  MOV     #C,W2
02182:  REPEAT  #1
02184:  MOV.B   [W2++],[W1++]
02186:  CLR.B   [W1++]
02188:  CLR.B   [W1++]
....................             if (mediaInformation->sectorSize > MEDIA_SECTOR_SIZE) 
0218A:  MOV     #2,W0
0218C:  ADD     FD6,W0
0218E:  MOV     [W0],W5
02190:  MOV     #200,W4
02192:  CP      W4,W5
02194:  BRA     C,21A4
....................             { 
....................                 error = CE_UNSUPPORTED_SECTOR_SIZE; 
02196:  MOV.B   #21,W0L
02198:  MOV.B   W0L,FD4
....................                 FSerrno = CE_UNSUPPORTED_SECTOR_SIZE; 
0219A:  MOV.B   #21,W0L
0219C:  MOV.B   W0L,8B1
....................                 return error; 
0219E:  MOV.B   FD4,W0L
021A0:  MOV.B   W0L,0
021A2:  BRA     21D4
....................             } 
....................         } 
....................  
....................         // Load the Master Boot Record (partition) 
....................         if((error = LoadMBR(dsk)) == CE_GOOD) 
021A4:  PUSH    FD2
021A6:  POP     FDA
021A8:  CALL    1786
021AC:  MOV.B   W0L,FD4
021AE:  CP0.B   FD4
021B0:  BRA     NZ,21D0
....................         { 
....................             // Now the boot sector 
....................             if((error = LoadBootSector(dsk)) == CE_GOOD) 
021B2:  PUSH    FD2
021B4:  POP     FDA
021B6:  CALL    1B3A
021BA:  MOV.B   W0L,FD4
021BC:  CP0.B   FD4
021BE:  BRA     NZ,21D0
....................                 dsk->mount = TRUE; // Mark that the DISK mounted successfully 
021C0:  MOV     #23,W4
021C2:  MOV     FD2,W3
021C4:  ADD     W3,W4,W0
021C6:  MOV     W0,W5
021C8:  MOV.B   #1,W6L
021CA:  MOV     W5,W1
021CC:  MOV     #C,W2
021CE:  MOV.B   [W2++],[W1++]
....................         } 
....................     } // -- Load file parameters 
....................  
....................     return(error); 
021D0:  MOV.B   FD4,W0L
021D2:  MOV.B   W0L,0
021D4:  MOV     [--W15],W7
021D6:  MOV     [--W15],W6
021D8:  MOV     [--W15],W5
021DA:  RETURN  
.................... } // -- mount 
....................  
....................  
....................  
.................... /******************************************************************** 
....................   Function: 
....................     CETYPE LoadMBR ( DISK *dsk) 
....................   Summary: 
....................     Loads the MBR and extracts necessary information 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -  The disk containing the master boot record to be loaded 
....................   Return Values: 
....................     CE_GOOD -            MBR loaded successfully 
....................     CE_BAD_SECTOR_READ - A bad read occured of a sector 
....................     CE_BAD_PARTITION -   The boot record is bad 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The LoadMBR function will use the function pointed to by the 
....................     MDD_SectorRead function pointer to read the 0 sector from the 
....................     device.  If a valid boot signature is obtained, this function 
....................     will compare fields in that cached sector to the values that 
....................     would be present if that sector was a boot sector.  If all of 
....................     those values match, it will be assumed that the device does not 
....................     have a master boot record and the 0 sector is actually the boot 
....................     sector.  Otherwise, data about the partition and the actual 
....................     location of the boot sector will be loaded from the MBR into 
....................     the DISK structure pointed to by 'dsk.' 
....................   Remarks: 
....................     None 
....................   ********************************************************************/ 
....................  
.................... BYTE LoadMBR(DISK *dsk) 
*
01786:  MOV     W5,[W15++]
01788:  MOV     #C,W5
0178A:  REPEAT  #4
0178C:  MOV     [W5++],[W15++]
*
01790:  CLR.B   FDE
.................... { 
....................     PT_MBR  Partition; 
*
0178E:  CLR     FDC
....................     BYTE error = CE_GOOD; 
....................     BYTE type; 
*
01792:  CLR.B   FDF
....................     BootSec BSec; 
01794:  CLR     FE0
....................  
....................     // Get the partition table from the MBR 
....................     if ( MDD_SectorRead( FO_MBR, dsk->buffer) != TRUE) 
01796:  MOV     FDA,W4
01798:  ADD     W4,#0,W4
0179A:  MOV     W4,W0
0179C:  MOV     #A,W1
0179E:  MOV     W0,W2
017A0:  REPEAT  #1
017A2:  MOV.B   [W2++],[W1++]
017A4:  CLR     10F2
017A6:  CLR     10F4
017A8:  MOV     W5,10F6
017AA:  CALL    1722
017AE:  CP.B    W0L,#1
017B0:  BRA     Z,17BE
....................     { 
....................         #ifdef __DEBUG_UART 
....................         PrintROMASCIIStringUART("Error reading MBR block"); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................  
....................         error = CE_BAD_SECTOR_READ; 
017B2:  MOV.B   #8,W0L
017B4:  MOV.B   W0L,FDE
....................         FSerrno = CE_BAD_SECTOR_READ; 
017B6:  MOV.B   #8,W0L
017B8:  MOV.B   W0L,8B1
....................     } 
017BA:  GOTO    1A58
....................     else 
....................     { 
....................         #ifdef __DEBUG_UART 
....................         PrintROMASCIIStringUART("MBR:"); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         PrintRAMBytesUART(((unsigned char*)dsk->buffer), 512); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................  
....................         // Check if the card has no MBR 
....................         BSec = (BootSec) dsk->buffer; 
017BE:  MOV     FDA,W4
017C0:  ADD     W4,#0,W4
017C2:  MOV     W4,W0
017C4:  MOV     #A,W1
017C6:  MOV     W0,W2
017C8:  REPEAT  #1
017CA:  MOV.B   [W2++],[W1++]
017CC:  MOV     W5,FE0
....................  
....................         #ifdef __DEBUG_UART 
....................         PrintROMASCIIStringUART("MBR Sig0="); 
....................         PrintRAMBytesUART(((unsigned char*)&BSec->Signature0), 1); 
....................         PrintROMASCIIStringUART(" Sig1="); 
....................         PrintRAMBytesUART(((unsigned char*)&BSec->Signature1), 1); 
....................         PrintROMASCIIStringUART(" FAT1* type="); 
....................         PrintRAMBytesUART(((unsigned char*)BSec->FAT.FAT_16.BootSec_FSType), 4); 
....................         PrintROMASCIIStringUART(" sig="); 
....................         PrintRAMBytesUART(((unsigned char*)&BSec->FAT.FAT_16.BootSec_BootSig), 1); 
....................         PrintROMASCIIStringUART(" FAT32 type="); 
....................         PrintRAMBytesUART(((unsigned char*)BSec->FAT.FAT_32.BootSec_FilSysType), 4); 
....................         PrintROMASCIIStringUART(" sig="); 
....................         PrintRAMBytesUART(((unsigned char*)&BSec->FAT.FAT_32.BootSec_BootSig), 1); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................  
....................         if((BSec->Signature0 == FAT_GOOD_SIGN_0) && (BSec->Signature1 == FAT_GOOD_SIGN_1)) 
017CE:  MOV     #1FE,W4
017D0:  MOV     FE0,W3
017D2:  ADD     W3,W4,W0
017D4:  MOV     #A,W1
017D6:  MOV     W0,W2
017D8:  MOV.B   [W2++],[W1++]
017DA:  MOV     #55,W4
017DC:  CP.B    W4L,W5L
017DE:  BRA     NZ,197A
017E0:  MOV     #1FF,W4
017E2:  MOV     FE0,W3
017E4:  ADD     W3,W4,W0
017E6:  MOV     #A,W1
017E8:  MOV     W0,W2
017EA:  MOV.B   [W2++],[W1++]
017EC:  MOV     #AA,W4
017EE:  CP.B    W4L,W5L
017F0:  BRA     NZ,197A
....................         { 
....................          // Technically, the OEM name is not for indication 
....................          // The alternative is to read the CIS from attribute 
....................          // memory.  See the PCMCIA metaformat for more details 
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................             if ((ReadByte( dsk->buffer, BSI_FSTYPE ) == 'F') && \ 
....................             (ReadByte( dsk->buffer, BSI_FSTYPE + 1 ) == 'A') && \ 
....................             (ReadByte( dsk->buffer, BSI_FSTYPE + 2 ) == 'T') && \ 
....................             (ReadByte( dsk->buffer, BSI_FSTYPE + 3 ) == '1') && \ 
....................             (ReadByte( dsk->buffer, BSI_BOOTSIG) == 0x29)) 
017F2:  MOV     FDA,W4
017F4:  ADD     W4,#0,W4
017F6:  MOV     W4,W0
017F8:  MOV     #A,W1
017FA:  MOV     W0,W2
017FC:  REPEAT  #1
017FE:  MOV.B   [W2++],[W1++]
01800:  MOV     W5,FF6
01802:  MOV     #36,W4
01804:  MOV     W4,FF8
01806:  CALL    1776
0180A:  MOV     #46,W4
0180C:  CP.B    W4L,W0L
0180E:  BRA     NZ,18B8
01810:  MOV     FDA,W4
01812:  ADD     W4,#0,W4
01814:  MOV     W4,W0
01816:  MOV     #C,W1
01818:  MOV     W0,W2
0181A:  REPEAT  #1
0181C:  MOV.B   [W2++],[W1++]
0181E:  MOV     W6,FF6
01820:  MOV     #37,W4
01822:  MOV     W4,FF8
01824:  CALL    1776
01828:  MOV     #41,W4
0182A:  CP.B    W4L,W0L
0182C:  BRA     NZ,18B8
0182E:  MOV     FDA,W4
01830:  ADD     W4,#0,W4
01832:  MOV     W4,W0
01834:  MOV     #E,W1
01836:  MOV     W0,W2
01838:  REPEAT  #1
0183A:  MOV.B   [W2++],[W1++]
0183C:  MOV     W7,FF6
0183E:  MOV     #38,W4
01840:  MOV     W4,FF8
01842:  CALL    1776
01846:  MOV     #54,W4
01848:  CP.B    W4L,W0L
0184A:  BRA     NZ,18B8
0184C:  MOV     FDA,W4
0184E:  ADD     W4,#0,W4
01850:  MOV     W4,W0
01852:  MOV     #10,W1
01854:  MOV     W0,W2
01856:  REPEAT  #1
01858:  MOV.B   [W2++],[W1++]
0185A:  MOV     W8,FF6
0185C:  MOV     #39,W4
0185E:  MOV     W4,FF8
01860:  CALL    1776
01864:  MOV     #31,W4
01866:  CP.B    W4L,W0L
01868:  BRA     NZ,18B8
0186A:  MOV     FDA,W4
0186C:  ADD     W4,#0,W4
0186E:  MOV     W4,W0
01870:  MOV     #12,W1
01872:  MOV     W0,W2
01874:  REPEAT  #1
01876:  MOV.B   [W2++],[W1++]
01878:  MOV     W9,FF6
0187A:  MOV     #26,W4
0187C:  MOV     W4,FF8
0187E:  CALL    1776
01882:  MOV     #29,W4
01884:  CP.B    W4L,W0L
01886:  BRA     NZ,18B8
.................... #else 
....................             if ((BSec->FAT.FAT_16.BootSec_FSType[0] == 'F') && \ 
....................                 (BSec->FAT.FAT_16.BootSec_FSType[1] == 'A') && \ 
....................                 (BSec->FAT.FAT_16.BootSec_FSType[2] == 'T') && \ 
....................                 (BSec->FAT.FAT_16.BootSec_FSType[3] == '1') && \ 
....................                 (BSec->FAT.FAT_16.BootSec_BootSig == 0x29)) 
.................... #endif 
....................              { 
....................                 dsk->firsts = 0; 
01888:  MOV     FDA,W4
0188A:  ADD     W4,#2,W4
0188C:  MOV     W4,W0
0188E:  MOV     W0,W5
01890:  MOV     #0,W6
01892:  MOV     #0,W7
01894:  MOV     W5,W1
01896:  MOV     #C,W2
01898:  REPEAT  #1
0189A:  MOV.B   [W2++],[W1++]
0189C:  CLR.B   [W1++]
0189E:  CLR.B   [W1++]
....................                 dsk->type = FAT16; 
018A0:  MOV     #22,W4
018A2:  MOV     FDA,W3
018A4:  ADD     W3,W4,W0
018A6:  MOV     W0,W5
018A8:  MOV.B   #2,W6L
018AA:  MOV     W5,W1
018AC:  MOV     #C,W2
018AE:  MOV.B   [W2++],[W1++]
....................                 return CE_GOOD; 
018B0:  CLR.B   0
018B2:  BRA     1A5C
....................              } 
018B4:  GOTO    197A
....................              else 
....................              { 
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................                 if ((ReadByte( dsk->buffer, BSI_FAT32_FSTYPE ) == 'F') && \ 
....................                     (ReadByte( dsk->buffer, BSI_FAT32_FSTYPE + 1 ) == 'A') && \ 
....................                     (ReadByte( dsk->buffer, BSI_FAT32_FSTYPE + 2 ) == 'T') && \ 
....................                     (ReadByte( dsk->buffer, BSI_FAT32_FSTYPE + 3 ) == '3') && \ 
....................                     (ReadByte( dsk->buffer, BSI_FAT32_BOOTSIG) == 0x29)) 
018B8:  MOV     FDA,W4
018BA:  ADD     W4,#0,W4
018BC:  MOV     W4,W0
018BE:  MOV     #A,W1
018C0:  MOV     W0,W2
018C2:  REPEAT  #1
018C4:  MOV.B   [W2++],[W1++]
018C6:  MOV     W5,FF6
018C8:  MOV     #52,W4
018CA:  MOV     W4,FF8
018CC:  CALL    1776
018D0:  MOV     #46,W4
018D2:  CP.B    W4L,W0L
018D4:  BRA     NZ,197A
018D6:  MOV     FDA,W4
018D8:  ADD     W4,#0,W4
018DA:  MOV     W4,W0
018DC:  MOV     #C,W1
018DE:  MOV     W0,W2
018E0:  REPEAT  #1
018E2:  MOV.B   [W2++],[W1++]
018E4:  MOV     W6,FF6
018E6:  MOV     #53,W4
018E8:  MOV     W4,FF8
018EA:  CALL    1776
018EE:  MOV     #41,W4
018F0:  CP.B    W4L,W0L
018F2:  BRA     NZ,197A
018F4:  MOV     FDA,W4
018F6:  ADD     W4,#0,W4
018F8:  MOV     W4,W0
018FA:  MOV     #E,W1
018FC:  MOV     W0,W2
018FE:  REPEAT  #1
01900:  MOV.B   [W2++],[W1++]
01902:  MOV     W7,FF6
01904:  MOV     #54,W4
01906:  MOV     W4,FF8
01908:  CALL    1776
0190C:  MOV     #54,W4
0190E:  CP.B    W4L,W0L
01910:  BRA     NZ,197A
01912:  MOV     FDA,W4
01914:  ADD     W4,#0,W4
01916:  MOV     W4,W0
01918:  MOV     #10,W1
0191A:  MOV     W0,W2
0191C:  REPEAT  #1
0191E:  MOV.B   [W2++],[W1++]
01920:  MOV     W8,FF6
01922:  MOV     #55,W4
01924:  MOV     W4,FF8
01926:  CALL    1776
0192A:  MOV     #33,W4
0192C:  CP.B    W4L,W0L
0192E:  BRA     NZ,197A
01930:  MOV     FDA,W4
01932:  ADD     W4,#0,W4
01934:  MOV     W4,W0
01936:  MOV     #12,W1
01938:  MOV     W0,W2
0193A:  REPEAT  #1
0193C:  MOV.B   [W2++],[W1++]
0193E:  MOV     W9,FF6
01940:  MOV     #42,W4
01942:  MOV     W4,FF8
01944:  CALL    1776
01948:  MOV     #29,W4
0194A:  CP.B    W4L,W0L
0194C:  BRA     NZ,197A
.................... #else 
....................                 if ((BSec->FAT.FAT_32.BootSec_FilSysType[0] == 'F') && \ 
....................                     (BSec->FAT.FAT_32.BootSec_FilSysType[1] == 'A') && \ 
....................                     (BSec->FAT.FAT_32.BootSec_FilSysType[2] == 'T') && \ 
....................                     (BSec->FAT.FAT_32.BootSec_FilSysType[3] == '3') && \ 
....................                     (BSec->FAT.FAT_32.BootSec_BootSig == 0x29)) 
.................... #endif 
....................                 { 
....................                     dsk->firsts = 0; 
0194E:  MOV     FDA,W4
01950:  ADD     W4,#2,W4
01952:  MOV     W4,W0
01954:  MOV     W0,W5
01956:  MOV     #0,W6
01958:  MOV     #0,W7
0195A:  MOV     W5,W1
0195C:  MOV     #C,W2
0195E:  REPEAT  #1
01960:  MOV.B   [W2++],[W1++]
01962:  CLR.B   [W1++]
01964:  CLR.B   [W1++]
....................                     dsk->type = FAT32; 
01966:  MOV     #22,W4
01968:  MOV     FDA,W3
0196A:  ADD     W3,W4,W0
0196C:  MOV     W0,W5
0196E:  MOV.B   #3,W6L
01970:  MOV     W5,W1
01972:  MOV     #C,W2
01974:  MOV.B   [W2++],[W1++]
....................                     return CE_GOOD; 
01976:  CLR.B   0
01978:  BRA     1A5C
....................                 } 
....................             } 
....................         } 
....................         // assign it the partition table strucutre 
....................         Partition = (PT_MBR)dsk->buffer; 
0197A:  MOV     FDA,W4
0197C:  ADD     W4,#0,W4
0197E:  MOV     W4,W0
01980:  MOV     #A,W1
01982:  MOV     W0,W2
01984:  REPEAT  #1
01986:  MOV.B   [W2++],[W1++]
01988:  MOV     W5,FDC
....................  
....................         #ifdef __DEBUG_UART 
....................         PrintROMASCIIStringUART("Partition Sig0="); 
....................         PrintRAMBytesUART(((unsigned char*)&Partition->Signature0), 1); 
....................         PrintROMASCIIStringUART(" Sig1="); 
....................         PrintRAMBytesUART(((unsigned char*)&Partition->Signature1), 1); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................  
....................         // Ensure its good 
....................         if((Partition->Signature0 != FAT_GOOD_SIGN_0) || (Partition->Signature1 != FAT_GOOD_SIGN_1)) 
0198A:  MOV     #1FE,W4
0198C:  MOV     FDC,W3
0198E:  ADD     W3,W4,W0
01990:  MOV     #A,W1
01992:  MOV     W0,W2
01994:  MOV.B   [W2++],[W1++]
01996:  MOV     #55,W4
01998:  CP.B    W4L,W5L
0199A:  BRA     NZ,19AE
0199C:  MOV     #1FF,W4
0199E:  MOV     FDC,W3
019A0:  ADD     W3,W4,W0
019A2:  MOV     #A,W1
019A4:  MOV     W0,W2
019A6:  MOV.B   [W2++],[W1++]
019A8:  MOV     #AA,W4
019AA:  CP.B    W4L,W5L
019AC:  BRA     Z,19BA
....................         { 
....................             FSerrno = CE_BAD_PARTITION; 
019AE:  MOV.B   #4,W0L
019B0:  MOV.B   W0L,8B1
....................             error = CE_BAD_PARTITION; 
019B2:  MOV.B   #4,W0L
019B4:  MOV.B   W0L,FDE
....................         } 
019B6:  GOTO    1A58
....................         else 
....................         { 
....................             BYTE i; 
019BA:  CLR.B   FE2
019BC:  MOV     #1BE,W4
019BE:  MOV     FDC,W3
019C0:  ADD     W3,W4,W0
....................             PTE_MBR* partitionEntry = &Partition->Partition0; 
019C2:  MOV     W0,FE4
....................  
....................             for(i=0; i<4; i++) 
019C4:  CLR.B   FE2
019C6:  MOV     FE2,W4
019C8:  CP.B    W4L,#4
019CA:  BRA     C,1A50
....................             { 
....................                 /*    Valid Master Boot Record Loaded   */ 
....................  
....................                 // Get the 32 bit offset to the first partition 
....................                 dsk->firsts = partitionEntry->PTE_FrstSect; 
019CC:  MOV     FDA,W4
019CE:  ADD     W4,#2,W4
019D0:  MOV     W4,W0
019D2:  MOV     W0,W5
019D4:  MOV     FE4,W4
019D6:  ADD     W4,#8,W4
019D8:  MOV     W4,W0
019DA:  MOV     #C,W1
019DC:  MOV     W0,W2
019DE:  REPEAT  #3
019E0:  MOV.B   [W2++],[W1++]
019E2:  MOV.D   W6,W8
019E4:  MOV     W5,W1
019E6:  MOV     #10,W2
019E8:  REPEAT  #3
019EA:  MOV.B   [W2++],[W1++]
....................  
....................                 // check if the partition type is acceptable 
....................                   type = partitionEntry->PTE_FSDesc; 
019EC:  MOV     FE4,W4
019EE:  ADD     W4,#4,W4
019F0:  MOV     W4,W0
019F2:  MOV     #A,W1
019F4:  MOV     W0,W2
019F6:  MOV.B   [W2++],[W1++]
019F8:  MOV.B   W5L,W0L
019FA:  MOV.B   W0L,FDF
....................  
....................                 switch (type) 
019FC:  MOV.B   FDF,W0L
019FE:  CLR.B   1
01A00:  XOR     #4,W0
01A02:  BRA     Z,1A16
01A04:  XOR     #2,W0
01A06:  BRA     Z,1A16
01A08:  XOR     #8,W0
01A0A:  BRA     Z,1A16
01A0C:  XOR     #5,W0
01A0E:  BRA     Z,1A2C
01A10:  XOR     #7,W0
01A12:  BRA     Z,1A2C
01A14:  BRA     1A42
....................                 { 
....................                 #ifdef SUPPORT_FAT12 
....................                     case 0x01: 
....................                         dsk->type = FAT12; 
....................                         break; 
....................                         #endif 
....................  
....................                 case 0x04: 
....................                     case 0x06: 
....................                     case 0x0E: 
....................                         dsk->type = FAT16; 
01A16:  MOV     #22,W4
01A18:  MOV     FDA,W3
01A1A:  ADD     W3,W4,W0
01A1C:  MOV     W0,W5
01A1E:  MOV.B   #2,W6L
01A20:  MOV     W5,W1
01A22:  MOV     #C,W2
01A24:  MOV.B   [W2++],[W1++]
....................                         return(error); 
01A26:  MOV.B   FDE,W0L
01A28:  MOV.B   W0L,0
01A2A:  BRA     1A5C
....................  
....................                     case 0x0B: 
....................                     case 0x0C: 
....................                         #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................                             dsk->type = FAT32;    // FAT32 is supported too 
01A2C:  MOV     #22,W4
01A2E:  MOV     FDA,W3
01A30:  ADD     W3,W4,W0
01A32:  MOV     W0,W5
01A34:  MOV.B   #3,W6L
01A36:  MOV     W5,W1
01A38:  MOV     #C,W2
01A3A:  MOV.B   [W2++],[W1++]
....................                             return(error); 
01A3C:  MOV.B   FDE,W0L
01A3E:  MOV.B   W0L,0
01A40:  BRA     1A5C
....................                         #endif 
....................                 } // switch 
....................  
....................                 /* If we are here, we didn't find a matching partition.  We 
....................                    should increment to the next partition table entry */ 
....................                 partitionEntry++; 
01A42:  PUSH    FE4
01A44:  MOV     #10,W0
01A46:  ADD     FE4
01A48:  MOV     [--W15],W0
01A4A:  INC.B   0FE2
01A4C:  GOTO    19C6
....................             } 
....................  
....................             FSerrno = CE_UNSUPPORTED_FS; 
01A50:  MOV.B   #5,W0L
01A52:  MOV.B   W0L,8B1
....................             error = CE_UNSUPPORTED_FS; 
01A54:  MOV.B   #5,W0L
01A56:  MOV.B   W0L,FDE
....................         } 
....................     } 
....................  
....................     return(error); 
01A58:  MOV.B   FDE,W0L
01A5A:  MOV.B   W0L,0
01A5C:  MOV     #14,W5
01A5E:  REPEAT  #4
01A60:  MOV     [--W15],[W5--]
01A62:  MOV     [--W15],W5
01A64:  RETURN  
.................... }// -- LoadMBR 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     BYTE LoadBootSector (DISK *dsk) 
....................   Summary: 
....................     Load the boot sector and extract the necessary information 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -  The disk containing the boot sector 
....................   Return Values: 
....................     CE_GOOD -                    Boot sector loaded 
....................     CE_BAD_SECTOR_READ -         A bad read occured of a sector 
....................     CE_NOT_FORMATTED -           The disk is of an unsupported format 
....................     CE_CARDFAT32 -               FAT 32 device not supported 
....................     CE_UNSUPPORTED_SECTOR_SIZE - The sector size is not supported 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     LoadBootSector will use the function pointed to by the MDD_SectorWrite 
....................     function pointer to load the boot sector, whose location was obtained 
....................     by a previous call of LoadMBR.  If the boot sector is loaded successfully, 
....................     partition information will be calcualted from it and copied into the DISK 
....................     structure pointed to by 'dsk.' 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
....................  
.................... BYTE LoadBootSector(DISK *dsk) 
*
01B3A:  MOV     W5,[W15++]
01B3C:  MOV     #C,W5
01B3E:  REPEAT  #4
01B40:  MOV     [W5++],[W15++]
*
01B4E:  CLR.B   FE8
*
01B56:  BCLR.B  FE9.0
01B58:  BCLR.B  FE9.1
.................... { 
....................     DWORD       RootDirSectors; 
*
01B42:  CLR     FDC
01B44:  CLR     FDE
....................     DWORD       TotSec,DataSec; 
01B46:  CLR     FE0
01B48:  CLR     FE2
01B4A:  CLR     FE4
01B4C:  CLR     FE6
....................     BYTE        error = CE_GOOD; 
....................     BootSec     BSec; 
*
01B50:  CLR     FEA
....................     WORD        BytesPerSec; 
01B52:  CLR     FEC
....................     WORD        ReservedSectorCount; 
01B54:  CLR     FEE
....................  
....................     #if defined(SUPPORT_FAT32) 
....................     BOOL        TriedSpecifiedBackupBootSec = FALSE; 
....................     BOOL        TriedBackupBootSecAtAddress6 = FALSE; 
....................     #endif 
....................     // Get the Boot sector 
....................     if ( MDD_SectorRead( dsk->firsts, dsk->buffer) != TRUE) 
*
01B5A:  MOV     FDA,W4
01B5C:  ADD     W4,#2,W4
01B5E:  MOV     W4,W0
01B60:  MOV     #A,W1
01B62:  MOV     W0,W2
01B64:  REPEAT  #3
01B66:  MOV.B   [W2++],[W1++]
01B68:  MOV     FDA,W4
01B6A:  ADD     W4,#0,W4
01B6C:  MOV     W4,W0
01B6E:  MOV     #E,W1
01B70:  MOV     W0,W2
01B72:  REPEAT  #1
01B74:  MOV.B   [W2++],[W1++]
01B76:  MOV     W5,10F2
01B78:  MOV     W6,10F4
01B7A:  MOV     W7,10F6
01B7C:  CALL    1722
01B80:  CP.B    W0L,#1
01B82:  BRA     Z,1B8C
....................     { 
....................         error = CE_BAD_SECTOR_READ; 
01B84:  MOV.B   #8,W0L
01B86:  MOV.B   W0L,FE8
....................     } 
01B88:  GOTO    2104
....................     else 
....................     { 
....................         BSec = (BootSec)dsk->buffer; 
01B8C:  MOV     FDA,W4
01B8E:  ADD     W4,#0,W4
01B90:  MOV     W4,W0
01B92:  MOV     #A,W1
01B94:  MOV     W0,W2
01B96:  REPEAT  #1
01B98:  MOV.B   [W2++],[W1++]
01B9A:  MOV     W5,FEA
....................  
....................         do      //test each possible boot sector (FAT32 can have backup boot sectors) 
....................         { 
....................  
....................             //Verify the Boot Sector has a valid signature 
....................             if(    (BSec->Signature0 != FAT_GOOD_SIGN_0) 
....................                 || (BSec->Signature1 != FAT_GOOD_SIGN_1) 
01B9C:  MOV     #1FE,W4
01B9E:  MOV     FEA,W3
01BA0:  ADD     W3,W4,W0
01BA2:  MOV     #A,W1
01BA4:  MOV     W0,W2
01BA6:  MOV.B   [W2++],[W1++]
01BA8:  MOV     #55,W4
01BAA:  CP.B    W4L,W5L
01BAC:  BRA     NZ,1BC0
01BAE:  MOV     #1FF,W4
01BB0:  MOV     FEA,W3
01BB2:  ADD     W3,W4,W0
01BB4:  MOV     #A,W1
01BB6:  MOV     W0,W2
01BB8:  MOV.B   [W2++],[W1++]
01BBA:  MOV     #AA,W4
01BBC:  CP.B    W4L,W5L
01BBE:  BRA     Z,1BC8
....................               ) 
....................             { 
....................                 error = CE_NOT_FORMATTED; 
01BC0:  MOV.B   #3,W0L
01BC2:  MOV.B   W0L,FE8
....................             } 
01BC4:  GOTO    1F22
....................             else 
....................             { 
....................  
....................                 do      //loop just to allow a break to jump out of this section of code 
....................                 { 
....................                     #ifdef __18CXX 
....................                     // Load count of sectors per cluster 
....................                     dsk->SecPerClus = BSec->FAT.FAT_16.BootSec_SPC; 
....................                     // Load the sector number of the first FAT sector 
....................                     dsk->fat        = dsk->firsts + BSec->FAT.FAT_16.BootSec_ResrvSec; 
....................                     // Load the count of FAT tables 
....................                     dsk->fatcopy    = BSec->FAT.FAT_16.BootSec_FATCount; 
....................                     // Load the size of the FATs 
....................                     dsk->fatsize = BSec->FAT.FAT_16.BootSec_SPF; 
....................                     if(dsk->fatsize == 0) 
....................                         dsk->fatsize  = BSec->FAT.FAT_32.BootSec_FATSz32; 
....................                     // Calculate the location of the root sector (for FAT12/16) 
....................                     dsk->root = dsk->fat + (DWORD)(dsk->fatcopy * (DWORD)dsk->fatsize); 
....................                     // Determine the max size of the root (will be 0 for FAT32) 
....................                     dsk->maxroot    = BSec->FAT.FAT_16.BootSec_RootDirEnts; 
....................  
....................                     // Determine the total number of sectors in the partition 
....................                     if(BSec->FAT.FAT_16.BootSec_TotSec16 != 0) 
....................                     { 
....................                         TotSec = BSec->FAT.FAT_16.BootSec_TotSec16; 
....................                     } 
....................                     else 
....................                     { 
....................                         TotSec = BSec->FAT.FAT_16.BootSec_TotSec32; 
....................                     } 
....................  
....................                     // Calculate the number of bytes in each sector 
....................                     BytesPerSec = BSec->FAT.FAT_16.BootSec_BPS; 
....................                     if( (BytesPerSec == 0) || ((BytesPerSec & 1) == 1) ) 
....................                     { 
....................                         error = CE_UNSUPPORTED_SECTOR_SIZE; 
....................                         break;  //break out of the do while loop 
....................                     } 
....................  
....................                     // Calculate the number of sectors in the root (will be 0 for FAT32) 
....................                     RootDirSectors = ((BSec->FAT.FAT_16.BootSec_RootDirEnts * 32) + (BSec->FAT.FAT_16.BootSec_BPS - 1)) / BSec->FAT.FAT_16.BootSec_BPS; 
....................                     // Calculate the number of data sectors on the card 
....................                     DataSec = TotSec - (dsk->root + RootDirSectors); 
....................                     // Calculate the maximum number of clusters on the card 
....................                     dsk->maxcls = DataSec / dsk->SecPerClus; 
....................  
....................                     #else // PIC24/30/33 
....................  
....................                     // Read the count of reserved sectors 
....................                     ReservedSectorCount = ReadWord( dsk->buffer, BSI_RESRVSEC ); 
01BC8:  MOV     FDA,W4
01BCA:  ADD     W4,#0,W4
01BCC:  MOV     W4,W0
01BCE:  MOV     #A,W1
01BD0:  MOV     W0,W2
01BD2:  REPEAT  #1
01BD4:  MOV.B   [W2++],[W1++]
01BD6:  MOV     W5,100A
01BD8:  MOV     #E,W4
01BDA:  MOV     W4,100C
01BDC:  CALL    1A66
01BE0:  MOV     W0,FEE
....................                     // Load the count of sectors per cluster 
....................                     dsk->SecPerClus = ReadByte( dsk->buffer, BSI_SPC ); 
01BE2:  MOV     #21,W4
01BE4:  MOV     FDA,W3
01BE6:  ADD     W3,W4,W0
01BE8:  MOV     W0,W5
01BEA:  MOV     FDA,W4
01BEC:  ADD     W4,#0,W4
01BEE:  MOV     W4,W0
01BF0:  MOV     #C,W1
01BF2:  MOV     W0,W2
01BF4:  REPEAT  #1
01BF6:  MOV.B   [W2++],[W1++]
01BF8:  MOV     W6,FF6
01BFA:  MOV     #D,W4
01BFC:  MOV     W4,FF8
01BFE:  CALL    1776
01C02:  MOV.B   W0L,W7L
01C04:  MOV     W5,W1
01C06:  MOV     #E,W2
01C08:  MOV.B   [W2++],[W1++]
....................                     // Load the sector number of the first FAT sector 
....................                     dsk->fat = dsk->firsts + ReservedSectorCount; 
01C0A:  MOV     FDA,W4
01C0C:  ADD     W4,#6,W4
01C0E:  MOV     W4,W0
01C10:  MOV     W0,W5
01C12:  MOV     FDA,W4
01C14:  ADD     W4,#2,W4
01C16:  MOV     W4,W0
01C18:  MOV     #C,W1
01C1A:  MOV     W0,W2
01C1C:  REPEAT  #3
01C1E:  MOV.B   [W2++],[W1++]
01C20:  MOV     W6,W0
01C22:  ADD     FEE,W0
01C24:  ADDC    W7,#0,W7
01C26:  MOV     W7,W1
01C28:  MOV.D   W0,W6
01C2A:  MOV     W5,W1
01C2C:  MOV     #C,W2
01C2E:  REPEAT  #3
01C30:  MOV.B   [W2++],[W1++]
....................                     // Load the count of FAT tables 
....................                     dsk->fatcopy    = ReadByte( dsk->buffer, BSI_FATCOUNT ); 
01C32:  MOV     #20,W4
01C34:  MOV     FDA,W3
01C36:  ADD     W3,W4,W0
01C38:  MOV     W0,W5
01C3A:  MOV     FDA,W4
01C3C:  ADD     W4,#0,W4
01C3E:  MOV     W4,W0
01C40:  MOV     #C,W1
01C42:  MOV     W0,W2
01C44:  REPEAT  #1
01C46:  MOV.B   [W2++],[W1++]
01C48:  MOV     W6,FF6
01C4A:  MOV     #10,W4
01C4C:  MOV     W4,FF8
01C4E:  CALL    1776
01C52:  MOV.B   W0L,W7L
01C54:  MOV     W5,W1
01C56:  MOV     #E,W2
01C58:  MOV.B   [W2++],[W1++]
....................                     // Load the size of the FATs 
....................                     dsk->fatsize = ReadWord( dsk->buffer, BSI_SPF ); 
01C5A:  MOV     FDA,W4
01C5C:  ADD     W4,#1C,W4
01C5E:  MOV     W4,W0
01C60:  MOV     W0,W5
01C62:  MOV     FDA,W4
01C64:  ADD     W4,#0,W4
01C66:  MOV     W4,W0
01C68:  MOV     #C,W1
01C6A:  MOV     W0,W2
01C6C:  REPEAT  #1
01C6E:  MOV.B   [W2++],[W1++]
01C70:  MOV     W6,100A
01C72:  MOV     #16,W4
01C74:  MOV     W4,100C
01C76:  CALL    1A66
01C7A:  MOV     W0,W7
01C7C:  MOV     #0,W8
01C7E:  MOV     W5,W1
01C80:  MOV     #E,W2
01C82:  REPEAT  #1
01C84:  MOV.B   [W2++],[W1++]
01C86:  CLR.B   [W1++]
01C88:  CLR.B   [W1++]
....................                     if(dsk->fatsize == 0) 
01C8A:  MOV     FDA,W4
01C8C:  ADD     W4,#1C,W4
01C8E:  MOV     W4,W0
01C90:  MOV     #A,W1
01C92:  MOV     W0,W2
01C94:  REPEAT  #3
01C96:  MOV.B   [W2++],[W1++]
01C98:  CP0     W5
01C9A:  BRA     NZ,1CCC
01C9C:  CP0     W6
01C9E:  BRA     NZ,1CCC
....................                         dsk->fatsize  = ReadDWord( dsk->buffer, BSI_FATSZ32 ); 
01CA0:  MOV     FDA,W4
01CA2:  ADD     W4,#1C,W4
01CA4:  MOV     W4,W0
01CA6:  MOV     W0,W5
01CA8:  MOV     FDA,W4
01CAA:  ADD     W4,#0,W4
01CAC:  MOV     W4,W0
01CAE:  MOV     #C,W1
01CB0:  MOV     W0,W2
01CB2:  REPEAT  #1
01CB4:  MOV.B   [W2++],[W1++]
01CB6:  MOV     W6,FF6
01CB8:  MOV     #24,W4
01CBA:  MOV     W4,FF8
01CBC:  CALL    1AA4
01CC0:  MOV     W0,W7
01CC2:  MOV     W1,W8
01CC4:  MOV     W5,W1
01CC6:  MOV     #E,W2
01CC8:  REPEAT  #3
01CCA:  MOV.B   [W2++],[W1++]
....................                     // Calculate the location of the root sector (for FAT12/16) 
....................                     dsk->root = dsk->fat + (DWORD)(dsk->fatcopy * (DWORD)dsk->fatsize); 
01CCC:  MOV     FDA,W4
01CCE:  ADD     W4,#A,W4
01CD0:  MOV     W4,W0
01CD2:  MOV     W0,W5
01CD4:  MOV     FDA,W4
01CD6:  ADD     W4,#6,W4
01CD8:  MOV     W4,W0
01CDA:  MOV     #C,W1
01CDC:  MOV     W0,W2
01CDE:  REPEAT  #3
01CE0:  MOV.B   [W2++],[W1++]
01CE2:  MOV     #20,W4
01CE4:  MOV     FDA,W3
01CE6:  ADD     W3,W4,W0
01CE8:  MOV     #10,W1
01CEA:  MOV     W0,W2
01CEC:  MOV.B   [W2++],[W1++]
01CEE:  MOV     FDA,W4
01CF0:  ADD     W4,#1C,W4
01CF2:  MOV     W4,W0
01CF4:  MOV     #12,W1
01CF6:  MOV     W0,W2
01CF8:  REPEAT  #3
01CFA:  MOV.B   [W2++],[W1++]
01CFC:  MOV     #0,W1
01CFE:  MOV.B   W8L,W0L
01D00:  CLR.B   1
01D02:  MOV     W9,W2
01D04:  MOV     W10,W3
01D06:  CALL    10CE
01D0A:  ADD     W0,W6,W0
01D0C:  ADDC    W1,W7,W1
01D0E:  MOV.D   W0,W6
01D10:  MOV     W5,W1
01D12:  MOV     #C,W2
01D14:  REPEAT  #3
01D16:  MOV.B   [W2++],[W1++]
....................                     // Determine the max size of the root (will be 0 for FAT32) 
....................                     dsk->maxroot = ReadWord( dsk->buffer, BSI_ROOTDIRENTS ); 
01D18:  MOV     FDA,W4
01D1A:  ADD     W4,#12,W4
01D1C:  MOV     W4,W0
01D1E:  MOV     W0,W5
01D20:  MOV     FDA,W4
01D22:  ADD     W4,#0,W4
01D24:  MOV     W4,W0
01D26:  MOV     #C,W1
01D28:  MOV     W0,W2
01D2A:  REPEAT  #1
01D2C:  MOV.B   [W2++],[W1++]
01D2E:  MOV     W6,100A
01D30:  MOV     #11,W4
01D32:  MOV     W4,100C
01D34:  CALL    1A66
01D38:  MOV     W0,W7
01D3A:  MOV     W5,W1
01D3C:  MOV     #E,W2
01D3E:  REPEAT  #1
01D40:  MOV.B   [W2++],[W1++]
....................  
....................                     // Determine the total number of sectors in the partition 
....................                     TotSec = ReadWord( dsk->buffer, BSI_TOTSEC16 ); 
01D42:  MOV     FDA,W4
01D44:  ADD     W4,#0,W4
01D46:  MOV     W4,W0
01D48:  MOV     #A,W1
01D4A:  MOV     W0,W2
01D4C:  REPEAT  #1
01D4E:  MOV.B   [W2++],[W1++]
01D50:  MOV     W5,100A
01D52:  MOV     #13,W4
01D54:  MOV     W4,100C
01D56:  CALL    1A66
01D5A:  MOV     W0,FE0
01D5C:  CLR     FE2
....................                     if( TotSec == 0 ) 
01D5E:  CP0     FE0
01D60:  BRA     NZ,1D82
01D62:  CP0     FE2
01D64:  BRA     NZ,1D82
....................                         TotSec = ReadDWord( dsk->buffer, BSI_TOTSEC32 ); 
01D66:  MOV     FDA,W4
01D68:  ADD     W4,#0,W4
01D6A:  MOV     W4,W0
01D6C:  MOV     #A,W1
01D6E:  MOV     W0,W2
01D70:  REPEAT  #1
01D72:  MOV.B   [W2++],[W1++]
01D74:  MOV     W5,FF6
01D76:  MOV     #20,W4
01D78:  MOV     W4,FF8
01D7A:  CALL    1AA4
01D7E:  MOV     W0,FE0
01D80:  MOV     W1,FE2
....................  
....................                     // Calculate the number of bytes in each sector 
....................                     BytesPerSec = ReadWord( dsk->buffer, BSI_BPS ); 
01D82:  MOV     FDA,W4
01D84:  ADD     W4,#0,W4
01D86:  MOV     W4,W0
01D88:  MOV     #A,W1
01D8A:  MOV     W0,W2
01D8C:  REPEAT  #1
01D8E:  MOV.B   [W2++],[W1++]
01D90:  MOV     W5,100A
01D92:  MOV     #B,W4
01D94:  MOV     W4,100C
01D96:  CALL    1A66
01D9A:  MOV     W0,FEC
....................                     if( (BytesPerSec == 0) || ((BytesPerSec & 1) == 1) ) 
01D9C:  CP0     FEC
01D9E:  BRA     Z,1DA8
01DA0:  MOV     FEC,W0
01DA2:  AND     W0,#1,W5
01DA4:  CP      W5,#1
01DA6:  BRA     NZ,1DB0
....................                     { 
....................                         error = CE_UNSUPPORTED_SECTOR_SIZE; 
01DA8:  MOV.B   #21,W0L
01DAA:  MOV.B   W0L,FE8
....................                         break; 
01DAC:  GOTO    1F22
....................                     } 
....................  
....................                     // Calculate the number of sectors in the root (will be 0 for FAT32) 
....................                     RootDirSectors = ((dsk->maxroot * NUMBER_OF_BYTES_IN_DIR_ENTRY) + (BytesPerSec - 1)) / BytesPerSec; 
01DB0:  MOV     FDA,W4
01DB2:  ADD     W4,#12,W4
01DB4:  MOV     W4,W0
01DB6:  MOV     #A,W1
01DB8:  MOV     W0,W2
01DBA:  REPEAT  #1
01DBC:  MOV.B   [W2++],[W1++]
01DBE:  SL      W5,#5,W5
01DC0:  MOV     FEC,W4
01DC2:  SUB     W4,#1,W0
01DC4:  ADD     W0,W5,W5
01DC6:  MOV     W5,W4
01DC8:  MOV     FEC,W3
01DCA:  REPEAT  #11
01DCC:  DIV.U   W4,W3
01DCE:  MOV     W0,FDC
01DD0:  CLR     FDE
....................                     // Calculate the number of data sectors on the card 
....................                     DataSec = TotSec - (ReservedSectorCount + (dsk->fatcopy * dsk->fatsize )  + RootDirSectors); 
01DD2:  MOV     #20,W4
01DD4:  MOV     FDA,W3
01DD6:  ADD     W3,W4,W0
01DD8:  MOV     #A,W1
01DDA:  MOV     W0,W2
01DDC:  MOV.B   [W2++],[W1++]
01DDE:  MOV     FDA,W4
01DE0:  ADD     W4,#1C,W4
01DE2:  MOV     W4,W0
01DE4:  MOV     #C,W1
01DE6:  MOV     W0,W2
01DE8:  REPEAT  #3
01DEA:  MOV.B   [W2++],[W1++]
01DEC:  MOV     #0,W1
01DEE:  MOV.B   W5L,W0L
01DF0:  CLR.B   1
01DF2:  MOV     W6,W2
01DF4:  MOV     W7,W3
01DF6:  CALL    10CE
01DFA:  MOV     FEE,W4
01DFC:  ADD     W0,W4,W5
01DFE:  ADDC    W1,#0,W1
01E00:  MOV     W1,W6
01E02:  MOV     W5,W0
01E04:  ADD     FDC,W0
01E06:  MOV     FDE,W4
01E08:  ADDC    W6,W4,W1
01E0A:  MOV     FE0,W4
01E0C:  SUB     W4,W0,W0
01E0E:  MOV     W0,FE4
01E10:  MOV     FE2,W4
01E12:  SUBB    W4,W1,W0
01E14:  MOV     W0,FE6
....................                     // Calculate the maximum number of clusters on the card 
....................                     dsk->maxcls = DataSec / dsk->SecPerClus; 
01E16:  MOV     FDA,W4
01E18:  ADD     W4,#14,W4
01E1A:  MOV     W4,W0
01E1C:  MOV     W0,W5
01E1E:  MOV     #21,W4
01E20:  MOV     FDA,W3
01E22:  ADD     W3,W4,W0
01E24:  MOV     #C,W1
01E26:  MOV     W0,W2
01E28:  MOV.B   [W2++],[W1++]
01E2A:  BCLR.B  43.0
01E2C:  MOV.B   W6L,W2L
01E2E:  CLR.B   5
01E30:  MOV     #0,W3
01E32:  MOV     FE4,W0
01E34:  MOV     FE6,W1
01E36:  CALL    1AE6
01E3A:  MOV     W0,W7
01E3C:  MOV     W1,W8
01E3E:  MOV     W5,W1
01E40:  MOV     #E,W2
01E42:  REPEAT  #3
01E44:  MOV.B   [W2++],[W1++]
....................  
....................                     #endif 
....................  
....................                     // Determine the file system type based on the number of clusters used 
....................                     #ifdef SUPPORT_FAT12 
....................                     if(dsk->maxcls < 4085) 
....................                     { 
....................                         dsk->type = FAT12; 
....................                     } 
....................                     else 
....................                     #endif 
....................                     { 
....................                         if(dsk->maxcls < 65525) 
01E46:  MOV     FDA,W4
01E48:  ADD     W4,#14,W4
01E4A:  MOV     W4,W0
01E4C:  MOV     #A,W1
01E4E:  MOV     W0,W2
01E50:  REPEAT  #3
01E52:  MOV.B   [W2++],[W1++]
01E54:  CP      W6,#0
01E56:  BRA     GTU,1E74
01E58:  BRA     NC,1E60
01E5A:  MOV     #FFF5,W4
01E5C:  CP      W4,W5
01E5E:  BRA     LEU,1E74
....................                         { 
....................                             dsk->type = FAT16; 
01E60:  MOV     #22,W4
01E62:  MOV     FDA,W3
01E64:  ADD     W3,W4,W0
01E66:  MOV     W0,W5
01E68:  MOV.B   #2,W6L
01E6A:  MOV     W5,W1
01E6C:  MOV     #C,W2
01E6E:  MOV.B   [W2++],[W1++]
....................                         } 
01E70:  GOTO    1E84
....................                         else 
....................                         { 
....................                             #ifdef SUPPORT_FAT32 
....................                                 dsk->type = FAT32; 
01E74:  MOV     #22,W4
01E76:  MOV     FDA,W3
01E78:  ADD     W3,W4,W0
01E7A:  MOV     W0,W5
01E7C:  MOV.B   #3,W6L
01E7E:  MOV     W5,W1
01E80:  MOV     #C,W2
01E82:  MOV.B   [W2++],[W1++]
....................                             #else 
....................                                 error = CE_CARDFAT32; 
....................                             #endif 
....................                         } 
....................                     } 
....................  
....................                     #ifdef SUPPORT_FAT32 
....................                         if (dsk->type == FAT32) 
01E84:  MOV     #22,W4
01E86:  MOV     FDA,W3
01E88:  ADD     W3,W4,W0
01E8A:  MOV     #A,W1
01E8C:  MOV     W0,W2
01E8E:  MOV.B   [W2++],[W1++]
01E90:  CP.B    W5L,#3
01E92:  BRA     NZ,1EDC
....................                         { 
....................                             #ifdef __18CXX 
....................                                 FatRootDirClusterValue =  BSec->FAT.FAT_32.BootSec_RootClus; 
....................                             #else 
....................                                 FatRootDirClusterValue = ReadDWord( dsk->buffer, BSI_ROOTCLUS ); 
01E94:  MOV     FDA,W4
01E96:  ADD     W4,#0,W4
01E98:  MOV     W4,W0
01E9A:  MOV     #A,W1
01E9C:  MOV     W0,W2
01E9E:  REPEAT  #1
01EA0:  MOV.B   [W2++],[W1++]
01EA2:  MOV     W5,FF6
01EA4:  MOV     #2C,W4
01EA6:  MOV     W4,FF8
01EA8:  CALL    1AA4
01EAC:  MOV     W0,8B2
01EAE:  MOV     W1,8B4
....................                             #endif 
....................                             dsk->data = dsk->root + RootDirSectors; 
01EB0:  MOV     FDA,W4
01EB2:  ADD     W4,#E,W4
01EB4:  MOV     W4,W0
01EB6:  MOV     W0,W5
01EB8:  MOV     FDA,W4
01EBA:  ADD     W4,#A,W4
01EBC:  MOV     W4,W0
01EBE:  MOV     #C,W1
01EC0:  MOV     W0,W2
01EC2:  REPEAT  #3
01EC4:  MOV.B   [W2++],[W1++]
01EC6:  MOV     W6,W0
01EC8:  ADD     FDC,W0
01ECA:  MOV     FDE,W4
01ECC:  ADDC    W7,W4,W1
01ECE:  MOV.D   W0,W6
01ED0:  MOV     W5,W1
01ED2:  MOV     #C,W2
01ED4:  REPEAT  #3
01ED6:  MOV.B   [W2++],[W1++]
....................                         } 
01ED8:  GOTO    1F16
....................                         else 
....................                     #endif 
....................                     { 
....................                         FatRootDirClusterValue = 0; 
01EDC:  CLR     8B2
01EDE:  CLR     8B4
....................                         dsk->data = dsk->root + ( dsk->maxroot >> 4); 
01EE0:  MOV     FDA,W4
01EE2:  ADD     W4,#E,W4
01EE4:  MOV     W4,W0
01EE6:  MOV     W0,W5
01EE8:  MOV     FDA,W4
01EEA:  ADD     W4,#A,W4
01EEC:  MOV     W4,W0
01EEE:  MOV     #C,W1
01EF0:  MOV     W0,W2
01EF2:  REPEAT  #3
01EF4:  MOV.B   [W2++],[W1++]
01EF6:  MOV     FDA,W4
01EF8:  ADD     W4,#12,W4
01EFA:  MOV     W4,W0
01EFC:  MOV     #10,W1
01EFE:  MOV     W0,W2
01F00:  REPEAT  #1
01F02:  MOV.B   [W2++],[W1++]
01F04:  LSR     W8,#4,W0
01F06:  ADD     W0,W6,W0
01F08:  MOV     #0,W4
01F0A:  ADDC    W4,W7,W1
01F0C:  MOV.D   W0,W6
01F0E:  MOV     W5,W1
01F10:  MOV     #C,W2
01F12:  REPEAT  #3
01F14:  MOV.B   [W2++],[W1++]
....................                     } 
....................  
....................                 #ifdef __18CXX 
....................                     if(BSec->FAT.FAT_16.BootSec_BPS > MEDIA_SECTOR_SIZE) 
....................                 #else 
....................                     if(BytesPerSec > MEDIA_SECTOR_SIZE) 
01F16:  MOV     FEC,W4
01F18:  MOV     #200,W3
01F1A:  CP      W3,W4
01F1C:  BRA     C,1F22
....................                 #endif 
....................                     { 
....................                         error = CE_UNSUPPORTED_SECTOR_SIZE; 
01F1E:  MOV.B   #21,W0L
01F20:  MOV.B   W0L,FE8
....................                     } 
....................  
....................                 }while(0);  // do/while loop designed to allow to break out if 
....................                             //   there is an error detected without returning 
....................                             //   from the function. 
....................  
....................             } 
....................  
....................             #if defined(SUPPORT_FAT32) 
....................             if ((dsk->type == FAT32) || ((error != CE_GOOD) && ((BSec->FAT.FAT_32.BootSec_BootSig == 0x29) || (BSec->FAT.FAT_32.BootSec_BootSig == 0x28)))) 
01F22:  MOV     #22,W4
01F24:  MOV     FDA,W3
01F26:  ADD     W3,W4,W0
01F28:  MOV     #A,W1
01F2A:  MOV     W0,W2
01F2C:  MOV.B   [W2++],[W1++]
01F2E:  CP.B    W5L,#3
01F30:  BRA     Z,1F5A
01F32:  CP0.B   FE8
01F34:  BRA     Z,20FC
01F36:  MOV     #42,W4
01F38:  MOV     FEA,W3
01F3A:  ADD     W3,W4,W0
01F3C:  MOV     #A,W1
01F3E:  MOV     W0,W2
01F40:  MOV.B   [W2++],[W1++]
01F42:  MOV     #29,W4
01F44:  CP.B    W4L,W5L
01F46:  BRA     Z,1F5A
01F48:  MOV     #42,W4
01F4A:  MOV     FEA,W3
01F4C:  ADD     W3,W4,W0
01F4E:  MOV     #A,W1
01F50:  MOV     W0,W2
01F52:  MOV.B   [W2++],[W1++]
01F54:  MOV     #28,W4
01F56:  CP.B    W4L,W5L
01F58:  BRA     NZ,20FC
....................             { 
....................                 //Check for possible errors in the formatting 
....................                 if(    (BSec->FAT.FAT_32.BootSec_TotSec16 != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[0] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[1] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[2] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[3] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[4] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[5] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[6] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[7] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[8] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[9] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[10] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[11] != 0) 
....................                     || ((BSec->FAT.FAT_32.BootSec_BootSig != 0x29) && (BSec->FAT.FAT_32.BootSec_BootSig != 0x28)) 
01F5A:  MOV     FEA,W4
01F5C:  ADD     W4,#13,W4
01F5E:  MOV     W4,W0
01F60:  MOV     #A,W1
01F62:  MOV     W0,W2
01F64:  REPEAT  #1
01F66:  MOV.B   [W2++],[W1++]
01F68:  CP0     W5
01F6A:  BRA     NZ,2050
01F6C:  MOV     #34,W4
01F6E:  MOV     FEA,W3
01F70:  ADD     W3,W4,W0
01F72:  MOV     #A,W1
01F74:  MOV     W0,W2
01F76:  MOV.B   [W2++],[W1++]
01F78:  CP0.B   W5L
01F7A:  BRA     NZ,2050
01F7C:  MOV     #35,W4
01F7E:  MOV     FEA,W3
01F80:  ADD     W3,W4,W0
01F82:  MOV     #A,W1
01F84:  MOV     W0,W2
01F86:  MOV.B   [W2++],[W1++]
01F88:  CP0.B   W5L
01F8A:  BRA     NZ,2050
01F8C:  MOV     #36,W4
01F8E:  MOV     FEA,W3
01F90:  ADD     W3,W4,W0
01F92:  MOV     #A,W1
01F94:  MOV     W0,W2
01F96:  MOV.B   [W2++],[W1++]
01F98:  CP0.B   W5L
01F9A:  BRA     NZ,2050
01F9C:  MOV     #37,W4
01F9E:  MOV     FEA,W3
01FA0:  ADD     W3,W4,W0
01FA2:  MOV     #A,W1
01FA4:  MOV     W0,W2
01FA6:  MOV.B   [W2++],[W1++]
01FA8:  CP0.B   W5L
01FAA:  BRA     NZ,2050
01FAC:  MOV     #38,W4
01FAE:  MOV     FEA,W3
01FB0:  ADD     W3,W4,W0
01FB2:  MOV     #A,W1
01FB4:  MOV     W0,W2
01FB6:  MOV.B   [W2++],[W1++]
01FB8:  CP0.B   W5L
01FBA:  BRA     NZ,2050
01FBC:  MOV     #39,W4
01FBE:  MOV     FEA,W3
01FC0:  ADD     W3,W4,W0
01FC2:  MOV     #A,W1
01FC4:  MOV     W0,W2
01FC6:  MOV.B   [W2++],[W1++]
01FC8:  CP0.B   W5L
01FCA:  BRA     NZ,2050
01FCC:  MOV     #3A,W4
01FCE:  MOV     FEA,W3
01FD0:  ADD     W3,W4,W0
01FD2:  MOV     #A,W1
01FD4:  MOV     W0,W2
01FD6:  MOV.B   [W2++],[W1++]
01FD8:  CP0.B   W5L
01FDA:  BRA     NZ,2050
01FDC:  MOV     #3B,W4
01FDE:  MOV     FEA,W3
01FE0:  ADD     W3,W4,W0
01FE2:  MOV     #A,W1
01FE4:  MOV     W0,W2
01FE6:  MOV.B   [W2++],[W1++]
01FE8:  CP0.B   W5L
01FEA:  BRA     NZ,2050
01FEC:  MOV     #3C,W4
01FEE:  MOV     FEA,W3
01FF0:  ADD     W3,W4,W0
01FF2:  MOV     #A,W1
01FF4:  MOV     W0,W2
01FF6:  MOV.B   [W2++],[W1++]
01FF8:  CP0.B   W5L
01FFA:  BRA     NZ,2050
01FFC:  MOV     #3D,W4
01FFE:  MOV     FEA,W3
02000:  ADD     W3,W4,W0
02002:  MOV     #A,W1
02004:  MOV     W0,W2
02006:  MOV.B   [W2++],[W1++]
02008:  CP0.B   W5L
0200A:  BRA     NZ,2050
0200C:  MOV     #3E,W4
0200E:  MOV     FEA,W3
02010:  ADD     W3,W4,W0
02012:  MOV     #A,W1
02014:  MOV     W0,W2
02016:  MOV.B   [W2++],[W1++]
02018:  CP0.B   W5L
0201A:  BRA     NZ,2050
0201C:  MOV     #3F,W4
0201E:  MOV     FEA,W3
02020:  ADD     W3,W4,W0
02022:  MOV     #A,W1
02024:  MOV     W0,W2
02026:  MOV.B   [W2++],[W1++]
02028:  CP0.B   W5L
0202A:  BRA     NZ,2050
0202C:  MOV     #42,W4
0202E:  MOV     FEA,W3
02030:  ADD     W3,W4,W0
02032:  MOV     #A,W1
02034:  MOV     W0,W2
02036:  MOV.B   [W2++],[W1++]
02038:  MOV     #29,W4
0203A:  CP.B    W4L,W5L
0203C:  BRA     Z,2054
0203E:  MOV     #42,W4
02040:  MOV     FEA,W3
02042:  ADD     W3,W4,W0
02044:  MOV     #A,W1
02046:  MOV     W0,W2
02048:  MOV.B   [W2++],[W1++]
0204A:  MOV     #28,W4
0204C:  CP.B    W4L,W5L
0204E:  BRA     Z,2054
....................                   ) 
....................                 { 
....................                     error = CE_NOT_FORMATTED; 
02050:  MOV.B   #3,W0L
02052:  MOV.B   W0L,FE8
....................                 } 
....................  
....................                 //If there were formatting errors then in FAT32 we can try to use 
....................                 //  the backup boot sector 
....................                 if((error != CE_GOOD) && (TriedSpecifiedBackupBootSec == FALSE)) 
02054:  CP0.B   FE8
02056:  BRA     Z,20B0
02058:  BTSC.B  FE9.0
0205A:  BRA     20B0
....................                 { 
....................                     TriedSpecifiedBackupBootSec = TRUE; 
0205C:  BSET.B  FE9.0
....................  
....................                     if ( MDD_SectorRead( dsk->firsts + BSec->FAT.FAT_32.BootSec_BkBootSec, dsk->buffer) != TRUE) 
0205E:  MOV     FDA,W4
02060:  ADD     W4,#2,W4
02062:  MOV     W4,W0
02064:  MOV     #A,W1
02066:  MOV     W0,W2
02068:  REPEAT  #3
0206A:  MOV.B   [W2++],[W1++]
0206C:  MOV     #32,W4
0206E:  MOV     FEA,W3
02070:  ADD     W3,W4,W0
02072:  MOV     #E,W1
02074:  MOV     W0,W2
02076:  REPEAT  #1
02078:  MOV.B   [W2++],[W1++]
0207A:  ADD     W7,W5,W5
0207C:  MOV     #0,W4
0207E:  ADDC    W4,W6,W6
02080:  MOV     FDA,W4
02082:  ADD     W4,#0,W4
02084:  MOV     W4,W0
02086:  MOV     #10,W1
02088:  MOV     W0,W2
0208A:  REPEAT  #1
0208C:  MOV.B   [W2++],[W1++]
0208E:  MOV     W5,10F2
02090:  MOV     W6,10F4
02092:  MOV     W8,10F6
02094:  CALL    1722
02098:  CP.B    W0L,#1
0209A:  BRA     Z,20AA
....................                     { 
....................                         FSerrno = CE_BAD_SECTOR_READ; 
0209C:  MOV.B   #8,W0L
0209E:  MOV.B   W0L,8B1
....................                         return CE_BAD_SECTOR_READ; 
020A0:  MOV.B   #8,W0L
020A2:  MOV.B   W0L,0
020A4:  BRA     2110
....................                     } 
020A6:  GOTO    20B0
....................                     else 
....................                     { 
....................                         error = CE_GOOD; 
020AA:  CLR.B   FE8
....................                         continue; 
020AC:  GOTO    2100
....................                     } 
....................                 } 
....................  
....................                 if((error != CE_GOOD) && (TriedBackupBootSecAtAddress6 == FALSE)) 
020B0:  CP0.B   FE8
020B2:  BRA     Z,20FC
020B4:  BTSC.B  FE9.1
020B6:  BRA     20FC
....................                 { 
....................                     TriedBackupBootSecAtAddress6 = TRUE; 
020B8:  BSET.B  FE9.1
....................  
....................                     //Here we are using the magic number 6 because the FAT32 specification 
....................                     //  recommends that "No value other than 6 is recommended."  We've 
....................                     //  already tried using the value specified in the BPB_BkBootSec 
....................                     //  field and it must have failed 
....................                     if ( MDD_SectorRead( dsk->firsts + 6, dsk->buffer) != TRUE) 
020BA:  MOV     FDA,W4
020BC:  ADD     W4,#2,W4
020BE:  MOV     W4,W0
020C0:  MOV     #A,W1
020C2:  MOV     W0,W2
020C4:  REPEAT  #3
020C6:  MOV.B   [W2++],[W1++]
020C8:  ADD     W5,#6,W5
020CA:  ADDC    W6,#0,W6
020CC:  MOV     FDA,W4
020CE:  ADD     W4,#0,W4
020D0:  MOV     W4,W0
020D2:  MOV     #E,W1
020D4:  MOV     W0,W2
020D6:  REPEAT  #1
020D8:  MOV.B   [W2++],[W1++]
020DA:  MOV     W5,10F2
020DC:  MOV     W6,10F4
020DE:  MOV     W7,10F6
020E0:  CALL    1722
020E4:  CP.B    W0L,#1
020E6:  BRA     Z,20F6
....................                     { 
....................                         FSerrno = CE_BAD_SECTOR_READ; 
020E8:  MOV.B   #8,W0L
020EA:  MOV.B   W0L,8B1
....................                         return CE_BAD_SECTOR_READ; 
020EC:  MOV.B   #8,W0L
020EE:  MOV.B   W0L,0
020F0:  BRA     2110
....................                     } 
020F2:  GOTO    20FC
....................                     else 
....................                     { 
....................                         error = CE_GOOD; 
020F6:  CLR.B   FE8
....................                         continue; 
020F8:  GOTO    2100
....................                     } 
....................                 } 
....................  
....................             }   //type == FAT32 
....................             #endif  //SUPPORT_FAT32 
....................             break; 
020FC:  GOTO    2104
....................         } 
....................         while(1); 
02100:  GOTO    1B9C
....................     } 
....................  
....................     if(error != CE_GOOD) 
02104:  CP0.B   FE8
02106:  BRA     Z,210C
....................     { 
....................         FSerrno = error; 
02108:  MOV.B   FE8,W0L
0210A:  MOV.B   W0L,8B1
....................     } 
....................  
....................     return(error); 
0210C:  MOV.B   FE8,W0L
0210E:  MOV.B   W0L,0
02110:  MOV     #14,W5
02112:  REPEAT  #4
02114:  MOV     [--W15],[W5--]
02116:  MOV     [--W15],W5
02118:  RETURN  
.................... } 
....................  
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     DWORD GetFullClusterNumber (DIRENTRY entry) 
....................   Summary: 
....................     Gets the cluster number from a directory entry 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     entry - The cached directory entry to get the cluster number from 
....................   Returns: 
....................     The cluster value from the passed directory entry 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     This function will load both the high and low 16-bit first cluster 
....................     values of a file from a directory entry and copy them into a 32-bit 
....................     cluster number variable, which will be returned. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... DWORD GetFullClusterNumber(DIRENTRY entry) 
*
034B4:  CLR     1086
034B6:  CLR     1088
.................... { 
....................  
....................     DWORD TempFullClusterCalc = 0; 
....................  
.................... #ifndef SUPPORT_FAT32 // If FAT32 Not supported. 
....................     entry->DIR_FstClusHI = 0; // If FAT32 is not supported then Higher Word of the address is "0" 
.................... #endif 
....................  
....................     // Get the cluster 
....................     TempFullClusterCalc = (entry->DIR_FstClusHI); 
034B8:  MOV     #14,W0
034BA:  ADD     1084,W0
034BC:  MOV     [W0],[W15++]
034BE:  POP     1086
034C0:  CLR     1088
....................     TempFullClusterCalc = TempFullClusterCalc << 16; 
034C2:  PUSH    1086
034C4:  POP     1088
034C6:  CLR     1086
....................     TempFullClusterCalc |= entry->DIR_FstClusLO; 
034C8:  MOV     #1A,W0
034CA:  ADD     1084,W0
034CC:  MOV     W0,W4
034CE:  MOV     [W4],W0
034D0:  IOR     1086
....................  
....................     return TempFullClusterCalc; 
034D2:  MOV     1086,W0
034D4:  MOV     1088,W1
034D6:  RETURN  
.................... } 
....................  
....................  
.................... #ifdef ALLOW_FORMATS 
.................... #ifdef ALLOW_WRITES 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     int FSCreateMBR (unsigned long firstSector, unsigned long numSectors) 
....................   Summary: 
....................     Creates a master boot record 
....................   Conditions: 
....................     The I/O pins for the device have been initialized by the InitIO function. 
....................   Input: 
....................     firstSector -  The first sector of the partition on the device (cannot 
....................                    be 0; that's the MBR) 
....................     numSectors -   The number of sectors available in memory (including the 
....................                    MBR) 
....................   Return Values: 
....................     0 -   MBR was created successfully 
....................     EOF - MBR could not be created 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function can be used to create a master boot record for a device.  Note 
....................     that this function should not be used on a device that is already formatted 
....................     with a master boot record (i.e. most SD cards, CF cards, USB keys).  This 
....................     function will fill the global data buffer with appropriate partition information 
....................     for a FAT partition with a type determined by the number of sectors available 
....................     to the partition.  It will then write the MBR information to the first sector 
....................     on the device.  This function should be followed by a call to FSformat, which 
....................     will create a boot sector, root dir, and FAT appropriate the the information 
....................     contained in the new master boot record.  Note that FSformat only supports 
....................     FAT12 and FAT16 formatting at this time, and so cannot be used to format a 
....................     device with more than 0x3FFD5F sectors. 
....................   Remarks: 
....................     This function can damage the device being used, and should not be called 
....................     unless the user is sure about the size of the device and the first sector value. 
....................   *********************************************************************************/ 
....................  
.................... int FSCreateMBR (unsigned long firstSector, unsigned long numSectors) 
.................... { 
....................     PT_MBR  Partition; 
....................     DWORD CyHdSc = 0x00000000; 
....................     DWORD tempSector; 
....................  
....................     if ((firstSector == 0) || (numSectors <= 1)) 
....................         return EOF; 
....................  
....................     if (firstSector > (numSectors - 1)) 
....................         return EOF; 
....................  
....................     if (gNeedDataWrite) 
....................         if (flushData()) 
....................             return EOF; 
....................  
....................     memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE); 
....................  
....................     Partition = (PT_MBR) gDataBuffer; 
....................  
....................     // Set Cylinder-head-sector address of the first sector 
....................     tempSector = firstSector; 
....................     CyHdSc = (tempSector / (unsigned int)16065 ) << 14; 
....................     tempSector %= 16065; 
....................     CyHdSc |= (tempSector / 63) << 6; 
....................     tempSector %= 63; 
....................     CyHdSc |= tempSector + 1; 
....................     gDataBuffer[447] = (BYTE)((CyHdSc >> 16) & 0xFF); 
....................     gDataBuffer[448] = (BYTE)((CyHdSc >> 8) & 0xFF); 
....................     gDataBuffer[449] = (BYTE)((CyHdSc) & 0xFF); 
....................  
....................     // Set the count of sectors 
....................     Partition->Partition0.PTE_NumSect = numSectors - firstSector; 
....................  
....................     // Set the partition type 
....................     // We only support creating FAT12 and FAT16 MBRs at this time 
....................     if (Partition->Partition0.PTE_NumSect < 0x1039) 
....................     { 
....................         // FAT12 
....................         Partition->Partition0.PTE_FSDesc = 0x01; 
....................     } 
....................     else if (Partition->Partition0.PTE_NumSect <= 0x3FFD5F) 
....................     { 
....................         // FAT16 
....................         Partition->Partition0.PTE_FSDesc = 0x06; 
....................     } 
....................     else 
....................         return EOF; 
....................  
....................     // Set the LBA of the first sector 
....................     Partition->Partition0.PTE_FrstSect = firstSector; 
....................  
....................     // Set the Cylinder-head-sector address of the last sector 
....................     tempSector = firstSector + numSectors - 1; 
....................     CyHdSc = (tempSector / (unsigned int)16065 ) << 14; 
....................     tempSector %= 16065; 
....................     CyHdSc |= (tempSector / 63) << 6; 
....................     tempSector %= 63; 
....................     CyHdSc |= tempSector + 1; 
....................     gDataBuffer[451] = (BYTE)((CyHdSc >> 16) & 0xFF); 
....................     gDataBuffer[452] = (BYTE)((CyHdSc >> 8) & 0xFF); 
....................     gDataBuffer[453] = (BYTE)((CyHdSc) & 0xFF); 
....................  
....................     // Set the boot descriptor.  This will be 0, since we won't 
....................     // be booting anything from our device probably 
....................     Partition->Partition0.PTE_BootDes = 0x00; 
....................  
....................     // Set the signature codes 
....................     Partition->Signature0 = 0x55; 
....................     Partition->Signature1 = 0xAA; 
....................  
....................     if (MDD_SectorWrite (0x00, gDataBuffer, TRUE) != TRUE) 
....................         return EOF; 
....................     else 
....................         return 0; 
....................  
.................... } 
....................  
....................  
.................... /******************************************************************* 
....................   Function: 
....................     int FSformat (char mode, long int serialNumber, char * volumeID) 
....................   Summary: 
....................     Formats a device 
....................   Conditions: 
....................     The device must possess a valid master boot record. 
....................   Input: 
....................     mode -          - 0 - Just erase the FAT and root 
....................                     - 1 - Create a new boot sector 
....................     serialNumber -  Serial number to write to the card 
....................     volumeID -      Name of the card 
....................   Return Values: 
....................     0 -    Format was successful 
....................     EOF -  Format was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSformat function can be used to create a new boot sector 
....................     on a device, based on the information in the master boot record. 
....................     This function will first initialize the I/O pins and the device, 
....................     and then attempts to read the master boot record.  If the MBR 
....................     cannot be loaded successfully, the function will fail.  Next, if 
....................     the 'mode' argument is specified as '0' the existing boot sector 
....................     information will be loaded.  If the 'mode' argument is '1' an 
....................     entirely new boot sector will be constructed using the disk 
....................     values from the master boot record.  Once the boot sector has 
....................     been successfully loaded/created, the locations of the FAT and 
....................     root will be loaded from it, and they will be completely 
....................     erased.  If the user has specified a volumeID parameter, a 
....................     VOLUME attribute entry will be created in the root directory 
....................     to name the device. 
....................  
....................     FAT12, FAT16 and FAT32 formatting are supported. 
....................  
....................     Based on the number of sectors, the format function automatically 
....................     compute the smallest possible value for the cluster size in order to 
....................     accommodate the physical size of the media. In this case, if a media 
....................     with a big capacity is formatted, the format function may take a very 
....................     long time to write all the FAT tables. 
....................  
....................     Therefore, the FORMAT_SECTORS_PER_CLUSTER macro may be used to 
....................     specify the exact cluster size (in multiples of sector size). This 
....................     macro can be defined in FSconfig.h 
....................  
....................   Remarks: 
....................     Only devices with a sector size of 512 bytes are supported by the 
....................     format function 
....................   *******************************************************************/ 
....................  
.................... int FSformat (char mode, long int serialNumber, char * volumeID) 
.................... { 
....................     PT_MBR   masterBootRecord; 
....................     DWORD    secCount, DataClusters, RootDirSectors; 
....................     BootSec   BSec; 
....................     DISK   d; 
....................     DISK * disk = &d; 
....................     WORD    j; 
....................     DWORD   fatsize, test; 
....................     DWORD Index; 
....................     MEDIA_INFORMATION * mediaInfo; 
.................... #ifdef __18CXX 
....................     // This is here because of a C18 compiler feature 
....................     BYTE *  dataBufferPointer = gDataBuffer; 
.................... #endif 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................     gBufferZeroed = FALSE; 
....................     gNeedFATWrite = FALSE; 
....................     gLastFATSectorRead = 0xFFFFFFFF; 
....................     gLastDataSectorRead = 0xFFFFFFFF; 
....................  
....................     disk->buffer = gDataBuffer; 
....................  
....................     MDD_InitIO(); 
....................  
....................     mediaInfo = MDD_MediaInitialize(); 
....................     if (mediaInfo->errorCode != MEDIA_NO_ERROR) 
....................     { 
....................         FSerrno = CE_INIT_ERROR; 
....................         return EOF; 
....................     } 
....................  
....................     if (MDD_SectorRead (0x00, gDataBuffer) == FALSE) 
....................     { 
....................         FSerrno = CE_BADCACHEREAD; 
....................         return EOF; 
....................     } 
....................  
....................     // Check if the card has no MBR 
....................     BSec = (BootSec) disk->buffer; 
....................     if((BSec->Signature0 == FAT_GOOD_SIGN_0) && (BSec->Signature1 == FAT_GOOD_SIGN_1)) 
....................     { 
....................         // Technically, the OEM name is not for indication 
....................         // The alternative is to read the CIS from attribute 
....................         // memory.  See the PCMCIA metaformat for more details 
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................         if ((ReadByte( disk->buffer, BSI_FSTYPE ) == 'F') && \ 
....................             (ReadByte( disk->buffer, BSI_FSTYPE + 1 ) == 'A') && \ 
....................             (ReadByte( disk->buffer, BSI_FSTYPE + 2 ) == 'T') && \ 
....................             (ReadByte( disk->buffer, BSI_FSTYPE + 3 ) == '1') && \ 
....................             (ReadByte( disk->buffer, BSI_BOOTSIG) == 0x29)) 
.................... #else 
....................         if ((BSec->FAT.FAT_16.BootSec_FSType[0] == 'F') && \ 
....................             (BSec->FAT.FAT_16.BootSec_FSType[1] == 'A') && \ 
....................             (BSec->FAT.FAT_16.BootSec_FSType[2] == 'T') && \ 
....................             (BSec->FAT.FAT_16.BootSec_FSType[3] == '1') && \ 
....................             (BSec->FAT.FAT_16.BootSec_BootSig == 0x29)) 
.................... #endif 
....................         { 
....................             /* Mark that we do not have a MBR; 
....................                 this is not actualy used - is here only to remove a compilation warning */ 
....................             masterBootRecord = (PT_MBR) NULL; 
....................             switch (mode) 
....................             { 
....................                 case 1: 
....................                     // not enough info to construct our own boot sector 
....................                     FSerrno = CE_INVALID_ARGUMENT; 
....................                     return EOF; 
....................                 case 0: 
....................                     // We have to determine the operating system, and the 
....................                     // locations and sizes of the root dir and FAT, and the 
....................                     // count of FATs 
....................                     disk->firsts = 0; 
....................                     if (LoadBootSector (disk) != CE_GOOD) 
....................                     { 
....................                         FSerrno = CE_BADCACHEREAD; 
....................                         return EOF; 
....................                     } 
....................                 default: 
....................                     break; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             masterBootRecord = (PT_MBR) &gDataBuffer; 
....................             disk->firsts = masterBootRecord->Partition0.PTE_FrstSect; 
....................         } 
....................     } 
....................     else 
....................     { 
....................         /* If the signature is not correct, this is neither a MBR, nor a VBR */ 
....................         FSerrno = CE_BAD_PARTITION; 
....................         return EOF; 
....................     } 
....................  
....................     switch (mode) 
....................     { 
....................         // True: Rewrite the whole boot sector 
....................         case 1: 
....................             secCount = masterBootRecord->Partition0.PTE_NumSect; 
....................  
....................            #ifdef SUPPORT_FAT12 
....................             if (secCount < 0x1039) 
....................             { 
....................                 disk->type = FAT12; 
....................                 // Format to FAT12 only if there are too few sectors to format 
....................                 // as FAT16 
....................                 masterBootRecord->Partition0.PTE_FSDesc = 0x01; 
....................                 if (MDD_SectorWrite (0x00, gDataBuffer, TRUE) == FALSE) 
....................                 { 
....................                     FSerrno = CE_WRITE_ERROR; 
....................                     return EOF; 
....................                 } 
....................  
....................                 if (secCount >= 0x1028) 
....................                 { 
....................                     // More than 0x18 sectors for FATs, 0x20 for root dir, 
....................                     // 0x8 reserved, and 0xFED for data 
....................                     // So double the number of sectors in a cluster to reduce 
....................                     // the number of data clusters used 
....................                     disk->SecPerClus = 2; 
....................                 } 
....................                 else 
....................                 { 
....................                     // One sector per cluster 
....................                     disk->SecPerClus = 1; 
....................                 } 
....................  
....................                 // Prepare a boot sector 
....................                 memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE); 
....................  
....................                 // Last digit of file system name (FAT12   ) 
....................                 gDataBuffer[58] = '2'; 
....................  
....................                 // Calculate the size of the FAT 
....................                 fatsize = (secCount - 0x21  + (2*disk->SecPerClus)); 
....................                 test =   (341 * disk->SecPerClus) + 2; 
....................                 fatsize = (fatsize + (test-1)) / test; 
....................  
....................                 disk->fatcopy = 0x02; 
....................                 disk->maxroot = 0x200; 
....................  
....................                 disk->fatsize = fatsize; 
....................  
....................             } 
....................             else 
....................            #endif 
....................             if (secCount <= 0x3FFD5F) 
....................             { 
....................                 disk->type = FAT16; 
....................                 // Format to FAT16 
....................                 masterBootRecord->Partition0.PTE_FSDesc = 0x06; 
....................                 if (MDD_SectorWrite (0x00, gDataBuffer, TRUE) == FALSE) 
....................                 { 
....................                     FSerrno = CE_WRITE_ERROR; 
....................                     return EOF; 
....................                 } 
....................  
....................                 DataClusters = secCount - 0x218; 
....................                 // Figure out how many sectors per cluster we need 
....................                 disk->SecPerClus = 1; 
....................                 while (DataClusters > 0xFFED) 
....................                 { 
....................                     disk->SecPerClus *= 2; 
....................                     DataClusters /= 2; 
....................                 } 
....................                 // This shouldnt happen 
....................                 if (disk->SecPerClus > 128) 
....................                 { 
....................                     FSerrno = CE_BAD_PARTITION; 
....................                     return EOF; 
....................                 } 
....................  
....................                 // Prepare a boot sector 
....................                 memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE); 
....................  
....................                 // Last digit of file system name (FAT16   ) 
....................                 gDataBuffer[58] = '6'; 
....................  
....................                 // Calculate the size of the FAT 
....................                 fatsize = (secCount - 0x21  + (2*disk->SecPerClus)); 
....................                 test =    (256  * disk->SecPerClus) + 2; 
....................                 fatsize = (fatsize + (test-1)) / test; 
....................  
....................                 disk->fatcopy = 0x02; 
....................                 disk->maxroot = 0x200; 
....................  
....................                 disk->fatsize = fatsize; 
....................             } 
....................             else 
....................             { 
....................                 disk->type = FAT32; 
....................                 // Format to FAT32 
....................                 masterBootRecord->Partition0.PTE_FSDesc = 0x0B; 
....................                 if (MDD_SectorWrite (0x00, gDataBuffer, TRUE) == FALSE) 
....................                 { 
....................                     FSerrno = CE_WRITE_ERROR; 
....................                     return EOF; 
....................                 } 
....................  
....................                 #ifdef FORMAT_SECTORS_PER_CLUSTER 
....................                     disk->SecPerClus = FORMAT_SECTORS_PER_CLUSTER; 
....................                     DataClusters = secCount / disk->SecPerClus; 
....................  
....................                     /* FAT32: 65526 < Number of clusters < 4177918 */ 
....................                     if ((DataClusters <= 65526) || (DataClusters >= 4177918)) 
....................                     { 
....................                         FSerrno = CE_BAD_PARTITION; 
....................                         return EOF; 
....................                     } 
....................                 #else 
....................                     /*  FAT32: 65526 < Number of clusters < 4177918 */ 
....................                     DataClusters = secCount; 
....................                     // Figure out how many sectors per cluster we need 
....................                     disk->SecPerClus = 1; 
....................                     while (DataClusters > 0x3FBFFE) 
....................                     { 
....................                         disk->SecPerClus *= 2; 
....................                         DataClusters /= 2; 
....................                     } 
....................                 #endif 
....................                 // Check the cluster size: FAT32 supports 512, 1024, 2048, 4096, 8192, 16K, 32K, 64K 
....................                 if (disk->SecPerClus > 128) 
....................                 { 
....................                     FSerrno = CE_BAD_PARTITION; 
....................                     return EOF; 
....................                 } 
....................  
....................                 // Prepare a boot sector 
....................                 memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE); 
....................  
....................                // Calculate the size of the FAT 
....................                 fatsize = (secCount - 0x20); 
....................                 test =    (128  * disk->SecPerClus) + 1; 
....................                 fatsize = (fatsize + (test-1)) / test; 
....................  
....................                 disk->fatcopy = 0x02; 
....................                 disk->maxroot = 0x200; 
....................  
....................                 disk->fatsize = fatsize; 
....................             } 
....................  
....................             // Non-file system specific values 
....................             gDataBuffer[0] = 0xEB;         //Jump instruction 
....................             gDataBuffer[1] = 0x3C; 
....................             gDataBuffer[2] = 0x90; 
....................             gDataBuffer[3] =  'M';         //OEM Name "MCHP FAT" 
....................             gDataBuffer[4] =  'C'; 
....................             gDataBuffer[5] =  'H'; 
....................             gDataBuffer[6] =  'P'; 
....................             gDataBuffer[7] =  ' '; 
....................             gDataBuffer[8] =  'F'; 
....................             gDataBuffer[9] =  'A'; 
....................             gDataBuffer[10] = 'T'; 
....................  
....................             gDataBuffer[11] = 0x00;             //Sector size 
....................             gDataBuffer[12] = 0x02; 
....................  
....................             gDataBuffer[13] = disk->SecPerClus;   //Sectors per cluster 
....................  
....................             if ((disk->type == FAT12) || (disk->type == FAT16)) 
....................             { 
....................                 gDataBuffer[14] = 0x08;         //Reserved sector count 
....................                 gDataBuffer[15] = 0x00; 
....................                 disk->fat = 0x08 + disk->firsts; 
....................  
....................                 gDataBuffer[16] = 0x02;         //number of FATs 
....................  
....................                 gDataBuffer[17] = 0x00;          //Max number of root directory entries - 512 files allowed 
....................                 gDataBuffer[18] = 0x02; 
....................  
....................                 gDataBuffer[19] = 0x00;         //total sectors 
....................                 gDataBuffer[20] = 0x00; 
....................  
....................                 gDataBuffer[21] = 0xF8;         //Media Descriptor 
....................  
....................                 gDataBuffer[22] = fatsize & 0xFF;         //Sectors per FAT 
....................                 gDataBuffer[23] = (fatsize >> 8) & 0xFF; 
....................  
....................                 gDataBuffer[24] = 0x3F;           //Sectors per track 
....................                 gDataBuffer[25] = 0x00; 
....................  
....................                 gDataBuffer[26] = 0xFF;         //Number of heads 
....................                 gDataBuffer[27] = 0x00; 
....................  
....................                 // Hidden sectors = sectors between the MBR and the boot sector 
....................                 gDataBuffer[28] = (BYTE)(disk->firsts & 0xFF); 
....................                 gDataBuffer[29] = (BYTE)((disk->firsts / 0x100) & 0xFF); 
....................                 gDataBuffer[30] = (BYTE)((disk->firsts / 0x10000) & 0xFF); 
....................                 gDataBuffer[31] = (BYTE)((disk->firsts / 0x1000000) & 0xFF); 
....................  
....................                 // Total Sectors = same as sectors in the partition from MBR 
....................                 gDataBuffer[32] = (BYTE)(secCount & 0xFF); 
....................                 gDataBuffer[33] = (BYTE)((secCount / 0x100) & 0xFF); 
....................                 gDataBuffer[34] = (BYTE)((secCount / 0x10000) & 0xFF); 
....................                 gDataBuffer[35] = (BYTE)((secCount / 0x1000000) & 0xFF); 
....................  
....................                 gDataBuffer[36] = 0x00;         // Physical drive number 
....................  
....................                 gDataBuffer[37] = 0x00;         // Reserved (current head) 
....................  
....................                 gDataBuffer[38] = 0x29;         // Signature code 
....................  
....................                 gDataBuffer[39] = (BYTE)(serialNumber & 0xFF); 
....................                 gDataBuffer[40] = (BYTE)((serialNumber / 0x100) & 0xFF); 
....................                 gDataBuffer[41] = (BYTE)((serialNumber / 0x10000) & 0xFF); 
....................                 gDataBuffer[42] = (BYTE)((serialNumber / 0x1000000) & 0xFF); 
....................  
....................                 // Volume ID 
....................                 if (volumeID != NULL) 
....................                 { 
....................                     for (Index = 0; (*(volumeID + Index) != 0) && (Index < 11); Index++) 
....................                     { 
....................                         gDataBuffer[Index + 43] = *(volumeID + Index); 
....................                     } 
....................                     while (Index < 11) 
....................                     { 
....................                         gDataBuffer[43 + Index++] = 0x20; 
....................                     } 
....................                 } 
....................                 else 
....................                 { 
....................                     for (Index = 0; Index < 11; Index++) 
....................                     { 
....................                         gDataBuffer[Index+43] = 0; 
....................                     } 
....................                 } 
....................  
....................                 gDataBuffer[54] = 'F'; 
....................                 gDataBuffer[55] = 'A'; 
....................                 gDataBuffer[56] = 'T'; 
....................                 gDataBuffer[57] = '1'; 
....................                 gDataBuffer[59] = ' '; 
....................                 gDataBuffer[60] = ' '; 
....................                 gDataBuffer[61] = ' '; 
....................  
....................             } 
....................             else //FAT32 
....................             { 
....................                 gDataBuffer[14] = 0x20;         //Reserved sector count 
....................                 gDataBuffer[15] = 0x00; 
....................                 disk->fat = 0x20 + disk->firsts; 
....................  
....................                 gDataBuffer[16] = 0x02;         //number of FATs 
....................  
....................                 gDataBuffer[17] = 0x00;          //Max number of root directory entries - 512 files allowed 
....................                 gDataBuffer[18] = 0x00; 
....................  
....................                 gDataBuffer[19] = 0x00;         //total sectors 
....................                 gDataBuffer[20] = 0x00; 
....................  
....................                 gDataBuffer[21] = 0xF8;         //Media Descriptor 
....................  
....................                 gDataBuffer[22] = 0x00;         //Sectors per FAT 
....................                 gDataBuffer[23] = 0x00; 
....................  
....................                 gDataBuffer[24] = 0x3F;         //Sectors per track 
....................                 gDataBuffer[25] = 0x00; 
....................  
....................                 gDataBuffer[26] = 0xFF;         //Number of heads 
....................                 gDataBuffer[27] = 0x00; 
....................  
....................                 // Hidden sectors = sectors between the MBR and the boot sector 
....................                 gDataBuffer[28] = (BYTE)(disk->firsts & 0xFF); 
....................                 gDataBuffer[29] = (BYTE)((disk->firsts / 0x100) & 0xFF); 
....................                 gDataBuffer[30] = (BYTE)((disk->firsts / 0x10000) & 0xFF); 
....................                 gDataBuffer[31] = (BYTE)((disk->firsts / 0x1000000) & 0xFF); 
....................  
....................                 // Total Sectors = same as sectors in the partition from MBR 
....................                 gDataBuffer[32] = (BYTE)(secCount & 0xFF); 
....................                 gDataBuffer[33] = (BYTE)((secCount / 0x100) & 0xFF); 
....................                 gDataBuffer[34] = (BYTE)((secCount / 0x10000) & 0xFF); 
....................                 gDataBuffer[35] = (BYTE)((secCount / 0x1000000) & 0xFF); 
....................  
....................                 gDataBuffer[36] = fatsize & 0xFF;         //Sectors per FAT 
....................                 gDataBuffer[37] = (fatsize >>  8) & 0xFF; 
....................                 gDataBuffer[38] = (fatsize >> 16) & 0xFF; 
....................                 gDataBuffer[39] = (fatsize >> 24) & 0xFF; 
....................  
....................                 gDataBuffer[40] = 0x00;         //Active FAT 
....................                 gDataBuffer[41] = 0x00; 
....................  
....................                 gDataBuffer[42] = 0x00;         //File System version 
....................                 gDataBuffer[43] = 0x00; 
....................  
....................                 gDataBuffer[44] = 0x02;         //First cluster of the root directory 
....................                 gDataBuffer[45] = 0x00; 
....................                 gDataBuffer[46] = 0x00; 
....................                 gDataBuffer[47] = 0x00; 
....................  
....................                 gDataBuffer[48] = 0x01;         //FSInfo 
....................                 gDataBuffer[49] = 0x00; 
....................  
....................                 gDataBuffer[50] = 0x00;         //Backup Boot Sector 
....................                 gDataBuffer[51] = 0x00; 
....................  
....................                 gDataBuffer[52] = 0x00;         //Reserved for future expansion 
....................                 gDataBuffer[53] = 0x00; 
....................                 gDataBuffer[54] = 0x00; 
....................                 gDataBuffer[55] = 0x00; 
....................                 gDataBuffer[56] = 0x00; 
....................                 gDataBuffer[57] = 0x00; 
....................                 gDataBuffer[58] = 0x00; 
....................                 gDataBuffer[59] = 0x00; 
....................                 gDataBuffer[60] = 0x00; 
....................                 gDataBuffer[61] = 0x00; 
....................                 gDataBuffer[62] = 0x00; 
....................                 gDataBuffer[63] = 0x00; 
....................  
....................                 gDataBuffer[64] = 0x00;         // Physical drive number 
....................  
....................                 gDataBuffer[65] = 0x00;         // Reserved (current head) 
....................  
....................                 gDataBuffer[66] = 0x29;         // Signature code 
....................  
....................                 gDataBuffer[67] = (BYTE)(serialNumber & 0xFF); 
....................                 gDataBuffer[68] = (BYTE)((serialNumber / 0x100) & 0xFF); 
....................                 gDataBuffer[69] = (BYTE)((serialNumber / 0x10000) & 0xFF); 
....................                 gDataBuffer[70] = (BYTE)((serialNumber / 0x1000000) & 0xFF); 
....................  
....................                 // Volume ID 
....................                 if (volumeID != NULL) 
....................                 { 
....................                     for (Index = 0; (*(volumeID + Index) != 0) && (Index < 11); Index++) 
....................                     { 
....................                         gDataBuffer[Index + 71] = *(volumeID + Index); 
....................                     } 
....................                     while (Index < 11) 
....................                     { 
....................                         gDataBuffer[71 + Index++] = 0x20; 
....................                     } 
....................                 } 
....................                 else 
....................                 { 
....................                     for (Index = 0; Index < 11; Index++) 
....................                     { 
....................                         gDataBuffer[Index+71] = 0; 
....................                     } 
....................                 } 
....................  
....................                 gDataBuffer[82] = 'F'; 
....................                 gDataBuffer[83] = 'A'; 
....................                 gDataBuffer[84] = 'T'; 
....................                 gDataBuffer[85] = '3'; 
....................                 gDataBuffer[86] = '2'; 
....................                 gDataBuffer[87] = ' '; 
....................                 gDataBuffer[88] = ' '; 
....................                 gDataBuffer[89] = ' '; 
....................  
....................  
....................             } 
....................  
.................... #ifdef __18CXX 
....................             // C18 can't reference a value greater than 256 
....................             // using an array name pointer 
....................             *(dataBufferPointer + 510) = 0x55; 
....................             *(dataBufferPointer + 511) = 0xAA; 
.................... #else 
....................             gDataBuffer[510] = 0x55; 
....................             gDataBuffer[511] = 0xAA; 
.................... #endif 
....................  
....................             disk->root = disk->fat + (disk->fatcopy * disk->fatsize); 
....................  
....................             if (MDD_SectorWrite (disk->firsts, gDataBuffer, FALSE) == FALSE) 
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
....................                 return EOF; 
....................             } 
....................  
....................             break; 
....................         case 0: 
....................             if (LoadBootSector (disk) != CE_GOOD) 
....................             { 
....................                 FSerrno = CE_BADCACHEREAD; 
....................                 return EOF; 
....................             } 
....................             break; 
....................         default: 
....................             FSerrno = CE_INVALID_ARGUMENT; 
....................             return EOF; 
....................     } 
....................  
....................     // Erase the FAT 
....................     memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE); 
....................  
....................     if (disk->type == FAT32) 
....................     { 
....................         gDataBuffer[0] = 0xF8;          //BPB_Media byte value in its low 8 bits, and all other bits are set to 1 
....................         gDataBuffer[1] = 0xFF; 
....................         gDataBuffer[2] = 0xFF; 
....................         gDataBuffer[3] = 0xFF; 
....................  
....................         gDataBuffer[4] = 0x00;          //Disk is clean and no read/write errors were encountered 
....................         gDataBuffer[5] = 0x00; 
....................         gDataBuffer[6] = 0x00; 
....................         gDataBuffer[7] = 0x0C; 
....................  
....................         gDataBuffer[8]  = 0xFF;         //Root Directory EOF 
....................         gDataBuffer[9]  = 0xFF; 
....................         gDataBuffer[10] = 0xFF; 
....................         gDataBuffer[11] = 0xFF; 
....................  
....................         for (j = disk->fatcopy - 1; j != 0xFFFF; j--) 
....................         { 
....................             if (MDD_SectorWrite (disk->fat + (j * disk->fatsize), gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         memset (gDataBuffer, 0x00, 12); 
....................  
....................         for (Index = disk->fat + 1; Index < (disk->fat + disk->fatsize); Index++) 
....................         { 
....................             for (j = disk->fatcopy - 1; j != 0xFFFF; j--) 
....................             { 
....................                 if (MDD_SectorWrite (Index + (j * disk->fatsize), gDataBuffer, FALSE) == FALSE) 
....................                     return EOF; 
....................             } 
....................         } 
....................  
....................         // Erase the root directory 
....................         for (Index = 1; Index < disk->SecPerClus; Index++) 
....................         { 
....................             if (MDD_SectorWrite (disk->root + Index, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         if (volumeID != NULL) 
....................         { 
....................             // Create a drive name entry in the root dir 
....................             Index = 0; 
....................             while ((*(volumeID + Index) != 0) && (Index < 11)) 
....................             { 
....................                 gDataBuffer[Index] = *(volumeID + Index); 
....................                 Index++; 
....................             } 
....................             while (Index < 11) 
....................             { 
....................                 gDataBuffer[Index++] = ' '; 
....................             } 
....................             gDataBuffer[11] = 0x08; 
....................             gDataBuffer[17] = 0x11; 
....................             gDataBuffer[19] = 0x11; 
....................             gDataBuffer[23] = 0x11; 
....................  
....................             if (MDD_SectorWrite (disk->root, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................         else 
....................         { 
....................             if (MDD_SectorWrite (disk->root, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         return 0; 
....................     } 
....................     else 
....................     { 
....................         gDataBuffer[0] = 0xF8; 
....................         gDataBuffer[1] = 0xFF; 
....................         gDataBuffer[2] = 0xFF; 
....................         if (disk->type == FAT16) 
....................             gDataBuffer[3] = 0xFF; 
....................  
....................         for (j = disk->fatcopy - 1; j != 0xFFFF; j--) 
....................         { 
....................             if (MDD_SectorWrite (disk->fat + (j * disk->fatsize), gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         memset (gDataBuffer, 0x00, 4); 
....................  
....................         for (Index = disk->fat + 1; Index < (disk->fat + disk->fatsize); Index++) 
....................         { 
....................             for (j = disk->fatcopy - 1; j != 0xFFFF; j--) 
....................             { 
....................                 if (MDD_SectorWrite (Index + (j * disk->fatsize), gDataBuffer, FALSE) == FALSE) 
....................                     return EOF; 
....................             } 
....................         } 
....................  
....................       // Initialize the sector size 
....................         disk->sectorSize = MEDIA_SECTOR_SIZE; 
....................  
....................         // Erase the root directory 
....................         RootDirSectors = ((disk->maxroot * 32) + (disk->sectorSize - 1)) / disk->sectorSize; 
....................  
....................         for (Index = 1; Index < RootDirSectors; Index++) 
....................         { 
....................             if (MDD_SectorWrite (disk->root + Index, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         if (volumeID != NULL) 
....................         { 
....................             // Create a drive name entry in the root dir 
....................             Index = 0; 
....................             while ((*(volumeID + Index) != 0) && (Index < 11)) 
....................             { 
....................                 gDataBuffer[Index] = *(volumeID + Index); 
....................                 Index++; 
....................             } 
....................             while (Index < 11) 
....................             { 
....................                 gDataBuffer[Index++] = ' '; 
....................             } 
....................             gDataBuffer[11] = 0x08; 
....................             gDataBuffer[17] = 0x11; 
....................             gDataBuffer[19] = 0x11; 
....................             gDataBuffer[23] = 0x11; 
....................  
....................             if (MDD_SectorWrite (disk->root, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................         else 
....................         { 
....................             if (MDD_SectorWrite (disk->root, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         return 0; 
....................     } 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /******************************************************* 
....................   Function: 
....................     BYTE Write_File_Entry( FILEOBJ fo, WORD * curEntry) 
....................   Summary: 
....................     Write dir entry info into a specified entry 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -        \File structure 
....................     curEntry -  Write destination 
....................   Return Values: 
....................     TRUE - Operation successful 
....................     FALSE - Operation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will calculate the sector of the 
....................     directory (whose base sector is pointed to by the 
....................     dirccls value in the FSFILE object 'fo') that contains 
....................     a directory entry whose offset is indicated by the 
....................     curEntry parameter.  It will then write the data 
....................     in the global data buffer (which should already 
....................     contain the entries for that sector) to the device. 
....................   Remarks: 
....................     None 
....................   *******************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE Write_File_Entry( FILEOBJ fo, WORD * curEntry) 
*
03964:  MOV     W5,[W15++]
03966:  MOV     W6,[W15++]
03968:  MOV     W7,[W15++]
.................... { 
....................     DISK   *dsk; 
0396A:  CLR     1064
....................     BYTE   status; 
0396C:  CLR.B   1066
....................     BYTE   offset2; 
0396E:  CLR.B   1067
....................     DWORD   sector; 
03970:  CLR     1068
03972:  CLR     106A
....................     DWORD   ccls; 
03974:  CLR     106C
03976:  CLR     106E
....................  
....................     dsk = fo->dsk; 
03978:  MOV     1060,W4
0397A:  ADD     W4,#0,W4
0397C:  MOV     W4,W0
0397E:  MOV     [W0],[W15++]
03980:  POP     1064
....................  
....................     // get the cluster of this entry 
....................     ccls = fo->dirccls; 
03982:  MOV     #32,W0
03984:  ADD     1060,W0
03986:  MOV     #106C,W4
03988:  MOV     [W0++],[W4++]
0398A:  MOV     [W0++],[W4++]
....................  
....................      // figure out the offset from the base sector 
....................     offset2  = (*curEntry / (dsk->sectorSize/32)); 
0398C:  MOV     1062,W0
0398E:  MOV     [W0],W5
03990:  MOV     1064,W4
03992:  ADD     W4,#18,W4
03994:  MOV     W4,W0
03996:  MOV     #C,W1
03998:  MOV     W0,W2
0399A:  REPEAT  #3
0399C:  MOV.B   [W2++],[W1++]
0399E:  MOV     #5,W4
039A0:  CLR.B   9
039A2:  MOV.D   W6,W0
039A4:  INC     W4,W4
039A6:  DEC     W4,W4
039A8:  BRA     Z,39B0
039AA:  LSR     W1,W1
039AC:  RRC     W0,W0
039AE:  BRA     39A6
039B0:  BCLR.B  43.0
039B2:  MOV     W0,W2
039B4:  MOV     W1,W3
039B6:  MOV     W5,W0
039B8:  MOV     #0,W1
039BA:  CALL    1AE6
039BE:  MOV.B   W0L,1067
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
039C0:  MOV     #22,W4
039C2:  MOV     1064,W3
039C4:  ADD     W3,W4,W0
039C6:  MOV     #A,W1
039C8:  MOV     W0,W2
039CA:  MOV.B   [W2++],[W1++]
039CC:  MOV.B   W5L,W0L
039CE:  CLR.B   1
039D0:  XOR     #3,W0
039D2:  BRA     Z,39DA
039D4:  XOR     #1,W0
039D6:  BRA     Z,39FC
039D8:  BRA     3A2A
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             // Root is always cluster-based in FAT32 
....................             offset2 = offset2 % (dsk->SecPerClus); 
039DA:  MOV     #21,W4
039DC:  MOV     1064,W3
039DE:  ADD     W3,W4,W0
039E0:  MOV     #A,W1
039E2:  MOV     W0,W2
039E4:  MOV.B   [W2++],[W1++]
039E6:  MOV.B   1067,W0L
039E8:  CLR.B   1
039EA:  CLR.B   1
039EC:  CLR.B   B
039EE:  CLR.B   B
039F0:  REPEAT  #11
039F2:  DIV.U   W0,W5
039F4:  MOV.B   W1L,W0L
039F6:  MOV.B   W0L,1067
....................             break; 
039F8:  GOTO    3A2A
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
.................... #endif 
....................         case FAT16: 
....................             if(ccls != FatRootDirClusterValue) 
039FC:  MOV     106C,W0
039FE:  CP      8B2
03A00:  BRA     NZ,3A08
03A02:  MOV     106E,W0
03A04:  CP      8B4
03A06:  BRA     Z,3A26
....................                 offset2 = offset2 % (dsk->SecPerClus); 
03A08:  MOV     #21,W4
03A0A:  MOV     1064,W3
03A0C:  ADD     W3,W4,W0
03A0E:  MOV     #A,W1
03A10:  MOV     W0,W2
03A12:  MOV.B   [W2++],[W1++]
03A14:  MOV.B   1067,W0L
03A16:  CLR.B   1
03A18:  CLR.B   1
03A1A:  CLR.B   B
03A1C:  CLR.B   B
03A1E:  REPEAT  #11
03A20:  DIV.U   W0,W5
03A22:  MOV.B   W1L,W0L
03A24:  MOV.B   W0L,1067
....................             break; 
03A26:  GOTO    3A2A
....................     } 
....................  
....................     sector = Cluster2Sector(dsk,ccls); 
03A2A:  PUSH    1064
03A2C:  POP     10B0
03A2E:  PUSH    106C
03A30:  POP     10B2
03A32:  PUSH    106E
03A34:  POP     10B4
03A36:  CALL    308C
03A3A:  MOV     W0,1068
03A3C:  MOV     W1,106A
....................  
....................     // Now write it 
....................     // "Offset" ensures writing of data belonging to a file entry only. Hence it doesn't change other file entries. 
....................     if ( !MDD_SectorWrite( sector + offset2, dsk->buffer, FALSE)) 
03A3E:  MOV     1066,W4
03A40:  LSR     W4,#8,W4
03A42:  MOV     1068,W3
03A44:  ADD     W3,W4,W5
03A46:  MOV     106A,W3
03A48:  ADDC    W3,#0,W3
03A4A:  MOV     W3,W6
03A4C:  MOV     1064,W4
03A4E:  ADD     W4,#0,W4
03A50:  MOV     W4,W0
03A52:  MOV     #E,W1
03A54:  MOV     W0,W2
03A56:  REPEAT  #1
03A58:  MOV.B   [W2++],[W1++]
03A5A:  CLR.B   10F8
03A5C:  MOV     W5,10F2
03A5E:  MOV     W6,10F4
03A60:  MOV     W7,10F6
03A62:  CALL    2BBE
03A66:  CP0.B   W0L
03A68:  BRA     NZ,3A70
....................         status = FALSE; 
03A6A:  CLR.B   1066
03A6C:  GOTO    3A74
....................     else 
....................         status = TRUE; 
03A70:  MOV.B   #1,W0L
03A72:  MOV.B   W0L,1066
....................  
....................     return(status); 
03A74:  MOV.B   1066,W0L
03A76:  MOV.B   W0L,0
03A78:  MOV     [--W15],W7
03A7A:  MOV     [--W15],W6
03A7C:  MOV     [--W15],W5
03A7E:  RETURN  
.................... } // Write_File_Entry 
.................... #endif 
....................  
....................  
.................... /********************************************************** 
....................   Function: 
....................     BYTE FAT_erase_cluster_chain (WORD cluster, DISK * dsk) 
....................   Summary: 
....................     Erase a chain of clusters 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     cluster -  The cluster number 
....................     dsk -      The disk structure 
....................   Return Values: 
....................     TRUE -  Operation successful 
....................     FALSE - Operation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will parse through a cluster chain 
....................     starting with the cluster pointed to by 'cluster' and 
....................     mark all of the FAT entries as empty until the end of 
....................     the chain has been reached or an error occurs. 
....................   Remarks: 
....................     None 
....................   **********************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE FAT_erase_cluster_chain (DWORD cluster, DISK * dsk) 
03A80:  MOV     W5,[W15++]
03A82:  MOV     W6,[W15++]
.................... { 
....................     DWORD     c,c2,ClusterFailValue; 
03A84:  CLR     1066
03A86:  CLR     1068
03A88:  CLR     106A
03A8A:  CLR     106C
03A8C:  CLR     106E
03A8E:  CLR     1070
....................     enum    _status {Good, Fail, Exit}status; 
03A90:  CLR.B   1072
....................  
....................     status = Good; 
03A92:  CLR.B   1072
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
03A94:  MOV     #22,W4
03A96:  MOV     1064,W3
03A98:  ADD     W3,W4,W0
03A9A:  MOV     #A,W1
03A9C:  MOV     W0,W2
03A9E:  MOV.B   [W2++],[W1++]
03AA0:  MOV.B   W5L,W0L
03AA2:  CLR.B   1
03AA4:  XOR     #3,W0
03AA6:  BRA     Z,3AAE
03AA8:  XOR     #1,W0
03AAA:  BRA     Z,3AC0
03AAC:  BRA     3AC0
....................     { 
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             ClusterFailValue = CLUSTER_FAIL_FAT32; 
03AAE:  SETM    106E
03AB0:  MOV     #FFF,W4
03AB2:  MOV     W4,1070
....................             c2 =  LAST_CLUSTER_FAT32; 
03AB4:  MOV     #FFF8,W4
03AB6:  MOV     W4,106A
03AB8:  MOV     #FFF,W4
03ABA:  MOV     W4,106C
....................             break; 
03ABC:  GOTO    3ACE
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; // FAT16 value itself 
....................             c2 =  LAST_CLUSTER_FAT12; 
....................             break; 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
03AC0:  SETM    106E
03AC2:  CLR     1070
....................             c2 =  LAST_CLUSTER_FAT16; 
03AC4:  MOV     #FFF8,W4
03AC6:  MOV     W4,106A
03AC8:  CLR     106C
....................             break; 
03ACA:  GOTO    3ACE
....................     } 
....................  
....................     // Make sure there is actually a cluster assigned 
....................     if((cluster == 0) || (cluster == 1))  // Cluster assigned can't be "0" and "1" 
03ACE:  CP0     1060
03AD0:  BRA     NZ,3AD6
03AD2:  CP0     1062
03AD4:  BRA     Z,3AE0
03AD6:  MOV     1060,W4
03AD8:  CP      W4,#1
03ADA:  BRA     NZ,3AE8
03ADC:  CP0     1062
03ADE:  BRA     NZ,3AE8
....................     { 
....................         status = Exit; 
03AE0:  MOV.B   #2,W0L
03AE2:  MOV.B   W0L,1072
....................     } 
03AE4:  GOTO    3B7A
....................     else 
....................     { 
....................         while(status == Good) 
03AE8:  CP0.B   1072
03AEA:  BRA     NZ,3B7A
....................         { 
....................             // Get the FAT entry 
....................             if((c = ReadFAT( dsk, cluster)) == ClusterFailValue) 
03AEC:  PUSH    1064
03AEE:  POP     10A2
03AF0:  PUSH    1060
03AF2:  POP     10A4
03AF4:  PUSH    1062
03AF6:  POP     10A6
03AF8:  CALL    2ECC
03AFC:  MOV     W0,1066
03AFE:  MOV     W1,1068
03B00:  MOV     1066,W0
03B02:  CP      106E
03B04:  BRA     NZ,3B14
03B06:  MOV     1068,W0
03B08:  CP      1070
03B0A:  BRA     NZ,3B14
....................                 status = Fail; 
03B0C:  MOV.B   #1,W0L
03B0E:  MOV.B   W0L,1072
03B10:  GOTO    3B76
....................             else 
....................             { 
....................                 if((c == 0) || (c == 1))  // Cluster assigned can't be "0" and "1" 
03B14:  CP0     1066
03B16:  BRA     NZ,3B1C
03B18:  CP0     1068
03B1A:  BRA     Z,3B26
03B1C:  MOV     1066,W4
03B1E:  CP      W4,#1
03B20:  BRA     NZ,3B2E
03B22:  CP0     1068
03B24:  BRA     NZ,3B2E
....................                 { 
....................                     status = Exit; 
03B26:  MOV.B   #2,W0L
03B28:  MOV.B   W0L,1072
....................                 } 
03B2A:  GOTO    3B76
....................                 else 
....................                 { 
....................                     // compare against max value of a cluster in FATxx 
....................                     // look for the last cluster in the chain 
....................                     if ( c >= c2) 
03B2E:  MOV     106C,W0
03B30:  MOV     1068,W4
03B32:  CP      W4,W0
03B34:  BRA     NC,3B44
03B36:  BRA     GTU,3B40
03B38:  MOV     106A,W0
03B3A:  MOV     1066,W4
03B3C:  CP      W4,W0
03B3E:  BRA     NC,3B44
....................                         status = Exit; 
03B40:  MOV.B   #2,W0L
03B42:  MOV.B   W0L,1072
....................  
....................                     // Now erase this FAT entry 
....................                     if(WriteFAT(dsk, cluster, CLUSTER_EMPTY, FALSE) == ClusterFailValue) 
03B44:  CLR.B   10D2
03B46:  PUSH    1064
03B48:  POP     10C8
03B4A:  PUSH    1060
03B4C:  POP     10CA
03B4E:  PUSH    1062
03B50:  POP     10CC
03B52:  CLR     10CE
03B54:  CLR     10D0
03B56:  CALL    2C18
03B5A:  MOV     W0,W5
03B5C:  MOV     W1,W6
03B5E:  MOV     106E,W4
03B60:  CP      W4,W5
03B62:  BRA     NZ,3B6E
03B64:  MOV     1070,W4
03B66:  CP      W4,W6
03B68:  BRA     NZ,3B6E
....................                         status = Fail; 
03B6A:  MOV.B   #1,W0L
03B6C:  MOV.B   W0L,1072
....................  
....................                     // now update what the current cluster is 
....................                     cluster = c; 
03B6E:  PUSH    1066
03B70:  POP     1060
03B72:  PUSH    1068
03B74:  POP     1062
....................                 } 
....................             } 
03B76:  GOTO    3AE8
....................         }// while status 
....................     }// cluster == 0 
....................  
....................     WriteFAT (dsk, 0, 0, TRUE); 
03B7A:  MOV.B   #1,W0L
03B7C:  MOV.B   W0L,10D2
03B7E:  PUSH    1064
03B80:  POP     10C8
03B82:  CLR     10CA
03B84:  CLR     10CC
03B86:  CLR     10CE
03B88:  CLR     10D0
03B8A:  CALL    2C18
....................  
....................     if(status == Exit) 
03B8E:  MOV     1072,W4
03B90:  CP.B    W4L,#2
03B92:  BRA     NZ,3B9E
....................         return(TRUE); 
03B94:  MOV.B   #1,W0L
03B96:  MOV.B   W0L,0
03B98:  BRA     3BA2
03B9A:  GOTO    3BA2
....................     else 
....................         return(FALSE); 
03B9E:  CLR.B   0
03BA0:  BRA     3BA2
03BA2:  MOV     [--W15],W6
03BA4:  MOV     [--W15],W5
03BA6:  RETURN  
.................... } // Erase cluster 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     DIRENTRY Cache_File_Entry( FILEOBJ fo, WORD * curEntry, BYTE ForceRead) 
....................   Summary: 
....................     Load a file entry 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -         File information 
....................     curEntry -   Offset of the directory entry to load. 
....................     ForceRead -  Forces loading of a new sector of the directory. 
....................   Return: 
....................     DIRENTRY - Pointer to the directory entry that was loaded. 
....................   Side Effects: 
....................     Any unwritten data in the data buffer will be written to the device. 
....................   Description: 
....................     Load the sector containing the file entry pointed to by 'curEntry' 
....................     from the directory pointed to by the variables in 'fo.' 
....................   Remarks: 
....................     Any modification of this function is extremely likely to 
....................     break something. 
....................   **************************************************************************/ 
....................  
.................... DIRENTRY Cache_File_Entry( FILEOBJ fo, WORD * curEntry, BYTE ForceRead) 
*
031E4:  MOV     W5,[W15++]
031E6:  MOV     W6,[W15++]
031E8:  MOV     W7,[W15++]
031EA:  MOV     W8,[W15++]
.................... { 
....................     DIRENTRY dir; 
031EC:  CLR     1088
....................     DISK *dsk; 
031EE:  CLR     108A
....................     DWORD sector; 
031F0:  CLR     108C
031F2:  CLR     108E
....................     DWORD cluster, LastClusterLimit; 
031F4:  CLR     1090
031F6:  CLR     1092
031F8:  CLR     1094
031FA:  CLR     1096
....................     DWORD ccls; 
031FC:  CLR     1098
031FE:  CLR     109A
....................     BYTE offset2; 
03200:  CLR.B   1087
....................     BYTE numofclus; 
03202:  CLR.B   109C
....................    BYTE dirEntriesPerSector; 
03204:  CLR.B   109D
....................  
....................     dsk = fo->dsk; 
03206:  MOV     1082,W4
03208:  ADD     W4,#0,W4
0320A:  MOV     W4,W0
0320C:  MOV     [W0],[W15++]
0320E:  POP     108A
....................  
....................     // get the base sector of this directory 
....................     cluster = fo->dirclus; 
03210:  MOV     #2E,W0
03212:  ADD     1082,W0
03214:  MOV     #1090,W4
03216:  MOV     [W0++],[W4++]
03218:  MOV     [W0++],[W4++]
....................     ccls = fo->dirccls; 
0321A:  MOV     #32,W0
0321C:  ADD     1082,W0
0321E:  MOV     #1098,W4
03220:  MOV     [W0++],[W4++]
03222:  MOV     [W0++],[W4++]
....................  
....................    dirEntriesPerSector = dsk->sectorSize/32; 
03224:  MOV     108A,W4
03226:  ADD     W4,#18,W4
03228:  MOV     W4,W0
0322A:  MOV     #A,W1
0322C:  MOV     W0,W2
0322E:  REPEAT  #3
03230:  MOV.B   [W2++],[W1++]
03232:  MOV     #5,W4
03234:  CLR.B   9
03236:  MOV     W5,W0
03238:  MOV     W6,W1
0323A:  INC     W4,W4
0323C:  DEC     W4,W4
0323E:  BRA     Z,3246
03240:  LSR     W1,W1
03242:  RRC     W0,W0
03244:  BRA     323C
03246:  MOV.B   W0L,109D
....................  
....................      // figure out the offset from the base sector 
....................     offset2  = (*curEntry / dirEntriesPerSector); 
03248:  MOV     1084,W0
0324A:  MOV     [W0],W5
0324C:  MOV     W5,W4
0324E:  MOV.B   109D,W0L
03250:  CLR.B   1
03252:  MOV.B   W0L,W3L
03254:  CLR.B   7
03256:  REPEAT  #11
03258:  DIV.U   W4,W3
0325A:  MOV.B   W0L,1087
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
0325C:  MOV     #22,W4
0325E:  MOV     108A,W3
03260:  ADD     W3,W4,W0
03262:  MOV     #A,W1
03264:  MOV     W0,W2
03266:  MOV.B   [W2++],[W1++]
03268:  MOV.B   W5L,W0L
0326A:  CLR.B   1
0326C:  XOR     #3,W0
0326E:  BRA     Z,3276
03270:  XOR     #1,W0
03272:  BRA     Z,32A0
03274:  BRA     32A0
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             // the ROOT is always cluster based in FAT32 
....................             /* In FAT32: There is no ROOT region. Root etries are made in DATA region only. 
....................             Every cluster of DATA which is accupied by ROOT is tracked by FAT table/entry so the ROOT can grow 
....................             to an amount which is restricted only by available free DATA region. */ 
....................             offset2  = offset2 % (dsk->SecPerClus);   // figure out the offset 
03276:  MOV     #21,W4
03278:  MOV     108A,W3
0327A:  ADD     W3,W4,W0
0327C:  MOV     #A,W1
0327E:  MOV     W0,W2
03280:  MOV.B   [W2++],[W1++]
03282:  MOV.B   1087,W0L
03284:  CLR.B   1
03286:  CLR.B   1
03288:  CLR.B   B
0328A:  CLR.B   B
0328C:  REPEAT  #11
0328E:  DIV.U   W0,W5
03290:  MOV.B   W1L,W0L
03292:  MOV.B   W0L,1087
....................             LastClusterLimit = LAST_CLUSTER_FAT32; 
03294:  MOV     #FFF8,W4
03296:  MOV     W4,1094
03298:  MOV     #FFF,W4
0329A:  MOV     W4,1096
....................             break; 
0329C:  GOTO    32D0
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             // if its the root its not cluster based 
....................             if(cluster != 0) 
032A0:  CP0     1090
032A2:  BRA     NZ,32A8
032A4:  CP0     1092
032A6:  BRA     Z,32C6
....................                 offset2  = offset2 % (dsk->SecPerClus);   // figure out the offset 
032A8:  MOV     #21,W4
032AA:  MOV     108A,W3
032AC:  ADD     W3,W4,W0
032AE:  MOV     #A,W1
032B0:  MOV     W0,W2
032B2:  MOV.B   [W2++],[W1++]
032B4:  MOV.B   1087,W0L
032B6:  CLR.B   1
032B8:  CLR.B   1
032BA:  CLR.B   B
032BC:  CLR.B   B
032BE:  REPEAT  #11
032C0:  DIV.U   W0,W5
032C2:  MOV.B   W1L,W0L
032C4:  MOV.B   W0L,1087
....................             LastClusterLimit = LAST_CLUSTER_FAT16; 
032C6:  MOV     #FFF8,W4
032C8:  MOV     W4,1094
032CA:  CLR     1096
....................             break; 
032CC:  GOTO    32D0
....................     } 
....................  
....................    //#ifdef __DEBUG_UART   
....................    #if 0 
....................    PrintROMASCIIStringUART("Cache_File_Entry"); 
....................     
....................    PrintROMASCIIStringUART(" cluster="); 
....................    PrintRAMBytesUART(((unsigned char*)&cluster), sizeof(cluster)); 
....................  
....................    PrintROMASCIIStringUART(" ccls="); 
....................    PrintRAMBytesUART(((unsigned char*)&ccls), sizeof(ccls)); 
....................  
....................    PrintROMASCIIStringUART(" dirEntriesPerSector="); 
....................    PrintRAMBytesUART(((unsigned char*)&dirEntriesPerSector), sizeof(dirEntriesPerSector)); 
....................  
....................    PrintROMASCIIStringUART(" LastClusterLimit="); 
....................    PrintRAMBytesUART(((unsigned char*)&LastClusterLimit), sizeof(LastClusterLimit)); 
....................  
....................    PrintROMASCIIStringUART(" offset2="); 
....................    PrintRAMBytesUART(((unsigned char*)&offset2), sizeof(offset2)); 
....................  
....................    PrintROMASCIIStringUART(" curEntry="); 
....................    PrintRAMBytesUART(((unsigned char*)curEntry), sizeof(WORD)); 
....................    #endif 
....................  
....................     // check if a new sector of the root must be loaded 
....................     if (ForceRead || ((*curEntry & MASK_MAX_FILE_ENTRY_LIMIT_BITS) == 0))     // only 16 entries per sector 
032D0:  CP0.B   1086
032D2:  BRA     NZ,32DE
032D4:  MOV     1084,W0
032D6:  MOV     [W0],W5
032D8:  AND     W5,#F,W5
032DA:  CP0     W5
032DC:  BRA     NZ,347E
....................     { 
....................         // see if we have to load a new cluster 
....................         if(((offset2 == 0) && (*curEntry >= dirEntriesPerSector)) || ForceRead) 
032DE:  CP0.B   1087
032E0:  BRA     NZ,32F0
032E2:  MOV     1084,W0
032E4:  MOV     [W0],W5
032E6:  MOV.B   109D,W0L
032E8:  CLR.B   1
032EA:  CP      W0,W5
032EC:  BRA     GTU,32F0
032EE:  BRA     32F4
032F0:  CP0.B   1086
032F2:  BRA     Z,336E
....................         { 
....................             if(cluster == 0) 
032F4:  CP0     1090
032F6:  BRA     NZ,3304
032F8:  CP0     1092
032FA:  BRA     NZ,3304
....................             { 
....................                 ccls = 0; 
032FC:  CLR     1098
032FE:  CLR     109A
....................             } 
03300:  GOTO    336E
....................             else 
....................             { 
....................                 // If ForceRead, read the number of sectors from 0 
....................                 if(ForceRead) 
03304:  CP0.B   1086
03306:  BRA     Z,3332
....................                     numofclus = ((WORD)(*curEntry) / (WORD)(((WORD)dirEntriesPerSector) * (WORD)dsk->SecPerClus)); 
03308:  MOV     1084,W0
0330A:  MOV     [W0],W5
0330C:  MOV.B   109D,W0L
0330E:  MOV.B   W0L,W6L
03310:  CLR.B   D
03312:  MOV     #21,W4
03314:  MOV     108A,W3
03316:  ADD     W3,W4,W0
03318:  MOV     #E,W1
0331A:  MOV     W0,W2
0331C:  MOV.B   [W2++],[W1++]
0331E:  MOV.B   W7L,W0L
03320:  CLR.B   1
03322:  MUL.UU  W6,W0,W0
03324:  MOV     W5,W4
03326:  MOV     W0,W3
03328:  REPEAT  #11
0332A:  DIV.U   W4,W3
0332C:  MOV.B   W0L,109C
0332E:  GOTO    3336
....................                 // Otherwise just read the next sector 
....................                 else 
....................                     numofclus = 1; 
03332:  MOV.B   #1,W0L
03334:  MOV.B   W0L,109C
....................  
....................                 // move to the correct cluster 
....................                 while(numofclus) 
03336:  CP0.B   109C
03338:  BRA     Z,336E
....................                 { 
....................                     ccls = ReadFAT(dsk, ccls); 
0333A:  PUSH    108A
0333C:  POP     10A2
0333E:  PUSH    1098
03340:  POP     10A4
03342:  PUSH    109A
03344:  POP     10A6
03346:  CALL    2ECC
0334A:  MOV     W0,1098
0334C:  MOV     W1,109A
....................  
....................                     if(ccls >= LastClusterLimit) 
0334E:  MOV     1096,W0
03350:  MOV     109A,W4
03352:  CP      W4,W0
03354:  BRA     NC,3368
03356:  BRA     GTU,3360
03358:  MOV     1094,W0
0335A:  MOV     1098,W4
0335C:  CP      W4,W0
0335E:  BRA     NC,3368
....................                         break; 
03360:  GOTO    336E
03364:  GOTO    336A
....................                     else 
....................                         numofclus--; 
03368:  DEC.B   109C
0336A:  GOTO    3336
....................                 } 
....................             } 
....................         } 
....................  
....................    //#ifdef __DEBUG_UART   
....................    #if 0 
....................    PrintROMASCIIStringUART(" numofclus="); 
....................    PrintRAMBytesUART(((unsigned char*)&numofclus), sizeof(numofclus)); 
....................  
....................    PrintROMASCIIStringUART(" ccls="); 
....................    PrintRAMBytesUART(((unsigned char*)&ccls), sizeof(ccls)); 
....................    #endif 
....................  
....................         // see if that we have a valid cluster number 
....................         if(ccls < LastClusterLimit) 
0336E:  MOV     109A,W0
03370:  MOV     1096,W4
03372:  CP      W4,W0
03374:  BRA     NC,3474
03376:  BRA     GTU,3380
03378:  MOV     1098,W0
0337A:  MOV     1094,W4
0337C:  CP      W4,W0
0337E:  BRA     LEU,3474
....................         { 
....................             fo->dirccls = ccls; // write it back 
03380:  MOV     #32,W0
03382:  ADD     1082,W0
03384:  MOV     W0,W5
03386:  MOV     #1098,W4
03388:  MOV     [W4++],[W5++]
0338A:  MOV     [W4++],[W5++]
....................  
....................             sector = Cluster2Sector(dsk,ccls); 
0338C:  PUSH    108A
0338E:  POP     10B0
03390:  PUSH    1098
03392:  POP     10B2
03394:  PUSH    109A
03396:  POP     10B4
03398:  CALL    308C
0339C:  MOV     W0,108C
0339E:  MOV     W1,108E
....................  
....................             //#ifdef __DEBUG_UART   
....................             #if 0 
....................             PrintROMASCIIStringUART(" sector="); 
....................             PrintRAMBytesUART(((unsigned char*)&sector), sizeof(sector)); 
....................             #endif 
....................  
....................  
....................             /* see if we are root and about to go pass our boundaries 
....................             FAT32 stores the root directory in the Data Region along with files and other directories, 
....................             allowing it to grow without such a restraint */ 
....................             if((ccls == FatRootDirClusterValue) && ((sector + offset2) >= dsk->data) && (FAT32 != dsk->type)) 
033A0:  MOV     1098,W0
033A2:  CP      8B2
033A4:  BRA     NZ,33E8
033A6:  MOV     109A,W0
033A8:  CP      8B4
033AA:  BRA     NZ,33E8
033AC:  MOV     1086,W4
033AE:  LSR     W4,#8,W4
033B0:  MOV     108C,W3
033B2:  ADD     W3,W4,W5
033B4:  MOV     108E,W3
033B6:  ADDC    W3,#0,W3
033B8:  MOV     W3,W6
033BA:  MOV     108A,W4
033BC:  ADD     W4,#E,W4
033BE:  MOV     W4,W0
033C0:  MOV     #E,W1
033C2:  MOV     W0,W2
033C4:  REPEAT  #3
033C6:  MOV.B   [W2++],[W1++]
033C8:  CP      W8,W6
033CA:  BRA     GTU,33E8
033CC:  BRA     NC,33D2
033CE:  CP      W7,W5
033D0:  BRA     GTU,33E8
033D2:  MOV     #22,W4
033D4:  MOV     108A,W3
033D6:  ADD     W3,W4,W0
033D8:  MOV     #A,W1
033DA:  MOV     W0,W2
033DC:  MOV.B   [W2++],[W1++]
033DE:  CP.B    W5L,#3
033E0:  BRA     Z,33E8
....................             { 
....................                 dir = ((DIRENTRY)NULL);   // reached the end of the root 
033E2:  CLR     1088
....................             } 
033E4:  GOTO    3470
....................             else 
....................             { 
.................... #ifdef ALLOW_WRITES 
....................                 if (gNeedDataWrite) 
033E8:  CP0.B   8AE
033EA:  BRA     Z,33F8
....................                     if (flushData()) 
033EC:  CALL    3170
033F0:  CP0.B   W0L
033F2:  BRA     Z,33F8
....................                         return NULL; 
033F4:  CLR     0
033F6:  BRA     34AA
.................... #endif 
....................                 gBufferOwner = NULL; 
033F8:  CLR     8A8
....................                 gBufferZeroed = FALSE; 
033FA:  CLR.B   8B0
....................  
....................                 if ( MDD_SectorRead( sector + offset2, dsk->buffer) != TRUE) // if FALSE: sector could not be read. 
033FC:  MOV     1086,W4
033FE:  LSR     W4,#8,W4
03400:  MOV     108C,W3
03402:  ADD     W3,W4,W5
03404:  MOV     108E,W3
03406:  ADDC    W3,#0,W3
03408:  MOV     W3,W6
0340A:  MOV     108A,W4
0340C:  ADD     W4,#0,W4
0340E:  MOV     W4,W0
03410:  MOV     #E,W1
03412:  MOV     W0,W2
03414:  REPEAT  #1
03416:  MOV.B   [W2++],[W1++]
03418:  MOV     W5,10F2
0341A:  MOV     W6,10F4
0341C:  MOV     W7,10F6
0341E:  CALL    1722
03422:  CP.B    W0L,#1
03424:  BRA     Z,342C
....................                 { 
....................                     dir = ((DIRENTRY)NULL); 
03426:  CLR     1088
....................                 } 
03428:  GOTO    346C
....................                 else // Sector has been read properly, Copy the root entry info of the file searched. 
....................                 { 
....................                     if(ForceRead)    // Buffer holds all 16 root entry info. Point to the one required. 
0342C:  CP0.B   1086
0342E:  BRA     Z,345C
....................                         dir = (DIRENTRY)((DIRENTRY)dsk->buffer) + ((*curEntry)%dirEntriesPerSector); 
03430:  MOV     108A,W4
03432:  ADD     W4,#0,W4
03434:  MOV     W4,W0
03436:  MOV     #A,W1
03438:  MOV     W0,W2
0343A:  REPEAT  #1
0343C:  MOV.B   [W2++],[W1++]
0343E:  MOV     1084,W0
03440:  MOV     [W0],W6
03442:  MOV     W6,W4
03444:  MOV.B   109D,W0L
03446:  CLR.B   1
03448:  MOV.B   W0L,W3L
0344A:  CLR.B   7
0344C:  REPEAT  #11
0344E:  DIV.U   W4,W3
03450:  MOV     W1,W6
03452:  SL      W6,#5,W0
03454:  ADD     W0,W5,W0
03456:  MOV     W0,1088
03458:  GOTO    346C
....................                     else 
....................                         dir = (DIRENTRY)dsk->buffer; 
0345C:  MOV     108A,W4
0345E:  ADD     W4,#0,W4
03460:  MOV     W4,W0
03462:  MOV     #A,W1
03464:  MOV     W0,W2
03466:  REPEAT  #1
03468:  MOV.B   [W2++],[W1++]
0346A:  MOV     W5,1088
....................                 } 
....................                //#ifdef __DEBUG_UART   
....................                #if 0 
....................                PrintROMASCIIStringUART(" dirread="); 
....................                PrintRAMBytesUART(((unsigned char*)&dir), sizeof(dir)); 
....................                #endif                 
....................                 gLastDataSectorRead = 0xFFFFFFFF; 
0346C:  SETM    8AA
0346E:  SETM    8AC
....................             } 
....................         } 
03470:  GOTO    347A
....................         else 
....................         { 
....................             nextClusterIsLast = TRUE; 
03474:  MOV.B   #1,W0L
03476:  MOV.B   W0L,8AF
....................             dir = ((DIRENTRY)NULL); 
03478:  CLR     1088
....................         } 
....................     } 
0347A:  GOTO    34A6
....................     else 
....................     { 
....................         dir = (DIRENTRY)((DIRENTRY)dsk->buffer) + ((*curEntry)%dirEntriesPerSector); 
0347E:  MOV     108A,W4
03480:  ADD     W4,#0,W4
03482:  MOV     W4,W0
03484:  MOV     #A,W1
03486:  MOV     W0,W2
03488:  REPEAT  #1
0348A:  MOV.B   [W2++],[W1++]
0348C:  MOV     1084,W0
0348E:  MOV     [W0],W6
03490:  MOV     W6,W4
03492:  MOV.B   109D,W0L
03494:  CLR.B   1
03496:  MOV.B   W0L,W3L
03498:  CLR.B   7
0349A:  REPEAT  #11
0349C:  DIV.U   W4,W3
0349E:  MOV     W1,W6
034A0:  SL      W6,#5,W0
034A2:  ADD     W0,W5,W0
034A4:  MOV     W0,1088
....................                //#ifdef __DEBUG_UART   
....................                #if 0 
....................                PrintROMASCIIStringUART(" dirmath="); 
....................                PrintRAMBytesUART(((unsigned char*)&dir), sizeof(dir)); 
....................                #endif                 
....................     } 
....................  
....................     return(dir); 
034A6:  PUSH    1088
034A8:  POP     0
034AA:  MOV     [--W15],W8
034AC:  MOV     [--W15],W7
034AE:  MOV     [--W15],W6
034B0:  MOV     [--W15],W5
034B2:  RETURN  
.................... } // Cache_File_Entry 
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     CETYPE CreateFileEntry(FILEOBJ fo, WORD *fHandle, BYTE mode, BOOL createFirstCluster) 
....................   Summary: 
....................     Create a new file entry 
....................   Conditions: 
....................     Should not be called by the user. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................     fHandle -  Location to create file 
....................     mode - DIRECTORY mode or ARCHIVE mode 
....................     createFirstCluster - If set to TRUE, first cluster is created 
....................   Return Values: 
....................     CE_GOOD -        File Creation successful 
....................     CE_DIR_FULL -    All root directory entries are taken 
....................     CE_WRITE_ERROR - The head cluster of the file could not be created. 
....................   Side Effects: 
....................     Modifies the FSerrno variable. 
....................   Description: 
....................     With the data passed within fo, create a new file entry in the current 
....................     directory.  This function will first search for empty file entries. 
....................     Once an empty entry is found, the entry will be populated with data 
....................     for a file or directory entry.  Finally, the first cluster of the 
....................     new file will be located and allocated, and its value will be 
....................     written into the file entry. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... CETYPE CreateFileEntry(FILEOBJ fo, WORD *fHandle, BYTE mode, BOOL createFirstCluster) 
*
043FA:  MOV     W5,[W15++]
043FC:  CLR.B   1032
.................... { 
....................     CETYPE  error = CE_GOOD; 
....................  
....................    #if defined(SUPPORT_LFN) 
....................    LFN_ENTRY *lfno; 
....................    unsigned short int   *templfnPtr = (unsigned short int *)fo -> utf16LFNptr,*dest; 
....................    unsigned short int   tempString[MAX_UTF16_CHARS_IN_LFN_ENTRY]; 
....................    UINT16_VAL tempShift; 
....................     BOOL    firstTime = TRUE; 
....................    BYTE   checksum,sequenceNumber,reminder,tempCalc1,numberOfFileEntries; 
....................     char    index; 
....................    char    *src; 
....................    #endif 
....................  
....................    FSerrno = CE_GOOD; 
043FE:  CLR.B   8B1
....................  
....................    *fHandle = 0; 
04400:  MOV     102E,W5
04402:  CLR.B   [W5]
04404:  MOV.B   #0,W0L
04406:  MOV.B   W0L,[W5+#1]
....................  
....................     // figure out where to put this file in the directory stucture 
....................     if(FindEmptyEntries(fo, fHandle) == FOUND) 
04408:  PUSH    102C
0440A:  POP     1038
0440C:  PUSH    102E
0440E:  POP     103A
04410:  CALL    3F70
04414:  CP0.B   W0L
04416:  BRA     NZ,4444
....................     { 
....................       #if defined(SUPPORT_LFN) 
....................       // If LFN entry 
....................       if(fo->utf16LFNlength) 
....................       { 
....................          // Alias the LFN to short file name 
....................          if(!Alias_LFN_Object(fo)) 
....................          { 
....................             // If Aliasing of LFN is unsucessful 
....................             error = FSerrno = CE_FILENAME_EXISTS; 
....................             return(error); 
....................          } 
....................  
....................          src = fo -> name; 
....................  
....................            // Find the checksum for Short file name of LFN 
....................            checksum = 0; 
....................            for (index = 11; index != 0; index--) 
....................            { 
....................             checksum = ((checksum & 1) ? 0x80 : 0) + (checksum >> 1) + *src++; 
....................          } 
....................  
....................          // File Name + NULL character is file name length in LFN 
....................          fileNameLength = fo->utf16LFNlength; 
....................  
....................          // Determine the number of entries for LFN 
....................          reminder = tempCalc1 = fileNameLength % MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................          numberOfFileEntries = fileNameLength/MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................          if(tempCalc1 || (fileNameLength < MAX_UTF16_CHARS_IN_LFN_ENTRY)) 
....................          { 
....................             numberOfFileEntries++; 
....................          } 
....................  
....................          // Max sequence number for LFN root entry 
....................          sequenceNumber = numberOfFileEntries | 0x40; 
....................  
....................          // Store the max sequence number entries in tempString 
....................          if(tempCalc1) 
....................          { 
....................             index = 0; 
....................             while(tempCalc1) 
....................             { 
....................                tempString[(BYTE)index++] = templfnPtr[fileNameLength - tempCalc1]; 
....................                tempCalc1--; 
....................             } 
....................  
....................             tempString[(BYTE)index++] = 0x0000; 
....................  
....................             // Store the remaining bytes of max sequence number entries with 0xFF 
....................             for(;index < MAX_UTF16_CHARS_IN_LFN_ENTRY;index++) 
....................             { 
....................                tempString[(BYTE)index] = 0xFFFF; 
....................             } 
....................          } 
....................          else 
....................          { 
....................             // Store the remaining bytes of max sequence number entries with 0xFF 
....................             for(index = MAX_UTF16_CHARS_IN_LFN_ENTRY;index > 0;index--) 
....................             { 
....................                tempString[MAX_UTF16_CHARS_IN_LFN_ENTRY - (BYTE)index] = templfnPtr[fileNameLength - (BYTE)index]; 
....................             } 
....................          } 
....................  
....................          dest = &tempString[12]; 
....................  
....................          while(numberOfFileEntries) 
....................          { 
....................             fo->dirccls = fo->dirclus; 
....................              lfno = (LFN_ENTRY *)Cache_File_Entry( fo, fHandle, TRUE); 
....................  
....................              if (lfno == NULL) 
....................             { 
....................                  return CE_BADCACHEREAD; 
....................             } 
....................  
....................             // Write the 32 byte LFN Object as per FAT specification 
....................             lfno->LFN_SequenceNo = sequenceNumber--;   // Sequence number, 
....................  
....................             lfno->LFN_Part3[1] = *dest--; 
....................             lfno->LFN_Part3[0] = *dest--; 
....................  
....................             lfno->LFN_Part2[5] = *dest--; 
....................             lfno->LFN_Part2[4] = *dest--; 
....................             lfno->LFN_Part2[3] = *dest--; 
....................             lfno->LFN_Part2[2] = *dest--; 
....................             lfno->LFN_Part2[1] = *dest--; 
....................             lfno->LFN_Part2[0] = *dest--; 
....................  
....................             tempShift.Val = *dest--; 
....................             lfno->LFN_Part1[9] = tempShift.byte.HB; 
....................             lfno->LFN_Part1[8] = tempShift.byte.LB; 
....................             tempShift.Val = *dest--; 
....................             lfno->LFN_Part1[7] = tempShift.byte.HB; 
....................             lfno->LFN_Part1[6] = tempShift.byte.LB; 
....................             tempShift.Val = *dest--; 
....................             lfno->LFN_Part1[5] = tempShift.byte.HB; 
....................             lfno->LFN_Part1[4] = tempShift.byte.LB; 
....................             tempShift.Val = *dest--; 
....................             lfno->LFN_Part1[3] = tempShift.byte.HB; 
....................             lfno->LFN_Part1[2] = tempShift.byte.LB; 
....................             tempShift.Val = *dest--; 
....................             lfno->LFN_Part1[1] = tempShift.byte.HB; 
....................             lfno->LFN_Part1[0] = tempShift.byte.LB; 
....................  
....................             lfno->LFN_Attribute = ATTR_LONG_NAME; 
....................             lfno->LFN_Type = 0; 
....................             lfno->LFN_Checksum = checksum; 
....................             lfno->LFN_Reserved2 = 0; 
....................  
....................              // just write the last entry in 
....................              if (Write_File_Entry(fo,fHandle) != TRUE) 
....................                  error = CE_WRITE_ERROR; 
....................  
....................                // 0x40 should be ORed with only max sequence number & in 
....................             // all other cases it should not be present 
....................                sequenceNumber &= (~0x40); 
....................                *fHandle = *fHandle + 1; 
....................             numberOfFileEntries--; 
....................  
....................             // Load the destination address only once and during first time, 
....................             if(firstTime) 
....................             { 
....................                if(reminder) 
....................                   dest = (unsigned short int *)(fo -> utf16LFNptr + fileNameLength - reminder - 1); 
....................                else 
....................                   dest = (unsigned short int *)(fo -> utf16LFNptr + fileNameLength - MAX_UTF16_CHARS_IN_LFN_ENTRY - 1); 
....................                firstTime = FALSE; 
....................             } 
....................          } 
....................       } 
....................       #endif 
....................  
....................         // found the entry, now populate it 
....................         if((error = PopulateEntries(fo, fHandle, mode)) == CE_GOOD) 
04418:  MOV.B   1030,W0L
0441A:  MOV.B   W0L,103C
0441C:  PUSH    102C
0441E:  POP     1038
04420:  PUSH    102E
04422:  POP     103A
04424:  CALL    40EA
04428:  MOV.B   W0L,1032
0442A:  CP0.B   1032
0442C:  BRA     NZ,4440
....................         { 
....................          if(createFirstCluster) 
0442E:  CP0.B   1031
04430:  BRA     Z,4440
....................                // if everything is ok, create a first cluster 
....................                error = CreateFirstCluster(fo); 
04432:  PUSH    102C
04434:  POP     1038
04436:  CALL    4380
0443A:  MOV.B   W0L,1032
0443C:  GOTO    4440
....................          else 
....................          { 
....................  
....................          } 
....................         } 
....................     } 
04440:  GOTO    4448
....................     else 
....................     { 
....................         error = CE_DIR_FULL; 
04444:  MOV.B   #14,W0L
04446:  MOV.B   W0L,1032
....................     } 
....................  
....................     FSerrno = error; 
04448:  MOV.B   1032,W0L
0444A:  MOV.B   W0L,8B1
....................  
....................     return(error); 
0444C:  MOV.B   1032,W0L
0444E:  MOV.B   W0L,0
04450:  MOV     [--W15],W5
04452:  RETURN  
.................... } 
.................... #endif 
....................  
.................... /****************************************************** 
....................   Function: 
....................     CETYPE CreateFirstCluster(FILEOBJ fo) 
....................   Summary: 
....................     Create the first cluster for a file 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -  The file that contains the first cluster 
....................   Return Values: 
....................     CE_GOOD -        First cluster created successfully 
....................     CE_WRITE_ERROR - Cluster creation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will find an unused cluster, link it to 
....................     a file's directory entry, and write the entry back 
....................     to the device. 
....................   Remarks: 
....................     None. 
....................   ******************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... CETYPE CreateFirstCluster(FILEOBJ fo) 
*
04380:  MOV     W5,[W15++]
.................... { 
....................     CETYPE       error; 
04382:  CLR.B   103A
....................     DWORD      cluster,TempMsbCluster; 
04384:  CLR     103C
04386:  CLR     103E
04388:  CLR     1040
0438A:  CLR     1042
....................     WORD        fHandle; 
0438C:  CLR     1044
....................     DIRENTRY   dir; 
0438E:  CLR     1046
....................     fHandle = fo->entry; 
04390:  MOV     #28,W0
04392:  ADD     1038,W0
04394:  MOV     [W0],[W15++]
04396:  POP     1044
....................  
....................     // Now create the first cluster (head cluster) 
....................     if((error = FILECreateHeadCluster(fo,&cluster)) == CE_GOOD) 
04398:  PUSH    1038
0439A:  POP     104A
0439C:  MOV     #103C,W4
0439E:  MOV     W4,104C
043A0:  CALL    421E
043A4:  MOV.B   W0L,103A
043A6:  CP0.B   103A
043A8:  BRA     NZ,43F2
....................     { 
....................         // load the file entry so the new cluster can be linked to it 
....................         dir = LoadDirAttrib(fo, &fHandle); 
043AA:  PUSH    1038
043AC:  POP     104A
043AE:  MOV     #1044,W4
043B0:  MOV     W4,104C
043B2:  CALL    42F0
043B6:  MOV     W0,1046
....................  
....................         // Now update the new cluster 
....................         dir->DIR_FstClusLO = (cluster & 0x0000FFFF); 
043B8:  MOV     #1A,W0
043BA:  ADD     1046,W0
043BC:  MOV     W0,W5
043BE:  CLR     W1
043C0:  MOV     103C,W0
043C2:  MOV     W0,[W5]
....................  
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         // Get the higher part of cluster and store it in directory entry. 
....................        TempMsbCluster = (cluster & 0x0FFF0000);    // Since only 28 bits usedin FAT32. Mask the higher MSB nibble. 
043C4:  CLR     1040
043C6:  PUSH    103E
043C8:  POP     1042
043CA:  MOV     #FFF,W0
043CC:  AND     1042
....................        TempMsbCluster = TempMsbCluster >> 16;      // Get the date into Lsb place. 
043CE:  PUSH    1042
043D0:  POP     1040
043D2:  CLR     1042
....................        dir->DIR_FstClusHI = TempMsbCluster; 
043D4:  MOV     #14,W0
043D6:  ADD     1046,W0
043D8:  MOV     W0,W5
043DA:  MOV     1040,W4
043DC:  MOV     W4,[W5+#0]
.................... #else // If FAT32 support not enabled 
....................        TempMsbCluster = 0;                         // Just to avoid compiler warnigng. 
....................        dir->DIR_FstClusHI = 0; 
.................... #endif 
....................  
....................         // now write it 
....................         if(Write_File_Entry(fo, &fHandle) != TRUE) 
043DE:  PUSH    1038
043E0:  POP     1060
043E2:  MOV     #1044,W4
043E4:  MOV     W4,1062
043E6:  CALL    3964
043EA:  CP.B    W0L,#1
043EC:  BRA     Z,43F2
....................             error = CE_WRITE_ERROR; 
043EE:  MOV.B   #9,W0L
043F0:  MOV.B   W0L,103A
....................     } // Create Cluster 
....................  
....................     return(error); 
043F2:  MOV.B   103A,W0L
043F4:  MOV.B   W0L,0
043F6:  MOV     [--W15],W5
043F8:  RETURN  
.................... }// End of CreateFirstCluster 
.................... #endif 
....................  
.................... /********************************************************** 
....................   Function: 
....................     BYTE FindEmptyEntries(FILEOBJ fo, WORD *fHandle) 
....................   Summary: 
....................     Find an empty dir entry 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................     fHandle -  Start of entries 
....................   Return Values: 
....................     TRUE - One found 
....................     FALSE - None found 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache directory entries, starting 
....................     with the one pointed to by the fHandle argument.  It will 
....................     then search through the entries until an unused one 
....................     is found.  If the end of the cluster chain for the 
....................     directory is reached, a new cluster will be allocated 
....................     to the directory (unless it's a FAT12 or FAT16 root) 
....................     and the first entry of the new cluster will be used. 
....................   Remarks: 
....................     None. 
....................   **********************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE FindEmptyEntries(FILEOBJ fo, WORD *fHandle) 
*
03F70:  MOV     W5,[W15++]
03F72:  MOV     W6,[W15++]
03F74:  MOV     W7,[W15++]
03F76:  MOV.B   #1,W0L
03F78:  MOV.B   W0L,103C
*
03F7E:  CLR.B   103F
03F80:  MOV     103A,W0
03F82:  MOV     [W0],[W15++]
03F84:  POP     1040
.................... { 
....................     BYTE   status = NOT_FOUND; 
....................     BYTE   amountfound,numberOfFileEntries; 
*
03F7A:  CLR.B   103D
03F7C:  CLR.B   103E
....................     BYTE   a = 0; 
....................     WORD   bHandle = *fHandle; 
....................     DWORD b; 
*
03F86:  CLR     1042
03F88:  CLR     1044
....................     DIRENTRY    dir; 
03F8A:  CLR     1046
....................  
....................     fo->dirccls = fo->dirclus; 
03F8C:  MOV     #32,W0
03F8E:  ADD     1038,W0
03F90:  MOV     W0,W5
03F92:  MOV     #2E,W0
03F94:  ADD     1038,W0
03F96:  MOV     [W0++],[W5++]
03F98:  MOV     [W0++],[W5++]
....................     if((dir = Cache_File_Entry( fo, fHandle, TRUE)) != NULL) 
03F9A:  MOV.B   #1,W0L
03F9C:  MOV.B   W0L,1086
03F9E:  PUSH    1038
03FA0:  POP     1082
03FA2:  PUSH    103A
03FA4:  POP     1084
03FA6:  CALL    31E4
03FAA:  MOV     W0,1046
03FAC:  CP0     1046
03FAE:  BRA     Z,409A
....................     { 
....................       #if defined(SUPPORT_LFN) 
....................       // If LFN entry 
....................       if(fo->utf16LFNlength) 
....................       { 
....................          // File Name + NULL character is file name length in LFN 
....................          fileNameLength = fo->utf16LFNlength; 
....................  
....................          // Determine the number of entries for LFN 
....................          a = fileNameLength % MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................          numberOfFileEntries = fileNameLength/MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................          if(a || (fileNameLength < MAX_UTF16_CHARS_IN_LFN_ENTRY)) 
....................          { 
....................             numberOfFileEntries++; 
....................          } 
....................  
....................             // Increment by 1 so that you have space to store for assosciated short file name 
....................             numberOfFileEntries = numberOfFileEntries + 1; 
....................       } 
....................       else 
....................       #endif 
....................             numberOfFileEntries = 1; 
03FB0:  MOV.B   #1,W0L
03FB2:  MOV.B   W0L,103E
....................  
....................         // while its still not found 
....................         while(status == NOT_FOUND) 
03FB4:  MOV     103C,W4
03FB6:  CP.B    W4L,#1
03FB8:  BRA     NZ,409A
....................         { 
....................             amountfound = 0; 
03FBA:  CLR.B   103D
....................             bHandle = *fHandle; 
03FBC:  MOV     103A,W0
03FBE:  MOV     [W0],[W15++]
03FC0:  POP     1040
....................  
....................             // find (number) continuous entries 
....................             do 
....................             { 
....................                 // Get the entry 
....................                 dir = Cache_File_Entry( fo, fHandle, FALSE); 
03FC2:  CLR.B   1086
03FC4:  PUSH    1038
03FC6:  POP     1082
03FC8:  PUSH    103A
03FCA:  POP     1084
03FCC:  CALL    31E4
03FD0:  MOV     W0,1046
....................  
....................                 // Read the first char of the file name 
....................                 if(dir != NULL) // Last entry of the cluster 
03FD2:  CP0     1046
03FD4:  BRA     Z,3FE2
....................                 { 
....................                     a = dir->DIR_Name[0]; 
03FD6:  MOV     #0,W0
03FD8:  ADD     1046,W0
03FDA:  MOV     W0,[W15++]
03FDC:  MOV.B   [W0],W0L
03FDE:  MOV.B   W0L,103F
03FE0:  MOV     [--W15],W0
....................                 } 
....................                 // increase number 
....................                 (*fHandle)++; 
03FE2:  MOV     103A,W5
03FE4:  INC     [W5],[W5]
....................             }while((dir != (DIRENTRY)NULL) && ((a == DIR_DEL) || (a == DIR_EMPTY)) && (++amountfound < numberOfFileEntries)); 
03FE6:  CP0     1046
03FE8:  BRA     Z,4000
03FEA:  MOV     103E,W4
03FEC:  LSR     W4,#8,W4
03FEE:  XOR.B   #E5,W4L
03FF0:  BRA     Z,3FF6
03FF2:  CP0.B   103F
03FF4:  BRA     NZ,4000
03FF6:  INC.B   103D
03FF8:  MOV.B   103D,W0L
03FFA:  MOV     103E,W4
03FFC:  CP.B    W4L,W0L
03FFE:  BRA     GTU,3FC2
....................  
....................             // --- now why did we exit? 
....................             if(dir == NULL) // Last entry of the cluster 
04000:  CP0     1046
04002:  BRA     NZ,408E
....................             { 
....................                 //setup the current cluster 
....................                 b = fo->dirccls; // write it back 
04004:  MOV     #32,W0
04006:  ADD     1038,W0
04008:  MOV     #1042,W4
0400A:  MOV     [W0++],[W4++]
0400C:  MOV     [W0++],[W4++]
....................  
....................                 // make sure we are not the root directory 
....................                 if(b == FatRootDirClusterValue) 
0400E:  MOV     1042,W0
04010:  CP      8B2
04012:  BRA     NZ,4064
04014:  MOV     1044,W0
04016:  CP      8B4
04018:  BRA     NZ,4064
....................                 { 
....................                     if (fo->dsk->type != FAT32) 
0401A:  MOV     #0,W0
0401C:  ADD     1038,W0
0401E:  MOV     W0,W5
04020:  MOV     W5,W0
04022:  MOV     [W0],W6
04024:  MOV     #22,W4
04026:  ADD     W6,W4,W0
04028:  MOV     #E,W1
0402A:  MOV     W0,W2
0402C:  MOV.B   [W2++],[W1++]
0402E:  CP.B    W7L,#3
04030:  BRA     Z,403A
....................                         status = NO_MORE; 
04032:  MOV.B   #2,W0L
04034:  MOV.B   W0L,103C
04036:  GOTO    4060
....................                     else 
....................                     { 
....................                         fo->ccls = b; 
0403A:  MOV     #6,W0
0403C:  ADD     1038,W0
0403E:  MOV     W0,W5
04040:  MOV     #1042,W4
04042:  MOV     [W4++],[W5++]
04044:  MOV     [W4++],[W5++]
....................  
....................                         if(FILEallocate_new_cluster(fo, 1) == CE_DISK_FULL) 
04046:  MOV.B   #1,W0L
04048:  MOV.B   W0L,104E
0404A:  PUSH    1038
0404C:  POP     104C
0404E:  CALL    3E9C
04052:  CP.B    W0L,#15
04054:  BRA     NZ,405E
....................                             status = NO_MORE; 
04056:  MOV.B   #2,W0L
04058:  MOV.B   W0L,103C
0405A:  GOTO    4060
....................                         else 
....................                             status = FOUND;     // a new cluster will surely hold a new file name 
0405E:  CLR.B   103C
....................                     } 
....................                 } 
04060:  GOTO    408A
....................                 else 
....................                 { 
....................                     fo->ccls = b; 
04064:  MOV     #6,W0
04066:  ADD     1038,W0
04068:  MOV     W0,W5
0406A:  MOV     #1042,W4
0406C:  MOV     [W4++],[W5++]
0406E:  MOV     [W4++],[W5++]
....................  
....................                     if(FILEallocate_new_cluster(fo, 1) == CE_DISK_FULL) 
04070:  MOV.B   #1,W0L
04072:  MOV.B   W0L,104E
04074:  PUSH    1038
04076:  POP     104C
04078:  CALL    3E9C
0407C:  CP.B    W0L,#15
0407E:  BRA     NZ,4088
....................                         status = NO_MORE; 
04080:  MOV.B   #2,W0L
04082:  MOV.B   W0L,103C
04084:  GOTO    408A
....................                     else 
....................                     { 
....................                         status = FOUND;     // a new cluster will surely hold a new file name 
04088:  CLR.B   103C
....................                     } 
....................                 } 
....................             } 
0408A:  GOTO    4096
....................             else 
....................             { 
....................                 if(amountfound == numberOfFileEntries) 
0408E:  MOV.B   103D,W0L
04090:  CP.B    103E
04092:  BRA     NZ,4096
....................                     status = FOUND; 
04094:  CLR.B   103C
....................             } 
04096:  GOTO    3FB4
....................         }// while 
....................     } 
....................  
....................     // copy the base handle over 
....................    *fHandle = bHandle; 
0409A:  MOV     103A,W5
0409C:  MOV     1040,W4
0409E:  MOV     W4,[W5+#0]
....................  
....................    return(status); 
040A0:  MOV.B   103C,W0L
040A2:  MOV.B   W0L,0
040A4:  MOV     [--W15],W7
040A6:  MOV     [--W15],W6
040A8:  MOV     [--W15],W5
040AA:  RETURN  
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     BYTE PopulateEntries(FILEOBJ fo, WORD *fHandle, BYTE mode) 
....................   Summary: 
....................     Populate a dir entry with data 
....................   Conditions: 
....................     Should not be called by the user. 
....................   Input: 
....................     fo -      Pointer to file structure 
....................     fHandle - Location of the file 
....................     mode - DIRECTORY mode or ARCHIVE mode 
....................   Return Values: 
....................     CE_GOOD - Population successful 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will write data into a new file entry.  It will also 
....................     load timestamp data (based on the method selected by the user) and 
....................     update the timestamp variables. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE PopulateEntries(FILEOBJ fo, WORD *fHandle, BYTE mode) 
*
040EA:  MOV     W5,[W15++]
040EC:  MOV     W6,[W15++]
040EE:  CLR.B   103D
.................... { 
....................     BYTE error = CE_GOOD; 
....................     DIRENTRY    dir; 
040F0:  CLR     103E
....................  
....................     fo->dirccls = fo->dirclus; 
040F2:  MOV     #32,W0
040F4:  ADD     1038,W0
040F6:  MOV     W0,W5
040F8:  MOV     #2E,W0
040FA:  ADD     1038,W0
040FC:  MOV     [W0++],[W5++]
040FE:  MOV     [W0++],[W5++]
....................     dir = Cache_File_Entry( fo, fHandle, TRUE); 
04100:  MOV.B   #1,W0L
04102:  MOV.B   W0L,1086
04104:  PUSH    1038
04106:  POP     1082
04108:  PUSH    103A
0410A:  POP     1084
0410C:  CALL    31E4
04110:  MOV     W0,103E
....................  
....................     if (dir == NULL) 
04112:  CP0     103E
04114:  BRA     NZ,411C
....................         return CE_BADCACHEREAD; 
04116:  MOV.B   #1B,W0L
04118:  MOV.B   W0L,0
0411A:  BRA     4218
....................  
....................     // copy the contents over 
....................     strncpy(dir->DIR_Name,fo->name,DIR_NAMECOMP); 
0411C:  MOV     #0,W0
0411E:  ADD     103E,W0
04120:  MOV     W0,W5
04122:  MOV     #1C,W0
04124:  ADD     1038,W0
04126:  MOV     W0,W6
04128:  MOV     W5,104A
0412A:  MOV     W6,104C
0412C:  MOV     #B,W4
0412E:  MOV     W4,104E
04130:  CALL    40AC
....................  
....................     // setup no attributes 
....................     if (mode == DIRECTORY) 
04134:  MOV     103C,W4
04136:  CP.B    W4L,#12
04138:  BRA     NZ,4148
....................         dir->DIR_Attr = ATTR_DIRECTORY; 
0413A:  MOV     #B,W0
0413C:  ADD     103E,W0
0413E:  MOV     W0,W5
04140:  MOV.B   #10,W0L
04142:  MOV.B   W0L,[W5]
04144:  GOTO    4152
....................     else 
....................         dir->DIR_Attr   = ATTR_ARCHIVE; 
04148:  MOV     #B,W0
0414A:  ADD     103E,W0
0414C:  MOV     W0,W5
0414E:  MOV.B   #20,W0L
04150:  MOV.B   W0L,[W5]
....................  
....................     dir->DIR_NTRes  = 0x00;              // nt reserved 
04152:  MOV     #C,W0
04154:  ADD     103E,W0
04156:  MOV     W0,W5
04158:  CLR.B   [W5]
....................     dir->DIR_FstClusHI =    0x0000;      // high word of this enty's first cluster number 
0415A:  MOV     #14,W0
0415C:  ADD     103E,W0
0415E:  MOV     W0,W5
04160:  CLR.B   [W5]
04162:  MOV.B   #0,W0L
04164:  MOV.B   W0L,[W5+#1]
....................     dir->DIR_FstClusLO =    0x0000;      // low word of this entry's first cluster number 
04166:  MOV     #1A,W0
04168:  ADD     103E,W0
0416A:  MOV     W0,W5
0416C:  CLR.B   [W5]
0416E:  MOV.B   #0,W0L
04170:  MOV.B   W0L,[W5+#1]
....................     dir->DIR_FileSize =     0x0;         // file size in DWORD 
04172:  MOV     #1C,W0
04174:  ADD     103E,W0
04176:  MOV     W0,W5
04178:  CLR.B   [W5]
0417A:  MOV.B   #0,W0L
0417C:  MOV.B   W0L,[W5+#1]
0417E:  MOV.B   #0,W0L
04180:  MOV.B   W0L,[W5+#2]
04182:  MOV.B   #0,W0L
04184:  MOV.B   W0L,[W5+#3]
....................  
....................    // Timing information for uncontrolled clock mode 
.................... #ifdef INCREMENTTIMESTAMP 
....................     dir->DIR_CrtTimeTenth = 0xB2;        // millisecond stamp 
....................     dir->DIR_CrtTime =      0x7278;      // time created 
....................     dir->DIR_CrtDate =      0x32B0;      // date created 
....................     dir->DIR_LstAccDate =   0x32B0;      // Last Access date 
....................     dir->DIR_WrtTime =      0x7279;      // last update time 
....................     dir->DIR_WrtDate =      0x32B0;      // last update date 
.................... #endif 
....................  
.................... #ifdef USEREALTIMECLOCK 
....................     CacheTime(); 
....................     dir->DIR_CrtTimeTenth = gTimeCrtMS;        // millisecond stamp 
....................     dir->DIR_CrtTime =      gTimeCrtTime;      // time created // 
....................     dir->DIR_CrtDate =      gTimeCrtDate;      // date created (1/1/2004) 
....................     dir->DIR_LstAccDate =   gTimeAccDate;      // Last Access date 
....................     dir->DIR_WrtTime =      gTimeWrtTime;      // last update time 
....................     dir->DIR_WrtDate =      gTimeWrtDate;      // last update date 
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................     // The user will have set the time before this funciton is called 
....................     dir->DIR_CrtTimeTenth = gTimeCrtMS; 
04186:  MOV     #D,W0
04188:  ADD     103E,W0
0418A:  MOV     W0,W5
0418C:  MOV     898,W0
0418E:  MOV.B   W0L,[W5+#0]
....................     dir->DIR_CrtTime =      gTimeCrtTime; 
04190:  MOV     #E,W0
04192:  ADD     103E,W0
04194:  MOV     W0,W5
04196:  MOV     89A,W4
04198:  MOV     W4,[W5+#0]
....................     dir->DIR_CrtDate =       gTimeCrtDate; 
0419A:  MOV     #10,W0
0419C:  ADD     103E,W0
0419E:  MOV     W0,W5
041A0:  MOV     89C,W4
041A2:  MOV     W4,[W5+#0]
....................     dir->DIR_LstAccDate =   gTimeAccDate; 
041A4:  MOV     #12,W0
041A6:  ADD     103E,W0
041A8:  MOV     W0,W5
041AA:  MOV     89E,W4
041AC:  MOV     W4,[W5+#0]
....................     dir->DIR_WrtTime =       gTimeWrtTime; 
041AE:  MOV     #16,W0
041B0:  ADD     103E,W0
041B2:  MOV     W0,W5
041B4:  MOV     8A0,W4
041B6:  MOV     W4,[W5+#0]
....................     dir->DIR_WrtDate =      gTimeWrtDate; 
041B8:  MOV     #18,W0
041BA:  ADD     103E,W0
041BC:  MOV     W0,W5
041BE:  MOV     8A2,W4
041C0:  MOV     W4,[W5+#0]
.................... #endif 
....................  
....................     fo->size        = dir->DIR_FileSize; 
041C2:  MOV     #12,W0
041C4:  ADD     1038,W0
041C6:  MOV     W0,W5
041C8:  MOV     #1C,W0
041CA:  ADD     103E,W0
041CC:  MOV     [W0++],[W5++]
041CE:  MOV     [W0++],[W5++]
....................     fo->time        = dir->DIR_CrtTime; 
041D0:  MOV     #18,W0
041D2:  ADD     1038,W0
041D4:  MOV     W0,W5
041D6:  MOV     #E,W0
041D8:  ADD     103E,W0
041DA:  MOV     [W0],[W5]
....................     fo->date        = dir->DIR_CrtDate; 
041DC:  MOV     #1A,W0
041DE:  ADD     1038,W0
041E0:  MOV     W0,W5
041E2:  MOV     #10,W0
041E4:  ADD     103E,W0
041E6:  MOV     [W0],[W5]
....................     fo->attributes  = dir->DIR_Attr; 
041E8:  MOV     #2C,W0
041EA:  ADD     1038,W0
041EC:  MOV     W0,W5
041EE:  MOV     #B,W0
041F0:  ADD     103E,W0
041F2:  MOV.B   [W0],[W5]
041F4:  MOV.B   #0,W4L
041F6:  MOV.B   W4L,[W5+#1]
....................     fo->entry       = *fHandle; 
041F8:  MOV     #28,W0
041FA:  ADD     1038,W0
041FC:  MOV     W0,W5
041FE:  MOV     103A,W0
04200:  MOV     [W0],[W5]
....................  
....................     // just write the last entry in 
....................     if (Write_File_Entry(fo,fHandle) != TRUE) 
04202:  PUSH    1038
04204:  POP     1060
04206:  PUSH    103A
04208:  POP     1062
0420A:  CALL    3964
0420E:  CP.B    W0L,#1
04210:  BRA     Z,4216
....................         error = CE_WRITE_ERROR; 
04212:  MOV.B   #9,W0L
04214:  MOV.B   W0L,103D
....................  
....................     return(error); 
04216:  MOV.B   103D,W0L
04218:  MOV     [--W15],W6
0421A:  MOV     [--W15],W5
0421C:  RETURN  
.................... } 
....................  
.................... /***************************************************************** 
....................   Function: 
....................     BOOL Alias_LFN_Object(FILEOBJ fo) 
....................   Summary: 
....................     Find the Short file name of the LFN entry 
....................   Conditions: 
....................     Long file name should be present. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................   Return Values: 
....................     FOUND -     Operation successful 
....................     NOT_FOUND - Operation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will find the short file name 
....................     of the long file name as mentioned in the FAT 
....................     specs. 
....................   Remarks: 
....................     None. 
....................   *****************************************************************/ 
.................... #if defined(SUPPORT_LFN) 
.................... BOOL Alias_LFN_Object(FILEOBJ fo) 
.................... { 
....................    FSFILE      filePtr1; 
....................    FSFILE      filePtr2; 
....................    unsigned long int index4; 
....................    short int   lfnIndex,index1,index2; 
....................     BYTE  tempVariable,index; 
....................    char  tempString[8]; 
....................    char  *lfnAliasPtr; 
....................    unsigned short int  *templfnPtr; 
....................    BOOL result = FALSE; 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&filePtr1, fo); 
....................  
....................    lfnAliasPtr = (char *)&filePtr1.name[0]; 
....................  
....................    templfnPtr = (unsigned short int *)filePtr1.utf16LFNptr; 
....................  
....................    fileNameLength = fo->utf16LFNlength; 
....................  
....................    // Initially fill the alias name with space characters 
....................    for(index1 = 0;index1 < FILE_NAME_SIZE_8P3;index1++) 
....................    { 
....................       lfnAliasPtr[index1] = ' '; 
....................    } 
....................  
....................    // find the location where '.' is present 
....................    for(lfnIndex = fileNameLength - 1;lfnIndex > 0;lfnIndex--) 
....................    { 
....................       if (templfnPtr[lfnIndex] == '.') 
....................       { 
....................           break; 
....................       } 
....................    } 
....................  
....................    index1 = lfnIndex + 1; 
....................  
....................    tempVariable = 0; 
....................    if(lfnIndex) 
....................    { 
....................       index2 = 8; 
....................       // Complete the extension part as per the FAT specifications 
....................       for(;((index1 < fileNameLength) && (tempVariable < 3));index1++) 
....................       { 
....................          // Convert lower-case to upper-case 
....................          index = (BYTE)templfnPtr[index1]; 
....................          if ((index >= 0x61) && (index <= 0x7A)) 
....................          { 
....................              lfnAliasPtr[index2++] = index - 0x20; 
....................          } 
....................          else if(index == ' ') 
....................          { 
....................             continue; 
....................          } 
....................          else if ((index == 0x2B) || (index == 0x2C) || (index == 0x3B) || 
....................                (index == 0x3D) || (index == 0x5B) || (index == 0x5D) || 
....................                (templfnPtr[index1] > 0xFF)) 
....................          { 
....................              lfnAliasPtr[index2++] = '_'; 
....................          } 
....................          else 
....................          { 
....................              lfnAliasPtr[index2++] = index; 
....................          } 
....................  
....................          tempVariable++; 
....................       } 
....................  
....................       index2 = lfnIndex; 
....................       tempVariable = 0; 
....................    } 
....................    else 
....................    { 
....................       index2 = fileNameLength; 
....................    } 
....................  
....................    // Fill the base part as per the FAT specifications 
....................    for(index1 = 0;((index1 < index2) && (tempVariable < 6));index1++) 
....................    { 
....................       // Convert lower-case to upper-case 
....................       index = (BYTE)templfnPtr[index1]; 
....................       if ((index >= 0x61) && (index <= 0x7A)) 
....................       { 
....................           lfnAliasPtr[tempVariable] = index - 0x20; 
....................       } 
....................       else if(index == ' ') 
....................       { 
....................          continue; 
....................       } 
....................       else if ((index == 0x2B) || (index == 0x2C) || (index == 0x3B) || 
....................             (index == 0x3D) || (index == 0x5B) || (index == 0x5D) || 
....................             (templfnPtr[index1] > 0xFF)) 
....................       { 
....................           lfnAliasPtr[tempVariable] = '_'; 
....................       } 
....................       else 
....................       { 
....................           lfnAliasPtr[tempVariable] = index; 
....................       } 
....................       tempVariable++; 
....................    } 
....................  
....................    // Aliasing of the predicted name should append ~1 
....................    lfnAliasPtr[tempVariable] = '~'; 
....................    lfnAliasPtr[tempVariable + 1] = '1'; 
....................  
....................     filePtr1.attributes = ATTR_ARCHIVE; 
....................  
....................    filePtr1.utf16LFNlength = 0; 
....................  
....................    // Try for 9999999 combinations before telling error to the user 
....................    for(index4 = 1;index4 < (unsigned long int)10000000;index4++) 
....................    { 
....................        filePtr1.cluster = 0; 
....................        filePtr1.ccls    = 0; 
....................        filePtr1.entry = 0; 
....................  
....................           // start at the current directory 
....................       #ifdef ALLOW_DIRS 
....................           filePtr1.dirclus    = cwdptr->dirclus; 
....................           filePtr1.dirccls    = cwdptr->dirccls; 
....................       #else 
....................           filePtr1.dirclus = FatRootDirClusterValue; 
....................           filePtr1.dirccls = FatRootDirClusterValue; 
....................       #endif 
....................  
....................        // copy file object over 
....................        FileObjectCopy(&filePtr2, &filePtr1); 
....................  
....................        // See if the file is found 
....................        if(FILEfind (&filePtr2, &filePtr1, LOOK_FOR_MATCHING_ENTRY, 0) == CE_GOOD) 
....................       { 
....................          tempString[7] = index4 % (BYTE)10 + '0'; 
....................          tempString[6] = (index4 % (BYTE)100)/10 + '0'; 
....................          tempString[5] = (index4 % 1000)/100 + '0'; 
....................          tempString[4] = (index4 % 10000)/1000 + '0'; 
....................          tempString[3] = (index4 % 100000)/10000 + '0'; 
....................          tempString[2] = (index4 % 1000000)/100000 + '0'; 
....................          if((tempString[1] = ((index4 % 10000000)/1000000 + '0')) != '0') 
....................          { 
....................                tempString[index = 0] = '~'; 
....................          } 
....................          else 
....................          { 
....................             for(index = 6;index > 0;index--) 
....................             { 
....................                if((tempString[index] == '0') && (tempString[index - 1] == '0')) 
....................                { 
....................                   tempString[index] = '~'; 
....................                   if(!filePtr1.AsciiEncodingType) 
....................                   { 
....................                      if(index % 2) 
....................                      { 
....................                         for(index2 = index - 1;index2 < 7;index2++) 
....................                         { 
....................                            tempString[index2] = tempString[index2 + 1]; 
....................                         } 
....................                         tempString[7] = ' '; 
....................                         index--; 
....................                      } 
....................                   } 
....................                   break; 
....................                } 
....................             } 
....................          } 
....................  
....................          if(index >= tempVariable) 
....................          { 
....................             index1 = tempVariable; 
....................          } 
....................          else 
....................          { 
....................             index1 = index; 
....................          } 
....................  
....................          while(index < 8) 
....................          { 
....................             filePtr1.name[index1++] = tempString[index++]; 
....................          } 
....................  
....................          // Store the remaining bytes with leading spaces 
....................          while(index1 < 8) 
....................          { 
....................             filePtr1.name[index1++] = ' '; 
....................          } 
....................  
....................       } 
....................       else 
....................       { 
....................          // short file name is found.Store it & quit 
....................          lfnAliasPtr = &fo->name[0]; 
....................  
....................          for(index = 0;index < FILE_NAME_SIZE_8P3;index++) 
....................          { 
....................             lfnAliasPtr[index] = filePtr1.name[index]; 
....................          } 
....................  
....................          result = TRUE; 
....................          break; 
....................       } 
....................    } 
....................  
....................    return(result); 
....................  
.................... } // Alias_LFN_Object 
.................... #endif 
....................  
.................... #ifdef USEREALTIMECLOCK 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     void CacheTime (void) 
....................   Summary: 
....................     Automatically store timestamp information from the RTCC 
....................   Conditions: 
....................     RTCC module enabled.  Should not be called by the user. 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     Modifies global timing variables 
....................   Description: 
....................     This function will automatically load information from an RTCC 
....................     module and use it to update the global timing variables.  These can 
....................     then be used to update file timestamps. 
....................   Remarks: 
....................     None. 
....................   *************************************************************************/ 
....................  
.................... void CacheTime (void) 
.................... { 
....................     WORD    year, monthday, weekhour, minsec, c, result; 
....................  
.................... #if defined (__PIC32MX__)   // Added support for PIC32. -Bud (3/4/2008) 
....................  
....................    unsigned int   t0, t1; 
....................    unsigned int   d0, d1; 
....................  
....................    do  // Get the time 
....................    { 
....................       t0=RTCTIME; 
....................       t1=RTCTIME; 
....................    }while(t0!=t1); 
....................  
....................    do  // Get the date 
....................    { 
....................       d0=RTCDATE; 
....................       d1=RTCDATE; 
....................    }while(d0!=d1); 
....................  
....................     // Put them in place. 
....................     year        = (WORD)(d0 >> 24); 
....................     monthday    = (WORD)(d0 >> 8); 
....................     weekhour    = (WORD)((d0 & 0x0F) << 8); 
....................     weekhour   |= (WORD)(t0 >> 24); 
....................     minsec      = (WORD)(t0 >> 8); 
....................  
.................... #else 
....................     BYTE    ptr1, ptr0; 
....................     if(RCFGCALbits.RTCPTR0) 
....................         ptr0 = 1; 
....................     else 
....................         ptr0 = 0; 
....................     if (RCFGCALbits.RTCPTR1) 
....................         ptr1 = 1; 
....................     else 
....................         ptr1 = 0; 
....................  
....................     RCFGCALbits.RTCPTR0 = 1; 
....................     RCFGCALbits.RTCPTR1 = 1; 
....................     year = RTCVAL; 
....................     monthday = RTCVAL; 
....................     weekhour = RTCVAL; 
....................     minsec = RTCVAL; 
....................  
....................     if (ptr0 == 1) 
....................         RCFGCALbits.RTCPTR0 = 1; 
....................  
....................     if (ptr1 == 1) 
....................         RCFGCALbits.RTCPTR1 = 1; 
....................  
.................... #endif 
....................  
....................     c = 0; 
....................     c += (year & 0x0F); 
....................     c += ((year & 0xF0) >> 4) * 10; 
....................     // c equals the last 2 digits of the year from 2000 to 2099 
....................     // Add 20 to adjust it to FAT time (from 1980 to 2107) 
....................     c += 20; 
....................     // shift the result to bits 
....................     result = c << 9; 
....................  
....................     if ((monthday & 0x1000) == 0x1000) 
....................     { 
....................         c = 10; 
....................     } 
....................     else 
....................     { 
....................         c = 0; 
....................     } 
....................     c += ((monthday & 0x0F00) >> 8); 
....................     c <<= 5; 
....................     result |= c; 
....................  
....................     c = (monthday & 0x00F0) >> 4; 
....................     c *= 10; 
....................     c += (monthday & 0x000F); 
....................  
....................     result |= c; 
....................  
....................     gTimeCrtDate = result; 
....................     gTimeWrtDate = result; 
....................     gTimeAccDate = result; 
....................  
....................     c = ((weekhour & 0x00F0) >> 4) * 10; 
....................     c += (weekhour & 0x000F); 
....................     result = c << 11; 
....................     c = ((minsec & 0xF000) >> 12) * 10; 
....................     c += (minsec & 0x0F00) >> 8; 
....................     result |= (c << 5); 
....................     c = ((minsec & 0x00F0) >> 4) * 10; 
....................     c += (minsec & 0x000F); 
....................  
....................     // If seconds mod 2 is 1, add 1000 ms 
....................     if (c % 2) 
....................         gTimeCrtMS = 100; 
....................     else 
....................         gTimeCrtMS = 0; 
....................  
....................     c >>= 1; 
....................     result |= c; 
....................  
....................     gTimeCrtTime = result; 
....................     gTimeWrtTime = result; 
.................... } 
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................  
.................... /*********************************************************************************************************** 
....................   Function: 
....................     int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second) 
....................   Summary: 
....................     Manually set timestamp variables 
....................   Conditions: 
....................     USERDEFINEDCLOCK macro defined in FSconfig.h. 
....................   Input: 
....................     year -     The year (1980\-2107) 
....................     month -   The month (1\-12) 
....................     day -     The day of the month (1\-31) 
....................     hour -    The hour (0\-23) 
....................     minute -  The minute (0\-59) 
....................     second -  The second (0\-59) 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     Modifies global timing variables 
....................   Description: 
....................     Lets the user manually set the timing variables.  The values passed in will be converted to the format 
....................     used by the FAT timestamps. 
....................   Remarks: 
....................     Call this before creating a file or directory (set create time) and 
....................     before closing a file (set last access time, last modified time) 
....................   ***********************************************************************************************************/ 
....................  
.................... int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second) 
.................... { 
....................     unsigned int result; 
....................  
....................     if ((year < 1980) || (year > 2107) || (month < 1) || (month > 12) || 
....................         (day < 1) || (day > 31) || (hour > 23) || (minute > 59) || (second > 59)) 
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
....................         return -1; 
....................     } 
....................  
....................     result = (year - 1980) << 9; 
....................     result |= (unsigned int)((unsigned int)month << 5); 
....................     result |= (day); 
....................  
....................     gTimeAccDate = result; 
....................     gTimeCrtDate = result; 
....................     gTimeWrtDate = result; 
....................  
....................     result = ((unsigned int)hour << 11); 
....................     result |= (unsigned int)((unsigned int)minute << 5); 
....................     result |= (second/2); 
....................  
....................     gTimeCrtTime = result; 
....................     gTimeWrtTime = result; 
....................  
....................     if (second % 2) 
....................         gTimeCrtMS = 100; 
....................     else 
....................         gTimeCrtMS = 0; 
....................  
....................     FSerrno = CE_GOOD; 
....................     return 0; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /*********************************************************************** 
....................   Function: 
....................     BYTE FILEallocate_new_cluster( FILEOBJ fo, BYTE mode) 
....................   Summary; 
....................     Allocate a new cluster to a file 
....................   Conditions: 
....................     Should not be called by the user. 
....................   Input: 
....................     fo -    Pointer to file structure 
....................     mode - 
....................          - 0 - Allocate a cluster to a file 
....................          - 1 - Allocate a cluster to a directory 
....................   Return Values: 
....................     CE_GOOD -      Cluster allocated 
....................     CE_DISK_FULL - No clusters available 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will find an empty cluster on the device using the 
....................     FATfindEmptyCluster function.  It will then mark it as the last 
....................     cluster in the file in the FAT chain, and link the current last 
....................     cluster of the passed file to the new cluster.  If the new 
....................     cluster is a directory cluster, it will be erased (so there are no 
....................     extraneous directory entries).  If it's allocated to a non-directory 
....................     file, it doesn't need to be erased; extraneous data in the cluster 
....................     will be unviewable because of the file size parameter. 
....................   Remarks: 
....................     None. 
....................   ***********************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE FILEallocate_new_cluster( FILEOBJ fo, BYTE mode) 
*
03E9C:  MOV     W5,[W15++]
.................... { 
....................     DISK *      dsk; 
03E9E:  CLR     1050
....................     DWORD c,curcls; 
03EA0:  CLR     1052
03EA2:  CLR     1054
03EA4:  CLR     1056
03EA6:  CLR     1058
....................  
....................     dsk = fo->dsk; 
03EA8:  MOV     104C,W4
03EAA:  ADD     W4,#0,W4
03EAC:  MOV     W4,W0
03EAE:  MOV     [W0],[W15++]
03EB0:  POP     1050
....................     c = fo->ccls; 
03EB2:  MOV     #6,W0
03EB4:  ADD     104C,W0
03EB6:  MOV     #1052,W4
03EB8:  MOV     [W0++],[W4++]
03EBA:  MOV     [W0++],[W4++]
....................  
....................     // find the next empty cluster 
....................     c = FATfindEmptyCluster(fo); 
03EBC:  PUSH    104C
03EBE:  POP     105E
03EC0:  CALL    3CAE
03EC4:  MOV     W0,1052
03EC6:  MOV     W1,1054
....................     if (c == 0)      // "0" is just an indication as Disk full in the fn "FATfindEmptyCluster()" 
03EC8:  CP0     1052
03ECA:  BRA     NZ,3ED6
03ECC:  CP0     1054
03ECE:  BRA     NZ,3ED6
....................         return CE_DISK_FULL; 
03ED0:  MOV.B   #15,W0L
03ED2:  MOV.B   W0L,0
03ED4:  BRA     3F6C
....................  
....................  
....................     // mark the cluster as taken, and last in chain 
.................... #ifdef SUPPORT_FAT12 
....................     if(dsk->type == FAT12) 
....................         WriteFAT( dsk, c, LAST_CLUSTER_FAT12, FALSE); 
....................     else 
.................... #endif 
....................     if (dsk->type == FAT16) 
03ED6:  MOV     #22,W4
03ED8:  MOV     1050,W3
03EDA:  ADD     W3,W4,W0
03EDC:  MOV     #A,W1
03EDE:  MOV     W0,W2
03EE0:  MOV.B   [W2++],[W1++]
03EE2:  CP.B    W5L,#2
03EE4:  BRA     NZ,3F02
....................         WriteFAT( dsk, c, LAST_CLUSTER_FAT16, FALSE); 
03EE6:  CLR.B   10D2
03EE8:  PUSH    1050
03EEA:  POP     10C8
03EEC:  PUSH    1052
03EEE:  POP     10CA
03EF0:  PUSH    1054
03EF2:  POP     10CC
03EF4:  MOV     #FFF8,W4
03EF6:  MOV     W4,10CE
03EF8:  CLR     10D0
03EFA:  CALL    2C18
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
03EFE:  GOTO    3F1C
....................     else 
....................         WriteFAT( dsk, c, LAST_CLUSTER_FAT32, FALSE); 
03F02:  CLR.B   10D2
03F04:  PUSH    1050
03F06:  POP     10C8
03F08:  PUSH    1052
03F0A:  POP     10CA
03F0C:  PUSH    1054
03F0E:  POP     10CC
03F10:  MOV     #FFF8,W4
03F12:  MOV     W4,10CE
03F14:  MOV     #FFF,W4
03F16:  MOV     W4,10D0
03F18:  CALL    2C18
.................... #endif 
....................  
....................     // link current cluster to the new one 
....................     curcls = fo->ccls; 
03F1C:  MOV     #6,W0
03F1E:  ADD     104C,W0
03F20:  MOV     #1056,W4
03F22:  MOV     [W0++],[W4++]
03F24:  MOV     [W0++],[W4++]
....................  
....................     WriteFAT( dsk, curcls, c, FALSE); 
03F26:  CLR.B   10D2
03F28:  PUSH    1050
03F2A:  POP     10C8
03F2C:  PUSH    1056
03F2E:  POP     10CA
03F30:  PUSH    1058
03F32:  POP     10CC
03F34:  PUSH    1052
03F36:  POP     10CE
03F38:  PUSH    1054
03F3A:  POP     10D0
03F3C:  CALL    2C18
....................  
....................     // update the FILE structure 
....................     fo->ccls = c; 
03F40:  MOV     #6,W0
03F42:  ADD     104C,W0
03F44:  MOV     W0,W5
03F46:  MOV     #1052,W4
03F48:  MOV     [W4++],[W5++]
03F4A:  MOV     [W4++],[W5++]
....................  
....................     // IF this is a dir, we need to erase the cluster 
....................     // If it's a file, we can leave it- the file size 
....................     // will limit the data we see to the data that's been 
....................     // written 
....................     if (mode == 1) 
03F4C:  MOV     104E,W4
03F4E:  CP.B    W4L,#1
03F50:  BRA     NZ,3F68
....................         return (EraseCluster(dsk, c)); 
03F52:  PUSH    1050
03F54:  POP     105E
03F56:  PUSH    1052
03F58:  POP     1060
03F5A:  PUSH    1054
03F5C:  POP     1062
03F5E:  CALL    3DDC
03F62:  BRA     3F6C
03F64:  GOTO    3F6C
....................     else 
....................         return CE_GOOD; 
03F68:  CLR.B   0
03F6A:  BRA     3F6C
03F6C:  MOV     [--W15],W5
03F6E:  RETURN  
....................  
.................... } // allocate new cluster 
.................... #endif 
....................  
.................... /*********************************************** 
....................   Function: 
....................     DWORD FATfindEmptyCluster(FILEOBJ fo) 
....................   Summary: 
....................     Find the next available cluster on the device 
....................   Conditions: 
....................     This function should not be called by the 
....................     user. 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return Values: 
....................     DWORD - Address of empty cluster 
....................     0 -     Could not find empty cluster 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will search through the FAT to 
....................     find the next available cluster on the device. 
....................   Remarks: 
....................     Should not be called by user 
....................   ***********************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... DWORD FATfindEmptyCluster(FILEOBJ fo) 
*
03CAE:  MOV     W5,[W15++]
03CB0:  MOV     W6,[W15++]
*
03CB4:  CLR     1062
03CB6:  CLR     1064
.................... { 
....................     DISK *   disk; 
*
03CB2:  CLR     1060
....................     DWORD    value = 0x0; 
....................     DWORD    c,curcls, EndClusterLimit, ClusterFailValue; 
*
03CB8:  CLR     1066
03CBA:  CLR     1068
03CBC:  CLR     106A
03CBE:  CLR     106C
03CC0:  CLR     106E
03CC2:  CLR     1070
03CC4:  CLR     1072
03CC6:  CLR     1074
....................  
....................     disk = fo->dsk; 
03CC8:  MOV     105E,W4
03CCA:  ADD     W4,#0,W4
03CCC:  MOV     W4,W0
03CCE:  MOV     [W0],[W15++]
03CD0:  POP     1060
....................     c = fo->ccls; 
03CD2:  MOV     #6,W0
03CD4:  ADD     105E,W0
03CD6:  MOV     #1066,W4
03CD8:  MOV     [W0++],[W4++]
03CDA:  MOV     [W0++],[W4++]
....................  
....................     /* Settings based on FAT type */ 
....................     switch (disk->type) 
03CDC:  MOV     #22,W4
03CDE:  MOV     1060,W3
03CE0:  ADD     W3,W4,W0
03CE2:  MOV     #A,W1
03CE4:  MOV     W0,W2
03CE6:  MOV.B   [W2++],[W1++]
03CE8:  MOV.B   W5L,W0L
03CEA:  CLR.B   1
03CEC:  XOR     #3,W0
03CEE:  BRA     Z,3CF6
03CF0:  XOR     #1,W0
03CF2:  BRA     Z,3D08
03CF4:  BRA     3D08
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             EndClusterLimit = END_CLUSTER_FAT32; 
03CF6:  MOV     #FFF7,W4
03CF8:  MOV     W4,106E
03CFA:  MOV     #FFF,W4
03CFC:  MOV     W4,1070
....................             ClusterFailValue = CLUSTER_FAIL_FAT32; 
03CFE:  SETM    1072
03D00:  MOV     #FFF,W4
03D02:  MOV     W4,1074
....................             break; 
03D04:  GOTO    3D16
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
....................             EndClusterLimit = END_CLUSTER_FAT12; 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
....................             break; 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             EndClusterLimit = END_CLUSTER_FAT16; 
03D08:  MOV     #FFF7,W4
03D0A:  MOV     W4,106E
03D0C:  CLR     1070
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
03D0E:  SETM    1072
03D10:  CLR     1074
....................             break; 
03D12:  GOTO    3D16
....................     } 
....................  
....................     // just in case 
....................     if(c < 2) 
03D16:  MOV     1068,W4
03D18:  CP      W4,#0
03D1A:  BRA     GTU,3D2A
03D1C:  BRA     NC,3D24
03D1E:  MOV     1066,W4
03D20:  CP      W4,#2
03D22:  BRA     C,3D2A
....................         c = 2; 
03D24:  MOV     #2,W4
03D26:  MOV     W4,1066
03D28:  CLR     1068
....................  
....................     curcls = c; 
03D2A:  PUSH    1066
03D2C:  POP     106A
03D2E:  PUSH    1068
03D30:  POP     106C
....................     ReadFAT(disk, c); 
03D32:  PUSH    1060
03D34:  POP     10A2
03D36:  PUSH    1066
03D38:  POP     10A4
03D3A:  PUSH    1068
03D3C:  POP     10A6
03D3E:  CALL    2ECC
....................  
....................     // sequentially scan through the FAT looking for an empty cluster 
....................     while(c) 
03D42:  CP0     1066
03D44:  BRA     NZ,3D4A
03D46:  CP0     1068
03D48:  BRA     Z,3DD2
....................     { 
....................         // look at its value 
....................         if ( (value = ReadFAT(disk, c)) == ClusterFailValue) 
03D4A:  PUSH    1060
03D4C:  POP     10A2
03D4E:  PUSH    1066
03D50:  POP     10A4
03D52:  PUSH    1068
03D54:  POP     10A6
03D56:  CALL    2ECC
03D5A:  MOV     W0,1062
03D5C:  MOV     W1,1064
03D5E:  MOV     1062,W0
03D60:  CP      1072
03D62:  BRA     NZ,3D72
03D64:  MOV     1064,W0
03D66:  CP      1074
03D68:  BRA     NZ,3D72
....................         { 
....................             c = 0; 
03D6A:  CLR     1066
03D6C:  CLR     1068
....................             break; 
03D6E:  GOTO    3DD2
....................         } 
....................  
....................         // check if empty cluster found 
....................         if (value == CLUSTER_EMPTY) 
03D72:  CP0     1062
03D74:  BRA     NZ,3D7E
03D76:  CP0     1064
03D78:  BRA     NZ,3D7E
....................             break; 
03D7A:  GOTO    3DD2
....................  
....................         c++;    // check next cluster in FAT 
03D7E:  INC     1066
03D80:  BTSC.B  42.1
03D82:  INC     1068
....................         // check if reached last cluster in FAT, re-start from top 
....................         if ((value == EndClusterLimit) || (c >= (disk->maxcls+2))) 
03D84:  MOV     1062,W0
03D86:  CP      106E
03D88:  BRA     NZ,3D90
03D8A:  MOV     1064,W0
03D8C:  CP      1070
03D8E:  BRA     Z,3DB4
03D90:  MOV     1060,W4
03D92:  ADD     W4,#14,W4
03D94:  MOV     W4,W0
03D96:  MOV     #A,W1
03D98:  MOV     W0,W2
03D9A:  REPEAT  #3
03D9C:  MOV.B   [W2++],[W1++]
03D9E:  ADD     W5,#2,W5
03DA0:  MOV     W5,W0
03DA2:  ADDC    W6,#0,W6
03DA4:  MOV     W6,W1
03DA6:  MOV     1068,W4
03DA8:  CP      W4,W1
03DAA:  BRA     NC,3DBA
03DAC:  BRA     GTU,3DB4
03DAE:  MOV     1066,W4
03DB0:  CP      W4,W0
03DB2:  BRA     NC,3DBA
....................             c = 2; 
03DB4:  MOV     #2,W4
03DB6:  MOV     W4,1066
03DB8:  CLR     1068
....................  
....................         // check if full circle done, disk full 
....................         if ( c == curcls) 
03DBA:  MOV     1066,W0
03DBC:  CP      106A
03DBE:  BRA     NZ,3DCE
03DC0:  MOV     1068,W0
03DC2:  CP      106C
03DC4:  BRA     NZ,3DCE
....................         { 
....................             c = 0; 
03DC6:  CLR     1066
03DC8:  CLR     1068
....................             break; 
03DCA:  GOTO    3DD2
....................         } 
03DCE:  GOTO    3D42
....................     }  // scanning for an empty cluster 
....................  
....................     return(c); 
03DD2:  MOV     1066,W0
03DD4:  MOV     1068,W1
03DD6:  MOV     [--W15],W6
03DD8:  MOV     [--W15],W5
03DDA:  RETURN  
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     void FSGetDiskProperties(FS_DISK_PROPERTIES* properties) 
....................   Summary: 
....................     Allows user to get the disk properties (size of disk, free space, etc) 
....................   Conditions: 
....................     1) ALLOW_GET_DISK_PROPERTIES must be defined in FSconfig.h 
....................     2) a FS_DISK_PROPERTIES object must be created before the function is called 
....................     3) the new_request member of the FS_DISK_PROPERTIES object must be set before 
....................         calling the function for the first time.  This will start a new search. 
....................     4) this function should not be called while there is a file open.  Close all 
....................         files before calling this function. 
....................   Input: 
....................     properties - a pointer to a FS_DISK_PROPERTIES object where the results should 
....................       be stored. 
....................   Return Values: 
....................     This function returns void.  The properties_status of the previous call of this 
....................       function is located in the properties.status field.  This field has the 
....................       following possible values: 
....................  
....................     FS_GET_PROPERTIES_NO_ERRORS - operation completed without error.  Results 
....................       are in the properties object passed into the function. 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED - there is no mounted disk.  Results in 
....................       properties object is not valid 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE - there was a failure trying to read a 
....................       cluster from the drive.  The results in the properties object is a partial 
....................       result up until the point of the failure. 
....................     FS_GET_PROPERTIES_STILL_WORKING - the search for free sectors is still in 
....................       process.  Continue calling this function with the same properties pointer 
....................       until either the function completes or until the partial results meets the 
....................       application needs.  The properties object contains the partial results of 
....................       the search and can be used by the application. 
....................   Side Effects: 
....................     Can cause errors if called when files are open.  Close all files before 
....................     calling this function. 
....................  
....................     Calling this function without setting the new_request member on the first 
....................     call can result in undefined behavior and results. 
....................  
....................     Calling this function after a result is returned other than 
....................     FS_GET_PROPERTIES_STILL_WORKING can result in undefined behavior and results. 
....................   Description: 
....................     This function returns the information about the mounted drive.  The results 
....................     member of the properties object passed into the function is populated with 
....................     the information about the drive. 
....................  
....................     Before starting a new request, the new_request member of the properties 
....................     input parameter should be set to TRUE.  This will initiate a new search 
....................     request. 
....................  
....................     This function will return before the search is complete with partial results. 
....................     All of the results except the free_clusters will be correct after the first 
....................     call.  The free_clusters will contain the number of free clusters found up 
....................     until that point, thus the free_clusters result will continue to grow until 
....................     the entire drive is searched.  If an application only needs to know that a 
....................     certain number of bytes is available and doesn't need to know the total free 
....................     size, then this function can be called until the required free size is 
....................     verified.  To continue a search, pass a pointer to the same FS_DISK_PROPERTIES 
....................     object that was passed in to create the search. 
....................  
....................     A new search request sould be made once this function has returned a value 
....................     other than FS_GET_PROPERTIES_STILL_WORKING.  Continuing a completed search 
....................     can result in undefined behavior or results. 
....................  
....................     Typical Usage: 
....................     <code> 
....................     FS_DISK_PROPERTIES disk_properties; 
....................  
....................     disk_properties.new_request = TRUE; 
....................  
....................     do 
....................     { 
....................         FSGetDiskProperties(&disk_properties); 
....................     } while (disk_properties.properties_status == FS_GET_PROPERTIES_STILL_WORKING); 
....................     </code> 
....................  
....................     results.disk_format - contains the format of the drive.  Valid results are 
....................       FAT12(1), FAT16(2), or FAT32(3). 
....................  
....................     results.sector_size - the sector size of the mounted drive.  Valid values are 
....................       512, 1024, 2048, and 4096. 
....................  
....................     results.sectors_per_cluster - the number sectors per cluster. 
....................  
....................     results.total_clusters - the number of total clusters on the drive.  This 
....................       can be used to calculate the total disk size (total_clusters * 
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................     results.free_clusters - the number of free (unallocated) clusters on the drive. 
....................       This can be used to calculate the total free disk size (free_clusters * 
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................   Remarks: 
....................     PIC24F size estimates: 
....................       Flash - 400 bytes (-Os setting) 
....................  
....................     PIC24F speed estimates: 
....................       Search takes approximately 7 seconds per Gigabyte of drive space.  Speed 
....................         will vary based on the number of sectors per cluster and the sector size. 
....................   *********************************************************************************/ 
.................... #if defined(ALLOW_GET_DISK_PROPERTIES) 
.................... void FSGetDiskProperties(FS_DISK_PROPERTIES* properties) 
*
08152:  MOV     W5,[W15++]
08154:  MOV     #C,W5
08156:  REPEAT  #3
08158:  MOV     [W5++],[W15++]
*
0815C:  CLR     FF2
0815E:  CLR     FF4
.................... { 
....................     BYTE    i; 
*
0815A:  CLR.B   FF0
....................     DWORD   value = 0x0; 
....................  
....................     if(properties->new_request == TRUE) 
*
08160:  MOV     #2,W0
08162:  ADD     FEE,W0
08164:  MOV     W0,W4
08166:  CLR     W0
08168:  MOV.B   [W4],W3L
0816A:  BTSC    W3.0
0816C:  INC     W0,W0
0816E:  CP.B    W0L,#1
08170:  BRA     NZ,8302
....................     { 
....................         properties->disk = &gDiskData; 
08172:  MOV     FEE,W4
08174:  ADD     W4,#0,W4
08176:  MOV     W4,W0
08178:  MOV     W0,W5
0817A:  MOV.B   #60,W0L
0817C:  MOV.B   W0L,[W5]
0817E:  MOV.B   #D,W0L
08180:  MOV.B   W0L,[W5+#1]
....................         properties->results.free_clusters = 0; 
08182:  MOV     #E,W0
08184:  ADD     FEE,W0
08186:  MOV     W0,W5
08188:  CLR.B   [W5]
0818A:  MOV.B   #0,W0L
0818C:  MOV.B   W0L,[W5+#1]
0818E:  MOV.B   #0,W0L
08190:  MOV.B   W0L,[W5+#2]
08192:  MOV.B   #0,W0L
08194:  MOV.B   W0L,[W5+#3]
....................         properties->new_request = FALSE; 
08196:  MOV     #2,W0
08198:  ADD     FEE,W0
0819A:  MOV     W0,W5
0819C:  MOV     #FE,W4
0819E:  AND.B   W4L,[W5],[W5]
....................  
....................         if(properties->disk->mount != TRUE) 
081A0:  MOV     #0,W0
081A2:  ADD     FEE,W0
081A4:  MOV     W0,W5
081A6:  MOV     W5,W0
081A8:  MOV     [W0],W6
081AA:  MOV     #23,W4
081AC:  ADD     W6,W4,W0
081AE:  MOV     #E,W1
081B0:  MOV     W0,W2
081B2:  MOV.B   [W2++],[W1++]
081B4:  CP.B    W7L,#1
081B6:  BRA     Z,81C4
....................         { 
....................             properties->properties_status = FS_GET_PROPERTIES_DISK_NOT_MOUNTED; 
081B8:  MOV     #3,W0
081BA:  ADD     FEE,W0
081BC:  MOV     W0,W5
081BE:  MOV.B   #1,W0L
081C0:  MOV.B   W0L,[W5]
....................             return; 
081C2:  BRA     8418
....................         } 
....................  
....................         properties->properties_status = FS_GET_PROPERTIES_STILL_WORKING; 
081C4:  MOV     #3,W0
081C6:  ADD     FEE,W0
081C8:  MOV     W0,W5
081CA:  SETM.B  [W5]
....................  
....................         properties->results.disk_format = properties->disk->type; 
081CC:  MOV     #4,W0
081CE:  ADD     FEE,W0
081D0:  MOV     W0,W5
081D2:  MOV     #0,W0
081D4:  ADD     FEE,W0
081D6:  MOV     W0,W6
081D8:  MOV     W6,W0
081DA:  MOV     [W0],W7
081DC:  MOV     #22,W4
081DE:  ADD     W7,W4,W0
081E0:  MOV     #10,W1
081E2:  MOV     W0,W2
081E4:  MOV.B   [W2++],[W1++]
081E6:  MOV.B   W8L,[W5]
....................         properties->results.sector_size = properties->disk->sectorSize; 
081E8:  MOV     #6,W0
081EA:  ADD     FEE,W0
081EC:  MOV     W0,W5
081EE:  MOV     #0,W0
081F0:  ADD     FEE,W0
081F2:  MOV     W0,W6
081F4:  MOV     W6,W0
081F6:  MOV     [W0],W7
081F8:  ADD     W7,#18,W7
081FA:  MOV     W7,W0
081FC:  MOV     #10,W1
081FE:  MOV     W0,W2
08200:  REPEAT  #3
08202:  MOV.B   [W2++],[W1++]
08204:  MOV     W8,[W5]
....................         properties->results.sectors_per_cluster = properties->disk->SecPerClus; 
08206:  MOV     #8,W0
08208:  ADD     FEE,W0
0820A:  MOV     W0,W5
0820C:  MOV     #0,W0
0820E:  ADD     FEE,W0
08210:  MOV     W0,W6
08212:  MOV     W6,W0
08214:  MOV     [W0],W7
08216:  MOV     #21,W4
08218:  ADD     W7,W4,W0
0821A:  MOV     #10,W1
0821C:  MOV     W0,W2
0821E:  MOV.B   [W2++],[W1++]
08220:  MOV.B   W8L,[W5]
....................         properties->results.total_clusters = properties->disk->maxcls; 
08222:  MOV     #A,W0
08224:  ADD     FEE,W0
08226:  MOV     W0,W5
08228:  MOV     #0,W0
0822A:  ADD     FEE,W0
0822C:  MOV     W0,W6
0822E:  MOV     W6,W0
08230:  MOV     [W0],W7
08232:  ADD     W7,#14,W7
08234:  MOV     W7,W0
08236:  MOV     #10,W1
08238:  MOV     W0,W2
0823A:  REPEAT  #3
0823C:  MOV.B   [W2++],[W1++]
0823E:  MOV     #10,W4
08240:  MOV     [W4++],[W5++]
08242:  MOV     [W4++],[W5++]
....................  
....................         /* Settings based on FAT type */ 
....................         switch (properties->disk->type) 
08244:  MOV     #0,W0
08246:  ADD     FEE,W0
08248:  MOV     W0,W5
0824A:  MOV     W5,W0
0824C:  MOV     [W0],W6
0824E:  MOV     #22,W4
08250:  ADD     W6,W4,W0
08252:  MOV     #E,W1
08254:  MOV     W0,W2
08256:  MOV.B   [W2++],[W1++]
08258:  MOV.B   W7L,W0L
0825A:  CLR.B   1
0825C:  XOR     #3,W0
0825E:  BRA     Z,8266
08260:  XOR     #1,W0
08262:  BRA     Z,8294
08264:  BRA     82C2
....................         { 
....................     #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................             case FAT32: 
....................                 properties->private.EndClusterLimit = END_CLUSTER_FAT32; 
08266:  MOV     #1A,W0
08268:  ADD     FEE,W0
0826A:  MOV     W0,W5
0826C:  MOV.B   #F7,W0L
0826E:  MOV.B   W0L,[W5]
08270:  MOV.B   #FF,W0L
08272:  MOV.B   W0L,[W5+#1]
08274:  MOV.B   #FF,W0L
08276:  MOV.B   W0L,[W5+#2]
08278:  MOV.B   #F,W0L
0827A:  MOV.B   W0L,[W5+#3]
....................                 properties->private.ClusterFailValue = CLUSTER_FAIL_FAT32; 
0827C:  MOV     #1E,W0
0827E:  ADD     FEE,W0
08280:  MOV     W0,W5
08282:  SETM.B  [W5]
08284:  MOV.B   #FF,W0L
08286:  MOV.B   W0L,[W5+#1]
08288:  MOV.B   #FF,W0L
0828A:  MOV.B   W0L,[W5+#2]
0828C:  MOV.B   #F,W0L
0828E:  MOV.B   W0L,[W5+#3]
....................                 break; 
08290:  GOTO    82C2
....................     #endif 
....................             case FAT16: 
....................                 properties->private.EndClusterLimit = END_CLUSTER_FAT16; 
08294:  MOV     #1A,W0
08296:  ADD     FEE,W0
08298:  MOV     W0,W5
0829A:  MOV.B   #F7,W0L
0829C:  MOV.B   W0L,[W5]
0829E:  MOV.B   #FF,W0L
082A0:  MOV.B   W0L,[W5+#1]
082A2:  MOV.B   #0,W0L
082A4:  MOV.B   W0L,[W5+#2]
082A6:  MOV.B   #0,W0L
082A8:  MOV.B   W0L,[W5+#3]
....................                 properties->private.ClusterFailValue = CLUSTER_FAIL_FAT16; 
082AA:  MOV     #1E,W0
082AC:  ADD     FEE,W0
082AE:  MOV     W0,W5
082B0:  SETM.B  [W5]
082B2:  MOV.B   #FF,W0L
082B4:  MOV.B   W0L,[W5+#1]
082B6:  MOV.B   #0,W0L
082B8:  MOV.B   W0L,[W5+#2]
082BA:  MOV.B   #0,W0L
082BC:  MOV.B   W0L,[W5+#3]
....................                 break; 
082BE:  GOTO    82C2
.................... #ifdef SUPPORT_FAT12 
....................             case FAT12: 
....................                 properties->private.EndClusterLimit = END_CLUSTER_FAT12; 
....................                 properties->private.ClusterFailValue = CLUSTER_FAIL_FAT16; 
....................                 break; 
.................... #endif 
....................         } 
....................  
....................         properties->private.c = 2; 
082C2:  MOV     #12,W0
082C4:  ADD     FEE,W0
082C6:  MOV     W0,W5
082C8:  MOV.B   #2,W0L
082CA:  MOV.B   W0L,[W5]
082CC:  MOV.B   #0,W0L
082CE:  MOV.B   W0L,[W5+#1]
082D0:  MOV.B   #0,W0L
082D2:  MOV.B   W0L,[W5+#2]
082D4:  MOV.B   #0,W0L
082D6:  MOV.B   W0L,[W5+#3]
....................  
....................         properties->private.curcls = properties->private.c; 
082D8:  MOV     #16,W0
082DA:  ADD     FEE,W0
082DC:  MOV     W0,W5
082DE:  MOV     #12,W0
082E0:  ADD     FEE,W0
082E2:  MOV     [W0++],[W5++]
082E4:  MOV     [W0++],[W5++]
....................         ReadFAT(properties->disk, properties->private.c); 
082E6:  MOV     FEE,W4
082E8:  ADD     W4,#0,W4
082EA:  MOV     W4,W0
082EC:  MOV     [W0],W5
082EE:  MOV     #12,W0
082F0:  ADD     FEE,W0
082F2:  MOV     #C,W4
082F4:  MOV     [W0++],[W4++]
082F6:  MOV     [W0++],[W4++]
082F8:  MOV     W5,10A2
082FA:  MOV     W6,10A4
082FC:  MOV     W7,10A6
082FE:  CALL    2ECC
....................     } 
....................  
....................     if(properties->disk == NULL) 
08302:  MOV     FEE,W4
08304:  ADD     W4,#0,W4
08306:  MOV     W4,W0
08308:  MOV     [W0],W5
0830A:  CP0     W5
0830C:  BRA     NZ,831A
....................     { 
....................         properties->properties_status = FS_GET_PROPERTIES_DISK_NOT_MOUNTED; 
0830E:  MOV     #3,W0
08310:  ADD     FEE,W0
08312:  MOV     W0,W5
08314:  MOV.B   #1,W0L
08316:  MOV.B   W0L,[W5]
....................         return; 
08318:  BRA     8418
....................     } 
....................  
....................     if(properties->properties_status != FS_GET_PROPERTIES_STILL_WORKING) 
0831A:  MOV     #3,W0
0831C:  ADD     FEE,W0
0831E:  MOV.B   [W0],W4L
08320:  XOR.B   #FF,W4L
08322:  BRA     Z,8326
....................     { 
....................         return; 
08324:  BRA     8418
....................     } 
....................  
....................     // sequentially scan through the FAT looking for an empty cluster 
....................     for(i=0;i<255;i++) 
08326:  CLR.B   FF0
08328:  MOV     FF0,W4
0832A:  XOR.B   #FF,W4L
0832C:  BRA     Z,8410
....................     { 
....................         // look at its value 
....................         if ( (value = ReadFAT(properties->disk, properties->private.c)) == properties->private.ClusterFailValue) 
0832E:  MOV     FEE,W4
08330:  ADD     W4,#0,W4
08332:  MOV     W4,W0
08334:  MOV     [W0],W5
08336:  MOV     #12,W0
08338:  ADD     FEE,W0
0833A:  MOV     #C,W4
0833C:  MOV     [W0++],[W4++]
0833E:  MOV     [W0++],[W4++]
08340:  MOV     W5,10A2
08342:  MOV     W6,10A4
08344:  MOV     W7,10A6
08346:  CALL    2ECC
0834A:  MOV     W0,FF2
0834C:  MOV     W1,FF4
0834E:  MOV     #1E,W0
08350:  ADD     FEE,W0
08352:  MOV     W0,W4
08354:  MOV     #0,W3
08356:  MOV     [W4++],[W3++]
08358:  MOV     [W4++],[W3++]
0835A:  CP      FF2
0835C:  BRA     NZ,8370
0835E:  MOV     FF4,W4
08360:  CP      W4,W1
08362:  BRA     NZ,8370
....................         { 
....................             properties->properties_status = FS_GET_PROPERTIES_CLUSTER_FAILURE; 
08364:  MOV     #3,W0
08366:  ADD     FEE,W0
08368:  MOV     W0,W5
0836A:  MOV.B   #2,W0L
0836C:  MOV.B   W0L,[W5]
....................             return; 
0836E:  BRA     8418
....................         } 
....................  
....................         // check if empty cluster found 
....................         if (value == CLUSTER_EMPTY) 
08370:  CP0     FF2
08372:  BRA     NZ,8384
08374:  CP0     FF4
08376:  BRA     NZ,8384
....................         { 
....................             properties->results.free_clusters++; 
08378:  MOV     #E,W0
0837A:  ADD     FEE,W0
0837C:  MOV     W0,W5
0837E:  INC     [W5],[W5++]
08380:  BTSC.B  42.1
08382:  INC     [W5],[W5++]
....................         } 
....................  
....................         properties->private.c++;    // check next cluster in FAT 
08384:  MOV     #12,W0
08386:  ADD     FEE,W0
08388:  MOV     W0,W5
0838A:  INC     [W5],[W5++]
0838C:  BTSC.B  42.1
0838E:  INC     [W5],[W5++]
....................         // check if reached last cluster in FAT, re-start from top 
....................         if ((value == properties->private.EndClusterLimit) || (properties->private.c >= (properties->results.total_clusters + 2))) 
08390:  MOV     #1A,W0
08392:  ADD     FEE,W0
08394:  MOV     W0,W4
08396:  MOV     #0,W3
08398:  MOV     [W4++],[W3++]
0839A:  MOV     [W4++],[W3++]
0839C:  CP      FF2
0839E:  BRA     NZ,83A6
083A0:  MOV     FF4,W4
083A2:  CP      W4,W1
083A4:  BRA     Z,83CC
083A6:  MOV     #12,W0
083A8:  ADD     FEE,W0
083AA:  MOV     #A,W4
083AC:  MOV     [W0++],[W4++]
083AE:  MOV     [W0++],[W4++]
083B0:  MOV     #A,W0
083B2:  ADD     FEE,W0
083B4:  MOV     #E,W4
083B6:  MOV     [W0++],[W4++]
083B8:  MOV     [W0++],[W4++]
083BA:  ADD     W7,#2,W7
083BC:  MOV     W7,W0
083BE:  ADDC    W8,#0,W8
083C0:  MOV     W8,W1
083C2:  CP      W1,W6
083C4:  BRA     GTU,83E2
083C6:  BRA     NC,83CC
083C8:  CP      W0,W5
083CA:  BRA     GTU,83E2
....................             properties->private.c = 2; 
083CC:  MOV     #12,W0
083CE:  ADD     FEE,W0
083D0:  MOV     W0,W5
083D2:  MOV.B   #2,W0L
083D4:  MOV.B   W0L,[W5]
083D6:  MOV.B   #0,W0L
083D8:  MOV.B   W0L,[W5+#1]
083DA:  MOV.B   #0,W0L
083DC:  MOV.B   W0L,[W5+#2]
083DE:  MOV.B   #0,W0L
083E0:  MOV.B   W0L,[W5+#3]
....................  
....................         // check if full circle done, disk full 
....................         if ( properties->private.c == properties->private.curcls) 
083E2:  MOV     #12,W0
083E4:  ADD     FEE,W0
083E6:  MOV     #A,W4
083E8:  MOV     [W0++],[W4++]
083EA:  MOV     [W0++],[W4++]
083EC:  MOV     #16,W0
083EE:  ADD     FEE,W0
083F0:  MOV     W0,W4
083F2:  MOV     #0,W3
083F4:  MOV     [W4++],[W3++]
083F6:  MOV     [W4++],[W3++]
083F8:  CP      W5,W0
083FA:  BRA     NZ,840A
083FC:  CP      W6,W1
083FE:  BRA     NZ,840A
....................         { 
....................             properties->properties_status = FS_GET_PROPERTIES_NO_ERRORS; 
08400:  MOV     #3,W0
08402:  ADD     FEE,W0
08404:  MOV     W0,W5
08406:  CLR.B   [W5]
....................             return; 
08408:  BRA     8418
....................         } 
0840A:  INC.B   0FF0
0840C:  GOTO    8328
....................     }  // scanning for an empty cluster 
....................  
....................     properties->properties_status = FS_GET_PROPERTIES_STILL_WORKING; 
08410:  MOV     #3,W0
08412:  ADD     FEE,W0
08414:  MOV     W0,W5
08416:  SETM.B  [W5]
....................     return; 
08418:  MOV     #12,W5
0841A:  REPEAT  #3
0841C:  MOV     [--W15],[W5--]
0841E:  MOV     [--W15],W5
08420:  RETURN  
.................... } 
.................... #endif 
....................  
.................... /************************************************************ 
....................   Function: 
....................     int FSfclose(FSFILE *fo) 
....................   Summary: 
....................     Update file information and free FSFILE objects 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to the file to close 
....................   Return Values: 
....................     0 -   File closed successfully 
....................     EOF - Error closing the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will update the directory entry for the 
....................     file pointed to by 'fo' with the information contained 
....................     in 'fo,' including the new file size and attributes. 
....................     Timestamp information will also be loaded based on the 
....................     method selected by the user and written to the entry 
....................     as the last modified time and date.  The file entry will 
....................     then be written to the device.  Finally, the memory 
....................     used for the specified file object will be freed from 
....................     the dynamic heap or the array of FSFILE objects. 
....................   Remarks: 
....................     A function to flush data to the device without closing the 
....................     file can be created by removing the portion of this 
....................     function that frees the memory and the line that clears 
....................     the write flag. 
....................   ************************************************************/ 
....................  
.................... int FSfclose(FSFILE   *fo) 
*
05142:  MOV     W5,[W15++]
05144:  MOV     W6,[W15++]
05146:  MOV     W7,[W15++]
*
0514C:  MOV     #48,W4
0514E:  MOV     W4,1022
.................... { 
....................     WORD        fHandle; 
*
05148:  CLR     101E
.................... #ifndef FS_DYNAMIC_MEM 
....................     WORD        fIndex; 
0514A:  CLR     1020
.................... #endif 
....................     int        error = 72; 
.................... #ifdef ALLOW_WRITES 
....................     DIRENTRY    dir; 
*
05150:  CLR     1024
.................... #endif 
....................  
....................     FSerrno = CE_GOOD; 
05152:  CLR.B   8B1
....................     fHandle = fo->entry; 
05154:  MOV     #28,W0
05156:  ADD     101C,W0
05158:  MOV     [W0],[W15++]
0515A:  POP     101E
....................  
.................... #ifdef ALLOW_WRITES 
....................     if(fo->flags.write) 
0515C:  MOV     #16,W0
0515E:  ADD     101C,W0
05160:  MOV.B   [W0],W4L
05162:  BTSS    W4.0
05164:  BRA     5238
....................     { 
....................         if (gNeedDataWrite) 
05166:  CP0.B   8AE
05168:  BRA     Z,517A
....................         { 
....................             if (flushData()) 
0516A:  CALL    3170
0516E:  CP0.B   W0L
05170:  BRA     Z,517A
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
05172:  MOV.B   #9,W0L
05174:  MOV.B   W0L,8B1
....................                 return EOF; 
05176:  SETM    0
05178:  BRA     526C
....................             } 
....................         } 
....................  
....................         // Write the current FAT sector to the disk 
....................         WriteFAT (fo->dsk, 0, 0, TRUE); 
0517A:  MOV     101C,W4
0517C:  ADD     W4,#0,W4
0517E:  MOV     W4,W0
05180:  MOV     [W0],W5
05182:  MOV     W0,[W15++]
05184:  MOV.B   #1,W0L
05186:  MOV.B   W0L,10D2
05188:  MOV     [--W15],W0
0518A:  MOV     W5,10C8
0518C:  CLR     10CA
0518E:  CLR     10CC
05190:  CLR     10CE
05192:  CLR     10D0
05194:  CALL    2C18
....................  
....................         // Invalidate the currently cached FAT entry so that the next read will 
....................         //   result in an acutal read from the physical media instead of a read 
....................         //   from the RAM cache. 
....................         gLastFATSectorRead = 0; 
05198:  CLR     8A4
0519A:  CLR     8A6
....................  
....................         // Read the FAT entry from the physical media.  This is required because 
....................         //   some physical media cache the entries in RAM and only write them 
....................         //   after a time expires for until the sector is accessed again. 
....................         ReadFAT (fo->dsk, fo->ccls); 
0519C:  MOV     101C,W4
0519E:  ADD     W4,#0,W4
051A0:  MOV     W4,W0
051A2:  MOV     [W0],W5
051A4:  MOV     #6,W0
051A6:  ADD     101C,W0
051A8:  MOV     #C,W4
051AA:  MOV     [W0++],[W4++]
051AC:  MOV     [W0++],[W4++]
051AE:  MOV     W5,10A2
051B0:  MOV     W6,10A4
051B2:  MOV     W7,10A6
051B4:  CALL    2ECC
....................  
....................         // Get the file entry 
....................         dir = LoadDirAttrib(fo, &fHandle); 
051B8:  PUSH    101C
051BA:  POP     104A
051BC:  MOV     #101E,W4
051BE:  MOV     W4,104C
051C0:  CALL    42F0
051C4:  MOV     W0,1024
....................  
....................         if (dir == NULL) 
051C6:  CP0     1024
051C8:  BRA     NZ,51D6
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
051CA:  MOV.B   #1B,W0L
051CC:  MOV.B   W0L,8B1
....................             error = EOF; 
051CE:  SETM    1022
....................             return error; 
051D0:  PUSH    1022
051D2:  POP     0
051D4:  BRA     526C
....................         } 
....................  
....................       // update the time 
.................... #ifdef INCREMENTTIMESTAMP 
....................         IncrementTimeStamp(dir); 
.................... #elif defined USERDEFINEDCLOCK 
....................         dir->DIR_WrtTime = gTimeWrtTime; 
051D6:  MOV     #16,W0
051D8:  ADD     1024,W0
051DA:  MOV     W0,W5
051DC:  MOV     8A0,W4
051DE:  MOV     W4,[W5+#0]
....................         dir->DIR_WrtDate = gTimeWrtDate; 
051E0:  MOV     #18,W0
051E2:  ADD     1024,W0
051E4:  MOV     W0,W5
051E6:  MOV     8A2,W4
051E8:  MOV     W4,[W5+#0]
.................... #elif defined USEREALTIMECLOCK 
....................         CacheTime(); 
....................         dir->DIR_WrtTime = gTimeWrtTime; 
....................         dir->DIR_WrtDate = gTimeWrtDate; 
.................... #endif 
....................  
....................         dir->DIR_FileSize = fo->size; 
051EA:  MOV     #1C,W0
051EC:  ADD     1024,W0
051EE:  MOV     W0,W5
051F0:  MOV     #12,W0
051F2:  ADD     101C,W0
051F4:  MOV     [W0++],[W5++]
051F6:  MOV     [W0++],[W5++]
....................  
....................         dir->DIR_Attr = fo->attributes; 
051F8:  MOV     #B,W0
051FA:  ADD     1024,W0
051FC:  MOV     W0,W5
051FE:  MOV     #2C,W0
05200:  ADD     101C,W0
05202:  MOV.B   [W0],[W5]
....................  
....................         // just write the last entry in 
....................         if(Write_File_Entry(fo,&fHandle)) 
05204:  PUSH    101C
05206:  POP     1060
05208:  MOV     #101E,W4
0520A:  MOV     W4,1062
0520C:  CALL    3964
05210:  CP0.B   W0L
05212:  BRA     Z,5228
....................         { 
....................             // Read the folder entry from the physical media.  This is required because 
....................             //   some physical media cache the entries in RAM and only write them 
....................             //   after a time expires for until the sector is accessed again. 
....................             dir = LoadDirAttrib(fo, &fHandle); 
05214:  PUSH    101C
05216:  POP     104A
05218:  MOV     #101E,W4
0521A:  MOV     W4,104C
0521C:  CALL    42F0
05220:  MOV     W0,1024
....................             error = 0; 
05222:  CLR     1022
....................         } 
05224:  GOTO    522E
....................         else 
....................         { 
....................             FSerrno = CE_WRITE_ERROR; 
05228:  MOV.B   #9,W0L
0522A:  MOV.B   W0L,8B1
....................             error = EOF; 
0522C:  SETM    1022
....................         } 
....................  
....................         // it's now closed 
....................         fo->flags.write = FALSE; 
0522E:  MOV     #16,W0
05230:  ADD     101C,W0
05232:  MOV     W0,W5
05234:  MOV     #FE,W4
05236:  AND.B   W4L,[W5],[W5]
....................     } 
.................... #endif 
....................  
.................... #ifdef FS_DYNAMIC_MEM 
....................     #ifdef   SUPPORT_LFN 
....................       FS_free((unsigned char *)fo->utf16LFNptr); 
....................    #endif 
....................    FS_free((unsigned char *)fo); 
.................... #else 
....................  
....................     for( fIndex = 0; fIndex < FS_MAX_FILES_OPEN; fIndex++ ) 
05238:  CLR     1020
0523A:  CP0     1020
0523C:  BRA     NZ,5260
....................     { 
....................         if( fo == &gFileArray[fIndex] ) 
0523E:  MOV     1020,W4
05240:  MOV     #36,W3
05242:  MUL.UU  W4,W3,W0
05244:  MOV     #862,W4
05246:  ADD     W0,W4,W0
05248:  CP      101C
0524A:  BRA     NZ,525A
....................         { 
....................             gFileSlotOpen[fIndex] = TRUE; 
0524C:  MOV     #85B,W4
0524E:  MOV     1020,W3
05250:  ADD     W3,W4,W5
05252:  MOV.B   #1,W0L
05254:  MOV.B   W0L,[W5]
....................             break; 
05256:  GOTO    5260
....................         } 
0525A:  INC     1020
0525C:  GOTO    523A
....................     } 
.................... #endif 
....................  
....................     // File opened in read mode 
....................     if (error == 72) 
05260:  MOV     1022,W4
05262:  XOR     #48,W4
05264:  BRA     NZ,5268
....................         error = 0; 
05266:  CLR     1022
....................  
....................     return(error); 
05268:  PUSH    1022
0526A:  POP     0
0526C:  MOV     [--W15],W7
0526E:  MOV     [--W15],W6
05270:  MOV     [--W15],W5
05272:  RETURN  
.................... } // FSfclose 
....................  
....................  
.................... /******************************************************* 
....................   Function: 
....................     void IncrementTimeStamp(DIRENTRY dir) 
....................   Summary: 
....................     Automatically set the timestamp to "don't care" data 
....................   Conditions: 
....................     Should not be called by the user. 
....................   Input: 
....................     dir -  Pointer to directory structure 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will increment the timestamp variable in 
....................     the 'dir' directory entry.  This is used for the 
....................     don't-care timing method. 
....................   Remarks: 
....................     None 
....................   *******************************************************/ 
.................... #ifdef INCREMENTTIMESTAMP 
.................... void IncrementTimeStamp(DIRENTRY dir) 
.................... { 
....................     BYTE          seconds; 
....................     BYTE          minutes; 
....................     BYTE          hours; 
....................  
....................     BYTE          day; 
....................     BYTE          month; 
....................     BYTE          year; 
....................  
....................     seconds = (dir->DIR_WrtTime & 0x1f); 
....................     minutes = ((dir->DIR_WrtTime & 0x07E0) >> 5); 
....................     hours   = ((dir->DIR_WrtTime & 0xF800) >> 11); 
....................  
....................     day     = (dir->DIR_WrtDate & 0x1f); 
....................     month   = ((dir->DIR_WrtDate & 0x01E0) >> 5); 
....................     year    = ((dir->DIR_WrtDate & 0xFE00) >> 9); 
....................  
....................     if(seconds < 29) 
....................     { 
....................         // Increment number of seconds by 2 
....................         // This clock method isn't intended to be accurate anyway 
....................         seconds++; 
....................     } 
....................     else 
....................     { 
....................         seconds = 0x00; 
....................  
....................         if(minutes < 59) 
....................         { 
....................             minutes++; 
....................         } 
....................         else 
....................         { 
....................             minutes = 0; 
....................  
....................             if(hours < 23) 
....................             { 
....................                 hours++; 
....................             } 
....................             else 
....................             { 
....................                 hours = 0; 
....................                 if(day < 30) 
....................                 { 
....................                     day++; 
....................                 } 
....................                 else 
....................                 { 
....................                     day = 1; 
....................  
....................                     if(month < 12) 
....................                     { 
....................                         month++; 
....................                     } 
....................                     else 
....................                     { 
....................                         month = 1; 
....................                         // new year 
....................                         year++; 
....................                         // This is only valid until 2107 
....................                     } 
....................                 } 
....................             } 
....................         } 
....................     } 
....................  
....................     dir->DIR_WrtTime = (WORD)(seconds); 
....................     dir->DIR_WrtTime |= ((WORD)(minutes) << 5); 
....................     dir->DIR_WrtTime |= ((WORD)(hours) << 11); 
....................  
....................     dir->DIR_WrtDate = (WORD)(day); 
....................     dir->DIR_WrtDate |= ((WORD)(month) << 5); 
....................     dir->DIR_WrtDate |= ((WORD)(year) << 9); 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************** 
....................   Function: 
....................     BYTE Fill_File_Object(FILEOBJ fo, WORD *fHandle) 
....................   Summary: 
....................     Fill a file object with specified dir entry data 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................     fHandle -  Passed member's location 
....................   Return Values: 
....................     FOUND -     Operation successful 
....................     NOT_FOUND - Operation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache the sector of directory entries 
....................     in the directory pointed to by the dirclus value in 
....................     the FSFILE object 'fo' that contains the entry that 
....................     corresponds to the fHandle offset.  It will then copy 
....................     the file information for that entry into the 'fo' FSFILE 
....................     object. 
....................   Remarks: 
....................     None. 
....................   *****************************************************************/ 
....................  
.................... BYTE Fill_File_Object(FILEOBJ fo, WORD *fHandle) 
*
034D8:  MOV     W5,[W15++]
*
034E4:  CLR.B   107C
.................... { 
....................     DIRENTRY    dir; 
*
034DA:  CLR     1076
....................     BYTE        index, a; 
034DC:  CLR.B   1078
034DE:  CLR.B   1079
....................     BYTE        character; 
034E0:  CLR.B   107A
....................     BYTE        status; 
034E2:  CLR.B   107B
....................     BYTE        test = 0; 
....................  
.................... #ifdef __DEBUG_UART   
.................... PrintROMASCIIStringUART("Fill_File_Object"); 
.................... #endif 
....................  
....................  
....................     // Get the entry 
....................     if (((*fHandle & MASK_MAX_FILE_ENTRY_LIMIT_BITS) == 0) && (*fHandle != 0)) // 4-bit mask because 16-root entries max per sector 
*
034E6:  MOV     1074,W0
034E8:  MOV     [W0],W5
034EA:  AND     W5,#F,W5
034EC:  CP0     W5
034EE:  BRA     NZ,351C
034F0:  MOV     1074,W0
034F2:  MOV     [W0],W5
034F4:  CP0     W5
034F6:  BRA     Z,351C
....................     { 
....................         fo->dirccls = fo->dirclus; 
034F8:  MOV     #32,W0
034FA:  ADD     1072,W0
034FC:  MOV     W0,W5
034FE:  MOV     #2E,W0
03500:  ADD     1072,W0
03502:  MOV     [W0++],[W5++]
03504:  MOV     [W0++],[W5++]
....................          
....................          #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" Cache_File_Entry FORCE dirccls="); 
....................          PrintRAMBytesUART(((unsigned char*)&fo->dirccls), 4); 
....................          #endif     
....................      
....................         dir = Cache_File_Entry(fo, fHandle, TRUE); 
03506:  MOV.B   #1,W0L
03508:  MOV.B   W0L,1086
0350A:  PUSH    1072
0350C:  POP     1082
0350E:  PUSH    1074
03510:  POP     1084
03512:  CALL    31E4
03516:  MOV     W0,1076
....................     } 
03518:  GOTO    352C
....................     else 
....................     { 
....................          #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" Cache_File_Entry dirccls="); 
....................          PrintRAMBytesUART(((unsigned char*)&fo->dirccls), 4); 
....................          PrintROMASCIIStringUART(" dirclus="); 
....................          PrintRAMBytesUART(((unsigned char*)&fo->dirclus), 4);                   
....................          #endif     
....................           
....................         dir = Cache_File_Entry (fo, fHandle, FALSE); 
0351C:  CLR.B   1086
0351E:  PUSH    1072
03520:  POP     1082
03522:  PUSH    1074
03524:  POP     1084
03526:  CALL    31E4
0352A:  MOV     W0,1076
....................     } 
....................  
....................    #ifdef __DEBUG_UART 
....................    PrintROMASCIIStringUART(" dir="); 
....................    PrintRAMBytesUART(((unsigned char*)&dir), sizeof(dir));          
....................    #endif 
....................  
....................  
....................     // Make sure there is a directory left 
....................     if(dir == (DIRENTRY)NULL) 
0352C:  CP0     1076
0352E:  BRA     NZ,3538
....................     { 
....................         status = NO_MORE; 
03530:  MOV.B   #2,W0L
03532:  MOV.B   W0L,107B
....................     } 
03534:  GOTO    36B8
....................     else 
....................     { 
....................         // Read the first char of the file name 
....................         a = dir->DIR_Name[0]; 
03538:  MOV     #0,W0
0353A:  ADD     1076,W0
0353C:  MOV     W0,[W15++]
0353E:  MOV.B   [W0],W0L
03540:  MOV.B   W0L,1079
03542:  MOV     [--W15],W0
....................  
....................    #ifdef __DEBUG_UART 
....................    PrintROMASCIIStringUART(" a="); 
....................    PrintRAMBytesUART(((unsigned char*)&a), sizeof(a));          
....................    #endif 
....................  
....................         // Check for empty or deleted directory 
....................         if ( a == DIR_DEL) 
03544:  MOV     1078,W4
03546:  LSR     W4,#8,W4
03548:  XOR.B   #E5,W4L
0354A:  BRA     NZ,3554
....................       { 
....................             status = NOT_FOUND; 
0354C:  MOV.B   #1,W0L
0354E:  MOV.B   W0L,107B
....................       } 
03550:  GOTO    36B8
....................       else if ( a == DIR_EMPTY) 
03554:  CP0.B   1079
03556:  BRA     NZ,3560
....................       { 
....................          status = NO_MORE; 
03558:  MOV.B   #2,W0L
0355A:  MOV.B   W0L,107B
....................       } 
0355C:  GOTO    36B8
....................         else 
....................         { 
....................             // Get the attributes 
....................             a = dir->DIR_Attr; 
03560:  MOV     #B,W0
03562:  ADD     1076,W0
03564:  MOV     W0,[W15++]
03566:  MOV.B   [W0],W0L
03568:  MOV.B   W0L,1079
0356A:  MOV     [--W15],W0
....................  
....................             // print the file name and extension 
....................             for (index=0; index < DIR_NAMESIZE; index++) 
0356C:  CLR.B   1078
0356E:  MOV     1078,W4
03570:  CP.B    W4L,#8
03572:  BRA     C,35B4
....................             { 
....................                 character = dir->DIR_Name[index]; 
03574:  MOV     1078,W4
03576:  CLR.B   9
03578:  MOV     W4,W0
0357A:  ADD     1076,W0
0357C:  MOV     107A,W4
0357E:  MOV.B   [W0+#0],W4L
03580:  MOV     W4,107A
....................                 character = (BYTE)toupper(character); 
03582:  MOV     107A,W4
03584:  MOV     #61,W3
03586:  CP.B    W3L,W4L
03588:  BRA     GTU,3598
0358A:  MOV     107A,W4
0358C:  MOV     #7A,W3
0358E:  CP.B    W3L,W4L
03590:  BRA     NC,3598
03592:  MOV.B   107A,W0L
03594:  AND.B   #DF,W0L
03596:  BRA     359A
03598:  MOV.B   107A,W0L
0359A:  MOV.B   W0L,107A
....................                 fo->name[test++] = character; 
0359C:  MOV.B   107C,W0L
0359E:  INC.B   107C
035A0:  ADD.B   W0L,#1C,W0L
035A2:  ZE      W0,W0
035A4:  CLR.B   1
035A6:  MOV     1072,W4
035A8:  ADD     W0,W4,W5
035AA:  MOV     107A,W0
035AC:  MOV.B   W0L,[W5+#0]
035AE:  INC.B   1078
035B0:  GOTO    356E
....................             } 
....................  
....................             // Get the attributes 
....................             a = dir->DIR_Attr; 
035B4:  MOV     #B,W0
035B6:  ADD     1076,W0
035B8:  MOV     W0,[W15++]
035BA:  MOV.B   [W0],W0L
035BC:  MOV.B   W0L,1079
035BE:  MOV     [--W15],W0
....................  
....................             // its possible to have an extension in a directory 
....................             character = dir->DIR_Extension[0]; 
035C0:  MOV     #8,W0
035C2:  ADD     1076,W0
035C4:  MOV     107A,W4
035C6:  MOV.B   [W0+#0],W4L
035C8:  MOV     W4,107A
....................  
....................             // Get the file extension if its there 
....................             for (index=0; index < DIR_EXTENSION; index++) 
035CA:  CLR.B   1078
035CC:  MOV     1078,W4
035CE:  CP.B    W4L,#3
035D0:  BRA     C,3616
....................             { 
....................                 character = dir->DIR_Extension[index]; 
035D2:  MOV     #8,W0
035D4:  ADD.B   1078,W0L
035D6:  ZE      W0,W0
035D8:  CLR.B   1
035DA:  MOV     1076,W4
035DC:  ADD     W0,W4,W0
035DE:  MOV     107A,W4
035E0:  MOV.B   [W0+#0],W4L
035E2:  MOV     W4,107A
....................                 character = (BYTE)toupper(character); 
035E4:  MOV     107A,W4
035E6:  MOV     #61,W3
035E8:  CP.B    W3L,W4L
035EA:  BRA     GTU,35FA
035EC:  MOV     107A,W4
035EE:  MOV     #7A,W3
035F0:  CP.B    W3L,W4L
035F2:  BRA     NC,35FA
035F4:  MOV.B   107A,W0L
035F6:  AND.B   #DF,W0L
035F8:  BRA     35FC
035FA:  MOV.B   107A,W0L
035FC:  MOV.B   W0L,107A
....................                 fo->name[test++] = character; 
035FE:  MOV.B   107C,W0L
03600:  INC.B   107C
03602:  ADD.B   W0L,#1C,W0L
03604:  ZE      W0,W0
03606:  CLR.B   1
03608:  MOV     1072,W4
0360A:  ADD     W0,W4,W5
0360C:  MOV     107A,W0
0360E:  MOV.B   W0L,[W5+#0]
03610:  INC.B   1078
03612:  GOTO    35CC
....................             } 
....................  
....................    #ifdef __DEBUG_UART 
....................    PrintROMASCIIStringUART(" name="); 
....................    PrintRAMBytesUART(((unsigned char*)fo->name), test);          
....................    #endif 
....................  
....................             // done and done with the name 
....................             //         fo->name[++test] = (BYTE)'\0'; 
....................  
....................             // Now store the identifier 
....................             fo->entry = *fHandle; 
03616:  MOV     #28,W0
03618:  ADD     1072,W0
0361A:  MOV     W0,W5
0361C:  MOV     1074,W0
0361E:  MOV     [W0],[W5]
....................  
....................             // see if we are still a good file 
....................             a = dir->DIR_Name[0]; 
03620:  MOV     #0,W0
03622:  ADD     1076,W0
03624:  MOV     W0,[W15++]
03626:  MOV.B   [W0],W0L
03628:  MOV.B   W0L,1079
0362A:  MOV     [--W15],W0
....................  
....................             if(a == DIR_DEL) 
0362C:  MOV     1078,W4
0362E:  LSR     W4,#8,W4
03630:  XOR.B   #E5,W4L
03632:  BRA     NZ,363C
....................                 status = NOT_FOUND; 
03634:  MOV.B   #1,W0L
03636:  MOV.B   W0L,107B
03638:  GOTO    363E
....................             else 
....................                 status = FOUND; 
0363C:  CLR.B   107B
....................  
....................             // Now store the size 
....................             fo->size = (dir->DIR_FileSize); 
0363E:  MOV     #12,W0
03640:  ADD     1072,W0
03642:  MOV     W0,W5
03644:  MOV     #1C,W0
03646:  ADD     1076,W0
03648:  MOV     [W0++],[W5++]
0364A:  MOV     [W0++],[W5++]
....................  
....................             fo->cluster = GetFullClusterNumber(dir); // Get Complete Cluster number. 
0364C:  MOV     #2,W0
0364E:  ADD     1072,W0
03650:  MOV     W0,W5
03652:  PUSH    1076
03654:  POP     1084
03656:  CALL    34B4
0365A:  MOV     #0,W4
0365C:  MOV     [W4++],[W5++]
0365E:  MOV     [W4++],[W5++]
....................  
....................    #ifdef __DEBUG_UART 
....................    PrintROMASCIIStringUART(" cluster="); 
....................    PrintRAMBytesUART(((unsigned char*)&fo->cluster), 4);          
....................    #endif 
....................  
....................             /// -Get and store the attributes 
....................             a = dir->DIR_Attr; 
03660:  MOV     #B,W0
03662:  ADD     1076,W0
03664:  MOV     W0,[W15++]
03666:  MOV.B   [W0],W0L
03668:  MOV.B   W0L,1079
0366A:  MOV     [--W15],W0
....................             fo->attributes = a; 
0366C:  MOV     #2C,W0
0366E:  ADD     1072,W0
03670:  MOV     W0,W5
03672:  MOV.B   1079,W0L
03674:  MOV.B   W0L,[W5]
03676:  MOV.B   #0,W0L
03678:  MOV.B   W0L,[W5+#1]
....................  
....................             // get the date and time 
....................             if ((a & ATTR_DIRECTORY) != 0) 
0367A:  MOV.B   1079,W0L
0367C:  CLR.B   1
0367E:  AND     W0,#10,W5
03680:  CP0     W5
03682:  BRA     Z,36A0
....................             { 
....................                 fo->time = dir->DIR_CrtTime; 
03684:  MOV     #18,W0
03686:  ADD     1072,W0
03688:  MOV     W0,W5
0368A:  MOV     #E,W0
0368C:  ADD     1076,W0
0368E:  MOV     [W0],[W5]
....................                 fo->date = dir->DIR_CrtDate; 
03690:  MOV     #1A,W0
03692:  ADD     1072,W0
03694:  MOV     W0,W5
03696:  MOV     #10,W0
03698:  ADD     1076,W0
0369A:  MOV     [W0],[W5]
....................             } 
0369C:  GOTO    36B8
....................             else 
....................             { 
....................                 fo->time = dir->DIR_WrtTime; 
036A0:  MOV     #18,W0
036A2:  ADD     1072,W0
036A4:  MOV     W0,W5
036A6:  MOV     #16,W0
036A8:  ADD     1076,W0
036AA:  MOV     [W0],[W5]
....................                 fo->date = dir->DIR_WrtDate; 
036AC:  MOV     #1A,W0
036AE:  ADD     1072,W0
036B0:  MOV     W0,W5
036B2:  MOV     #18,W0
036B4:  ADD     1076,W0
036B6:  MOV     [W0],[W5]
....................             } 
....................  
....................         }// deleted directory 
....................     }// Ensure we are still good 
....................  
.................... #ifdef __DEBUG_UART   
.................... UARTSendLineFeedCarriageReturn(); 
.................... #endif 
....................     return(status); 
036B8:  MOV.B   107B,W0L
036BA:  MOV     [--W15],W5
036BC:  RETURN  
.................... } // Fill_File_Object 
....................  
.................... /***************************************************************** 
....................   Function: 
....................     BYTE Fill_LFN_Object(FILEOBJ fo, LFN_ENTRY *lfno, WORD *fHandle) 
....................   Summary: 
....................     Fill a LFN object with specified entry data 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -   Pointer to file structure 
....................     lfno - Pointer to Long File Name Object 
....................     fHandle -  Passed member's location 
....................   Return Values: 
....................     FOUND -     Operation successful 
....................     NOT_FOUND - Operation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache the sector of LFN entries 
....................     in the directory pointed to by the dirclus value in 
....................     the FSFILE object 'fo' that contains the entry that 
....................     corresponds to the fHandle offset.  It will then copy 
....................     the file information for that entry into the 'fo' FSFILE 
....................     object. 
....................   Remarks: 
....................     None. 
....................   *****************************************************************/ 
.................... #if defined(SUPPORT_LFN) 
.................... BYTE Fill_LFN_Object(FILEOBJ fo, LFN_ENTRY *lfno, WORD *fHandle) 
.................... { 
....................     DIRENTRY    dir; 
....................     BYTE        tempVariable; 
....................     BYTE        *src,*dst; 
....................     BYTE        status; 
....................  
....................     // Get the entry 
....................     if (((*fHandle & MASK_MAX_FILE_ENTRY_LIMIT_BITS) == 0) && (*fHandle != 0)) // 4-bit mask because 16-root entries max per sector 
....................     { 
....................         fo->dirccls = fo->dirclus; 
....................         dir = Cache_File_Entry(fo, fHandle, TRUE); 
....................     } 
....................     else 
....................     { 
....................         dir = Cache_File_Entry (fo, fHandle, FALSE); 
....................     } 
....................  
....................  
....................     // Make sure there is a directory left 
....................     if(dir == (DIRENTRY)NULL) 
....................     { 
....................         status = NO_MORE; 
....................     } 
....................     else 
....................     { 
....................         // Read the first char of the file name 
....................         tempVariable = dir->DIR_Name[0]; 
....................  
....................         // Check for empty or deleted directory 
....................         if ( tempVariable == DIR_DEL) 
....................       { 
....................             status = NOT_FOUND; 
....................       } 
....................       else if ( tempVariable == DIR_EMPTY) 
....................       { 
....................          status = NO_MORE; 
....................       } 
....................         else 
....................         { 
....................             status = FOUND; 
....................  
....................          dst = (BYTE *)lfno; 
....................          src = (BYTE *)dir; 
....................  
....................          // Copy the entry in the lfno object 
....................          for(tempVariable = 0;tempVariable < 32;tempVariable++) 
....................          { 
....................             *dst++ = *src++; 
....................          } 
....................         }// deleted directory 
....................     }// Ensure we are still good 
....................     return(status); 
.................... } // Fill_File_Object 
.................... #endif 
.................... /************************************************************************ 
....................   Function: 
....................     DIRENTRY LoadDirAttrib(FILEOBJ fo, WORD *fHandle) 
....................   Summary: 
....................     Load file information from a directory entry and cache the entry 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................     fHandle -  Information location 
....................   Return Values: 
....................     DIRENTRY - Pointer to the directory entry 
....................     NULL -     Directory entry could not be loaded 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache the sector of directory entries 
....................     in the directory pointed to by the dirclus value in 
....................     the FSFILE object 'fo' that contains the entry that 
....................     corresponds to the fHandle offset.  It will then return a pointer 
....................     to the directory entry in the global data buffer. 
....................   Remarks: 
....................     None. 
....................   ************************************************************************/ 
....................  
.................... DIRENTRY LoadDirAttrib(FILEOBJ fo, WORD *fHandle) 
*
042F0:  MOV     W5,[W15++]
.................... { 
....................     DIRENTRY    dir; 
042F2:  CLR     104E
....................     BYTE      a; 
042F4:  CLR.B   1050
....................  
....................     fo->dirccls = fo->dirclus; 
042F6:  MOV     #32,W0
042F8:  ADD     104A,W0
042FA:  MOV     W0,W5
042FC:  MOV     #2E,W0
042FE:  ADD     104A,W0
04300:  MOV     [W0++],[W5++]
04302:  MOV     [W0++],[W5++]
....................     // Get the entry 
....................     dir = Cache_File_Entry( fo, fHandle, TRUE); 
04304:  MOV.B   #1,W0L
04306:  MOV.B   W0L,1086
04308:  PUSH    104A
0430A:  POP     1082
0430C:  PUSH    104C
0430E:  POP     1084
04310:  CALL    31E4
04314:  MOV     W0,104E
....................     if (dir == NULL) 
04316:  CP0     104E
04318:  BRA     NZ,431E
....................         return NULL; 
0431A:  CLR     0
0431C:  BRA     437C
....................  
....................     // Read the first char of the file name 
....................     a = dir->DIR_Name[0]; 
0431E:  MOV     #0,W0
04320:  ADD     104E,W0
04322:  MOV     1050,W4
04324:  MOV.B   [W0+#0],W4L
04326:  MOV     W4,1050
....................  
....................     // Make sure there is a directory left 
....................     if(a == DIR_EMPTY) 
04328:  CP0.B   1050
0432A:  BRA     NZ,432E
....................         dir = (DIRENTRY)NULL; 
0432C:  CLR     104E
....................  
....................     if(dir != (DIRENTRY)NULL) 
0432E:  CP0     104E
04330:  BRA     Z,4378
....................     { 
....................         // Check for empty or deleted directory 
....................         if ( a == DIR_DEL) 
04332:  MOV     1050,W4
04334:  XOR.B   #E5,W4L
04336:  BRA     NZ,433E
....................             dir = (DIRENTRY)NULL; 
04338:  CLR     104E
0433A:  GOTO    4378
....................         else 
....................         { 
....................             // Get the attributes 
....................             a = dir->DIR_Attr; 
0433E:  MOV     #B,W0
04340:  ADD     104E,W0
04342:  MOV     1050,W4
04344:  MOV.B   [W0+#0],W4L
04346:  MOV     W4,1050
....................  
....................             // scan through all the long dir entries 
....................             while(a == ATTR_LONG_NAME) 
04348:  MOV     1050,W4
0434A:  CP.B    W4L,#F
0434C:  BRA     NZ,4378
....................             { 
....................                 (*fHandle)++; 
0434E:  MOV     104C,W5
04350:  INC     [W5],[W5]
....................                 dir = Cache_File_Entry( fo, fHandle, FALSE); 
04352:  CLR.B   1086
04354:  PUSH    104A
04356:  POP     1082
04358:  PUSH    104C
0435A:  POP     1084
0435C:  CALL    31E4
04360:  MOV     W0,104E
....................                 if (dir == NULL) 
04362:  CP0     104E
04364:  BRA     NZ,436A
....................                     return NULL; 
04366:  CLR     0
04368:  BRA     437C
....................                 a = dir->DIR_Attr; 
0436A:  MOV     #B,W0
0436C:  ADD     104E,W0
0436E:  MOV     1050,W4
04370:  MOV.B   [W0+#0],W4L
04372:  MOV     W4,1050
04374:  GOTO    4348
....................             } // long file name while loop 
....................         } // deleted dir 
....................     }// Ensure we are still good 
....................  
....................     return(dir); 
04378:  PUSH    104E
0437A:  POP     0
0437C:  MOV     [--W15],W5
0437E:  RETURN  
.................... } // LoadDirAttrib 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     CETYPE FILEerase( FILEOBJ fo, WORD *fHandle, BYTE EraseClusters) 
....................   Summary: 
....................     Erase a file 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -            Pointer to file structure 
....................     fHandle -       Location of file information 
....................     EraseClusters - If set to TRUE, delete the corresponding cluster of file 
....................   Return Values: 
....................     CE_GOOD - File erased successfully 
....................     CE_FILE_NOT_FOUND - Could not find the file on the card 
....................     CE_ERASE_FAIL - Internal Card erase failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache the sector of directory entries in the directory 
....................     pointed to by the dirclus value in the FSFILE object 'fo' that contains 
....................     the entry that corresponds to the fHandle offset.  It will then mark that 
....................     entry as deleted.  If the EraseClusters argument is TRUE, the chain of 
....................     clusters for that file will be marked as unused in the FAT by the 
....................     FAT_erase_cluster_chain function. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... CETYPE FILEerase( FILEOBJ fo, WORD *fHandle, BYTE EraseClusters) 
*
03BA8:  MOV     W5,[W15++]
03BAA:  MOV     W6,[W15++]
*
03BB0:  CLR.B   1052
03BB2:  CLR     1054
03BB4:  CLR     1056
*
03BBA:  BSET.B  105A.0
.................... { 
....................     DIRENTRY    dir; 
*
03BAC:  CLR     1050
....................     BYTE        a; 
03BAE:  CLR.B   104F
....................     CETYPE      status = CE_GOOD; 
....................     DWORD       clus = 0; 
....................     DISK *      disk; 
*
03BB6:  CLR     1058
....................  
....................     BYTE   numberOfFileEntries; 
03BB8:  CLR.B   1053
....................    BOOL   forFirstTime = TRUE; 
....................    #if defined(SUPPORT_LFN) 
....................       BYTE   tempCalc1; 
....................    #endif 
....................  
....................     disk = fo->dsk; 
*
03BBC:  MOV     104A,W4
03BBE:  ADD     W4,#0,W4
03BC0:  MOV     W4,W0
03BC2:  MOV     [W0],[W15++]
03BC4:  POP     1058
....................  
....................    #if defined(SUPPORT_LFN) 
....................  
....................    fileNameLength = fo->utf16LFNlength; 
....................  
....................    // Find the number of entries of LFN in the root directory 
....................    if(fileNameLength) 
....................    { 
....................       tempCalc1 = fileNameLength % 13; 
....................  
....................       numberOfFileEntries = fileNameLength/13; 
....................  
....................       if(tempCalc1 || (fileNameLength < 13)) 
....................       { 
....................          numberOfFileEntries = numberOfFileEntries + 2; 
....................       } 
....................       else 
....................       { 
....................          numberOfFileEntries++; 
....................       } 
....................    } 
....................    else 
....................    #endif 
....................    { 
....................       numberOfFileEntries = 1; 
03BC6:  MOV.B   #1,W0L
03BC8:  MOV.B   W0L,1053
....................    } 
....................  
....................    FSerrno = CE_ERASE_FAIL; 
03BCA:  MOV.B   #1,W0L
03BCC:  MOV.B   W0L,8B1
....................  
....................    // delete all the entries of LFN in root directory 
....................    while(numberOfFileEntries--) 
03BCE:  MOV.B   1053,W0L
03BD0:  DEC.B   1053
03BD2:  CP0.B   W0L
03BD4:  BRA     Z,3C6A
....................    { 
....................        // reset the cluster 
....................        fo->dirccls = fo->dirclus; 
03BD6:  MOV     #32,W0
03BD8:  ADD     104A,W0
03BDA:  MOV     W0,W5
03BDC:  MOV     #2E,W0
03BDE:  ADD     104A,W0
03BE0:  MOV     [W0++],[W5++]
03BE2:  MOV     [W0++],[W5++]
....................  
....................        // load the sector 
....................        dir = Cache_File_Entry(fo, fHandle, TRUE); 
03BE4:  MOV.B   #1,W0L
03BE6:  MOV.B   W0L,1086
03BE8:  PUSH    104A
03BEA:  POP     1082
03BEC:  PUSH    104C
03BEE:  POP     1084
03BF0:  CALL    31E4
03BF4:  MOV     W0,1050
....................  
....................        if (dir == NULL) 
03BF6:  CP0     1050
03BF8:  BRA     NZ,3C00
....................        { 
....................            return CE_BADCACHEREAD; 
03BFA:  MOV.B   #1B,W0L
03BFC:  MOV.B   W0L,0
03BFE:  BRA     3CA8
....................        } 
....................  
....................        // Fill up the File Object with the information pointed to by fHandle 
....................        a = dir->DIR_Name[0]; 
03C00:  MOV     #0,W0
03C02:  ADD     1050,W0
03C04:  MOV     W0,[W15++]
03C06:  MOV.B   [W0],W0L
03C08:  MOV.B   W0L,104F
03C0A:  MOV     [--W15],W0
....................  
....................        // see if there is something in the dir 
....................        if((dir == (DIRENTRY)NULL) || (a == DIR_EMPTY) || (a == DIR_DEL)) 
03C0C:  CP0     1050
03C0E:  BRA     Z,3C1C
03C10:  CP0.B   104F
03C12:  BRA     Z,3C1C
03C14:  MOV     104E,W4
03C16:  LSR     W4,#8,W4
03C18:  XOR.B   #E5,W4L
03C1A:  BRA     NZ,3C28
....................        { 
....................            status = CE_FILE_NOT_FOUND; 
03C1C:  MOV.B   #B,W0L
03C1E:  MOV.B   W0L,1052
....................          break; 
03C20:  GOTO    3C6A
....................        } 
03C24:  GOTO    3C4A
....................       else 
....................       { 
....................             /* 8.3 File Name - entry*/ 
....................             dir->DIR_Name[0] = DIR_DEL; // mark as deleted 
03C28:  MOV     #0,W0
03C2A:  ADD     1050,W0
03C2C:  MOV     W0,W5
03C2E:  MOV.B   #E5,W0L
03C30:  MOV.B   W0L,[W5]
....................  
....................          if(!(Write_File_Entry( fo, fHandle))) 
03C32:  PUSH    104A
03C34:  POP     1060
03C36:  PUSH    104C
03C38:  POP     1062
03C3A:  CALL    3964
03C3E:  CP0.B   W0L
03C40:  BRA     NZ,3C4A
....................            { 
....................                status = CE_ERASE_FAIL; 
03C42:  MOV.B   #1,W0L
03C44:  MOV.B   W0L,1052
....................             break; 
03C46:  GOTO    3C6A
....................            } 
....................       } 
....................  
....................       if(forFirstTime) 
03C4A:  BTSS.B  105A.0
03C4C:  BRA     3C5C
....................       { 
....................          // Get the starting cluster 
....................          clus = GetFullClusterNumber(dir); // Get Complete Cluster number. 
03C4E:  PUSH    1050
03C50:  POP     1084
03C52:  CALL    34B4
03C56:  MOV     W0,1054
03C58:  MOV     W1,1056
....................          forFirstTime = FALSE; 
03C5A:  BCLR.B  105A.0
....................       } 
....................  
....................       *fHandle = *fHandle - 1; 
03C5C:  MOV     104C,W5
03C5E:  MOV     104C,W0
03C60:  MOV     [W0],W6
03C62:  SUB     W6,#1,W0
03C64:  MOV     W0,[W5]
03C66:  GOTO    3BCE
....................    } 
....................  
....................    if(status == CE_GOOD) 
03C6A:  CP0.B   1052
03C6C:  BRA     NZ,3CA4
....................    { 
....................       if (clus != FatRootDirClusterValue) // 
03C6E:  MOV     1054,W0
03C70:  CP      8B2
03C72:  BRA     NZ,3C7A
03C74:  MOV     1056,W0
03C76:  CP      8B4
03C78:  BRA     Z,3CA0
....................       { 
....................          // If 'EraseClusters' is set to TRUE, erase the cluster chain corresponding to file 
....................           if(EraseClusters) 
03C7A:  CP0.B   104E
03C7C:  BRA     Z,3CA0
....................           { 
....................               /* Now remove the cluster allocation from the FAT */ 
....................               status = ((FAT_erase_cluster_chain(clus, disk)) ? CE_GOOD : CE_ERASE_FAIL); 
03C7E:  PUSH    1054
03C80:  POP     1060
03C82:  PUSH    1056
03C84:  POP     1062
03C86:  PUSH    1058
03C88:  POP     1064
03C8A:  CALL    3A80
03C8E:  CP0.B   W0L
03C90:  BRA     Z,3C9A
03C92:  MOV     #0,W0
03C94:  MOV     #0,W1
03C96:  GOTO    3C9E
03C9A:  MOV     #1,W0
03C9C:  MOV     #0,W1
03C9E:  MOV.B   W0L,1052
....................           } 
....................       } 
....................  
....................       FSerrno = status; 
03CA0:  MOV.B   1052,W0L
03CA2:  MOV.B   W0L,8B1
....................    } 
....................  
....................     return (status); 
03CA4:  MOV.B   1052,W0L
03CA6:  MOV.B   W0L,0
03CA8:  MOV     [--W15],W6
03CAA:  MOV     [--W15],W5
03CAC:  RETURN  
.................... } 
.................... #endif 
....................  
.................... /*************************************************************** 
....................   Function: 
....................     int FSrename (const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices. 
....................     First, it will search through the current working directory to ensure the 
....................     specified new filename is not already in use. If it isn't, the new filename 
....................     will be written to the file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None 
....................   ***************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... int FSrename (const char * fileName, FSFILE * fo) 
.................... { 
....................     WORD fHandle; 
....................    FSFILE   tempFo1,tempFo2; 
....................     DIRENTRY dir; 
....................     #ifdef SUPPORT_LFN 
....................     DWORD  TempMsbCluster; 
....................     #else 
....................     BYTE j; 
....................     #endif 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................     if (MDD_WriteProtectState()) 
....................     { 
....................         FSerrno = CE_WRITE_PROTECTED; 
....................         return (-1); 
....................     } 
....................  
....................      // copy file object over 
....................     FileObjectCopy(&tempFo1, fo); 
....................  
....................     //Format the source string 
....................     if(!FormatFileName(fileName, &tempFo1, 0) ) 
....................     { 
....................         FSerrno = CE_INVALID_FILENAME; 
....................         return -1; 
....................     } 
....................  
....................    tempFo1.entry  = 0; 
....................  
....................    // start at the current directory 
....................    tempFo1.dirclus  = cwdptr->dirclus; 
....................    tempFo1.dirccls  = cwdptr->dirccls; 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&tempFo2, &tempFo1); 
....................  
....................     // See if the file is found 
....................     if(FILEfind (&tempFo2, &tempFo1, LOOK_FOR_MATCHING_ENTRY, 0) == CE_FILE_NOT_FOUND) 
....................    { 
....................       fHandle = fo->entry; 
....................  
....................       #ifdef SUPPORT_LFN 
....................  
....................       if(CE_GOOD != FILEerase(fo, &fHandle, FALSE)) 
....................       { 
....................          FSerrno = CE_ERASE_FAIL; 
....................          return -1; 
....................       } 
....................  
....................          // Create the new entry as per the user requested name 
....................          FSerrno = CreateFileEntry (&tempFo1, &fHandle, tempFo1.attributes, FALSE); 
....................  
....................          // load the file entry so the new cluster can be linked to it 
....................          dir = LoadDirAttrib(&tempFo1, &fHandle); 
....................  
....................          // Now update the new cluster 
....................          dir->DIR_FstClusLO = (fo->cluster & 0x0000FFFF); 
....................  
....................          #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................          // Get the higher part of cluster and store it in directory entry. 
....................          TempMsbCluster = (fo->cluster & 0x0FFF0000);    // Since only 28 bits usedin FAT32. Mask the higher MSB nibble. 
....................          TempMsbCluster = TempMsbCluster >> 16;      // Get the date into Lsb place. 
....................          dir->DIR_FstClusHI = TempMsbCluster; 
....................          #else // If FAT32 support not enabled 
....................          TempMsbCluster = 0;                         // Just to avoid compiler warnigng. 
....................          dir->DIR_FstClusHI = 0; 
....................          #endif 
....................  
....................       // Update the file size 
....................         dir->DIR_FileSize = fo->size; 
....................  
....................          // now write it 
....................          if(Write_File_Entry(&tempFo1, &fHandle) != TRUE) 
....................       { 
....................           FSerrno = CE_WRITE_ERROR; 
....................           return -1; 
....................       } 
....................  
....................          tempFo1.size = fo->size; 
....................  
....................       // copy file object over 
....................       FileObjectCopy(fo, &tempFo1); 
....................  
....................       #else 
....................  
....................         // Get the file entry 
....................         dir = LoadDirAttrib(fo, &fHandle); 
....................  
....................         for (j = 0; j < 11; j++) 
....................         { 
....................             fo->name[j] = tempFo1.name[j]; 
....................             dir->DIR_Name[j] = tempFo1.name[j]; 
....................         } 
....................  
....................         // just write the last entry in 
....................         if(!Write_File_Entry(fo,&fHandle)) 
....................         { 
....................             FSerrno = CE_WRITE_ERROR; 
....................             return -1; 
....................         } 
....................  
....................       #endif 
....................    } 
....................    else 
....................    { 
....................         FSerrno = CE_FILENAME_EXISTS; 
....................         return -1; 
....................    } 
....................  
....................     return 0; 
.................... } 
....................  
.................... /*************************************************************** 
....................   Function: 
....................     int wFSrename (const rom unsigned short int * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices. First, it will search through the current 
....................     working directory to ensure the specified new UTF16 filename is not 
....................     already in use.  If it isn't, the new filename will be written to the 
....................     file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None 
....................   ***************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSrename (const unsigned short int * fileName, FSFILE * fo) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................    result = FSrename ((const char *)fileName,fo); 
....................    utfModeFileName = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... #endif // Allow writes 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * wFSfopen (const unsigned short int * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... FSFILE * wFSfopen( const unsigned short int * fileName, const char *mode ) 
.................... { 
....................    FSFILE *result; 
....................    utfModeFileName = TRUE; 
....................    result = FSfopen((const char *)fileName,mode); 
....................    utfModeFileName = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * FSfopen (const char * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with ascii input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will open a ascii name file or directory on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * FSfopen( const char * fileName, const char *mode ) 
*
04A26:  MOV     W5,[W15++]
04A28:  MOV     W6,[W15++]
04A2A:  MOV     W7,[W15++]
.................... { 
....................     FILEOBJ    filePtr; 
04A2C:  CLR     1020
.................... #ifndef FS_DYNAMIC_MEM 
....................     int      fIndex; 
04A2E:  CLR     1022
.................... #endif 
....................     BYTE   ModeC; 
04A30:  CLR.B   1024
....................     WORD    fHandle; 
04A32:  CLR     1026
....................     CETYPE   final; 
04A34:  CLR.B   1025
....................  
....................     //Read the mode character 
....................     ModeC = mode[0]; 
04A36:  MOV     #0,W0
04A38:  ADD     101E,W0
04A3A:  MOV     1024,W4
04A3C:  MOV.B   [W0+#0],W4L
04A3E:  MOV     W4,1024
....................  
....................     if(MDD_WriteProtectState() && (ModeC != 'r') && (ModeC != 'R')) 
04A40:  CALL    25A0
04A44:  CP0.B   W0L
04A46:  BRA     Z,4A5C
04A48:  MOV     1024,W4
04A4A:  XOR.B   #72,W4L
04A4C:  BRA     Z,4A5C
04A4E:  MOV     1024,W4
04A50:  XOR.B   #52,W4L
04A52:  BRA     Z,4A5C
....................     { 
....................         FSerrno = CE_WRITE_PROTECTED; 
04A54:  MOV.B   #18,W0L
04A56:  MOV.B   W0L,8B1
....................         return NULL; 
04A58:  CLR     0
04A5A:  BRA     4E34
....................     } 
....................  
.................... #ifdef FS_DYNAMIC_MEM 
....................     filePtr = (FILEOBJ) FS_malloc(sizeof(FSFILE)); 
.................... #else 
....................  
....................     filePtr = NULL; 
04A5C:  CLR     1020
....................  
....................     //Pick available file structure 
....................     for( fIndex = 0; fIndex < FS_MAX_FILES_OPEN; fIndex++ ) 
04A5E:  CLR     1022
04A60:  MOV     1022,W4
04A62:  CP      W4,#1
04A64:  BRA     GE,4A8E
....................     { 
....................         if( gFileSlotOpen[fIndex] )   //this slot is available 
04A66:  MOV     #85B,W4
04A68:  MOV     1022,W3
04A6A:  ADD     W3,W4,W0
04A6C:  CP0.B   [W0]
04A6E:  BRA     Z,4A88
....................         { 
....................             gFileSlotOpen[fIndex] = FALSE; 
04A70:  MOV     #85B,W4
04A72:  MOV     1022,W3
04A74:  ADD     W3,W4,W5
04A76:  CLR.B   [W5]
....................             filePtr = &gFileArray[fIndex]; 
04A78:  MOV     1022,W4
04A7A:  MOV     #36,W3
04A7C:  MUL.SS  W4,W3,W0
04A7E:  MOV     #862,W4
04A80:  ADD     W0,W4,W0
04A82:  MOV     W0,1020
....................          break; 
04A84:  GOTO    4A8E
....................         } 
04A88:  INC     1022
04A8A:  GOTO    4A60
....................     } 
....................  
....................     if( filePtr == NULL ) 
04A8E:  CP0     1020
04A90:  BRA     NZ,4A9A
....................     { 
....................         FSerrno = CE_TOO_MANY_FILES_OPEN; 
04A92:  MOV.B   #20,W0L
04A94:  MOV.B   W0L,8B1
....................         return NULL;      //no file structure slot available 
04A96:  CLR     0
04A98:  BRA     4E34
....................     } 
.................... #endif 
....................  
....................    #if defined(SUPPORT_LFN) 
....................       #if defined(FS_DYNAMIC_MEM) 
....................          filePtr -> utf16LFNptr = (unsigned short int *)FS_malloc(514); 
....................       #else 
....................          filePtr->utf16LFNptr = &lfnData[fIndex][0]; 
....................       #endif 
....................     #endif 
....................  
....................     //Format the source string. 
....................     if( !FormatFileName(fileName, filePtr, 0) ) 
04A9A:  CLR.B   105E
04A9C:  PUSH    101C
04A9E:  POP     105A
04AA0:  PUSH    1020
04AA2:  POP     105C
04AA4:  CALL    26EC
04AA8:  CP0.B   W0L
04AAA:  BRA     NZ,4ABE
....................     { 
....................       #ifdef FS_DYNAMIC_MEM 
....................          #if defined(SUPPORT_LFN) 
....................             FS_free((unsigned char *)filePtr->utf16LFNptr); 
....................          #endif 
....................            FS_free( (unsigned char *)filePtr ); 
....................       #else 
....................            gFileSlotOpen[fIndex] = TRUE;   //put this slot back to the pool 
04AAC:  MOV     #85B,W4
04AAE:  MOV     1022,W3
04AB0:  ADD     W3,W4,W5
04AB2:  MOV.B   #1,W0L
04AB4:  MOV.B   W0L,[W5]
....................       #endif 
....................  
....................       FSerrno = CE_INVALID_FILENAME; 
04AB6:  MOV.B   #12,W0L
04AB8:  MOV.B   W0L,8B1
....................         return NULL;   //bad filename 
04ABA:  CLR     0
04ABC:  BRA     4E34
....................     } 
....................  
....................     filePtr->dsk = &gDiskData; 
04ABE:  MOV     1020,W4
04AC0:  ADD     W4,#0,W4
04AC2:  MOV     W4,W0
04AC4:  MOV     W0,W5
04AC6:  MOV.B   #60,W0L
04AC8:  MOV.B   W0L,[W5]
04ACA:  MOV.B   #D,W0L
04ACC:  MOV.B   W0L,[W5+#1]
....................     filePtr->cluster = 0; 
04ACE:  MOV     #2,W0
04AD0:  ADD     1020,W0
04AD2:  MOV     W0,W5
04AD4:  CLR.B   [W5]
04AD6:  MOV.B   #0,W0L
04AD8:  MOV.B   W0L,[W5+#1]
04ADA:  MOV.B   #0,W0L
04ADC:  MOV.B   W0L,[W5+#2]
04ADE:  MOV.B   #0,W0L
04AE0:  MOV.B   W0L,[W5+#3]
....................     filePtr->ccls    = 0; 
04AE2:  MOV     #6,W0
04AE4:  ADD     1020,W0
04AE6:  MOV     W0,W5
04AE8:  CLR.B   [W5]
04AEA:  MOV.B   #0,W0L
04AEC:  MOV.B   W0L,[W5+#1]
04AEE:  MOV.B   #0,W0L
04AF0:  MOV.B   W0L,[W5+#2]
04AF2:  MOV.B   #0,W0L
04AF4:  MOV.B   W0L,[W5+#3]
....................     filePtr->entry = 0; 
04AF6:  MOV     #28,W0
04AF8:  ADD     1020,W0
04AFA:  MOV     W0,W5
04AFC:  CLR.B   [W5]
04AFE:  MOV.B   #0,W0L
04B00:  MOV.B   W0L,[W5+#1]
....................     filePtr->attributes = ATTR_ARCHIVE; 
04B02:  MOV     #2C,W0
04B04:  ADD     1020,W0
04B06:  MOV     W0,W5
04B08:  MOV.B   #20,W0L
04B0A:  MOV.B   W0L,[W5]
04B0C:  MOV.B   #0,W0L
04B0E:  MOV.B   W0L,[W5+#1]
....................  
....................     // start at the current directory 
.................... #ifdef ALLOW_DIRS 
....................     filePtr->dirclus    = cwdptr->dirclus; 
04B10:  MOV     #2E,W0
04B12:  ADD     1020,W0
04B14:  MOV     W0,W5
04B16:  MOV     #2E,W0
04B18:  ADD     95E,W0
04B1A:  MOV     [W0++],[W5++]
04B1C:  MOV     [W0++],[W5++]
....................     filePtr->dirccls    = cwdptr->dirccls; 
04B1E:  MOV     #32,W0
04B20:  ADD     1020,W0
04B22:  MOV     W0,W5
04B24:  MOV     #32,W0
04B26:  ADD     95E,W0
04B28:  MOV     [W0++],[W5++]
04B2A:  MOV     [W0++],[W5++]
.................... #else 
....................     filePtr->dirclus = FatRootDirClusterValue; 
....................     filePtr->dirccls = FatRootDirClusterValue; 
.................... #endif 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&gFileTemp, filePtr); 
04B2C:  MOV     #8F2,W4
04B2E:  MOV     W4,105C
04B30:  PUSH    1020
04B32:  POP     105E
04B34:  CALL    28E2
....................  
....................     // See if the file is found 
....................     if(FILEfind (filePtr, &gFileTemp, LOOK_FOR_MATCHING_ENTRY, 0) == CE_GOOD) 
04B38:  MOV.B   #1,W0L
04B3A:  MOV.B   W0L,1060
04B3C:  CLR.B   1061
04B3E:  PUSH    1020
04B40:  POP     105C
04B42:  MOV     #8F2,W4
04B44:  MOV     W4,105E
04B46:  CALL    36BE
04B4A:  CP0.B   W0L
04B4C:  BRA     NZ,4D66
....................     { 
....................         // File is Found 
....................         switch(ModeC) 
04B4E:  MOV.B   1024,W0L
04B50:  CLR.B   1
04B52:  XOR     #77,W0
04B54:  BRA     Z,4B6C
04B56:  XOR     #20,W0
04B58:  BRA     Z,4B6C
04B5A:  XOR     #16,W0
04B5C:  BRA     Z,4BF6
04B5E:  XOR     #20,W0
04B60:  BRA     Z,4BF6
04B62:  XOR     #33,W0
04B64:  BRA     Z,4D18
04B66:  XOR     #20,W0
04B68:  BRA     Z,4D18
04B6A:  BRA     4D56
....................         { 
.................... #ifdef ALLOW_WRITES 
....................             case 'w': 
....................             case 'W': 
....................             { 
....................                 // File exists, we want to create a new one, remove it first 
....................                 fHandle = filePtr->entry; 
04B6C:  MOV     #28,W0
04B6E:  ADD     1020,W0
04B70:  MOV     [W0],[W15++]
04B72:  POP     1026
....................                 final = FILEerase(filePtr, &fHandle, TRUE); 
04B74:  MOV.B   #1,W0L
04B76:  MOV.B   W0L,104E
04B78:  PUSH    1020
04B7A:  POP     104A
04B7C:  MOV     #1026,W4
04B7E:  MOV     W4,104C
04B80:  CALL    3BA8
04B84:  MOV.B   W0L,1025
....................  
....................                 if (final == CE_GOOD) 
04B86:  CP0.B   1025
04B88:  BRA     NZ,4BF2
....................                 { 
....................                     // now create a new one 
....................                     final = CreateFileEntry (filePtr, &fHandle, 0, TRUE); 
04B8A:  CLR.B   1030
04B8C:  MOV.B   #1,W0L
04B8E:  MOV.B   W0L,1031
04B90:  PUSH    1020
04B92:  POP     102C
04B94:  MOV     #1026,W4
04B96:  MOV     W4,102E
04B98:  CALL    43FA
04B9C:  MOV.B   W0L,1025
....................  
....................                     if (final == CE_GOOD) 
04B9E:  CP0.B   1025
04BA0:  BRA     NZ,4BF2
....................                     { 
....................                         final = FILEopen (filePtr, &fHandle, 'w'); 
04BA2:  MOV.B   #77,W0L
04BA4:  MOV.B   W0L,105E
04BA6:  PUSH    1020
04BA8:  POP     105A
04BAA:  MOV     #1026,W4
04BAC:  MOV     W4,105C
04BAE:  CALL    4454
04BB2:  MOV.B   W0L,1025
....................  
....................                         if (filePtr->attributes & ATTR_DIRECTORY) 
04BB4:  MOV     #2C,W0
04BB6:  ADD     1020,W0
04BB8:  MOV     [W0],W5
04BBA:  AND     W5,#10,W0
04BBC:  CP0     W0
04BBE:  BRA     Z,4BC8
....................                         { 
....................                             FSerrno = CE_INVALID_ARGUMENT; 
04BC0:  MOV.B   #1F,W0L
04BC2:  MOV.B   W0L,8B1
....................                             final = 0xFF; 
04BC4:  MOV.B   #FF,W0L
04BC6:  MOV.B   W0L,1025
....................                         } 
....................  
....................                         if (final == CE_GOOD) 
04BC8:  CP0.B   1025
04BCA:  BRA     NZ,4BF2
....................                         { 
....................                             final = FSfseek (filePtr, 0, SEEK_END); 
04BCC:  PUSH    1020
04BCE:  POP     102C
04BD0:  CLR     102E
04BD2:  CLR     1030
04BD4:  MOV     #2,W4
04BD6:  MOV     W4,1032
04BD8:  CALL    4760
04BDC:  MOV.B   W0L,1025
....................                             if (mode[1] == '+') 
04BDE:  MOV     #1,W0
04BE0:  ADD     101E,W0
04BE2:  MOV.B   [W0],W4L
04BE4:  XOR.B   #2B,W4L
04BE6:  BRA     NZ,4BF2
....................                                 filePtr->flags.read = 1; 
04BE8:  MOV     #16,W0
04BEA:  ADD     1020,W0
04BEC:  MOV     W0,W5
04BEE:  MOV     #2,W4
04BF0:  IOR.B    W4L,  [W5],[W5]
....................                         } 
....................                     } 
....................                 } 
....................                 break; 
04BF2:  GOTO    4D62
....................             } 
....................  
....................             case 'A': 
....................             case 'a': 
....................             { 
....................                 if(filePtr->size != 0) 
04BF6:  MOV     #12,W0
04BF8:  ADD     1020,W0
04BFA:  MOV     #A,W4
04BFC:  MOV     [W0++],[W4++]
04BFE:  MOV     [W0++],[W4++]
04C00:  CP0     W5
04C02:  BRA     NZ,4C08
04C04:  CP0     W6
04C06:  BRA     Z,4C86
....................                 { 
....................                     fHandle = filePtr->entry; 
04C08:  MOV     #28,W0
04C0A:  ADD     1020,W0
04C0C:  MOV     [W0],[W15++]
04C0E:  POP     1026
....................  
....................                     final = FILEopen (filePtr, &fHandle, 'w'); 
04C10:  MOV.B   #77,W0L
04C12:  MOV.B   W0L,105E
04C14:  PUSH    1020
04C16:  POP     105A
04C18:  MOV     #1026,W4
04C1A:  MOV     W4,105C
04C1C:  CALL    4454
04C20:  MOV.B   W0L,1025
....................  
....................                     if (filePtr->attributes & ATTR_DIRECTORY) 
04C22:  MOV     #2C,W0
04C24:  ADD     1020,W0
04C26:  MOV     [W0],W5
04C28:  AND     W5,#10,W0
04C2A:  CP0     W0
04C2C:  BRA     Z,4C36
....................                     { 
....................                         FSerrno = CE_INVALID_ARGUMENT; 
04C2E:  MOV.B   #1F,W0L
04C30:  MOV.B   W0L,8B1
....................                         final = 0xFF; 
04C32:  MOV.B   #FF,W0L
04C34:  MOV.B   W0L,1025
....................                     } 
....................  
....................                     if (final == CE_GOOD) 
04C36:  CP0.B   1025
04C38:  BRA     NZ,4C82
....................                     { 
....................                         final = FSfseek (filePtr, 0, SEEK_END); 
04C3A:  PUSH    1020
04C3C:  POP     102C
04C3E:  CLR     102E
04C40:  CLR     1030
04C42:  MOV     #2,W4
04C44:  MOV     W4,1032
04C46:  CALL    4760
04C4A:  MOV.B   W0L,1025
....................                         if (final != CE_GOOD) 
04C4C:  CP0.B   1025
04C4E:  BRA     Z,4C58
....................                             FSerrno = CE_SEEK_ERROR; 
04C50:  MOV.B   #1A,W0L
04C52:  MOV.B   W0L,8B1
04C54:  GOTO    4C6E
....................                         else 
....................                             ReadFAT (&gDiskData, filePtr->ccls); 
04C58:  MOV     #D60,W5
04C5A:  MOV     #6,W0
04C5C:  ADD     1020,W0
04C5E:  MOV     #C,W4
04C60:  MOV     [W0++],[W4++]
04C62:  MOV     [W0++],[W4++]
04C64:  MOV     W5,10A2
04C66:  MOV     W6,10A4
04C68:  MOV     W7,10A6
04C6A:  CALL    2ECC
....................                         if (mode[1] == '+') 
04C6E:  MOV     #1,W0
04C70:  ADD     101E,W0
04C72:  MOV.B   [W0],W4L
04C74:  XOR.B   #2B,W4L
04C76:  BRA     NZ,4C82
....................                             filePtr->flags.read = 1; 
04C78:  MOV     #16,W0
04C7A:  ADD     1020,W0
04C7C:  MOV     W0,W5
04C7E:  MOV     #2,W4
04C80:  IOR.B    W4L,  [W5],[W5]
....................                     } 
....................                 } 
04C82:  GOTO    4D14
....................                 else 
....................                 { 
....................                     fHandle = filePtr->entry; 
04C86:  MOV     #28,W0
04C88:  ADD     1020,W0
04C8A:  MOV     [W0],[W15++]
04C8C:  POP     1026
....................                     final = FILEerase(filePtr, &fHandle, TRUE); 
04C8E:  MOV.B   #1,W0L
04C90:  MOV.B   W0L,104E
04C92:  PUSH    1020
04C94:  POP     104A
04C96:  MOV     #1026,W4
04C98:  MOV     W4,104C
04C9A:  CALL    3BA8
04C9E:  MOV.B   W0L,1025
....................  
....................                     if (final == CE_GOOD) 
04CA0:  CP0.B   1025
04CA2:  BRA     NZ,4D14
....................                     { 
....................                         // now create a new one 
....................                         final = CreateFileEntry (filePtr, &fHandle, 0, TRUE); 
04CA4:  CLR.B   1030
04CA6:  MOV.B   #1,W0L
04CA8:  MOV.B   W0L,1031
04CAA:  PUSH    1020
04CAC:  POP     102C
04CAE:  MOV     #1026,W4
04CB0:  MOV     W4,102E
04CB2:  CALL    43FA
04CB6:  MOV.B   W0L,1025
....................  
....................                         if (final == CE_GOOD) 
04CB8:  CP0.B   1025
04CBA:  BRA     NZ,4D14
....................                         { 
....................                             final = FILEopen (filePtr, &fHandle, 'w'); 
04CBC:  MOV.B   #77,W0L
04CBE:  MOV.B   W0L,105E
04CC0:  PUSH    1020
04CC2:  POP     105A
04CC4:  MOV     #1026,W4
04CC6:  MOV     W4,105C
04CC8:  CALL    4454
04CCC:  MOV.B   W0L,1025
....................  
....................                             if (filePtr->attributes & ATTR_DIRECTORY) 
04CCE:  MOV     #2C,W0
04CD0:  ADD     1020,W0
04CD2:  MOV     [W0],W5
04CD4:  AND     W5,#10,W0
04CD6:  CP0     W0
04CD8:  BRA     Z,4CE2
....................                             { 
....................                                 FSerrno = CE_INVALID_ARGUMENT; 
04CDA:  MOV.B   #1F,W0L
04CDC:  MOV.B   W0L,8B1
....................                                 final = 0xFF; 
04CDE:  MOV.B   #FF,W0L
04CE0:  MOV.B   W0L,1025
....................                             } 
....................  
....................                             if (final == CE_GOOD) 
04CE2:  CP0.B   1025
04CE4:  BRA     NZ,4D14
....................                             { 
....................                                 final = FSfseek (filePtr, 0, SEEK_END); 
04CE6:  PUSH    1020
04CE8:  POP     102C
04CEA:  CLR     102E
04CEC:  CLR     1030
04CEE:  MOV     #2,W4
04CF0:  MOV     W4,1032
04CF2:  CALL    4760
04CF6:  MOV.B   W0L,1025
....................                                 if (final != CE_GOOD) 
04CF8:  CP0.B   1025
04CFA:  BRA     Z,4D00
....................                                     FSerrno = CE_SEEK_ERROR; 
04CFC:  MOV.B   #1A,W0L
04CFE:  MOV.B   W0L,8B1
....................                                 if (mode[1] == '+') 
04D00:  MOV     #1,W0
04D02:  ADD     101E,W0
04D04:  MOV.B   [W0],W4L
04D06:  XOR.B   #2B,W4L
04D08:  BRA     NZ,4D14
....................                                     filePtr->flags.read = 1; 
04D0A:  MOV     #16,W0
04D0C:  ADD     1020,W0
04D0E:  MOV     W0,W5
04D10:  MOV     #2,W4
04D12:  IOR.B    W4L,  [W5],[W5]
....................                             } 
....................                         } 
....................                     } 
....................                 } 
....................                 break; 
04D14:  GOTO    4D62
....................             } 
.................... #endif 
....................             case 'R': 
....................             case 'r': 
....................             { 
....................                 fHandle = filePtr->entry; 
04D18:  MOV     #28,W0
04D1A:  ADD     1020,W0
04D1C:  MOV     [W0],[W15++]
04D1E:  POP     1026
....................  
....................                 final = FILEopen (filePtr, &fHandle, 'r'); 
04D20:  MOV.B   #72,W0L
04D22:  MOV.B   W0L,105E
04D24:  PUSH    1020
04D26:  POP     105A
04D28:  MOV     #1026,W4
04D2A:  MOV     W4,105C
04D2C:  CALL    4454
04D30:  MOV.B   W0L,1025
.................... #ifdef ALLOW_WRITES 
....................                 if ((mode[1] == '+') && !(filePtr->attributes & ATTR_DIRECTORY)) 
04D32:  MOV     #1,W0
04D34:  ADD     101E,W0
04D36:  MOV.B   [W0],W4L
04D38:  XOR.B   #2B,W4L
04D3A:  BRA     NZ,4D52
04D3C:  MOV     #2C,W0
04D3E:  ADD     1020,W0
04D40:  MOV     [W0],W5
04D42:  AND     W5,#10,W0
04D44:  CP0     W0
04D46:  BRA     NZ,4D52
....................                     filePtr->flags.write = 1; 
04D48:  MOV     #16,W0
04D4A:  ADD     1020,W0
04D4C:  MOV     W0,W5
04D4E:  MOV     #1,W4
04D50:  IOR.B    W4L,  [W5],[W5]
.................... #endif 
....................                 break; 
04D52:  GOTO    4D62
....................             } 
....................  
....................             default: 
....................                 FSerrno = CE_INVALID_ARGUMENT; 
04D56:  MOV.B   #1F,W0L
04D58:  MOV.B   W0L,8B1
....................                 final = 0xFF;;  //indicate error condition 
04D5A:  MOV.B   #FF,W0L
04D5C:  MOV.B   W0L,1025
....................                 break; 
04D5E:  GOTO    4D62
....................         } 
....................     } 
04D62:  GOTO    4E08
....................     else 
....................     { 
.................... #ifdef ALLOW_WRITES 
....................         // the file was not found, reset to the default asked 
....................         FileObjectCopy(filePtr, &gFileTemp); 
04D66:  PUSH    1020
04D68:  POP     105C
04D6A:  MOV     #8F2,W4
04D6C:  MOV     W4,105E
04D6E:  CALL    28E2
....................  
....................         // File is not Found 
....................         if((ModeC == 'w') || (ModeC == 'W') || (ModeC == 'a') || (ModeC == 'A')) 
04D72:  MOV     1024,W4
04D74:  XOR.B   #77,W4L
04D76:  BRA     Z,4D8A
04D78:  MOV     1024,W4
04D7A:  XOR.B   #57,W4L
04D7C:  BRA     Z,4D8A
04D7E:  MOV     1024,W4
04D80:  XOR.B   #61,W4L
04D82:  BRA     Z,4D8A
04D84:  MOV     1024,W4
04D86:  XOR.B   #41,W4L
04D88:  BRA     NZ,4E00
....................         { 
....................             // use the user requested name 
....................             fHandle = 0; 
04D8A:  CLR     1026
....................             final = CreateFileEntry (filePtr, &fHandle, 0, TRUE); 
04D8C:  CLR.B   1030
04D8E:  MOV.B   #1,W0L
04D90:  MOV.B   W0L,1031
04D92:  PUSH    1020
04D94:  POP     102C
04D96:  MOV     #1026,W4
04D98:  MOV     W4,102E
04D9A:  CALL    43FA
04D9E:  MOV.B   W0L,1025
....................  
....................             if (final == CE_GOOD) 
04DA0:  CP0.B   1025
04DA2:  BRA     NZ,4DFC
....................             { 
....................                 final = FILEopen (filePtr, &fHandle, 'w'); 
04DA4:  MOV.B   #77,W0L
04DA6:  MOV.B   W0L,105E
04DA8:  PUSH    1020
04DAA:  POP     105A
04DAC:  MOV     #1026,W4
04DAE:  MOV     W4,105C
04DB0:  CALL    4454
04DB4:  MOV.B   W0L,1025
....................                 if (filePtr->attributes & ATTR_DIRECTORY) 
04DB6:  MOV     #2C,W0
04DB8:  ADD     1020,W0
04DBA:  MOV     [W0],W5
04DBC:  AND     W5,#10,W0
04DBE:  CP0     W0
04DC0:  BRA     Z,4DCA
....................                 { 
....................                     FSerrno = CE_INVALID_ARGUMENT; 
04DC2:  MOV.B   #1F,W0L
04DC4:  MOV.B   W0L,8B1
....................                     final = 0xFF; 
04DC6:  MOV.B   #FF,W0L
04DC8:  MOV.B   W0L,1025
....................                 } 
....................  
....................                 if (final == CE_GOOD) 
04DCA:  CP0.B   1025
04DCC:  BRA     NZ,4DFC
....................                 { 
....................                     final = FSfseek (filePtr, 0, SEEK_END); 
04DCE:  PUSH    1020
04DD0:  POP     102C
04DD2:  CLR     102E
04DD4:  CLR     1030
04DD6:  MOV     #2,W4
04DD8:  MOV     W4,1032
04DDA:  CALL    4760
04DDE:  MOV.B   W0L,1025
....................                     if (final != CE_GOOD) 
04DE0:  CP0.B   1025
04DE2:  BRA     Z,4DE8
....................                         FSerrno = CE_SEEK_ERROR; 
04DE4:  MOV.B   #1A,W0L
04DE6:  MOV.B   W0L,8B1
....................                     if (mode[1] == '+') 
04DE8:  MOV     #1,W0
04DEA:  ADD     101E,W0
04DEC:  MOV.B   [W0],W4L
04DEE:  XOR.B   #2B,W4L
04DF0:  BRA     NZ,4DFC
....................                         filePtr->flags.read = 1; 
04DF2:  MOV     #16,W0
04DF4:  ADD     1020,W0
04DF6:  MOV     W0,W5
04DF8:  MOV     #2,W4
04DFA:  IOR.B    W4L,  [W5],[W5]
....................                 } 
....................             } 
....................         } 
04DFC:  GOTO    4E08
....................         else 
.................... #endif 
....................       { 
....................             final = CE_FILE_NOT_FOUND; 
04E00:  MOV.B   #B,W0L
04E02:  MOV.B   W0L,1025
....................            FSerrno = CE_FILE_NOT_FOUND; 
04E04:  MOV.B   #B,W0L
04E06:  MOV.B   W0L,8B1
....................        } 
....................     } 
....................  
....................     if (MDD_WriteProtectState()) 
04E08:  CALL    25A0
04E0C:  CP0.B   W0L
04E0E:  BRA     Z,4E1A
....................     { 
....................         filePtr->flags.write = 0;; 
04E10:  MOV     #16,W0
04E12:  ADD     1020,W0
04E14:  MOV     W0,W5
04E16:  MOV     #FE,W4
04E18:  AND.B   W4L,[W5],[W5]
....................     } 
....................  
.................... #ifdef FS_DYNAMIC_MEM 
....................     if( final != CE_GOOD ) 
....................     { 
....................         #ifdef   SUPPORT_LFN 
....................          FS_free((unsigned char *)filePtr->utf16LFNptr); 
....................       #endif 
....................       FS_free( (unsigned char *)filePtr ); 
....................         filePtr = NULL; 
....................     } 
.................... #else 
....................     if( final != CE_GOOD ) 
04E1A:  CP0.B   1025
04E1C:  BRA     Z,4E2E
....................     { 
....................         gFileSlotOpen[fIndex] = TRUE;   //put this slot back to the pool 
04E1E:  MOV     #85B,W4
04E20:  MOV     1022,W3
04E22:  ADD     W3,W4,W5
04E24:  MOV.B   #1,W0L
04E26:  MOV.B   W0L,[W5]
....................         filePtr = NULL; 
04E28:  CLR     1020
....................     } 
.................... #endif 
04E2A:  GOTO    4E30
....................     else 
....................     { 
....................         FSerrno = CE_GOOD; 
04E2E:  CLR.B   8B1
....................     } 
....................  
....................     return filePtr; 
04E30:  PUSH    1020
04E32:  POP     0
04E34:  MOV     [--W15],W7
04E36:  MOV     [--W15],W6
04E38:  MOV     [--W15],W5
04E3A:  RETURN  
.................... } 
....................  
.................... /******************************************************************* 
....................   Function: 
....................     long FSftell (FSFILE * fo) 
....................   Summary: 
....................     Determine the current location in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return: Current location in the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     The FSftell function will return the current position in the 
....................     file pointed to by 'fo' by returning the 'seek' variable in the 
....................     FSFILE object, which is used to keep track of the absolute 
....................     location of the current position in the file. 
....................   Remarks: 
....................     None 
....................   *******************************************************************/ 
....................  
.................... long FSftell (FSFILE * fo) 
.................... { 
....................     FSerrno = CE_GOOD; 
....................     return (fo->seek); 
.................... } 
....................  
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     int FSremove (const char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed 
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................     The FSremove function will attempt to find the specified file with the FILEfind 
....................     function.  If the file is found, it will be erased using the FILEerase function. 
....................     The user can also provide ascii alias name of the ascii long file name as the 
....................     input to this function to get it erased from the memory. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int FSremove (const char * fileName) 
*
05CD6:  MOV     W5,[W15++]
05CD8:  MOV     #8BC,W4
05CDA:  MOV     W4,FD2
.................... { 
....................     FILEOBJ fo = &tempCWDobj; 
....................  
....................    #ifdef SUPPORT_LFN 
....................       FSFILE cwdTemp; 
....................       char tempArray[514]; 
....................       LFN_ENTRY *lfno; 
....................       WORD prevHandle; 
....................       unsigned short int i = 0; 
....................    #endif 
....................     FSerrno = CE_GOOD; 
05CDC:  CLR.B   8B1
....................  
....................     if (MDD_WriteProtectState()) 
05CDE:  CALL    25A0
05CE2:  CP0.B   W0L
05CE4:  BRA     Z,5CEE
....................     { 
....................         FSerrno = CE_WRITE_PROTECTED; 
05CE6:  MOV.B   #18,W0L
05CE8:  MOV.B   W0L,8B1
....................         return (-1); 
05CEA:  SETM    0
05CEC:  BRA     5DDC
....................     } 
....................  
....................     //Format the source string 
....................    #if defined(SUPPORT_LFN) 
....................       fo->utf16LFNptr = (unsigned short int *)&tempArray[0]; 
....................    #endif 
....................  
....................     if( !FormatFileName(fileName, fo, 0) ) 
05CEE:  CLR.B   105E
05CF0:  PUSH    FD0
05CF2:  POP     105A
05CF4:  PUSH    FD2
05CF6:  POP     105C
05CF8:  CALL    26EC
05CFC:  CP0.B   W0L
05CFE:  BRA     NZ,5D08
....................     { 
....................         FSerrno = CE_INVALID_FILENAME; 
05D00:  MOV.B   #12,W0L
05D02:  MOV.B   W0L,8B1
....................         return -1; 
05D04:  SETM    0
05D06:  BRA     5DDC
....................     } 
....................  
....................     fo->dsk = &gDiskData; 
05D08:  MOV     FD2,W4
05D0A:  ADD     W4,#0,W4
05D0C:  MOV     W4,W0
05D0E:  MOV     W0,W5
05D10:  MOV.B   #60,W0L
05D12:  MOV.B   W0L,[W5]
05D14:  MOV.B   #D,W0L
05D16:  MOV.B   W0L,[W5+#1]
....................     fo->cluster = 0; 
05D18:  MOV     #2,W0
05D1A:  ADD     FD2,W0
05D1C:  MOV     W0,W5
05D1E:  CLR.B   [W5]
05D20:  MOV.B   #0,W0L
05D22:  MOV.B   W0L,[W5+#1]
05D24:  MOV.B   #0,W0L
05D26:  MOV.B   W0L,[W5+#2]
05D28:  MOV.B   #0,W0L
05D2A:  MOV.B   W0L,[W5+#3]
....................     fo->ccls    = 0; 
05D2C:  MOV     #6,W0
05D2E:  ADD     FD2,W0
05D30:  MOV     W0,W5
05D32:  CLR.B   [W5]
05D34:  MOV.B   #0,W0L
05D36:  MOV.B   W0L,[W5+#1]
05D38:  MOV.B   #0,W0L
05D3A:  MOV.B   W0L,[W5+#2]
05D3C:  MOV.B   #0,W0L
05D3E:  MOV.B   W0L,[W5+#3]
....................     fo->entry = 0; 
05D40:  MOV     #28,W0
05D42:  ADD     FD2,W0
05D44:  MOV     W0,W5
05D46:  CLR.B   [W5]
05D48:  MOV.B   #0,W0L
05D4A:  MOV.B   W0L,[W5+#1]
....................     fo->attributes = ATTR_ARCHIVE; 
05D4C:  MOV     #2C,W0
05D4E:  ADD     FD2,W0
05D50:  MOV     W0,W5
05D52:  MOV.B   #20,W0L
05D54:  MOV.B   W0L,[W5]
05D56:  MOV.B   #0,W0L
05D58:  MOV.B   W0L,[W5+#1]
....................  
.................... #ifndef ALLOW_DIRS 
....................     // start at the root directory 
....................     fo->dirclus    = FatRootDirClusterValue; 
....................     fo->dirccls    = FatRootDirClusterValue; 
.................... #else 
....................     fo->dirclus = cwdptr->dirclus; 
05D5A:  MOV     #2E,W0
05D5C:  ADD     FD2,W0
05D5E:  MOV     W0,W5
05D60:  MOV     #2E,W0
05D62:  ADD     95E,W0
05D64:  MOV     [W0++],[W5++]
05D66:  MOV     [W0++],[W5++]
....................     fo->dirccls = cwdptr->dirccls; 
05D68:  MOV     #32,W0
05D6A:  ADD     FD2,W0
05D6C:  MOV     W0,W5
05D6E:  MOV     #32,W0
05D70:  ADD     95E,W0
05D72:  MOV     [W0++],[W5++]
05D74:  MOV     [W0++],[W5++]
.................... #endif 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&gFileTemp, fo); 
05D76:  MOV     #8F2,W4
05D78:  MOV     W4,105C
05D7A:  PUSH    FD2
05D7C:  POP     105E
05D7E:  CALL    28E2
....................  
....................     // See if the file is found 
....................     if (FILEfind (fo, &gFileTemp, LOOK_FOR_MATCHING_ENTRY, 0) != CE_GOOD) 
05D82:  MOV.B   #1,W0L
05D84:  MOV.B   W0L,1060
05D86:  CLR.B   1061
05D88:  PUSH    FD2
05D8A:  POP     105C
05D8C:  MOV     #8F2,W4
05D8E:  MOV     W4,105E
05D90:  CALL    36BE
05D94:  CP0.B   W0L
05D96:  BRA     Z,5DA0
....................     { 
....................         FSerrno = CE_FILE_NOT_FOUND; 
05D98:  MOV.B   #B,W0L
05D9A:  MOV.B   W0L,8B1
....................         return -1; 
05D9C:  SETM    0
05D9E:  BRA     5DDC
....................     } 
....................  
....................     if (fo->attributes & ATTR_DIRECTORY) 
05DA0:  MOV     #2C,W0
05DA2:  ADD     FD2,W0
05DA4:  MOV     [W0],W5
05DA6:  AND     W5,#10,W0
05DA8:  CP0     W0
05DAA:  BRA     Z,5DB4
....................     { 
....................         FSerrno = CE_DELETE_DIR; 
05DAC:  MOV.B   #13,W0L
05DAE:  MOV.B   W0L,8B1
....................         return -1; 
05DB0:  SETM    0
05DB2:  BRA     5DDC
....................     } 
....................  
....................    // Find the long file name assosciated with the short file name if present 
....................    #ifdef SUPPORT_LFN 
....................    if(!fo->utf16LFNlength) 
....................    { 
....................       FileObjectCopy (&cwdTemp, fo); 
....................       prevHandle = fo->entry - 1; 
....................  
....................       lfno = (LFN_ENTRY *)Cache_File_Entry (fo, &prevHandle, FALSE); 
....................  
....................  
....................          while((lfno->LFN_Attribute == ATTR_LONG_NAME) && (lfno->LFN_SequenceNo != DIR_DEL) 
....................  
....................                && (lfno->LFN_SequenceNo != DIR_EMPTY)) 
....................  
....................          { 
....................  
....................  
....................          i = i + MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................             prevHandle = prevHandle - 1; 
....................  
....................             lfno = (LFN_ENTRY *)Cache_File_Entry (fo, &prevHandle, FALSE); 
....................  
....................          } 
....................  
....................  
....................  
....................          FileObjectCopy (fo, &cwdTemp); 
....................  
....................       // Find the length of LFN file 
....................       fo->utf16LFNlength = i; 
....................  
....................    } 
....................    #endif 
....................  
....................    // Erase the file 
....................     if( FILEerase(fo, &fo->entry, TRUE) == CE_GOOD ) 
05DB4:  MOV     #28,W0
05DB6:  ADD     FD2,W0
05DB8:  MOV     W0,W5
05DBA:  MOV.B   #1,W0L
05DBC:  MOV.B   W0L,104E
05DBE:  PUSH    FD2
05DC0:  POP     104A
05DC2:  MOV     W5,104C
05DC4:  CALL    3BA8
05DC8:  CP0.B   W0L
05DCA:  BRA     NZ,5DD4
....................         return 0; 
05DCC:  CLR     0
05DCE:  BRA     5DDC
05DD0:  GOTO    5DDC
....................     else 
....................     { 
....................         FSerrno = CE_ERASE_FAIL; 
05DD4:  MOV.B   #1,W0L
05DD6:  MOV.B   W0L,8B1
....................         return -1; 
05DD8:  SETM    0
05DDA:  BRA     5DDC
....................     } 
05DDC:  MOV     [--W15],W5
05DDE:  RETURN  
.................... } 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     int wFSremove (const unsigned short int * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed 
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................     The wFSremove function will attempt to find the specified UTF16 file 
....................     name with the FILEfind function. If the file is found, it will be erased 
....................     using the FILEerase function. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSremove (const unsigned short int * fileName) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................    result = FSremove ((const char *)fileName); 
....................    utfModeFileName = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /********************************************************* 
....................   Function: 
....................     void FSrewind (FSFILE * fo) 
....................   Summary: 
....................     Set the current position in a file to the beginning 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The FSrewind funciton will reset the position of the 
....................     specified file to the beginning of the file.  This 
....................     functionality is faster than using FSfseek to reset 
....................     the position in the file. 
....................   Remarks: 
....................     None. 
....................   *********************************************************/ 
....................  
.................... void FSrewind (FSFILE * fo) 
.................... { 
.................... #ifdef ALLOW_WRITES 
....................     if (gNeedDataWrite) 
....................         flushData(); 
.................... #endif 
....................     fo->seek = 0; 
....................     fo->pos = 0; 
....................     fo->sec = 0; 
....................     fo->ccls = fo->cluster; 
....................     gBufferOwner = NULL; 
....................     return; 
.................... } 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSerror (void) 
....................   Summary: 
....................     Return an error code for the last function call 
....................   Conditions: 
....................     The return value depends on the last function called. 
....................   Input: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Return Values: 
....................     FSInit       - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INIT_ERROR             The physical media could not be initialized 
....................                  - CE_BAD_SECTOR_READ        The MBR or the boot sector could not be 
....................                                               read correctly 
....................                  - CE_BAD_PARITION           The MBR signature code was incorrect. 
....................                  - CE_NOT_FORMATTED          The boot sector signature code was incorrect or 
....................                                               indicates an invalid number of bytes per sector. 
....................                  - CE_UNSUPPORTED_SECTOR_SIZE - The number of bytes per sector is unsupported 
....................                  - CE_CARDFAT32              The physical media is FAT32 type (only an error 
....................                                               when FAT32 support is disabled). 
....................                  - CE_UNSUPPORTED_FS         The device is formatted with an unsupported file 
....................                                               system (not FAT12 or 16). 
....................     FSfopen      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_NOT_INIT               The device has not been initialized. 
....................                  - CE_TOO_MANY_FILES_OPEN    The function could not allocate any 
....................                                               additional file information to the array 
....................                                               of FSFILE structures or the heap. 
....................                  - CE_INVALID_FILENAME       The file name argument was invalid. 
....................                  - CE_INVALID_ARGUMENT       The user attempted to open a directory in a 
....................                                               write mode or specified an invalid mode argument. 
....................                  - CE_FILE_NOT_FOUND         The specified file (which was to be opened in read 
....................                                               mode) does not exist on the device. 
....................                  - CE_BADCACHEREAD           A read from the device failed. 
....................                  - CE_ERASE_FAIL             The existing file could not be erased (when opening 
....................                                               a file in FS_WRITE mode). 
....................                  - CE_DIR_FULL               The directory is full. 
....................                  - CE_DISK_FULL              The data memory section is full. 
....................                  - CE_WRITE_ERROR            A write to the device failed. 
....................                  - CE_SEEK_ERROR             The current position in the file could not be set to 
....................                                               the end (when the file was opened in FS_APPEND mode). 
....................     FSfclose     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer or the new file 
....................                                               entry information could not be written to the device. 
....................                  - CE_BADCACHEREAD           The file entry information could not be cached 
....................     FSfread      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITEONLY              The file was opened in a write-only mode. 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device. 
....................                  - CE_BAD_SECTOR_READ        The data sector could not be read. 
....................                  - CE_EOF                    The end of the file was reached. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be loaded. 
....................     FSfwrite     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_READONLY               The file was opened in a read-only mode. 
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated 
....................                                               that the device has been write-protected. 
....................                  - CE_WRITE_ERROR            There was an error writing data to the device. 
....................                  - CE_BADCACHEREAD           The data sector to be modified could not be read from 
....................                                               the device. 
....................                  - CE_DISK_FULL              All data clusters on the device are in use. 
....................     FSfseek      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device. 
....................                  - CE_INVALID_ARGUMENT       The specified offset exceeds the size of the file. 
....................                  - CE_BADCACHEREAD           The sector that contains the new current position 
....................                                               could not be loaded. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be 
....................                                               loaded/allocated. 
....................     FSftell      - 
....................                  - CE_GOOD                   No Error 
....................     FSattrib     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INVALID_ARGUMENT       The attribute argument was invalid. 
....................                  - CE_BADCACHEREAD           The existing file entry information could not be 
....................                                               loaded. 
....................                  - CE_WRITE_ERROR            The file entry information could not be written to 
....................                                               the device. 
....................     FSrename     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_FILENOTOPENED          A null file pointer was passed into the function. 
....................                  - CE_INVALID_FILENAME       The file name passed into the function was invalid. 
....................                  - CE_BADCACHEREAD           A read from the device failed. 
....................                  - CE_FILENAME_EXISTS        A file with the specified name already exists. 
....................                  - CE_WRITE_ERROR            The new file entry data could not be written to the 
....................                                               device. 
....................     FSfeof       - 
....................                  - CE_GOOD                   No Error 
....................     FSformat     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INIT_ERROR             The device could not be initialized. 
....................                  - CE_BADCACHEREAD           The master boot record or boot sector could not be 
....................                                               loaded successfully. 
....................                  - CE_INVALID_ARGUMENT       The user selected to create their own boot sector on 
....................                                               a device that has no master boot record, or the mode 
....................                                               argument was invalid. 
....................                  - CE_WRITE_ERROR            The updated MBR/Boot sector could not be written to 
....................                                               the device. 
....................                  - CE_BAD_PARTITION          The calculated number of sectors per clusters was 
....................                                               invalid. 
....................                  - CE_NONSUPPORTED_SIZE      The card has too many sectors to be formatted as 
....................                                               FAT12 or FAT16. 
....................     FSremove     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated 
....................                                               that the device has been write-protected. 
....................                  - CE_INVALID_FILENAME       The specified filename was invalid. 
....................                  - CE_FILE_NOT_FOUND         The specified file could not be found. 
....................                  - CE_ERASE_FAIL             The file could not be erased. 
....................     FSchdir      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed or the user tried to 
....................                                               change to a non-directory file. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_FOUND          Could not find a directory in the path. 
....................     FSgetcwd     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INVALID_ARGUMENT       The user passed a 0-length buffer into the function. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory 
....................                                               of the current working directory. 
....................     FSmkdir      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated 
....................                                               that the device has been write-protected. 
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed. 
....................                  - CE_BADCACHEREAD           Could not successfully change to a recently created 
....................                                               directory to store its dir entry information, or 
....................                                               could not cache directory entry information. 
....................                  - CE_INVALID_FILENAME       One or more of the directory names has an invalid 
....................                                               format. 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device or the dot/dotdot entries could 
....................                                               not be written to a newly created directory. 
....................                  - CE_DIR_FULL               There are no available dir entries in the CWD. 
....................                  - CE_DISK_FULL              There are no available clusters in the data region of 
....................                                               the device. 
....................     FSrmdir      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_DIR_NOT_FOUND          The directory specified could not be found or the 
....................                                               function could not change to a subdirectory within 
....................                                               the directory to be deleted (when recursive delete is 
....................                                               enabled). 
....................                  - CE_INVALID_ARGUMENT       The user tried to remove the CWD or root directory. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_EMPTY          The directory to be deleted was not empty and 
....................                                               recursive subdirectory removal was disabled. 
....................                  - CE_ERASE_FAIL             The directory or one of the directories or files 
....................                                               within it could not be deleted. 
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory 
....................                                               of the CWD. 
....................     SetClockVars - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INVALID_ARGUMENT       The time values passed into the function were 
....................                                               invalid. 
....................     FindFirst    - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INVALID_FILENAME       The specified filename was invalid. 
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found. 
....................                  - CE_BADCACHEREAD           The file information for the file that was found 
....................                                               could not be cached. 
....................     FindNext     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_NOT_INIT               The SearchRec object was not initialized by a call to 
....................                                               FindFirst. 
....................                  - CE_INVALID_ARGUMENT       The SearchRec object was initialized in a different 
....................                                               directory from the CWD. 
....................                  - CE_INVALID_FILENAME       The filename is invalid. 
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found. 
....................     FSfprintf    - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITE_ERROR            Characters could not be written to the file. 
....................   Description: 
....................     The FSerror function will return the FSerrno variable.  This global 
....................     variable will have been set to an error value during the last call of a 
....................     library function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... int FSerror (void) 
.................... { 
....................     return FSerrno; 
.................... } 
....................  
....................  
.................... /************************************************************** 
....................   Function: 
....................     void FileObjectCopy(FILEOBJ foDest,FILEOBJ foSource) 
....................   Summary: 
....................     Copy a file object 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     foDest -    The destination 
....................     foSource -  the source 
....................   Return: 
....................     None 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The FileObjectCopy function will make an exacy copy of 
....................     a specified FSFILE object. 
....................   Remarks: 
....................     None 
....................   **************************************************************/ 
....................  
.................... void FileObjectCopy(FILEOBJ foDest,FILEOBJ foSource) 
*
028E2:  MOV     W5,[W15++]
.................... { 
....................     int size; 
028E4:  CLR     1060
....................     BYTE *dest; 
028E6:  CLR     1062
....................     BYTE *source; 
028E8:  CLR     1064
....................     int Index; 
028EA:  CLR     1066
....................  
....................     dest = (BYTE *)foDest; 
028EC:  PUSH    105C
028EE:  POP     1062
....................     source = (BYTE *)foSource; 
028F0:  PUSH    105E
028F2:  POP     1064
....................  
....................     size = sizeof(FSFILE); 
028F4:  MOV     #36,W4
028F6:  MOV     W4,1060
....................  
....................     for(Index=0;Index< size; Index++) 
028F8:  CLR     1066
028FA:  MOV     1066,W0
028FC:  MOV     1060,W4
028FE:  CP      W4,W0
02900:  BRA     LE,2914
....................     { 
....................         dest[Index] = source[Index]; 
02902:  MOV     1066,W0
02904:  ADD     1062,W0
02906:  MOV     W0,W5
02908:  MOV     1066,W0
0290A:  ADD     1064,W0
0290C:  MOV.B   [W0],[W5]
0290E:  INC     1066
02910:  GOTO    28FA
....................     } 
02914:  MOV     [--W15],W5
02916:  RETURN  
.................... } 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     CETYPE FILECreateHeadCluster( FILEOBJ fo, DWORD *cluster) 
....................   Summary: 
....................     Create the first cluster of a file 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................     cluster -  Cluster location 
....................   Return Values: 
....................     CE_GOOD - File closed successfully 
....................     CE_WRITE_ERROR - Could not write to the sector 
....................     CE_DISK_FULL - All clusters in partition are taken 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The FILECreateHeadCluster function will create the first cluster 
....................     of a file.  First, it will find an empty cluster with the 
....................     FATfindEmptyCluster function and mark it as the last cluster in the 
....................     file.  It will then erase the cluster using the EraseCluster function. 
....................   Remarks: 
....................     None. 
....................   *************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... CETYPE FILECreateHeadCluster( FILEOBJ fo, DWORD *cluster) 
*
0421E:  MOV     W5,[W15++]
04220:  MOV     W6,[W15++]
*
04224:  CLR.B   1050
.................... { 
....................     DISK *      disk; 
*
04222:  CLR     104E
....................     CETYPE        error = CE_GOOD; 
....................  
....................     disk = fo->dsk; 
*
04226:  MOV     104A,W4
04228:  ADD     W4,#0,W4
0422A:  MOV     W4,W0
0422C:  MOV     [W0],[W15++]
0422E:  POP     104E
....................  
....................     // find the next empty cluster 
....................     *cluster = FATfindEmptyCluster(fo); 
04230:  MOV     104C,W5
04232:  PUSH    104A
04234:  POP     105E
04236:  CALL    3CAE
0423A:  MOV     #0,W4
0423C:  MOV     [W4++],[W5++]
0423E:  MOV     [W4++],[W5++]
....................  
....................     if(*cluster == 0)  // "0" is just an indication as Disk full in the fn "FATfindEmptyCluster()" 
04240:  MOV     104C,W0
04242:  MOV     #A,W4
04244:  MOV     [W0++],[W4++]
04246:  MOV     [W0++],[W4++]
04248:  CP0     W5
0424A:  BRA     NZ,4258
0424C:  CP0     W6
0424E:  BRA     NZ,4258
....................     { 
....................         error = CE_DISK_FULL; 
04250:  MOV.B   #15,W0L
04252:  MOV.B   W0L,1050
....................     } 
04254:  GOTO    42E6
....................     else 
....................     { 
....................         // mark the cluster as taken, and last in chain 
....................        #ifdef SUPPORT_FAT12 
....................         if(disk->type == FAT12) 
....................         { 
....................             if(WriteFAT( disk, *cluster, LAST_CLUSTER_FAT12, FALSE) == CLUSTER_FAIL_FAT16) 
....................             { 
....................                 error = CE_WRITE_ERROR; 
....................             } 
....................         } 
....................         else 
....................        #endif 
....................         if(disk->type == FAT16) 
04258:  MOV     #22,W4
0425A:  MOV     104E,W3
0425C:  ADD     W3,W4,W0
0425E:  MOV     #A,W1
04260:  MOV     W0,W2
04262:  MOV.B   [W2++],[W1++]
04264:  CP.B    W5L,#2
04266:  BRA     NZ,429A
....................         { 
....................             if(WriteFAT( disk, *cluster, LAST_CLUSTER_FAT16, FALSE) == CLUSTER_FAIL_FAT16) 
04268:  MOV     104C,W0
0426A:  MOV     #A,W4
0426C:  MOV     [W0++],[W4++]
0426E:  MOV     [W0++],[W4++]
04270:  CLR.B   10D2
04272:  PUSH    104E
04274:  POP     10C8
04276:  MOV     W5,10CA
04278:  MOV     W6,10CC
0427A:  MOV     #FFF8,W4
0427C:  MOV     W4,10CE
0427E:  CLR     10D0
04280:  CALL    2C18
04284:  MOV     W0,W5
04286:  MOV     W1,W6
04288:  MOV     #FFFF,W4
0428A:  CP      W4,W5
0428C:  BRA     NZ,4296
0428E:  CP0     W6
04290:  BRA     NZ,4296
....................             { 
....................                 error = CE_WRITE_ERROR; 
04292:  MOV.B   #9,W0L
04294:  MOV.B   W0L,1050
....................             } 
....................         } 
....................  
....................  #ifdef SUPPORT_FAT32 // If FAT32 supported. 
04296:  GOTO    42CC
....................         else 
....................         { 
....................             if(WriteFAT( disk, *cluster, LAST_CLUSTER_FAT32, FALSE) == CLUSTER_FAIL_FAT32) 
0429A:  MOV     104C,W0
0429C:  MOV     #A,W4
0429E:  MOV     [W0++],[W4++]
042A0:  MOV     [W0++],[W4++]
042A2:  CLR.B   10D2
042A4:  PUSH    104E
042A6:  POP     10C8
042A8:  MOV     W5,10CA
042AA:  MOV     W6,10CC
042AC:  MOV     #FFF8,W4
042AE:  MOV     W4,10CE
042B0:  MOV     #FFF,W4
042B2:  MOV     W4,10D0
042B4:  CALL    2C18
042B8:  MOV     W0,W5
042BA:  MOV     W1,W6
042BC:  MOV     #FFFF,W4
042BE:  CP      W4,W5
042C0:  BRA     NZ,42CC
042C2:  MOV     #FFF,W4
042C4:  CP      W4,W6
042C6:  BRA     NZ,42CC
....................             { 
....................                 error = CE_WRITE_ERROR; 
042C8:  MOV.B   #9,W0L
042CA:  MOV.B   W0L,1050
....................             } 
....................         } 
.................... #endif 
....................  
....................         // lets erase this cluster 
....................         if(error == CE_GOOD) 
042CC:  CP0.B   1050
042CE:  BRA     NZ,42E6
....................         { 
....................             error = EraseCluster(disk,*cluster); 
042D0:  MOV     104C,W0
042D2:  MOV     #A,W4
042D4:  MOV     [W0++],[W4++]
042D6:  MOV     [W0++],[W4++]
042D8:  PUSH    104E
042DA:  POP     105E
042DC:  MOV     W5,1060
042DE:  MOV     W6,1062
042E0:  CALL    3DDC
042E4:  MOV.B   W0L,1050
....................         } 
....................     } 
....................  
....................     return(error); 
042E6:  MOV.B   1050,W0L
042E8:  MOV.B   W0L,0
042EA:  MOV     [--W15],W6
042EC:  MOV     [--W15],W5
042EE:  RETURN  
.................... } // allocate head cluster 
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE EraseCluster(DISK *disk, DWORD cluster) 
....................   Summary: 
....................     Erase a cluster 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -      Disk structure 
....................     cluster -  Cluster to be erased 
....................   Return Values: 
....................     CE_GOOD - File closed successfully 
....................     CE_WRITE_ERROR - Could not write to the sector 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The EraseCluster function will write a 0 value into every byte of 
....................     the specified cluster. 
....................   Remarks: 
....................     None. 
....................   *************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE EraseCluster(DISK *disk, DWORD cluster) 
*
03DDC:  MOV     W5,[W15++]
03DDE:  MOV     W6,[W15++]
03DE0:  MOV     W7,[W15++]
*
03DE8:  CLR.B   1065
.................... { 
....................     BYTE index; 
*
03DE2:  CLR.B   1064
....................     DWORD SectorAddress; 
03DE4:  CLR     1066
03DE6:  CLR     1068
....................     BYTE error = CE_GOOD; 
....................  
....................     SectorAddress = Cluster2Sector(disk,cluster); 
*
03DEA:  PUSH    105E
03DEC:  POP     10B0
03DEE:  PUSH    1060
03DF0:  POP     10B2
03DF2:  PUSH    1062
03DF4:  POP     10B4
03DF6:  CALL    308C
03DFA:  MOV     W0,1066
03DFC:  MOV     W1,1068
....................     if (gNeedDataWrite) 
03DFE:  CP0.B   8AE
03E00:  BRA     Z,3E10
....................         if (flushData()) 
03E02:  CALL    3170
03E06:  CP0.B   W0L
03E08:  BRA     Z,3E10
....................             return CE_WRITE_ERROR; 
03E0A:  MOV.B   #9,W0L
03E0C:  MOV.B   W0L,0
03E0E:  BRA     3E94
....................  
....................     gBufferOwner = NULL; 
03E10:  CLR     8A8
....................  
....................     if (gBufferZeroed == FALSE) 
03E12:  CP0.B   8B0
03E14:  BRA     NZ,3E44
....................     { 
....................         // clear out the memory first 
....................         memset(disk->buffer, 0x00, disk->sectorSize); 
03E16:  MOV     105E,W4
03E18:  ADD     W4,#0,W4
03E1A:  MOV     W4,W0
03E1C:  MOV     #A,W1
03E1E:  MOV     W0,W2
03E20:  REPEAT  #1
03E22:  MOV.B   [W2++],[W1++]
03E24:  MOV     105E,W4
03E26:  ADD     W4,#18,W4
03E28:  MOV     W4,W0
03E2A:  MOV     #C,W1
03E2C:  MOV     W0,W2
03E2E:  REPEAT  #3
03E30:  MOV.B   [W2++],[W1++]
03E32:  MOV     W5,W1
03E34:  MOV     #0,W2
03E36:  MOV     W6,W0
03E38:  DEC     W0,W0
03E3A:  BRA     N,3E3E
03E3C:  REPEAT  W0
03E3E:  CLR.B   [W1++]
....................         gBufferZeroed = TRUE; 
03E40:  MOV.B   #1,W0L
03E42:  MOV.B   W0L,8B0
....................     } 
....................  
....................     // Now clear them out 
....................     for(index = 0; (index < disk->SecPerClus) && (error == CE_GOOD); index++) 
03E44:  CLR.B   1064
03E46:  MOV     #21,W4
03E48:  MOV     105E,W3
03E4A:  ADD     W3,W4,W0
03E4C:  MOV     #A,W1
03E4E:  MOV     W0,W2
03E50:  MOV.B   [W2++],[W1++]
03E52:  MOV     1064,W4
03E54:  CP.B    W4L,W5L
03E56:  BRA     C,3E92
03E58:  CP0.B   1065
03E5A:  BRA     NZ,3E92
....................     { 
....................         if (MDD_SectorWrite( SectorAddress++, disk->buffer, FALSE) != TRUE) 
03E5C:  MOV     1068,W1
03E5E:  MOV     1066,W0
03E60:  INC     1066
03E62:  BTSC.B  42.1
03E64:  INC     1068
03E66:  MOV     W0,W5
03E68:  MOV     W1,W6
03E6A:  MOV     105E,W4
03E6C:  ADD     W4,#0,W4
03E6E:  MOV     W4,W0
03E70:  MOV     #E,W1
03E72:  MOV     W0,W2
03E74:  REPEAT  #1
03E76:  MOV.B   [W2++],[W1++]
03E78:  CLR.B   10F8
03E7A:  MOV     W5,10F2
03E7C:  MOV     W6,10F4
03E7E:  MOV     W7,10F6
03E80:  CALL    2BBE
03E84:  CP.B    W0L,#1
03E86:  BRA     Z,3E8C
....................             error = CE_WRITE_ERROR; 
03E88:  MOV.B   #9,W0L
03E8A:  MOV.B   W0L,1065
03E8C:  INC.B   1064
03E8E:  GOTO    3E46
....................     } 
....................  
....................     return(error); 
03E92:  MOV.B   1065,W0L
03E94:  MOV     [--W15],W7
03E96:  MOV     [--W15],W6
03E98:  MOV     [--W15],W5
03E9A:  RETURN  
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................  
.................... /*************************************************** 
....................   Function: 
....................     BYTE ReadByte(BYTE * pBuffer, WORD index) 
....................   Summary: 
....................     Read a byte from a buffer 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     pBuffer -  pointer to a buffer to read from 
....................     index -    index in the buffer to read to 
....................   Return: 
....................     BYTE - the byte read 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     Reads a byte from a buffer 
....................   Remarks: 
....................     None. 
....................   ***************************************************/ 
....................  
.................... BYTE ReadByte( BYTE* pBuffer, WORD index ) 
*
01776:  MOV     W5,[W15++]
.................... { 
....................     return( pBuffer[index] ); 
01778:  MOV     FF8,W0
0177A:  ADD     FF6,W0
0177C:  MOV     W0,W5
0177E:  MOV.B   [W5+#0],W0L
01780:  MOV.B   W0L,0
01782:  MOV     [--W15],W5
01784:  RETURN  
.................... } 
....................  
....................  
.................... /*************************************************** 
....................   Function: 
....................     BYTE ReadWord(BYTE * pBuffer, WORD index) 
....................   Summary: 
....................     Read a 16-bit word from a buffer 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     pBuffer -  pointer to a buffer to read from 
....................     index -    index in the buffer to read to 
....................   Return: 
....................     WORD - the word read 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     Reads a 16-bit word from a buffer 
....................   Remarks: 
....................     None. 
....................   ***************************************************/ 
....................  
.................... WORD ReadWord( BYTE* pBuffer, WORD index ) 
*
01A66:  MOV     W5,[W15++]
.................... { 
....................     BYTE loByte, hiByte; 
01A68:  CLR.B   100E
01A6A:  CLR.B   100F
....................     WORD res; 
01A6C:  CLR     1010
....................  
....................     loByte = pBuffer[index]; 
01A6E:  MOV     100C,W0
01A70:  ADD     100A,W0
01A72:  MOV     100E,W4
01A74:  MOV.B   [W0+#0],W4L
01A76:  MOV     W4,100E
....................     hiByte = pBuffer[index+1]; 
01A78:  MOV     100C,W4
01A7A:  ADD     W4,#1,W4
01A7C:  MOV     W4,W5
01A7E:  MOV     W5,W0
01A80:  ADD     100A,W0
01A82:  MOV     W0,[W15++]
01A84:  MOV.B   [W0],W0L
01A86:  MOV.B   W0L,100F
01A88:  MOV     [--W15],W0
....................     res = hiByte; 
01A8A:  MOV.B   100F,W0L
01A8C:  MOV.B   W0L,1010
01A8E:  CLR.B   1011
....................     res *= 0x100; 
01A90:  MOV.B   1010,W0L
01A92:  MOV.B   W0L,1011
01A94:  CLR.B   1010
....................     res |= loByte; 
01A96:  MOV.B   100E,W0L
01A98:  CLR.B   1
01A9A:  IOR     1010
....................     return( res ); 
01A9C:  PUSH    1010
01A9E:  POP     0
01AA0:  MOV     [--W15],W5
01AA2:  RETURN  
.................... } 
....................  
....................  
.................... /**************************************************** 
....................   Function: 
....................     BYTE ReadDWord(BYTE * pBuffer, WORD index) 
....................   Summary: 
....................     Read a 32-bit double word from a buffer 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     pBuffer -  pointer to a buffer to read from 
....................     index -    index in the buffer to read to 
....................   Return: 
....................     DWORD - the double word read 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     Reads a 32-bit double word from a buffer 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... DWORD ReadDWord( BYTE* pBuffer, WORD index ) 
01AA4:  MOV     W5,[W15++]
.................... { 
....................     WORD loWord, hiWord; 
01AA6:  CLR     FFA
01AA8:  CLR     FFC
....................     DWORD result; 
01AAA:  CLR     FFE
01AAC:  CLR     1000
....................  
....................     loWord = ReadWord( pBuffer, index ); 
01AAE:  PUSH    FF6
01AB0:  POP     100A
01AB2:  PUSH    FF8
01AB4:  POP     100C
01AB6:  CALL    1A66
01ABA:  MOV     W0,FFA
....................     hiWord = ReadWord( pBuffer, index+2 ); 
01ABC:  MOV     FF8,W4
01ABE:  ADD     W4,#2,W4
01AC0:  MOV     W4,W5
01AC2:  PUSH    FF6
01AC4:  POP     100A
01AC6:  MOV     W5,100C
01AC8:  CALL    1A66
01ACC:  MOV     W0,FFC
....................  
....................     result = hiWord; 
01ACE:  PUSH    FFC
01AD0:  POP     FFE
01AD2:  CLR     1000
....................     result *= 0x10000; 
01AD4:  PUSH    FFE
01AD6:  POP     1000
01AD8:  CLR     FFE
....................     result |= loWord; 
01ADA:  MOV     FFA,W0
01ADC:  IOR     FFE
....................     return result; 
01ADE:  MOV     FFE,W0
01AE0:  MOV     1000,W1
01AE2:  MOV     [--W15],W5
01AE4:  RETURN  
.................... } 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /**************************************************** 
....................   Function: 
....................     DWORD Cluster2Sector(DISK * dsk, DWORD cluster) 
....................   Summary: 
....................     Convert a cluster number to the corresponding sector 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     disk -     Disk structure 
....................     cluster -  Cluster to be converted 
....................   Return: 
....................     sector - Sector that corresponds to given cluster 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The Cluster2Sector function will calculate the 
....................     sector number that corresponds to the first sector 
....................     of the cluster whose value was passed into the 
....................     function. 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... DWORD Cluster2Sector(DISK * dsk, DWORD cluster) 
*
0308C:  MOV     W5,[W15++]
0308E:  MOV     #C,W5
03090:  REPEAT  #3
03092:  MOV     [W5++],[W15++]
.................... { 
....................     DWORD sector; 
03094:  CLR     10B6
03096:  CLR     10B8
....................  
....................     /* Rt: Settings based on FAT type */ 
....................     switch (dsk->type) 
03098:  MOV     #22,W4
0309A:  MOV     10B0,W3
0309C:  ADD     W3,W4,W0
0309E:  MOV     #A,W1
030A0:  MOV     W0,W2
030A2:  MOV.B   [W2++],[W1++]
030A4:  MOV.B   W5L,W0L
030A6:  CLR.B   1
030A8:  XOR     #3,W0
030AA:  BRA     Z,30B2
030AC:  XOR     #1,W0
030AE:  BRA     Z,30F2
030B0:  BRA     30F2
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             /* In FAT32, there is no separate ROOT region. It is as well stored in DATA region */ 
....................             sector = (((DWORD)cluster-2) * dsk->SecPerClus) + dsk->data; 
030B2:  MOV     10B2,W4
030B4:  SUB     W4,#2,W5
030B6:  MOV     10B4,W4
030B8:  SUBB    W4,#0,W6
030BA:  MOV     #21,W4
030BC:  MOV     10B0,W3
030BE:  ADD     W3,W4,W0
030C0:  MOV     #E,W1
030C2:  MOV     W0,W2
030C4:  MOV.B   [W2++],[W1++]
030C6:  MOV.B   W7L,W2L
030C8:  CLR.B   5
030CA:  MOV     #0,W3
030CC:  MOV     W5,W0
030CE:  MOV     W6,W1
030D0:  CALL    10CE
030D4:  MOV     W0,W5
030D6:  MOV     W1,W6
030D8:  MOV     10B0,W4
030DA:  ADD     W4,#E,W4
030DC:  MOV     W4,W0
030DE:  MOV     #10,W1
030E0:  MOV     W0,W2
030E2:  REPEAT  #3
030E4:  MOV.B   [W2++],[W1++]
030E6:  ADD     W8,W5,W0
030E8:  MOV     W0,10B6
030EA:  ADDC    W9,W6,W0
030EC:  MOV     W0,10B8
....................             break; 
030EE:  GOTO    3162
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             // The root dir takes up cluster 0 and 1 
....................             if((cluster == 0) || (cluster == 1)) 
030F2:  CP0     10B2
030F4:  BRA     NZ,30FA
030F6:  CP0     10B4
030F8:  BRA     Z,3104
030FA:  MOV     10B2,W4
030FC:  CP      W4,#1
030FE:  BRA     NZ,3122
03100:  CP0     10B4
03102:  BRA     NZ,3122
....................                 sector = dsk->root + cluster; 
03104:  MOV     10B0,W4
03106:  ADD     W4,#A,W4
03108:  MOV     W4,W0
0310A:  MOV     #A,W1
0310C:  MOV     W0,W2
0310E:  REPEAT  #3
03110:  MOV.B   [W2++],[W1++]
03112:  MOV     W5,W0
03114:  ADD     10B2,W0
03116:  MOV     W0,10B6
03118:  MOV     10B4,W4
0311A:  ADDC    W6,W4,W0
0311C:  MOV     W0,10B8
0311E:  GOTO    315E
....................             else 
....................                 sector = (((DWORD)cluster-2) * dsk->SecPerClus) + dsk->data; 
03122:  MOV     10B2,W4
03124:  SUB     W4,#2,W5
03126:  MOV     10B4,W4
03128:  SUBB    W4,#0,W6
0312A:  MOV     #21,W4
0312C:  MOV     10B0,W3
0312E:  ADD     W3,W4,W0
03130:  MOV     #E,W1
03132:  MOV     W0,W2
03134:  MOV.B   [W2++],[W1++]
03136:  MOV.B   W7L,W2L
03138:  CLR.B   5
0313A:  MOV     #0,W3
0313C:  MOV     W5,W0
0313E:  MOV     W6,W1
03140:  CALL    10CE
03144:  MOV     W0,W5
03146:  MOV     W1,W6
03148:  MOV     10B0,W4
0314A:  ADD     W4,#E,W4
0314C:  MOV     W4,W0
0314E:  MOV     #10,W1
03150:  MOV     W0,W2
03152:  REPEAT  #3
03154:  MOV.B   [W2++],[W1++]
03156:  ADD     W8,W5,W0
03158:  MOV     W0,10B6
0315A:  ADDC    W9,W6,W0
0315C:  MOV     W0,10B8
....................             break; 
0315E:  GOTO    3162
....................     } 
....................  
....................     return(sector); 
03162:  MOV     10B6,W0
03164:  MOV     10B8,W1
03166:  MOV     #12,W5
03168:  REPEAT  #3
0316A:  MOV     [--W15],[W5--]
0316C:  MOV     [--W15],W5
0316E:  RETURN  
....................  
.................... } 
....................  
....................  
.................... /*************************************************************************** 
....................   Function: 
....................     int FSattrib (FSFILE * file, unsigned char attributes) 
....................   Summary: 
....................     Change the attributes of a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     file -        Pointer to file structure 
....................     attributes -  The attributes to set for the file 
....................                -  Attribute -      Value - Indications 
....................                -  ATTR_READ_ONLY - 0x01  - The read-only attribute 
....................                -  ATTR_HIDDEN -    0x02  - The hidden attribute 
....................                -  ATTR_SYSTEM -    0x04  - The system attribute 
....................                -  ATTR_ARCHIVE -   0x20  - The archive attribute 
....................   Return Values: 
....................     0 -  Attribute change was successful 
....................     -1 - Attribute change was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSattrib funciton will set the attributes of the specified file 
....................     to the attributes passed in by the user.  This function will load the 
....................     file entry, replace the attributes with the ones specified, and write 
....................     the attributes back.  If the specified file is a directory, the 
....................     directory attribute will be preserved. 
....................   Remarks: 
....................     None 
....................   ***************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... int FSattrib (FSFILE * file, unsigned char attributes) 
.................... { 
....................     WORD fHandle; 
....................     DIRENTRY dir; 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................     // Check for valid attributes 
....................     if ((attributes & ~0x27) != 0) 
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
....................         return -1; 
....................     } 
....................  
....................     fHandle = file->entry; 
....................  
....................     file->dirccls = file->dirclus; 
....................  
....................     // Get the file entry 
....................     dir = LoadDirAttrib(file, &fHandle); 
....................  
....................     if (dir == NULL) 
....................     { 
....................         FSerrno = CE_BADCACHEREAD; 
....................         return -1; 
....................     } 
....................  
....................     // Ensure that we aren't trying to change the 
....................     // attributes of a volume entry 
....................     if (dir->DIR_Attr & ATTR_VOLUME) 
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
....................         return -1; 
....................     } 
....................  
....................     // Don't remove the directory attribute from DIR files 
....................     if (file->attributes & ATTR_DIRECTORY) 
....................         file->attributes = attributes | ATTR_DIRECTORY; 
....................     else 
....................         file->attributes = attributes; 
....................  
....................     // just write the last entry in 
....................     if(!Write_File_Entry(file,&fHandle)) 
....................     { 
....................         FSerrno = CE_WRITE_ERROR; 
....................         return -1; 
....................     } 
....................  
....................     return 0; 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Write data to a file 
....................   Conditions: 
....................     File opened in FS_WRITE, FS_APPEND, FS_WRITE+, FS_APPEND+, FS_READ+ mode 
....................   Input: 
....................     data_to_write -     Pointer to source buffer 
....................     size -              Size of units in bytes 
....................     n -                 Number of units to transfer 
....................     stream -  Pointer to file structure 
....................   Return: 
....................     size_t - number of units written 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfwrite function will write data to a file.  First, the sector that 
....................     corresponds to the current position in the file will be loaded (if it hasn't 
....................     already been cached in the global data buffer).  Data will then be written to 
....................     the device from the specified buffer until the specified amount has been written. 
....................     If the end of a cluster is reached, the next cluster will be loaded, unless 
....................     the end-of-file flag for the specified file has been set.  If it has, a new 
....................     cluster will be allocated to the file.  Finally, the new position and filesize 
....................     will be stored in the FSFILE object.  The parameters 'size' and 'n' indicate how 
....................     much data to write.  'Size' refers to the size of one object to write (in bytes), 
....................     and 'n' will refer to the number of these objects to write.  The value returned 
....................     will be equal  to 'n' unless an error occured. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream) 
*
04E70:  MOV     W5,[W15++]
04E72:  MOV     W6,[W15++]
04E74:  MOV     FE4,W4
04E76:  MOV     FE6,W3
04E78:  MUL.UU  W4,W3,W0
04E7A:  MOV     W0,FEA
04E7C:  CLR     FEC
04E7E:  PUSH    FE2
04E80:  POP     FEE
*
04E84:  CLR.B   FF2
*
04E94:  CLR     1002
.................... { 
....................     DWORD       count = size * n; 
....................     BYTE   *    src = (BYTE *) data_to_write; 
....................     DISK   *    dsk;                 // pointer to disk structure 
*
04E82:  CLR     FF0
....................     CETYPE      error = CE_GOOD; 
....................     WORD        pos; 
*
04E86:  CLR     FF4
....................     DWORD       l;                     // absolute lba of sector to load 
04E88:  CLR     FF6
04E8A:  CLR     FF8
....................     DWORD       seek, filesize; 
04E8C:  CLR     FFA
04E8E:  CLR     FFC
04E90:  CLR     FFE
04E92:  CLR     1000
....................     WORD        writeCount = 0; 
....................  
....................     // see if the file was opened in a write mode 
....................     if(!(stream->flags.write)) 
*
04E96:  MOV     #16,W0
04E98:  ADD     FE8,W0
04E9A:  MOV.B   [W0],W4L
04E9C:  BTSC    W4.0
04E9E:  BRA     4EAC
....................     { 
....................         FSerrno = CE_READONLY; 
04EA0:  MOV.B   #1D,W0L
04EA2:  MOV.B   W0L,8B1
....................         error = CE_WRITE_ERROR; 
04EA4:  MOV.B   #9,W0L
04EA6:  MOV.B   W0L,FF2
....................         return 0; 
04EA8:  CLR     0
04EAA:  BRA     513C
....................     } 
....................  
....................     if (count == 0) 
04EAC:  CP0     FEA
04EAE:  BRA     NZ,4EB8
04EB0:  CP0     FEC
04EB2:  BRA     NZ,4EB8
....................         return 0; 
04EB4:  CLR     0
04EB6:  BRA     513C
....................  
....................     if (MDD_WriteProtectState()) 
04EB8:  CALL    25A0
04EBC:  CP0.B   W0L
04EBE:  BRA     Z,4ECC
....................     { 
....................         FSerrno = CE_WRITE_PROTECTED; 
04EC0:  MOV.B   #18,W0L
04EC2:  MOV.B   W0L,8B1
....................         error = CE_WRITE_PROTECTED; 
04EC4:  MOV.B   #18,W0L
04EC6:  MOV.B   W0L,FF2
....................         return 0; 
04EC8:  CLR     0
04ECA:  BRA     513C
....................     } 
....................  
....................     gBufferZeroed = FALSE; 
04ECC:  CLR.B   8B0
....................     dsk = stream->dsk; 
04ECE:  MOV     FE8,W4
04ED0:  ADD     W4,#0,W4
04ED2:  MOV     W4,W0
04ED4:  MOV     [W0],[W15++]
04ED6:  POP     FF0
....................     // get the stated position 
....................     pos = stream->pos; 
04ED8:  MOV     #C,W0
04EDA:  ADD     FE8,W0
04EDC:  MOV     [W0],[W15++]
04EDE:  POP     FF4
....................     seek = stream->seek; 
04EE0:  MOV     #E,W0
04EE2:  ADD     FE8,W0
04EE4:  MOV     #FFA,W4
04EE6:  MOV     [W0++],[W4++]
04EE8:  MOV     [W0++],[W4++]
....................     l = Cluster2Sector(dsk,stream->ccls); 
04EEA:  MOV     #6,W0
04EEC:  ADD     FE8,W0
04EEE:  MOV     #A,W4
04EF0:  MOV     [W0++],[W4++]
04EF2:  MOV     [W0++],[W4++]
04EF4:  PUSH    FF0
04EF6:  POP     10B0
04EF8:  MOV     W5,10B2
04EFA:  MOV     W6,10B4
04EFC:  CALL    308C
04F00:  MOV     W0,FF6
04F02:  MOV     W1,FF8
....................     l += (WORD)stream->sec;      // add the sector number to it 
04F04:  MOV     #A,W0
04F06:  ADD     FE8,W0
04F08:  MOV     W0,W4
04F0A:  MOV     [W4],W0
04F0C:  ADD     FF6
04F0E:  MOV     #0,W0
04F10:  ADDC    FF8,W0
04F12:  MOV     W0,FF8
....................  
....................     // Check if the current stream was the last one to use the 
....................     // buffer. If not, check if we need to write data from the 
....................     // old stream 
....................     if (gBufferOwner != stream) 
04F14:  MOV     8A8,W0
04F16:  CP      FE8
04F18:  BRA     Z,4F32
....................     { 
....................         if (gNeedDataWrite) 
04F1A:  CP0.B   8AE
04F1C:  BRA     Z,4F2E
....................         { 
....................             if (flushData()) 
04F1E:  CALL    3170
04F22:  CP0.B   W0L
04F24:  BRA     Z,4F2E
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
04F26:  MOV.B   #9,W0L
04F28:  MOV.B   W0L,8B1
....................                 return 0; 
04F2A:  CLR     0
04F2C:  BRA     513C
....................             } 
....................         } 
....................         gBufferOwner = stream; 
04F2E:  PUSH    FE8
04F30:  POP     8A8
....................     } 
....................     if (gLastDataSectorRead != l) 
04F32:  MOV     8AA,W0
04F34:  CP      FF6
04F36:  BRA     NZ,4F3E
04F38:  MOV     8AC,W0
04F3A:  CP      FF8
04F3C:  BRA     Z,4F84
....................     { 
....................         if (gNeedDataWrite) 
04F3E:  CP0.B   8AE
04F40:  BRA     Z,4F52
....................         { 
....................             if (flushData()) 
04F42:  CALL    3170
04F46:  CP0.B   W0L
04F48:  BRA     Z,4F52
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
04F4A:  MOV.B   #9,W0L
04F4C:  MOV.B   W0L,8B1
....................                 return 0; 
04F4E:  CLR     0
04F50:  BRA     513C
....................             } 
....................         } 
....................  
....................         gBufferZeroed = FALSE; 
04F52:  CLR.B   8B0
....................         if(!MDD_SectorRead( l, dsk->buffer) ) 
04F54:  MOV     FF0,W4
04F56:  ADD     W4,#0,W4
04F58:  MOV     W4,W0
04F5A:  MOV     #A,W1
04F5C:  MOV     W0,W2
04F5E:  REPEAT  #1
04F60:  MOV.B   [W2++],[W1++]
04F62:  PUSH    FF6
04F64:  POP     10F2
04F66:  PUSH    FF8
04F68:  POP     10F4
04F6A:  MOV     W5,10F6
04F6C:  CALL    1722
04F70:  CP0.B   W0L
04F72:  BRA     NZ,4F7C
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
04F74:  MOV.B   #1B,W0L
04F76:  MOV.B   W0L,8B1
....................             error = CE_BAD_SECTOR_READ; 
04F78:  MOV.B   #8,W0L
04F7A:  MOV.B   W0L,FF2
....................         } 
....................         gLastDataSectorRead = l; 
04F7C:  PUSH    FF6
04F7E:  POP     8AA
04F80:  PUSH    FF8
04F82:  POP     8AC
....................     } 
....................     // exit loop if EOF reached 
....................     filesize = stream->size; 
04F84:  MOV     #12,W0
04F86:  ADD     FE8,W0
04F88:  MOV     #FFE,W4
04F8A:  MOV     [W0++],[W4++]
04F8C:  MOV     [W0++],[W4++]
....................  
....................     // Loop while writing bytes 
....................     while ((error == CE_GOOD) && (count > 0)) 
04F8E:  CP0.B   FF2
04F90:  BRA     NZ,5110
04F92:  CP0     FEA
04F94:  BRA     NZ,4F9A
04F96:  CP0     FEC
04F98:  BRA     Z,5110
....................     { 
....................         if( seek == filesize ) 
04F9A:  MOV     FFA,W0
04F9C:  CP      FFE
04F9E:  BRA     NZ,4FB0
04FA0:  MOV     FFC,W0
04FA2:  CP      1000
04FA4:  BRA     NZ,4FB0
....................             stream->flags.FileWriteEOF = TRUE; 
04FA6:  MOV     #16,W0
04FA8:  ADD     FE8,W0
04FAA:  MOV     W0,W5
04FAC:  MOV     #4,W4
04FAE:  IOR.B    W4L,  [W5],[W5]
....................  
....................         // load a new sector if necessary, multiples of sector 
....................         if (pos == dsk->sectorSize) 
04FB0:  MOV     FF0,W4
04FB2:  ADD     W4,#18,W4
04FB4:  MOV     W4,W0
04FB6:  MOV     #A,W1
04FB8:  MOV     W0,W2
04FBA:  REPEAT  #3
04FBC:  MOV.B   [W2++],[W1++]
04FBE:  MOV     FF4,W4
04FC0:  CP      W4,W5
04FC2:  BRA     NZ,50C6
04FC4:  CP0     W6
04FC6:  BRA     NZ,50C6
....................         { 
....................             BYTE needRead = TRUE; 
04FC8:  MOV.B   #1,W0L
04FCA:  MOV.B   W0L,FF3
....................  
....................             if (gNeedDataWrite) 
04FCC:  CP0.B   8AE
04FCE:  BRA     Z,4FE0
....................                 if (flushData()) 
04FD0:  CALL    3170
04FD4:  CP0.B   W0L
04FD6:  BRA     Z,4FE0
....................                 { 
....................                     FSerrno = CE_WRITE_ERROR; 
04FD8:  MOV.B   #9,W0L
04FDA:  MOV.B   W0L,8B1
....................                     return 0; 
04FDC:  CLR     0
04FDE:  BRA     513C
....................                 } 
....................  
....................             // reset position 
....................             pos = 0; 
04FE0:  CLR     FF4
....................  
....................             // point to the next sector 
....................             stream->sec++; 
04FE2:  MOV     #A,W0
04FE4:  ADD     FE8,W0
04FE6:  MOV     W0,W5
04FE8:  INC     [W5],[W5]
....................  
....................             // get a new cluster if necessary 
....................             if (stream->sec == dsk->SecPerClus) 
04FEA:  MOV     #A,W0
04FEC:  ADD     FE8,W0
04FEE:  MOV     [W0],W5
04FF0:  MOV     #21,W4
04FF2:  MOV     FF0,W3
04FF4:  ADD     W3,W4,W0
04FF6:  MOV     #C,W1
04FF8:  MOV     W0,W2
04FFA:  MOV.B   [W2++],[W1++]
04FFC:  CLR.B   D
04FFE:  CP      W5,W6
05000:  BRA     NZ,503A
....................             { 
....................                 stream->sec = 0; 
05002:  MOV     #A,W0
05004:  ADD     FE8,W0
05006:  MOV     W0,W5
05008:  CLR.B   [W5]
0500A:  MOV.B   #0,W0L
0500C:  MOV.B   W0L,[W5+#1]
....................  
....................                 if(stream->flags.FileWriteEOF) 
0500E:  MOV     #16,W0
05010:  ADD     FE8,W0
05012:  MOV.B   [W0],W4L
05014:  BTSS    W4.2
05016:  BRA     502A
....................                 { 
....................                     error = FILEallocate_new_cluster(stream, 0);    // add new cluster to the file 
05018:  CLR.B   104E
0501A:  PUSH    FE8
0501C:  POP     104C
0501E:  CALL    3E9C
05022:  MOV.B   W0L,FF2
....................                     needRead = FALSE; 
05024:  CLR.B   FF3
....................                 } 
05026:  GOTO    503A
....................                 else 
....................                     error = FILEget_next_cluster( stream, 1); 
0502A:  PUSH    FE8
0502C:  POP     1050
0502E:  MOV     #1,W4
05030:  MOV     W4,1052
05032:  CLR     1054
05034:  CALL    4674
05038:  MOV.B   W0L,FF2
....................             } 
....................  
....................             if (error == CE_DISK_FULL) 
0503A:  MOV     FF2,W4
0503C:  CP.B    W4L,#15
0503E:  BRA     NZ,5048
....................             { 
....................                 FSerrno = CE_DISK_FULL; 
05040:  MOV.B   #15,W0L
05042:  MOV.B   W0L,8B1
....................                 return 0; 
05044:  CLR     0
05046:  BRA     513C
....................             } 
....................  
....................             if(error == CE_GOOD) 
05048:  CP0.B   FF2
0504A:  BRA     NZ,50C6
....................             { 
....................                 l = Cluster2Sector(dsk,stream->ccls); 
0504C:  MOV     #6,W0
0504E:  ADD     FE8,W0
05050:  MOV     #A,W4
05052:  MOV     [W0++],[W4++]
05054:  MOV     [W0++],[W4++]
05056:  PUSH    FF0
05058:  POP     10B0
0505A:  MOV     W5,10B2
0505C:  MOV     W6,10B4
0505E:  CALL    308C
05062:  MOV     W0,FF6
05064:  MOV     W1,FF8
....................                 l += (WORD)stream->sec;      // add the sector number to it 
05066:  MOV     #A,W0
05068:  ADD     FE8,W0
0506A:  MOV     W0,W4
0506C:  MOV     [W4],W0
0506E:  ADD     FF6
05070:  MOV     #0,W0
05072:  ADDC    FF8,W0
05074:  MOV     W0,FF8
....................                 gBufferOwner = stream; 
05076:  PUSH    FE8
05078:  POP     8A8
....................                 // If we just allocated a new cluster, then the cluster will 
....................                 // contain garbage data, so it doesn't matter what we write to it 
....................                 // Whatever is in the buffer will work fine 
....................                 if (needRead) 
0507A:  CP0.B   FF3
0507C:  BRA     Z,50BE
....................                 { 
....................                     if( !MDD_SectorRead( l, dsk->buffer) ) 
0507E:  MOV     FF0,W4
05080:  ADD     W4,#0,W4
05082:  MOV     W4,W0
05084:  MOV     #A,W1
05086:  MOV     W0,W2
05088:  REPEAT  #1
0508A:  MOV.B   [W2++],[W1++]
0508C:  PUSH    FF6
0508E:  POP     10F2
05090:  PUSH    FF8
05092:  POP     10F4
05094:  MOV     W5,10F6
05096:  CALL    1722
0509A:  CP0.B   W0L
0509C:  BRA     NZ,50B2
....................                     { 
....................                         FSerrno = CE_BADCACHEREAD; 
0509E:  MOV.B   #1B,W0L
050A0:  MOV.B   W0L,8B1
....................                         error = CE_BAD_SECTOR_READ; 
050A2:  MOV.B   #8,W0L
050A4:  MOV.B   W0L,FF2
....................                         gLastDataSectorRead = 0xFFFFFFFF; 
050A6:  SETM    8AA
050A8:  SETM    8AC
....................                         return 0; 
050AA:  CLR     0
050AC:  BRA     513C
....................                     } 
050AE:  GOTO    50BA
....................                     else 
....................                     { 
....................                         gLastDataSectorRead = l; 
050B2:  PUSH    FF6
050B4:  POP     8AA
050B6:  PUSH    FF8
050B8:  POP     8AC
....................                     } 
....................                 } 
050BA:  GOTO    50C6
....................                 else 
....................                     gLastDataSectorRead = l; 
050BE:  PUSH    FF6
050C0:  POP     8AA
050C2:  PUSH    FF8
050C4:  POP     8AC
....................             } 
....................         } //  load new sector 
....................  
....................         if(error == CE_GOOD) 
050C6:  CP0.B   FF2
050C8:  BRA     NZ,510C
....................         { 
....................             // Write one byte at a time 
....................             RAMwrite(dsk->buffer, pos++, *(char *)src); 
050CA:  MOV     FF0,W4
050CC:  ADD     W4,#0,W4
050CE:  MOV     W4,W0
050D0:  MOV     #A,W1
050D2:  MOV     W0,W2
050D4:  REPEAT  #1
050D6:  MOV.B   [W2++],[W1++]
050D8:  MOV     FF4,W0
050DA:  INC     0FF4
050DC:  ADD     W0,W5,W0
050DE:  MOV     W0,W5
050E0:  MOV     FEE,W0
050E2:  MOV.B   [W0],[W5]
....................             src = src + 1; // compiler bug 
050E4:  MOV     FEE,W4
050E6:  ADD     W4,#1,W4
050E8:  MOV     W4,FEE
....................             seek++; 
050EA:  INC     0FFA
050EC:  BTSC.B  42.1
050EE:  INC     0FFC
....................             count--; 
050F0:  DEC     0FEA
050F2:  BTSS.B  42.0
050F4:  DEC     0FEC
....................             writeCount++; 
050F6:  INC     1002
....................             // now increment the size of the part 
....................             if(stream->flags.FileWriteEOF) 
050F8:  MOV     #16,W0
050FA:  ADD     FE8,W0
050FC:  MOV.B   [W0],W4L
050FE:  BTSS    W4.2
05100:  BRA     5108
....................                 filesize++; 
05102:  INC     0FFE
05104:  BTSC.B  42.1
05106:  INC     1000
....................             gNeedDataWrite = TRUE; 
05108:  MOV.B   #1,W0L
0510A:  MOV.B   W0L,8AE
....................         } 
0510C:  GOTO    4F8E
....................     } // while count 
....................  
....................     // save off the positon 
....................     stream->pos = pos; 
05110:  MOV     #C,W0
05112:  ADD     FE8,W0
05114:  MOV     W0,W5
05116:  MOV     FF4,W4
05118:  MOV     W4,[W5+#0]
....................  
....................     // save off the seek 
....................     stream->seek = seek; 
0511A:  MOV     #E,W0
0511C:  ADD     FE8,W0
0511E:  MOV     W0,W5
05120:  MOV     #FFA,W4
05122:  MOV     [W4++],[W5++]
05124:  MOV     [W4++],[W5++]
....................  
....................     // now the new size 
....................     stream->size = filesize; 
05126:  MOV     #12,W0
05128:  ADD     FE8,W0
0512A:  MOV     W0,W5
0512C:  MOV     #FFE,W4
0512E:  MOV     [W4++],[W5++]
05130:  MOV     [W4++],[W5++]
....................  
....................     return(writeCount / size); 
05132:  MOV     1002,W4
05134:  MOV     FE4,W3
05136:  REPEAT  #11
05138:  DIV.U   W4,W3
0513A:  MOV     W0,0
0513C:  MOV     [--W15],W6
0513E:  MOV     [--W15],W5
05140:  RETURN  
.................... } // fwrite 
.................... #endif 
....................  
....................  
.................... /********************************************************** 
....................   Function: 
....................     BYTE flushData (void) 
....................   Summary: 
....................     Flush unwritten data to a file 
....................   Conditions: 
....................     File opened in a write mode, data needs to be written 
....................   Return Values: 
....................     CE_GOOD -        Data was updated successfully 
....................     CE_WRITE_ERROR - Data could not be updated 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The flushData function is called when it is necessary to 
....................     read new data into the global data buffer and the 
....................     gNeedDataWrite variable indicates that there is data 
....................     in the buffer that hasn't been written to the device. 
....................     The flushData function will write the data from the 
....................     buffer into the current cluster of the FSFILE object 
....................     that is stored in the gBufferOwner global variable. 
....................   Remarks: 
....................     None 
....................   **********************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE flushData (void) 
*
03170:  MOV     W5,[W15++]
03172:  MOV     W6,[W15++]
*
0317A:  PUSH    8A8
0317C:  POP     10A8
.................... { 
....................     DWORD l; 
*
03174:  CLR     10A2
03176:  CLR     10A4
....................     DISK * dsk; 
03178:  CLR     10A6
....................  
....................     // This will either be the pointer to the last file, or the handle 
....................     FILEOBJ stream = gBufferOwner; 
....................  
....................     dsk = stream->dsk; 
*
0317E:  MOV     10A8,W4
03180:  ADD     W4,#0,W4
03182:  MOV     W4,W0
03184:  MOV     [W0],[W15++]
03186:  POP     10A6
....................  
....................     // figure out the lba 
....................     l = Cluster2Sector(dsk,stream->ccls); 
03188:  MOV     #6,W0
0318A:  ADD     10A8,W0
0318C:  MOV     #A,W4
0318E:  MOV     [W0++],[W4++]
03190:  MOV     [W0++],[W4++]
03192:  PUSH    10A6
03194:  POP     10B0
03196:  MOV     W5,10B2
03198:  MOV     W6,10B4
0319A:  CALL    308C
0319E:  MOV     W0,10A2
031A0:  MOV     W1,10A4
....................     l += (WORD)stream->sec;      // add the sector number to it 
031A2:  MOV     #A,W0
031A4:  ADD     10A8,W0
031A6:  MOV     W0,W4
031A8:  MOV     [W4],W0
031AA:  ADD     10A2
031AC:  MOV     #0,W0
031AE:  ADDC    10A4,W0
031B0:  MOV     W0,10A4
....................  
....................     if(!MDD_SectorWrite( l, dsk->buffer, FALSE)) 
031B2:  MOV     10A6,W4
031B4:  ADD     W4,#0,W4
031B6:  MOV     W4,W0
031B8:  MOV     #A,W1
031BA:  MOV     W0,W2
031BC:  REPEAT  #1
031BE:  MOV.B   [W2++],[W1++]
031C0:  CLR.B   10F8
031C2:  PUSH    10A2
031C4:  POP     10F2
031C6:  PUSH    10A4
031C8:  POP     10F4
031CA:  MOV     W5,10F6
031CC:  CALL    2BBE
031D0:  CP0.B   W0L
031D2:  BRA     NZ,31DA
....................     { 
....................         return CE_WRITE_ERROR; 
031D4:  MOV.B   #9,W0L
031D6:  MOV.B   W0L,0
031D8:  BRA     31DE
....................     } 
....................  
....................     gNeedDataWrite = FALSE; 
031DA:  CLR.B   8AE
....................  
....................     return CE_GOOD; 
031DC:  CLR.B   0
031DE:  MOV     [--W15],W6
031E0:  MOV     [--W15],W5
031E2:  RETURN  
.................... } 
.................... #endif 
....................  
.................... /**************************************************** 
....................   Function: 
....................     int FSfeof( FSFILE * stream ) 
....................   Summary: 
....................     Indicate whether the current file position is at the end 
....................   Conditions: 
....................     File is open in a read mode 
....................   Input: 
....................     stream -  Pointer to the target file 
....................   Return Values: 
....................     Non-Zero - EOF reached 
....................     0 - Not at end of File 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfeof function will indicate that the end-of- 
....................     file has been reached for the specified file by 
....................     comparing the absolute location in the file to the 
....................     size of the file. 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... int FSfeof( FSFILE * stream ) 
.................... { 
....................     FSerrno = CE_GOOD; 
....................     return( stream->seek == stream->size ); 
.................... } 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Read data from a file 
....................   Conditions: 
....................     File is opened in a read mode 
....................   Input: 
....................     ptr -     Destination buffer for read bytes 
....................     size -    Size of units in bytes 
....................     n -       Number of units to be read 
....................     stream -  File to be read from 
....................   Return: 
....................     size_t - number of units read 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfread function will read data from the specified file.  First, 
....................     the appropriate sector of the file is loaded.  Then, data is read into 
....................     the specified buffer until the specified number of bytes have been read. 
....................     When a cluster boundary is reached, a new cluster will be loaded.  The 
....................     parameters 'size' and 'n' indicate how much data to read.  'Size' 
....................     refers to the size of one object to read (in bytes), and 'n' will refer 
....................     to the number of these objects to read.  The value returned will be equal 
....................     to 'n' unless an error occured or the user tried to read beyond the end 
....................     of the file. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... size_t FSfread (void *ptr, size_t size, size_t n, FSFILE *stream) 
*
06C70:  MOV     W5,[W15++]
06C72:  MOV     W6,[W15++]
06C74:  MOV     101E,W4
06C76:  MOV     1020,W3
06C78:  MUL.UU  W4,W3,W0
06C7A:  MOV     W0,1024
06C7C:  CLR     1026
06C7E:  PUSH    101C
06C80:  POP     1028
*
06C8E:  CLR.B   1036
06C90:  CLR     1038
.................... { 
....................     DWORD   len = size * n; 
....................     BYTE    *pointer = (BYTE *) ptr; 
....................     DISK    *dsk;               // Disk structure 
*
06C82:  CLR     102A
....................     DWORD    seek, sec_sel; 
06C84:  CLR     102C
06C86:  CLR     102E
06C88:  CLR     1030
06C8A:  CLR     1032
....................     WORD    pos;       //position within sector 
06C8C:  CLR     1034
....................     CETYPE   error = CE_GOOD; 
....................     WORD    readCount = 0; 
....................  
....................     FSerrno = CE_GOOD; 
*
06C92:  CLR.B   8B1
....................  
....................     dsk    = (DISK *)stream->dsk; 
06C94:  MOV     1022,W4
06C96:  ADD     W4,#0,W4
06C98:  MOV     W4,W0
06C9A:  MOV     [W0],[W15++]
06C9C:  POP     102A
....................     pos    = stream->pos; 
06C9E:  MOV     #C,W0
06CA0:  ADD     1022,W0
06CA2:  MOV     [W0],[W15++]
06CA4:  POP     1034
....................     seek    = stream->seek; 
06CA6:  MOV     #E,W0
06CA8:  ADD     1022,W0
06CAA:  MOV     #102C,W4
06CAC:  MOV     [W0++],[W4++]
06CAE:  MOV     [W0++],[W4++]
....................  
....................     if( !stream->flags.read ) 
06CB0:  MOV     #16,W0
06CB2:  ADD     1022,W0
06CB4:  MOV.B   [W0],W4L
06CB6:  BTSC    W4.1
06CB8:  BRA     6CC2
....................     { 
....................         FSerrno = CE_WRITEONLY; 
06CBA:  MOV.B   #1E,W0L
06CBC:  MOV.B   W0L,8B1
....................         return 0;   // CE_WRITEONLY 
06CBE:  CLR     0
06CC0:  BRA     6E94
....................     } 
....................  
.................... #ifdef ALLOW_WRITES 
....................     if (gNeedDataWrite) 
06CC2:  CP0.B   8AE
06CC4:  BRA     Z,6CD6
....................         if (flushData() != CE_GOOD) 
06CC6:  CALL    3170
06CCA:  CP0.B   W0L
06CCC:  BRA     Z,6CD6
....................         { 
....................             FSerrno = CE_WRITE_ERROR; 
06CCE:  MOV.B   #9,W0L
06CD0:  MOV.B   W0L,8B1
....................             return 0; 
06CD2:  CLR     0
06CD4:  BRA     6E94
....................         } 
.................... #endif 
....................  
....................     // if it not my buffer, then get it from the disk. 
....................     if( (gBufferOwner != stream) && (pos != dsk->sectorSize)) 
06CD6:  MOV     8A8,W0
06CD8:  CP      1022
06CDA:  BRA     Z,6D58
06CDC:  MOV     102A,W4
06CDE:  ADD     W4,#18,W4
06CE0:  MOV     W4,W0
06CE2:  MOV     #A,W1
06CE4:  MOV     W0,W2
06CE6:  REPEAT  #3
06CE8:  MOV.B   [W2++],[W1++]
06CEA:  MOV     1034,W4
06CEC:  CP      W4,W5
06CEE:  BRA     NZ,6CF4
06CF0:  CP0     W6
06CF2:  BRA     Z,6D58
....................     { 
....................         gBufferOwner = stream; 
06CF4:  PUSH    1022
06CF6:  POP     8A8
....................         sec_sel = Cluster2Sector(dsk,stream->ccls); 
06CF8:  MOV     #6,W0
06CFA:  ADD     1022,W0
06CFC:  MOV     #A,W4
06CFE:  MOV     [W0++],[W4++]
06D00:  MOV     [W0++],[W4++]
06D02:  PUSH    102A
06D04:  POP     10B0
06D06:  MOV     W5,10B2
06D08:  MOV     W6,10B4
06D0A:  CALL    308C
06D0E:  MOV     W0,1030
06D10:  MOV     W1,1032
....................         sec_sel += (WORD)stream->sec;      // add the sector number to it 
06D12:  MOV     #A,W0
06D14:  ADD     1022,W0
06D16:  MOV     W0,W4
06D18:  MOV     [W4],W0
06D1A:  ADD     1030
06D1C:  MOV     #0,W0
06D1E:  ADDC    1032,W0
06D20:  MOV     W0,1032
....................  
....................         gBufferZeroed = FALSE; 
06D22:  CLR.B   8B0
....................         if( !MDD_SectorRead( sec_sel, dsk->buffer) ) 
06D24:  MOV     102A,W4
06D26:  ADD     W4,#0,W4
06D28:  MOV     W4,W0
06D2A:  MOV     #A,W1
06D2C:  MOV     W0,W2
06D2E:  REPEAT  #1
06D30:  MOV.B   [W2++],[W1++]
06D32:  PUSH    1030
06D34:  POP     10F2
06D36:  PUSH    1032
06D38:  POP     10F4
06D3A:  MOV     W5,10F6
06D3C:  CALL    1722
06D40:  CP0.B   W0L
06D42:  BRA     NZ,6D50
....................         { 
....................             FSerrno = CE_BAD_SECTOR_READ; 
06D44:  MOV.B   #8,W0L
06D46:  MOV.B   W0L,8B1
....................             error = CE_BAD_SECTOR_READ; 
06D48:  MOV.B   #8,W0L
06D4A:  MOV.B   W0L,1036
....................             return 0; 
06D4C:  CLR     0
06D4E:  BRA     6E94
....................         } 
....................         gLastDataSectorRead = sec_sel; 
06D50:  PUSH    1030
06D52:  POP     8AA
06D54:  PUSH    1032
06D56:  POP     8AC
....................     } 
....................  
....................     //loop reading (count) bytes 
....................     while( len ) 
06D58:  CP0     1024
06D5A:  BRA     NZ,6D60
06D5C:  CP0     1026
06D5E:  BRA     Z,6E74
....................     { 
....................         if( seek == stream->size ) 
06D60:  MOV     #12,W0
06D62:  ADD     1022,W0
06D64:  MOV     W0,W4
06D66:  MOV     #0,W3
06D68:  MOV     [W4++],[W3++]
06D6A:  MOV     [W4++],[W3++]
06D6C:  CP      102C
06D6E:  BRA     NZ,6D82
06D70:  MOV     102E,W4
06D72:  CP      W4,W1
06D74:  BRA     NZ,6D82
....................         { 
....................             FSerrno = CE_EOF; 
06D76:  MOV.B   #3D,W0L
06D78:  MOV.B   W0L,8B1
....................             error = CE_EOF; 
06D7A:  MOV.B   #3D,W0L
06D7C:  MOV.B   W0L,1036
....................             break; 
06D7E:  GOTO    6E74
....................         } 
....................  
....................         // In fopen, pos is init to 0 and the sect is loaded 
....................         if( pos == dsk->sectorSize ) 
06D82:  MOV     102A,W4
06D84:  ADD     W4,#18,W4
06D86:  MOV     W4,W0
06D88:  MOV     #A,W1
06D8A:  MOV     W0,W2
06D8C:  REPEAT  #3
06D8E:  MOV.B   [W2++],[W1++]
06D90:  MOV     1034,W4
06D92:  CP      W4,W5
06D94:  BRA     NZ,6E48
06D96:  CP0     W6
06D98:  BRA     NZ,6E48
....................         { 
....................             // reset position 
....................             pos = 0; 
06D9A:  CLR     1034
....................             // point to the next sector 
....................             stream->sec++; 
06D9C:  MOV     #A,W0
06D9E:  ADD     1022,W0
06DA0:  MOV     W0,W5
06DA2:  INC     [W5],[W5]
....................  
....................             // get a new cluster if necessary 
....................             if( stream->sec == dsk->SecPerClus ) 
06DA4:  MOV     #A,W0
06DA6:  ADD     1022,W0
06DA8:  MOV     [W0],W5
06DAA:  MOV     #21,W4
06DAC:  MOV     102A,W3
06DAE:  ADD     W3,W4,W0
06DB0:  MOV     #C,W1
06DB2:  MOV     W0,W2
06DB4:  MOV.B   [W2++],[W1++]
06DB6:  CLR.B   D
06DB8:  CP      W5,W6
06DBA:  BRA     NZ,6DE4
....................             { 
....................                 stream->sec = 0; 
06DBC:  MOV     #A,W0
06DBE:  ADD     1022,W0
06DC0:  MOV     W0,W5
06DC2:  CLR.B   [W5]
06DC4:  MOV.B   #0,W0L
06DC6:  MOV.B   W0L,[W5+#1]
....................                 if( (error = FILEget_next_cluster( stream, 1)) != CE_GOOD ) 
06DC8:  PUSH    1022
06DCA:  POP     1050
06DCC:  MOV     #1,W4
06DCE:  MOV     W4,1052
06DD0:  CLR     1054
06DD2:  CALL    4674
06DD6:  MOV.B   W0L,1036
06DD8:  CP0.B   1036
06DDA:  BRA     Z,6DE4
....................                 { 
....................                     FSerrno = CE_COULD_NOT_GET_CLUSTER; 
06DDC:  MOV.B   #F,W0L
06DDE:  MOV.B   W0L,8B1
....................                     break; 
06DE0:  GOTO    6E74
....................                 } 
....................             } 
....................  
....................             sec_sel = Cluster2Sector(dsk,stream->ccls); 
06DE4:  MOV     #6,W0
06DE6:  ADD     1022,W0
06DE8:  MOV     #A,W4
06DEA:  MOV     [W0++],[W4++]
06DEC:  MOV     [W0++],[W4++]
06DEE:  PUSH    102A
06DF0:  POP     10B0
06DF2:  MOV     W5,10B2
06DF4:  MOV     W6,10B4
06DF6:  CALL    308C
06DFA:  MOV     W0,1030
06DFC:  MOV     W1,1032
....................             sec_sel += (WORD)stream->sec;      // add the sector number to it 
06DFE:  MOV     #A,W0
06E00:  ADD     1022,W0
06E02:  MOV     W0,W4
06E04:  MOV     [W4],W0
06E06:  ADD     1030
06E08:  MOV     #0,W0
06E0A:  ADDC    1032,W0
06E0C:  MOV     W0,1032
....................  
....................  
....................             gBufferOwner = stream; 
06E0E:  PUSH    1022
06E10:  POP     8A8
....................             gBufferZeroed = FALSE; 
06E12:  CLR.B   8B0
....................             if( !MDD_SectorRead( sec_sel, dsk->buffer) ) 
06E14:  MOV     102A,W4
06E16:  ADD     W4,#0,W4
06E18:  MOV     W4,W0
06E1A:  MOV     #A,W1
06E1C:  MOV     W0,W2
06E1E:  REPEAT  #1
06E20:  MOV.B   [W2++],[W1++]
06E22:  PUSH    1030
06E24:  POP     10F2
06E26:  PUSH    1032
06E28:  POP     10F4
06E2A:  MOV     W5,10F6
06E2C:  CALL    1722
06E30:  CP0.B   W0L
06E32:  BRA     NZ,6E40
....................             { 
....................                 FSerrno = CE_BAD_SECTOR_READ; 
06E34:  MOV.B   #8,W0L
06E36:  MOV.B   W0L,8B1
....................                 error = CE_BAD_SECTOR_READ; 
06E38:  MOV.B   #8,W0L
06E3A:  MOV.B   W0L,1036
....................                 break; 
06E3C:  GOTO    6E74
....................             } 
....................             gLastDataSectorRead = sec_sel; 
06E40:  PUSH    1030
06E42:  POP     8AA
06E44:  PUSH    1032
06E46:  POP     8AC
....................         } 
....................  
....................         // copy one byte at a time 
....................         *pointer = RAMread( dsk->buffer, pos++ ); 
06E48:  MOV     1028,W5
06E4A:  MOV     102A,W4
06E4C:  ADD     W4,#0,W4
06E4E:  MOV     W4,W0
06E50:  MOV     #C,W1
06E52:  MOV     W0,W2
06E54:  REPEAT  #1
06E56:  MOV.B   [W2++],[W1++]
06E58:  MOV     1034,W0
06E5A:  INC     1034
06E5C:  ADD     W0,W6,W0
06E5E:  MOV.B   [W0],[W5]
....................         pointer++; 
06E60:  INC     1028
....................         seek++; 
06E62:  INC     102C
06E64:  BTSC.B  42.1
06E66:  INC     102E
....................         readCount++; 
06E68:  INC     1038
....................         len--; 
06E6A:  DEC     1024
06E6C:  BTSS.B  42.0
06E6E:  DEC     1026
06E70:  GOTO    6D58
....................     } 
....................  
....................     // save off the positon 
....................     stream->pos = pos; 
06E74:  MOV     #C,W0
06E76:  ADD     1022,W0
06E78:  MOV     W0,W5
06E7A:  MOV     1034,W4
06E7C:  MOV     W4,[W5+#0]
....................     // save off the seek 
....................     stream->seek = seek; 
06E7E:  MOV     #E,W0
06E80:  ADD     1022,W0
06E82:  MOV     W0,W5
06E84:  MOV     #102C,W4
06E86:  MOV     [W4++],[W5++]
06E88:  MOV     [W4++],[W5++]
....................  
....................     return(readCount / size); 
06E8A:  MOV     1038,W4
06E8C:  MOV     101E,W3
06E8E:  REPEAT  #11
06E90:  DIV.U   W4,W3
06E92:  MOV     W0,0
06E94:  MOV     [--W15],W6
06E96:  MOV     [--W15],W5
06E98:  RETURN  
.................... } // fread 
....................  
....................  
.................... /*************************************************************************** 
....................   Function: 
....................     BYTE FormatFileName( const char* fileName, FILEOBJ fptr, BYTE mode ) 
....................   Summary: 
....................     Format a file name into dir entry format 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fileName -  The name to be formatted 
....................     fN2 -       The location the formatted name will be stored 
....................     mode -      Non-zero if parital string search chars are allowed 
....................   Return Values: 
....................     TRUE - Name formatted successfully 
....................     FALSE - File name could not be formatted 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     Format an 8.3 filename into FSFILE structure format. If filename is less 
....................     than 8 chars, then it will be padded with spaces. If the extension name is 
....................     fewer than 3 chars, then it will also be oadded with spaces. The 
....................     ValidateChars function is used to ensure the characters in the specified 
....................     filename are valid in this filesystem. 
....................   Remarks: 
....................     None. 
....................   ***************************************************************************/ 
.................... BYTE FormatFileName( const char* fileName, FILEOBJ fptr, BYTE mode) 
*
026EC:  MOV     W5,[W15++]
026EE:  MOV     W6,[W15++]
026F0:  MOV     W7,[W15++]
*
02700:  BCLR.B  106C.0
02702:  CLR     106E
.................... { 
....................    char *fN2; 
*
026F2:  CLR     1060
....................    FILE_DIR_NAME_TYPE fileNameType; 
026F4:  CLR.B   105F
....................     int temp,count1,count2,count3,count4; 
026F6:  CLR     1062
026F8:  CLR     1064
026FA:  CLR     1066
026FC:  CLR     1068
026FE:  CLR     106A
....................     BOOL supportLFN = FALSE; 
....................    char *localFileName = NULL; 
....................  
....................    // go with static allocation 
....................    #if defined(SUPPORT_LFN) 
....................       unsigned short int tempString[256]; 
....................       BOOL   AscciIndication = TRUE; 
....................       count1 = 256; 
....................    #else 
....................       unsigned short int   tempString[13]; 
*
02704:  CLR     1070
02706:  CLR     1072
02708:  CLR     1074
0270A:  CLR     1076
0270C:  CLR     1078
0270E:  CLR     107A
02710:  CLR     107C
02712:  CLR     107E
02714:  CLR     1080
02716:  CLR     1082
02718:  CLR     1084
0271A:  CLR     1086
0271C:  CLR     1088
....................       count1 = 12; 
0271E:  MOV     #C,W4
02720:  MOV     W4,1064
....................    #endif 
....................  
....................    // Check whether the length of the file name is valid 
....................    // for LFN support as well as Non LFN support 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................    { 
....................       utf16Filename = (unsigned short int *)fileName; 
....................       fileNameLength = 0; 
....................       while(utf16Filename[fileNameLength]) 
....................       { 
....................          fileNameLength++; 
....................       } 
....................  
....................       if((fileNameLength > count1) || (*utf16Filename == '.') || 
....................          (*utf16Filename == 0)) 
....................       { 
....................          return FALSE; 
....................       } 
....................  
....................       for (count1 = 0;count1 < fileNameLength; count1++) 
....................       { 
....................          tempString[count1] = utf16Filename[count1]; 
....................       } 
....................  
....................       utf16Filename = tempString; 
....................    } 
....................    else 
....................    #endif 
....................    { 
....................       fileNameLength = strlen(fileName); 
02722:  PUSH    105A
02724:  POP     1090
02726:  CALL    25A8
0272A:  MOV     W0,D86
....................  
....................       if((fileNameLength > count1) || (*fileName == '.') || (*fileName == 0)) 
0272C:  MOV     1064,W0
0272E:  MOV     D86,W4
02730:  CP      W4,W0
02732:  BRA     GT,2746
02734:  MOV     105A,W0
02736:  MOV.B   [W0],W4L
02738:  XOR.B   #2E,W4L
0273A:  BRA     Z,2746
0273C:  MOV     105A,W0
0273E:  MOV.B   [W0],W5L
02740:  SE      W5,W5
02742:  CP0     W5
02744:  BRA     NZ,274A
....................       { 
....................          return FALSE; 
02746:  CLR.B   0
02748:  BRA     28DA
....................       } 
....................  
....................       asciiFilename = (char *)tempString; 
0274A:  MOV     #1070,W5
0274C:  MOV     W5,D84
....................       for (count1 = 0;count1 < fileNameLength; count1++) 
0274E:  CLR     1064
02750:  MOV     1064,W0
02752:  MOV     D86,W4
02754:  CP      W4,W0
02756:  BRA     LE,276A
....................       { 
....................          asciiFilename[count1] = fileName[count1]; 
02758:  MOV     1064,W0
0275A:  ADD     D84,W0
0275C:  MOV     W0,W5
0275E:  MOV     1064,W0
02760:  ADD     105A,W0
02762:  MOV.B   [W0],[W5]
02764:  INC     1064
02766:  GOTO    2750
....................       } 
....................    } 
....................     
....................  
....................        #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" FormatFileName len="); 
....................          PrintRAMBytesUART(((unsigned char*)&fileNameLength), 1); 
....................          PrintROMASCIIStringUART(" FormatFileName asciiFilename="); 
....................          PrintRAMBytesUART(((unsigned char*)asciiFilename), 13);          
....................          PrintROMASCIIStringUART(" FormatFileName fileName="); 
....................          PrintRAMBytesUART(((unsigned char*)fileName), 13);          
....................         #endif 
....................  
....................     // Make sure the characters are valid 
....................       fileNameType = ValidateChars(mode); 
0276A:  MOV.B   105E,W0L
0276C:  MOV.B   W0L,1090
0276E:  CALL    25C8
02772:  MOV.B   W0L,105F
....................  
....................     // If the file name doesn't follow 8P3 or LFN format, then return FALSE 
....................     if(NAME_ERROR == fileNameType) 
02774:  MOV     105E,W4
02776:  LSR     W4,#8,W4
02778:  CP.B    W4L,#7
0277A:  BRA     NZ,2780
....................    { 
....................       return FALSE; 
0277C:  CLR.B   0
0277E:  BRA     28DA
....................    } 
....................  
....................    temp = fileNameLength; 
02780:  PUSH    D86
02782:  POP     1062
....................  
....................    #if defined(SUPPORT_LFN) 
....................       fptr->AsciiEncodingType = TRUE; 
....................       fptr->utf16LFNlength = 0; 
....................    #endif 
....................  
....................    // If LFN is supported and the file name is UTF16 type or Ascii mixed type, 
....................    // go for LFN support rather than trying to adjust in 8P3 format 
....................    if(NAME_8P3_ASCII_MIXED_TYPE == fileNameType) 
02784:  MOV     105E,W4
02786:  LSR     W4,#8,W4
02788:  CP.B    W4L,#1
0278A:  BRA     NZ,278C
....................    { 
....................       #if defined(SUPPORT_LFN) 
....................          supportLFN = TRUE; 
....................       #endif 
....................    } 
....................  
....................    #if defined(SUPPORT_LFN) 
....................    if(NAME_8P3_UTF16_TYPE == fileNameType) 
....................    { 
....................       for (count3 = 0; count3 < temp; count3++) 
....................       { 
....................          if(utf16Filename[count3] > 0xFF) 
....................          { 
....................             fileNameType = NAME_8P3_UTF16_NONASCII_TYPE; 
....................             supportLFN = TRUE; 
....................             break; 
....................          } 
....................       } 
....................  
....................       if(count3 == temp) 
....................       { 
....................          fileNameType = NAME_8P3_UTF16_ASCII_CAPS_TYPE; 
....................  
....................          for (count3 = 0; count3 < temp; count3++) 
....................          { 
....................             if((utf16Filename[count3] >= 0x61) && (utf16Filename[count3] <= 0x7A)) 
....................             { 
....................                fileNameType = NAME_8P3_UTF16_ASCII_MIXED_TYPE; 
....................                supportLFN = TRUE; 
....................                break; 
....................             } 
....................          } 
....................       } 
....................    } 
....................    #endif 
....................  
....................    // If the file name follows 8P3 type 
....................    if((NAME_LFN_TYPE != fileNameType) && (FALSE == supportLFN)) 
0278C:  MOV     105E,W4
0278E:  LSR     W4,#8,W4
02790:  CP.B    W4L,#6
02792:  BRA     Z,28C6
02794:  BTSC.B  106C.0
02796:  BRA     28C6
....................    { 
....................       for (count3 = 0; count3 < temp; count3++) 
02798:  CLR     1068
0279A:  MOV     1068,W0
0279C:  MOV     1062,W4
0279E:  CP      W4,W0
027A0:  BRA     LE,27DE
....................       { 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................          { 
....................             if(((utf16Filename[count3] == '.') && ((temp - count3) > 4)) || 
....................                (count3 > 8)) 
....................             { 
....................                // UTF File name extension greater then 3 characters or 
....................                 // UTF File name greater then 8 charcters 
....................                supportLFN = TRUE; 
....................                break; 
....................             } 
....................             else if(utf16Filename[count3] == '.') 
....................             { 
....................                break; 
....................             } 
....................          } 
....................          else 
....................          #endif 
....................          { 
....................             if(((asciiFilename[count3] == '.') && ((temp - count3) > 4)) || 
....................                (count3 > 8)) 
027A2:  MOV     1068,W0
027A4:  ADD     D84,W0
027A6:  MOV.B   [W0],W4L
027A8:  XOR.B   #2E,W4L
027AA:  BRA     NZ,27B6
027AC:  MOV     1062,W4
027AE:  MOV     1068,W3
027B0:  SUB     W4,W3,W5
027B2:  CP      W5,#4
027B4:  BRA     GT,27BC
027B6:  MOV     1068,W4
027B8:  CP      W4,#8
027BA:  BRA     LE,27CA
....................             { 
....................                // File extension greater then 3 characters or 
....................                // File name greater then 8 charcters 
....................                #if !defined(SUPPORT_LFN) 
....................                   return FALSE; 
027BC:  CLR.B   0
027BE:  BRA     28DA
....................                #endif 
....................                supportLFN = TRUE; 
027C0:  BSET.B  106C.0
....................                break; 
027C2:  GOTO    27DE
....................             } 
027C6:  GOTO    27D8
....................             else if(asciiFilename[count3] == '.') 
027CA:  MOV     1068,W0
027CC:  ADD     D84,W0
027CE:  MOV.B   [W0],W4L
027D0:  XOR.B   #2E,W4L
027D2:  BRA     NZ,27D8
....................             { 
....................                break; 
027D4:  GOTO    27DE
....................             } 
....................          } 
027D8:  INC     1068
027DA:  GOTO    279A
....................       } 
....................  
....................       // If LFN not supported try to adjust in 8P3 format 
....................       if(FALSE == supportLFN) 
027DE:  BTSC.B  106C.0
027E0:  BRA     28C6
....................       { 
....................           // point fN2 to short file name 
....................           fN2 = fptr -> name; 
027E2:  MOV     #1C,W0
027E4:  ADD     105C,W0
027E6:  MOV     W0,1060
....................  
....................           // Load destination filename to be space intially. 
....................           for (count1 = 0; count1 < FILE_NAME_SIZE_8P3; count1++) 
027E8:  CLR     1064
027EA:  MOV     1064,W4
027EC:  CP      W4,#B
027EE:  BRA     GE,2800
....................           { 
....................               *(fN2 + count1) = ' '; 
027F0:  MOV     1060,W0
027F2:  ADD     1064,W0
027F4:  MOV     W0,W5
027F6:  MOV.B   #20,W0L
027F8:  MOV.B   W0L,[W5]
027FA:  INC     1064
027FC:  GOTO    27EA
....................           } 
....................  
....................          // multiply the length by 2 as each UTF word has 2 byte 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................          { 
....................             count4 = count3 * 2; 
....................             temp = temp * 2; 
....................             localFileName = (char *)utf16Filename; 
....................          } 
....................          else 
....................          #endif 
....................          { 
....................             count4 = count3; 
02800:  PUSH    1068
02802:  POP     106A
....................             localFileName = asciiFilename; 
02804:  PUSH    D84
02806:  POP     106E
....................          } 
....................  
....................           //copy only file name ( not the extension part ) 
....................           for (count1 = 0,count2 = 0; (count2 < 8) && (count1 < count4);count1++ ) 
02808:  CLR     1064
0280A:  CLR     1066
0280C:  MOV     1066,W4
0280E:  CP      W4,#8
02810:  BRA     GE,2862
02812:  MOV     1064,W0
02814:  MOV     106A,W4
02816:  CP      W4,W0
02818:  BRA     LE,2862
....................           { 
....................             if(localFileName[count1]) 
0281A:  MOV     1064,W0
0281C:  ADD     106E,W0
0281E:  CP0.B   [W0]
02820:  BRA     Z,285C
....................             { 
....................                fN2[count2] = localFileName[count1]; // Destination filename initially filled with SPACE. Now copy only available chars. 
02822:  MOV     1066,W0
02824:  ADD     1060,W0
02826:  MOV     W0,W5
02828:  MOV     1064,W0
0282A:  ADD     106E,W0
0282C:  MOV.B   [W0],[W5]
....................  
....................                 // Convert lower-case to upper-case 
....................                 if ((fN2[count2] >= 0x61) && (fN2[count2] <= 0x7A)) 
0282E:  MOV     1066,W0
02830:  ADD     1060,W0
02832:  MOV.B   [W0],W5L
02834:  SE      W5,W5
02836:  MOV     #61,W4
02838:  CP      W4,W5
0283A:  BRA     GT,285A
0283C:  MOV     1066,W0
0283E:  ADD     1060,W0
02840:  MOV.B   [W0],W5L
02842:  SE      W5,W5
02844:  MOV     #7A,W4
02846:  CP      W4,W5
02848:  BRA     LT,285A
....................                 { 
....................                     fN2[count2] -= 0x20; 
0284A:  MOV     1066,W0
0284C:  ADD     1060,W0
0284E:  MOV     W0,W5
02850:  MOV.B   [W5],W4L
02852:  CLR.B   9
02854:  MOV     #20,W3
02856:  SUB     W4,W3,W0
02858:  MOV.B   W0L,[W5]
....................                } 
....................                count2++; 
0285A:  INC     1066
....................             } 
0285C:  INC     1064
0285E:  GOTO    280C
....................           } 
....................  
....................          if(count4 < temp) 
02862:  MOV     106A,W0
02864:  MOV     1062,W4
02866:  CP      W4,W0
02868:  BRA     LE,28C6
....................          { 
....................             // Discard the '.' part 
....................             count4++; 
0286A:  INC     106A
....................  
....................               // Copy the extn to 8th position onwards. Ex: "FILE    .Tx " 
....................               for (count3 = 8; (count3 < 11) && (count4 < temp);count4++ ) 
0286C:  MOV     #8,W4
0286E:  MOV     W4,1068
02870:  MOV     1068,W4
02872:  CP      W4,#B
02874:  BRA     GE,28C6
02876:  MOV     106A,W0
02878:  MOV     1062,W4
0287A:  CP      W4,W0
0287C:  BRA     LE,28C6
....................               { 
....................                if(localFileName[count4]) 
0287E:  MOV     106A,W0
02880:  ADD     106E,W0
02882:  CP0.B   [W0]
02884:  BRA     Z,28C0
....................                { 
....................                      fN2[count3] = localFileName[count4]; 
02886:  MOV     1068,W0
02888:  ADD     1060,W0
0288A:  MOV     W0,W5
0288C:  MOV     106A,W0
0288E:  ADD     106E,W0
02890:  MOV.B   [W0],[W5]
....................  
....................                       // Convert lower-case to upper-case 
....................                       if ((fN2[count3] >= 0x61) && (fN2[count3] <= 0x7A)) 
02892:  MOV     1068,W0
02894:  ADD     1060,W0
02896:  MOV.B   [W0],W5L
02898:  SE      W5,W5
0289A:  MOV     #61,W4
0289C:  CP      W4,W5
0289E:  BRA     GT,28BE
028A0:  MOV     1068,W0
028A2:  ADD     1060,W0
028A4:  MOV.B   [W0],W5L
028A6:  SE      W5,W5
028A8:  MOV     #7A,W4
028AA:  CP      W4,W5
028AC:  BRA     LT,28BE
....................                       { 
....................                           fN2[count3] -= 0x20; 
028AE:  MOV     1068,W0
028B0:  ADD     1060,W0
028B2:  MOV     W0,W5
028B4:  MOV.B   [W5],W4L
028B6:  CLR.B   9
028B8:  MOV     #20,W3
028BA:  SUB     W4,W3,W0
028BC:  MOV.B   W0L,[W5]
....................                   } 
....................                   count3++; 
028BE:  INC     1068
....................                } 
028C0:  INC     106A
028C2:  GOTO    2870
....................               } 
....................          } 
....................       } 
....................    } 
....................  
....................    // If the file name follows LFN format 
....................     if((NAME_LFN_TYPE == fileNameType) || (TRUE == supportLFN)) 
028C6:  MOV     105E,W4
028C8:  LSR     W4,#8,W4
028CA:  CP.B    W4L,#6
028CC:  BRA     Z,28D2
028CE:  BTSS.B  106C.0
028D0:  BRA     28D6
....................    { 
....................       #if defined(SUPPORT_LFN) 
....................  
....................          // point fN2 to long file name 
....................          fN2 = (char *)(fptr -> utf16LFNptr); 
....................  
....................          if(!utfModeFileName) 
....................          { 
....................             localFileName = asciiFilename; 
....................          } 
....................  
....................          // Copy the LFN name in the adress specified by FSFILE pointer 
....................          count2 = 0; 
....................          for(count1 = 0;count1 < temp;count1++) 
....................          { 
....................             if(utfModeFileName) 
....................             { 
....................                fptr -> utf16LFNptr[count1] = utf16Filename[count1]; 
....................                if(AscciIndication) 
....................                { 
....................                   if(utf16Filename[count1] > 0xFF) 
....................                   { 
....................                      fptr->AsciiEncodingType = FALSE; 
....................                      AscciIndication = FALSE; 
....................                   } 
....................                } 
....................             } 
....................             else 
....................             { 
....................                fN2[count2++] = localFileName[count1]; 
....................                fN2[count2++] = (BYTE)0x00; 
....................             } 
....................          } 
....................          fptr -> utf16LFNptr[count1] = 0x0000; 
....................  
....................          fptr->utf16LFNlength = fileNameLength; 
....................       #else 
....................          return FALSE; 
028D2:  CLR.B   0
028D4:  BRA     28DA
....................       #endif 
....................    } 
....................  
....................    // Free the temporary heap used for intermediate execution 
....................    return TRUE; 
028D6:  MOV.B   #1,W0L
028D8:  MOV.B   W0L,0
028DA:  MOV     [--W15],W7
028DC:  MOV     [--W15],W6
028DE:  MOV     [--W15],W5
028E0:  RETURN  
.................... } 
....................  
.................... #ifdef ALLOW_DIRS 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE FormatDirName (char * string,FILEOBJ fptr, BYTE mode) 
....................   Summary: 
....................     Format a dir name into dir entry format 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     string -  The name to be formatted 
....................     mode - 
....................          - TRUE -  Partial string search characters are allowed 
....................          - FALSE - Partial string search characters are forbidden 
....................   Return Values: 
....................     TRUE - The name was formatted correctly 
....................     FALSE - The name contained invalid characters 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     Format an 8.3 filename into directory structure format. If the name is less 
....................     than 8 chars, then it will be padded with spaces. If the extension name is 
....................     fewer than 3 chars, then it will also be oadded with spaces. The 
....................     ValidateChars function is used to ensure the characters in the specified 
....................     directory name are valid in this filesystem. 
....................   Remarks: 
....................     None. 
....................   *************************************************************************/ 
....................  
.................... BYTE FormatDirName (char * string,FILEOBJ fptr, BYTE mode) 
*
05F54:  MOV     W5,[W15++]
05F56:  MOV     W6,[W15++]
05F58:  MOV     W7,[W15++]
*
05F6E:  BCLR.B  1074.0
.................... { 
....................     char tempString [12]; 
*
05F5A:  CLR     1062
05F5C:  CLR     1064
05F5E:  CLR     1066
05F60:  CLR     1068
05F62:  CLR     106A
05F64:  CLR     106C
....................    FILE_DIR_NAME_TYPE fileNameType; 
05F66:  CLR.B   1061
....................     int temp,count1,count2; 
05F68:  CLR     106E
05F6A:  CLR     1070
05F6C:  CLR     1072
....................     BOOL supportLFN = FALSE; 
....................    char *localFileName; 
*
05F70:  CLR     1076
....................  
....................    // go with static allocation 
....................    #if defined(SUPPORT_LFN) 
....................        int count3,count4; 
....................       BOOL   AscciIndication = TRUE; 
....................       count1 = 256; 
....................    #else 
....................       count1 = 12; 
05F72:  MOV     #C,W4
05F74:  MOV     W4,1070
....................    #endif 
....................  
....................    // Calculate the String length 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................    { 
....................       utf16Filename = (unsigned short int *)string; 
....................       fileNameLength = 0; 
....................       while(utf16Filename[fileNameLength]) 
....................       { 
....................          fileNameLength++; 
....................       } 
....................    } 
....................    else 
....................    #endif 
....................    { 
....................       asciiFilename = string; 
05F76:  PUSH    105C
05F78:  POP     D84
....................       fileNameLength = strlen(string); 
05F7A:  PUSH    105C
05F7C:  POP     1090
05F7E:  CALL    25A8
05F82:  MOV     W0,D86
....................    } 
....................  
....................    if(fileNameLength > count1) 
05F84:  MOV     1070,W0
05F86:  MOV     D86,W4
05F88:  CP      W4,W0
05F8A:  BRA     LE,5F90
....................    { 
....................       return FALSE; 
05F8C:  CLR.B   0
05F8E:  BRA     60C4
....................    } 
....................  
....................     // Make sure the characters are valid 
....................     fileNameType = ValidateChars(mode); 
05F90:  MOV.B   1060,W0L
05F92:  MOV.B   W0L,1090
05F94:  CALL    25C8
05F98:  MOV.B   W0L,1061
....................  
....................     // If the file name doesn't follow 8P3 or LFN format, then return FALSE 
....................     if(NAME_ERROR == fileNameType) 
05F9A:  MOV     1060,W4
05F9C:  LSR     W4,#8,W4
05F9E:  CP.B    W4L,#7
05FA0:  BRA     NZ,5FA6
....................    { 
....................       return FALSE; 
05FA2:  CLR.B   0
05FA4:  BRA     60C4
....................    } 
....................  
....................    temp = fileNameLength; 
05FA6:  PUSH    D86
05FA8:  POP     106E
....................  
....................    #if defined(SUPPORT_LFN) 
....................       fptr->AsciiEncodingType = TRUE; 
....................       fptr->utf16LFNlength = 0; 
....................    #endif 
....................  
....................    // If LFN is supported and the file name is UTF16 type or Ascii mixed type, 
....................    // go for LFN support rather than trying to adjust in 8P3 format 
....................    if(NAME_8P3_ASCII_MIXED_TYPE == fileNameType) 
05FAA:  MOV     1060,W4
05FAC:  LSR     W4,#8,W4
05FAE:  CP.B    W4L,#1
05FB0:  BRA     NZ,5FB2
....................    { 
....................       #if defined(SUPPORT_LFN) 
....................          supportLFN = TRUE; 
....................       #endif 
....................    } 
....................  
....................    #if defined(SUPPORT_LFN) 
....................    if(NAME_8P3_UTF16_TYPE == fileNameType) 
....................    { 
....................       for (count3 = 0; count3 < temp; count3++) 
....................       { 
....................          if(utf16Filename[count3] > 0xFF) 
....................          { 
....................             fileNameType = NAME_8P3_UTF16_NONASCII_TYPE; 
....................             supportLFN = TRUE; 
....................             break; 
....................          } 
....................       } 
....................  
....................       if(count3 == temp) 
....................       { 
....................          fileNameType = NAME_8P3_UTF16_ASCII_CAPS_TYPE; 
....................  
....................          for (count3 = 0; count3 < temp; count3++) 
....................          { 
....................             if((utf16Filename[count3] >= 0x61) && (utf16Filename[count3] <= 0x7A)) 
....................             { 
....................                fileNameType = NAME_8P3_UTF16_ASCII_MIXED_TYPE; 
....................                supportLFN = TRUE; 
....................                break; 
....................             } 
....................          } 
....................       } 
....................    } 
....................    #endif 
....................  
....................    // If the file name follows LFN format 
....................     if((NAME_LFN_TYPE == fileNameType) || (TRUE == supportLFN)) 
05FB2:  MOV     1060,W4
05FB4:  LSR     W4,#8,W4
05FB6:  CP.B    W4L,#6
05FB8:  BRA     Z,5FBE
05FBA:  BTSS.B  1074.0
05FBC:  BRA     5FC6
....................    { 
....................       #if !defined(SUPPORT_LFN) 
....................            return FALSE; 
05FBE:  CLR.B   0
05FC0:  BRA     60C4
....................       #else 
....................          fptr -> utf16LFNptr = (unsigned short int *)string; 
....................  
....................          if(utfModeFileName) 
....................          { 
....................             if(utf16Filename != (unsigned short int *)string) 
....................             { 
....................                // Copy the validated/Fomated name in the UTF16 string 
....................                for(count1 = 0; count1 < temp; count1++) 
....................                { 
....................                   fptr -> utf16LFNptr[count1] = utf16Filename[count1]; 
....................                   if(AscciIndication) 
....................                   { 
....................                      if(utf16Filename[count1] > 0xFF) 
....................                      { 
....................                         fptr->AsciiEncodingType = FALSE; 
....................                         AscciIndication = FALSE; 
....................                      } 
....................                   } 
....................                } 
....................                fptr -> utf16LFNptr[count1] = 0x0000; 
....................             } 
....................             else 
....................             { 
....................                for(count1 = 0; count1 < temp; count1++) 
....................                { 
....................                   if(AscciIndication) 
....................                   { 
....................                      if(utf16Filename[count1] > 0xFF) 
....................                      { 
....................                         fptr->AsciiEncodingType = FALSE; 
....................                         AscciIndication = FALSE; 
....................                         break; 
....................                      } 
....................                   } 
....................                } 
....................             } 
....................          } 
....................          else 
....................          { 
....................             #ifdef FS_DYNAMIC_MEM 
....................                 unsigned short int *tempAsciiLFN = (unsigned short int *)FS_malloc((temp + 1) * 2); 
....................             #else 
....................                unsigned short int   tempAsciiLFN[temp + 1]; 
....................             #endif 
....................  
....................             localFileName = (char *)tempAsciiLFN; 
....................  
....................             // Copy the validated/Fomated name in the Ascii string 
....................             count2 = 0; 
....................  
....................             for(count1 = 0; count1 < temp; count1++) 
....................             { 
....................                localFileName[count2++] = asciiFilename[count1]; 
....................  
....................                localFileName[count2++] = (BYTE)0x00; 
....................  
....................             } 
....................  
....................             // Copy the validated/Fomated name in the UTF16 string 
....................             for(count1 = 0; count1 < temp; count1++) 
....................             { 
....................                fptr -> utf16LFNptr[count1] = tempAsciiLFN[count1]; 
....................             } 
....................  
....................             #ifdef FS_DYNAMIC_MEM 
....................                 FS_free((unsigned char *)tempAsciiLFN); 
....................             #endif 
....................             fptr -> utf16LFNptr[count1] = 0x0000; 
....................          } 
....................  
....................          fptr->utf16LFNlength = fileNameLength; 
....................       #endif 
....................    } 
05FC2:  GOTO    60C0
....................    else 
....................    { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................       { 
....................          localFileName = (char *)utf16Filename; 
....................  
....................          // Copy the name part in the temporary string 
....................           count4 = 0; 
....................           for (count3 = 0; (count3 < temp) && (utf16Filename[count3] != '.') && (utf16Filename[count3] != 0); count3++) 
....................           { 
....................             count1 = count3 * 2; 
....................             if(localFileName[count1]) 
....................             { 
....................                  tempString[count4] = localFileName[count1]; 
....................                count4++; 
....................                if(count4 == 8) 
....................                   break; 
....................             } 
....................  
....................             if(localFileName[count1 + 1]) 
....................             { 
....................                  tempString[count4] = localFileName[count1 + 1]; 
....................                count4++; 
....................                if(count4 == 8) 
....................                   break; 
....................             } 
....................           } 
....................  
....................          // File the remaining name portion with spaces 
....................           while (count4 < 8) 
....................           { 
....................               tempString [count4++] = 0x20; 
....................           } 
....................  
....................          // Copy the extension part in the temporary string 
....................           if (utf16Filename[count3] == '.') 
....................           { 
....................             count1 = count3 * 2 + 2; 
....................               while (localFileName[count1] != 0) 
....................               { 
....................                if(localFileName[count3]) 
....................                { 
....................                     tempString[count4] = localFileName[count3]; 
....................                   count4++; 
....................                   if(count4 == 11) 
....................                      break; 
....................                } 
....................               } 
....................           } 
....................  
....................          count1 = count4; 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................          // Copy the name part in the temporary string 
....................           for (count1 = 0; (count1 < 8) && (*(asciiFilename + count1) != '.') && (*(asciiFilename + count1) != 0); count1++) 
05FC6:  CLR     1070
05FC8:  MOV     1070,W4
05FCA:  CP      W4,#8
05FCC:  BRA     GE,5FF6
05FCE:  MOV     D84,W0
05FD0:  ADD     1070,W0
05FD2:  MOV.B   [W0],W4L
05FD4:  XOR.B   #2E,W4L
05FD6:  BRA     Z,5FF6
05FD8:  MOV     D84,W0
05FDA:  ADD     1070,W0
05FDC:  MOV.B   [W0],W5L
05FDE:  SE      W5,W5
05FE0:  CP0     W5
05FE2:  BRA     Z,5FF6
....................           { 
....................               tempString[count1] = *(asciiFilename + count1); 
05FE4:  MOV     #1062,W4
05FE6:  MOV     1070,W3
05FE8:  ADD     W3,W4,W5
05FEA:  MOV     D84,W0
05FEC:  ADD     1070,W0
05FEE:  MOV.B   [W0],[W5]
05FF0:  INC     1070
05FF2:  GOTO    5FC8
....................           } 
....................  
....................          count2 = count1; 
05FF6:  PUSH    1070
05FF8:  POP     1072
....................  
....................          // File the remaining name portion with spaces 
....................           while (count1 < 8) 
05FFA:  MOV     1070,W4
05FFC:  CP      W4,#8
05FFE:  BRA     GE,6012
....................           { 
....................               tempString [count1++] = 0x20; 
06000:  MOV     1070,W0
06002:  INC     1070
06004:  MOV     W0,W5
06006:  MOV     #1062,W4
06008:  ADD     W5,W4,W6
0600A:  MOV.B   #20,W0L
0600C:  MOV.B   W0L,[W6]
0600E:  GOTO    5FFA
....................           } 
....................  
....................          // Copy the extension part in the temporary string 
....................           if (*(asciiFilename + count2) == '.') 
06012:  MOV     D84,W0
06014:  ADD     1072,W0
06016:  MOV.B   [W0],W4L
06018:  XOR.B   #2E,W4L
0601A:  BRA     NZ,6048
....................           { 
....................               count2++; 
0601C:  INC     1072
....................               while ((*(asciiFilename + count2) != 0) && (count1 < FILE_NAME_SIZE_8P3)) 
0601E:  MOV     D84,W0
06020:  ADD     1072,W0
06022:  MOV.B   [W0],W5L
06024:  SE      W5,W5
06026:  CP0     W5
06028:  BRA     Z,6048
0602A:  MOV     1070,W4
0602C:  CP      W4,#B
0602E:  BRA     GE,6048
....................               { 
....................                   tempString[count1++] = *(asciiFilename + count2++); 
06030:  MOV     1070,W0
06032:  INC     1070
06034:  MOV     W0,W5
06036:  MOV     #1062,W4
06038:  ADD     W5,W4,W6
0603A:  MOV     1072,W0
0603C:  INC     1072
0603E:  MOV     D84,W4
06040:  ADD     W0,W4,W0
06042:  MOV.B   [W0],[W6]
06044:  GOTO    601E
....................               } 
....................           } 
....................       } 
....................  
....................       // File the remaining portion with spaces 
....................       while (count1 < FILE_NAME_SIZE_8P3) 
06048:  MOV     1070,W4
0604A:  CP      W4,#B
0604C:  BRA     GE,6060
....................       { 
....................           tempString[count1++] = 0x20; 
0604E:  MOV     1070,W0
06050:  INC     1070
06052:  MOV     W0,W5
06054:  MOV     #1062,W4
06056:  ADD     W5,W4,W6
06058:  MOV.B   #20,W0L
0605A:  MOV.B   W0L,[W6]
0605C:  GOTO    6048
....................       } 
....................  
....................       // Forbidden 
....................       if (tempString[0] == 0x20) 
06060:  MOV.B   1062,W0L
06062:  SE      W0,W0
06064:  MOV     #20,W4
06066:  CP      W4,W0
06068:  BRA     NZ,606E
....................       { 
....................           tempString[0] = '_'; 
0606A:  MOV.B   #5F,W0L
0606C:  MOV.B   W0L,1062
....................       } 
....................  
....................       // point fN2 to short file name 
....................       localFileName = fptr -> name; 
0606E:  MOV     #1C,W0
06070:  ADD     105E,W0
06072:  MOV     W0,1076
....................  
....................       // Copy the formated name in string 
....................       for (count1 = 0; count1 < FILE_NAME_SIZE_8P3; count1++) 
06074:  CLR     1070
06076:  MOV     1070,W4
06078:  CP      W4,#B
0607A:  BRA     GE,60C0
....................       { 
....................           localFileName[count1] = tempString[count1]; 
0607C:  MOV     1070,W0
0607E:  ADD     1076,W0
06080:  MOV     W0,W5
06082:  MOV     #1062,W4
06084:  MOV     1070,W3
06086:  ADD     W3,W4,W0
06088:  MOV.B   [W0],[W5]
....................  
....................          // Convert lower-case to upper-case 
....................          if ((tempString[count1] >= 0x61) && (tempString[count1] <= 0x7A)) 
0608A:  MOV     #1062,W4
0608C:  MOV     1070,W3
0608E:  ADD     W3,W4,W0
06090:  MOV.B   [W0],W5L
06092:  SE      W5,W5
06094:  MOV     #61,W4
06096:  CP      W4,W5
06098:  BRA     GT,60BA
0609A:  MOV     #1062,W4
0609C:  MOV     1070,W3
0609E:  ADD     W3,W4,W0
060A0:  MOV.B   [W0],W5L
060A2:  SE      W5,W5
060A4:  MOV     #7A,W4
060A6:  CP      W4,W5
060A8:  BRA     LT,60BA
....................          { 
....................              localFileName[count1] -= 0x20; 
060AA:  MOV     1070,W0
060AC:  ADD     1076,W0
060AE:  MOV     W0,W5
060B0:  MOV.B   [W5],W4L
060B2:  CLR.B   9
060B4:  MOV     #20,W3
060B6:  SUB     W4,W3,W0
060B8:  MOV.B   W0L,[W5]
....................          } 
060BA:  INC     1070
060BC:  GOTO    6076
....................       } 
....................    } 
....................  
....................    return TRUE; 
060C0:  MOV.B   #1,W0L
060C2:  MOV.B   W0L,0
060C4:  MOV     [--W15],W7
060C6:  MOV     [--W15],W6
060C8:  MOV     [--W15],W5
060CA:  RETURN  
.................... } 
.................... #endif 
....................  
....................  
.................... /************************************************************* 
....................   Function: 
....................     FILE_DIR_NAME_TYPE ValidateChars(BYTE mode) 
....................   Summary: 
....................     Validate the characters in a given file name 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fileName -  The name to be validated 
....................     mode -      Determines if partial string search is allowed 
....................   Return Values: 
....................     TRUE - Name was validated 
....................     FALSE - File name was not valid 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The ValidateChars function will compare characters in a 
....................     specified filename to determine if they're permissable 
....................     in the FAT file system.  Lower-case characters will be 
....................     converted to upper-case.  If the mode argument is specifed 
....................     to be 'TRUE,' partial string search characters are allowed. 
....................   Remarks: 
....................     None. 
....................   *************************************************************/ 
.................... FILE_DIR_NAME_TYPE ValidateChars(BYTE mode) 
*
025CC:  CLR.B   1094
.................... { 
....................    FILE_DIR_NAME_TYPE fileNameType; 
*
025C8:  CLR.B   1091
....................     unsigned short int count1; 
025CA:  CLR     1092
....................    #if defined(SUPPORT_LFN) 
....................    unsigned short int utf16Value; 
....................     unsigned short int count2; 
....................    int      count3; 
....................    #endif 
....................     unsigned char radix = FALSE,asciiValue; 
*
025CE:  CLR.B   1095
....................  
....................    #if defined(SUPPORT_LFN) 
....................  
....................       // Remove the spaces if they are present before the file name 
....................       for (count1 = 0; count1 < fileNameLength; count1++) 
....................       { 
....................            if(utfModeFileName) 
....................          { 
....................             if((utf16Filename[count1] != ' ') && (utf16Filename[count1] != '.')) 
....................             { 
....................                utf16Filename = utf16Filename + count1; 
....................                break; 
....................             } 
....................          } 
....................          else if((asciiFilename[count1] != ' ') && (asciiFilename[count1] != '.')) 
....................          { 
....................             asciiFilename = asciiFilename + count1; 
....................             break; 
....................           } 
....................        } 
....................  
....................        count2 = 0; 
....................  
....................       // Remove the spaces  & dots if they are present after the file name 
....................        for (count3 = fileNameLength - count1 - 1; count3 > 0; count3--) 
....................        { 
....................            if(utfModeFileName) 
....................          { 
....................             if((utf16Filename[count3] != ' ') && (utf16Filename[count3] != '.')) 
....................             { 
....................                break; 
....................             } 
....................          } 
....................          else if((asciiFilename[count3] != ' ') && (asciiFilename[count3] != '.')) 
....................          { 
....................             break; 
....................           } 
....................  
....................           count2++; 
....................        } 
....................  
....................       fileNameLength = fileNameLength - count1 - count2; 
....................  
....................        if(( fileNameLength > MAX_FILE_NAME_LENGTH_LFN ) || (fileNameLength == 0))// 255 
....................            return NAME_ERROR; //long file name 
....................  
....................     #endif 
....................  
....................     // If the string length is greater then 8P3 length, then assume 
....................    // the file name as LFN type provided there are no errors in the 
....................    // below for loop. 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................    { 
....................       if((fileNameLength * 2) > (TOTAL_FILE_SIZE_8P3 * 2)) 
....................       { 
....................          fileNameType = NAME_LFN_TYPE; 
....................       } 
....................       else 
....................       { 
....................          fileNameType = NAME_8P3_UTF16_TYPE; 
....................       } 
....................    } 
....................    else 
....................    #endif 
....................    { 
....................       if(fileNameLength > TOTAL_FILE_SIZE_8P3) 
025D0:  MOV     D86,W4
025D2:  CP      W4,#C
025D4:  BRA     LEU,25DE
....................       { 
....................          fileNameType = NAME_LFN_TYPE; 
025D6:  MOV.B   #6,W0L
025D8:  MOV.B   W0L,1091
....................       } 
025DA:  GOTO    25E0
....................       else 
....................       { 
....................          fileNameType = NAME_8P3_ASCII_CAPS_TYPE; 
025DE:  CLR.B   1091
....................       } 
....................    } 
....................  
....................    for( count1 = 0; count1 < fileNameLength; count1++ ) 
025E0:  CLR     1092
025E2:  MOV     1092,W0
025E4:  MOV     D86,W4
025E6:  CP      W4,W0
025E8:  BRA     LEU,26E8
....................    { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................       { 
....................          utf16Value = utf16Filename[count1]; 
....................           // Characters not valid for either of 8P3 & LFN format 
....................           if (((utf16Value < 0x20) && (utf16Value != 0x05)) || (utf16Value == 0x22) || 
....................             (utf16Value == 0x2F) || (utf16Value == 0x3A) || (utf16Value == 0x3C) || 
....................               (utf16Value == 0x3E) || (utf16Value == 0x5C) || (utf16Value == 0x7C)) 
....................           { 
....................               return NAME_ERROR; 
....................           } 
....................  
....................            // Check for partial string search chars 
....................            if (mode == FALSE) 
....................            { 
....................                if ((utf16Value == '*') || (utf16Value == '?')) 
....................                { 
....................                  return NAME_ERROR; 
....................               } 
....................            } 
....................  
....................          if(fileNameType != NAME_LFN_TYPE) 
....................          { 
....................             // Characters valid for LFN format only 
....................              if ((utf16Value == 0x20) || (utf16Value == 0x2B) || (utf16Value == 0x2C) || 
....................                (utf16Value == 0x3B) || (utf16Value == 0x3D) || (utf16Value == 0x5B) || 
....................                (utf16Value == 0x5D) || ((utf16Value == 0x2E) && (radix == TRUE))) 
....................              { 
....................                fileNameType = NAME_LFN_TYPE; 
....................                continue; 
....................              } 
....................  
....................               // only one radix ('.') character is allowed in 8P3 format, where as 
....................             // multiple radices can be present in LFN format 
....................               if (utf16Filename[count1] == 0x2E) 
....................               { 
....................                   radix = TRUE; 
....................               } 
....................          } 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................          asciiValue = asciiFilename[count1]; 
025EA:  MOV     1092,W0
025EC:  ADD     D84,W0
025EE:  MOV     W0,[W15++]
025F0:  MOV.B   [W0],W0L
025F2:  MOV.B   W0L,1095
025F4:  MOV     [--W15],W0
....................          if(((asciiValue < 0x20) && (asciiValue != 0x05)) || (asciiValue == 0x22) || 
....................             (asciiValue == 0x2F) || (asciiValue == 0x3A) || (asciiValue == 0x3C) || 
....................             (asciiValue == 0x3E) || (asciiValue == 0x5C) || (asciiValue == 0x7C)) 
025F6:  MOV     1094,W4
025F8:  LSR     W4,#8,W4
025FA:  MOV     #20,W3
025FC:  CP.B    W3L,W4L
025FE:  BRA     LEU,2608
02600:  MOV     1094,W4
02602:  LSR     W4,#8,W4
02604:  CP.B    W4L,#5
02606:  BRA     NZ,2640
02608:  MOV     1094,W4
0260A:  LSR     W4,#8,W4
0260C:  XOR.B   #22,W4L
0260E:  BRA     Z,2640
02610:  MOV     1094,W4
02612:  LSR     W4,#8,W4
02614:  XOR.B   #2F,W4L
02616:  BRA     Z,2640
02618:  MOV     1094,W4
0261A:  LSR     W4,#8,W4
0261C:  XOR.B   #3A,W4L
0261E:  BRA     Z,2640
02620:  MOV     1094,W4
02622:  LSR     W4,#8,W4
02624:  XOR.B   #3C,W4L
02626:  BRA     Z,2640
02628:  MOV     1094,W4
0262A:  LSR     W4,#8,W4
0262C:  XOR.B   #3E,W4L
0262E:  BRA     Z,2640
02630:  MOV     1094,W4
02632:  LSR     W4,#8,W4
02634:  XOR.B   #5C,W4L
02636:  BRA     Z,2640
02638:  MOV     1094,W4
0263A:  LSR     W4,#8,W4
0263C:  XOR.B   #7C,W4L
0263E:  BRA     NZ,2646
....................          { 
....................             return NAME_ERROR; 
02640:  MOV.B   #7,W0L
02642:  MOV.B   W0L,0
02644:  BRA     26EA
....................          } 
....................  
....................            // Check for partial string search chars 
....................            if (mode == FALSE) 
02646:  CP0.B   1090
02648:  BRA     NZ,2660
....................            { 
....................                if ((asciiValue == '*') || (asciiValue == '?')) 
0264A:  MOV     1094,W4
0264C:  LSR     W4,#8,W4
0264E:  XOR.B   #2A,W4L
02650:  BRA     Z,265A
02652:  MOV     1094,W4
02654:  LSR     W4,#8,W4
02656:  XOR.B   #3F,W4L
02658:  BRA     NZ,2660
....................                { 
....................                  return NAME_ERROR; 
0265A:  MOV.B   #7,W0L
0265C:  MOV.B   W0L,0
0265E:  BRA     26EA
....................               } 
....................            } 
....................  
....................          if(fileNameType != NAME_LFN_TYPE) 
02660:  MOV     1090,W4
02662:  LSR     W4,#8,W4
02664:  CP.B    W4L,#6
02666:  BRA     Z,26E2
....................          { 
....................             // Characters valid for LFN format only 
....................              if ((asciiValue == 0x20) || (asciiValue == 0x2B) || (asciiValue == 0x2C) || 
....................                 (asciiValue == 0x3B) || (asciiValue == 0x3D) || (asciiValue == 0x5B) || 
....................                  (asciiValue == 0x5D) || ((asciiValue == 0x2E) && (radix == TRUE))) 
02668:  MOV     1094,W4
0266A:  LSR     W4,#8,W4
0266C:  XOR.B   #20,W4L
0266E:  BRA     Z,26AE
02670:  MOV     1094,W4
02672:  LSR     W4,#8,W4
02674:  XOR.B   #2B,W4L
02676:  BRA     Z,26AE
02678:  MOV     1094,W4
0267A:  LSR     W4,#8,W4
0267C:  XOR.B   #2C,W4L
0267E:  BRA     Z,26AE
02680:  MOV     1094,W4
02682:  LSR     W4,#8,W4
02684:  XOR.B   #3B,W4L
02686:  BRA     Z,26AE
02688:  MOV     1094,W4
0268A:  LSR     W4,#8,W4
0268C:  XOR.B   #3D,W4L
0268E:  BRA     Z,26AE
02690:  MOV     1094,W4
02692:  LSR     W4,#8,W4
02694:  XOR.B   #5B,W4L
02696:  BRA     Z,26AE
02698:  MOV     1094,W4
0269A:  LSR     W4,#8,W4
0269C:  XOR.B   #5D,W4L
0269E:  BRA     Z,26AE
026A0:  MOV     1094,W4
026A2:  LSR     W4,#8,W4
026A4:  XOR.B   #2E,W4L
026A6:  BRA     NZ,26B6
026A8:  MOV     1094,W4
026AA:  CP.B    W4L,#1
026AC:  BRA     NZ,26B6
....................              { 
....................                fileNameType = NAME_LFN_TYPE; 
026AE:  MOV.B   #6,W0L
026B0:  MOV.B   W0L,1091
....................                continue; 
026B2:  GOTO    26E2
....................              } 
....................  
....................               // only one radix ('.') character is allowed in 8P3 format, where as 
....................             // multiple radices can be present in LFN format 
....................               if (asciiValue == 0x2E) 
026B6:  MOV     1094,W4
026B8:  LSR     W4,#8,W4
026BA:  XOR.B   #2E,W4L
026BC:  BRA     NZ,26C2
....................               { 
....................                   radix = TRUE; 
026BE:  MOV.B   #1,W0L
026C0:  MOV.B   W0L,1094
....................               } 
....................  
....................             // If the characters are mixed type & are within 8P3 length range 
....................             // then store file type as 8P3 mixed type format 
....................             if(fileNameType != NAME_8P3_ASCII_MIXED_TYPE) 
026C2:  MOV     1090,W4
026C4:  LSR     W4,#8,W4
026C6:  CP.B    W4L,#1
026C8:  BRA     Z,26E2
....................             { 
....................                if((asciiValue >= 0x61) && (asciiValue <= 0x7A)) 
026CA:  MOV     1094,W4
026CC:  LSR     W4,#8,W4
026CE:  MOV     #61,W3
026D0:  CP.B    W3L,W4L
026D2:  BRA     GTU,26E2
026D4:  MOV     1094,W4
026D6:  LSR     W4,#8,W4
026D8:  MOV     #7A,W3
026DA:  CP.B    W3L,W4L
026DC:  BRA     NC,26E2
....................                { 
....................                   fileNameType = NAME_8P3_ASCII_MIXED_TYPE; 
026DE:  MOV.B   #1,W0L
026E0:  MOV.B   W0L,1091
....................                } 
....................             } 
....................          } 
....................       } 
026E2:  INC     1092
026E4:  GOTO    25E2
....................    } 
....................  
....................    return fileNameType; 
026E8:  MOV.B   1091,W0L
026EA:  RETURN  
.................... } 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FSfseek(FSFILE *stream, long offset, int whence) 
....................   Summary: 
....................     Change the current position in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     stream -    Pointer to file structure 
....................     offset -    Offset from base location 
....................     whence - 
....................            - SEEK_SET -  Seek from start of file 
....................            - SEEK_CUR -  Seek from current location 
....................            - SEEK_END -  Seek from end of file (subtract offset) 
....................   Return Values: 
....................     0 -  Operation successful 
....................     -1 - Operation unsuccesful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfseek function will change the current position in the file to 
....................     one specified by the user.  First, an absolute offset is calculated 
....................     using the offset and base location passed in by the user.  Then, the 
....................     position variables are updated, and the sector number that corresponds 
....................     to the new location.  That sector is then loaded.  If the offset 
....................     falls exactly on a cluster boundary, a new cluster will be allocated 
....................     to the file and the position will be set to the first byte of that 
....................     cluster. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int FSfseek(FSFILE *stream, long offset, int whence) 
*
04760:  MOV     W5,[W15++]
04762:  MOV     W6,[W15++]
04764:  MOV     W7,[W15++]
*
04772:  PUSH    102E
04774:  POP     1040
04776:  PUSH    1030
04778:  POP     1042
.................... { 
....................     DWORD    numsector, temp;   // lba of first sector of first cluster 
*
04766:  CLR     1034
04768:  CLR     1036
0476A:  CLR     1038
0476C:  CLR     103A
....................     DISK*   dsk;            // pointer to disk structure 
0476E:  CLR     103C
....................     BYTE   test; 
04770:  CLR.B   103E
....................     long offset2 = offset; 
....................  
....................     dsk = stream->dsk; 
*
0477A:  MOV     102C,W4
0477C:  ADD     W4,#0,W4
0477E:  MOV     W4,W0
04780:  MOV     [W0],[W15++]
04782:  POP     103C
....................  
....................     switch(whence) 
04784:  MOV     1032,W0
04786:  XOR     #1,W0
04788:  BRA     Z,4794
0478A:  XOR     #3,W0
0478C:  BRA     Z,47AC
0478E:  XOR     #2,W0
04790:  BRA     Z,47C6
04792:  BRA     47C6
....................     { 
....................         case SEEK_CUR: 
....................             // Apply the offset to the current position 
....................             offset2 += stream->seek; 
04794:  MOV     #E,W0
04796:  ADD     102C,W0
04798:  MOV     W0,W4
0479A:  MOV     #0,W3
0479C:  MOV     [W4++],[W3++]
0479E:  MOV     [W4++],[W3++]
047A0:  ADD     1040
047A2:  MOV     W1,W0
047A4:  ADDC    1042,W0
047A6:  MOV     W0,1042
....................             break; 
047A8:  GOTO    47CA
....................         case SEEK_END: 
....................             // Apply the offset to the end of the file 
....................             offset2 = stream->size - offset2; 
047AC:  MOV     #12,W0
047AE:  ADD     102C,W0
047B0:  MOV     #A,W4
047B2:  MOV     [W0++],[W4++]
047B4:  MOV     [W0++],[W4++]
047B6:  MOV     1040,W4
047B8:  SUB     W5,W4,W0
047BA:  MOV     W0,1040
047BC:  MOV     1042,W4
047BE:  SUBB    W6,W4,W0
047C0:  MOV     W0,1042
....................             break; 
047C2:  GOTO    47CA
....................         case SEEK_SET: 
....................             // automatically there 
....................         default: 
....................             break; 
047C6:  GOTO    47CA
....................    } 
....................  
.................... #ifdef ALLOW_WRITES 
....................     if (gNeedDataWrite) 
047CA:  CP0.B   8AE
047CC:  BRA     Z,47DE
....................         if (flushData()) 
047CE:  CALL    3170
047D2:  CP0.B   W0L
047D4:  BRA     Z,47DE
....................         { 
....................             FSerrno = CE_WRITE_ERROR; 
047D6:  MOV.B   #9,W0L
047D8:  MOV.B   W0L,8B1
....................             return EOF; 
047DA:  SETM    0
047DC:  BRA     4A1E
....................         } 
.................... #endif 
....................  
....................     // start from the beginning 
....................     temp = stream->cluster; 
047DE:  MOV     #2,W0
047E0:  ADD     102C,W0
047E2:  MOV     #1038,W4
047E4:  MOV     [W0++],[W4++]
047E6:  MOV     [W0++],[W4++]
....................     stream->ccls = temp; 
047E8:  MOV     #6,W0
047EA:  ADD     102C,W0
047EC:  MOV     W0,W5
047EE:  MOV     #1038,W4
047F0:  MOV     [W4++],[W5++]
047F2:  MOV     [W4++],[W5++]
....................  
....................     temp = stream->size; 
047F4:  MOV     #12,W0
047F6:  ADD     102C,W0
047F8:  MOV     #1038,W4
047FA:  MOV     [W0++],[W4++]
047FC:  MOV     [W0++],[W4++]
....................  
....................     if (offset2 > temp) 
047FE:  MOV     103A,W0
04800:  MOV     1042,W4
04802:  CP      W4,W0
04804:  BRA     LT,481C
04806:  BRA     GT,4810
04808:  MOV     1038,W0
0480A:  MOV     1040,W4
0480C:  CP      W4,W0
0480E:  BRA     LEU,481C
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
04810:  MOV.B   #1F,W0L
04812:  MOV.B   W0L,8B1
....................         return (-1);      // past the limits 
04814:  SETM    0
04816:  BRA     4A1E
....................     } 
04818:  GOTO    4A1A
....................     else 
....................     { 
....................         // if we are writing we are no longer at the end 
....................         stream->flags.FileWriteEOF = FALSE; 
0481C:  MOV     #16,W0
0481E:  ADD     102C,W0
04820:  MOV     W0,W5
04822:  MOV     #FB,W4
04824:  AND.B   W4L,[W5],[W5]
....................  
....................         // set the new postion 
....................         stream->seek = offset2; 
04826:  MOV     #E,W0
04828:  ADD     102C,W0
0482A:  MOV     W0,W5
0482C:  MOV     #1040,W4
0482E:  MOV     [W4++],[W5++]
04830:  MOV     [W4++],[W5++]
....................  
....................         // figure out how many sectors 
....................         numsector = offset2 / dsk->sectorSize; 
04832:  MOV     103C,W4
04834:  ADD     W4,#18,W4
04836:  MOV     W4,W0
04838:  MOV     #A,W1
0483A:  MOV     W0,W2
0483C:  REPEAT  #3
0483E:  MOV.B   [W2++],[W1++]
04840:  BCLR.B  43.0
04842:  MOV     1040,W0
04844:  MOV     1042,W1
04846:  MOV     W5,W2
04848:  MOV     W6,W3
0484A:  CALL    45F6
0484E:  MOV     W0,1034
04850:  MOV     W1,1036
....................  
....................         // figure out how many bytes off of the offset 
....................         offset2 = offset2 - (numsector * dsk->sectorSize); 
04852:  MOV     103C,W4
04854:  ADD     W4,#18,W4
04856:  MOV     W4,W0
04858:  MOV     #A,W1
0485A:  MOV     W0,W2
0485C:  REPEAT  #3
0485E:  MOV.B   [W2++],[W1++]
04860:  MOV     1034,W0
04862:  MOV     1036,W1
04864:  MOV     W5,W2
04866:  MOV     W6,W3
04868:  CALL    10CE
0486C:  MOV     1040,W4
0486E:  SUB     W4,W0,W0
04870:  MOV     W0,1040
04872:  MOV     1042,W4
04874:  SUBB    W4,W1,W0
04876:  MOV     W0,1042
....................         stream->pos = offset2; 
04878:  MOV     #C,W0
0487A:  ADD     102C,W0
0487C:  MOV     W0,W5
0487E:  MOV     1040,W4
04880:  MOV     W4,[W5+#0]
....................  
....................         // figure out how many clusters 
....................         temp = numsector / dsk->SecPerClus; 
04882:  MOV     #21,W4
04884:  MOV     103C,W3
04886:  ADD     W3,W4,W0
04888:  MOV     #A,W1
0488A:  MOV     W0,W2
0488C:  MOV.B   [W2++],[W1++]
0488E:  BCLR.B  43.0
04890:  MOV.B   W5L,W2L
04892:  CLR.B   5
04894:  MOV     #0,W3
04896:  MOV     1034,W0
04898:  MOV     1036,W1
0489A:  CALL    1AE6
0489E:  MOV     W0,1038
048A0:  MOV     W1,103A
....................  
....................         // figure out the stranded sectors 
....................         numsector = numsector - (dsk->SecPerClus * temp); 
048A2:  MOV     #21,W4
048A4:  MOV     103C,W3
048A6:  ADD     W3,W4,W0
048A8:  MOV     #A,W1
048AA:  MOV     W0,W2
048AC:  MOV.B   [W2++],[W1++]
048AE:  MOV     #0,W1
048B0:  MOV.B   W5L,W0L
048B2:  CLR.B   1
048B4:  MOV     1038,W2
048B6:  MOV     103A,W3
048B8:  CALL    10CE
048BC:  MOV     1034,W4
048BE:  SUB     W4,W0,W0
048C0:  MOV     W0,1034
048C2:  MOV     1036,W4
048C4:  SUBB    W4,W1,W0
048C6:  MOV     W0,1036
....................         stream->sec = numsector; 
048C8:  MOV     #A,W0
048CA:  ADD     102C,W0
048CC:  MOV     W0,W5
048CE:  MOV     1034,W4
048D0:  MOV     W4,[W5+#0]
....................  
....................         // if we are in the current cluster stay there 
....................         if (temp > 0) 
048D2:  CP0     1038
048D4:  BRA     NZ,48DA
048D6:  CP0     103A
048D8:  BRA     Z,49B4
....................         { 
....................             test = FILEget_next_cluster(stream, temp); 
048DA:  PUSH    102C
048DC:  POP     1050
048DE:  PUSH    1038
048E0:  POP     1052
048E2:  PUSH    103A
048E4:  POP     1054
048E6:  CALL    4674
048EA:  MOV.B   W0L,103E
....................             if (test != CE_GOOD) 
048EC:  CP0.B   103E
048EE:  BRA     Z,49B4
....................             { 
....................                 if (test == CE_FAT_EOF) 
048F0:  MOV     103E,W4
048F2:  XOR.B   #3C,W4L
048F4:  BRA     NZ,49AC
....................                 { 
.................... #ifdef ALLOW_WRITES 
....................                     if (stream->flags.write) 
048F6:  MOV     #16,W0
048F8:  ADD     102C,W0
048FA:  MOV.B   [W0],W4L
048FC:  BTSS    W4.0
048FE:  BRA     4948
....................                     { 
....................                         // load the previous cluster 
....................                         stream->ccls = stream->cluster; 
04900:  MOV     #6,W0
04902:  ADD     102C,W0
04904:  MOV     W0,W5
04906:  MOV     #2,W0
04908:  ADD     102C,W0
0490A:  MOV     [W0++],[W5++]
0490C:  MOV     [W0++],[W5++]
....................                         // Don't perform this operation if there's only one cluster 
....................                         if (temp != 1) 
0490E:  MOV     1038,W4
04910:  CP      W4,#1
04912:  BRA     NZ,4918
04914:  CP0     103A
04916:  BRA     Z,492E
....................                         test = FILEget_next_cluster(stream, temp - 1); 
04918:  MOV     1038,W4
0491A:  SUB     W4,#1,W5
0491C:  MOV     103A,W4
0491E:  SUBB    W4,#0,W6
04920:  PUSH    102C
04922:  POP     1050
04924:  MOV     W5,1052
04926:  MOV     W6,1054
04928:  CALL    4674
0492C:  MOV.B   W0L,103E
....................                         if (FILEallocate_new_cluster(stream, 0) != CE_GOOD) 
0492E:  CLR.B   104E
04930:  PUSH    102C
04932:  POP     104C
04934:  CALL    3E9C
04938:  CP0.B   W0L
0493A:  BRA     Z,4944
....................                         { 
....................                             FSerrno = CE_COULD_NOT_GET_CLUSTER; 
0493C:  MOV.B   #F,W0L
0493E:  MOV.B   W0L,8B1
....................                             return -1; 
04940:  SETM    0
04942:  BRA     4A1E
....................                         } 
....................                         // sec and pos should already be zero 
....................                     } 
04944:  GOTO    49A8
....................                     else 
....................                     { 
.................... #endif 
....................                         stream->ccls = stream->cluster; 
04948:  MOV     #6,W0
0494A:  ADD     102C,W0
0494C:  MOV     W0,W5
0494E:  MOV     #2,W0
04950:  ADD     102C,W0
04952:  MOV     [W0++],[W5++]
04954:  MOV     [W0++],[W5++]
....................                         test = FILEget_next_cluster(stream, temp - 1); 
04956:  MOV     1038,W4
04958:  SUB     W4,#1,W5
0495A:  MOV     103A,W4
0495C:  SUBB    W4,#0,W6
0495E:  PUSH    102C
04960:  POP     1050
04962:  MOV     W5,1052
04964:  MOV     W6,1054
04966:  CALL    4674
0496A:  MOV.B   W0L,103E
....................                         if (test != CE_GOOD) 
0496C:  CP0.B   103E
0496E:  BRA     Z,4978
....................                         { 
....................                             FSerrno = CE_COULD_NOT_GET_CLUSTER; 
04970:  MOV.B   #F,W0L
04972:  MOV.B   W0L,8B1
....................                             return (-1); 
04974:  SETM    0
04976:  BRA     4A1E
....................                         } 
....................                         stream->pos = dsk->sectorSize; 
04978:  MOV     #C,W0
0497A:  ADD     102C,W0
0497C:  MOV     W0,W5
0497E:  MOV     103C,W4
04980:  ADD     W4,#18,W4
04982:  MOV     W4,W0
04984:  MOV     #C,W1
04986:  MOV     W0,W2
04988:  REPEAT  #3
0498A:  MOV.B   [W2++],[W1++]
0498C:  MOV     W6,[W5]
....................                         stream->sec = dsk->SecPerClus - 1; 
0498E:  MOV     #A,W0
04990:  ADD     102C,W0
04992:  MOV     W0,W5
04994:  MOV     #21,W4
04996:  MOV     103C,W3
04998:  ADD     W3,W4,W0
0499A:  MOV     #C,W1
0499C:  MOV     W0,W2
0499E:  MOV.B   [W2++],[W1++]
049A0:  ZE      W6,W6
049A2:  CLR.B   D
049A4:  SUB     W6,#1,W0
049A6:  MOV     W0,[W5]
.................... #ifdef ALLOW_WRITES 
....................                     } 
.................... #endif 
....................                 } 
049A8:  GOTO    49B4
....................                 else 
....................                 { 
....................                     FSerrno = CE_COULD_NOT_GET_CLUSTER; 
049AC:  MOV.B   #F,W0L
049AE:  MOV.B   W0L,8B1
....................                     return (-1);   // past the limits 
049B0:  SETM    0
049B2:  BRA     4A1E
....................                 } 
....................             } 
....................         } 
....................  
....................         // Determine the lba of the selected sector and load 
....................         temp = Cluster2Sector(dsk,stream->ccls); 
049B4:  MOV     #6,W0
049B6:  ADD     102C,W0
049B8:  MOV     #A,W4
049BA:  MOV     [W0++],[W4++]
049BC:  MOV     [W0++],[W4++]
049BE:  PUSH    103C
049C0:  POP     10B0
049C2:  MOV     W5,10B2
049C4:  MOV     W6,10B4
049C6:  CALL    308C
049CA:  MOV     W0,1038
049CC:  MOV     W1,103A
....................  
....................         // now the extra sectors 
....................         numsector = stream->sec; 
049CE:  MOV     #A,W0
049D0:  ADD     102C,W0
049D2:  MOV     [W0],[W15++]
049D4:  POP     1034
049D6:  CLR     1036
....................         temp += numsector; 
049D8:  MOV     1038,W0
049DA:  ADD     1034,W0
049DC:  MOV     W0,1038
049DE:  MOV     1036,W4
049E0:  MOV     103A,W3
049E2:  ADDC    W3,W4,W0
049E4:  MOV     W0,103A
....................  
....................         gBufferOwner = NULL; 
049E6:  CLR     8A8
....................         gBufferZeroed = FALSE; 
049E8:  CLR.B   8B0
....................         if( !MDD_SectorRead(temp, dsk->buffer) ) 
049EA:  MOV     103C,W4
049EC:  ADD     W4,#0,W4
049EE:  MOV     W4,W0
049F0:  MOV     #A,W1
049F2:  MOV     W0,W2
049F4:  REPEAT  #1
049F6:  MOV.B   [W2++],[W1++]
049F8:  PUSH    1038
049FA:  POP     10F2
049FC:  PUSH    103A
049FE:  POP     10F4
04A00:  MOV     W5,10F6
04A02:  CALL    1722
04A06:  CP0.B   W0L
04A08:  BRA     NZ,4A12
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
04A0A:  MOV.B   #1B,W0L
04A0C:  MOV.B   W0L,8B1
....................             return (-1);   // Bad read 
04A0E:  SETM    0
04A10:  BRA     4A1E
....................         } 
....................         gLastDataSectorRead = temp; 
04A12:  PUSH    1038
04A14:  POP     8AA
04A16:  PUSH    103A
04A18:  POP     8AC
....................     } 
....................  
....................     FSerrno = CE_GOOD; 
04A1A:  CLR.B   8B1
....................  
....................     return (0); 
04A1C:  CLR     0
04A1E:  MOV     [--W15],W7
04A20:  MOV     [--W15],W6
04A22:  MOV     [--W15],W5
04A24:  RETURN  
.................... } 
....................  
....................  
.................... // FSfopenpgm, FSremovepgm, and FSrenamepgm will only work on PIC18s 
.................... #ifdef __18CXX 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... /***************************************************************** 
....................   Function: 
....................     int FSrenamepgm(const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the file with the ascii ROM string(PIC18) 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file (in ROM) 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -  File renamed successfully 
....................     -1 - File could not be renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the file with the ascii ROM string(PIC18).The Fsrenamepgm 
....................     function will copy the rom fileName specified by the user into a 
....................     RAM array and pass that array into the FSrename function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   *****************************************************************/ 
....................  
.................... int FSrenamepgm (const rom char * fileName, FSFILE * fo) 
.................... { 
....................    #if defined(SUPPORT_LFN) 
....................  
....................       char tempArray[257]; 
....................       unsigned short int count; 
....................    #else 
....................  
....................       char   tempArray[13]; 
....................  
....................        BYTE count; 
....................    #endif 
....................  
....................  
....................     *fileName; 
....................     for(count = 0; count < sizeof(tempArray); count++) 
....................     { 
....................         _asm TBLRDPOSTINC _endasm 
....................         tempArray[count] = TABLAT; 
....................     }//end for(...) 
....................  
....................     return FSrename (tempArray, fo); 
.................... } 
.................... #endif 
....................  
.................... /****************************************************************************** 
....................   Function: 
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode) 
....................   Summary: 
....................     Opens a file on PIC18 Microcontrollers where 'fileName' ROM string is given 
....................     in Ascii format. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to be opened (ROM) 
....................     mode -      The mode the file will be opened in (ROM) 
....................   Return Values: 
....................     FSFILE * - A pointer to the file object 
....................     NULL -     File could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file on PIC18 Microcontrollers where 'fileName' ROM string 
....................     is given in Ascii format.The FSfopenpgm function will copy a PIC18 ROM fileName and 
....................     mode argument into RAM arrays, and then pass those arrays to the FSfopen function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   ******************************************************************************/ 
....................  
.................... FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode) 
.................... { 
....................    #if defined(SUPPORT_LFN) 
....................        char tempArray[257]; 
....................        unsigned short int count = 0; 
....................     #else 
....................        char tempArray[13]; 
....................        BYTE count = 0; 
....................    #endif 
....................     char M[2]; 
....................  
....................     for(;;) 
....................    { 
....................       tempArray[count] = fileName[count]; 
....................       if(tempArray[count]) 
....................          count++; 
....................       else 
....................          break; 
....................    } 
....................  
....................     for (count = 0; count < 2; count++) 
....................     { 
....................         M[count] = *(mode + count); 
....................     } 
....................  
....................     return FSfopen(tempArray, M); 
.................... } 
....................  
.................... /************************************************************* 
....................   Function: 
....................     int FSremovepgm (const rom char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC18 device 
....................   Conditions: 
....................     File not opened; file exists 
....................   Input: 
....................     fileName -  The name of the file to be deleted (ROM) 
....................   Return Values: 
....................     0 -  File was removed successfully 
....................     -1 - File could not be removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC18 device.The FSremovepgm function will copy a 
....................     PIC18 ROM fileName argument into a RAM array, and then pass that array 
....................     to the FSremove function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   *************************************************************/ 
.................... #ifdef ALLOW_WRITES 
.................... int FSremovepgm (const rom char * fileName) 
.................... { 
....................    #ifdef SUPPORT_LFN 
....................       char tempArray[257]; 
....................       unsigned short int count; 
....................    #else 
....................  
....................       char   tempArray[13]; 
....................  
....................        BYTE count; 
....................    #endif 
....................  
....................  
....................     *fileName; 
....................     for(count = 0; count < sizeof(tempArray); count++) 
....................     { 
....................         _asm TBLRDPOSTINC _endasm 
....................         tempArray[count] = TABLAT; 
....................     }//end for(...) 
....................  
....................     return FSremove (tempArray); 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************************** 
....................   Function: 
....................     int FindFirstpgm (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Find a file named with a ROM string on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName -  The name of the file to be found (ROM) 
....................     attr -      The attributes of the file to be found 
....................     rec -       Pointer to a search record to store the file info in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the given parameters was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirstpgm call on passed SearchRec object 
....................     will be lost.The FSerrno variable will be changed. 
....................   Description: 
....................     This function finds a file named with 'fileName' on PIC18. The FindFirstpgm 
....................     function will copy a PIC18 ROM fileName argument into a RAM array, and then 
....................     pass that array to the FindFirst function. 
....................   Remarks: 
....................     Call FindFirstpgm or FindFirst before calling FindNext. 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************************/ 
.................... #ifdef ALLOW_FILESEARCH 
.................... int FindFirstpgm (const rom char * fileName, unsigned int attr, SearchRec * rec) 
.................... { 
....................    #if defined(SUPPORT_LFN) 
....................  
....................       char tempArray[257]; 
....................       unsigned short int count; 
....................    #else 
....................  
....................       char   tempArray[13]; 
....................  
....................        BYTE count; 
....................    #endif 
....................  
....................  
....................     *fileName; 
....................     for(count = 0; count < sizeof(tempArray); count++) 
....................     { 
....................         _asm TBLRDPOSTINC _endasm 
....................         tempArray[count] = TABLAT; 
....................     }//end for 
....................  
....................     return FindFirst (tempArray,attr,rec); 
.................... } 
.................... #endif 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /*********************************************** 
....................   Function: 
....................     DWORD ReadFAT (DISK *dsk, DWORD ccls) 
....................   Summary: 
....................     Read the next entry from the FAT 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -   The disk structure 
....................     ccls -  The current cluster 
....................   Return: 
....................     DWORD - The next cluster in a file chain 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The ReadFAT function will read the FAT and 
....................     determine the next cluster value after the 
....................     cluster specified by 'ccls.' Note that the 
....................     FAT sector that is read is stored in the 
....................     global FAT cache buffer. 
....................   Remarks: 
....................     None. 
....................   ***********************************************/ 
....................  
.................... DWORD ReadFAT (DISK *dsk, DWORD ccls) 
*
02ECC:  MOV     W5,[W15++]
02ECE:  MOV     W6,[W15++]
02ED0:  MOV     W7,[W15++]
02ED2:  MOV     W8,[W15++]
*
02EDE:  CLR     10B2
02EE0:  CLR     10B4
.................... { 
....................     BYTE q; 
*
02ED4:  CLR.B   10A8
....................     DWORD p, l;  // "l" is the sector Address 
02ED6:  CLR     10AA
02ED8:  CLR     10AC
02EDA:  CLR     10AE
02EDC:  CLR     10B0
....................     DWORD c = 0, d, ClusterFailValue,LastClusterLimit;   // ClusterEntries 
*
02EE2:  CLR     10B6
02EE4:  CLR     10B8
02EE6:  CLR     10BA
02EE8:  CLR     10BC
02EEA:  CLR     10BE
02EEC:  CLR     10C0
....................  
....................     gBufferZeroed = FALSE; 
02EEE:  CLR.B   8B0
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
02EF0:  MOV     #22,W4
02EF2:  MOV     10A2,W3
02EF4:  ADD     W3,W4,W0
02EF6:  MOV     #A,W1
02EF8:  MOV     W0,W2
02EFA:  MOV.B   [W2++],[W1++]
02EFC:  MOV.B   W5L,W0L
02EFE:  CLR.B   1
02F00:  XOR     #3,W0
02F02:  BRA     Z,2F0A
02F04:  XOR     #1,W0
02F06:  BRA     Z,2F2E
02F08:  BRA     2F2E
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             p = (DWORD)ccls * 4; 
02F0A:  PUSH    10A4
02F0C:  POP     10AA
02F0E:  PUSH    10A6
02F10:  POP     10AC
02F12:  SL      10AA
02F14:  RLC     10AC
02F16:  SL      10AA
02F18:  RLC     10AC
....................             q = 0; // "q" not used for FAT32, only initialized to remove a warning 
02F1A:  CLR.B   10A8
....................             ClusterFailValue = CLUSTER_FAIL_FAT32; 
02F1C:  SETM    10BA
02F1E:  MOV     #FFF,W4
02F20:  MOV     W4,10BC
....................             LastClusterLimit = LAST_CLUSTER_FAT32; 
02F22:  MOV     #FFF8,W4
02F24:  MOV     W4,10BE
02F26:  MOV     #FFF,W4
02F28:  MOV     W4,10C0
....................             break; 
02F2A:  GOTO    2F4A
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
....................             p = (DWORD) ccls *3;  // Mulby1.5 to find cluster pos in FAT 
....................             q = p&1; 
....................             p >>= 1; 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
....................             LastClusterLimit = LAST_CLUSTER_FAT12; 
....................             break; 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             p = (DWORD)ccls *2;     // Mulby 2 to find cluster pos in FAT 
02F2E:  PUSH    10A4
02F30:  POP     10AA
02F32:  PUSH    10A6
02F34:  POP     10AC
02F36:  SL      10AA
02F38:  RLC     10AC
....................             q = 0; // "q" not used for FAT16, only initialized to remove a warning 
02F3A:  CLR.B   10A8
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
02F3C:  SETM    10BA
02F3E:  CLR     10BC
....................             LastClusterLimit = LAST_CLUSTER_FAT16; 
02F40:  MOV     #FFF8,W4
02F42:  MOV     W4,10BE
02F44:  CLR     10C0
....................             break; 
02F46:  GOTO    2F4A
....................     } 
....................  
....................     l = dsk->fat + (p / dsk->sectorSize);     // 
02F4A:  MOV     10A2,W4
02F4C:  ADD     W4,#6,W4
02F4E:  MOV     W4,W0
02F50:  MOV     #A,W1
02F52:  MOV     W0,W2
02F54:  REPEAT  #3
02F56:  MOV.B   [W2++],[W1++]
02F58:  MOV     10A2,W4
02F5A:  ADD     W4,#18,W4
02F5C:  MOV     W4,W0
02F5E:  MOV     #E,W1
02F60:  MOV     W0,W2
02F62:  REPEAT  #3
02F64:  MOV.B   [W2++],[W1++]
02F66:  BCLR.B  43.0
02F68:  MOV     10AA,W0
02F6A:  MOV     10AC,W1
02F6C:  MOV     W7,W2
02F6E:  MOV     W8,W3
02F70:  CALL    1AE6
02F74:  ADD     W0,W5,W0
02F76:  MOV     W0,10AE
02F78:  ADDC    W1,W6,W0
02F7A:  MOV     W0,10B0
....................     p &= dsk->sectorSize - 1;                 // Restrict 'p' within the FATbuffer size 
02F7C:  MOV     10A2,W4
02F7E:  ADD     W4,#18,W4
02F80:  MOV     W4,W0
02F82:  MOV     #A,W1
02F84:  MOV     W0,W2
02F86:  REPEAT  #3
02F88:  MOV.B   [W2++],[W1++]
02F8A:  SUB     W5,#1,W0
02F8C:  SUBB    W6,#0,W1
02F8E:  AND     10AA
02F90:  MOV     W1,W0
02F92:  AND     10AC
....................  
....................     // Check if the appropriate FAT sector is already loaded 
....................     if (gLastFATSectorRead == l) 
02F94:  MOV     8A4,W0
02F96:  CP      10AE
02F98:  BRA     NZ,2FDC
02F9A:  MOV     8A6,W0
02F9C:  CP      10B0
02F9E:  BRA     NZ,2FDC
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         if (dsk->type == FAT32) 
02FA0:  MOV     #22,W4
02FA2:  MOV     10A2,W3
02FA4:  ADD     W3,W4,W0
02FA6:  MOV     #A,W1
02FA8:  MOV     W0,W2
02FAA:  MOV.B   [W2++],[W1++]
02FAC:  CP.B    W5L,#3
02FAE:  BRA     NZ,2FBE
....................             c = RAMreadD (gFATBuffer, p); 
02FB0:  MOV     #B60,W0
02FB2:  ADD     10AA,W0
02FB4:  MOV     #10B2,W4
02FB6:  MOV     [W0++],[W4++]
02FB8:  MOV     [W0++],[W4++]
02FBA:  GOTO    2FD8
....................         else 
.................... #endif 
....................             if(dsk->type == FAT16) 
02FBE:  MOV     #22,W4
02FC0:  MOV     10A2,W3
02FC2:  ADD     W3,W4,W0
02FC4:  MOV     #A,W1
02FC6:  MOV     W0,W2
02FC8:  MOV.B   [W2++],[W1++]
02FCA:  CP.B    W5L,#2
02FCC:  BRA     NZ,2FD8
....................                 c = RAMreadW (gFATBuffer, p); 
02FCE:  MOV     #B60,W0
02FD0:  ADD     10AA,W0
02FD2:  MOV     [W0],[W15++]
02FD4:  POP     10B2
02FD6:  CLR     10B4
.................... #ifdef SUPPORT_FAT12 
....................             else if(dsk->type == FAT12) 
....................             { 
....................                 c = RAMread (gFATBuffer, p); 
....................                 if (q) 
....................                 { 
....................                     c >>= 4; 
....................                 } 
....................                 // Check if the MSB is across the sector boundry 
....................                 p = (p +1) & (dsk->sectorSize-1); 
....................                 if (p == 0) 
....................                 { 
....................                     // Start by writing the sector we just worked on to the card 
....................                     // if we need to 
.................... #ifdef ALLOW_WRITES 
....................                     if (gNeedFATWrite) 
....................                         if(WriteFAT (dsk, 0, 0, TRUE)) 
....................                             return ClusterFailValue; 
.................... #endif 
....................                     if (!MDD_SectorRead (l+1, gFATBuffer)) 
....................                     { 
....................                         gLastFATSectorRead = 0xFFFF; 
....................                         return ClusterFailValue; 
....................                     } 
....................                     else 
....................                     { 
....................                         gLastFATSectorRead = l +1; 
....................                     } 
....................                 } 
....................                 d = RAMread (gFATBuffer, p); 
....................                 if (q) 
....................                 { 
....................                     c += (d <<4); 
....................                 } 
....................                 else 
....................                 { 
....................                     c += ((d & 0x0F)<<8); 
....................                 } 
....................             } 
.................... #endif 
....................         } 
02FD8:  GOTO    3064
....................         else 
....................         { 
....................             // If there's a currently open FAT sector, 
....................             // write it back before reading into the buffer 
.................... #ifdef ALLOW_WRITES 
....................             if (gNeedFATWrite) 
02FDC:  CP0.B   899
02FDE:  BRA     Z,3002
....................             { 
....................                 if(WriteFAT (dsk, 0, 0, TRUE)) 
02FE0:  MOV.B   #1,W0L
02FE2:  MOV.B   W0L,10D2
02FE4:  PUSH    10A2
02FE6:  POP     10C8
02FE8:  CLR     10CA
02FEA:  CLR     10CC
02FEC:  CLR     10CE
02FEE:  CLR     10D0
02FF0:  CALL    2C18
02FF4:  CP0     W0
02FF6:  BRA     NZ,2FFC
02FF8:  CP0     W1
02FFA:  BRA     Z,3002
....................                     return ClusterFailValue; 
02FFC:  MOV     10BA,W0
02FFE:  MOV     10BC,W1
03000:  BRA     3082
....................             } 
.................... #endif 
....................             if (!MDD_SectorRead (l, gFATBuffer)) 
03002:  PUSH    10AE
03004:  POP     10F2
03006:  PUSH    10B0
03008:  POP     10F4
0300A:  MOV     #B60,W4
0300C:  MOV     W4,10F6
0300E:  CALL    1722
03012:  CP0.B   W0L
03014:  BRA     NZ,3024
....................             { 
....................                 gLastFATSectorRead = 0xFFFF;  // Note: It is Sector not Cluster. 
03016:  SETM    8A4
03018:  CLR     8A6
....................                 return ClusterFailValue; 
0301A:  MOV     10BA,W0
0301C:  MOV     10BC,W1
0301E:  BRA     3082
....................             } 
03020:  GOTO    3064
....................             else 
....................             { 
....................                 gLastFATSectorRead = l; 
03024:  PUSH    10AE
03026:  POP     8A4
03028:  PUSH    10B0
0302A:  POP     8A6
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................                 if (dsk->type == FAT32) 
0302C:  MOV     #22,W4
0302E:  MOV     10A2,W3
03030:  ADD     W3,W4,W0
03032:  MOV     #A,W1
03034:  MOV     W0,W2
03036:  MOV.B   [W2++],[W1++]
03038:  CP.B    W5L,#3
0303A:  BRA     NZ,304A
....................                     c = RAMreadD (gFATBuffer, p); 
0303C:  MOV     #B60,W0
0303E:  ADD     10AA,W0
03040:  MOV     #10B2,W4
03042:  MOV     [W0++],[W4++]
03044:  MOV     [W0++],[W4++]
03046:  GOTO    3064
....................                 else 
.................... #endif 
....................                     if(dsk->type == FAT16) 
0304A:  MOV     #22,W4
0304C:  MOV     10A2,W3
0304E:  ADD     W3,W4,W0
03050:  MOV     #A,W1
03052:  MOV     W0,W2
03054:  MOV.B   [W2++],[W1++]
03056:  CP.B    W5L,#2
03058:  BRA     NZ,3064
....................                         c = RAMreadW (gFATBuffer, p); 
0305A:  MOV     #B60,W0
0305C:  ADD     10AA,W0
0305E:  MOV     [W0],[W15++]
03060:  POP     10B2
03062:  CLR     10B4
.................... #ifdef SUPPORT_FAT12 
....................                     else if (dsk->type == FAT12) 
....................                     { 
....................                         c = RAMread (gFATBuffer, p); 
....................                         if (q) 
....................                         { 
....................                             c >>= 4; 
....................                         } 
....................                         p = (p +1) & (dsk->sectorSize-1); 
....................                         d = RAMread (gFATBuffer, p); 
....................                         if (q) 
....................                         { 
....................                             c += (d <<4); 
....................                         } 
....................                         else 
....................                         { 
....................                             c += ((d & 0x0F)<<8); 
....................                         } 
....................                     } 
.................... #endif 
....................             } 
....................     } 
....................  
....................     // Normalize it so 0xFFFF is an error 
....................     if (c >= LastClusterLimit) 
03064:  MOV     10C0,W0
03066:  MOV     10B4,W4
03068:  CP      W4,W0
0306A:  BRA     NC,307E
0306C:  BRA     GTU,3076
0306E:  MOV     10BE,W0
03070:  MOV     10B2,W4
03072:  CP      W4,W0
03074:  BRA     NC,307E
....................         c = LastClusterLimit; 
03076:  PUSH    10BE
03078:  POP     10B2
0307A:  PUSH    10C0
0307C:  POP     10B4
....................  
....................    return c; 
0307E:  MOV     10B2,W0
03080:  MOV     10B4,W1
03082:  MOV     [--W15],W8
03084:  MOV     [--W15],W7
03086:  MOV     [--W15],W6
03088:  MOV     [--W15],W5
0308A:  RETURN  
.................... }   // ReadFAT 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Function: 
....................     WORD WriteFAT (DISK *dsk, DWORD ccls, WORD value, BYTE forceWrite) 
....................   Summary: 
....................     Write an entry to the FAT 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -         The disk structure 
....................     ccls -        The current cluster 
....................     value -       The value to write in 
....................     forceWrite -  Force the function to write the current FAT sector 
....................   Return: 
....................     0 -    The FAT write was successful 
....................     FAIL - The FAT could not be written 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The WriteFAT function writes an entry to the FAT.  If the function 
....................     is called and the 'forceWrite' argument is TRUE, the function will 
....................     write the existing FAT data to the device.  Otherwise, the function 
....................     will replace a single entry in the FAT buffer (indicated by 'ccls') 
....................     with a new value (indicated by 'value.') 
....................   Remarks: 
....................     None. 
....................   ****************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... DWORD WriteFAT (DISK *dsk, DWORD ccls, DWORD value, BYTE forceWrite) 
*
02C18:  MOV     W5,[W15++]
02C1A:  MOV     W6,[W15++]
02C1C:  MOV     W7,[W15++]
02C1E:  MOV     W8,[W15++]
.................... { 
....................     BYTE i, q, c; 
02C20:  CLR.B   10D3
02C22:  CLR.B   10D4
02C24:  CLR.B   10D5
....................     DWORD p, li, l, ClusterFailValue; 
02C26:  CLR     10D6
02C28:  CLR     10D8
02C2A:  CLR     10DA
02C2C:  CLR     10DC
02C2E:  CLR     10DE
02C30:  CLR     10E0
02C32:  CLR     10E2
02C34:  CLR     10E4
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................     if ((dsk->type != FAT32) && (dsk->type != FAT16) && (dsk->type != FAT12)) 
02C36:  MOV     #22,W4
02C38:  MOV     10C8,W3
02C3A:  ADD     W3,W4,W0
02C3C:  MOV     #A,W1
02C3E:  MOV     W0,W2
02C40:  MOV.B   [W2++],[W1++]
02C42:  CP.B    W5L,#3
02C44:  BRA     Z,2C6C
02C46:  MOV     #22,W4
02C48:  MOV     10C8,W3
02C4A:  ADD     W3,W4,W0
02C4C:  MOV     #A,W1
02C4E:  MOV     W0,W2
02C50:  MOV.B   [W2++],[W1++]
02C52:  CP.B    W5L,#2
02C54:  BRA     Z,2C6C
02C56:  MOV     #22,W4
02C58:  MOV     10C8,W3
02C5A:  ADD     W3,W4,W0
02C5C:  MOV     #A,W1
02C5E:  MOV     W0,W2
02C60:  MOV.B   [W2++],[W1++]
02C62:  CP.B    W5L,#1
02C64:  BRA     Z,2C6C
....................         return CLUSTER_FAIL_FAT32; 
02C66:  MOV     #FFFF,W0
02C68:  MOV     #FFF,W1
02C6A:  BRA     2EC2
.................... #else // If FAT32 support not enabled 
....................     if ((dsk->type != FAT16) && (dsk->type != FAT12)) 
....................         return CLUSTER_FAIL_FAT16; 
.................... #endif 
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
02C6C:  MOV     #22,W4
02C6E:  MOV     10C8,W3
02C70:  ADD     W3,W4,W0
02C72:  MOV     #A,W1
02C74:  MOV     W0,W2
02C76:  MOV.B   [W2++],[W1++]
02C78:  MOV.B   W5L,W0L
02C7A:  CLR.B   1
02C7C:  XOR     #3,W0
02C7E:  BRA     Z,2C86
02C80:  XOR     #1,W0
02C82:  BRA     Z,2C90
02C84:  BRA     2C90
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             ClusterFailValue = CLUSTER_FAIL_FAT32; 
02C86:  SETM    10E2
02C88:  MOV     #FFF,W4
02C8A:  MOV     W4,10E4
....................             break; 
02C8C:  GOTO    2C98
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
02C90:  SETM    10E2
02C92:  CLR     10E4
....................             break; 
02C94:  GOTO    2C98
....................     } 
....................  
....................     gBufferZeroed = FALSE; 
02C98:  CLR.B   8B0
....................  
....................     // The only purpose for calling this function with forceWrite 
....................     // is to write the current FAT sector to the card 
....................     if (forceWrite) 
02C9A:  CP0.B   10D2
02C9C:  BRA     Z,2D00
....................     { 
....................         for (i = 0, li = gLastFATSectorRead; i < dsk->fatcopy; i++, li += dsk->fatsize) 
02C9E:  CLR.B   10D3
02CA0:  PUSH    8A4
02CA2:  POP     10DA
02CA4:  PUSH    8A6
02CA6:  POP     10DC
02CA8:  MOV     #20,W4
02CAA:  MOV     10C8,W3
02CAC:  ADD     W3,W4,W0
02CAE:  MOV     #A,W1
02CB0:  MOV     W0,W2
02CB2:  MOV.B   [W2++],[W1++]
02CB4:  MOV     10D2,W4
02CB6:  LSR     W4,#8,W4
02CB8:  CP.B    W4L,W5L
02CBA:  BRA     C,2CF8
....................         { 
....................             if (!MDD_SectorWrite (li, gFATBuffer, FALSE)) 
02CBC:  CLR.B   10F8
02CBE:  PUSH    10DA
02CC0:  POP     10F2
02CC2:  PUSH    10DC
02CC4:  POP     10F4
02CC6:  MOV     #B60,W4
02CC8:  MOV     W4,10F6
02CCA:  CALL    2BBE
02CCE:  CP0.B   W0L
02CD0:  BRA     NZ,2CD8
....................             { 
....................                 return ClusterFailValue; 
02CD2:  MOV     10E2,W0
02CD4:  MOV     10E4,W1
02CD6:  BRA     2EC2
....................             } 
02CD8:  MOV.B   10D3,W0L
02CDA:  INC.B   10D3
02CDC:  MOV     10C8,W4
02CDE:  ADD     W4,#1C,W4
02CE0:  MOV     W4,W0
02CE2:  MOV     #A,W1
02CE4:  MOV     W0,W2
02CE6:  REPEAT  #3
02CE8:  MOV.B   [W2++],[W1++]
02CEA:  MOV     W5,W0
02CEC:  ADD     10DA
02CEE:  MOV     W6,W0
02CF0:  ADDC    10DC,W0
02CF2:  MOV     W0,10DC
02CF4:  GOTO    2CA8
....................         } 
....................  
....................         gNeedFATWrite = FALSE; 
02CF8:  CLR.B   899
....................  
....................         return 0; 
02CFA:  MOV     #0,W0
02CFC:  MOV     #0,W1
02CFE:  BRA     2EC2
....................     } 
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
02D00:  MOV     #22,W4
02D02:  MOV     10C8,W3
02D04:  ADD     W3,W4,W0
02D06:  MOV     #A,W1
02D08:  MOV     W0,W2
02D0A:  MOV.B   [W2++],[W1++]
02D0C:  MOV.B   W5L,W0L
02D0E:  CLR.B   1
02D10:  XOR     #3,W0
02D12:  BRA     Z,2D1A
02D14:  XOR     #1,W0
02D16:  BRA     Z,2D30
02D18:  BRA     2D30
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             p = (DWORD)ccls *4;   // "p" is the position in "gFATBuffer" for corresponding cluster. 
02D1A:  PUSH    10CA
02D1C:  POP     10D6
02D1E:  PUSH    10CC
02D20:  POP     10D8
02D22:  SL      10D6
02D24:  RLC     10D8
02D26:  SL      10D6
02D28:  RLC     10D8
....................             q = 0;      // "q" not used for FAT32, only initialized to remove a warning 
02D2A:  CLR.B   10D4
....................             break; 
02D2C:  GOTO    2D42
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
....................             p = (DWORD) ccls * 3; // "p" is the position in "gFATBuffer" for corresponding cluster. 
....................             q = p & 1;   // Odd or even? 
....................             p >>= 1; 
....................             break; 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             p = (DWORD) ccls *2;   // "p" is the position in "gFATBuffer" for corresponding cluster. 
02D30:  PUSH    10CA
02D32:  POP     10D6
02D34:  PUSH    10CC
02D36:  POP     10D8
02D38:  SL      10D6
02D3A:  RLC     10D8
....................             q = 0;      // "q" not used for FAT16, only initialized to remove a warning 
02D3C:  CLR.B   10D4
....................             break; 
02D3E:  GOTO    2D42
....................     } 
....................  
....................     l = dsk->fat + (p / dsk->sectorSize);     // 
02D42:  MOV     10C8,W4
02D44:  ADD     W4,#6,W4
02D46:  MOV     W4,W0
02D48:  MOV     #A,W1
02D4A:  MOV     W0,W2
02D4C:  REPEAT  #3
02D4E:  MOV.B   [W2++],[W1++]
02D50:  MOV     10C8,W4
02D52:  ADD     W4,#18,W4
02D54:  MOV     W4,W0
02D56:  MOV     #E,W1
02D58:  MOV     W0,W2
02D5A:  REPEAT  #3
02D5C:  MOV.B   [W2++],[W1++]
02D5E:  BCLR.B  43.0
02D60:  MOV     10D6,W0
02D62:  MOV     10D8,W1
02D64:  MOV     W7,W2
02D66:  MOV     W8,W3
02D68:  CALL    1AE6
02D6C:  ADD     W0,W5,W0
02D6E:  MOV     W0,10DE
02D70:  ADDC    W1,W6,W0
02D72:  MOV     W0,10E0
....................     p &= dsk->sectorSize - 1;                 // Restrict 'p' within the FATbuffer size 
02D74:  MOV     10C8,W4
02D76:  ADD     W4,#18,W4
02D78:  MOV     W4,W0
02D7A:  MOV     #A,W1
02D7C:  MOV     W0,W2
02D7E:  REPEAT  #3
02D80:  MOV.B   [W2++],[W1++]
02D82:  SUB     W5,#1,W0
02D84:  SUBB    W6,#0,W1
02D86:  AND     10D6
02D88:  MOV     W1,W0
02D8A:  AND     10D8
....................  
....................     if (gLastFATSectorRead != l) 
02D8C:  MOV     8A4,W0
02D8E:  CP      10DE
02D90:  BRA     NZ,2D98
02D92:  MOV     8A6,W0
02D94:  CP      10E0
02D96:  BRA     Z,2E22
....................     { 
....................         // If we are loading a new sector then write 
....................         // the current one to the card if we need to 
....................         if (gNeedFATWrite) 
02D98:  CP0.B   899
02D9A:  BRA     Z,2DF8
....................         { 
....................             for (i = 0, li = gLastFATSectorRead; i < dsk->fatcopy; i++, li += dsk->fatsize) 
02D9C:  CLR.B   10D3
02D9E:  PUSH    8A4
02DA0:  POP     10DA
02DA2:  PUSH    8A6
02DA4:  POP     10DC
02DA6:  MOV     #20,W4
02DA8:  MOV     10C8,W3
02DAA:  ADD     W3,W4,W0
02DAC:  MOV     #A,W1
02DAE:  MOV     W0,W2
02DB0:  MOV.B   [W2++],[W1++]
02DB2:  MOV     10D2,W4
02DB4:  LSR     W4,#8,W4
02DB6:  CP.B    W4L,W5L
02DB8:  BRA     C,2DF6
....................             { 
....................                 if (!MDD_SectorWrite (li, gFATBuffer, FALSE)) 
02DBA:  CLR.B   10F8
02DBC:  PUSH    10DA
02DBE:  POP     10F2
02DC0:  PUSH    10DC
02DC2:  POP     10F4
02DC4:  MOV     #B60,W4
02DC6:  MOV     W4,10F6
02DC8:  CALL    2BBE
02DCC:  CP0.B   W0L
02DCE:  BRA     NZ,2DD6
....................                 { 
....................                     return ClusterFailValue; 
02DD0:  MOV     10E2,W0
02DD2:  MOV     10E4,W1
02DD4:  BRA     2EC2
....................                 } 
02DD6:  MOV.B   10D3,W0L
02DD8:  INC.B   10D3
02DDA:  MOV     10C8,W4
02DDC:  ADD     W4,#1C,W4
02DDE:  MOV     W4,W0
02DE0:  MOV     #A,W1
02DE2:  MOV     W0,W2
02DE4:  REPEAT  #3
02DE6:  MOV.B   [W2++],[W1++]
02DE8:  MOV     W5,W0
02DEA:  ADD     10DA
02DEC:  MOV     W6,W0
02DEE:  ADDC    10DC,W0
02DF0:  MOV     W0,10DC
02DF2:  GOTO    2DA6
....................             } 
....................  
....................             gNeedFATWrite = FALSE; 
02DF6:  CLR.B   899
....................         } 
....................  
....................         // Load the new sector 
....................         if (!MDD_SectorRead (l, gFATBuffer)) 
02DF8:  PUSH    10DE
02DFA:  POP     10F2
02DFC:  PUSH    10E0
02DFE:  POP     10F4
02E00:  MOV     #B60,W4
02E02:  MOV     W4,10F6
02E04:  CALL    1722
02E08:  CP0.B   W0L
02E0A:  BRA     NZ,2E1A
....................         { 
....................             gLastFATSectorRead = 0xFFFF; 
02E0C:  SETM    8A4
02E0E:  CLR     8A6
....................             return ClusterFailValue; 
02E10:  MOV     10E2,W0
02E12:  MOV     10E4,W1
02E14:  BRA     2EC2
....................         } 
02E16:  GOTO    2E22
....................         else 
....................         { 
....................             gLastFATSectorRead = l; 
02E1A:  PUSH    10DE
02E1C:  POP     8A4
02E1E:  PUSH    10E0
02E20:  POP     8A6
....................         } 
....................     } 
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................     if (dsk->type == FAT32)  // Refer page 16 of FAT requirement. 
02E22:  MOV     #22,W4
02E24:  MOV     10C8,W3
02E26:  ADD     W3,W4,W0
02E28:  MOV     #A,W1
02E2A:  MOV     W0,W2
02E2C:  MOV.B   [W2++],[W1++]
02E2E:  CP.B    W5L,#3
02E30:  BRA     NZ,2E88
....................     { 
....................         RAMwrite (gFATBuffer, p,   ((value & 0x000000ff)));         // lsb,1st byte of cluster value 
02E32:  MOV     #B60,W0
02E34:  ADD     10D6,W0
02E36:  MOV     W0,W5
02E38:  CLR     W1
02E3A:  MOV     10CE,W0
02E3C:  AND     #FF,W0
02E3E:  MOV.B   W0L,[W5]
....................         RAMwrite (gFATBuffer, p+1, ((value & 0x0000ff00) >> 8)); 
02E40:  MOV     #B60,W0
02E42:  ADD     10D6,W0
02E44:  MOV     W0,W5
02E46:  ADD     W5,#1,W5
02E48:  MOV     W5,W0
02E4A:  MOV     W0,W5
02E4C:  MOV     #FF00,W0
02E4E:  AND     10CE,W0
02E50:  MOV     W0,W6
02E52:  CLR     W7
02E54:  MOV.B   D,W0L
02E56:  MOV.B   W0L,[W5]
....................         RAMwrite (gFATBuffer, p+2, ((value & 0x00ff0000) >> 16)); 
02E58:  MOV     #B60,W0
02E5A:  ADD     10D6,W0
02E5C:  MOV     W0,W5
02E5E:  ADD     W5,#2,W5
02E60:  MOV     W5,W0
02E62:  MOV     W0,W5
02E64:  CLR     W6
02E66:  MOV     10D0,W7
02E68:  AND     #FF,W7
02E6A:  MOV.B   W7L,[W5]
....................         RAMwrite (gFATBuffer, p+3, ((value & 0x0f000000) >> 24));   // the MSB nibble is supposed to be "0" in FAT32. So mask it. 
02E6C:  MOV     #B60,W0
02E6E:  ADD     10D6,W0
02E70:  MOV     W0,W5
02E72:  ADD     W5,#3,W5
02E74:  MOV     W5,W0
02E76:  MOV     W0,W5
02E78:  CLR     W6
02E7A:  MOV     #F00,W0
02E7C:  AND     10D0,W0
02E7E:  MOV     W0,W7
02E80:  MOV.B   F,W0L
02E82:  MOV.B   W0L,[W5]
....................     } 
02E84:  GOTO    2EBA
....................     else 
....................  
.................... #endif 
....................     { 
....................         if (dsk->type == FAT16) 
02E88:  MOV     #22,W4
02E8A:  MOV     10C8,W3
02E8C:  ADD     W3,W4,W0
02E8E:  MOV     #A,W1
02E90:  MOV     W0,W2
02E92:  MOV.B   [W2++],[W1++]
02E94:  CP.B    W5L,#2
02E96:  BRA     NZ,2EBA
....................         { 
....................             RAMwrite (gFATBuffer, p, value);            //lsB 
02E98:  MOV     #B60,W0
02E9A:  ADD     10D6,W0
02E9C:  MOV     W0,W5
02E9E:  MOV     10CE,W0
02EA0:  MOV.B   W0L,[W5+#0]
....................             RAMwrite (gFATBuffer, p+1, ((value&0x0000ff00) >> 8));    // msB 
02EA2:  MOV     #B60,W0
02EA4:  ADD     10D6,W0
02EA6:  MOV     W0,W5
02EA8:  ADD     W5,#1,W5
02EAA:  MOV     W5,W0
02EAC:  MOV     W0,W5
02EAE:  MOV     #FF00,W0
02EB0:  AND     10CE,W0
02EB2:  MOV     W0,W6
02EB4:  CLR     W7
02EB6:  MOV.B   D,W0L
02EB8:  MOV.B   W0L,[W5]
....................         } 
....................        #ifdef SUPPORT_FAT12 
....................         else if (dsk->type == FAT12) 
....................         { 
....................             // Get the current byte from the FAT 
....................             c = RAMread (gFATBuffer, p); 
....................             if (q) 
....................             { 
....................                 c = ((value & 0x0F) << 4) | ( c & 0x0F); 
....................             } 
....................             else 
....................             { 
....................                 c = (value & 0xFF); 
....................             } 
....................             // Write in those bits 
....................             RAMwrite (gFATBuffer, p, c); 
....................  
....................             // FAT12 entries can cross sector boundaries 
....................             // Check if we need to load a new sector 
....................             p = (p +1) & (dsk->sectorSize-1); 
....................             if (p == 0) 
....................             { 
....................                 // call this function to update the FAT on the card 
....................                 if (WriteFAT (dsk, 0,0,TRUE)) 
....................                     return ClusterFailValue; 
....................  
....................                 // Load the next sector 
....................                 if (!MDD_SectorRead (l +1, gFATBuffer)) 
....................                 { 
....................                     gLastFATSectorRead = 0xFFFF; 
....................                     return ClusterFailValue; 
....................                 } 
....................                 else 
....................                 { 
....................                     gLastFATSectorRead = l + 1; 
....................                 } 
....................             } 
....................  
....................             // Get the second byte of the table entry 
....................             c = RAMread (gFATBuffer, p); 
....................             if (q) 
....................             { 
....................                 c = (value >> 4); 
....................             } 
....................             else 
....................             { 
....................                 c = ((value >> 8) & 0x0F) | (c & 0xF0); 
....................             } 
....................             RAMwrite (gFATBuffer, p, c); 
....................         } 
....................        #endif 
....................     } 
....................     gNeedFATWrite = TRUE; 
02EBA:  MOV.B   #1,W0L
02EBC:  MOV.B   W0L,899
....................  
....................     return 0; 
02EBE:  MOV     #0,W0
02EC0:  MOV     #0,W1
02EC2:  MOV     [--W15],W8
02EC4:  MOV     [--W15],W7
02EC6:  MOV     [--W15],W6
02EC8:  MOV     [--W15],W5
02ECA:  RETURN  
.................... } 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_DIRS 
....................  
.................... // This string is used by dir functions to hold dir names temporarily 
.................... #if defined(SUPPORT_LFN) 
....................    char tempDirectoryString [522]; 
.................... #else 
....................    char tempDirectoryString [14]; 
.................... #endif 
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdir (char * path) 
....................   Summary: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC). 
....................     The FSchdir function passes a RAM pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... int FSchdir (char * path) 
.................... { 
....................     return chdirhelper (0, path, NULL); 
*
0650A:  CLR.B   100C
0650C:  PUSH    1008
0650E:  POP     100E
06510:  CLR     1010
06512:  CALL    60CC
06516:  MOV     W0,0
06518:  RETURN  
.................... } 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int wFSchdir (unsigned short int * path) 
....................   Summary: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC).The FSchdir function passes a RAM 
....................     pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSchdir (unsigned short int * path) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................     result = chdirhelper (0, (char *)path, NULL); 
....................    utfModeFileName = FALSE; 
....................     return result; 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdirpgm (const rom char * path) 
....................   Summary: 
....................     Changes the CWD to the input path on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to (ROM) 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the CWD to the input path on PIC18.The FSchdirpgm function 
....................     passes a PIC18 ROM path pointer to the chdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int FSchdirpgm (const rom char * path) 
.................... { 
....................     return chdirhelper (1, NULL, path); 
.................... } 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int wFSchdirpgm (const rom unsigned short int * path) 
....................   Summary: 
....................     Changed the CWD with a path in ROM on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to (ROM) 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     The FSchdirpgm function passes a PIC18 ROM path pointer to the 
....................     chdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM 
....................   **************************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSchdirpgm (const rom unsigned short int * path) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................     result = chdirhelper (1, NULL, (const char *)path); 
....................    utfModeFileName = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int chdirhelper (BYTE mode, char * ramptr, char * romptr); 
....................     // PIC18 
....................     int chdirhelper (BYTE mode, char * ramptr, const rom char * romptr); 
....................   Summary: 
....................     Helper function for FSchdir 
....................   Conditions: 
....................     None 
....................   Input: 
....................     mode -    Indicates which path pointer to use 
....................     ramptr -  Pointer to the path specified in RAM 
....................     romptr -  Pointer to the path specified in ROM 
....................   Return Values: 
....................     0 -   Directory was changed successfully. 
....................     EOF - Directory could not be changed. 
....................   Side Effects: 
....................     The current working directory will be changed. The FSerrno variable 
....................     will be changed. Any unwritten data in the data buffer will be written 
....................     to the device. 
....................   Description: 
....................     This helper function is used by the FSchdir function. If the path 
....................     argument is specified in ROM for PIC18 this function will be able to 
....................     parse it correctly.  The function will loop through a switch statement 
....................     to process the tokens in the path string.  Dot or dotdot entries are 
....................     handled in the first case statement.  A backslash character is handled 
....................     in the second case statement (note that this case statement will only 
....................     be used if backslash is the first character in the path; backslash 
....................     token delimiters will automatically be skipped after each token in the 
....................     path is processed).  The third case statement will handle actual 
....................     directory name strings. 
....................   Remarks: 
....................     None. 
....................   *************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int chdirhelper (BYTE mode, char * ramptr, const rom char * romptr) 
.................... #else 
.................... int chdirhelper (BYTE mode, char * ramptr, char * romptr) 
.................... #endif 
*
060CC:  MOV     W5,[W15++]
060CE:  MOV     W6,[W15++]
*
060D4:  CLR     1016
060D6:  MOV     #1,W4
060D8:  MOV     W4,1018
*
060DC:  PUSH    100E
060DE:  POP     101C
*
06116:  MOV     #101E,W4
06118:  MOV     W4,1054
.................... { 
....................     unsigned short int i,j,k = 0; 
*
060D0:  CLR     1012
060D2:  CLR     1014
....................     WORD curent = 1; 
....................     DIRENTRY entry; 
*
060DA:  CLR     101A
....................     char * temppath = ramptr; 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     rom char * temppath2 = romptr; 
....................     rom unsigned short int * utf16path2 = (rom unsigned short int *)romptr; 
.................... #endif 
....................    #ifdef SUPPORT_LFN 
....................       unsigned short int *utf16path = (unsigned short int *)ramptr; 
....................    #endif 
....................  
....................     FSFILE tempCWDobj2; 
*
060E0:  CLR     101E
060E2:  CLR     1020
060E4:  CLR     1022
060E6:  CLR     1024
060E8:  CLR     1026
060EA:  CLR     1028
060EC:  CLR     102A
060EE:  CLR     102C
060F0:  CLR     102E
060F2:  CLR     1030
060F4:  CLR     1032
060F6:  CLR     1034
060F8:  CLR     1036
060FA:  CLR     1038
060FC:  CLR     103A
060FE:  CLR     103C
06100:  CLR     103E
06102:  CLR     1040
06104:  CLR     1042
06106:  CLR     1044
06108:  CLR     1046
0610A:  CLR     1048
0610C:  CLR     104A
0610E:  CLR     104C
06110:  CLR     104E
06112:  CLR     1050
06114:  CLR     1052
....................     FILEOBJ tempCWD = &tempCWDobj2; 
....................  
....................     FileObjectCopy (tempCWD, cwdptr); 
*
0611A:  PUSH    1054
0611C:  POP     105C
0611E:  PUSH    95E
06120:  POP     105E
06122:  CALL    28E2
....................  
....................     FSerrno = CE_GOOD; 
06126:  CLR.B   8B1
....................  
....................    // Check the first char of the path 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     if (mode) 
....................    { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................  
....................       { 
....................  
....................          i = *utf16path2; 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................          i = *temppath2; 
....................       } 
....................     } 
....................     else 
.................... #endif 
....................    { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................  
....................       { 
....................  
....................          i = *utf16path; 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................          i = *temppath; 
06128:  MOV     101C,W0
0612A:  MOV     W0,W4
0612C:  MOV.B   [W4],W0L
0612E:  SE      W0,W0
06130:  MOV     W0,1012
....................       } 
....................     } 
....................  
....................    // if NULL character return error 
....................     if (i == 0) 
06132:  CP0     1012
06134:  BRA     NZ,613E
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
06136:  MOV.B   #1F,W0L
06138:  MOV.B   W0L,8B1
....................         return -1; 
0613A:  SETM    0
0613C:  BRA     6504
....................     } 
....................  
....................     while(1) 
....................     { 
....................         switch (i) 
0613E:  MOV     1012,W0
06140:  XOR     #2E,W0
06142:  BRA     Z,614A
06144:  XOR     #72,W0
06146:  BRA     Z,631A
06148:  BRA     63CC
....................         { 
....................             // First case: dot or dotdot entry 
....................             case '.': 
....................                 // Move past the dot 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 if (mode) 
....................                 { 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................  
....................                { 
....................  
....................                        utf16path2++; 
....................                        i = *utf16path2; 
....................                } 
....................                else 
....................                #endif 
....................                { 
....................                        temppath2++; 
....................                        i = *temppath2; 
....................                } 
....................                 } 
....................                 else 
....................                 { 
.................... #endif 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................  
....................                { 
....................  
....................                        utf16path++; 
....................                        i = *utf16path; 
....................                } 
....................                else 
....................                #endif 
....................                { 
....................                        temppath++; 
0614A:  INC     101C
....................                        i = *temppath; 
0614C:  MOV     101C,W0
0614E:  MOV     W0,W4
06150:  MOV.B   [W4],W0L
06152:  SE      W0,W0
06154:  MOV     W0,1012
....................                } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 } 
.................... #endif 
....................                 // Check if it's a dotdot entry 
....................                 if (i == '.') 
06156:  MOV     1012,W4
06158:  XOR     #2E,W4
0615A:  BRA     NZ,62C2
....................                 { 
....................                     // Increment the path variable 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     if (mode) 
....................                     { 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                           utf16path2++; 
....................                           i = *utf16path2; 
....................                   } 
....................                   else 
....................                   #endif 
....................                   { 
....................                           temppath2++; 
....................                           i = *temppath2; 
....................                   } 
....................                     } 
....................                     else 
....................                     { 
.................... #endif 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                           utf16path++; 
....................                           i = *utf16path; 
....................                   } 
....................                   else 
....................                   #endif 
....................                   { 
....................                           temppath++; 
0615C:  INC     101C
....................                           i = *temppath; 
0615E:  MOV     101C,W0
06160:  MOV     W0,W4
06162:  MOV.B   [W4],W0L
06164:  SE      W0,W0
06166:  MOV     W0,1012
....................                   } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     } 
.................... #endif 
....................                     // Check if we're in the root 
....................                     if (tempCWD->dirclus == FatRootDirClusterValue) 
06168:  MOV     #2E,W0
0616A:  ADD     1054,W0
0616C:  MOV     #A,W4
0616E:  MOV     [W0++],[W4++]
06170:  MOV     [W0++],[W4++]
06172:  MOV     8B2,W4
06174:  CP      W4,W5
06176:  BRA     NZ,618A
06178:  MOV     8B4,W4
0617A:  CP      W4,W6
0617C:  BRA     NZ,618A
....................                     { 
....................                         // Fails if there's a dotdot chdir from the root 
....................                         FSerrno = CE_INVALID_ARGUMENT; 
0617E:  MOV.B   #1F,W0L
06180:  MOV.B   W0L,8B1
....................                         return -1; 
06182:  SETM    0
06184:  BRA     6504
....................                     } 
06186:  GOTO    62BE
....................                     else 
....................                     { 
....................                         // Cache the dotdot entry 
....................                         tempCWD->dirccls = tempCWD->dirclus; 
0618A:  MOV     #32,W0
0618C:  ADD     1054,W0
0618E:  MOV     W0,W5
06190:  MOV     #2E,W0
06192:  ADD     1054,W0
06194:  MOV     [W0++],[W5++]
06196:  MOV     [W0++],[W5++]
....................                         curent = 1; 
06198:  MOV     #1,W4
0619A:  MOV     W4,1018
....................                         entry = Cache_File_Entry (tempCWD, &curent, TRUE); 
0619C:  MOV.B   #1,W0L
0619E:  MOV.B   W0L,1086
061A0:  PUSH    1054
061A2:  POP     1082
061A4:  MOV     #1018,W4
061A6:  MOV     W4,1084
061A8:  CALL    31E4
061AC:  MOV     W0,101A
....................                         if (entry == NULL) 
061AE:  CP0     101A
061B0:  BRA     NZ,61BA
....................                         { 
....................                             FSerrno = CE_BADCACHEREAD; 
061B2:  MOV.B   #1B,W0L
061B4:  MOV.B   W0L,8B1
....................                             return -1; 
061B6:  SETM    0
061B8:  BRA     6504
....................                         } 
....................  
....................                         // Get the cluster 
....................                         tempCWD->dirclus = GetFullClusterNumber(entry); // Get Complete Cluster number. 
061BA:  MOV     #2E,W0
061BC:  ADD     1054,W0
061BE:  MOV     W0,W5
061C0:  PUSH    101A
061C2:  POP     1084
061C4:  CALL    34B4
061C8:  MOV     #0,W4
061CA:  MOV     [W4++],[W5++]
061CC:  MOV     [W4++],[W5++]
....................                         tempCWD->dirccls = tempCWD->dirclus; 
061CE:  MOV     #32,W0
061D0:  ADD     1054,W0
061D2:  MOV     W0,W5
061D4:  MOV     #2E,W0
061D6:  ADD     1054,W0
061D8:  MOV     [W0++],[W5++]
061DA:  MOV     [W0++],[W5++]
....................  
....................                         // If we changed to root, record the name 
....................                         if (tempCWD->dirclus == VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT) // "0" is the value of Dotdot entry for Root in both FAT types. 
061DC:  MOV     #2E,W0
061DE:  ADD     1054,W0
061E0:  MOV     #A,W4
061E2:  MOV     [W0++],[W4++]
061E4:  MOV     [W0++],[W4++]
061E6:  CP0     W5
061E8:  BRA     NZ,6236
061EA:  CP0     W6
061EC:  BRA     NZ,6236
....................                         { 
....................                             j = 0; 
061EE:  CLR     1014
....................                             tempCWD->name[j++] = '\\'; 
061F0:  MOV     1014,W0
061F2:  INC     1014
061F4:  MOV     W0,W5
061F6:  ADD     W5,#1C,W5
061F8:  MOV     W5,W0
061FA:  MOV     1054,W4
061FC:  ADD     W0,W4,W6
061FE:  MOV.B   #5C,W0L
06200:  MOV.B   W0L,[W6]
.................... //                            if(utfModeFileName) 
.................... //                     { 
.................... //                               tempCWD->name[j++] = 0x00; 
.................... //                     } 
....................                             for (;j < 11;) 
06202:  MOV     1014,W4
06204:  CP      W4,#B
06206:  BRA     C,621A
....................                             { 
....................                                 tempCWD->name[j] = 0x20; 
06208:  MOV     #1C,W0
0620A:  ADD     1014,W0
0620C:  MOV     1054,W4
0620E:  ADD     W0,W4,W5
06210:  MOV.B   #20,W0L
06212:  MOV.B   W0L,[W5]
....................                                ++j; 
06214:  INC     1014
06216:  GOTO    6202
....................                             } 
....................  
....................                             /* While moving to Root, get the Root cluster value */ 
....................                             tempCWD->dirccls = FatRootDirClusterValue; 
0621A:  MOV     #32,W0
0621C:  ADD     1054,W0
0621E:  MOV     W0,W5
06220:  MOV     #8B2,W4
06222:  MOV     [W4++],[W5++]
06224:  MOV     [W4++],[W5++]
....................                             tempCWD->dirclus = FatRootDirClusterValue; 
06226:  MOV     #2E,W0
06228:  ADD     1054,W0
0622A:  MOV     W0,W5
0622C:  MOV     #8B2,W4
0622E:  MOV     [W4++],[W5++]
06230:  MOV     [W4++],[W5++]
....................                         } 
06232:  GOTO    6274
....................                         else 
....................                         { 
....................                             // Otherwise set the name to .. 
....................                             j = 0; 
06236:  CLR     1014
....................                             tempCWD->name[j++] = '.'; 
06238:  MOV     1014,W0
0623A:  INC     1014
0623C:  MOV     W0,W5
0623E:  ADD     W5,#1C,W5
06240:  MOV     W5,W0
06242:  MOV     1054,W4
06244:  ADD     W0,W4,W6
06246:  MOV.B   #2E,W0L
06248:  MOV.B   W0L,[W6]
.................... //                            if(utfModeFileName) 
.................... //                     { 
.................... //                               tempCWD->name[j++] = 0x00; 
.................... //                               tempCWD->name[j++] = '.'; 
.................... //                               tempCWD->name[j++] = 0x00; 
.................... //                     } 
.................... //                     else 
....................                      { 
....................                                tempCWD->name[j++] = '.'; 
0624A:  MOV     1014,W0
0624C:  INC     1014
0624E:  MOV     W0,W5
06250:  ADD     W5,#1C,W5
06252:  MOV     W5,W0
06254:  MOV     1054,W4
06256:  ADD     W0,W4,W6
06258:  MOV.B   #2E,W0L
0625A:  MOV.B   W0L,[W6]
....................                             } 
....................                             for (; j < 11;) 
0625C:  MOV     1014,W4
0625E:  CP      W4,#B
06260:  BRA     C,6274
....................                             { 
....................                                 tempCWD->name[j] = 0x20; 
06262:  MOV     #1C,W0
06264:  ADD     1014,W0
06266:  MOV     1054,W4
06268:  ADD     W0,W4,W5
0626A:  MOV.B   #20,W0L
0626C:  MOV.B   W0L,[W5]
....................                                ++j; 
0626E:  INC     1014
06270:  GOTO    625C
....................                             } 
....................                         } 
....................                         // Cache the dot entry 
....................                         curent = 0; 
06274:  CLR     1018
....................                         if (Cache_File_Entry(tempCWD, &curent, TRUE) == NULL) 
06276:  MOV.B   #1,W0L
06278:  MOV.B   W0L,1086
0627A:  PUSH    1054
0627C:  POP     1082
0627E:  MOV     #1018,W4
06280:  MOV     W4,1084
06282:  CALL    31E4
06286:  MOV     W0,W5
06288:  CP0     W5
0628A:  BRA     NZ,6294
....................                         { 
....................                             FSerrno = CE_BADCACHEREAD; 
0628C:  MOV.B   #1B,W0L
0628E:  MOV.B   W0L,8B1
....................                             return -1; 
06290:  SETM    0
06292:  BRA     6504
....................                         } 
....................                         // Move past the next backslash, if necessary 
....................                         while (i == '\\') 
06294:  MOV     1012,W4
06296:  XOR     #5C,W4
06298:  BRA     NZ,62AA
....................                         { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                             if (mode) 
....................                             { 
....................                         #ifdef SUPPORT_LFN 
....................                         if(utfModeFileName) 
....................  
....................                         { 
....................  
....................                                 utf16path2++; 
....................                                 i = *utf16path2; 
....................                         } 
....................                         else 
....................                         #endif 
....................                         { 
....................                                 temppath2++; 
....................                                 i = *temppath2; 
....................                         } 
....................                             } 
....................                             else 
....................                             { 
.................... #endif 
....................                         #ifdef SUPPORT_LFN 
....................                         if(utfModeFileName) 
....................  
....................                         { 
....................  
....................                                 utf16path++; 
....................                                 i = *utf16path; 
....................                         } 
....................                         else 
....................                         #endif 
....................                         { 
....................                                 temppath++; 
0629A:  INC     101C
....................                                 i = *temppath; 
0629C:  MOV     101C,W0
0629E:  MOV     W0,W4
062A0:  MOV.B   [W4],W0L
062A2:  SE      W0,W0
062A4:  MOV     W0,1012
....................                         } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
062A6:  GOTO    6294
....................                             } 
.................... #endif 
....................                         } 
....................                         // Copy and return, if we're at the end 
....................                         if (i == 0) 
062AA:  CP0     1012
062AC:  BRA     NZ,62BE
....................                         { 
....................                             FileObjectCopy (cwdptr, tempCWD); 
062AE:  PUSH    95E
062B0:  POP     105C
062B2:  PUSH    1054
062B4:  POP     105E
062B6:  CALL    28E2
....................                             return 0; 
062BA:  CLR     0
062BC:  BRA     6504
....................                         } 
....................                     } 
....................                 } 
062BE:  GOTO    6316
....................                 else 
....................                 { 
....................                     // If we ended with a . entry, 
....................                     // just return what we have 
....................                     if (i == 0) 
062C2:  CP0     1012
062C4:  BRA     NZ,62DA
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
062C6:  PUSH    95E
062C8:  POP     105C
062CA:  PUSH    1054
062CC:  POP     105E
062CE:  CALL    28E2
....................                         return 0; 
062D2:  CLR     0
062D4:  BRA     6504
....................                     } 
062D6:  GOTO    6316
....................                     else 
....................                     { 
....................                         if (i == '\\') 
062DA:  MOV     1012,W4
062DC:  XOR     #5C,W4
062DE:  BRA     NZ,630E
....................                         { 
....................                             while (i == '\\') 
062E0:  MOV     1012,W4
062E2:  XOR     #5C,W4
062E4:  BRA     NZ,62F6
....................                             { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                                 if (mode) 
....................                                 { 
....................                            #ifdef SUPPORT_LFN 
....................                            if(utfModeFileName) 
....................  
....................                            { 
....................  
....................                                    utf16path2++; 
....................                                    i = *utf16path2; 
....................                            } 
....................                            else 
....................                            #endif 
....................                            { 
....................                                    temppath2++; 
....................                                    i = *temppath2; 
....................                            } 
....................                                 } 
....................                                 else 
....................                                 { 
.................... #endif 
....................                            #ifdef SUPPORT_LFN 
....................                            if(utfModeFileName) 
....................  
....................                            { 
....................  
....................                                    utf16path++; 
....................                                    i = *utf16path; 
....................                            } 
....................                            else 
....................                            #endif 
....................                            { 
....................                                    temppath++; 
062E6:  INC     101C
....................                                    i = *temppath; 
062E8:  MOV     101C,W0
062EA:  MOV     W0,W4
062EC:  MOV.B   [W4],W0L
062EE:  SE      W0,W0
062F0:  MOV     W0,1012
....................                            } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
062F2:  GOTO    62E0
....................                                 } 
.................... #endif 
....................                             } 
....................                             if (i == 0) 
062F6:  CP0     1012
062F8:  BRA     NZ,630A
....................                             { 
....................                                 FileObjectCopy (cwdptr, tempCWD); 
062FA:  PUSH    95E
062FC:  POP     105C
062FE:  PUSH    1054
06300:  POP     105E
06302:  CALL    28E2
....................                                 return 0; 
06306:  CLR     0
06308:  BRA     6504
....................                             } 
....................                         } 
0630A:  GOTO    6316
....................                         else 
....................                         { 
....................                             // Anything else after a dot doesn't make sense 
....................                             FSerrno = CE_INVALID_ARGUMENT; 
0630E:  MOV.B   #1F,W0L
06310:  MOV.B   W0L,8B1
....................                             return -1; 
06312:  SETM    0
06314:  BRA     6504
....................                         } 
....................                     } 
....................                 } 
....................  
....................                 break; 
06316:  GOTO    6500
....................  
....................             // Second case: the first char is the root backslash 
....................             // We will ONLY switch to this case if the first char 
....................             // of the path is a backslash 
....................             case '\\': 
....................             // Increment pointer to second char 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             if (mode) 
....................             { 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................  
....................             { 
....................  
....................                     utf16path2++; 
....................                     i = *utf16path2; 
....................             } 
....................             else 
....................             #endif 
....................             { 
....................                     temppath2++; 
....................                     i = *temppath2; 
....................             } 
....................             } 
....................             else 
....................             { 
.................... #endif 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................  
....................             { 
....................  
....................                     utf16path++; 
....................                     i = *utf16path; 
....................             } 
....................             else 
....................             #endif 
....................             { 
....................                     temppath++; 
0631A:  INC     101C
....................                     i = *temppath; 
0631C:  MOV     101C,W0
0631E:  MOV     W0,W4
06320:  MOV.B   [W4],W0L
06322:  SE      W0,W0
06324:  MOV     W0,1012
....................             } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             } 
.................... #endif 
....................             // Can't start the path with multiple backslashes 
....................             if (i == '\\') 
06326:  MOV     1012,W4
06328:  XOR     #5C,W4
0632A:  BRA     NZ,6334
....................             { 
....................                 FSerrno = CE_INVALID_ARGUMENT; 
0632C:  MOV.B   #1F,W0L
0632E:  MOV.B   W0L,8B1
....................                 return -1; 
06330:  SETM    0
06332:  BRA     6504
....................             } 
....................  
....................             if (i == 0) 
06334:  CP0     1012
06336:  BRA     NZ,6384
....................             { 
....................                 // The user is changing directory to 
....................                 // the root 
....................                 cwdptr->dirclus = FatRootDirClusterValue; 
06338:  MOV     #2E,W0
0633A:  ADD     95E,W0
0633C:  MOV     W0,W5
0633E:  MOV     #8B2,W4
06340:  MOV     [W4++],[W5++]
06342:  MOV     [W4++],[W5++]
....................                 cwdptr->dirccls = FatRootDirClusterValue; 
06344:  MOV     #32,W0
06346:  ADD     95E,W0
06348:  MOV     W0,W5
0634A:  MOV     #8B2,W4
0634C:  MOV     [W4++],[W5++]
0634E:  MOV     [W4++],[W5++]
....................                 j = 0; 
06350:  CLR     1014
....................                 cwdptr->name[j++] = '\\'; 
06352:  MOV     1014,W0
06354:  INC     1014
06356:  MOV     W0,W5
06358:  ADD     W5,#1C,W5
0635A:  MOV     W5,W0
0635C:  MOV     95E,W4
0635E:  ADD     W0,W4,W6
06360:  MOV.B   #5C,W0L
06362:  MOV.B   W0L,[W6]
.................... //                if(utfModeFileName) 
.................... //            { 
.................... //                   cwdptr->name[j++] = 0x00; 
.................... //            } 
....................                 for (; j < 11;) 
06364:  MOV     1014,W4
06366:  CP      W4,#B
06368:  BRA     C,637C
....................                 { 
....................                     cwdptr->name[j] = 0x20; 
0636A:  MOV     #1C,W0
0636C:  ADD     1014,W0
0636E:  MOV     95E,W4
06370:  ADD     W0,W4,W5
06372:  MOV.B   #20,W0L
06374:  MOV.B   W0L,[W5]
....................                    ++j; 
06376:  INC     1014
06378:  GOTO    6364
....................                 } 
....................                 return 0; 
0637C:  CLR     0
0637E:  BRA     6504
....................             } 
06380:  GOTO    63C8
....................             else 
....................             { 
....................                 // Our first char is the root dir switch 
....................                 tempCWD->dirclus = FatRootDirClusterValue; 
06384:  MOV     #2E,W0
06386:  ADD     1054,W0
06388:  MOV     W0,W5
0638A:  MOV     #8B2,W4
0638C:  MOV     [W4++],[W5++]
0638E:  MOV     [W4++],[W5++]
....................                 tempCWD->dirccls = FatRootDirClusterValue; 
06390:  MOV     #32,W0
06392:  ADD     1054,W0
06394:  MOV     W0,W5
06396:  MOV     #8B2,W4
06398:  MOV     [W4++],[W5++]
0639A:  MOV     [W4++],[W5++]
....................                 j = 0; 
0639C:  CLR     1014
....................                 tempCWD->name[j++] = '\\'; 
0639E:  MOV     1014,W0
063A0:  INC     1014
063A2:  MOV     W0,W5
063A4:  ADD     W5,#1C,W5
063A6:  MOV     W5,W0
063A8:  MOV     1054,W4
063AA:  ADD     W0,W4,W6
063AC:  MOV.B   #5C,W0L
063AE:  MOV.B   W0L,[W6]
.................... //                if(utfModeFileName) 
.................... //            { 
.................... //                   tempCWD->name[j++] = 0x00; 
.................... //            } 
....................                 for (; j < 11;) 
063B0:  MOV     1014,W4
063B2:  CP      W4,#B
063B4:  BRA     C,63C8
....................                 { 
....................                     tempCWD->name[j] = 0x20; 
063B6:  MOV     #1C,W0
063B8:  ADD     1014,W0
063BA:  MOV     1054,W4
063BC:  ADD     W0,W4,W5
063BE:  MOV.B   #20,W0L
063C0:  MOV.B   W0L,[W5]
....................                    ++j; 
063C2:  INC     1014
063C4:  GOTO    63B0
....................                 } 
....................             } 
....................             break; 
063C8:  GOTO    6500
....................  
....................         default: 
....................             // We should be at the beginning of a string of letters/numbers 
....................             j = 0; 
063CC:  CLR     1014
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             if (mode) 
....................             { 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................  
....................             { 
....................  
....................                    // Change directories as specified 
....................                k = 512; 
....................  
....................  
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempDirectoryString[j++] = i; 
....................                        tempDirectoryString[j++] = i >> 8; 
....................                        i = *(++utf16path2); 
....................                    } 
....................  
....................                tempDirectoryString[j++] = 0; 
....................             } 
....................  
....................             else 
....................  
....................             #endif 
....................               { 
....................  
....................                #if defined(SUPPORT_LFN) 
....................  
....................                   k = 256; 
....................  
....................                #else 
....................  
....................                   k = 12; 
....................  
....................                #endif 
....................  
....................  
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempDirectoryString[j++] = i; 
....................                        i = *(++temppath2); 
....................                    } 
....................             } 
....................  
....................             } 
....................             else 
....................             { 
.................... #endif 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................  
....................             { 
....................  
....................                    // Change directories as specified 
....................                k = 512; 
....................  
....................  
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempDirectoryString[j++] = i; 
....................                        tempDirectoryString[j++] = i >> 8; 
....................                        i = *(++utf16path); 
....................                    } 
....................  
....................                tempDirectoryString[j++] = 0; 
....................             } 
....................  
....................             else 
....................  
....................             #endif 
....................               { 
....................  
....................                #if defined(SUPPORT_LFN) 
....................  
....................                   k = 256; 
....................  
....................                #else 
....................  
....................                   k = 12; 
063CE:  MOV     #C,W4
063D0:  MOV     W4,1016
....................  
....................                #endif 
....................  
....................  
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
063D2:  CP0     1012
063D4:  BRA     Z,6402
063D6:  MOV     1012,W4
063D8:  XOR     #5C,W4
063DA:  BRA     Z,6402
063DC:  MOV     1014,W0
063DE:  MOV     1016,W4
063E0:  CP      W4,W0
063E2:  BRA     LEU,6402
....................                    { 
....................                        tempDirectoryString[j++] = i; 
063E4:  MOV     1014,W0
063E6:  INC     1014
063E8:  MOV     W0,W5
063EA:  MOV     #D88,W4
063EC:  ADD     W5,W4,W6
063EE:  MOV     1012,W0
063F0:  MOV.B   W0L,[W6+#0]
....................                        i = *(++temppath); 
063F2:  INC     101C
063F4:  MOV     101C,W0
063F6:  MOV     W0,W4
063F8:  MOV.B   [W4],W0L
063FA:  SE      W0,W0
063FC:  MOV     W0,1012
063FE:  GOTO    63D2
....................                    } 
....................             } 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             } 
.................... #endif 
....................  
....................             tempDirectoryString[j++] = 0; 
06402:  MOV     1014,W0
06404:  INC     1014
06406:  MOV     W0,W5
06408:  MOV     #D88,W4
0640A:  ADD     W5,W4,W6
0640C:  CLR.B   [W6]
....................  
....................             // We got a whole 12 chars 
....................             // There could be more- truncate it 
....................             if (j > k) 
0640E:  MOV     1016,W0
06410:  MOV     1014,W4
06412:  CP      W4,W0
06414:  BRA     LEU,6430
....................             { 
....................                 while ((i != 0) && (i != '\\')) 
06416:  CP0     1012
06418:  BRA     Z,6430
0641A:  MOV     1012,W4
0641C:  XOR     #5C,W4
0641E:  BRA     Z,6430
....................                 { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     if (mode) 
....................                     { 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                            i = *(++utf16path2); 
....................                        } 
....................                   else 
....................                   #endif 
....................                   { 
....................  
....................                            i = *(++temppath2); 
....................                        } 
....................                     } 
....................                     else 
....................                     { 
.................... #endif 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                            i = *(++utf16path); 
....................                        } 
....................                   else 
....................                   #endif 
....................                   { 
....................  
....................                            i = *(++temppath); 
06420:  INC     101C
06422:  MOV     101C,W0
06424:  MOV     W0,W4
06426:  MOV.B   [W4],W0L
06428:  SE      W0,W0
0642A:  MOV     W0,1012
....................                        } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
0642C:  GOTO    6416
....................                     } 
.................... #endif 
....................                 } 
....................             } 
....................  
....................             if (FormatDirName (tempDirectoryString, tempCWD,0) == FALSE) 
06430:  CLR.B   1060
06432:  MOV     #D88,W4
06434:  MOV     W4,105C
06436:  PUSH    1054
06438:  POP     105E
0643A:  CALL    5F54
0643E:  CP0.B   W0L
06440:  BRA     NZ,6446
....................                 return -1; 
06442:  SETM    0
06444:  BRA     6504
....................  
....................             // copy file object over 
....................             FileObjectCopy(&gFileTemp, tempCWD); 
06446:  MOV     #8F2,W4
06448:  MOV     W4,105C
0644A:  PUSH    1054
0644C:  POP     105E
0644E:  CALL    28E2
....................  
....................             // See if the directory is there 
....................             if(FILEfind (&gFileTemp, tempCWD, LOOK_FOR_MATCHING_ENTRY, 0) != CE_GOOD) 
06452:  MOV.B   #1,W0L
06454:  MOV.B   W0L,1060
06456:  CLR.B   1061
06458:  MOV     #8F2,W4
0645A:  MOV     W4,105C
0645C:  PUSH    1054
0645E:  POP     105E
06460:  CALL    36BE
06464:  CP0.B   W0L
06466:  BRA     Z,6474
....................             { 
....................                 // Couldn't find the DIR 
....................                 FSerrno = CE_DIR_NOT_FOUND; 
06468:  MOV.B   #C,W0L
0646A:  MOV.B   W0L,8B1
....................                 return -1; 
0646C:  SETM    0
0646E:  BRA     6504
....................             } 
06470:  GOTO    64BA
....................             else 
....................             { 
....................                 // Found the file 
....................                 // Check to make sure it's actually a directory 
....................                 if ((gFileTemp.attributes & ATTR_DIRECTORY) == 0 ) 
06474:  MOV     91E,W0
06476:  AND     W0,#10,W5
06478:  CP0     W5
0647A:  BRA     NZ,6484
....................                 { 
....................                     FSerrno = CE_INVALID_ARGUMENT; 
0647C:  MOV.B   #1F,W0L
0647E:  MOV.B   W0L,8B1
....................                     return -1; 
06480:  SETM    0
06482:  BRA     6504
....................                 } 
....................  
....................                 // Get the new name 
....................             #if defined(SUPPORT_LFN) 
....................                if(!tempCWD->utf16LFNlength) 
....................             #endif 
....................                       for (j = 0; j < 11; j++) 
06484:  CLR     1014
06486:  MOV     1014,W4
06488:  CP      W4,#B
0648A:  BRA     C,64A0
....................                       { 
....................                           tempCWD->name[j] = gFileTemp.name[j]; 
0648C:  MOV     #1C,W0
0648E:  ADD     1014,W0
06490:  MOV     1054,W4
06492:  ADD     W0,W4,W5
06494:  MOV     #90E,W0
06496:  ADD     1014,W0
06498:  MOV.B   [W0],[W5]
0649A:  INC     1014
0649C:  GOTO    6486
....................                       } 
....................  
....................                 tempCWD->dirclus = gFileTemp.cluster; 
064A0:  MOV     #2E,W0
064A2:  ADD     1054,W0
064A4:  MOV     W0,W5
064A6:  MOV     #8F4,W4
064A8:  MOV     [W4++],[W5++]
064AA:  MOV     [W4++],[W5++]
....................                 tempCWD->dirccls = tempCWD->dirclus; 
064AC:  MOV     #32,W0
064AE:  ADD     1054,W0
064B0:  MOV     W0,W5
064B2:  MOV     #2E,W0
064B4:  ADD     1054,W0
064B6:  MOV     [W0++],[W5++]
064B8:  MOV     [W0++],[W5++]
....................             } 
....................  
....................             if (i == 0) 
064BA:  CP0     1012
064BC:  BRA     NZ,64D2
....................             { 
....................                 // If we're at the end of the string, we're done 
....................                 FileObjectCopy (cwdptr, tempCWD); 
064BE:  PUSH    95E
064C0:  POP     105C
064C2:  PUSH    1054
064C4:  POP     105E
064C6:  CALL    28E2
....................                 return 0; 
064CA:  CLR     0
064CC:  BRA     6504
....................             } 
064CE:  GOTO    64FC
....................             else 
....................             { 
....................                 while (i == '\\') 
064D2:  MOV     1012,W4
064D4:  XOR     #5C,W4
064D6:  BRA     NZ,64FC
....................                 { 
....................                     // If we get to another backslash, increment past it 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     if (mode) 
....................                     { 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                           utf16path2++; 
....................                           i = *utf16path2; 
....................                   } 
....................                   else 
....................                   #endif 
....................                   { 
....................                           temppath2++; 
....................                           i = *temppath2; 
....................                   } 
....................                     } 
....................                     else 
....................                     { 
.................... #endif 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                           utf16path++; 
....................                           i = *utf16path; 
....................                   } 
....................                   else 
....................                   #endif 
....................                   { 
....................                           temppath++; 
064D8:  INC     101C
....................                           i = *temppath; 
064DA:  MOV     101C,W0
064DC:  MOV     W0,W4
064DE:  MOV.B   [W4],W0L
064E0:  SE      W0,W0
064E2:  MOV     W0,1012
....................                   } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     } 
.................... #endif 
....................                     if (i == 0) 
064E4:  CP0     1012
064E6:  BRA     NZ,64F8
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
064E8:  PUSH    95E
064EA:  POP     105C
064EC:  PUSH    1054
064EE:  POP     105E
064F0:  CALL    28E2
....................                         return 0; 
064F4:  CLR     0
064F6:  BRA     6504
....................                     } 
064F8:  GOTO    64D2
....................                 } 
....................             } 
....................             break; 
064FC:  GOTO    6500
....................         } 
06500:  GOTO    613E
....................     } // loop 
06504:  MOV     [--W15],W6
06506:  MOV     [--W15],W5
06508:  RETURN  
.................... } 
....................  
....................  
....................  
.................... // This string is used by FSgetcwd to return the cwd name if the path 
.................... // passed into the function is NULL 
.................... char defaultArray [10]; 
....................  
....................  
.................... /************************************************************** 
....................   Function: 
....................     char * FSgetcwd (char * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in Ascii format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in Ascii format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name 
....................     into the buffer backwards, and insert a backslash character. 
....................     Next, the function will continuously switch to the previous 
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the 
....................     root. 
....................   Remarks: 
....................     None 
....................   **************************************************************/ 
.................... char * FSgetcwd (char * path, int numchars) 
*
055BA:  MOV     W5,[W15++]
055BC:  MOV     W6,[W15++]
055BE:  MOV     W7,[W15++]
055C0:  CP0     1010
055C2:  BRA     NZ,55CA
055C4:  MOV     #A,W0
055C6:  GOTO    55CC
055CA:  MOV     1012,W0
055CC:  MOV     W0,1014
*
055D2:  MOV     #8F2,W4
055D4:  MOV     W4,101A
055D6:  CLR.B   101C
*
055E2:  CLR     1026
055E4:  CLR     1028
.................... { 
....................     // If path is passed in as null, set up a default 
....................     // array with 10 characters 
....................     unsigned short int totalchars = (path == NULL) ? 10 : numchars; 
....................     char * returnPointer; 
*
055CE:  CLR     1016
....................     char * bufferEnd; 
055D0:  CLR     1018
....................     FILEOBJ tempCWD = &gFileTemp; 
....................     BYTE bufferOverflow = FALSE; 
....................     signed char j; 
*
055D8:  CLR.B   101D
....................     DWORD curclus; 
055DA:  CLR     101E
055DC:  CLR     1020
....................     WORD fHandle, tempindex; 
055DE:  CLR     1022
055E0:  CLR     1024
....................     short int i = 0, index = 0; 
....................     char aChar; 
*
055E6:  CLR.B   102A
....................     DIRENTRY entry; 
055E8:  CLR     102C
....................  
....................    #if defined(SUPPORT_LFN) 
....................    WORD prevHandle; 
....................    UINT16_VAL tempShift; 
....................    FSFILE cwdTemp; 
....................    LFN_ENTRY *lfno; 
....................    unsigned short int *tempLFN = (unsigned short int *)&tempDirectoryString[0]; 
....................    #endif 
....................  
....................     FSerrno = CE_GOOD; 
055EA:  CLR.B   8B1
....................  
....................     // Set up the return value 
....................     if (path == NULL) 
055EC:  CP0     1010
055EE:  BRA     NZ,55F8
....................         returnPointer = defaultArray; 
055F0:  MOV     #D96,W4
055F2:  MOV     W4,1016
055F4:  GOTO    5608
....................     else 
....................     { 
....................         returnPointer = path; 
055F8:  PUSH    1010
055FA:  POP     1016
....................         if (numchars == 0) 
055FC:  CP0     1012
055FE:  BRA     NZ,5608
....................         { 
....................             FSerrno = CE_INVALID_ARGUMENT; 
05600:  MOV.B   #1F,W0L
05602:  MOV.B   W0L,8B1
....................             return NULL; 
05604:  CLR     0
05606:  BRA     599C
....................         } 
....................     } 
....................  
....................     bufferEnd = returnPointer + totalchars - 1; 
05608:  MOV     1016,W0
0560A:  ADD     1014,W0
0560C:  MOV     W0,W5
0560E:  SUB     W5,#1,W0
05610:  MOV     W0,1018
....................  
....................     FileObjectCopy (tempCWD, cwdptr); 
05612:  PUSH    101A
05614:  POP     105C
05616:  PUSH    95E
05618:  POP     105E
0561A:  CALL    28E2
....................  
....................     if (((tempCWD->name[0] == '.') && (tempCWD->name[1] == '.')) 
....................       #if defined(SUPPORT_LFN) 
0561E:  MOV     #1C,W0
05620:  ADD     101A,W0
05622:  MOV.B   [W0],W4L
05624:  XOR.B   #2E,W4L
05626:  BRA     NZ,578E
05628:  MOV     #1D,W0
0562A:  ADD     101A,W0
0562C:  MOV.B   [W0],W4L
0562E:  XOR.B   #2E,W4L
05630:  BRA     NZ,578E
....................        || tempCWD->utf16LFNlength 
....................       #endif 
....................       ) 
....................     { 
....................         // We last changed directory into a dotdot entry 
....................         // Save the value of the current directory 
....................         curclus = tempCWD->dirclus; 
05632:  MOV     #2E,W0
05634:  ADD     101A,W0
05636:  MOV     #101E,W4
05638:  MOV     [W0++],[W4++]
0563A:  MOV     [W0++],[W4++]
....................         // Put this dir's dotdot entry into the dirclus 
....................         // Our cwd absolutely is not the root 
....................         fHandle = 1; 
0563C:  MOV     #1,W4
0563E:  MOV     W4,1022
....................         tempCWD->dirccls = tempCWD->dirclus; 
05640:  MOV     #32,W0
05642:  ADD     101A,W0
05644:  MOV     W0,W5
05646:  MOV     #2E,W0
05648:  ADD     101A,W0
0564A:  MOV     [W0++],[W5++]
0564C:  MOV     [W0++],[W5++]
....................         entry = Cache_File_Entry (tempCWD,&fHandle, TRUE); 
0564E:  MOV.B   #1,W0L
05650:  MOV.B   W0L,1086
05652:  PUSH    101A
05654:  POP     1082
05656:  MOV     #1022,W4
05658:  MOV     W4,1084
0565A:  CALL    31E4
0565E:  MOV     W0,102C
....................         if (entry == NULL) 
05660:  CP0     102C
05662:  BRA     NZ,566C
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
05664:  MOV.B   #1B,W0L
05666:  MOV.B   W0L,8B1
....................             return NULL; 
05668:  CLR     0
0566A:  BRA     599C
....................         } 
....................  
....................        // Get the cluster 
....................        TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number. 
0566C:  PUSH    102C
0566E:  POP     1084
05670:  CALL    34B4
05674:  MOV     W0,8B6
05676:  MOV     W1,8B8
....................  
....................         // For FAT32, if the .. entry is 0, the cluster won't be 0 
.................... #ifdef SUPPORT_FAT32 
....................         if (TempClusterCalc == VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT) 
05678:  CP0     8B6
0567A:  BRA     NZ,5690
0567C:  CP0     8B8
0567E:  BRA     NZ,5690
....................         { 
....................             tempCWD->dirclus = FatRootDirClusterValue; 
05680:  MOV     #2E,W0
05682:  ADD     101A,W0
05684:  MOV     W0,W5
05686:  MOV     #8B2,W4
05688:  MOV     [W4++],[W5++]
0568A:  MOV     [W4++],[W5++]
....................         } 
0568C:  GOTO    569C
....................         else 
.................... #endif 
....................             tempCWD->dirclus = TempClusterCalc; 
05690:  MOV     #2E,W0
05692:  ADD     101A,W0
05694:  MOV     W0,W5
05696:  MOV     #8B6,W4
05698:  MOV     [W4++],[W5++]
0569A:  MOV     [W4++],[W5++]
....................  
....................         tempCWD->dirccls = tempCWD->dirclus; 
0569C:  MOV     #32,W0
0569E:  ADD     101A,W0
056A0:  MOV     W0,W5
056A2:  MOV     #2E,W0
056A4:  ADD     101A,W0
056A6:  MOV     [W0++],[W5++]
056A8:  MOV     [W0++],[W5++]
....................  
....................         // Find the direntry for the entry we were just in 
....................         fHandle = 0; 
056AA:  CLR     1022
....................         entry = Cache_File_Entry (tempCWD, &fHandle, TRUE); 
056AC:  MOV.B   #1,W0L
056AE:  MOV.B   W0L,1086
056B0:  PUSH    101A
056B2:  POP     1082
056B4:  MOV     #1022,W4
056B6:  MOV     W4,1084
056B8:  CALL    31E4
056BC:  MOV     W0,102C
....................         if (entry == NULL) 
056BE:  CP0     102C
056C0:  BRA     NZ,56CA
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
056C2:  MOV.B   #1B,W0L
056C4:  MOV.B   W0L,8B1
....................             return NULL; 
056C6:  CLR     0
056C8:  BRA     599C
....................         } 
....................  
....................         // Get the cluster 
....................         TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number. 
056CA:  PUSH    102C
056CC:  POP     1084
056CE:  CALL    34B4
056D2:  MOV     W0,8B6
056D4:  MOV     W1,8B8
....................  
....................         while ((TempClusterCalc != curclus) || 
....................             ((TempClusterCalc == curclus) && 
....................             (((unsigned char)entry->DIR_Name[0] == 0xE5) || (entry->DIR_Attr == ATTR_VOLUME) || (entry->DIR_Attr == ATTR_LONG_NAME)))) 
056D6:  MOV     8B6,W0
056D8:  CP      101E
056DA:  BRA     NZ,570C
056DC:  MOV     8B8,W0
056DE:  CP      1020
056E0:  BRA     NZ,570C
056E2:  MOV     8B6,W0
056E4:  CP      101E
056E6:  BRA     NZ,573A
056E8:  MOV     8B8,W0
056EA:  CP      1020
056EC:  BRA     NZ,573A
056EE:  MOV     #0,W0
056F0:  ADD     102C,W0
056F2:  MOV.B   [W0],W4L
056F4:  XOR.B   #E5,W4L
056F6:  BRA     Z,570C
056F8:  MOV     #B,W0
056FA:  ADD     102C,W0
056FC:  MOV.B   [W0],W4L
056FE:  CP.B    W4L,#8
05700:  BRA     Z,570C
05702:  MOV     #B,W0
05704:  ADD     102C,W0
05706:  MOV.B   [W0],W4L
05708:  CP.B    W4L,#F
0570A:  BRA     NZ,573A
....................         { 
....................             fHandle++; 
0570C:  INC     1022
....................             entry = Cache_File_Entry (tempCWD, &fHandle, FALSE); 
0570E:  CLR.B   1086
05710:  PUSH    101A
05712:  POP     1082
05714:  MOV     #1022,W4
05716:  MOV     W4,1084
05718:  CALL    31E4
0571C:  MOV     W0,102C
....................             if (entry == NULL) 
0571E:  CP0     102C
05720:  BRA     NZ,572A
....................             { 
....................                 FSerrno = CE_BADCACHEREAD; 
05722:  MOV.B   #1B,W0L
05724:  MOV.B   W0L,8B1
....................                 return NULL; 
05726:  CLR     0
05728:  BRA     599C
....................             } 
....................  
....................             // Get the cluster 
....................             TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number in a loop. 
0572A:  PUSH    102C
0572C:  POP     1084
0572E:  CALL    34B4
05732:  MOV     W0,8B6
05734:  MOV     W1,8B8
....................         } 
....................  
....................       #if defined(SUPPORT_LFN) 
05736:  GOTO    56D6
....................           FileObjectCopy (&cwdTemp, tempCWD); 
....................          prevHandle = fHandle - 1; 
....................  
....................          lfno = (LFN_ENTRY *)Cache_File_Entry (tempCWD, &prevHandle, FALSE); 
....................  
....................  
....................          while((lfno->LFN_Attribute == ATTR_LONG_NAME) && (lfno->LFN_SequenceNo != DIR_DEL) 
....................  
....................                && (lfno->LFN_SequenceNo != DIR_EMPTY)) 
....................  
....................          { 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[0]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[1]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[2]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[3]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[4]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[5]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[6]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[7]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[8]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[9]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................  
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[0]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[1]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[2]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[3]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[4]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[5]; 
....................  
....................  
....................  
....................             tempLFN[i++] = lfno->LFN_Part3[0]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part3[1]; 
....................  
....................  
....................  
....................             prevHandle = prevHandle - 1; 
....................  
....................             lfno = (LFN_ENTRY *)Cache_File_Entry (tempCWD, &prevHandle, FALSE); 
....................  
....................          } 
....................  
....................          FileObjectCopy (tempCWD, &cwdTemp); 
....................       #endif 
....................  
....................          if(i == 0) 
0573A:  CP0     1026
0573C:  BRA     NZ,5776
....................          { 
....................              for (j = 0; j < 11; j++) 
0573E:  CLR.B   101D
05740:  MOV.B   101D,W0L
05742:  SE      W0,W0
05744:  CP      W0,#B
05746:  BRA     GE,5776
....................               { 
....................                tempCWD->name[j] = entry->DIR_Name[j]; 
05748:  MOV.B   101D,W0L
0574A:  SE      W0,W0
0574C:  ADD     W0,#1C,W0
0574E:  MOV     101A,W4
05750:  ADD     W0,W4,W5
05752:  MOV.B   101D,W0L
05754:  SE      W0,W0
05756:  MOV     102C,W4
05758:  ADD     W0,W4,W0
0575A:  MOV.B   [W0],[W5]
....................                cwdptr->name[j] = entry->DIR_Name[j]; 
0575C:  MOV.B   101D,W0L
0575E:  SE      W0,W0
05760:  ADD     W0,#1C,W0
05762:  MOV     95E,W4
05764:  ADD     W0,W4,W5
05766:  MOV.B   101D,W0L
05768:  SE      W0,W0
0576A:  MOV     102C,W4
0576C:  ADD     W0,W4,W0
0576E:  MOV.B   [W0],[W5]
....................               } 
....................          #if defined(SUPPORT_LFN) 
05770:  INC.B   101D
05772:  GOTO    5740
....................             cwdptr->utf16LFNlength = 0; 
....................  
....................             tempCWD->utf16LFNlength = 0; 
....................  
....................          #endif 
....................          } 
....................  
....................       #if defined(SUPPORT_LFN) 
....................          else 
....................          { 
....................  
....................             tempCWD->utf16LFNlength = i; 
....................  
....................          for(j = 12;j >= 0;j--) 
....................          { 
....................             if((tempLFN[i - j - 1]) == 0x0000) 
....................             { 
....................                tempCWD->utf16LFNlength = i - j - 1; 
....................                break; 
....................             } 
....................          } 
....................          cwdptr->utf16LFNlength = tempCWD->utf16LFNlength; 
....................  
....................             tempCWD->utf16LFNptr = (unsigned short int *)&tempDirectoryString[0]; 
....................  
....................             cwdptr->utf16LFNptr = (unsigned short int *)&tempDirectoryString[0]; 
....................  
....................          } 
....................  
....................       #endif 
....................         // Reset our temp dir back to that cluster 
....................         tempCWD->dirclus = curclus; 
05776:  MOV     #2E,W0
05778:  ADD     101A,W0
0577A:  MOV     W0,W5
0577C:  MOV     #101E,W4
0577E:  MOV     [W4++],[W5++]
05780:  MOV     [W4++],[W5++]
....................         tempCWD->dirccls = curclus; 
05782:  MOV     #32,W0
05784:  ADD     101A,W0
05786:  MOV     W0,W5
05788:  MOV     #101E,W4
0578A:  MOV     [W4++],[W5++]
0578C:  MOV     [W4++],[W5++]
....................         // This will set us at the cwd, but it will actually 
....................         // have the name in the name field this time 
....................     } 
....................  
....................     // There's actually some kind of name value in the cwd 
....................    #if defined(SUPPORT_LFN) 
....................     if (((tempCWD->name[0] == '\\') && (tempCWD->utf16LFNlength == 0x0000)) || 
....................       ((tempCWD->utf16LFNlength != 0x0000) && (tempCWD->utf16LFNptr[0] == (unsigned short int)'\\')) || (numchars == 0x02)) 
....................    #else 
....................     if ((tempCWD->name[0] == '\\') || (numchars == 0x02)) 
0578E:  MOV     #1C,W0
05790:  ADD     101A,W0
05792:  MOV.B   [W0],W4L
05794:  XOR.B   #5C,W4L
05796:  BRA     Z,579E
05798:  MOV     1012,W4
0579A:  CP      W4,#2
0579C:  BRA     NZ,57B8
....................    #endif 
....................     { 
....................         // Easy, our CWD is the root 
....................         *returnPointer = '\\'; 
0579E:  MOV     1016,W5
057A0:  MOV.B   #5C,W0L
057A2:  MOV.B   W0L,[W5]
....................         *(returnPointer + 1) = 0; 
057A4:  MOV     1016,W4
057A6:  ADD     W4,#1,W4
057A8:  MOV     W4,W0
057AA:  MOV     W0,W5
057AC:  CLR.B   [W5]
....................         return returnPointer; 
057AE:  PUSH    1016
057B0:  POP     0
057B2:  BRA     599C
....................     } 
057B4:  GOTO    58CE
....................     else 
....................     { 
....................         index = 0; 
057B8:  CLR     1028
....................         // Loop until we get back to the root 
....................         while (tempCWD->dirclus != FatRootDirClusterValue) 
057BA:  MOV     #2E,W0
057BC:  ADD     101A,W0
057BE:  MOV     #A,W4
057C0:  MOV     [W0++],[W4++]
057C2:  MOV     [W0++],[W4++]
057C4:  MOV     8B2,W4
057C6:  CP      W4,W5
057C8:  BRA     NZ,57D0
057CA:  MOV     8B4,W4
057CC:  CP      W4,W6
057CE:  BRA     Z,58CE
....................         { 
....................          #if defined(SUPPORT_LFN) 
....................             if(tempCWD->utf16LFNlength) 
....................             { 
....................              i = tempCWD->utf16LFNlength * 2 - 1; 
....................              while(i >= 0) 
....................             { 
....................                #ifdef SUPPORT_LFN 
....................                if(twoByteMode) 
....................                { 
....................                   returnPointer[index++] = tempDirectoryString[i--]; 
....................                       if (index == totalchars) 
....................                       { 
....................                           index = 0; 
....................                           bufferOverflow = TRUE; 
....................                       } 
....................                } 
....................                else 
....................                #endif 
....................                { 
....................                   if(tempDirectoryString[i]) 
....................                   { 
....................                      returnPointer[index++] = tempDirectoryString[i]; 
....................                               if (index == totalchars) 
....................                               { 
....................                                   index = 0; 
....................                                   bufferOverflow = TRUE; 
....................                               } 
....................  
....................                   } 
....................                   i--; 
....................                } 
....................             } 
....................          } 
....................          else 
....................          #endif 
....................          { 
....................                j = 10; 
057D0:  MOV.B   #A,W0L
057D2:  MOV.B   W0L,101D
....................                while (tempCWD->name[j] == 0x20) 
057D4:  MOV.B   101D,W0L
057D6:  SE      W0,W0
057D8:  ADD     W0,#1C,W0
057DA:  MOV     101A,W4
057DC:  ADD     W0,W4,W0
057DE:  MOV.B   [W0],W5L
057E0:  SE      W5,W5
057E2:  MOV     #20,W4
057E4:  CP      W4,W5
057E6:  BRA     NZ,57EE
....................                    j--; 
057E8:  DEC.B   101D
057EA:  GOTO    57D4
....................                if (j >= 8) 
057EE:  MOV.B   101D,W0L
057F0:  SE      W0,W0
057F2:  CP      W0,#8
057F4:  BRA     LT,5842
....................                { 
....................                    while (j >= 8) 
057F6:  MOV.B   101D,W0L
057F8:  SE      W0,W0
057FA:  CP      W0,#8
057FC:  BRA     LT,5828
....................                    { 
....................                        *(returnPointer + index++) = tempCWD->name[j--]; 
057FE:  MOV     1028,W0
05800:  INC     1028
05802:  MOV     1016,W4
05804:  ADD     W0,W4,W0
05806:  MOV     W0,W5
05808:  MOV.B   101D,W0L
0580A:  DEC.B   101D
0580C:  SE      W0,W6
0580E:  ADD     W6,#1C,W6
05810:  MOV     W6,W0
05812:  MOV     101A,W4
05814:  ADD     W0,W4,W0
05816:  MOV.B   [W0],[W5]
....................                        // This is a circular buffer 
....................                        // Any unnecessary values will be overwritten 
....................                        if (index == totalchars) 
05818:  MOV     1028,W0
0581A:  CP      1014
0581C:  BRA     NZ,5824
....................                        { 
....................                            index = 0; 
0581E:  CLR     1028
....................                            bufferOverflow = TRUE; 
05820:  MOV.B   #1,W0L
05822:  MOV.B   W0L,101C
....................                        } 
....................  
....................                   #ifdef SUPPORT_LFN 
05824:  GOTO    57F6
....................                   if(twoByteMode) 
....................                   { 
....................                      returnPointer[index++] = 0x00; 
....................                            if (index == totalchars) 
....................                            { 
....................                                index = 0; 
....................                                bufferOverflow = TRUE; 
....................                            } 
....................                   } 
....................                   #endif 
....................                    } 
....................  
....................                    *(returnPointer + index++) = '.'; 
05828:  MOV     1028,W0
0582A:  INC     1028
0582C:  MOV     1016,W4
0582E:  ADD     W0,W4,W0
05830:  MOV     W0,W5
05832:  MOV.B   #2E,W0L
05834:  MOV.B   W0L,[W5]
....................                    if (index == totalchars) 
05836:  MOV     1028,W0
05838:  CP      1014
0583A:  BRA     NZ,5842
....................                    { 
....................                        index = 0; 
0583C:  CLR     1028
....................                        bufferOverflow = TRUE; 
0583E:  MOV.B   #1,W0L
05840:  MOV.B   W0L,101C
....................                    } 
....................  
....................                #ifdef SUPPORT_LFN 
....................                if(twoByteMode) 
....................                { 
....................                   returnPointer[index++] = 0x00; 
....................                        if (index == totalchars) 
....................                        { 
....................                            index = 0; 
....................                            bufferOverflow = TRUE; 
....................                        } 
....................                } 
....................                #endif 
....................                } 
....................  
....................                while (tempCWD->name[j] == 0x20) 
05842:  MOV.B   101D,W0L
05844:  SE      W0,W0
05846:  ADD     W0,#1C,W0
05848:  MOV     101A,W4
0584A:  ADD     W0,W4,W0
0584C:  MOV.B   [W0],W5L
0584E:  SE      W5,W5
05850:  MOV     #20,W4
05852:  CP      W4,W5
05854:  BRA     NZ,585C
....................                    j--; 
05856:  DEC.B   101D
05858:  GOTO    5842
....................  
....................                while (j >= 0) 
0585C:  MOV.B   101D,W0L
0585E:  SE      W0,W0
05860:  CP      W0,#0
05862:  BRA     LT,588E
....................                { 
....................                    *(returnPointer + index++) = tempCWD->name[j--]; 
05864:  MOV     1028,W0
05866:  INC     1028
05868:  MOV     1016,W4
0586A:  ADD     W0,W4,W0
0586C:  MOV     W0,W5
0586E:  MOV.B   101D,W0L
05870:  DEC.B   101D
05872:  SE      W0,W6
05874:  ADD     W6,#1C,W6
05876:  MOV     W6,W0
05878:  MOV     101A,W4
0587A:  ADD     W0,W4,W0
0587C:  MOV.B   [W0],[W5]
....................                    // This is a circular buffer 
....................                    // Any unnecessary values will be overwritten 
....................                    if (index == totalchars) 
0587E:  MOV     1028,W0
05880:  CP      1014
05882:  BRA     NZ,588A
....................                    { 
....................                        index = 0; 
05884:  CLR     1028
....................                        bufferOverflow = TRUE; 
05886:  MOV.B   #1,W0L
05888:  MOV.B   W0L,101C
....................                    } 
....................  
....................                #ifdef SUPPORT_LFN 
0588A:  GOTO    585C
....................                if(twoByteMode) 
....................                { 
....................                   returnPointer[index++] = 0x00; 
....................                        if (index == totalchars) 
....................                        { 
....................                            index = 0; 
....................                            bufferOverflow = TRUE; 
....................                        } 
....................                } 
....................                #endif 
....................                } 
....................          } 
....................  
....................          #ifdef SUPPORT_LFN 
....................          if(twoByteMode) 
....................          { 
....................             returnPointer[index++] = 0x00; 
....................                if (index == totalchars) 
....................                { 
....................                    index = 0; 
....................                    bufferOverflow = TRUE; 
....................                } 
....................          } 
....................          #endif 
....................  
....................             // Put a backslash delimiter in front of the dir name 
....................             *(returnPointer + index++) = '\\'; 
0588E:  MOV     1028,W0
05890:  INC     1028
05892:  MOV     1016,W4
05894:  ADD     W0,W4,W0
05896:  MOV     W0,W5
05898:  MOV.B   #5C,W0L
0589A:  MOV.B   W0L,[W5]
....................             if (index == totalchars) 
0589C:  MOV     1028,W0
0589E:  CP      1014
058A0:  BRA     NZ,58A8
....................             { 
....................                 index = 0; 
058A2:  CLR     1028
....................                 bufferOverflow = TRUE; 
058A4:  MOV.B   #1,W0L
058A6:  MOV.B   W0L,101C
....................             } 
....................  
....................             // Load the previous entry 
....................             tempCWD->dirccls = tempCWD->dirclus; 
058A8:  MOV     #32,W0
058AA:  ADD     101A,W0
058AC:  MOV     W0,W5
058AE:  MOV     #2E,W0
058B0:  ADD     101A,W0
058B2:  MOV     [W0++],[W5++]
058B4:  MOV     [W0++],[W5++]
....................             if (GetPreviousEntry (tempCWD)) 
058B6:  PUSH    101A
058B8:  POP     1032
058BA:  CALL    53FC
058BE:  CP0.B   W0L
058C0:  BRA     Z,58CA
....................             { 
....................                 FSerrno = CE_BAD_SECTOR_READ; 
058C2:  MOV.B   #8,W0L
058C4:  MOV.B   W0L,8B1
....................                 return NULL; 
058C6:  CLR     0
058C8:  BRA     599C
....................             } 
058CA:  GOTO    57BA
....................         } 
....................     } 
....................  
....................     // Point the index back at the last char in the string 
....................     index--; 
058CE:  DEC     1028
....................  
....................     i = 0; 
058D0:  CLR     1026
....................     // Swap the chars in the buffer so they are in the right places 
....................     if (bufferOverflow) 
058D2:  CP0.B   101C
058D4:  BRA     Z,5954
....................     { 
....................         tempindex = index; 
058D6:  PUSH    1028
058D8:  POP     1024
....................         // Swap the overflowed values in the buffer 
....................         while ((index - i) > 0) 
058DA:  MOV     1028,W4
058DC:  MOV     1026,W3
058DE:  SUB     W4,W3,W5
058E0:  CP      W5,#0
058E2:  BRA     LE,590C
....................         { 
....................              aChar = *(returnPointer + i); 
058E4:  MOV     1016,W0
058E6:  ADD     1026,W0
058E8:  MOV     102A,W4
058EA:  MOV.B   [W0+#0],W4L
058EC:  MOV     W4,102A
....................              *(returnPointer + i) = * (returnPointer + index); 
058EE:  MOV     1016,W0
058F0:  ADD     1026,W0
058F2:  MOV     W0,W5
058F4:  MOV     1016,W0
058F6:  ADD     1028,W0
058F8:  MOV.B   [W0],[W5]
....................              *(returnPointer + index) = aChar; 
058FA:  MOV     1016,W0
058FC:  ADD     1028,W0
058FE:  MOV     W0,W5
05900:  MOV     102A,W0
05902:  MOV.B   W0L,[W5+#0]
....................              index--; 
05904:  DEC     1028
....................              i++; 
05906:  INC     1026
05908:  GOTO    58DA
....................         } 
....................  
....................         // Point at the non-overflowed values 
....................         i = tempindex + 1; 
0590C:  MOV     1024,W4
0590E:  ADD     W4,#1,W4
05910:  MOV     W4,1026
....................         index = bufferEnd - returnPointer; 
05912:  MOV     1018,W4
05914:  MOV     1016,W3
05916:  SUB     W4,W3,W0
05918:  MOV     W0,1028
....................  
....................         // Swap the non-overflowed values into the right places 
....................         while ((index - i) > 0) 
0591A:  MOV     1028,W4
0591C:  MOV     1026,W3
0591E:  SUB     W4,W3,W5
05920:  CP      W5,#0
05922:  BRA     LE,594C
....................         { 
....................              aChar = *(returnPointer + i); 
05924:  MOV     1016,W0
05926:  ADD     1026,W0
05928:  MOV     102A,W4
0592A:  MOV.B   [W0+#0],W4L
0592C:  MOV     W4,102A
....................              *(returnPointer + i) = * (returnPointer + index); 
0592E:  MOV     1016,W0
05930:  ADD     1026,W0
05932:  MOV     W0,W5
05934:  MOV     1016,W0
05936:  ADD     1028,W0
05938:  MOV.B   [W0],[W5]
....................              *(returnPointer + index) = aChar; 
0593A:  MOV     1016,W0
0593C:  ADD     1028,W0
0593E:  MOV     W0,W5
05940:  MOV     102A,W0
05942:  MOV.B   W0L,[W5+#0]
....................              index--; 
05944:  DEC     1028
....................              i++; 
05946:  INC     1026
05948:  GOTO    591A
....................         } 
....................         // All the values should be in the right place now 
....................         // Null-terminate the string 
....................         *(bufferEnd) = 0; 
0594C:  MOV     1018,W5
0594E:  CLR.B   [W5]
....................     } 
05950:  GOTO    5998
....................     else 
....................     { 
....................         // There was no overflow, just do one set of swaps 
....................         tempindex = index; 
05954:  PUSH    1028
05956:  POP     1024
....................         while ((index - i) > 0) 
05958:  MOV     1028,W4
0595A:  MOV     1026,W3
0595C:  SUB     W4,W3,W5
0595E:  CP      W5,#0
05960:  BRA     LE,598A
....................         { 
....................             aChar = *(returnPointer + i); 
05962:  MOV     1016,W0
05964:  ADD     1026,W0
05966:  MOV     102A,W4
05968:  MOV.B   [W0+#0],W4L
0596A:  MOV     W4,102A
....................             *(returnPointer + i) = * (returnPointer + index); 
0596C:  MOV     1016,W0
0596E:  ADD     1026,W0
05970:  MOV     W0,W5
05972:  MOV     1016,W0
05974:  ADD     1028,W0
05976:  MOV.B   [W0],[W5]
....................             *(returnPointer + index) = aChar; 
05978:  MOV     1016,W0
0597A:  ADD     1028,W0
0597C:  MOV     W0,W5
0597E:  MOV     102A,W0
05980:  MOV.B   W0L,[W5+#0]
....................             index--; 
05982:  DEC     1028
....................             i++; 
05984:  INC     1026
05986:  GOTO    5958
....................         } 
....................         *(returnPointer + tempindex + 1) = 0; 
0598A:  MOV     1016,W0
0598C:  ADD     1024,W0
0598E:  MOV     W0,W5
05990:  ADD     W5,#1,W5
05992:  MOV     W5,W0
05994:  MOV     W0,W5
05996:  CLR.B   [W5]
....................     } 
....................  
....................     return returnPointer; 
05998:  PUSH    1016
0599A:  POP     0
0599C:  MOV     [--W15],W7
0599E:  MOV     [--W15],W6
059A0:  MOV     [--W15],W5
059A2:  RETURN  
.................... } 
....................  
.................... #ifdef SUPPORT_LFN 
....................  
.................... /************************************************************** 
....................   Function: 
....................     char * wFSgetcwd (unsigned short int * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in UTF16 format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in UTF16 format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name 
....................     into the buffer backwards, and insert a backslash character. 
....................     Next, the function will continuously switch to the previous 
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the 
....................     root. 
....................   Remarks: 
....................     None 
....................   **************************************************************/ 
.................... char * wFSgetcwd (unsigned short int * path, int numchars) 
.................... { 
....................    char *result; 
....................    twoByteMode = TRUE; 
....................     result = FSgetcwd ((char *)path,numchars); 
....................    twoByteMode = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     void GetPreviousEntry (FSFILE * fo) 
....................   Summary: 
....................     Get the file entry info for the parent dir of the specified dir 
....................   Conditions: 
....................     Should not be called by the user. 
....................   Input: 
....................     fo -  The file to get the previous entry of 
....................   Return Values: 
....................     0 -  The previous entry was successfully retrieved 
....................     -1 - The previous entry could not be retrieved 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The GetPreviousEntry function is used by the FSgetcwd function to 
....................     load the previous (parent) directory.  This function will load the 
....................     parent directory and then search through the file entries in that 
....................     directory for one that matches the cluster number of the original 
....................     directory.  When the matching entry is found, the name of the 
....................     original directory is copied into the 'fo' FSFILE object. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... BYTE GetPreviousEntry (FSFILE * fo) 
*
053FC:  MOV     W5,[W15++]
*
05402:  MOV     #1,W4
05404:  MOV     W4,1038
.................... { 
....................     int i,j; 
*
053FE:  CLR     1034
05400:  CLR     1036
....................     WORD fHandle = 1; 
....................     DWORD dirclus; 
*
05406:  CLR     103A
05408:  CLR     103C
....................     DIRENTRY dirptr; 
0540A:  CLR     103E
....................  
....................    #ifdef SUPPORT_LFN 
....................       unsigned short int *tempLFN = (unsigned short int *)&tempDirectoryString[0]; 
....................       FSFILE cwdTemp; 
....................       LFN_ENTRY *lfno; 
....................  
....................       WORD prevHandle; 
....................       UINT16_VAL tempShift; 
....................  
....................    #endif 
....................  
....................     // Load the previous entry 
....................     dirptr = Cache_File_Entry (fo, &fHandle, TRUE); 
0540C:  MOV.B   #1,W0L
0540E:  MOV.B   W0L,1086
05410:  PUSH    1032
05412:  POP     1082
05414:  MOV     #1038,W4
05416:  MOV     W4,1084
05418:  CALL    31E4
0541C:  MOV     W0,103E
....................     if (dirptr == NULL) 
0541E:  CP0     103E
05420:  BRA     NZ,5426
....................         return -1; 
05422:  SETM.B  0
05424:  BRA     55B6
....................  
....................     // Get the cluster 
....................     TempClusterCalc = GetFullClusterNumber(dirptr); // Get complete cluster number. 
05426:  PUSH    103E
05428:  POP     1084
0542A:  CALL    34B4
0542E:  MOV     W0,8B6
05430:  MOV     W1,8B8
....................  
....................     if (TempClusterCalc == VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT) 
05432:  CP0     8B6
05434:  BRA     NZ,547A
05436:  CP0     8B8
05438:  BRA     NZ,547A
....................     { 
....................         // The previous directory is the root 
....................         fo->name[0] = '\\'; 
0543A:  MOV     #1C,W0
0543C:  ADD     1032,W0
0543E:  MOV     W0,W5
05440:  MOV.B   #5C,W0L
05442:  MOV.B   W0L,[W5]
....................         for (i = 0; i < 11; i++) 
05444:  CLR     1034
05446:  MOV     1034,W4
05448:  CP      W4,#B
0544A:  BRA     GE,545E
....................         { 
....................             fo->name[i] = 0x20; 
0544C:  MOV     #1C,W0
0544E:  ADD     1034,W0
05450:  MOV     1032,W4
05452:  ADD     W0,W4,W5
05454:  MOV.B   #20,W0L
05456:  MOV.B   W0L,[W5]
05458:  INC     1034
0545A:  GOTO    5446
....................         } 
....................         fo->dirclus = FatRootDirClusterValue; 
0545E:  MOV     #2E,W0
05460:  ADD     1032,W0
05462:  MOV     W0,W5
05464:  MOV     #8B2,W4
05466:  MOV     [W4++],[W5++]
05468:  MOV     [W4++],[W5++]
....................         fo->dirccls = FatRootDirClusterValue; 
0546A:  MOV     #32,W0
0546C:  ADD     1032,W0
0546E:  MOV     W0,W5
05470:  MOV     #8B2,W4
05472:  MOV     [W4++],[W5++]
05474:  MOV     [W4++],[W5++]
....................     } 
05476:  GOTO    5592
....................     else 
....................     { 
....................         // Get the directory name 
....................         // Save the previous cluster value 
....................        // Get the cluster 
....................  
....................         dirclus = TempClusterCalc; 
0547A:  PUSH    8B6
0547C:  POP     103A
0547E:  PUSH    8B8
05480:  POP     103C
....................         fo->dirclus = TempClusterCalc; 
05482:  MOV     #2E,W0
05484:  ADD     1032,W0
05486:  MOV     W0,W5
05488:  MOV     #8B6,W4
0548A:  MOV     [W4++],[W5++]
0548C:  MOV     [W4++],[W5++]
....................         fo->dirccls = TempClusterCalc; 
0548E:  MOV     #32,W0
05490:  ADD     1032,W0
05492:  MOV     W0,W5
05494:  MOV     #8B6,W4
05496:  MOV     [W4++],[W5++]
05498:  MOV     [W4++],[W5++]
....................  
....................  
....................         // Load the previous previous cluster 
....................         dirptr = Cache_File_Entry (fo, &fHandle, TRUE); 
0549A:  MOV.B   #1,W0L
0549C:  MOV.B   W0L,1086
0549E:  PUSH    1032
054A0:  POP     1082
054A2:  MOV     #1038,W4
054A4:  MOV     W4,1084
054A6:  CALL    31E4
054AA:  MOV     W0,103E
....................         if (dirptr == NULL) 
054AC:  CP0     103E
054AE:  BRA     NZ,54B4
....................             return -1; 
054B0:  SETM.B  0
054B2:  BRA     55B6
....................  
....................        // Get the cluster 
....................         TempClusterCalc = GetFullClusterNumber(dirptr); // Get complete cluster number. 
054B4:  PUSH    103E
054B6:  POP     1084
054B8:  CALL    34B4
054BC:  MOV     W0,8B6
054BE:  MOV     W1,8B8
.................... #ifdef SUPPORT_FAT32 
....................         // If we're using FAT32 and the previous previous cluster is the root, the 
....................         // value in the dotdot entry will be 0, but the actual cluster won't 
....................         if (TempClusterCalc == VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT) 
054C0:  CP0     8B6
054C2:  BRA     NZ,54D8
054C4:  CP0     8B8
054C6:  BRA     NZ,54D8
....................         { 
....................             fo->dirclus = FatRootDirClusterValue; 
054C8:  MOV     #2E,W0
054CA:  ADD     1032,W0
054CC:  MOV     W0,W5
054CE:  MOV     #8B2,W4
054D0:  MOV     [W4++],[W5++]
054D2:  MOV     [W4++],[W5++]
....................         } 
054D4:  GOTO    54E4
....................         else 
.................... #endif 
....................             fo->dirclus = TempClusterCalc; 
054D8:  MOV     #2E,W0
054DA:  ADD     1032,W0
054DC:  MOV     W0,W5
054DE:  MOV     #8B6,W4
054E0:  MOV     [W4++],[W5++]
054E2:  MOV     [W4++],[W5++]
....................  
....................         fo->dirccls = fo->dirclus; 
054E4:  MOV     #32,W0
054E6:  ADD     1032,W0
054E8:  MOV     W0,W5
054EA:  MOV     #2E,W0
054EC:  ADD     1032,W0
054EE:  MOV     [W0++],[W5++]
054F0:  MOV     [W0++],[W5++]
....................  
....................         fHandle = 0; 
054F2:  CLR     1038
....................         dirptr = Cache_File_Entry (fo, &fHandle, TRUE); 
054F4:  MOV.B   #1,W0L
054F6:  MOV.B   W0L,1086
054F8:  PUSH    1032
054FA:  POP     1082
054FC:  MOV     #1038,W4
054FE:  MOV     W4,1084
05500:  CALL    31E4
05504:  MOV     W0,103E
....................         if (dirptr == NULL) 
05506:  CP0     103E
05508:  BRA     NZ,550E
....................             return -1; 
0550A:  SETM.B  0
0550C:  BRA     55B6
....................         // Look through it until we get the name 
....................         // of the previous cluster 
....................         // Get the cluster 
....................         TempClusterCalc = GetFullClusterNumber(dirptr); // Get complete cluster number. 
0550E:  PUSH    103E
05510:  POP     1084
05512:  CALL    34B4
05516:  MOV     W0,8B6
05518:  MOV     W1,8B8
....................         while ((TempClusterCalc != dirclus) || 
....................             ((TempClusterCalc == dirclus) && 
....................             (((unsigned char)dirptr->DIR_Name[0] == 0xE5) || (dirptr->DIR_Attr == ATTR_VOLUME) || (dirptr->DIR_Attr == ATTR_LONG_NAME)))) 
0551A:  MOV     8B6,W0
0551C:  CP      103A
0551E:  BRA     NZ,5550
05520:  MOV     8B8,W0
05522:  CP      103C
05524:  BRA     NZ,5550
05526:  MOV     8B6,W0
05528:  CP      103A
0552A:  BRA     NZ,557A
0552C:  MOV     8B8,W0
0552E:  CP      103C
05530:  BRA     NZ,557A
05532:  MOV     #0,W0
05534:  ADD     103E,W0
05536:  MOV.B   [W0],W4L
05538:  XOR.B   #E5,W4L
0553A:  BRA     Z,5550
0553C:  MOV     #B,W0
0553E:  ADD     103E,W0
05540:  MOV.B   [W0],W4L
05542:  CP.B    W4L,#8
05544:  BRA     Z,5550
05546:  MOV     #B,W0
05548:  ADD     103E,W0
0554A:  MOV.B   [W0],W4L
0554C:  CP.B    W4L,#F
0554E:  BRA     NZ,557A
....................         { 
....................             // Look through the entries until we get the 
....................             // right one 
....................             dirptr = Cache_File_Entry (fo, &fHandle, FALSE); 
05550:  CLR.B   1086
05552:  PUSH    1032
05554:  POP     1082
05556:  MOV     #1038,W4
05558:  MOV     W4,1084
0555A:  CALL    31E4
0555E:  MOV     W0,103E
....................             if (dirptr == NULL) 
05560:  CP0     103E
05562:  BRA     NZ,5568
....................                 return -1; 
05564:  SETM.B  0
05566:  BRA     55B6
....................             fHandle++; 
05568:  INC     1038
....................  
....................            TempClusterCalc = GetFullClusterNumber(dirptr); // Get complete cluster number in a loop. 
0556A:  PUSH    103E
0556C:  POP     1084
0556E:  CALL    34B4
05572:  MOV     W0,8B6
05574:  MOV     W1,8B8
05576:  GOTO    551A
....................         } 
....................  
....................         // The name should be in the entry now 
....................         // Copy the actual directory location back 
....................         fo->dirclus = dirclus; 
0557A:  MOV     #2E,W0
0557C:  ADD     1032,W0
0557E:  MOV     W0,W5
05580:  MOV     #103A,W4
05582:  MOV     [W4++],[W5++]
05584:  MOV     [W4++],[W5++]
....................         fo->dirccls = dirclus; 
05586:  MOV     #32,W0
05588:  ADD     1032,W0
0558A:  MOV     W0,W5
0558C:  MOV     #103A,W4
0558E:  MOV     [W4++],[W5++]
05590:  MOV     [W4++],[W5++]
....................    } 
....................  
....................       i = 0; 
05592:  CLR     1034
....................    #ifdef SUPPORT_LFN 
....................           FileObjectCopy (&cwdTemp, fo); 
....................          prevHandle = fHandle - 2; 
....................  
....................          lfno = (LFN_ENTRY *)Cache_File_Entry (fo, &prevHandle, FALSE); 
....................  
....................       // Get the long file name of the short file name(if present) 
....................          while((lfno->LFN_Attribute == ATTR_LONG_NAME) && (lfno->LFN_SequenceNo != DIR_DEL) 
....................  
....................                && (lfno->LFN_SequenceNo != DIR_EMPTY)) 
....................  
....................          { 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[0]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[1]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[2]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[3]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[4]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[5]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[6]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[7]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[8]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[9]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[0]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[1]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[2]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[3]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[4]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[5]; 
....................  
....................  
....................             tempLFN[i++] = lfno->LFN_Part3[0]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part3[1]; 
....................  
....................  
....................  
....................             prevHandle = prevHandle - 1; 
....................  
....................             lfno = (LFN_ENTRY *)Cache_File_Entry (fo, &prevHandle, FALSE); 
....................  
....................          } 
....................  
....................  
....................          FileObjectCopy (fo, &cwdTemp); 
....................    #endif 
....................  
....................       if(i == 0) 
05594:  CP0     1034
05596:  BRA     NZ,55B4
....................  
....................    { 
....................           for (j = 0; j < 11; j++) 
05598:  CLR     1036
0559A:  MOV     1036,W4
0559C:  CP      W4,#B
0559E:  BRA     GE,55B4
....................            fo->name[j] = dirptr->DIR_Name[j]; 
055A0:  MOV     #1C,W0
055A2:  ADD     1036,W0
055A4:  MOV     1032,W4
055A6:  ADD     W0,W4,W5
055A8:  MOV     1036,W0
055AA:  ADD     103E,W0
055AC:  MOV.B   [W0],[W5]
055AE:  INC     1036
055B0:  GOTO    559A
....................       #ifdef SUPPORT_LFN 
....................             fo->utf16LFNlength = 0; 
....................  
....................          #endif 
....................       } 
....................    #ifdef SUPPORT_LFN 
....................       else 
....................  
....................       { 
....................  
....................       fo->utf16LFNlength = i; 
....................  
....................  
....................  
....................       for(j = 12;j >= 0;j--) 
....................  
....................       { 
....................  
....................          if((tempLFN[i - j - 1]) == 0x0000) 
....................  
....................          { 
....................  
....................             fo->utf16LFNlength = i - j - 1; 
....................  
....................             break; 
....................  
....................          } 
....................  
....................       } 
....................  
....................  
....................          fo->utf16LFNptr = (unsigned short int *)&tempDirectoryString[0]; 
....................  
....................       } 
....................  
....................    #endif 
....................  
....................     return 0; 
055B4:  CLR.B   0
055B6:  MOV     [--W15],W5
055B8:  RETURN  
.................... } 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdir (char * path) 
....................   Summary: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno 
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... int FSmkdir (char * path) 
.................... { 
....................     return mkdirhelper (0, path, NULL); 
*
07678:  CLR.B   FD4
0767A:  PUSH    FD0
0767C:  POP     FD6
0767E:  CLR     FD8
07680:  CALL    72F2
07684:  MOV     W0,0
07686:  RETURN  
.................... } 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int wFSmkdir (unsigned short int * path) 
....................   Summary: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno 
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSmkdir (unsigned short int * path) 
.................... { 
....................    int   result; 
....................    utfModeFileName = TRUE; 
....................     result = mkdirhelper (0, (char *)path, NULL); 
....................    utfModeFileName = FALSE; 
....................     return result; 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdirpgm (const rom char * path) 
....................   Summary: 
....................     Creates a directory as per the path mentioned in the input string on 
....................     PIC18 devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create (ROM) 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno 
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the path mentioned in the input string on 
....................     PIC18 devices.'FSmkdirpgm' creates the directories as per the input 
....................     string path.This function doesn't move the current working 
....................     directory setting. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arugments in ROM 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int FSmkdirpgm (const rom char * path) 
.................... { 
....................     return mkdirhelper (1, NULL, path); 
.................... } 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int wFSmkdirpgm (const rom unsigned short int * path) 
....................   Summary: 
....................     Create a directory with a path in ROM on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create (ROM) 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno 
....................     variable will be changed. 
....................   Description: 
....................     The FSmkdirpgm function passes a PIC18 ROM path pointer to the 
....................     mkdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arugments in ROM 
....................   **************************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSmkdirpgm (const rom unsigned short int * path) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................     result = mkdirhelper (1, NULL, (const char *)path); 
....................    utfModeFileName = FALSE; 
....................     return result; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int mkdirhelper (BYTE mode, char * ramptr, char * romptr) 
....................     // PIC18 
....................     int mkdirhelper (BYTE mode, char * ramptr, const rom char * romptr) 
....................   Summary: 
....................     Helper function for FSmkdir 
....................   Conditions: 
....................     None 
....................   Input: 
....................     mode -   Indicates which path pointer to use 
....................     ramptr - Pointer to the path specified in RAM 
....................     romptr - Pointer to the path specified in ROM 
....................   Return Values: 
....................     0 -  Directory was created 
....................     -1 - Directory could not be created 
....................   Side Effects: 
....................     Will create all non-existant directories in the path. 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This helper function is used by the FSchdir function. If the path 
....................     argument is specified in ROM for PIC18 this function will be able 
....................     to parse it correctly.  This function will first scan through the path 
....................     to ensure that any DIR names don't exceed 11 characters.  It will then 
....................     backup the current working directory and begin changing directories 
....................     through the path until it reaches a directory than can't be changed to. 
....................     It will then create the specified directory and change directories to 
....................     the new directory. The function will continue creating and changing to 
....................     directories until the end of the path is reached.  The function will 
....................     then restore the original current working directory. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int mkdirhelper (BYTE mode, char * ramptr, const rom char * romptr) 
.................... #else 
.................... int mkdirhelper (BYTE mode, char * ramptr, char * romptr) 
.................... #endif 
*
072F2:  MOV     W5,[W15++]
072F4:  MOV     W6,[W15++]
*
072F8:  CLR     FDC
072FA:  CLR     FDE
072FC:  PUSH    FD6
072FE:  POP     FE0
07300:  PUSH    FD6
07302:  POP     FE2
07304:  MOV     #8BC,W4
07306:  MOV     W4,FE4
.................... { 
....................     unsigned short int i,j = 0,k = 0; 
*
072F6:  CLR     FDA
....................     char * temppath = ramptr; 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     rom char * temppath2 = romptr; 
....................     rom unsigned short int * utf16path2 = (rom unsigned short int *)romptr; 
.................... #endif 
....................    unsigned short int *utf16path = (unsigned short int *)ramptr; 
....................     FILEOBJ tempCWD = &tempCWDobj; 
....................  
.................... #ifdef __18CXX 
....................     char dotdotPath[] = ".."; 
....................     char dotdotPath1[5] = {'.','\0','.','\0','\0'}; 
.................... #endif 
....................  
.................... // Do Dynamic allocation if the macro is defined or 
.................... // go with static allocation 
.................... #if defined(SUPPORT_LFN) 
....................    char tempArray[514]; 
.................... #else 
....................    char tempArray[14]; 
*
07308:  CLR     FE6
0730A:  CLR     FE8
0730C:  CLR     FEA
0730E:  CLR     FEC
07310:  CLR     FEE
07312:  CLR     FF0
07314:  CLR     FF2
.................... #endif 
....................  
....................     FSerrno = CE_GOOD; 
07316:  CLR.B   8B1
....................  
....................     if (MDD_WriteProtectState()) 
07318:  CALL    25A0
0731C:  CP0.B   W0L
0731E:  BRA     Z,7328
....................     { 
....................         FSerrno = CE_WRITE_PROTECTED; 
07320:  MOV.B   #18,W0L
07322:  MOV.B   W0L,8B1
....................         return (-1); 
07324:  SETM    0
07326:  BRA     7672
....................     } 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     if (mode == 1) 
....................     { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................       { 
....................            // Scan for too-long file names 
....................            while (1) 
....................            { 
....................                i = 0; 
....................                while((*utf16path2 != 0) && (*utf16path2 != '.')&& (*utf16path2 != '\\')) 
....................                { 
....................                    utf16path2++; 
....................                    i++; 
....................                } 
....................  
....................               if (i > 256) 
....................               { 
....................                   FSerrno = CE_INVALID_ARGUMENT; 
....................                   return -1; 
....................               } 
....................  
....................                j = 0; 
....................                if (*utf16path2 == '.') 
....................                { 
....................                    utf16path2++; 
....................                    while ((*utf16path2 != 0) && (*utf16path2 != '\\')) 
....................                    { 
....................                        utf16path2++; 
....................                        j++; 
....................                    } 
....................                  if ((i + j) > 256) 
....................                  { 
....................                      FSerrno = CE_INVALID_ARGUMENT; 
....................                      return -1; 
....................                  } 
....................                } 
....................  
....................             if((i + j) > k) 
....................             { 
....................                k = (i + j); 
....................             } 
....................  
....................                while (*utf16path2 == '\\') 
....................                    utf16path2++; 
....................                if (*utf16path2 == 0) 
....................                    break; 
....................            } 
....................        } 
....................       else 
....................       #endif 
....................       { 
....................            // Scan for too-long file names 
....................            while (1) 
....................            { 
....................                i = 0; 
....................                while((*temppath2 != 0) && (*temppath2 != '.')&& (*temppath2 != '\\')) 
....................                { 
....................                    temppath2++; 
....................                    i++; 
....................                } 
....................  
....................             #if defined(SUPPORT_LFN) 
....................                   if (i > 256) 
....................                   { 
....................                       FSerrno = CE_INVALID_ARGUMENT; 
....................                       return -1; 
....................                   } 
....................             #else 
....................                   if (i > 8) 
....................                   { 
....................                       FSerrno = CE_INVALID_ARGUMENT; 
....................                       return -1; 
....................                   } 
....................             #endif 
....................  
....................                j = 0; 
....................                if (*temppath2 == '.') 
....................                { 
....................                    temppath2++; 
....................                    while ((*temppath2 != 0) && (*temppath2 != '\\')) 
....................                    { 
....................                        temppath2++; 
....................                        j++; 
....................                    } 
....................                #if defined(SUPPORT_LFN) 
....................                      if ((i + j) > 256) 
....................                      { 
....................                          FSerrno = CE_INVALID_ARGUMENT; 
....................                          return -1; 
....................                      } 
....................                #else 
....................                      if (j > 3) 
....................                      { 
....................                          FSerrno = CE_INVALID_ARGUMENT; 
....................                          return -1; 
....................                      } 
....................                #endif 
....................                } 
....................  
....................             if((i + j) > k) 
....................             { 
....................                k = (i + j); 
....................             } 
....................  
....................                while (*temppath2 == '\\') 
....................                    temppath2++; 
....................                if (*temppath2 == 0) 
....................                    break; 
....................            } 
....................        } 
....................     } 
....................     else 
.................... #endif 
....................    { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................       { 
....................          utf16path = (unsigned short int *)ramptr; 
....................            // Scan for too-long file names 
....................            while (1) 
....................            { 
....................                i = 0; 
....................                while((*utf16path != 0) && (*utf16path != '.')&& (*utf16path != '\\')) 
....................                { 
....................                    utf16path++; 
....................                    i++; 
....................                } 
....................               if (i > 256) 
....................               { 
....................                   FSerrno = CE_INVALID_ARGUMENT; 
....................                   return -1; 
....................               } 
....................  
....................                j = 0; 
....................                if (*utf16path == '.') 
....................                { 
....................                    utf16path++; 
....................                    while ((*utf16path != 0) && (*utf16path != '\\')) 
....................                    { 
....................                        utf16path++; 
....................                        j++; 
....................                    } 
....................                  if ((i + j) > 256) 
....................                  { 
....................                      FSerrno = CE_INVALID_ARGUMENT; 
....................                      return -1; 
....................                  } 
....................                } 
....................  
....................             if((i + j) > k) 
....................             { 
....................                k = (i + j); 
....................             } 
....................  
....................                while (*utf16path == '\\') 
....................                    utf16path++; 
....................                if (*utf16path == 0) 
....................                    break; 
....................            } 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................            // Scan for too-long file names 
....................            while (1) 
....................            { 
....................                i = 0; 
07328:  CLR     FDA
....................                while((*temppath != 0) && (*temppath != '.')&& (*temppath != '\\')) 
0732A:  MOV     FE0,W0
0732C:  MOV.B   [W0],W5L
0732E:  SE      W5,W5
07330:  CP0     W5
07332:  BRA     Z,734C
07334:  MOV     FE0,W0
07336:  MOV.B   [W0],W4L
07338:  XOR.B   #2E,W4L
0733A:  BRA     Z,734C
0733C:  MOV     FE0,W0
0733E:  MOV.B   [W0],W4L
07340:  XOR.B   #5C,W4L
07342:  BRA     Z,734C
....................                { 
....................                    temppath++; 
07344:  INC     0FE0
....................                    i++; 
07346:  INC     0FDA
....................                } 
....................             #if defined(SUPPORT_LFN) 
07348:  GOTO    732A
....................                   if (i > 256) 
....................                   { 
....................                       FSerrno = CE_INVALID_ARGUMENT; 
....................                       return -1; 
....................                   } 
....................             #else 
....................                   if (i > 8) 
0734C:  MOV     FDA,W4
0734E:  CP      W4,#8
07350:  BRA     LEU,735A
....................                   { 
....................                       FSerrno = CE_INVALID_ARGUMENT; 
07352:  MOV.B   #1F,W0L
07354:  MOV.B   W0L,8B1
....................                       return -1; 
07356:  SETM    0
07358:  BRA     7672
....................                   } 
....................             #endif 
....................  
....................                j = 0; 
0735A:  CLR     FDC
....................                if (*temppath == '.') 
0735C:  MOV     FE0,W0
0735E:  MOV.B   [W0],W4L
07360:  XOR.B   #2E,W4L
07362:  BRA     NZ,738E
....................                { 
....................                    temppath++; 
07364:  INC     0FE0
....................                    while ((*temppath != 0) && (*temppath != '\\')) 
07366:  MOV     FE0,W0
07368:  MOV.B   [W0],W5L
0736A:  SE      W5,W5
0736C:  CP0     W5
0736E:  BRA     Z,7380
07370:  MOV     FE0,W0
07372:  MOV.B   [W0],W4L
07374:  XOR.B   #5C,W4L
07376:  BRA     Z,7380
....................                    { 
....................                        temppath++; 
07378:  INC     0FE0
....................                        j++; 
0737A:  INC     0FDC
....................                    } 
....................                #if defined(SUPPORT_LFN) 
0737C:  GOTO    7366
....................                      if ((i + j) > 256) 
....................                      { 
....................                          FSerrno = CE_INVALID_ARGUMENT; 
....................                          return -1; 
....................                      } 
....................                #else 
....................                      if (j > 3) 
07380:  MOV     FDC,W4
07382:  CP      W4,#3
07384:  BRA     LEU,738E
....................                      { 
....................                          FSerrno = CE_INVALID_ARGUMENT; 
07386:  MOV.B   #1F,W0L
07388:  MOV.B   W0L,8B1
....................                          return -1; 
0738A:  SETM    0
0738C:  BRA     7672
....................                      } 
....................                #endif 
....................                } 
....................  
....................             if((i + j) > k) 
0738E:  MOV     FDA,W0
07390:  ADD     FDC,W0
07392:  MOV     W0,W5
07394:  MOV     FDE,W4
07396:  CP      W4,W5
07398:  BRA     C,73A0
....................             { 
....................                k = (i + j); 
0739A:  MOV     FDA,W0
0739C:  ADD     FDC,W0
0739E:  MOV     W0,FDE
....................             } 
....................  
....................                while (*temppath == '\\') 
073A0:  MOV     FE0,W0
073A2:  MOV.B   [W0],W4L
073A4:  XOR.B   #5C,W4L
073A6:  BRA     NZ,73AE
....................                    temppath++; 
073A8:  INC     0FE0
073AA:  GOTO    73A0
....................                if (*temppath == 0) 
073AE:  MOV     FE0,W0
073B0:  MOV.B   [W0],W5L
073B2:  SE      W5,W5
073B4:  CP0     W5
073B6:  BRA     NZ,73BC
....................                    break; 
073B8:  GOTO    73C0
073BC:  GOTO    7328
....................            } 
....................       } 
....................    } 
....................  
....................    utf16path = (unsigned short int *)ramptr; 
073C0:  PUSH    FD6
073C2:  POP     FE2
....................     temppath = ramptr; 
073C4:  PUSH    FD6
073C6:  POP     FE0
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    utf16path2 = (rom unsigned short int *)romptr; 
....................     temppath2 = romptr; 
.................... #endif 
....................  
....................     // We're going to be moving the CWD 
....................     // Back up the CWD 
....................     FileObjectCopy (tempCWD, cwdptr); 
073C8:  PUSH    FE4
073CA:  POP     105C
073CC:  PUSH    95E
073CE:  POP     105E
073D0:  CALL    28E2
....................  
....................     // get to the target directory 
....................     while (1) 
....................     { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................         if (mode == 1) 
....................         { 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................                i = *utf16path2; 
....................          else 
....................          #endif 
....................                i = *temppath2; 
....................       } 
....................         else 
.................... #endif 
....................       { 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................                i = *utf16path; 
....................          else 
....................          #endif 
....................                i = *temppath; 
073D4:  MOV     FE0,W0
073D6:  MOV     W0,W4
073D8:  MOV.B   [W4],W0L
073DA:  SE      W0,W0
073DC:  MOV     W0,FDA
....................       } 
....................  
....................         if (i == '.') 
073DE:  MOV     FDA,W4
073E0:  XOR     #2E,W4
073E2:  BRA     NZ,74A2
....................         { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             if (mode == 1) 
....................             { 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................             { 
....................                    utf16path2++; 
....................                    i = *utf16path2; 
....................             } 
....................             else 
....................             #endif 
....................                { 
....................                    temppath2++; 
....................                    i = *temppath2; 
....................             } 
....................             } 
....................             else 
....................             { 
.................... #endif 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................             { 
....................                    utf16path++; 
....................                    i = *utf16path; 
....................             } 
....................             else 
....................             #endif 
....................                { 
....................                    temppath++; 
073E4:  INC     0FE0
....................                    i = *temppath; 
073E6:  MOV     FE0,W0
073E8:  MOV     W0,W4
073EA:  MOV.B   [W4],W0L
073EC:  SE      W0,W0
073EE:  MOV     W0,FDA
....................             } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             } 
.................... #endif 
....................  
....................             if ((i != '.') && (i != 0) && (i != '\\')) 
073F0:  MOV     FDA,W4
073F2:  XOR     #2E,W4
073F4:  BRA     Z,7408
073F6:  CP0     FDA
073F8:  BRA     Z,7408
073FA:  MOV     FDA,W4
073FC:  XOR     #5C,W4
073FE:  BRA     Z,7408
....................             { 
....................                 FSerrno = CE_INVALID_ARGUMENT; 
07400:  MOV.B   #1F,W0L
07402:  MOV.B   W0L,8B1
....................                 return -1; 
07404:  SETM    0
07406:  BRA     7672
....................             } 
....................  
....................             if (i == '.') 
07408:  MOV     FDA,W4
0740A:  XOR     #2E,W4
0740C:  BRA     NZ,7470
....................             { 
....................                 if (cwdptr->dirclus ==  FatRootDirClusterValue) 
0740E:  MOV     #2E,W0
07410:  ADD     95E,W0
07412:  MOV     #A,W4
07414:  MOV     [W0++],[W4++]
07416:  MOV     [W0++],[W4++]
07418:  MOV     8B2,W4
0741A:  CP      W4,W5
0741C:  BRA     NZ,742C
0741E:  MOV     8B4,W4
07420:  CP      W4,W6
07422:  BRA     NZ,742C
....................                 { 
....................                     // If we try to change to the .. from the 
....................                     // root, operation fails 
....................                     FSerrno = CE_INVALID_ARGUMENT; 
07424:  MOV.B   #1F,W0L
07426:  MOV.B   W0L,8B1
....................                     return -1; 
07428:  SETM    0
0742A:  BRA     7672
....................                 } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 if (mode == 1) 
....................                 { 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path2++; 
....................                       i = *utf16path2; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath2++; 
....................                       i = *temppath2; 
....................                } 
....................                 } 
....................                 else 
.................... #endif 
....................                 { 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path++; 
....................                       i = *utf16path; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath++; 
0742C:  INC     0FE0
....................                       i = *temppath; 
0742E:  MOV     FE0,W0
07430:  MOV     W0,W4
07432:  MOV.B   [W4],W0L
07434:  SE      W0,W0
07436:  MOV     W0,FDA
....................                } 
....................             } 
....................  
....................                 if ((i != '\\') && (i != 0)) 
07438:  MOV     FDA,W4
0743A:  XOR     #5C,W4
0743C:  BRA     Z,744E
0743E:  CP0     FDA
07440:  BRA     Z,744E
....................                 { 
....................                     FSerrno = CE_INVALID_ARGUMENT; 
07442:  MOV.B   #1F,W0L
07444:  MOV.B   W0L,8B1
....................                     return -1; 
07446:  SETM    0
07448:  BRA     7672
....................                 } 
.................... // dotdot entry 
.................... #ifndef __18CXX 
....................          #ifdef SUPPORT_LFN 
0744A:  GOTO    7470
....................          if(utfModeFileName) 
....................                 FSchdir (".\0.\0\0"); 
....................          #endif 
....................          else 
....................                 FSchdir (".."); 
0744E:  MOV     #3,W3
07450:  MOV     #0,W2
07452:  MOV     #FF4,W1
07454:  MOV     W3,[W15++]
07456:  MOV     W2,W0
07458:  CALL    200
0745C:  MOV     [--W15],W3
0745E:  MOV.B   W0L,[W1++]
07460:  INC     W2,W2
07462:  DEC     W3,W3
07464:  BTSS.B  42.1
07466:  BRA     7454
07468:  MOV     #FF4,W4
0746A:  MOV     W4,1008
0746C:  CALL    650A
.................... #else 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................                 FSchdir (dotdotPath1); 
....................          else 
....................          #endif 
....................                 FSchdir (dotdotPath); 
.................... #endif 
....................             } 
....................             // Skip past any backslashes 
....................             while (i == '\\') 
07470:  MOV     FDA,W4
07472:  XOR     #5C,W4
07474:  BRA     NZ,7486
....................             { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 if (mode == 1) 
....................                 { 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path2++; 
....................                       i = *utf16path2; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath2++; 
....................                       i = *temppath2; 
....................                } 
....................                 } 
....................                 else 
....................                 { 
.................... #endif 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path++; 
....................                       i = *utf16path; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath++; 
07476:  INC     0FE0
....................                       i = *temppath; 
07478:  MOV     FE0,W0
0747A:  MOV     W0,W4
0747C:  MOV.B   [W4],W0L
0747E:  SE      W0,W0
07480:  MOV     W0,FDA
....................                } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
07482:  GOTO    7470
....................                 } 
.................... #endif 
....................             } 
....................             if (i == 0) 
07486:  CP0     FDA
07488:  BRA     NZ,749E
....................             { 
....................                 // No point in creating a dot or dotdot entry directly 
....................                 FileObjectCopy (cwdptr, tempCWD); 
0748A:  PUSH    95E
0748C:  POP     105C
0748E:  PUSH    FE4
07490:  POP     105E
07492:  CALL    28E2
....................                 FSerrno = CE_INVALID_ARGUMENT; 
07496:  MOV.B   #1F,W0L
07498:  MOV.B   W0L,8B1
....................                 return -1; 
0749A:  SETM    0
0749C:  BRA     7672
....................             } 
....................         } 
0749E:  GOTO    751E
....................         else 
....................         { 
....................             if (i == '\\') 
074A2:  MOV     FDA,W4
074A4:  XOR     #5C,W4
074A6:  BRA     NZ,751A
....................             { 
....................                 // Start at the root 
....................                 cwdptr->dirclus = FatRootDirClusterValue; 
074A8:  MOV     #2E,W0
074AA:  ADD     95E,W0
074AC:  MOV     W0,W5
074AE:  MOV     #8B2,W4
074B0:  MOV     [W4++],[W5++]
074B2:  MOV     [W4++],[W5++]
....................                 cwdptr->dirccls = FatRootDirClusterValue; 
074B4:  MOV     #32,W0
074B6:  ADD     95E,W0
074B8:  MOV     W0,W5
074BA:  MOV     #8B2,W4
074BC:  MOV     [W4++],[W5++]
074BE:  MOV     [W4++],[W5++]
....................                 i = 0; 
074C0:  CLR     FDA
....................                 cwdptr->name[i++] = '\\'; 
074C2:  MOV     FDA,W0
074C4:  INC     0FDA
074C6:  MOV     W0,W5
074C8:  ADD     W5,#1C,W5
074CA:  MOV     W5,W0
074CC:  MOV     95E,W4
074CE:  ADD     W0,W4,W6
074D0:  MOV.B   #5C,W0L
074D2:  MOV.B   W0L,[W6]
.................... //                if(utfModeFileName) 
.................... //            { 
.................... //                   cwdptr->name[i++] = 0x00; 
.................... //            } 
....................                 for (; i < 11; i++) 
074D4:  MOV     FDA,W4
074D6:  CP      W4,#B
074D8:  BRA     C,74EC
....................                 { 
....................                     cwdptr->name[i] = 0x20; 
074DA:  MOV     #1C,W0
074DC:  ADD     FDA,W0
074DE:  MOV     95E,W4
074E0:  ADD     W0,W4,W5
074E2:  MOV.B   #20,W0L
074E4:  MOV.B   W0L,[W5]
074E6:  INC     0FDA
074E8:  GOTO    74D4
....................                 } 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 if (mode == 1) 
....................                 { 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path2++; 
....................                       i = *utf16path2; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath2++; 
....................                       i = *temppath2; 
....................                } 
....................                 } 
....................                 else 
....................                 { 
.................... #endif 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path++; 
....................                       i = *utf16path; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath++; 
074EC:  INC     0FE0
....................                       i = *temppath; 
074EE:  MOV     FE0,W0
074F0:  MOV     W0,W4
074F2:  MOV.B   [W4],W0L
074F4:  SE      W0,W0
074F6:  MOV     W0,FDA
....................                } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 } 
.................... #endif 
....................                 // If we just got two backslashes in a row at the 
....................                 // beginning of the path, the function fails 
....................                 if ((i == '\\') || (i == 0)) 
074F8:  MOV     FDA,W4
074FA:  XOR     #5C,W4
074FC:  BRA     Z,7502
074FE:  CP0     FDA
07500:  BRA     NZ,7516
....................                 { 
....................                     FileObjectCopy (cwdptr, tempCWD); 
07502:  PUSH    95E
07504:  POP     105C
07506:  PUSH    FE4
07508:  POP     105E
0750A:  CALL    28E2
....................                     FSerrno = CE_INVALID_ARGUMENT; 
0750E:  MOV.B   #1F,W0L
07510:  MOV.B   W0L,8B1
....................                     return -1; 
07512:  SETM    0
07514:  BRA     7672
....................                 } 
....................             } 
07516:  GOTO    751E
....................             else 
....................             { 
....................                 break; 
0751A:  GOTO    7522
....................             } 
....................         } 
0751E:  GOTO    73D4
....................     } 
....................  
....................     while (1) 
....................     { 
....................         while(1) 
....................         { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             if (mode == 1) 
....................             { 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................             { 
....................                    // Change directories as specified 
....................                    i = *utf16path2; 
....................                    j = 0; 
....................  
....................                k = 512; 
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempArray[j++] = i; 
....................                        tempArray[j++] = i >> 8; 
....................                        utf16path2++; 
....................                        i = *utf16path2; 
....................                    } 
....................             } 
....................             else 
....................             #endif 
....................               { 
....................                    // Change directories as specified 
....................                    i = *temppath2; 
....................                    j = 0; 
....................  
....................                #if defined(SUPPORT_LFN) 
....................                   k = 256; 
....................                #else 
....................                   k = 12; 
....................                #endif 
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempArray[j++] = i; 
....................                        temppath2++; 
....................                        i = *temppath2; 
....................                    } 
....................             } 
....................             } 
....................             else 
....................             { 
.................... #endif 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................             { 
....................                    // Change directories as specified 
....................                    i = *utf16path; 
....................                    j = 0; 
....................  
....................                k = 512; 
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempArray[j++] = i; 
....................                        tempArray[j++] = i >> 8; 
....................                        utf16path++; 
....................                        i = *utf16path; 
....................                    } 
....................             } 
....................             else 
....................             #endif 
....................               { 
....................                    // Change directories as specified 
....................                    i = *temppath; 
07522:  MOV     FE0,W0
07524:  MOV     W0,W4
07526:  MOV.B   [W4],W0L
07528:  SE      W0,W0
0752A:  MOV     W0,FDA
....................                    j = 0; 
0752C:  CLR     FDC
....................  
....................                #if defined(SUPPORT_LFN) 
....................                   k = 256; 
....................                #else 
....................                   k = 12; 
0752E:  MOV     #C,W4
07530:  MOV     W4,FDE
....................                #endif 
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
07532:  CP0     FDA
07534:  BRA     Z,7562
07536:  MOV     FDA,W4
07538:  XOR     #5C,W4
0753A:  BRA     Z,7562
0753C:  MOV     FDC,W0
0753E:  MOV     FDE,W4
07540:  CP      W4,W0
07542:  BRA     LEU,7562
....................                    { 
....................                        tempArray[j++] = i; 
07544:  MOV     FDC,W0
07546:  INC     0FDC
07548:  MOV     W0,W5
0754A:  MOV     #FE6,W4
0754C:  ADD     W5,W4,W6
0754E:  MOV     FDA,W0
07550:  MOV.B   W0L,[W6+#0]
....................                        temppath++; 
07552:  INC     0FE0
....................                        i = *temppath; 
07554:  MOV     FE0,W0
07556:  MOV     W0,W4
07558:  MOV.B   [W4],W0L
0755A:  SE      W0,W0
0755C:  MOV     W0,FDA
0755E:  GOTO    7532
....................                    } 
....................             } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             } 
.................... #endif 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................          { 
....................                tempArray[j++] = 0; 
....................                tempArray[j] = 0; 
....................  
....................                if ((tempArray[0] == '.') && (tempArray[1] == 0)) 
....................                { 
....................                    if (((tempArray[2] != 0) || (tempArray[3] != 0)) && ((tempArray[2] != '.') || (tempArray[3] != 0))) 
....................                    { 
....................                        FileObjectCopy (cwdptr, tempCWD); 
....................                        FSerrno = CE_INVALID_ARGUMENT; 
....................                        return -1; 
....................                    } 
....................                    if (((tempArray[2] == '.') && (tempArray[3] == 0)) && ((tempArray[4] != 0) || (tempArray[5] != 0))) 
....................                    { 
....................                        FileObjectCopy (cwdptr, tempCWD); 
....................                        FSerrno = CE_INVALID_ARGUMENT; 
....................                        return -1; 
....................                    } 
....................                } 
....................          } 
....................          else 
....................          #endif 
....................          { 
....................                tempArray[j] = 0; 
07562:  MOV     #FE6,W4
07564:  MOV     FDC,W3
07566:  ADD     W3,W4,W5
07568:  CLR.B   [W5]
....................  
....................                if (tempArray[0] == '.') 
0756A:  MOV     FE6,W4
0756C:  XOR.B   #2E,W4L
0756E:  BRA     NZ,75B8
....................                { 
....................                    if ((tempArray[1] != 0) && (tempArray[1] != '.')) 
07570:  MOV.B   FE7,W0L
07572:  SE      W0,W0
07574:  CP0     W0
07576:  BRA     Z,7594
07578:  MOV     FE6,W4
0757A:  LSR     W4,#8,W4
0757C:  XOR.B   #2E,W4L
0757E:  BRA     Z,7594
....................                    { 
....................                        FileObjectCopy (cwdptr, tempCWD); 
07580:  PUSH    95E
07582:  POP     105C
07584:  PUSH    FE4
07586:  POP     105E
07588:  CALL    28E2
....................                        FSerrno = CE_INVALID_ARGUMENT; 
0758C:  MOV.B   #1F,W0L
0758E:  MOV.B   W0L,8B1
....................                        return -1; 
07590:  SETM    0
07592:  BRA     7672
....................                    } 
....................                    if ((tempArray[1] == '.') && (tempArray[2] != 0)) 
07594:  MOV     FE6,W4
07596:  LSR     W4,#8,W4
07598:  XOR.B   #2E,W4L
0759A:  BRA     NZ,75B8
0759C:  MOV.B   FE8,W0L
0759E:  SE      W0,W0
075A0:  CP0     W0
075A2:  BRA     Z,75B8
....................                    { 
....................                        FileObjectCopy (cwdptr, tempCWD); 
075A4:  PUSH    95E
075A6:  POP     105C
075A8:  PUSH    FE4
075AA:  POP     105E
075AC:  CALL    28E2
....................                        FSerrno = CE_INVALID_ARGUMENT; 
075B0:  MOV.B   #1F,W0L
075B2:  MOV.B   W0L,8B1
....................                        return -1; 
075B4:  SETM    0
075B6:  BRA     7672
....................                    } 
....................                } 
....................          } 
....................  
....................             // Try to change to it 
....................             // If you can't we need to create it 
....................             if (FSchdir (tempArray)) 
075B8:  MOV     #FE6,W4
075BA:  MOV     W4,1008
075BC:  CALL    650A
075C0:  CP0     W0
075C2:  BRA     Z,75CC
....................             break; 
075C4:  GOTO    75FA
075C8:  GOTO    75F6
....................             else 
....................             { 
....................                 // We changed into the directory 
....................                 while (i == '\\') 
075CC:  MOV     FDA,W4
075CE:  XOR     #5C,W4
075D0:  BRA     NZ,75E2
....................                 { 
....................                     // Next char is a backslash 
....................                     // Move past it 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     if (mode == 1) 
....................                     { 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................                   { 
....................                          utf16path2++; 
....................                          i = *utf16path2; 
....................                   } 
....................                   else 
....................                   #endif 
....................                      { 
....................                          temppath2++; 
....................                          i = *temppath2; 
....................                   } 
....................                     } 
....................                     else 
....................                     { 
.................... #endif 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................                   { 
....................                          utf16path++; 
....................                          i = *utf16path; 
....................                   } 
....................                   else 
....................                   #endif 
....................                      { 
....................                          temppath++; 
075D2:  INC     0FE0
....................                          i = *temppath; 
075D4:  MOV     FE0,W0
075D6:  MOV     W0,W4
075D8:  MOV.B   [W4],W0L
075DA:  SE      W0,W0
075DC:  MOV     W0,FDA
....................                   } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
075DE:  GOTO    75CC
....................                     } 
.................... #endif 
....................                 } 
....................                 // If it's the last one, return success 
....................                 if (i == 0) 
075E2:  CP0     FDA
075E4:  BRA     NZ,75F6
....................                 { 
....................                     FileObjectCopy (cwdptr, tempCWD); 
075E6:  PUSH    95E
075E8:  POP     105C
075EA:  PUSH    FE4
075EC:  POP     105E
075EE:  CALL    28E2
....................                     return 0; 
075F2:  CLR     0
075F4:  BRA     7672
....................                 } 
....................             } 
075F6:  GOTO    7522
....................         } 
....................  
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................       { 
....................          unsigned short int *tempPtr1; 
....................          unsigned short int *tempPtr2; 
....................          k = 0; 
....................          tempPtr1 = (unsigned short int *)&tempArray[0]; 
....................          tempPtr2 = (unsigned short int *)&tempDirectoryString[0]; 
....................  
....................          for(;;) 
....................          { 
....................             tempPtr2[k] = tempPtr1[k]; 
....................             if(tempPtr2[k]) 
....................                k++; 
....................             else 
....................                break; 
....................          } 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................          strcpy(&tempDirectoryString[0],&tempArray[0]); 
075FA:  MOV     #D88,W1
075FC:  MOV     #FE6,W2
075FE:  MOV.B   [W2++],[W1]
07600:  CP0.B   [W1++]
07602:  BTSS.B  42.1
07604:  BRA     75FE
....................       } 
....................  
....................         // Create a dir here 
....................         if (!CreateDIR (tempDirectoryString)) 
07606:  MOV     #D88,W4
07608:  MOV     W4,FFE
0760A:  CALL    7188
0760E:  CP0     W0
07610:  BRA     NZ,7622
....................         { 
....................             FileObjectCopy (cwdptr, tempCWD); 
07612:  PUSH    95E
07614:  POP     105C
07616:  PUSH    FE4
07618:  POP     105E
0761A:  CALL    28E2
....................            return -1; 
0761E:  SETM    0
07620:  BRA     7672
....................         } 
....................  
....................         // Try to change to that directory 
....................         if (FSchdir (tempArray)) 
07622:  MOV     #FE6,W4
07624:  MOV     W4,1008
07626:  CALL    650A
0762A:  CP0     W0
0762C:  BRA     Z,7642
....................         { 
....................             FileObjectCopy (cwdptr, tempCWD); 
0762E:  PUSH    95E
07630:  POP     105C
07632:  PUSH    FE4
07634:  POP     105E
07636:  CALL    28E2
....................             FSerrno = CE_BADCACHEREAD; 
0763A:  MOV.B   #1B,W0L
0763C:  MOV.B   W0L,8B1
....................            return -1; 
0763E:  SETM    0
07640:  BRA     7672
....................         } 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................         if (mode == 1) 
....................         { 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................          { 
....................                while (*utf16path2 == '\\') 
....................                { 
....................                    utf16path2++; 
....................                    i = *utf16path2; 
....................                } 
....................          } 
....................          else 
....................          #endif 
....................            { 
....................                // Check for another backslash 
....................                while (*temppath2 == '\\') 
....................                { 
....................                    temppath2++; 
....................                    i = *temppath2; 
....................                } 
....................          } 
....................         } 
....................         else 
....................         { 
.................... #endif 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................          { 
....................                while (*utf16path == '\\') 
....................                { 
....................                    utf16path++; 
....................                    i = *utf16path; 
....................                } 
....................          } 
....................          else 
....................          #endif 
....................            { 
....................                while (*temppath == '\\') 
07642:  MOV     FE0,W0
07644:  MOV.B   [W0],W4L
07646:  XOR.B   #5C,W4L
07648:  BRA     NZ,765A
....................                { 
....................                    temppath++; 
0764A:  INC     0FE0
....................                    i = *temppath; 
0764C:  MOV     FE0,W0
0764E:  MOV     W0,W4
07650:  MOV.B   [W4],W0L
07652:  SE      W0,W0
07654:  MOV     W0,FDA
07656:  GOTO    7642
....................                } 
....................          } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................         } 
.................... #endif 
....................  
....................         // Check to see if we're at the end of the path string 
....................         if (i == 0) 
0765A:  CP0     FDA
0765C:  BRA     NZ,766E
....................         { 
....................             // We already have one 
....................             FileObjectCopy (cwdptr, tempCWD); 
0765E:  PUSH    95E
07660:  POP     105C
07662:  PUSH    FE4
07664:  POP     105E
07666:  CALL    28E2
....................            return 0; 
0766A:  CLR     0
0766C:  BRA     7672
....................         } 
0766E:  GOTO    7522
....................     } 
07672:  MOV     [--W15],W6
07674:  MOV     [--W15],W5
07676:  RETURN  
.................... } 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int CreateDIR (char * path) 
....................   Summary: 
....................     FSmkdir helper function to create a directory 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     path -  The name of the dir to create 
....................   Return Values: 
....................     TRUE -  Directory was created successfully 
....................     FALSE - Directory could not be created. 
....................   Side Effects: 
....................     Any unwritten data in the data buffer or the FAT buffer will be written 
....................     to the device. 
....................   Description: 
....................     The CreateDIR function is a helper function for the mkdirhelper 
....................     function.  The CreateDIR function will create a new file entry for 
....................     a directory and assign a cluster to it.  It will erase the cluster 
....................     and write a dot and dotdot entry to it. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int CreateDIR (char * path) 
*
07188:  MOV     W5,[W15++]
0718A:  MOV     W6,[W15++]
0718C:  MOV     #8F2,W4
0718E:  MOV     W4,1000
*
07192:  CLR     1004
.................... { 
....................     FSFILE * dirEntryPtr = &gFileTemp; 
....................     DIRENTRY dir; 
*
07190:  CLR     1002
....................     WORD handle = 0; 
....................     DWORD dot, dotdot; 
*
07194:  CLR     1006
07196:  CLR     1008
07198:  CLR     100A
0719A:  CLR     100C
....................  
....................     if (FormatDirName(path, dirEntryPtr,0) == FALSE) 
0719C:  CLR.B   1060
0719E:  PUSH    FFE
071A0:  POP     105C
071A2:  PUSH    1000
071A4:  POP     105E
071A6:  CALL    5F54
071AA:  CP0.B   W0L
071AC:  BRA     NZ,71B6
....................     { 
....................         FSerrno = CE_INVALID_FILENAME; 
071AE:  MOV.B   #12,W0L
071B0:  MOV.B   W0L,8B1
....................         return FALSE; 
071B2:  CLR     0
071B4:  BRA     72EC
....................     } 
....................  
....................     dirEntryPtr->dirclus = cwdptr->dirclus; 
071B6:  MOV     #2E,W0
071B8:  ADD     1000,W0
071BA:  MOV     W0,W5
071BC:  MOV     #2E,W0
071BE:  ADD     95E,W0
071C0:  MOV     [W0++],[W5++]
071C2:  MOV     [W0++],[W5++]
....................     dirEntryPtr->dirccls = cwdptr->dirccls; 
071C4:  MOV     #32,W0
071C6:  ADD     1000,W0
071C8:  MOV     W0,W5
071CA:  MOV     #32,W0
071CC:  ADD     95E,W0
071CE:  MOV     [W0++],[W5++]
071D0:  MOV     [W0++],[W5++]
....................     dirEntryPtr->cluster = 0; 
071D2:  MOV     #2,W0
071D4:  ADD     1000,W0
071D6:  MOV     W0,W5
071D8:  CLR.B   [W5]
071DA:  MOV.B   #0,W0L
071DC:  MOV.B   W0L,[W5+#1]
071DE:  MOV.B   #0,W0L
071E0:  MOV.B   W0L,[W5+#2]
071E2:  MOV.B   #0,W0L
071E4:  MOV.B   W0L,[W5+#3]
....................     dirEntryPtr->ccls = 0; 
071E6:  MOV     #6,W0
071E8:  ADD     1000,W0
071EA:  MOV     W0,W5
071EC:  CLR.B   [W5]
071EE:  MOV.B   #0,W0L
071F0:  MOV.B   W0L,[W5+#1]
071F2:  MOV.B   #0,W0L
071F4:  MOV.B   W0L,[W5+#2]
071F6:  MOV.B   #0,W0L
071F8:  MOV.B   W0L,[W5+#3]
....................     dirEntryPtr->dsk = cwdptr->dsk; 
071FA:  MOV     1000,W4
071FC:  ADD     W4,#0,W4
071FE:  MOV     W4,W0
07200:  MOV     W0,W5
07202:  MOV     95E,W4
07204:  ADD     W4,#0,W4
07206:  MOV     W4,W0
07208:  MOV     [W0],[W5]
....................  
....................     // Create a directory entry 
....................     if(CreateFileEntry(dirEntryPtr, &handle, DIRECTORY, TRUE) != CE_GOOD) 
0720A:  MOV.B   #12,W0L
0720C:  MOV.B   W0L,1030
0720E:  MOV.B   #1,W0L
07210:  MOV.B   W0L,1031
07212:  PUSH    1000
07214:  POP     102C
07216:  MOV     #1004,W4
07218:  MOV     W4,102E
0721A:  CALL    43FA
0721E:  CP0.B   W0L
07220:  BRA     Z,722A
....................     { 
....................         return FALSE; 
07222:  CLR     0
07224:  BRA     72EC
....................     } 
07226:  GOTO    72EC
....................     else 
....................     { 
....................         if (gNeedFATWrite) 
0722A:  CP0.B   899
0722C:  BRA     Z,725C
....................             if(WriteFAT (dirEntryPtr->dsk, 0, 0, TRUE)) 
0722E:  MOV     1000,W4
07230:  ADD     W4,#0,W4
07232:  MOV     W4,W0
07234:  MOV     [W0],W5
07236:  MOV     W0,[W15++]
07238:  MOV.B   #1,W0L
0723A:  MOV.B   W0L,10D2
0723C:  MOV     [--W15],W0
0723E:  MOV     W5,10C8
07240:  CLR     10CA
07242:  CLR     10CC
07244:  CLR     10CE
07246:  CLR     10D0
07248:  CALL    2C18
0724C:  CP0     W0
0724E:  BRA     NZ,7254
07250:  CP0     W1
07252:  BRA     Z,725C
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
07254:  MOV.B   #9,W0L
07256:  MOV.B   W0L,8B1
....................                 return FALSE; 
07258:  CLR     0
0725A:  BRA     72EC
....................             } 
....................         // Zero that cluster 
....................         if (dirEntryPtr->dirclus == FatRootDirClusterValue) 
0725C:  MOV     #2E,W0
0725E:  ADD     1000,W0
07260:  MOV     #A,W4
07262:  MOV     [W0++],[W4++]
07264:  MOV     [W0++],[W4++]
07266:  MOV     8B2,W4
07268:  CP      W4,W5
0726A:  BRA     NZ,727A
0726C:  MOV     8B4,W4
0726E:  CP      W4,W6
07270:  BRA     NZ,727A
....................             dotdot = 0; 
07272:  CLR     100A
07274:  CLR     100C
07276:  GOTO    7284
....................         else 
....................             dotdot = dirEntryPtr->dirclus; 
0727A:  MOV     #2E,W0
0727C:  ADD     1000,W0
0727E:  MOV     #100A,W4
07280:  MOV     [W0++],[W4++]
07282:  MOV     [W0++],[W4++]
....................         dirEntryPtr->dirccls = dirEntryPtr->dirclus; 
07284:  MOV     #32,W0
07286:  ADD     1000,W0
07288:  MOV     W0,W5
0728A:  MOV     #2E,W0
0728C:  ADD     1000,W0
0728E:  MOV     [W0++],[W5++]
07290:  MOV     [W0++],[W5++]
....................         dir = Cache_File_Entry(dirEntryPtr, &handle, TRUE); 
07292:  MOV.B   #1,W0L
07294:  MOV.B   W0L,1086
07296:  PUSH    1000
07298:  POP     1082
0729A:  MOV     #1004,W4
0729C:  MOV     W4,1084
0729E:  CALL    31E4
072A2:  MOV     W0,1002
....................         if (dir == NULL) 
072A4:  CP0     1002
072A6:  BRA     NZ,72B0
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
072A8:  MOV.B   #1B,W0L
072AA:  MOV.B   W0L,8B1
....................             return FALSE; 
072AC:  CLR     0
072AE:  BRA     72EC
....................         } 
....................  
....................         // Get the cluster 
....................         dot = GetFullClusterNumber(dir); // Get complete cluster number. 
072B0:  PUSH    1002
072B2:  POP     1084
072B4:  CALL    34B4
072B8:  MOV     W0,1006
072BA:  MOV     W1,1008
....................  
....................         if (writeDotEntries (dirEntryPtr->dsk, dot, dotdot)) 
072BC:  MOV     1000,W4
072BE:  ADD     W4,#0,W4
072C0:  MOV     W4,W0
072C2:  MOV     [W0],W5
072C4:  MOV     W5,1012
072C6:  PUSH    1006
072C8:  POP     1014
072CA:  PUSH    1008
072CC:  POP     1016
072CE:  PUSH    100A
072D0:  POP     1018
072D2:  PUSH    100C
072D4:  POP     101A
072D6:  CALL    7004
072DA:  CP0.B   W0L
072DC:  BRA     Z,72E8
....................             return TRUE; 
072DE:  MOV     #1,W4
072E0:  MOV     W4,0
072E2:  BRA     72EC
072E4:  GOTO    72EC
....................         else 
....................             return FALSE; 
072E8:  CLR     0
072EA:  BRA     72EC
....................  
....................     } 
072EC:  MOV     [--W15],W6
072EE:  MOV     [--W15],W5
072F0:  RETURN  
.................... } 
....................  
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     BYTE writeDotEntries (DISK * disk, DWORD dotAddress, DWORD dotdotAddress) 
....................   Summary: 
....................     Create dot and dotdot entries in a non-root directory 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     disk -           The global disk structure 
....................     dotAddress -     The cluster the current dir is in 
....................     dotdotAddress -  The cluster the previous directory was in 
....................   Return Values: 
....................     TRUE -  The dot and dotdot entries were created 
....................     FALSE - The dot and dotdot entries could not be created in the new directory 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The writeDotEntries function will create and write dot and dotdot entries 
....................     to a newly created directory. 
....................   Remarks: 
....................     None. 
....................   ***********************************************************************************/ 
....................  
.................... BYTE writeDotEntries (DISK * disk, DWORD dotAddress, DWORD dotdotAddress) 
*
07004:  MOV     W5,[W15++]
07006:  MOV     W6,[W15++]
07008:  MOV     W7,[W15++]
*
0702E:  MOV     #1020,W4
07030:  MOV     W4,1040
.................... { 
....................     WORD i; 
*
0700A:  CLR     101C
....................     WORD size; 
0700C:  CLR     101E
....................     volatile _DIRENTRY entry; 
0700E:  CLR     1020
07010:  CLR     1022
07012:  CLR     1024
07014:  CLR     1026
07016:  CLR     1028
07018:  CLR     102A
0701A:  CLR     102C
0701C:  CLR     102E
0701E:  CLR     1030
07020:  CLR     1032
07022:  CLR     1034
07024:  CLR     1036
07026:  CLR     1038
07028:  CLR     103A
0702A:  CLR     103C
0702C:  CLR     103E
....................     DIRENTRY entryptr = (DIRENTRY)&entry; 
....................     DWORD sector; 
*
07032:  CLR     1042
07034:  CLR     1044
....................  
....................     gBufferOwner = NULL; 
07036:  CLR     8A8
....................  
....................     size = sizeof (_DIRENTRY); 
07038:  MOV     #20,W4
0703A:  MOV     W4,101E
....................  
....................    memset(disk->buffer, 0x00, disk->sectorSize); 
0703C:  MOV     1012,W4
0703E:  ADD     W4,#0,W4
07040:  MOV     W4,W0
07042:  MOV     #A,W1
07044:  MOV     W0,W2
07046:  REPEAT  #1
07048:  MOV.B   [W2++],[W1++]
0704A:  MOV     1012,W4
0704C:  ADD     W4,#18,W4
0704E:  MOV     W4,W0
07050:  MOV     #C,W1
07052:  MOV     W0,W2
07054:  REPEAT  #3
07056:  MOV.B   [W2++],[W1++]
07058:  MOV     W5,W1
0705A:  MOV     #0,W2
0705C:  MOV     W6,W0
0705E:  DEC     W0,W0
07060:  BRA     N,7064
07062:  REPEAT  W0
07064:  CLR.B   [W1++]
....................  
....................     entry.DIR_Name[0] = '.'; 
07066:  MOV.B   #2E,W0L
07068:  MOV.B   W0L,1020
....................  
....................     for (i = 1; i < 8; i++) 
0706A:  MOV     #1,W4
0706C:  MOV     W4,101C
0706E:  MOV     101C,W4
07070:  CP      W4,#8
07072:  BRA     C,7084
....................     { 
....................         entry.DIR_Name[i] = 0x20; 
07074:  MOV     #1020,W4
07076:  MOV     101C,W3
07078:  ADD     W3,W4,W5
0707A:  MOV.B   #20,W0L
0707C:  MOV.B   W0L,[W5]
0707E:  INC     101C
07080:  GOTO    706E
....................     } 
....................     for (i = 0; i < 3; i++) 
07084:  CLR     101C
07086:  MOV     101C,W4
07088:  CP      W4,#3
0708A:  BRA     C,709C
....................     { 
....................         entry.DIR_Extension[i] = 0x20; 
0708C:  MOV     #1028,W0
0708E:  ADD     101C,W0
07090:  MOV     W0,W5
07092:  MOV.B   #20,W0L
07094:  MOV.B   W0L,[W5]
07096:  INC     101C
07098:  GOTO    7086
....................     } 
....................  
....................     entry.DIR_Attr = ATTR_DIRECTORY; 
0709C:  MOV.B   #10,W0L
0709E:  MOV.B   W0L,102B
....................     entry.DIR_NTRes = 0x00; 
070A0:  CLR.B   102C
....................  
....................     entry.DIR_FstClusLO = (WORD)(dotAddress & 0x0000FFFF); // Lower 16 bit address 
070A2:  CLR     W1
070A4:  MOV     1014,W0
070A6:  MOV     W0,103A
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................     entry.DIR_FstClusHI = (WORD)((dotAddress & 0x0FFF0000)>> 16); // Higher 16 bit address. FAT32 uses only 28 bits. Mask even higher nibble also. 
070A8:  CLR     W5
070AA:  MOV     #FFF,W0
070AC:  AND     1016,W0
070AE:  MOV     W0,W6
070B0:  MOV     W6,W0
070B2:  MOV     #0,W1
070B4:  MOV     W0,1034
.................... #else // If FAT32 support not enabled 
....................     entry.DIR_FstClusHI = 0; 
.................... #endif 
....................  
....................     entry.DIR_FileSize = 0x00; 
070B6:  CLR     103C
070B8:  CLR     103E
....................  
.................... // Times need to be the same as the times in the directory entry 
....................  
.................... // Set dir date for uncontrolled clock source 
.................... #ifdef INCREMENTTIMESTAMP 
....................     entry.DIR_CrtTimeTenth = 0xB2; 
....................     entry.DIR_CrtTime = 0x7278; 
....................     entry.DIR_CrtDate = 0x32B0; 
....................     entry.DIR_LstAccDate = 0x0000; 
....................     entry.DIR_WrtTime = 0x0000; 
....................     entry.DIR_WrtDate = 0x0000; 
.................... #endif 
....................  
.................... #ifdef USEREALTIMECLOCK 
....................     entry.DIR_CrtTimeTenth = gTimeCrtMS;         // millisecond stamp 
....................     entry.DIR_CrtTime =      gTimeCrtTime;      // time created // 
....................     entry.DIR_CrtDate =      gTimeCrtDate;      // date created (1/1/2004) 
....................     entry.DIR_LstAccDate =   0x0000;         // Last Access date 
....................     entry.DIR_WrtTime =      0x0000;         // last update time 
....................     entry.DIR_WrtDate =      0x0000;         // last update date 
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................     entry.DIR_CrtTimeTenth  =   gTimeCrtMS;         // millisecond stamp 
070BA:  MOV.B   898,W0L
070BC:  MOV.B   W0L,102D
....................     entry.DIR_CrtTime       =   gTimeCrtTime;       // time created // 
070BE:  PUSH    89A
070C0:  POP     102E
....................     entry.DIR_CrtDate       =   gTimeCrtDate;       // date created (1/1/2004) 
070C2:  PUSH    89C
070C4:  POP     1030
....................     entry.DIR_LstAccDate    =   0x0000;             // Last Access date 
070C6:  CLR     1032
....................     entry.DIR_WrtTime       =   0x0000;             // last update time 
070C8:  CLR     1036
....................     entry.DIR_WrtDate       =   0x0000;             // last update date 
070CA:  CLR     1038
.................... #endif 
....................  
....................     for (i = 0; i < size; i++) 
070CC:  CLR     101C
070CE:  MOV     101C,W0
070D0:  MOV     101E,W4
070D2:  CP      W4,W0
070D4:  BRA     LEU,70F6
....................     { 
....................         *(disk->buffer + i) = *((char *)entryptr + i); 
070D6:  MOV     1012,W4
070D8:  ADD     W4,#0,W4
070DA:  MOV     W4,W0
070DC:  MOV     #A,W1
070DE:  MOV     W0,W2
070E0:  REPEAT  #1
070E2:  MOV.B   [W2++],[W1++]
070E4:  MOV     W5,W0
070E6:  ADD     101C,W0
070E8:  MOV     W0,W5
070EA:  MOV     1040,W0
070EC:  ADD     101C,W0
070EE:  MOV.B   [W0],[W5]
070F0:  INC     101C
070F2:  GOTO    70CE
....................     } 
....................     entry.DIR_Name[1] = '.'; 
070F6:  MOV.B   #2E,W0L
070F8:  MOV.B   W0L,1021
....................  
....................     entry.DIR_FstClusLO = (WORD)(dotdotAddress & 0x0000FFFF); // Lower 16 bit address 
070FA:  CLR     W1
070FC:  MOV     1018,W0
070FE:  MOV     W0,103A
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................     entry.DIR_FstClusHI = (WORD)((dotdotAddress & 0x0FFF0000)>> 16); // Higher 16 bit address. FAT32 uses only 28 bits. Mask even higher nibble also. 
07100:  CLR     W5
07102:  MOV     #FFF,W0
07104:  AND     101A,W0
07106:  MOV     W0,W6
07108:  MOV     W6,W0
0710A:  MOV     #0,W1
0710C:  MOV     W0,1034
.................... #else // If FAT32 support not enabled 
....................     entry.DIR_FstClusHI = 0; 
.................... #endif 
....................  
....................  
....................     for (i = 0; i < size; i++) 
0710E:  CLR     101C
07110:  MOV     101C,W0
07112:  MOV     101E,W4
07114:  CP      W4,W0
07116:  BRA     LEU,713E
....................     { 
....................         *(disk->buffer + i + size) = *((char *)entryptr + i); 
07118:  MOV     1012,W4
0711A:  ADD     W4,#0,W4
0711C:  MOV     W4,W0
0711E:  MOV     #A,W1
07120:  MOV     W0,W2
07122:  REPEAT  #1
07124:  MOV.B   [W2++],[W1++]
07126:  MOV     W5,W0
07128:  ADD     101C,W0
0712A:  MOV     W0,W5
0712C:  MOV     W5,W0
0712E:  ADD     101E,W0
07130:  MOV     W0,W5
07132:  MOV     1040,W0
07134:  ADD     101C,W0
07136:  MOV.B   [W0],[W5]
07138:  INC     101C
0713A:  GOTO    7110
....................     } 
....................  
....................     sector = Cluster2Sector (disk, dotAddress); 
0713E:  PUSH    1012
07140:  POP     10B0
07142:  PUSH    1014
07144:  POP     10B2
07146:  PUSH    1016
07148:  POP     10B4
0714A:  CALL    308C
0714E:  MOV     W0,1042
07150:  MOV     W1,1044
....................  
....................     if (MDD_SectorWrite(sector, disk->buffer, FALSE) == FALSE) 
07152:  MOV     1012,W4
07154:  ADD     W4,#0,W4
07156:  MOV     W4,W0
07158:  MOV     #A,W1
0715A:  MOV     W0,W2
0715C:  REPEAT  #1
0715E:  MOV.B   [W2++],[W1++]
07160:  CLR.B   10F8
07162:  PUSH    1042
07164:  POP     10F2
07166:  PUSH    1044
07168:  POP     10F4
0716A:  MOV     W5,10F6
0716C:  CALL    2BBE
07170:  CP0.B   W0L
07172:  BRA     NZ,717C
....................     { 
....................         FSerrno = CE_WRITE_ERROR; 
07174:  MOV.B   #9,W0L
07176:  MOV.B   W0L,8B1
....................         return FALSE; 
07178:  CLR.B   0
0717A:  BRA     7180
....................     } 
....................  
....................     return TRUE; 
0717C:  MOV.B   #1,W0L
0717E:  MOV.B   W0L,0
07180:  MOV     [--W15],W7
07182:  MOV     [--W15],W6
07184:  MOV     [--W15],W5
07186:  RETURN  
.................... } 
....................  
.................... // This array is used to prevent a stack frame error 
.................... #ifdef __18CXX 
....................     char tempArray[13] = "           "; 
.................... #endif 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdir (char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs - 
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int FSrmdir (char * path, unsigned char rmsubdirs) 
.................... { 
....................     return rmdirhelper (0, path, NULL, rmsubdirs); 
*
07EA6:  CLR.B   FD6
07EA8:  MOV.B   FD2,W0L
07EAA:  MOV.B   W0L,FD7
07EAC:  PUSH    FD0
07EAE:  POP     FD8
07EB0:  CLR     FDA
07EB2:  CALL    7808
07EB6:  MOV     W0,0
07EB8:  RETURN  
.................... } 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs) 
....................   Summary: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs - 
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................     result = rmdirhelper (0, (char *)path, NULL, rmsubdirs); 
....................    utfModeFileName = FALSE; 
....................     return result; 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdirpgm (const rom char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     path -      The path of the directory to remove (ROM) 
....................     rmsubdirs - 
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................     This function deletes the directory as specified in the path. 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int FSrmdirpgm (const rom char * path, unsigned char rmsubdirs) 
.................... { 
....................     return rmdirhelper (1, NULL, path, rmsubdirs); 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................         int wFSrmdirpgm (const rom unsigned short int * path, unsigned char rmsubdirs) 
....................   Summary: 
....................     Delete a directory with a path in ROM on PIC18 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     path -      The path of the directory to remove (ROM) 
....................     rmsubdirs - 
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSrmdirpgm function passes a PIC18 ROM path pointer to the 
....................     rmdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................  
.................... #ifdef SUPPORT_LFN 
.................... int wFSrmdirpgm (const rom unsigned short int * path, unsigned char rmsubdirs) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................     result = rmdirhelper (1, NULL, (const char *)path, rmsubdirs); 
....................    utfModeFileName = FALSE; 
....................     return result; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /************************************************************************************************ 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int rmdirhelper (BYTE mode, char * ramptr, char * romptr, unsigned char rmsubdirs) 
....................     // PIC18 
....................     int rmdirhelper (BYTE mode, char * ramptr, const rom char * romptr, unsigned char rmsubdirs) 
....................   Summary: 
....................     Helper function for FSrmdir 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     path -      The path of the dir to delete 
....................     rmsubdirs - 
....................               - TRUE -  Remove all sub-directories and files in the directory 
....................               - FALSE - Non-empty directories can not be removed 
....................   Return Values: 
....................     0 -   The specified directory was successfully removed. 
....................     EOF - The specified directory could not be removed. 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This helper function is used by the FSmkdir function.  If the path 
....................     argument is specified in ROM for PIC18 this function will be able 
....................     to parse it correctly.  This function will first change to the 
....................     specified directory.  If the rmsubdirs argument is FALSE the function 
....................     will search through the directory to ensure that it is empty and then 
....................     remove it.  If the rmsubdirs argument is TRUE the function will also 
....................     search through the directory for subdirectories or files.  When the 
....................     function finds a file, the file will be erased.  When the function 
....................     finds a subdirectory, it will switch to the subdirectory and begin 
....................     removing all of the files in that subdirectory.  Once the subdirectory 
....................     is empty, the function will switch back to the original directory. 
....................     return to the original position in that directory, and continue removing 
....................     files.  Once the specified directory is empty, the function will 
....................     change to the parent directory, search through it for the directory 
....................     to remove, and then erase that directory. 
....................   Remarks: 
....................     None. 
....................   ************************************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int rmdirhelper (BYTE mode, char * ramptr, const rom char * romptr, unsigned char rmsubdirs) 
.................... #else 
.................... int rmdirhelper (BYTE mode, char * ramptr, char * romptr, unsigned char rmsubdirs) 
.................... #endif 
*
07808:  MOV     W5,[W15++]
0780A:  MOV     W6,[W15++]
0780C:  MOV     #8BC,W4
0780E:  MOV     W4,FDC
07810:  MOV     #8F2,W4
07812:  MOV     W4,FDE
*
07816:  CLR     FE2
*
0781C:  CLR     FE8
.................... { 
....................     FILEOBJ tempCWD = &tempCWDobj; 
....................     FILEOBJ fo = &gFileTemp; 
....................     DIRENTRY entry; 
*
07814:  CLR     FE0
....................     WORD handle = 0; 
....................     WORD handle2; 
*
07818:  CLR     FE4
....................     WORD subDirDepth; 
0781A:  CLR     FE6
....................     short int Index3 = 0; 
....................     char Index, Index2; 
*
0781E:  CLR.B   FEA
07820:  CLR.B   FEB
....................  
....................    #if defined(SUPPORT_LFN) 
....................  
....................       BOOL prevUtfModeFileName = utfModeFileName; 
....................       char tempArray[514]; 
....................        WORD prevHandle; 
....................        LFN_ENTRY *lfno; 
....................        FSFILE cwdTemp; 
....................       UINT16_VAL tempShift; 
....................       unsigned short int *tempLFN = (unsigned short int *)&tempArray[0]; 
....................       BOOL   forFirstTime; 
....................    #else 
....................  
....................       char   tempArray[13]; 
07822:  CLR     FEC
07824:  CLR     FEE
07826:  CLR     FF0
07828:  CLR     FF2
0782A:  CLR     FF4
0782C:  CLR     FF6
0782E:  CLR.B   FF8
....................  
....................    #endif 
....................  
.................... #ifndef __18CXX 
....................  
.................... #else 
....................     char dotdotname[] = ".."; 
....................     char dotdotname1[5] = {'.','\0','.','\0','\0'}; 
.................... #endif 
....................  
....................     FSerrno = CE_GOOD; 
07830:  CLR.B   8B1
....................  
....................     // Back up the current working directory 
....................     FileObjectCopy (tempCWD, cwdptr); 
07832:  PUSH    FDC
07834:  POP     105C
07836:  PUSH    95E
07838:  POP     105E
0783A:  CALL    28E2
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     if (mode) 
....................     { 
....................         if (chdirhelper (1, NULL, romptr)) 
....................         { 
....................             FSerrno = CE_DIR_NOT_FOUND; 
....................             return -1; 
....................         } 
....................     } 
....................     else 
....................     { 
.................... #endif 
....................         if (FSchdir (ramptr)) 
0783E:  PUSH    FD8
07840:  POP     1008
07842:  CALL    650A
07846:  CP0     W0
07848:  BRA     Z,7852
....................         { 
....................             FSerrno = CE_DIR_NOT_FOUND; 
0784A:  MOV.B   #C,W0L
0784C:  MOV.B   W0L,8B1
....................             return -1; 
0784E:  SETM    0
07850:  BRA     7EA0
....................         } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     } 
.................... #endif 
....................  
....................     // Make sure we aren't trying to remove the root dir or the CWD 
....................     if ((cwdptr->dirclus == FatRootDirClusterValue) || (cwdptr->dirclus == tempCWD->dirclus)) 
07852:  MOV     #2E,W0
07854:  ADD     95E,W0
07856:  MOV     #A,W4
07858:  MOV     [W0++],[W4++]
0785A:  MOV     [W0++],[W4++]
0785C:  MOV     8B2,W4
0785E:  CP      W4,W5
07860:  BRA     NZ,7868
07862:  MOV     8B4,W4
07864:  CP      W4,W6
07866:  BRA     Z,7886
07868:  MOV     #2E,W0
0786A:  ADD     95E,W0
0786C:  MOV     #A,W4
0786E:  MOV     [W0++],[W4++]
07870:  MOV     [W0++],[W4++]
07872:  MOV     #2E,W0
07874:  ADD     FDC,W0
07876:  MOV     W0,W4
07878:  MOV     #0,W3
0787A:  MOV     [W4++],[W3++]
0787C:  MOV     [W4++],[W3++]
0787E:  CP      W5,W0
07880:  BRA     NZ,789A
07882:  CP      W6,W1
07884:  BRA     NZ,789A
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
07886:  PUSH    95E
07888:  POP     105C
0788A:  PUSH    FDC
0788C:  POP     105E
0788E:  CALL    28E2
....................         FSerrno = CE_INVALID_ARGUMENT; 
07892:  MOV.B   #1F,W0L
07894:  MOV.B   W0L,8B1
....................         return -1; 
07896:  SETM    0
07898:  BRA     7EA0
....................     } 
....................  
....................     handle++; 
0789A:  INC     0FE2
....................     entry = Cache_File_Entry (cwdptr, &handle, TRUE); 
0789C:  MOV.B   #1,W0L
0789E:  MOV.B   W0L,1086
078A0:  PUSH    95E
078A2:  POP     1082
078A4:  MOV     #FE2,W4
078A6:  MOV     W4,1084
078A8:  CALL    31E4
078AC:  MOV     W0,FE0
....................  
....................     if (entry == NULL) 
078AE:  CP0     FE0
078B0:  BRA     NZ,78C6
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
078B2:  PUSH    95E
078B4:  POP     105C
078B6:  PUSH    FDC
078B8:  POP     105E
078BA:  CALL    28E2
....................         FSerrno = CE_BADCACHEREAD; 
078BE:  MOV.B   #1B,W0L
078C0:  MOV.B   W0L,8B1
....................         return -1; 
078C2:  SETM    0
078C4:  BRA     7EA0
....................     } 
....................  
....................     handle++; 
078C6:  INC     0FE2
....................     entry = Cache_File_Entry (cwdptr, &handle, FALSE); 
078C8:  CLR.B   1086
078CA:  PUSH    95E
078CC:  POP     1082
078CE:  MOV     #FE2,W4
078D0:  MOV     W4,1084
078D2:  CALL    31E4
078D6:  MOV     W0,FE0
....................     if (entry == NULL) 
078D8:  CP0     FE0
078DA:  BRA     NZ,78F0
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
078DC:  PUSH    95E
078DE:  POP     105C
078E0:  PUSH    FDC
078E2:  POP     105E
078E4:  CALL    28E2
....................         FSerrno = CE_BADCACHEREAD; 
078E8:  MOV.B   #1B,W0L
078EA:  MOV.B   W0L,8B1
....................         return -1; 
078EC:  SETM    0
078EE:  BRA     7EA0
....................     } 
....................     // Don't remove subdirectories and sub-files 
....................     if (!rmsubdirs) 
078F0:  CP0.B   FD7
078F2:  BRA     NZ,7950
....................     { 
....................         while (entry->DIR_Name[0] != 0) 
078F4:  MOV     #0,W0
078F6:  ADD     FE0,W0
078F8:  MOV.B   [W0],W5L
078FA:  SE      W5,W5
078FC:  CP0     W5
078FE:  BRA     Z,794C
....................         { 
....................             if ((unsigned char)entry->DIR_Name[0] != 0xE5) 
07900:  MOV     #0,W0
07902:  ADD     FE0,W0
07904:  MOV.B   [W0],W4L
07906:  XOR.B   #E5,W4L
07908:  BRA     Z,791E
....................             { 
....................                 FileObjectCopy (cwdptr, tempCWD); 
0790A:  PUSH    95E
0790C:  POP     105C
0790E:  PUSH    FDC
07910:  POP     105E
07912:  CALL    28E2
....................                 FSerrno = CE_DIR_NOT_EMPTY; 
07916:  MOV.B   #16,W0L
07918:  MOV.B   W0L,8B1
....................                 return -1; 
0791A:  SETM    0
0791C:  BRA     7EA0
....................             } 
....................             handle++; 
0791E:  INC     0FE2
....................             entry = Cache_File_Entry (cwdptr, &handle, FALSE); 
07920:  CLR.B   1086
07922:  PUSH    95E
07924:  POP     1082
07926:  MOV     #FE2,W4
07928:  MOV     W4,1084
0792A:  CALL    31E4
0792E:  MOV     W0,FE0
....................             if ((entry == NULL)) 
07930:  CP0     FE0
07932:  BRA     NZ,7948
....................             { 
....................                 FileObjectCopy (cwdptr, tempCWD); 
07934:  PUSH    95E
07936:  POP     105C
07938:  PUSH    FDC
0793A:  POP     105E
0793C:  CALL    28E2
....................                 FSerrno = CE_BADCACHEREAD; 
07940:  MOV.B   #1B,W0L
07942:  MOV.B   W0L,8B1
....................                 return -1; 
07944:  SETM    0
07946:  BRA     7EA0
....................             } 
07948:  GOTO    78F4
....................         } 
....................     } 
0794C:  GOTO    7DDA
....................     else 
....................     { 
....................         // Do remove subdirectories and sub-files 
....................         dirCleared = FALSE; 
07950:  CLR.B   8BA
....................         subDirDepth = 0; 
07952:  CLR     FE6
....................       #if defined(SUPPORT_LFN) 
....................       tempCWD-> utf16LFNptr = (unsigned short int *)&tempArray[0]; 
....................       fo-> utf16LFNptr = (unsigned short int *)&tempArray[0]; 
....................       #endif 
....................  
....................         while (!dirCleared) 
07954:  CP0.B   8BA
07956:  BRA     NZ,7DDA
....................         { 
....................             if (entry->DIR_Name[0] != 0) 
07958:  MOV     #0,W0
0795A:  ADD     FE0,W0
0795C:  MOV.B   [W0],W5L
0795E:  SE      W5,W5
07960:  CP0     W5
07962:  BRA     Z,7BE6
....................             { 
....................                 if (((unsigned char)entry->DIR_Name[0] != 0xE5) && (entry->DIR_Attr == ATTR_LONG_NAME)) 
07964:  MOV     #0,W0
07966:  ADD     FE0,W0
07968:  MOV.B   [W0],W4L
0796A:  XOR.B   #E5,W4L
0796C:  BRA     Z,797C
0796E:  MOV     #B,W0
07970:  ADD     FE0,W0
07972:  MOV.B   [W0],W4L
07974:  CP.B    W4L,#F
07976:  BRA     NZ,797C
....................             { 
....................                #if defined(SUPPORT_LFN) 
....................                lfno = (LFN_ENTRY *)entry; 
....................  
....................                if(lfno->LFN_SequenceNo & 0x40) 
....................                { 
....................                   Index3 = (lfno->LFN_SequenceNo - 0x41) * 13; 
....................                   tempLFN[Index3 + 13] = 0x0000; 
....................                   forFirstTime = TRUE; 
....................                } 
....................                else 
....................                { 
....................                   Index3 = (lfno->LFN_SequenceNo - 1) * 13; 
....................                   forFirstTime = FALSE; 
....................                } 
....................  
....................                tempShift.byte.LB = lfno->LFN_Part1[0]; 
....................                tempShift.byte.HB = lfno->LFN_Part1[1]; 
....................                tempLFN[Index3++] = tempShift.Val; 
....................                tempShift.byte.LB = lfno->LFN_Part1[2]; 
....................                tempShift.byte.HB = lfno->LFN_Part1[3]; 
....................                tempLFN[Index3++] = tempShift.Val; 
....................                tempShift.byte.LB = lfno->LFN_Part1[4]; 
....................                tempShift.byte.HB = lfno->LFN_Part1[5]; 
....................                tempLFN[Index3++] = tempShift.Val; 
....................                tempShift.byte.LB = lfno->LFN_Part1[6]; 
....................                tempShift.byte.HB = lfno->LFN_Part1[7]; 
....................                tempLFN[Index3++] = tempShift.Val; 
....................                tempShift.byte.LB = lfno->LFN_Part1[8]; 
....................                tempShift.byte.HB = lfno->LFN_Part1[9]; 
....................                tempLFN[Index3++] = tempShift.Val; 
....................  
....................                tempLFN[Index3++] = lfno->LFN_Part2[0]; 
....................                tempLFN[Index3++] = lfno->LFN_Part2[1]; 
....................                tempLFN[Index3++] = lfno->LFN_Part2[2]; 
....................                tempLFN[Index3++] = lfno->LFN_Part2[3]; 
....................                tempLFN[Index3++] = lfno->LFN_Part2[4]; 
....................                tempLFN[Index3++] = lfno->LFN_Part2[5]; 
....................  
....................                tempLFN[Index3++] = lfno->LFN_Part3[0]; 
....................                tempLFN[Index3] = lfno->LFN_Part3[1]; 
....................  
....................                if(forFirstTime) 
....................                { 
....................                   tempCWD->utf16LFNlength = Index3; 
....................  
....................                   for(Index = 12;Index >= 0;Index--) 
....................                   { 
....................                      if((tempLFN[Index3 - Index - 1]) == 0x0000) 
....................                      { 
....................                         tempCWD->utf16LFNlength = Index3 - Index - 1; 
....................                         break; 
....................                      } 
....................                   } 
....................  
....................                   fo->utf16LFNlength = tempCWD->utf16LFNlength; 
....................                } 
....................                    handle++; 
....................                #endif 
....................             } 
07978:  GOTO    7B90
....................                 else if (((unsigned char)entry->DIR_Name[0] != 0xE5) && (entry->DIR_Attr != ATTR_VOLUME) && (entry->DIR_Attr != ATTR_LONG_NAME)) 
0797C:  MOV     #0,W0
0797E:  ADD     FE0,W0
07980:  MOV.B   [W0],W4L
07982:  XOR.B   #E5,W4L
07984:  BRA     Z,7B8E
07986:  MOV     #B,W0
07988:  ADD     FE0,W0
0798A:  MOV.B   [W0],W4L
0798C:  CP.B    W4L,#8
0798E:  BRA     Z,7B8E
07990:  MOV     #B,W0
07992:  ADD     FE0,W0
07994:  MOV.B   [W0],W4L
07996:  CP.B    W4L,#F
07998:  BRA     Z,7B8E
....................                 { 
....................                     if ((entry->DIR_Attr & ATTR_DIRECTORY) == ATTR_DIRECTORY) 
0799A:  MOV     #B,W0
0799C:  ADD     FE0,W0
0799E:  MOV.B   [W0],W0L
079A0:  CLR.B   1
079A2:  AND     W0,#10,W5
079A4:  CP      W5,#10
079A6:  BRA     NZ,7AAA
....................                     { 
....................                         // We have a directory 
....................                         subDirDepth++; 
079A8:  INC     0FE6
....................                   #if defined(SUPPORT_LFN) 
....................                   if(tempCWD-> utf16LFNlength) 
....................                   { 
....................                      utfModeFileName = 1; 
....................                      Index = FSchdir(&tempArray[0]); 
....................                      utfModeFileName = prevUtfModeFileName; 
....................                      tempCWD-> utf16LFNlength = 0; 
....................                      fo-> utf16LFNlength = 0; 
....................                   } 
....................                   else 
....................                   #endif 
....................                   { 
....................                            for (Index = 0; (Index < DIR_NAMESIZE) && (entry->DIR_Name[(BYTE)Index] != 0x20); Index++) 
079AA:  CLR.B   FEA
079AC:  MOV.B   FEA,W0L
079AE:  SE      W0,W0
079B0:  CP      W0,#8
079B2:  BRA     GE,79DE
079B4:  MOV     FEA,W4
079B6:  CLR.B   9
079B8:  MOV     W4,W0
079BA:  ADD     FE0,W0
079BC:  MOV.B   [W0],W5L
079BE:  SE      W5,W5
079C0:  MOV     #20,W4
079C2:  CP      W4,W5
079C4:  BRA     Z,79DE
....................                            { 
....................                                tempArray[(BYTE)Index] = entry->DIR_Name[(BYTE)Index]; 
079C6:  MOV     FEA,W4
079C8:  CLR.B   9
079CA:  MOV     #FEC,W3
079CC:  ADD     W4,W3,W5
079CE:  MOV     FEA,W4
079D0:  CLR.B   9
079D2:  MOV     W4,W0
079D4:  ADD     FE0,W0
079D6:  MOV.B   [W0],[W5]
079D8:  INC.B   0FEA
079DA:  GOTO    79AC
....................                            } 
....................                            if (entry->DIR_Extension[0] != 0x20) 
079DE:  MOV     #8,W0
079E0:  ADD     FE0,W0
079E2:  MOV.B   [W0],W5L
079E4:  SE      W5,W5
079E6:  MOV     #20,W4
079E8:  CP      W4,W5
079EA:  BRA     Z,7A3C
....................                            { 
....................                                tempArray[(BYTE)Index++] = '.'; 
079EC:  MOV.B   FEA,W0L
079EE:  INC.B   0FEA
079F0:  ZE      W0,W0
079F2:  CLR.B   1
079F4:  MOV     #FEC,W4
079F6:  ADD     W0,W4,W5
079F8:  MOV.B   #2E,W0L
079FA:  MOV.B   W0L,[W5]
....................                                for (Index2 = 0; (Index2 < DIR_EXTENSION) && (entry->DIR_Extension[(BYTE)Index2] != 0x20); Index2++) 
079FC:  CLR.B   FEB
079FE:  MOV.B   FEB,W0L
07A00:  SE      W0,W0
07A02:  CP      W0,#3
07A04:  BRA     GE,7A3C
07A06:  MOV     #8,W0
07A08:  ADD.B   FEB,W0L
07A0A:  ZE      W0,W0
07A0C:  CLR.B   1
07A0E:  MOV     FE0,W4
07A10:  ADD     W0,W4,W0
07A12:  MOV.B   [W0],W5L
07A14:  SE      W5,W5
07A16:  MOV     #20,W4
07A18:  CP      W4,W5
07A1A:  BRA     Z,7A3C
....................                                { 
....................                                    tempArray[(BYTE)Index++] = entry->DIR_Extension[(BYTE)Index2]; 
07A1C:  MOV.B   FEA,W0L
07A1E:  INC.B   0FEA
07A20:  ZE      W0,W0
07A22:  CLR.B   1
07A24:  MOV     #FEC,W4
07A26:  ADD     W0,W4,W5
07A28:  MOV     #8,W0
07A2A:  ADD.B   FEB,W0L
07A2C:  ZE      W0,W0
07A2E:  CLR.B   1
07A30:  MOV     FE0,W4
07A32:  ADD     W0,W4,W0
07A34:  MOV.B   [W0],[W5]
07A36:  INC.B   0FEB
07A38:  GOTO    79FE
....................                                } 
....................                            } 
....................                            tempArray[(BYTE)Index] = 0; 
07A3C:  MOV     FEA,W4
07A3E:  CLR.B   9
07A40:  MOV     #FEC,W3
07A42:  ADD     W4,W3,W5
07A44:  CLR.B   [W5]
....................                      #ifdef SUPPORT_LFN 
....................                      utfModeFileName = 0; 
....................                      #endif 
....................                      Index = FSchdir(&tempArray[0]); 
07A46:  MOV     #FEC,W4
07A48:  MOV     W4,1008
07A4A:  CALL    650A
07A4E:  MOV.B   W0L,FEA
....................                      #ifdef SUPPORT_LFN 
....................                      utfModeFileName = prevUtfModeFileName; 
....................                      #endif 
....................                   } 
....................  
....................                         // Change to the subdirectory 
....................                         if (Index) 
07A50:  CP0.B   FEA
07A52:  BRA     Z,7A6C
....................                         { 
....................                             FileObjectCopy (cwdptr, tempCWD); 
07A54:  PUSH    95E
07A56:  POP     105C
07A58:  PUSH    FDC
07A5A:  POP     105E
07A5C:  CALL    28E2
....................                             FSerrno = CE_DIR_NOT_FOUND; 
07A60:  MOV.B   #C,W0L
07A62:  MOV.B   W0L,8B1
....................                             return -1; 
07A64:  SETM    0
07A66:  BRA     7EA0
....................                         } 
07A68:  GOTO    7A9E
....................                         else 
....................                         { 
....................                             // Make sure we're not trying to delete the CWD 
....................                             if (cwdptr->dirclus == tempCWD->dirclus) 
07A6C:  MOV     #2E,W0
07A6E:  ADD     95E,W0
07A70:  MOV     #A,W4
07A72:  MOV     [W0++],[W4++]
07A74:  MOV     [W0++],[W4++]
07A76:  MOV     #2E,W0
07A78:  ADD     FDC,W0
07A7A:  MOV     W0,W4
07A7C:  MOV     #0,W3
07A7E:  MOV     [W4++],[W3++]
07A80:  MOV     [W4++],[W3++]
07A82:  CP      W5,W0
07A84:  BRA     NZ,7A9E
07A86:  CP      W6,W1
07A88:  BRA     NZ,7A9E
....................                             { 
....................                                 FileObjectCopy (cwdptr, tempCWD); 
07A8A:  PUSH    95E
07A8C:  POP     105C
07A8E:  PUSH    FDC
07A90:  POP     105E
07A92:  CALL    28E2
....................                                 FSerrno = CE_INVALID_ARGUMENT; 
07A96:  MOV.B   #1F,W0L
07A98:  MOV.B   W0L,8B1
....................                                 return -1; 
07A9A:  SETM    0
07A9C:  BRA     7EA0
....................                             } 
....................                         } 
....................                         handle = 2; 
07A9E:  MOV     #2,W4
07AA0:  MOV     W4,FE2
....................                         recache = TRUE; 
07AA2:  MOV.B   #1,W0L
07AA4:  MOV.B   W0L,8BB
....................                     } 
07AA6:  GOTO    7B8A
....................                     else 
....................                     { 
....................                   #if defined(SUPPORT_LFN) 
....................                   if(!tempCWD-> utf16LFNlength) 
....................                   #endif 
....................                   { 
....................                            for (Index = 0; Index < 8; Index++) 
07AAA:  CLR.B   FEA
07AAC:  MOV.B   FEA,W0L
07AAE:  SE      W0,W0
07AB0:  CP      W0,#8
07AB2:  BRA     GE,7AD0
....................                            { 
....................                                fo->name[(BYTE)Index] = entry->DIR_Name[(BYTE)Index]; 
07AB4:  MOV     #1C,W0
07AB6:  ADD.B   FEA,W0L
07AB8:  ZE      W0,W0
07ABA:  CLR.B   1
07ABC:  MOV     FDE,W4
07ABE:  ADD     W0,W4,W5
07AC0:  MOV     FEA,W4
07AC2:  CLR.B   9
07AC4:  MOV     W4,W0
07AC6:  ADD     FE0,W0
07AC8:  MOV.B   [W0],[W5]
07ACA:  INC.B   0FEA
07ACC:  GOTO    7AAC
....................                            } 
....................  
....................                            for (Index = 0; Index < 3; Index++) 
07AD0:  CLR.B   FEA
07AD2:  MOV.B   FEA,W0L
07AD4:  SE      W0,W0
07AD6:  CP      W0,#3
07AD8:  BRA     GE,7AFE
....................                            { 
....................                                fo->name[(BYTE)Index + 8] = entry->DIR_Extension[(BYTE)Index]; 
07ADA:  MOV     FEA,W4
07ADC:  CLR.B   9
07ADE:  ADD     W4,#8,W4
07AE0:  MOV     W4,W5
07AE2:  ADD     W5,#1C,W5
07AE4:  MOV     W5,W0
07AE6:  MOV     FDE,W4
07AE8:  ADD     W0,W4,W6
07AEA:  MOV     #8,W0
07AEC:  ADD.B   FEA,W0L
07AEE:  ZE      W0,W0
07AF0:  CLR.B   1
07AF2:  MOV     FE0,W4
07AF4:  ADD     W0,W4,W0
07AF6:  MOV.B   [W0],[W6]
07AF8:  INC.B   0FEA
07AFA:  GOTO    7AD2
....................                            } 
....................                   } 
....................  
....................                         fo->dsk = &gDiskData; 
07AFE:  MOV     FDE,W4
07B00:  ADD     W4,#0,W4
07B02:  MOV     W4,W0
07B04:  MOV     W0,W5
07B06:  MOV.B   #60,W0L
07B08:  MOV.B   W0L,[W5]
07B0A:  MOV.B   #D,W0L
07B0C:  MOV.B   W0L,[W5+#1]
....................  
....................                         fo->entry = handle; 
07B0E:  MOV     #28,W0
07B10:  ADD     FDE,W0
07B12:  MOV     W0,W5
07B14:  MOV     FE2,W4
07B16:  MOV     W4,[W5+#0]
....................                         fo->dirclus = cwdptr->dirclus; 
07B18:  MOV     #2E,W0
07B1A:  ADD     FDE,W0
07B1C:  MOV     W0,W5
07B1E:  MOV     #2E,W0
07B20:  ADD     95E,W0
07B22:  MOV     [W0++],[W5++]
07B24:  MOV     [W0++],[W5++]
....................                         fo->dirccls = cwdptr->dirccls; 
07B26:  MOV     #32,W0
07B28:  ADD     FDE,W0
07B2A:  MOV     W0,W5
07B2C:  MOV     #32,W0
07B2E:  ADD     95E,W0
07B30:  MOV     [W0++],[W5++]
07B32:  MOV     [W0++],[W5++]
....................                         fo->cluster = 0; 
07B34:  MOV     #2,W0
07B36:  ADD     FDE,W0
07B38:  MOV     W0,W5
07B3A:  CLR.B   [W5]
07B3C:  MOV.B   #0,W0L
07B3E:  MOV.B   W0L,[W5+#1]
07B40:  MOV.B   #0,W0L
07B42:  MOV.B   W0L,[W5+#2]
07B44:  MOV.B   #0,W0L
07B46:  MOV.B   W0L,[W5+#3]
....................                         fo->ccls    = 0; 
07B48:  MOV     #6,W0
07B4A:  ADD     FDE,W0
07B4C:  MOV     W0,W5
07B4E:  CLR.B   [W5]
07B50:  MOV.B   #0,W0L
07B52:  MOV.B   W0L,[W5+#1]
07B54:  MOV.B   #0,W0L
07B56:  MOV.B   W0L,[W5+#2]
07B58:  MOV.B   #0,W0L
07B5A:  MOV.B   W0L,[W5+#3]
....................  
....................                         if (FILEerase(fo, &handle, TRUE)) 
07B5C:  MOV.B   #1,W0L
07B5E:  MOV.B   W0L,104E
07B60:  PUSH    FDE
07B62:  POP     104A
07B64:  MOV     #FE2,W4
07B66:  MOV     W4,104C
07B68:  CALL    3BA8
07B6C:  CP0.B   W0L
07B6E:  BRA     Z,7B88
....................                         { 
....................                      #if defined(SUPPORT_LFN) 
....................                      tempCWD-> utf16LFNlength = 0; 
....................                      fo-> utf16LFNlength = 0; 
....................                      #endif 
....................                             FileObjectCopy (cwdptr, tempCWD); 
07B70:  PUSH    95E
07B72:  POP     105C
07B74:  PUSH    FDC
07B76:  POP     105E
07B78:  CALL    28E2
....................                             FSerrno = CE_ERASE_FAIL; 
07B7C:  MOV.B   #1,W0L
07B7E:  MOV.B   W0L,8B1
....................                             return -1; 
07B80:  SETM    0
07B82:  BRA     7EA0
....................                         } 
07B84:  GOTO    7B8A
....................                         else 
....................                         { 
....................                             handle++; 
07B88:  INC     0FE2
....................                         } 
....................                   #if defined(SUPPORT_LFN) 
....................                   tempCWD-> utf16LFNlength = 0; 
....................                   fo-> utf16LFNlength = 0; 
....................                   #endif 
....................                     } // Check to see if it's a DIR entry 
....................                 }// Check non-dir entry to see if its a valid file 
07B8A:  GOTO    7B90
....................                 else 
....................                 { 
....................                     handle++; 
07B8E:  INC     0FE2
....................                 } 
....................  
....................                 if (recache) 
07B90:  CP0.B   8BB
07B92:  BRA     Z,7BBA
....................                 { 
....................                     recache = FALSE; 
07B94:  CLR.B   8BB
....................                     cwdptr->dirccls = cwdptr->dirclus; 
07B96:  MOV     #32,W0
07B98:  ADD     95E,W0
07B9A:  MOV     W0,W5
07B9C:  MOV     #2E,W0
07B9E:  ADD     95E,W0
07BA0:  MOV     [W0++],[W5++]
07BA2:  MOV     [W0++],[W5++]
....................                     entry = Cache_File_Entry (cwdptr, &handle, TRUE); 
07BA4:  MOV.B   #1,W0L
07BA6:  MOV.B   W0L,1086
07BA8:  PUSH    95E
07BAA:  POP     1082
07BAC:  MOV     #FE2,W4
07BAE:  MOV     W4,1084
07BB0:  CALL    31E4
07BB4:  MOV     W0,FE0
....................                 } 
07BB6:  GOTO    7BCA
....................                 else 
....................                 { 
....................                     entry = Cache_File_Entry (cwdptr, &handle, FALSE); 
07BBA:  CLR.B   1086
07BBC:  PUSH    95E
07BBE:  POP     1082
07BC0:  MOV     #FE2,W4
07BC2:  MOV     W4,1084
07BC4:  CALL    31E4
07BC8:  MOV     W0,FE0
....................                 } 
....................  
....................             if (entry == NULL) 
07BCA:  CP0     FE0
07BCC:  BRA     NZ,7BE2
....................                 { 
....................                #if defined(SUPPORT_LFN) 
....................                tempCWD-> utf16LFNlength = 0; 
....................                fo-> utf16LFNlength = 0; 
....................                #endif 
....................                     FileObjectCopy (cwdptr, tempCWD); 
07BCE:  PUSH    95E
07BD0:  POP     105C
07BD2:  PUSH    FDC
07BD4:  POP     105E
07BD6:  CALL    28E2
....................                     FSerrno = CE_BADCACHEREAD; 
07BDA:  MOV.B   #1B,W0L
07BDC:  MOV.B   W0L,8B1
....................                     return -1; 
07BDE:  SETM    0
07BE0:  BRA     7EA0
....................                 } 
....................             } 
07BE2:  GOTO    7DD6
....................             else 
....................             { 
....................             #if defined(SUPPORT_LFN) 
....................             tempCWD-> utf16LFNlength = 0; 
....................             fo-> utf16LFNlength = 0; 
....................             #endif 
....................  
....................                 // We have reached the end of the directory 
....................                 if (subDirDepth != 0) 
07BE6:  CP0     FE6
07BE8:  BRA     Z,7DD2
....................                 { 
....................                     handle2 = 0; 
07BEA:  CLR     FE4
....................  
....................                     cwdptr->dirccls = cwdptr->dirclus; 
07BEC:  MOV     #32,W0
07BEE:  ADD     95E,W0
07BF0:  MOV     W0,W5
07BF2:  MOV     #2E,W0
07BF4:  ADD     95E,W0
07BF6:  MOV     [W0++],[W5++]
07BF8:  MOV     [W0++],[W5++]
....................                     entry = Cache_File_Entry (cwdptr, &handle2, TRUE); 
07BFA:  MOV.B   #1,W0L
07BFC:  MOV.B   W0L,1086
07BFE:  PUSH    95E
07C00:  POP     1082
07C02:  MOV     #FE4,W4
07C04:  MOV     W4,1084
07C06:  CALL    31E4
07C0A:  MOV     W0,FE0
....................                     if (entry == NULL) 
07C0C:  CP0     FE0
07C0E:  BRA     NZ,7C24
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
07C10:  PUSH    95E
07C12:  POP     105C
07C14:  PUSH    FDC
07C16:  POP     105E
07C18:  CALL    28E2
....................                         FSerrno = CE_BADCACHEREAD; 
07C1C:  MOV.B   #1B,W0L
07C1E:  MOV.B   W0L,8B1
....................                         return -1; 
07C20:  SETM    0
07C22:  BRA     7EA0
....................                     } 
....................  
....................                     // Get the cluster 
....................                     handle2 = GetFullClusterNumber(entry); // Get complete cluster number. 
07C24:  PUSH    FE0
07C26:  POP     1084
07C28:  CALL    34B4
07C2C:  MOV     W0,FE4
....................  
.................... #ifndef __18CXX 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................  
....................         Index3 = FSchdir (".\0.\0\0"); 
....................  
....................    else 
....................  
....................    #endif 
....................         Index3 = FSchdir (".."); 
07C2E:  MOV     #3,W3
07C30:  MOV     #0,W2
07C32:  MOV     #FFA,W1
07C34:  MOV     W3,[W15++]
07C36:  MOV     W2,W0
07C38:  CALL    200
07C3C:  MOV     [--W15],W3
07C3E:  MOV.B   W0L,[W1++]
07C40:  INC     W2,W2
07C42:  DEC     W3,W3
07C44:  BTSS.B  42.1
07C46:  BRA     7C34
07C48:  MOV     #FFA,W4
07C4A:  MOV     W4,1008
07C4C:  CALL    650A
07C50:  MOV     W0,FE8
....................  
.................... #else 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................  
....................         Index3 = FSchdir (dotdotname1); 
....................  
....................    else 
....................  
....................    #endif 
....................         Index3 = FSchdir (dotdotname); 
....................  
.................... #endif 
....................                     if(Index3) 
07C52:  CP0     FE8
07C54:  BRA     Z,7C6A
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
07C56:  PUSH    95E
07C58:  POP     105C
07C5A:  PUSH    FDC
07C5C:  POP     105E
07C5E:  CALL    28E2
....................                         FSerrno = CE_DIR_NOT_FOUND; 
07C62:  MOV.B   #C,W0L
07C64:  MOV.B   W0L,8B1
....................                         return -1; 
07C66:  SETM    0
07C68:  BRA     7EA0
....................                     } 
....................                     // Return to our previous position in this directory 
....................                     handle = 2; 
07C6A:  MOV     #2,W4
07C6C:  MOV     W4,FE2
....................                     cwdptr->dirccls = cwdptr->dirclus; 
07C6E:  MOV     #32,W0
07C70:  ADD     95E,W0
07C72:  MOV     W0,W5
07C74:  MOV     #2E,W0
07C76:  ADD     95E,W0
07C78:  MOV     [W0++],[W5++]
07C7A:  MOV     [W0++],[W5++]
....................                     entry = Cache_File_Entry (cwdptr, &handle, TRUE); 
07C7C:  MOV.B   #1,W0L
07C7E:  MOV.B   W0L,1086
07C80:  PUSH    95E
07C82:  POP     1082
07C84:  MOV     #FE2,W4
07C86:  MOV     W4,1084
07C88:  CALL    31E4
07C8C:  MOV     W0,FE0
....................                     if (entry == NULL) 
07C8E:  CP0     FE0
07C90:  BRA     NZ,7CA6
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
07C92:  PUSH    95E
07C94:  POP     105C
07C96:  PUSH    FDC
07C98:  POP     105E
07C9A:  CALL    28E2
....................                         FSerrno = CE_BADCACHEREAD; 
07C9E:  MOV.B   #1B,W0L
07CA0:  MOV.B   W0L,8B1
....................                         return -1; 
07CA2:  SETM    0
07CA4:  BRA     7EA0
....................                     } 
....................  
....................                     // Get the cluster 
....................                     TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number. 
07CA6:  PUSH    FE0
07CA8:  POP     1084
07CAA:  CALL    34B4
07CAE:  MOV     W0,8B6
07CB0:  MOV     W1,8B8
....................  
....................                     while ((TempClusterCalc != handle2) || 
....................                     ((TempClusterCalc == handle2) && 
....................                     (((unsigned char)entry->DIR_Name[0] == 0xE5) || (entry->DIR_Attr == ATTR_VOLUME)))) 
07CB2:  MOV     8B6,W0
07CB4:  CP      FE4
07CB6:  BRA     NZ,7CDA
07CB8:  CP0     8B8
07CBA:  BRA     NZ,7CDA
07CBC:  MOV     8B6,W0
07CBE:  CP      FE4
07CC0:  BRA     NZ,7D14
07CC2:  CP0     8B8
07CC4:  BRA     NZ,7D14
07CC6:  MOV     #0,W0
07CC8:  ADD     FE0,W0
07CCA:  MOV.B   [W0],W4L
07CCC:  XOR.B   #E5,W4L
07CCE:  BRA     Z,7CDA
07CD0:  MOV     #B,W0
07CD2:  ADD     FE0,W0
07CD4:  MOV.B   [W0],W4L
07CD6:  CP.B    W4L,#8
07CD8:  BRA     NZ,7D14
....................                     { 
....................                         handle++; 
07CDA:  INC     0FE2
....................                         entry = Cache_File_Entry (cwdptr, &handle, FALSE); 
07CDC:  CLR.B   1086
07CDE:  PUSH    95E
07CE0:  POP     1082
07CE2:  MOV     #FE2,W4
07CE4:  MOV     W4,1084
07CE6:  CALL    31E4
07CEA:  MOV     W0,FE0
....................                         if (entry == NULL) 
07CEC:  CP0     FE0
07CEE:  BRA     NZ,7D04
....................                         { 
....................                             FileObjectCopy (cwdptr, tempCWD); 
07CF0:  PUSH    95E
07CF2:  POP     105C
07CF4:  PUSH    FDC
07CF6:  POP     105E
07CF8:  CALL    28E2
....................                             FSerrno = CE_BADCACHEREAD; 
07CFC:  MOV.B   #1B,W0L
07CFE:  MOV.B   W0L,8B1
....................                             return -1; 
07D00:  SETM    0
07D02:  BRA     7EA0
....................                         } 
....................                         // Get the cluster 
....................                         TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number in a loop. 
07D04:  PUSH    FE0
07D06:  POP     1084
07D08:  CALL    34B4
07D0C:  MOV     W0,8B6
07D0E:  MOV     W1,8B8
07D10:  GOTO    7CB2
....................                     } 
....................  
....................                Index3 = 0; 
07D14:  CLR     FE8
....................                #if defined(SUPPORT_LFN) 
....................                  FileObjectCopy (&cwdTemp, cwdptr); 
....................                prevHandle = handle - 1; 
....................                lfno = (LFN_ENTRY *)Cache_File_Entry (cwdptr, &prevHandle, FALSE); 
....................  
....................  
....................                while((lfno->LFN_Attribute == ATTR_LONG_NAME) && (lfno->LFN_SequenceNo != DIR_DEL) 
....................                      && (lfno->LFN_SequenceNo != DIR_EMPTY)) 
....................                { 
....................                   tempShift.byte.LB = lfno->LFN_Part1[0]; 
....................                   tempShift.byte.HB = lfno->LFN_Part1[1]; 
....................                   tempLFN[Index3++] = tempShift.Val; 
....................                   tempShift.byte.LB = lfno->LFN_Part1[2]; 
....................                   tempShift.byte.HB = lfno->LFN_Part1[3]; 
....................                   tempLFN[Index3++] = tempShift.Val; 
....................                   tempShift.byte.LB = lfno->LFN_Part1[4]; 
....................                   tempShift.byte.HB = lfno->LFN_Part1[5]; 
....................                   tempLFN[Index3++] = tempShift.Val; 
....................                   tempShift.byte.LB = lfno->LFN_Part1[6]; 
....................                   tempShift.byte.HB = lfno->LFN_Part1[7]; 
....................                   tempLFN[Index3++] = tempShift.Val; 
....................                   tempShift.byte.LB = lfno->LFN_Part1[8]; 
....................                   tempShift.byte.HB = lfno->LFN_Part1[9]; 
....................                   tempLFN[Index3++] = tempShift.Val; 
....................  
....................                   tempLFN[Index3++] = lfno->LFN_Part2[0]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part2[1]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part2[2]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part2[3]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part2[4]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part2[5]; 
....................  
....................                   tempLFN[Index3++] = lfno->LFN_Part3[0]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part3[1]; 
....................  
....................                   prevHandle = prevHandle - 1; 
....................                   lfno = (LFN_ENTRY *)Cache_File_Entry (cwdptr, &prevHandle, FALSE); 
....................                } 
....................  
....................                FileObjectCopy (cwdptr, &cwdTemp); 
....................  
....................                #endif 
....................  
....................                if(Index3 == 0) 
07D16:  CP0     FE8
07D18:  BRA     NZ,7D6E
....................                { 
....................                        memset (tempArray, 0x00, 12); 
07D1A:  MOV     #FEC,W1
07D1C:  MOV     #0,W2
07D1E:  REPEAT  #B
07D20:  CLR.B   [W1++]
....................                        for (Index = 0; Index < 8; Index++) 
07D22:  CLR.B   FEA
07D24:  MOV.B   FEA,W0L
07D26:  SE      W0,W0
07D28:  CP      W0,#8
07D2A:  BRA     GE,7D44
....................                        { 
....................                            tempArray[(BYTE)Index] = entry->DIR_Name[(BYTE)Index]; 
07D2C:  MOV     FEA,W4
07D2E:  CLR.B   9
07D30:  MOV     #FEC,W3
07D32:  ADD     W4,W3,W5
07D34:  MOV     FEA,W4
07D36:  CLR.B   9
07D38:  MOV     W4,W0
07D3A:  ADD     FE0,W0
07D3C:  MOV.B   [W0],[W5]
07D3E:  INC.B   0FEA
07D40:  GOTO    7D24
....................                        } 
....................                        for (Index = 0; Index < 3; Index++) 
07D44:  CLR.B   FEA
07D46:  MOV.B   FEA,W0L
07D48:  SE      W0,W0
07D4A:  CP      W0,#3
07D4C:  BRA     GE,7D6E
....................                        { 
....................                            tempArray[(BYTE)Index + 8] = entry->DIR_Extension[(BYTE)Index]; 
07D4E:  MOV     FEA,W4
07D50:  CLR.B   9
07D52:  ADD     W4,#8,W4
07D54:  MOV     W4,W5
07D56:  MOV     #FEC,W4
07D58:  ADD     W5,W4,W6
07D5A:  MOV     #8,W0
07D5C:  ADD.B   FEA,W0L
07D5E:  ZE      W0,W0
07D60:  CLR.B   1
07D62:  MOV     FE0,W4
07D64:  ADD     W0,W4,W0
07D66:  MOV.B   [W0],[W6]
....................                        } 
....................                   #if defined(SUPPORT_LFN) 
07D68:  INC.B   0FEA
07D6A:  GOTO    7D46
....................                   cwdptr->utf16LFNlength = 0; 
....................                   #endif 
....................                } 
....................                #if defined(SUPPORT_LFN) 
....................                else 
....................                { 
....................                   cwdptr->utf16LFNlength = Index3; 
....................  
....................                   for(Index = 12;Index >= 0;Index--) 
....................                   { 
....................                      if((tempLFN[Index3 - Index - 1]) == 0x0000) 
....................                      { 
....................                         cwdptr->utf16LFNlength = Index3 - Index - 1; 
....................                         break; 
....................                      } 
....................                   } 
....................  
....................                   cwdptr->utf16LFNptr = (unsigned short int *)&tempArray[0]; 
....................                } 
....................                #endif 
....................                     // Erase the directory that we just cleared the subdirectories out of 
....................  
....................                     if (eraseDir (&tempArray[0])) 
07D6E:  MOV     #FEC,W4
07D70:  MOV     W4,1008
07D72:  CALL    7734
07D76:  CP0     W0
07D78:  BRA     Z,7D92
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
07D7A:  PUSH    95E
07D7C:  POP     105C
07D7E:  PUSH    FDC
07D80:  POP     105E
07D82:  CALL    28E2
....................                         FSerrno = CE_ERASE_FAIL; 
07D86:  MOV.B   #1,W0L
07D88:  MOV.B   W0L,8B1
....................                         return -1; 
07D8A:  SETM    0
07D8C:  BRA     7EA0
....................                     } 
07D8E:  GOTO    7DCC
....................                     else 
....................                     { 
....................                         handle++; 
07D92:  INC     0FE2
....................                         cwdptr->dirccls = cwdptr->dirclus; 
07D94:  MOV     #32,W0
07D96:  ADD     95E,W0
07D98:  MOV     W0,W5
07D9A:  MOV     #2E,W0
07D9C:  ADD     95E,W0
07D9E:  MOV     [W0++],[W5++]
07DA0:  MOV     [W0++],[W5++]
....................                         entry = Cache_File_Entry (cwdptr, &handle, TRUE); 
07DA2:  MOV.B   #1,W0L
07DA4:  MOV.B   W0L,1086
07DA6:  PUSH    95E
07DA8:  POP     1082
07DAA:  MOV     #FE2,W4
07DAC:  MOV     W4,1084
07DAE:  CALL    31E4
07DB2:  MOV     W0,FE0
....................                         if (entry == NULL) 
07DB4:  CP0     FE0
07DB6:  BRA     NZ,7DCC
....................                         { 
....................                             FileObjectCopy (cwdptr, tempCWD); 
07DB8:  PUSH    95E
07DBA:  POP     105C
07DBC:  PUSH    FDC
07DBE:  POP     105E
07DC0:  CALL    28E2
....................                             FSerrno = CE_BADCACHEREAD; 
07DC4:  MOV.B   #1B,W0L
07DC6:  MOV.B   W0L,8B1
....................                             return -1; 
07DC8:  SETM    0
07DCA:  BRA     7EA0
....................                         } 
....................                     } 
....................  
....................                     // Decrease the subdirectory depth 
....................                     subDirDepth--; 
07DCC:  DEC     0FE6
....................                 } 
07DCE:  GOTO    7DD6
....................                 else 
....................                 { 
....................                     dirCleared = TRUE; 
07DD2:  MOV.B   #1,W0L
07DD4:  MOV.B   W0L,8BA
....................                 } // Check subdirectory depth 
....................             } // Check until we get an empty entry 
07DD6:  GOTO    7954
....................         } // Loop until the whole dir is cleared 
....................     } 
....................  
....................     // Cache the current directory name 
....................     // tempArray is used so we don't disturb the 
....................     // global getcwd buffer 
....................     if (FSgetcwd (&tempArray[0], 2) == NULL) 
07DDA:  MOV     #FEC,W4
07DDC:  MOV     W4,1010
07DDE:  MOV     #2,W4
07DE0:  MOV     W4,1012
07DE2:  CALL    55BA
07DE6:  MOV     W0,W5
07DE8:  CP0     W5
07DEA:  BRA     NZ,7E00
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
07DEC:  PUSH    95E
07DEE:  POP     105C
07DF0:  PUSH    FDC
07DF2:  POP     105E
07DF4:  CALL    28E2
....................         return -1; 
07DF8:  SETM    0
07DFA:  BRA     7EA0
....................     } 
07DFC:  GOTO    7E2E
....................    else 
....................    { 
....................       #if defined(SUPPORT_LFN) 
....................          if(!cwdptr->utf16LFNlength) 
....................       #endif 
....................          { 
....................               memset (tempArray, 0x00, 12); 
07E00:  MOV     #FEC,W1
07E02:  MOV     #0,W2
07E04:  REPEAT  #B
07E06:  CLR.B   [W1++]
....................               for (Index = 0; Index < 11; Index++) 
07E08:  CLR.B   FEA
07E0A:  MOV.B   FEA,W0L
07E0C:  SE      W0,W0
07E0E:  CP      W0,#B
07E10:  BRA     GE,7E2E
....................               { 
....................                   tempArray[(BYTE)Index] = cwdptr->name[(BYTE)Index]; 
07E12:  MOV     FEA,W4
07E14:  CLR.B   9
07E16:  MOV     #FEC,W3
07E18:  ADD     W4,W3,W5
07E1A:  MOV     #1C,W0
07E1C:  ADD.B   FEA,W0L
07E1E:  ZE      W0,W0
07E20:  CLR.B   1
07E22:  MOV     95E,W4
07E24:  ADD     W0,W4,W0
07E26:  MOV.B   [W0],[W5]
07E28:  INC.B   0FEA
07E2A:  GOTO    7E0A
....................               } 
....................          } 
....................    } 
....................  
....................     // If we're here, this directory is empty 
.................... #ifndef __18CXX 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................  
....................         Index3 = FSchdir (".\0.\0\0"); 
....................  
....................    else 
....................  
....................    #endif 
....................         Index3 = FSchdir (".."); 
07E2E:  MOV     #3,W3
07E30:  MOV     #0,W2
07E32:  MOV     #FFE,W1
07E34:  MOV     W3,[W15++]
07E36:  MOV     W2,W0
07E38:  CALL    200
07E3C:  MOV     [--W15],W3
07E3E:  MOV.B   W0L,[W1++]
07E40:  INC     W2,W2
07E42:  DEC     W3,W3
07E44:  BTSS.B  42.1
07E46:  BRA     7E34
07E48:  MOV     #FFE,W4
07E4A:  MOV     W4,1008
07E4C:  CALL    650A
07E50:  MOV     W0,FE8
....................  
.................... #else 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................  
....................         Index3 = FSchdir (dotdotname1); 
....................  
....................    else 
....................  
....................    #endif 
....................         Index3 = FSchdir (dotdotname); 
....................  
.................... #endif 
....................     if(Index3) 
07E52:  CP0     FE8
07E54:  BRA     Z,7E6A
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
07E56:  PUSH    95E
07E58:  POP     105C
07E5A:  PUSH    FDC
07E5C:  POP     105E
07E5E:  CALL    28E2
....................         FSerrno = CE_DIR_NOT_FOUND; 
07E62:  MOV.B   #C,W0L
07E64:  MOV.B   W0L,8B1
....................         return -1; 
07E66:  SETM    0
07E68:  BRA     7EA0
....................     } 
....................  
....................    #if defined(SUPPORT_LFN) 
....................    if(cwdptr->utf16LFNlength) 
....................    { 
....................       Index3 = eraseDir((char *)cwdptr->utf16LFNptr); 
....................    } 
....................    else 
....................    #endif 
....................    { 
....................       Index3 = eraseDir(tempArray); 
07E6A:  MOV     #FEC,W4
07E6C:  MOV     W4,1008
07E6E:  CALL    7734
07E72:  MOV     W0,FE8
....................    } 
....................  
....................     if (Index3) 
07E74:  CP0     FE8
07E76:  BRA     Z,7E90
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
07E78:  PUSH    95E
07E7A:  POP     105C
07E7C:  PUSH    FDC
07E7E:  POP     105E
07E80:  CALL    28E2
....................         FSerrno = CE_ERASE_FAIL; 
07E84:  MOV.B   #1,W0L
07E86:  MOV.B   W0L,8B1
....................         return -1; 
07E88:  SETM    0
07E8A:  BRA     7EA0
....................     } 
07E8C:  GOTO    7EA0
....................     else 
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
07E90:  PUSH    95E
07E92:  POP     105C
07E94:  PUSH    FDC
07E96:  POP     105E
07E98:  CALL    28E2
....................         return 0; 
07E9C:  CLR     0
07E9E:  BRA     7EA0
....................     } 
07EA0:  MOV     [--W15],W6
07EA2:  MOV     [--W15],W5
07EA4:  RETURN  
.................... } 
....................  
....................  
.................... /**************************************************************** 
....................   Function: 
....................     int eraseDir (char * path) 
....................   Summary: 
....................     FSrmdir helper function to erase dirs 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     path -  The name of the directory to delete 
....................   Return Values: 
....................     0 -  Dir was deleted successfully 
....................     -1 - Dir could not be deleted. 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The eraseDir function is a helper function for the rmdirhelper 
....................     function.  The eraseDir function will search for the 
....................     directory that matches the specified path name and then erase 
....................     it with the FILEerase function. 
....................   Remarks: 
....................     None. 
....................   *****************************************************************/ 
....................  
.................... int eraseDir (char * path) 
*
07734:  MOV     W5,[W15++]
.................... { 
....................     int result; 
07736:  CLR     100A
....................     BYTE Index; 
07738:  CLR.B   100C
....................     FSFILE tempCWDobj2; 
0773A:  CLR     100E
0773C:  CLR     1010
0773E:  CLR     1012
07740:  CLR     1014
07742:  CLR     1016
07744:  CLR     1018
07746:  CLR     101A
07748:  CLR     101C
0774A:  CLR     101E
0774C:  CLR     1020
0774E:  CLR     1022
07750:  CLR     1024
07752:  CLR     1026
07754:  CLR     1028
07756:  CLR     102A
07758:  CLR     102C
0775A:  CLR     102E
0775C:  CLR     1030
0775E:  CLR     1032
07760:  CLR     1034
07762:  CLR     1036
07764:  CLR     1038
07766:  CLR     103A
07768:  CLR     103C
0776A:  CLR     103E
0776C:  CLR     1040
0776E:  CLR     1042
....................  
....................     if (MDD_WriteProtectState()) 
07770:  CALL    25A0
07774:  CP0.B   W0L
07776:  BRA     Z,777C
....................     { 
....................         return (-1); 
07778:  SETM    0
0777A:  BRA     7804
....................     } 
....................  
....................     // preserve CWD 
....................     FileObjectCopy(&tempCWDobj2, cwdptr); 
0777C:  MOV     #100E,W4
0777E:  MOV     W4,105C
07780:  PUSH    95E
07782:  POP     105E
07784:  CALL    28E2
....................  
....................    // If long file name not present, copy the 8.3 name in cwdptr 
....................    #if defined(SUPPORT_LFN) 
....................     if(!cwdptr->utf16LFNlength) 
....................    #endif 
....................     { 
....................        for (Index = 0; Index <11; Index++) 
07788:  CLR.B   100C
0778A:  MOV     100C,W4
0778C:  CP.B    W4L,#B
0778E:  BRA     C,77AC
....................        { 
....................            cwdptr->name[Index] = *(path + Index); 
07790:  MOV     #1C,W0
07792:  ADD.B   100C,W0L
07794:  ZE      W0,W0
07796:  CLR.B   1
07798:  MOV     95E,W4
0779A:  ADD     W0,W4,W5
0779C:  MOV     100C,W4
0779E:  CLR.B   9
077A0:  MOV     1008,W3
077A2:  ADD     W3,W4,W0
077A4:  MOV.B   [W0],[W5]
077A6:  INC.B   100C
077A8:  GOTO    778A
....................        } 
....................    } 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&gFileTemp, cwdptr); 
077AC:  MOV     #8F2,W4
077AE:  MOV     W4,105C
077B0:  PUSH    95E
077B2:  POP     105E
077B4:  CALL    28E2
....................  
....................     // See if the file is found 
....................    if(FILEfind (cwdptr, &gFileTemp, LOOK_FOR_MATCHING_ENTRY, 0) == CE_GOOD) 
077B8:  MOV.B   #1,W0L
077BA:  MOV.B   W0L,1060
077BC:  CLR.B   1061
077BE:  PUSH    95E
077C0:  POP     105C
077C2:  MOV     #8F2,W4
077C4:  MOV     W4,105E
077C6:  CALL    36BE
077CA:  CP0.B   W0L
077CC:  BRA     NZ,77F2
....................    { 
....................       if(FILEerase(cwdptr, &cwdptr->entry, TRUE) == CE_GOOD) 
077CE:  MOV     #28,W0
077D0:  ADD     95E,W0
077D2:  MOV     W0,W5
077D4:  MOV.B   #1,W0L
077D6:  MOV.B   W0L,104E
077D8:  PUSH    95E
077DA:  POP     104A
077DC:  MOV     W5,104C
077DE:  CALL    3BA8
077E2:  CP0.B   W0L
077E4:  BRA     NZ,77EC
....................          result = 0; 
077E6:  CLR     100A
077E8:  GOTO    77EE
....................       else 
....................          result = -1; 
077EC:  SETM    100A
....................    } 
077EE:  GOTO    77F4
....................    else 
....................       result = -1; 
077F2:  SETM    100A
....................  
....................    FileObjectCopy(cwdptr, &tempCWDobj2); 
077F4:  PUSH    95E
077F6:  POP     105C
077F8:  MOV     #100E,W4
077FA:  MOV     W4,105E
077FC:  CALL    28E2
....................    return(result); 
07800:  PUSH    100A
07802:  POP     0
07804:  MOV     [--W15],W5
07806:  RETURN  
.................... } 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_FILESEARCH 
....................  
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................     The FindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the 
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was 
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec) 
*
0655E:  MOV     W5,[W15++]
06560:  MOV     W6,[W15++]
06562:  MOV     W7,[W15++]
*
0659A:  MOV     #1018,W4
0659C:  MOV     W4,104E
.................... { 
....................     FSFILE f; 
*
06564:  CLR     1018
06566:  CLR     101A
06568:  CLR     101C
0656A:  CLR     101E
0656C:  CLR     1020
0656E:  CLR     1022
06570:  CLR     1024
06572:  CLR     1026
06574:  CLR     1028
06576:  CLR     102A
06578:  CLR     102C
0657A:  CLR     102E
0657C:  CLR     1030
0657E:  CLR     1032
06580:  CLR     1034
06582:  CLR     1036
06584:  CLR     1038
06586:  CLR     103A
06588:  CLR     103C
0658A:  CLR     103E
0658C:  CLR     1040
0658E:  CLR     1042
06590:  CLR     1044
06592:  CLR     1046
06594:  CLR     1048
06596:  CLR     104A
06598:  CLR     104C
....................     FILEOBJ fo = &f; 
....................     WORD fHandle; 
*
0659E:  CLR     1050
....................     BYTE j; 
065A0:  CLR.B   1052
....................     BYTE Index; 
065A2:  CLR.B   1053
....................    #ifdef SUPPORT_LFN 
....................       short int indexLFN; 
....................    #endif 
....................  
....................     FSerrno = CE_GOOD; 
065A4:  CLR.B   8B1
....................  
....................    #ifdef SUPPORT_LFN 
....................       fo->utf16LFNptr = &recordSearchName[0]; 
....................       rec->utf16LFNfound = &recordFoundName[0]; 
....................    #endif 
....................  
....................    // Format the file name as per 8.3 format or LFN format 
....................     if( !FormatFileName(fileName, fo, 1) ) 
065A6:  MOV.B   #1,W0L
065A8:  MOV.B   W0L,105E
065AA:  PUSH    1012
065AC:  POP     105A
065AE:  PUSH    104E
065B0:  POP     105C
065B2:  CALL    26EC
065B6:  CP0.B   W0L
065B8:  BRA     NZ,65C2
....................     { 
....................         FSerrno = CE_INVALID_FILENAME; 
065BA:  MOV.B   #12,W0L
065BC:  MOV.B   W0L,8B1
....................         return -1; 
065BE:  SETM    0
065C0:  BRA     6838
....................     } 
....................  
....................     rec->initialized = FALSE; 
065C2:  MOV     #2A,W0
065C4:  ADD     1016,W0
065C6:  MOV     W0,W5
065C8:  CLR.B   [W5]
....................  
....................    #if defined(SUPPORT_LFN) 
....................    rec->AsciiEncodingType = fo->AsciiEncodingType; 
....................    recordSearchLength = fo->utf16LFNlength; 
....................  
....................    // If file name is 8.3 format copy it in 'searchname' string 
....................     if(!recordSearchLength) 
....................    #endif 
....................     { 
....................        for (Index = 0; (Index < 12) && (fileName[Index] != 0); Index++) 
065CA:  CLR.B   1053
065CC:  MOV     1052,W4
065CE:  LSR     W4,#8,W4
065D0:  CP.B    W4L,#C
065D2:  BRA     C,6600
065D4:  MOV     1052,W4
065D6:  LSR     W4,#8,W4
065D8:  MOV     W4,W0
065DA:  ADD     1012,W0
065DC:  MOV.B   [W0],W5L
065DE:  SE      W5,W5
065E0:  CP0     W5
065E2:  BRA     Z,6600
....................        { 
....................            rec->searchname[Index] = fileName[Index]; 
065E4:  MOV     #18,W0
065E6:  ADD.B   1053,W0L
065E8:  ZE      W0,W0
065EA:  CLR.B   1
065EC:  MOV     1016,W4
065EE:  ADD     W0,W4,W5
065F0:  MOV     1052,W4
065F2:  LSR     W4,#8,W4
065F4:  MOV     W4,W0
065F6:  ADD     1012,W0
065F8:  MOV.B   [W0],[W5]
065FA:  INC.B   1053
065FC:  GOTO    65CC
....................        } 
....................  
....................        for (;Index < FILE_NAME_SIZE_8P3 + 2; Index++) 
06600:  MOV     1052,W4
06602:  LSR     W4,#8,W4
06604:  CP.B    W4L,#D
06606:  BRA     C,661C
....................        { 
....................            rec->searchname[Index] = 0; 
06608:  MOV     #18,W0
0660A:  ADD.B   1053,W0L
0660C:  ZE      W0,W0
0660E:  CLR.B   1
06610:  MOV     1016,W4
06612:  ADD     W0,W4,W5
06614:  CLR.B   [W5]
06616:  INC.B   1053
06618:  GOTO    6600
....................        } 
....................    } 
....................  
....................     rec->searchattr = attr; 
0661C:  MOV     #25,W0
0661E:  ADD     1016,W0
06620:  MOV     W0,W5
06622:  MOV     1014,W0
06624:  MOV.B   W0L,[W5+#0]
.................... #ifdef ALLOW_DIRS 
....................     rec->cwdclus = cwdptr->dirclus; 
06626:  MOV     #26,W0
06628:  ADD     1016,W0
0662A:  MOV     W0,W5
0662C:  MOV     #2E,W0
0662E:  ADD     95E,W0
06630:  MOV     [W0++],[W5++]
06632:  MOV     [W0++],[W5++]
.................... #else 
....................     rec->cwdclus = FatRootDirClusterValue; 
.................... #endif 
....................  
....................     fo->dsk = &gDiskData; 
06634:  MOV     104E,W4
06636:  ADD     W4,#0,W4
06638:  MOV     W4,W0
0663A:  MOV     W0,W5
0663C:  MOV.B   #60,W0L
0663E:  MOV.B   W0L,[W5]
06640:  MOV.B   #D,W0L
06642:  MOV.B   W0L,[W5+#1]
....................     fo->cluster = 0; 
06644:  MOV     #2,W0
06646:  ADD     104E,W0
06648:  MOV     W0,W5
0664A:  CLR.B   [W5]
0664C:  MOV.B   #0,W0L
0664E:  MOV.B   W0L,[W5+#1]
06650:  MOV.B   #0,W0L
06652:  MOV.B   W0L,[W5+#2]
06654:  MOV.B   #0,W0L
06656:  MOV.B   W0L,[W5+#3]
....................     fo->ccls    = 0; 
06658:  MOV     #6,W0
0665A:  ADD     104E,W0
0665C:  MOV     W0,W5
0665E:  CLR.B   [W5]
06660:  MOV.B   #0,W0L
06662:  MOV.B   W0L,[W5+#1]
06664:  MOV.B   #0,W0L
06666:  MOV.B   W0L,[W5+#2]
06668:  MOV.B   #0,W0L
0666A:  MOV.B   W0L,[W5+#3]
....................     fo->entry = 0; 
0666C:  MOV     #28,W0
0666E:  ADD     104E,W0
06670:  MOV     W0,W5
06672:  CLR.B   [W5]
06674:  MOV.B   #0,W0L
06676:  MOV.B   W0L,[W5+#1]
....................     fo->attributes = attr; 
06678:  MOV     #2C,W0
0667A:  ADD     104E,W0
0667C:  MOV     W0,W5
0667E:  MOV     1014,W4
06680:  MOV     W4,[W5+#0]
....................  
.................... #ifndef ALLOW_DIRS 
....................     // start at the root directory 
....................     fo->dirclus    = FatRootDirClusterValue; 
....................     fo->dirccls    = FatRootDirClusterValue; 
.................... #else 
....................     fo->dirclus = cwdptr->dirclus; 
06682:  MOV     #2E,W0
06684:  ADD     104E,W0
06686:  MOV     W0,W5
06688:  MOV     #2E,W0
0668A:  ADD     95E,W0
0668C:  MOV     [W0++],[W5++]
0668E:  MOV     [W0++],[W5++]
....................     fo->dirccls = cwdptr->dirccls; 
06690:  MOV     #32,W0
06692:  ADD     104E,W0
06694:  MOV     W0,W5
06696:  MOV     #32,W0
06698:  ADD     95E,W0
0669A:  MOV     [W0++],[W5++]
0669C:  MOV     [W0++],[W5++]
.................... #endif 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&gFileTemp, fo); 
0669E:  MOV     #8F2,W4
066A0:  MOV     W4,105C
066A2:  PUSH    104E
066A4:  POP     105E
066A6:  CALL    28E2
....................  
....................     // See if the file is found 
....................     if (FILEfind (fo, &gFileTemp,LOOK_FOR_MATCHING_ENTRY, 1) != CE_GOOD) 
066AA:  MOV.B   #1,W0L
066AC:  MOV.B   W0L,1060
066AE:  MOV.B   #1,W0L
066B0:  MOV.B   W0L,1061
066B2:  PUSH    104E
066B4:  POP     105C
066B6:  MOV     #8F2,W4
066B8:  MOV     W4,105E
066BA:  CALL    36BE
066BE:  CP0.B   W0L
066C0:  BRA     Z,66CA
....................     { 
....................         FSerrno = CE_FILE_NOT_FOUND; 
066C2:  MOV.B   #B,W0L
066C4:  MOV.B   W0L,8B1
....................         return -1; 
066C6:  SETM    0
066C8:  BRA     6838
....................     } 
....................  
....................     fHandle = fo->entry; 
066CA:  MOV     #28,W0
066CC:  ADD     104E,W0
066CE:  MOV     [W0],[W15++]
066D0:  POP     1050
....................  
....................     if (FILEopen (fo, &fHandle, 'r') == CE_GOOD) 
066D2:  MOV.B   #72,W0L
066D4:  MOV.B   W0L,105E
066D6:  PUSH    104E
066D8:  POP     105A
066DA:  MOV     #1050,W4
066DC:  MOV     W4,105C
066DE:  CALL    4454
066E2:  CP0.B   W0L
066E4:  BRA     NZ,6830
....................     { 
....................       #if defined(SUPPORT_LFN) 
....................       rec->utf16LFNfoundLength = fo->utf16LFNlength; 
....................       if(fo->utf16LFNlength) 
....................       { 
....................          indexLFN = fo->utf16LFNlength; 
....................          recordFoundName[indexLFN] = 0x0000; 
....................          while(indexLFN--) 
....................             recordFoundName[indexLFN] = fileFoundString[indexLFN]; 
....................       } 
....................       #endif 
....................  
....................       for(j = 0; j < FILE_NAME_SIZE_8P3 + 2 ; j++) 
066E6:  CLR.B   1052
066E8:  MOV     1052,W4
066EA:  CP.B    W4L,#D
066EC:  BRA     C,6700
....................       { 
....................             rec->filename[j] = 0; 
066EE:  MOV     1052,W4
066F0:  CLR.B   9
066F2:  MOV     W4,W0
066F4:  ADD     1016,W0
066F6:  MOV     W0,W5
066F8:  CLR.B   [W5]
066FA:  INC.B   1052
066FC:  GOTO    66E8
....................       } 
....................  
....................         // Copy as much name as there is 
....................         if (fo->attributes != ATTR_VOLUME) 
06700:  MOV     #2C,W0
06702:  ADD     104E,W0
06704:  MOV     [W0],W5
06706:  CP      W5,#8
06708:  BRA     Z,67B0
....................         { 
....................             for (Index = 0, j = 0; (j < 8) && (fo->name[j] != 0x20); Index++, j++) 
0670A:  CLR.B   1053
0670C:  CLR.B   1052
0670E:  MOV     1052,W4
06710:  CP.B    W4L,#8
06712:  BRA     C,674C
06714:  MOV     #1C,W0
06716:  ADD.B   1052,W0L
06718:  ZE      W0,W0
0671A:  CLR.B   1
0671C:  MOV     104E,W4
0671E:  ADD     W0,W4,W0
06720:  MOV.B   [W0],W5L
06722:  SE      W5,W5
06724:  MOV     #20,W4
06726:  CP      W4,W5
06728:  BRA     Z,674C
....................             { 
....................                rec->filename[Index] = fo->name[j]; 
0672A:  MOV     1052,W4
0672C:  LSR     W4,#8,W4
0672E:  MOV     W4,W0
06730:  ADD     1016,W0
06732:  MOV     W0,W5
06734:  MOV     #1C,W0
06736:  ADD.B   1052,W0L
06738:  ZE      W0,W0
0673A:  CLR.B   1
0673C:  MOV     104E,W4
0673E:  ADD     W0,W4,W0
06740:  MOV.B   [W0],[W5]
06742:  MOV.B   1053,W0L
06744:  INC.B   1053
06746:  INC.B   1052
06748:  GOTO    670E
....................             } 
....................  
....................          if(fo->name[8] != 0x20) 
0674C:  MOV     #24,W0
0674E:  ADD     104E,W0
06750:  MOV.B   [W0],W5L
06752:  SE      W5,W5
06754:  MOV     #20,W4
06756:  CP      W4,W5
06758:  BRA     Z,67AC
....................          { 
....................                rec->filename[Index++] = '.'; 
0675A:  MOV.B   1053,W0L
0675C:  INC.B   1053
0675E:  ZE      W0,W0
06760:  CLR.B   1
06762:  MOV     1016,W4
06764:  ADD     W0,W4,W5
06766:  MOV.B   #2E,W0L
06768:  MOV.B   W0L,[W5]
....................  
....................                // Move to the extension, even if there are more space chars 
....................                for (j = 8; (j < 11) && (fo->name[j] != 0x20); Index++, j++) 
0676A:  MOV.B   #8,W0L
0676C:  MOV.B   W0L,1052
0676E:  MOV     1052,W4
06770:  CP.B    W4L,#B
06772:  BRA     C,67AC
06774:  MOV     #1C,W0
06776:  ADD.B   1052,W0L
06778:  ZE      W0,W0
0677A:  CLR.B   1
0677C:  MOV     104E,W4
0677E:  ADD     W0,W4,W0
06780:  MOV.B   [W0],W5L
06782:  SE      W5,W5
06784:  MOV     #20,W4
06786:  CP      W4,W5
06788:  BRA     Z,67AC
....................                { 
....................                   rec->filename[Index] = fo->name[j]; 
0678A:  MOV     1052,W4
0678C:  LSR     W4,#8,W4
0678E:  MOV     W4,W0
06790:  ADD     1016,W0
06792:  MOV     W0,W5
06794:  MOV     #1C,W0
06796:  ADD.B   1052,W0L
06798:  ZE      W0,W0
0679A:  CLR.B   1
0679C:  MOV     104E,W4
0679E:  ADD     W0,W4,W0
067A0:  MOV.B   [W0],[W5]
067A2:  MOV.B   1053,W0L
067A4:  INC.B   1053
067A6:  INC.B   1052
067A8:  GOTO    676E
....................                } 
....................          } 
....................         } 
067AC:  GOTO    67D8
....................         else 
....................         { 
....................             for (Index = 0; Index < DIR_NAMECOMP; Index++) 
067B0:  CLR.B   1053
067B2:  MOV     1052,W4
067B4:  LSR     W4,#8,W4
067B6:  CP.B    W4L,#B
067B8:  BRA     C,67D8
....................             { 
....................                 rec->filename[Index] = fo->name[Index]; 
067BA:  MOV     1052,W4
067BC:  LSR     W4,#8,W4
067BE:  MOV     W4,W0
067C0:  ADD     1016,W0
067C2:  MOV     W0,W5
067C4:  MOV     #1C,W0
067C6:  ADD.B   1053,W0L
067C8:  ZE      W0,W0
067CA:  CLR.B   1
067CC:  MOV     104E,W4
067CE:  ADD     W0,W4,W0
067D0:  MOV.B   [W0],[W5]
067D2:  INC.B   1053
067D4:  GOTO    67B2
....................             } 
....................         } 
....................  
....................         rec->attributes = fo->attributes; 
067D8:  MOV     #D,W0
067DA:  ADD     1016,W0
067DC:  MOV     W0,W5
067DE:  MOV     #2C,W0
067E0:  ADD     104E,W0
067E2:  MOV.B   [W0],[W5]
....................         rec->filesize = fo->size; 
067E4:  MOV     #E,W0
067E6:  ADD     1016,W0
067E8:  MOV     W0,W5
067EA:  MOV     #12,W0
067EC:  ADD     104E,W0
067EE:  MOV     [W0++],[W5++]
067F0:  MOV     [W0++],[W5++]
....................         rec->timestamp = (DWORD)((DWORD)fo->date << 16) + fo->time; 
067F2:  MOV     #12,W0
067F4:  ADD     1016,W0
067F6:  MOV     W0,W5
067F8:  MOV     #1A,W0
067FA:  ADD     104E,W0
067FC:  MOV     [W0],W6
067FE:  MOV     #0,W7
06800:  MOV     W6,W7
06802:  MOV     #0,W6
06804:  MOV     #18,W0
06806:  ADD     104E,W0
06808:  MOV     W0,W4
0680A:  MOV     [W4],W0
0680C:  ADD     W0,W6,[W5]
0680E:  MOV     #0,W4
06810:  ADDC    W4,W7,[++W5]
....................         rec->entry = fo->entry; 
06812:  MOV     #16,W0
06814:  ADD     1016,W0
06816:  MOV     W0,W5
06818:  MOV     #28,W0
0681A:  ADD     104E,W0
0681C:  MOV     [W0],[W5]
....................         rec->initialized = TRUE; 
0681E:  MOV     #2A,W0
06820:  ADD     1016,W0
06822:  MOV     W0,W5
06824:  MOV.B   #1,W0L
06826:  MOV.B   W0L,[W5]
....................  
....................  
....................        #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" FINDFirst foCompareTo="); 
....................          PrintRAMBytesUART(((unsigned char*)fo->name), 13); 
....................          PrintROMASCIIStringUART(" FINDFirst recSearchname="); 
....................          PrintRAMBytesUART(((unsigned char*)rec->searchname), 13);          
....................          PrintROMASCIIStringUART(" FINDFirst gTempCompareTo="); 
....................          PrintRAMBytesUART(((unsigned char*)gFileTemp.name), 13); 
....................         #endif 
....................  
....................         return 0; 
06828:  CLR     0
0682A:  BRA     6838
....................     } 
0682C:  GOTO    6838
....................     else 
....................     { 
....................         FSerrno = CE_BADCACHEREAD; 
06830:  MOV.B   #1B,W0L
06832:  MOV.B   W0L,8B1
....................         return -1; 
06834:  SETM    0
06836:  BRA     6838
....................     } 
06838:  MOV     [--W15],W7
0683A:  MOV     [--W15],W6
0683C:  MOV     [--W15],W5
0683E:  RETURN  
.................... } 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FindNext (SearchRec * rec) 
....................   Summary: 
....................     Sequential search function 
....................   Conditions: 
....................     None 
....................   Input: 
....................     rec -  The structure to store the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No additional files matching the specified criteria were found 
....................   Side Effects: 
....................     Search criteria from previous FindNext call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     The FindNext function performs the same function as the FindFirst 
....................     funciton, except it does not copy any search parameters into the 
....................     SearchRec structure (only info about found files) and it begins 
....................     searching at the last directory entry offset at which a file was 
....................     found, rather than at the beginning of the current working 
....................     directory.If the return value of the function is 0 then "utf16LFNfoundLength" 
....................     indicates whether the file found was long file name or short file 
....................     name(8P3 format). The "utf16LFNfoundLength" is non-zero for long file name 
....................     and is zero for 8P3 format."utf16LFNfound" points to the address of long 
....................     file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling this function 
....................   **********************************************************************/ 
....................  
.................... int FindNext (SearchRec * rec) 
06840:  MOV     W5,[W15++]
06842:  MOV     W6,[W15++]
06844:  MOV     W7,[W15++]
*
0687C:  MOV     #1014,W4
0687E:  MOV     W4,104A
.................... { 
....................     FSFILE f; 
*
06846:  CLR     1014
06848:  CLR     1016
0684A:  CLR     1018
0684C:  CLR     101A
0684E:  CLR     101C
06850:  CLR     101E
06852:  CLR     1020
06854:  CLR     1022
06856:  CLR     1024
06858:  CLR     1026
0685A:  CLR     1028
0685C:  CLR     102A
0685E:  CLR     102C
06860:  CLR     102E
06862:  CLR     1030
06864:  CLR     1032
06866:  CLR     1034
06868:  CLR     1036
0686A:  CLR     1038
0686C:  CLR     103A
0686E:  CLR     103C
06870:  CLR     103E
06872:  CLR     1040
06874:  CLR     1042
06876:  CLR     1044
06878:  CLR     1046
0687A:  CLR     1048
....................     FILEOBJ fo = &f; 
....................     BYTE i, j; 
*
06880:  CLR.B   104C
06882:  CLR.B   104D
....................    #ifdef SUPPORT_LFN 
....................       short int indexLFN; 
....................    #endif 
....................  
....................     FSerrno = CE_GOOD; 
06884:  CLR.B   8B1
....................  
....................     // Make sure we called FindFirst on this object 
....................     if (rec->initialized == FALSE) 
06886:  MOV     #2A,W0
06888:  ADD     1012,W0
0688A:  CP0.B   [W0]
0688C:  BRA     NZ,6896
....................     { 
....................         FSerrno = CE_NOT_INIT; 
0688E:  MOV.B   #7,W0L
06890:  MOV.B   W0L,8B1
....................         return -1; 
06892:  SETM    0
06894:  BRA     6AC0
....................     } 
....................  
....................     // Make sure we called FindFirst in the cwd 
.................... #ifdef ALLOW_DIRS 
....................     if (rec->cwdclus != cwdptr->dirclus) 
06896:  MOV     #26,W0
06898:  ADD     1012,W0
0689A:  MOV     #A,W4
0689C:  MOV     [W0++],[W4++]
0689E:  MOV     [W0++],[W4++]
068A0:  MOV     #2E,W0
068A2:  ADD     95E,W0
068A4:  MOV     W0,W4
068A6:  MOV     #0,W3
068A8:  MOV     [W4++],[W3++]
068AA:  MOV     [W4++],[W3++]
068AC:  CP      W5,W0
068AE:  BRA     NZ,68B4
068B0:  CP      W6,W1
068B2:  BRA     Z,68BC
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
068B4:  MOV.B   #1F,W0L
068B6:  MOV.B   W0L,8B1
....................         return -1; 
068B8:  SETM    0
068BA:  BRA     6AC0
....................     } 
.................... #endif 
....................  
....................    #if defined(SUPPORT_LFN) 
....................     fo->AsciiEncodingType = rec->AsciiEncodingType; 
....................     fo->utf16LFNlength = recordSearchLength; 
....................    if(fo->utf16LFNlength) 
....................    { 
....................        fo->utf16LFNptr = &recordSearchName[0]; 
....................     } 
....................    else 
....................    #endif 
....................    { 
....................       // Format the file name 
....................        if( !FormatFileName(rec->searchname, fo, 1) ) 
068BC:  MOV     #18,W0
068BE:  ADD     1012,W0
068C0:  MOV     W0,W5
068C2:  MOV.B   #1,W0L
068C4:  MOV.B   W0L,105E
068C6:  MOV     W5,105A
068C8:  PUSH    104A
068CA:  POP     105C
068CC:  CALL    26EC
068D0:  CP0.B   W0L
068D2:  BRA     NZ,68DC
....................        { 
....................            FSerrno = CE_INVALID_FILENAME; 
068D4:  MOV.B   #12,W0L
068D6:  MOV.B   W0L,8B1
....................            return -1; 
068D8:  SETM    0
068DA:  BRA     6AC0
....................        } 
....................     } 
....................  
....................        #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" FindNext foCompareTo="); 
....................          PrintRAMBytesUART(((unsigned char*)fo->name), 13); 
....................          PrintROMASCIIStringUART(" FindNext recSearchname="); 
....................          PrintRAMBytesUART(((unsigned char*)rec->searchname), 13);          
....................         #endif 
....................  
....................     /* Brn: Copy the formatted name to "fo" which is necesary before calling "FILEfind" function */ 
....................     //strcpy(fo->name,rec->searchname); 
....................  
....................     fo->dsk = &gDiskData; 
068DC:  MOV     104A,W4
068DE:  ADD     W4,#0,W4
068E0:  MOV     W4,W0
068E2:  MOV     W0,W5
068E4:  MOV.B   #60,W0L
068E6:  MOV.B   W0L,[W5]
068E8:  MOV.B   #D,W0L
068EA:  MOV.B   W0L,[W5+#1]
....................     fo->cluster = 0; 
068EC:  MOV     #2,W0
068EE:  ADD     104A,W0
068F0:  MOV     W0,W5
068F2:  CLR.B   [W5]
068F4:  MOV.B   #0,W0L
068F6:  MOV.B   W0L,[W5+#1]
068F8:  MOV.B   #0,W0L
068FA:  MOV.B   W0L,[W5+#2]
068FC:  MOV.B   #0,W0L
068FE:  MOV.B   W0L,[W5+#3]
....................     fo->ccls    = 0; 
06900:  MOV     #6,W0
06902:  ADD     104A,W0
06904:  MOV     W0,W5
06906:  CLR.B   [W5]
06908:  MOV.B   #0,W0L
0690A:  MOV.B   W0L,[W5+#1]
0690C:  MOV.B   #0,W0L
0690E:  MOV.B   W0L,[W5+#2]
06910:  MOV.B   #0,W0L
06912:  MOV.B   W0L,[W5+#3]
....................     fo->entry = rec->entry + 1; 
06914:  MOV     #28,W0
06916:  ADD     104A,W0
06918:  MOV     W0,W5
0691A:  MOV     #16,W0
0691C:  ADD     1012,W0
0691E:  MOV     [W0],W6
06920:  ADD     W6,#1,W6
06922:  MOV     W6,[W5]
....................     fo->attributes = rec->searchattr; 
06924:  MOV     #2C,W0
06926:  ADD     104A,W0
06928:  MOV     W0,W5
0692A:  MOV     #25,W0
0692C:  ADD     1012,W0
0692E:  MOV.B   [W0],[W5]
06930:  MOV.B   #0,W4L
06932:  MOV.B   W4L,[W5+#1]
....................  
.................... #ifndef ALLOW_DIRS 
....................     // start at the root directory 
....................     fo->dirclus    = FatRootDirClusterValue; 
....................     fo->dirccls    = FatRootDirClusterValue; 
.................... #else 
....................     fo->dirclus = cwdptr->dirclus; 
06934:  MOV     #2E,W0
06936:  ADD     104A,W0
06938:  MOV     W0,W5
0693A:  MOV     #2E,W0
0693C:  ADD     95E,W0
0693E:  MOV     [W0++],[W5++]
06940:  MOV     [W0++],[W5++]
....................     fo->dirccls = cwdptr->dirccls; 
06942:  MOV     #32,W0
06944:  ADD     104A,W0
06946:  MOV     W0,W5
06948:  MOV     #32,W0
0694A:  ADD     95E,W0
0694C:  MOV     [W0++],[W5++]
0694E:  MOV     [W0++],[W5++]
.................... #endif 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&gFileTemp, fo); 
06950:  MOV     #8F2,W4
06952:  MOV     W4,105C
06954:  PUSH    104A
06956:  POP     105E
06958:  CALL    28E2
....................  
....................        #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" FindNext2 foCompareTo="); 
....................          PrintRAMBytesUART(((unsigned char*)fo->name), 13); 
....................          PrintROMASCIIStringUART(" FindNext2 recSearchname="); 
....................          PrintRAMBytesUART(((unsigned char*)gFileTemp.name), 13);          
....................         #endif 
....................  
....................     // See if the file is found 
....................     if (CE_GOOD != FILEfind (fo, &gFileTemp,LOOK_FOR_MATCHING_ENTRY, 1)) 
0695C:  MOV.B   #1,W0L
0695E:  MOV.B   W0L,1060
06960:  MOV.B   #1,W0L
06962:  MOV.B   W0L,1061
06964:  PUSH    104A
06966:  POP     105C
06968:  MOV     #8F2,W4
0696A:  MOV     W4,105E
0696C:  CALL    36BE
06970:  CP0.B   W0L
06972:  BRA     Z,6980
....................     { 
....................         FSerrno = CE_FILE_NOT_FOUND; 
06974:  MOV.B   #B,W0L
06976:  MOV.B   W0L,8B1
....................         return -1; 
06978:  SETM    0
0697A:  BRA     6AC0
....................     } 
0697C:  GOTO    6AC0
....................     else 
....................     { 
....................       #if defined(SUPPORT_LFN) 
....................       rec->utf16LFNfoundLength = fo->utf16LFNlength; 
....................       if(fo->utf16LFNlength) 
....................       { 
....................          indexLFN = fo->utf16LFNlength; 
....................          recordFoundName[indexLFN] = 0x0000; 
....................          while(indexLFN--) 
....................             recordFoundName[indexLFN] = fileFoundString[indexLFN]; 
....................       } 
....................       #endif 
....................  
....................       for(j = 0; j < FILE_NAME_SIZE_8P3 + 2 ; j++) 
06980:  CLR.B   104D
06982:  MOV     104C,W4
06984:  LSR     W4,#8,W4
06986:  CP.B    W4L,#D
06988:  BRA     C,699C
....................       { 
....................             rec->filename[j] = 0; 
0698A:  MOV     104C,W4
0698C:  LSR     W4,#8,W4
0698E:  MOV     W4,W0
06990:  ADD     1012,W0
06992:  MOV     W0,W5
06994:  CLR.B   [W5]
06996:  INC.B   104D
06998:  GOTO    6982
....................       } 
....................  
....................         if (fo->attributes != ATTR_VOLUME) 
0699C:  MOV     #2C,W0
0699E:  ADD     104A,W0
069A0:  MOV     [W0],W5
069A2:  CP      W5,#8
069A4:  BRA     Z,6A50
....................         { 
....................             for (i = 0, j = 0; (j < 8) && (fo->name[j] != 0x20); i++, j++) 
069A6:  CLR.B   104C
069A8:  CLR.B   104D
069AA:  MOV     104C,W4
069AC:  LSR     W4,#8,W4
069AE:  CP.B    W4L,#8
069B0:  BRA     C,69EA
069B2:  MOV     #1C,W0
069B4:  ADD.B   104D,W0L
069B6:  ZE      W0,W0
069B8:  CLR.B   1
069BA:  MOV     104A,W4
069BC:  ADD     W0,W4,W0
069BE:  MOV.B   [W0],W5L
069C0:  SE      W5,W5
069C2:  MOV     #20,W4
069C4:  CP      W4,W5
069C6:  BRA     Z,69EA
....................             { 
....................                rec->filename[i] = fo->name[j]; 
069C8:  MOV     104C,W4
069CA:  CLR.B   9
069CC:  MOV     W4,W0
069CE:  ADD     1012,W0
069D0:  MOV     W0,W5
069D2:  MOV     #1C,W0
069D4:  ADD.B   104D,W0L
069D6:  ZE      W0,W0
069D8:  CLR.B   1
069DA:  MOV     104A,W4
069DC:  ADD     W0,W4,W0
069DE:  MOV.B   [W0],[W5]
069E0:  MOV.B   104C,W0L
069E2:  INC.B   104C
069E4:  INC.B   104D
069E6:  GOTO    69AA
....................             } 
....................  
....................          if(fo->name[8] != 0x20) 
069EA:  MOV     #24,W0
069EC:  ADD     104A,W0
069EE:  MOV.B   [W0],W5L
069F0:  SE      W5,W5
069F2:  MOV     #20,W4
069F4:  CP      W4,W5
069F6:  BRA     Z,6A4C
....................          { 
....................                rec->filename[i++] = '.'; 
069F8:  MOV.B   104C,W0L
069FA:  INC.B   104C
069FC:  ZE      W0,W0
069FE:  CLR.B   1
06A00:  MOV     1012,W4
06A02:  ADD     W0,W4,W5
06A04:  MOV.B   #2E,W0L
06A06:  MOV.B   W0L,[W5]
....................  
....................                // Move to the extension, even if there are more space chars 
....................                for (j = 8; (j < 11) && (fo->name[j] != 0x20); i++, j++) 
06A08:  MOV.B   #8,W0L
06A0A:  MOV.B   W0L,104D
06A0C:  MOV     104C,W4
06A0E:  LSR     W4,#8,W4
06A10:  CP.B    W4L,#B
06A12:  BRA     C,6A4C
06A14:  MOV     #1C,W0
06A16:  ADD.B   104D,W0L
06A18:  ZE      W0,W0
06A1A:  CLR.B   1
06A1C:  MOV     104A,W4
06A1E:  ADD     W0,W4,W0
06A20:  MOV.B   [W0],W5L
06A22:  SE      W5,W5
06A24:  MOV     #20,W4
06A26:  CP      W4,W5
06A28:  BRA     Z,6A4C
....................                { 
....................                   rec->filename[i] = fo->name[j]; 
06A2A:  MOV     104C,W4
06A2C:  CLR.B   9
06A2E:  MOV     W4,W0
06A30:  ADD     1012,W0
06A32:  MOV     W0,W5
06A34:  MOV     #1C,W0
06A36:  ADD.B   104D,W0L
06A38:  ZE      W0,W0
06A3A:  CLR.B   1
06A3C:  MOV     104A,W4
06A3E:  ADD     W0,W4,W0
06A40:  MOV.B   [W0],[W5]
06A42:  MOV.B   104C,W0L
06A44:  INC.B   104C
06A46:  INC.B   104D
06A48:  GOTO    6A0C
....................                } 
....................          } 
....................         } 
06A4C:  GOTO    6A76
....................         else 
....................         { 
....................             for (i = 0; i < DIR_NAMECOMP; i++) 
06A50:  CLR.B   104C
06A52:  MOV     104C,W4
06A54:  CP.B    W4L,#B
06A56:  BRA     C,6A76
....................             { 
....................                 rec->filename[i] = fo->name[i]; 
06A58:  MOV     104C,W4
06A5A:  CLR.B   9
06A5C:  MOV     W4,W0
06A5E:  ADD     1012,W0
06A60:  MOV     W0,W5
06A62:  MOV     #1C,W0
06A64:  ADD.B   104C,W0L
06A66:  ZE      W0,W0
06A68:  CLR.B   1
06A6A:  MOV     104A,W4
06A6C:  ADD     W0,W4,W0
06A6E:  MOV.B   [W0],[W5]
06A70:  INC.B   104C
06A72:  GOTO    6A52
....................             } 
....................         } 
....................  
....................         rec->attributes = fo->attributes; 
06A76:  MOV     #D,W0
06A78:  ADD     1012,W0
06A7A:  MOV     W0,W5
06A7C:  MOV     #2C,W0
06A7E:  ADD     104A,W0
06A80:  MOV.B   [W0],[W5]
....................         rec->filesize = fo->size; 
06A82:  MOV     #E,W0
06A84:  ADD     1012,W0
06A86:  MOV     W0,W5
06A88:  MOV     #12,W0
06A8A:  ADD     104A,W0
06A8C:  MOV     [W0++],[W5++]
06A8E:  MOV     [W0++],[W5++]
....................         rec->timestamp = (DWORD)((DWORD)fo->date << 16) + fo->time; 
06A90:  MOV     #12,W0
06A92:  ADD     1012,W0
06A94:  MOV     W0,W5
06A96:  MOV     #1A,W0
06A98:  ADD     104A,W0
06A9A:  MOV     [W0],W6
06A9C:  MOV     #0,W7
06A9E:  MOV     W6,W7
06AA0:  MOV     #0,W6
06AA2:  MOV     #18,W0
06AA4:  ADD     104A,W0
06AA6:  MOV     W0,W4
06AA8:  MOV     [W4],W0
06AAA:  ADD     W0,W6,[W5]
06AAC:  MOV     #0,W4
06AAE:  ADDC    W4,W7,[++W5]
....................         rec->entry = fo->entry; 
06AB0:  MOV     #16,W0
06AB2:  ADD     1012,W0
06AB4:  MOV     W0,W5
06AB6:  MOV     #28,W0
06AB8:  ADD     104A,W0
06ABA:  MOV     [W0],[W5]
....................         return 0; 
06ABC:  CLR     0
06ABE:  BRA     6AC0
....................     } 
06AC0:  MOV     [--W15],W7
06AC2:  MOV     [--W15],W6
06AC4:  MOV     [--W15],W5
06AC6:  RETURN  
.................... } 
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous wFindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent wFindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................     The wFindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the 
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was 
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... #ifdef SUPPORT_LFN 
.................... int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................    result = FindFirst ((const char *)fileName,attr,rec); 
....................    utfModeFileName = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FSputc (char c, FSFILE * file) 
....................   Summary: 
....................     FSfprintf helper function to write a char 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     c - The character to write to the file. 
....................     file - The file to write to. 
....................   Return Values: 
....................     0 -   The character was written successfully 
....................     EOF - The character was not written to the file. 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This is a helper function for FSfprintf.  It will write one 
....................     character to a file. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int FSputc (char c, FSFILE * file) 
.................... { 
....................     if (FSfwrite ((void *)&c, 1, 1, file) != 1) 
....................         return EOF; 
....................     else 
....................         return 0; 
.................... } 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int str_put_n_chars (FSFILE * handle, unsigned char n, char c) 
....................   Summary: 
....................     FSfprintf helper function to write a char multiple times 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     handle - The file to write to. 
....................     n -      The number of times to write that character to a file. 
....................     c - The character to write to the file. 
....................   Return Values: 
....................     0 -   The characters were written successfully 
....................     EOF - The characters were not written to the file. 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This funciton is used by the FSfprintf function to write multiple 
....................     instances of a single character to a file (for example, when 
....................     padding a format specifier with leading spacez or zeros). 
....................   Remarks: 
....................     None. 
....................   **********************************************************************/ 
....................  
....................  
.................... unsigned char str_put_n_chars (FSFILE * handle, unsigned char n, char c) 
.................... { 
....................     while (n--) 
....................     if (FSputc (c, handle) == EOF) 
....................         return 1; 
....................     return 0; 
.................... } 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int FSfprintf (FSFILE * fptr, const char * fmt, ...) 
....................     // PIC18 
....................     int FSfpritnf (FSFILE * fptr, const rom char * fmt, ...) 
....................   Summary: 
....................     Function to write formatted strings to a file 
....................   Conditions: 
....................     For PIC18, integer promotion must be enabled in the project build 
....................     options menu.  File opened in a write mode. 
....................   Input: 
....................     fptr - A pointer to the file to write to. 
....................     fmt -  A string of characters and format specifiers to write to 
....................            the file 
....................     ... -  Additional arguments inserted in the string by format 
....................            specifiers 
....................   Returns: 
....................     The number of characters written to the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Writes a specially formatted string to a file. 
....................   Remarks: 
....................     Consult AN1045 for a full description of how to use format 
....................     specifiers. 
....................   **********************************************************************/ 
....................  
.................... #ifdef __18CXX 
.................... int FSfprintf (FSFILE *fptr, const rom char *fmt, ...) 
.................... #else 
.................... int FSfprintf (FSFILE *fptr, const char * fmt, ...) 
.................... #endif 
.................... { 
....................     va_list ap; 
....................     int n; 
....................  
....................     va_start (ap, fmt); 
....................     n = FSvfprintf (fptr, fmt, ap); 
....................     va_end (ap); 
....................     return n; 
.................... } 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int FSvfprintf (FSFILE * handle, const char * formatString, va_list ap) 
....................     // PIC18 
....................     int FSvfpritnf (auto FSFILE * handle, auto const rom char * formatString, auto va_list ap) 
....................   Summary: 
....................     Helper function for FSfprintf 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     handle -        A pointer to the file to write to. 
....................     formatString -  A string of characters and format specifiers to write to 
....................                     the file 
....................     ap -            A structure pointing to the arguments on the stack 
....................   Returns: 
....................     The number of characters written to the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This helper function will access the elements passed to FSfprintf 
....................   Remarks: 
....................     Consult AN1045 for a full description of how to use format 
....................     specifiers. 
....................   **********************************************************************/ 
....................  
.................... #ifdef __18CXX 
.................... int FSvfprintf (auto FSFILE *handle, auto const rom char * formatString, auto va_list ap) 
.................... #else 
.................... int FSvfprintf (FSFILE *handle, const char * formatString, va_list ap) 
.................... #endif 
.................... { 
....................     unsigned char c; 
....................     int count = 0; 
....................  
....................     for (c = *formatString; c; c = *++formatString) 
....................     { 
....................         if (c == '%') 
....................         { 
....................             unsigned char    flags = 0; 
....................             unsigned char    width = 0; 
....................             unsigned char    precision = 0; 
....................             unsigned char    have_precision = 0; 
....................             unsigned char    size = 0; 
.................... #ifndef __18CXX 
....................             unsigned char   size2 = 0; 
.................... #endif 
....................             unsigned char    space_cnt; 
....................             unsigned char    cval; 
.................... #ifdef __18CXX 
....................             unsigned long    larg; 
....................             far rom char *   romstring; 
.................... #else 
....................             unsigned long long larg; 
.................... #endif 
....................             char *         ramstring; 
....................             int n; 
....................  
....................             FSerrno = CE_GOOD; 
....................  
....................             c = *++formatString; 
....................  
....................             while ((c == '-') || (c == '+') || (c == ' ') || (c == '#') || (c == '0')) 
....................             { 
....................                 switch (c) 
....................                 { 
....................                     case '-': 
....................                         flags |= _FLAG_MINUS; 
....................                         break; 
....................                     case '+': 
....................                         flags |= _FLAG_PLUS; 
....................                         break; 
....................                     case ' ': 
....................                         flags |= _FLAG_SPACE; 
....................                         break; 
....................                     case '#': 
....................                         flags |= _FLAG_OCTO; 
....................                         break; 
....................                     case '0': 
....................                         flags |= _FLAG_ZERO; 
....................                         break; 
....................                 } 
....................                 c = *++formatString; 
....................             } 
....................             /* the optional width field is next */ 
....................             if (c == '*') 
....................             { 
....................                 n = va_arg (ap, int); 
....................                 if (n < 0) 
....................                 { 
....................                     flags |= _FLAG_MINUS; 
....................                     width = -n; 
....................                 } 
....................                 else 
....................                     width = n; 
....................                 c = *++formatString; 
....................             } 
....................             else 
....................             { 
....................                 cval = 0; 
....................                 while ((unsigned char) isdigit (c)) 
....................                 { 
....................                     cval = cval * 10 + c - '0'; 
....................                     c = *++formatString; 
....................                 } 
....................                 width = cval; 
....................             } 
....................  
....................             /* if '-' is specified, '0' is ignored */ 
....................             if (flags & _FLAG_MINUS) 
....................                 flags &= ~_FLAG_ZERO; 
....................  
....................             /* the optional precision field is next */ 
....................             if (c == '.') 
....................             { 
....................                 c = *++formatString; 
....................                 if (c == '*') 
....................                 { 
....................                     n = va_arg (ap, int); 
....................                     if (n >= 0) 
....................                     { 
....................                         precision = n; 
....................                         have_precision = 1; 
....................                     } 
....................                     c = *++formatString; 
....................                 } 
....................                 else 
....................                 { 
....................                     cval = 0; 
....................                     while ((unsigned char) isdigit (c)) 
....................                     { 
....................                         cval = cval * 10 + c - '0'; 
....................                         c = *++formatString; 
....................                     } 
....................                     precision = cval; 
....................                     have_precision = 1; 
....................                 } 
....................             } 
....................  
....................             /* the optional 'h' specifier. since int and short int are 
....................                 the same size for MPLAB C18, this is a NOP for us. */ 
....................             if (c == 'h') 
....................             { 
....................                 c = *++formatString; 
....................                 /* if 'c' is another 'h' character, this is an 'hh' 
....................                     specifier and the size is 8 bits */ 
....................                 if (c == 'h') 
....................                 { 
....................                     size = _FMT_BYTE; 
....................                     c = *++formatString; 
....................                 } 
....................             } 
....................             else if ((c == 't') || (c == 'z')) 
....................                 c = *++formatString; 
.................... #ifdef __18CXX 
....................             else if ((c == 'H') || (c == 'T') || (c == 'Z')) 
....................             { 
....................                 size = _FMT_SHRTLONG; 
....................                 c = *++formatString; 
....................             } 
....................             else if ((c == 'l') || (c == 'j')) 
.................... #else 
....................             else if ((c == 'q') || (c == 'j')) 
....................             { 
....................                 size = _FMT_LONGLONG; 
....................                 c = *++formatString; 
....................             } 
....................             else if (c == 'l') 
.................... #endif 
....................             { 
....................                 size = _FMT_LONG; 
....................                 c = *++formatString; 
....................             } 
....................  
....................             switch (c) 
....................             { 
....................                 case '\0': 
....................                 /* this is undefined behaviour. we have a trailing '%' character 
....................                     in the string, perhaps with some flags, width, precision 
....................                     stuff as well, but no format specifier. We'll, arbitrarily, 
....................                     back up a character so that the loop will terminate 
....................                     properly when it loops back and we'll output a '%' 
....................                     character. */ 
....................                     --formatString; 
....................                 /* fallthrough */ 
....................                 case '%': 
....................                     if (FSputc ('%', handle) == EOF) 
....................                     { 
....................                         FSerrno = CE_WRITE_ERROR; 
....................                         return EOF; 
....................                     } 
....................                     ++count; 
....................                     break; 
....................                 case 'c': 
....................                     space_cnt = 0; 
....................                     if (width > 1) 
....................                     { 
....................                         space_cnt = width - 1; 
....................                         count += space_cnt; 
....................                     } 
....................                     if (space_cnt && !(flags & _FLAG_MINUS)) 
....................                     { 
....................                         if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                         { 
....................                             FSerrno = CE_WRITE_ERROR; 
....................                             return EOF; 
....................                         } 
....................                         space_cnt = 0; 
....................                     } 
....................                     c = va_arg (ap, int); 
....................                     if (FSputc (c, handle) == EOF) 
....................                     { 
....................                         FSerrno = CE_WRITE_ERROR; 
....................                         return EOF; 
....................                     } 
....................                     ++count; 
....................                     if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                     { 
....................                         FSerrno = CE_WRITE_ERROR; 
....................                         return EOF; 
....................                     } 
....................                     break; 
....................                 case 'S': 
.................... #ifdef __18CXX 
....................                     if (size == _FMT_SHRTLONG) 
....................                         romstring = va_arg (ap, rom far char *); 
....................                     else 
....................                         romstring = (far rom char*)va_arg (ap, rom near char *); 
....................                     n = strlenpgm (romstring); 
....................                     /* Normalize the width based on the length of the actual 
....................                         string and the precision. */ 
....................                     if (have_precision && precision < (unsigned char) n) 
....................                         n = precision; 
....................                     if (width < (unsigned char) n) 
....................                         width = n; 
....................                     space_cnt = width - (unsigned char) n; 
....................                     count += space_cnt; 
....................                     /* we've already calculated the space count that the width 
....................                         will require. now we want the width field to have the 
....................                         number of character to display from the string itself, 
....................                         limited by the length of the actual string and the 
....................                         specified precision. */ 
....................                     if (have_precision && precision < width) 
....................                         width = precision; 
....................                     /* if right justified, we print the spaces before the 
....................                         string */ 
....................                     if (!(flags & _FLAG_MINUS)) 
....................                     { 
....................                         if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                         { 
....................                             FSerrno = CE_WRITE_ERROR; 
....................                             return EOF; 
....................                         } 
....................                         space_cnt = 0; 
....................                     } 
....................                     cval = 0; 
....................                     for (c = *romstring; c && cval < width; c = *++romstring) 
....................                     { 
....................                         if (FSputc (c, handle) == EOF) 
....................                         { 
....................                             FSerrno = CE_WRITE_ERROR; 
....................                             return EOF; 
....................                         } 
....................                         ++count; 
....................                         ++cval; 
....................                     } 
....................                     /* If there are spaces left, it's left justified. 
....................                         Either way, calling the function unconditionally 
....................                         is smaller code. */ 
....................                     if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                     { 
....................                         FSerrno = CE_WRITE_ERROR; 
....................                         return EOF; 
....................                     } 
....................                     break; 
.................... #endif 
....................                 case 's': 
....................                     ramstring = va_arg (ap, char *); 
....................                     n = strlen (ramstring); 
....................                     /* Normalize the width based on the length of the actual 
....................                         string and the precision. */ 
....................                     if (have_precision && precision < (unsigned char) n) 
....................                         n = precision; 
....................                     if (width < (unsigned char) n) 
....................                         width = n; 
....................                     space_cnt = width - (unsigned char) n; 
....................                     count += space_cnt; 
....................                     /* we've already calculated the space count that the width 
....................                         will require. now we want the width field to have the 
....................                         number of character to display from the string itself, 
....................                         limited by the length of the actual string and the 
....................                         specified precision. */ 
....................                     if (have_precision && precision < width) 
....................                         width = precision; 
....................                     /* if right justified, we print the spaces before the string */ 
....................                     if (!(flags & _FLAG_MINUS)) 
....................                     { 
....................                         if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                         { 
....................                             FSerrno = CE_WRITE_ERROR; 
....................                             return EOF; 
....................                         } 
....................                         space_cnt = 0; 
....................                     } 
....................                     cval = 0; 
....................                     for (c = *ramstring; c && cval < width; c = *++ramstring) 
....................                     { 
....................                         if (FSputc (c, handle) == EOF) 
....................                         { 
....................                             FSerrno = CE_WRITE_ERROR; 
....................                             return EOF; 
....................                         } 
....................                         ++count; 
....................                         ++cval; 
....................                     } 
....................                     /* If there are spaces left, it's left justified. 
....................                         Either way, calling the function unconditionally 
....................                         is smaller code. */ 
....................                     if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                     { 
....................                         FSerrno = CE_WRITE_ERROR; 
....................                         return EOF; 
....................                     } 
....................                     break; 
....................                 case 'd': 
....................                 case 'i': 
....................                     flags |= _FLAG_SIGNED; 
....................                 /* fall through */ 
....................                 case 'o': 
....................                 case 'u': 
....................                 case 'x': 
....................                 case 'X': 
....................                 case 'b': 
....................                 case 'B': 
....................                     /* This is a bit of a trick. The 'l' and 'hh' size 
....................                         specifiers are valid only for the integer conversions, 
....................                         not the 'p' or 'P' conversions, and are ignored for the 
....................                         latter. By jumping over the additional size specifier 
....................                         checks here we get the best code size since we can 
....................                         limit the size checks in the remaining code. */ 
....................                     if (size == _FMT_LONG) 
....................                     { 
....................                         if (flags & _FLAG_SIGNED) 
....................                             larg = va_arg (ap, long int); 
....................                         else 
....................                             larg = va_arg (ap, unsigned long int); 
....................                         goto _do_integer_conversion; 
....................                     } 
....................                     else if (size == _FMT_BYTE) 
....................                     { 
....................                         if (flags & _FLAG_SIGNED) 
....................                             larg = (signed char) va_arg (ap, int); 
....................                         else 
....................                             larg = (unsigned char) va_arg (ap, unsigned int); 
....................                         goto _do_integer_conversion; 
....................                     } 
.................... #ifndef __18CXX 
....................                     else if (size == _FMT_LONGLONG) 
....................                     { 
....................                         if (flags & _FLAG_SIGNED) 
....................                             larg = (signed long long)va_arg (ap, long long); 
....................                         else 
....................                             larg = (unsigned long long) va_arg (ap, unsigned long long); 
....................                         goto _do_integer_conversion; 
....................                     } 
.................... #endif 
....................                     /* fall trough */ 
....................                 case 'p': 
....................                 case 'P': 
.................... #ifdef __18CXX 
....................                     if (size == _FMT_SHRTLONG) 
....................                     { 
....................                         if (flags & _FLAG_SIGNED) 
....................                             larg = va_arg (ap, short long int); 
....................                         else 
....................                             larg = va_arg (ap, unsigned short long int); 
....................                     } 
....................                     else 
.................... #endif 
....................                         if (flags & _FLAG_SIGNED) 
....................                             larg = va_arg (ap, int); 
....................                         else 
....................                             larg = va_arg (ap, unsigned int); 
....................                     _do_integer_conversion: 
....................                         /* default precision is 1 */ 
....................                         if (!have_precision) 
....................                             precision = 1; 
....................                         { 
....................                             unsigned char digit_cnt = 0; 
....................                             unsigned char prefix_cnt = 0; 
....................                             unsigned char sign_char; 
....................                             /* A 32 bit number will require at most 32 digits in the 
....................                                 string representation (binary format). */ 
.................... #ifdef __18CXX 
....................                             char buf[33]; 
....................                             /* Start storing digits least-significant first */ 
....................                             char *q = &buf[31]; 
....................                             /* null terminate the string */ 
....................                             buf[32] = '\0'; 
.................... #else 
....................                             char buf[65]; 
....................                             char *q = &buf[63]; 
....................                             buf[64] = '\0'; 
.................... #endif 
....................                             space_cnt = 0; 
....................                             size = 10; 
....................  
....................                             switch (c) 
....................                             { 
....................                                 case 'b': 
....................                                 case 'B': 
....................                                     size = 2; 
.................... #ifndef __18CXX 
....................                                     size2 = 1; 
.................... #endif 
....................                                     break; 
....................                                 case 'o': 
....................                                     size = 8; 
.................... #ifndef __18CXX 
....................                                     size2 = 3; 
.................... #endif 
....................                                     break; 
....................                                 case 'p': 
....................                                 case 'P': 
....................                                     /* from here on out, treat 'p' conversions just 
....................                                         like 'x' conversions. */ 
....................                                     c += 'x' - 'p'; 
....................                                 /* fall through */ 
....................                                 case 'x': 
....................                                 case 'X': 
....................                                     size = 16; 
.................... #ifndef __18CXX 
....................                                     size2 = 4; 
.................... #endif 
....................                                     break; 
....................                             }// switch (c) 
....................  
....................                             /* if it's an unsigned conversion, we should ignore the 
....................                                 ' ' and '+' flags */ 
....................                             if (!(flags & _FLAG_SIGNED)) 
....................                                 flags &= ~(_FLAG_PLUS | _FLAG_SPACE); 
....................  
....................                             /* if it's a negative value, we need to negate the 
....................                                 unsigned version before we convert to text. Using 
....................                                 unsigned for this allows us to (ab)use the 2's 
....................                                 complement system to avoid overflow and be able to 
....................                                 adequately handle LONG_MIN. 
....................  
....................                                 We'll figure out what sign character to print, if 
....................                                 any, here as well. */ 
.................... #ifdef __18CXX 
....................                             if (flags & _FLAG_SIGNED && ((long) larg < 0)) 
....................                             { 
....................                                 larg = -(long) larg; 
.................... #else 
....................                             if (flags & _FLAG_SIGNED && ((long long) larg < 0)) 
....................                             { 
....................                                 larg = -(long long) larg; 
.................... #endif 
....................                                 sign_char = '-'; 
....................                                 ++digit_cnt; 
....................                             } 
....................                             else if (flags & _FLAG_PLUS) 
....................                             { 
....................                         sign_char = '+'; 
....................                         ++digit_cnt; 
....................                      } 
....................                       else if (flags & _FLAG_SPACE) 
....................                       { 
....................                                 sign_char = ' '; 
....................                                 ++digit_cnt; 
....................                             } 
....................                             else 
....................                                 sign_char = '\0'; 
....................                             /* get the digits for the actual number. If the 
....................                                 precision is zero and the value is zero, the result 
....................                                 is no characters. */ 
....................                             if (precision || larg) 
....................                             { 
....................                                 do 
....................                                 { 
.................... #ifdef __18CXX 
....................                                     cval = s_digits[larg % size]; 
....................                                     if ((c == 'X') && (cval >= 'a')) 
....................                                         cval -= 'a' - 'A'; 
....................                                     larg /= size; 
.................... #else 
....................                                     // larg is congruent mod size2 to its lower 16 bits 
....................                                     // for size2 = 2^n, 0 <= n <= 4 
....................                                     if (size2 != 0) 
....................                                         cval = s_digits[(unsigned int) larg % size]; 
....................                                     else 
....................                                         cval = s_digits[larg % size]; 
....................                                     if ((c == 'X') && (cval >= 'a')) 
....................                                         cval -= 'a' - 'A'; 
....................                                     if (size2 != 0) 
....................                                         larg = larg >> size2; 
....................                                     else 
....................                                         larg /= size; 
.................... #endif 
....................                                     *q-- = cval; 
....................                                     ++digit_cnt; 
....................                                 } while (larg); 
....................                                 /* if the '#' flag was specified and we're dealing 
....................                                     with an 'o', 'b', 'B', 'x', or 'X' conversion, 
....................                                     we need a bit more. */ 
....................                                 if (flags & _FLAG_OCTO) 
....................                                 { 
....................                                     if (c == 'o') 
....................                                     { 
....................                                         /* per the standard, for octal, the '#' flag 
....................                                             makes the precision be at least one more 
....................                                             than the number of digits in the number */ 
....................                                         if (precision <= digit_cnt) 
....................                                             precision = digit_cnt + 1; 
....................                                     } 
....................                                     else if ((c == 'x') || (c == 'X') || (c == 'b') || (c == 'B')) 
....................                                         prefix_cnt = 2; 
....................                                 } 
....................                             } 
....................                             else 
....................                                 digit_cnt = 0; 
....................  
....................                             /* The leading zero count depends on whether the '0' 
....................                                 flag was specified or not. If it was not, then the 
....................                                 count is the difference between the specified 
....................                                 precision and the number of digits (including the 
....................                                 sign character, if any) to be printed; otherwise, 
....................                                 it's as if the precision were equal to the max of 
....................                                 the specified precision and the field width. If a 
....................                                 precision was specified, the '0' flag is ignored, 
....................                                 however. */ 
....................                             if ((flags & _FLAG_ZERO) && (width > precision) 
....................                                 && !have_precision) 
....................                                 precision = width; 
....................                             /* for the rest of the processing, precision contains 
....................                                 the leading zero count for the conversion. */ 
....................                             if (precision > digit_cnt) 
....................                                 precision -= digit_cnt; 
....................                             else 
....................                                 precision = 0; 
....................                             /* the space count is the difference between the field 
....................                                 width and the digit count plus the leading zero 
....................                                 count. If the width is less than the digit count 
....................                                 plus the leading zero count, the space count is 
....................                                 zero. */ 
....................                             if (width > precision + digit_cnt + prefix_cnt) 
....................                                 space_cnt =   width - precision - digit_cnt - prefix_cnt; 
....................  
....................                             /* for output, we check the justification, if it's 
....................                                 right justified and the space count is positive, we 
....................                                 emit the space characters first. */ 
....................                             if (!(flags & _FLAG_MINUS) && space_cnt) 
....................                             { 
....................                                 if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                                 { 
....................                                     FSerrno = CE_WRITE_ERROR; 
....................                                     return EOF; 
....................                                 } 
....................                                 count += space_cnt; 
....................                                 space_cnt = 0; 
....................                             } 
....................                             /* if we have a sign character to print, that comes 
....................                                 next */ 
....................                             if (sign_char) 
....................                                 if (FSputc (sign_char, handle) == EOF) 
....................                                 { 
....................                                     FSerrno = CE_WRITE_ERROR; 
....................                                     return EOF; 
....................                                 } 
....................                             /* if we have a prefix (0b, 0B, 0x or 0X), that's next */ 
....................                             if (prefix_cnt) 
....................                             { 
....................                                 if (FSputc ('0', handle) == EOF) 
....................                                 { 
....................                                     FSerrno = CE_WRITE_ERROR; 
....................                                     return EOF; 
....................                                 } 
....................                                 if (FSputc (c, handle) == EOF) 
....................                                 { 
....................                                     FSerrno = CE_WRITE_ERROR; 
....................                                     return EOF; 
....................                                 } 
....................                             } 
....................                             /* if we have leading zeros, they follow. the prefix, if any 
....................                                 is included in the number of digits when determining how 
....................                                 many leading zeroes are needed. */ 
.................... //                            if (precision > prefix_cnt) 
....................   //                              precision -= prefix_cnt; 
....................                             if (str_put_n_chars (handle, precision, '0')) 
....................                             { 
....................                                 FSerrno = CE_WRITE_ERROR; 
....................                                 return EOF; 
....................                             } 
....................                             /* print the actual number */ 
....................                             for (cval = *++q; cval; cval = *++q) 
....................                                 if (FSputc (cval, handle) == EOF) 
....................                                 { 
....................                                     FSerrno = CE_WRITE_ERROR; 
....................                                     return EOF; 
....................                                 } 
....................                             /* if there are any spaces left, they go to right-pad 
....................                                 the field */ 
....................                             if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                             { 
....................                                 FSerrno = CE_WRITE_ERROR; 
....................                                 return EOF; 
....................                             } 
....................  
....................                             count += precision + digit_cnt + space_cnt + prefix_cnt; 
....................                         } 
....................                         break; 
....................                 case 'n': 
....................                     switch (size) 
....................                     { 
....................                         case _FMT_LONG: 
....................                             *(long *) va_arg (ap, long *) = count; 
....................                             break; 
.................... #ifdef __18CXX 
....................                         case _FMT_SHRTLONG: 
....................                             *(short long *) va_arg (ap, short long *) = count; 
....................                             break; 
.................... #else 
....................                         case _FMT_LONGLONG: 
....................                             *(long long *) va_arg (ap, long long *) = count; 
....................                             break; 
.................... #endif 
....................                         case _FMT_BYTE: 
....................                             *(signed char *) va_arg (ap, signed char *) = count; 
....................                             break; 
....................                         default: 
....................                             *(int *) va_arg (ap, int *) = count; 
....................                             break; 
....................                     } 
....................                     break; 
....................                 default: 
....................                     /* undefined behaviour. we do nothing */ 
....................                     break; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if (FSputc (c, handle) == EOF) 
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
....................                 return EOF; 
....................             } 
....................             ++count; 
....................         } 
....................     } 
....................     return count; 
.................... } 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #if defined(USE_SD_INTERFACE_WITH_SPI) 
.................... #include "sd-spi.c" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        SD-SPI.c 
....................  * Dependencies:    SD-SPI.h 
....................  *                  string.h 
....................  *                  FSIO.h 
....................  *                  FSDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the "Company") for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... ***************************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev     Description 
....................   -----   ----------- 
....................   1.2.5   Fixed bug in the calculation of the capacity for v1.0 devices 
....................   1.3.0   Improved media initialization sequence, for better card compatibility 
....................           (especially with SDHC cards). 
....................           Implemented SPI optimizations for data transfer rate improvement. 
....................           Added new MDD_SDSPI_AsyncReadTasks() and MDD_SDSPI_AsyncWriteTasks()  
....................           API functions.  These are non-blocking, state machine based read/write 
....................           handlers capable of considerably improved data throughput, particularly 
....................           for multi-block reads and multi-block writes. 
....................   1.3.2   Modified MDD_SDSPI_AsyncWriteTasks() so pre-erase command only gets 
....................           used for multi-block write scenarios.    
....................   1.3.4   1) Added support for dsPIC33E & PIC24E controllers. 
....................           2) #include "HardwareProfile.h" is moved up in the order. 
....................           3) "SPI_INTERRUPT_FLAG_ASM" macro has to be defined in "HardwareProfile.h" file 
....................              for PIC18 microcontrollers.Or else an error is generated while building 
....................              the code. 
....................                        "#define SPI_INTERRUPT_FLAG_ASM  PIR1, 3" is removed from SD-SPI.c 
....................           4) Replaced "__C30" usage with "__C30__" . 
....................   1.3.6   1) Modified "FSConfig.h" to "FSconfig.h" in '#include' directive. 
....................           2) Moved 'spiconvalue' variable definition to only C30 usage, as C32 
....................              is not using it. 
....................           3) Modified 'MDD_SDSPI_MediaDetect' function to ensure that CMD0 is sent freshly 
....................              after CS is asserted low. This minimizes the risk of SPI clock pulse master/slave 
....................              syncronization problems. 
....................  
.................... ********************************************************************/ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *					dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *					Microchip C30 v3.01 or higher 
....................  *					Microchip C18 v3.13 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006	Original, copied from old Compiler.h 
....................  * 11/07/2007	Reorganized and simplified 
....................  * 03/31/2010	Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__PCH__) 
....................    #include <p18cxxx.h> 
.................... #elif defined(__PCD__) 
....................    #include <..\OsmobotSDCard\CCSIncludes\PCDxxxx.h> 
.................... #elif defined(__18CXX) && !defined(HI_TECH_C)	 
.................... 	// PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)	 
.................... 	// PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
.................... 	#if !defined(__18CXX) 
.................... 		#define __18CXX 
.................... 	#endif 
....................     #define COMPILER_HITECH_PICC18 
.................... 	#include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p30fxxxx.h> 
.................... #elif defined(__C30__)		// Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p30sim.h> 
.................... 	// Define some useful inline assembly functions which are normally in the  
.................... 	// processor header files, but absent from the generic p30sim.h file. 
.................... 	#if !defined(Nop) 
.................... 		#define Nop()    __builtin_nop() 
.................... 		#define ClrWdt() {__asm__ volatile ("clrwdt");} 
.................... 		#define Sleep()  {__asm__ volatile ("pwrsav #0");} 
.................... 		#define Idle()   {__asm__ volatile ("pwrsav #1");} 
.................... 	#endif 
.................... #elif defined(__PIC32MX__)	// Microchip C32 compiler 
.................... 	#if !defined(__C32__) 
.................... 		#define __C32__ 
.................... 	#endif 
....................     #define COMPILER_MPLAB_C32 
.................... 	#include <p32xxxx.h> 
.................... 	#include <plib.h> 
.................... #else 
.................... 	#error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
.................... #include <string.h> 
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PIC32MX__) 
.................... 	#define PTR_BASE		unsigned long 
.................... 	#define ROM_PTR_BASE	unsigned long 
.................... #elif defined(__C30__) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
.................... 	#define memcmppgm2ram(a,b,c)	memcmp(a,b,c) 
.................... 	#define strcmppgm2ram(a,b)		strcmp(a,b) 
.................... 	#define memcpypgm2ram(a,b,c)	memcpy(a,b,c) 
.................... 	#define strcpypgm2ram(a,b)		strcpy(a,b) 
.................... 	#define strncpypgm2ram(a,b,c)	strncpy(a,b,c) 
.................... 	#define strstrrampgm(a,b)		strstr(a,b) 
.................... 	#define	strlenpgm(a)			strlen(a) 
.................... 	#define strchrpgm(a,b)			strchr(a,b) 
.................... 	#define strcatpgm2ram(a,b)		strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
.................... 	#define	__attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
.................... 	// Microchip C18 specific defines 
.................... 	#if defined(COMPILER_MPLAB_C18) 
.................... 	    #define ROM                 	rom 
.................... 	#endif 
.................... 	 
.................... 	// HI TECH PICC-18 specific defines 
.................... 	#if defined(COMPILER_HITECH_PICC18) 
.................... 	    #define ROM                 	const 
.................... 		#define rom 
.................... 	    #define Nop()               	asm("NOP"); 
.................... 		#define ClrWdt()				asm("CLRWDT"); 
.................... 	    #define Reset()					asm("RESET"); 
.................... 	#endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
.................... 	#define	ROM						const 
....................  
.................... 	// 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
.................... 	#if defined(__C30__) 
.................... 		#define Reset()				asm("reset") 
....................         #define FAR                 __attribute__((far)) 
.................... 	#endif 
....................  
.................... 	// 32-bit specific defines (PIC32) 
.................... 	#if defined(__PIC32MX__) 
.................... 		#define persistent 
.................... 		#define far 
....................         #define FAR 
.................... 		#define Reset()				SoftReset() 
.................... 		#define ClrWdt()			(WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
.................... 		// MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
.................... 		// Nop() function. However, version 1.05 has Nop() declared as _nop(). 
.................... 		#if !defined(Nop) && (__C32_VERSION__ <= 104) 
.................... 			#define Nop()				asm("nop") 
.................... 		#endif 
.................... 	#endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "HardwareProfile.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        HardwareProfile.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _MDD_HARDWAREPROFILE_H_ 
.................... #define _MDD_HARDWAREPROFILE_H_ 
....................  
.................... /*********************************************************************/ 
.................... /******************* Pin and Register Definitions ********************/ 
.................... /*********************************************************************/ 
....................  
.................... /* SD Card definitions: Change these to fit your application when using 
....................    an SD-card-based physical layer                                   */ 
....................  
.................... #if defined(HW_CCS_PIC24USB) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
.................... // ccs dsp analog board with sd connector 
....................  
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
.................... //        #define GetSystemClock() getenv("CLOCK") 
.................... //        #define GetPeripheralClock()    GetSystemClock() 
....................  //       #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATGbits.LATG8      //pin_G8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISGbits.TRISG8 
....................  
.................... //This is the old setup  December 30, 2014 
....................         // Description: SD-SPI Chip Select Output bit 
....................         //#define SD_CS            LATBbits.LATB14      //pin_b14 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         //#define SD_CS_TRIS          TRISBbits.TRISB14 
....................  
....................         #define SD_CD            PORTBbits.RB12      //pin_b12 
....................         #define SD_CD_TRIS       TRISBbits.TRISB12 
....................  
....................          //NO SD_WE_TRIS         
....................          int1 SD_WE_TRIS; 
....................          int1 SD_WE=0; 
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI1CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI1STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI1BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI1STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI1STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI1CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI1STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The main SPI control register 
....................         //#define SPICON1             SPI2CON1 
....................         // Description: The SPI status register 
....................         //#define SPISTAT             SPI2STAT 
....................         // Description: The SPI Buffer 
....................         //#define SPIBUF              SPI2BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         //#define SPISTAT_RBF         SPI2STATbits.SPIRBF 
....................         //#define SPISTAT_TBF         SPI2STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         //#define SPICON1bits         SPI2CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         //#define SPISTATbits         SPI2STATbits 
....................         // Description: The enable bit for the SPI module 
....................         //#define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................  
....................        // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISFbits.TRISF3 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISFbits.TRISF6 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISFbits.TRISF2 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         //#define SPICLOCK            TRISGbits.TRISG6 
....................         // Description: The TRIS bit for the SDI pin 
....................         //#define SPIIN               TRISGbits.TRISG7 
....................         // Description: The TRIS bit for the SDO pin 
....................         //#define SPIOUT              TRISGbits.TRISG8 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "MDD File System/FSIO.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSIO.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  *                  FSconfig.h 
....................  *                  FSDefs.h 
....................  *                  stddef.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.4.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  FS_DOT_H 
.................... #define  FS_DOT_H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... #include "../FSconfig.h" 
.................... #include "FSDefs.h"  
.................... #include "stddef.h" 
....................  
.................... #ifdef USE_SD_INTERFACE_WITH_SPI 
....................     #include    "SD-SPI.h" 
.................... #endif 
.................... #ifdef USE_CF_INTERFACE_WITH_PMP 
....................     #include    "CF-PMP.h" 
.................... #endif 
.................... #ifdef USE_MANUAL_CF_INTERFACE 
....................     #include    "CF- Bit transaction.h" 
.................... #endif 
.................... #ifdef USE_USB_INTERFACE 
....................     #include    "usb_host_msd_scsi.h" 
.................... #endif 
.................... #ifdef USE_INTERNAL_FLASH 
....................     #include    "Internal Flash.h" 
.................... #endif 
....................  
....................  
.................... /*******************************************************************/ 
.................... /*                     Strunctures and defines                     */ 
.................... /*******************************************************************/ 
....................  
.................... #ifndef FALSE 
....................     // Summary: False value 
....................     // Description:  This macro will indicate that a condition is false. 
....................     #define FALSE   0 
.................... #endif 
.................... #ifndef TRUE 
....................     // Summary: True value 
....................     // Description: This macro will indicate that a condition is true. 
....................     #define TRUE    !FALSE  // True value 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #ifndef SEEK_SET 
....................     // Summary: Macro for the FSfseek SEEK_SET base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed  
....................     //              relative to the beginning of the file. 
....................     #define SEEK_SET 0 
....................  
.................... #endif 
.................... #ifndef SEEK_CUR 
....................  
....................     // Summary: Macro for the FSfseek SEEK_CUR base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the current location of the file 
....................     #define SEEK_CUR 1 
....................  
.................... #endif 
.................... #ifndef SEEK_END 
....................  
....................     // Summary: Macro for the FSfseek SEEK_END base location 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the end of the file.  For this macro, the offset value will be subtracted from 
....................     //              the end location of the file by default. 
....................     #define SEEK_END 2 
....................  
.................... #endif 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file. 
.................... #define FS_APPEND   "a" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file. 
.................... #define FS_WRITE    "w" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file. 
.................... #define FS_READ "r" 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file 
.................... //              or read from the file. 
.................... #define FS_APPENDPLUS   "a+" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file or read from the file. 
.................... #define FS_WRITEPLUS    "w+" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file or write to the file. 
.................... #define FS_READPLUS     "r+" 
....................  
.................... #ifndef intmax_t 
....................     #ifdef __PIC24F__ 
....................         // Summary: A data type indicating the maximum integer size in an architecture 
....................         // Description: The intmax_t data type refers to the maximum-sized data type on any given architecture.  This 
....................         //              data type can be specified as a format specifier size specification for the FSfprintf function. 
....................         #define intmax_t long long 
....................     #elif defined __PIC24H__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC30F__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC33F__ 
....................         #define intmax_t long long 
....................     #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary:  Indicates flag conditions for a file object 
.................... // Description: The FILEFLAGS structure is used to indicate conditions in a file.  It contains three flags: 'write' indicates 
.................... //              that the file was opened in a mode that allows writes, 'read' indicates that the file was opened in a mode 
.................... //              that allows reads, and 'FileWriteEOF' indicates that additional data that is written to the file will increase 
.................... //              the file size. 
.................... typedef struct 
.................... { 
....................     unsigned    write :1;           // Indicates a file was opened in a mode that allows writes 
....................     unsigned    read :1;            // Indicates a file was opened in a mode that allows reads 
....................     unsigned    FileWriteEOF :1;    // Indicates the current position in a file is at the end of the file 
.................... }FILEFLAGS; 
....................  
....................  
....................  
.................... // Summary: Indicates how to search for file entries in the FILEfind function 
.................... // Description: The values in the SEARCH_TYPE enumeration are used internally by the library to indicate how the FILEfind function 
.................... //              how to perform a search.  The 'LOOK_FOR_EMPTY_ENTRY' value indicates that FILEfind should search for an empty file entry. 
.................... //              The 'LOOK_FOR_MATCHING_ENTRY' value indicates that FILEfind should search for an entry that matches the FSFILE object 
.................... //              that was passed into the FILEfind function. 
.................... typedef enum{ 
....................     LOOK_FOR_EMPTY_ENTRY = 0, 
....................     LOOK_FOR_MATCHING_ENTRY 
.................... } SEARCH_TYPE; 
....................  
....................  
....................  
.................... // Summary: Macro indicating the length of a 8.3 file name 
.................... // Description: The TOTAL_FILE_SIZE_8P3 macro indicates the maximum number of characters in an 8.3 file name.  This value includes 
.................... //              8 characters for the name, three for the extentsion, and 1 for the radix ('.') 
.................... #define TOTAL_FILE_SIZE_8P3             (8+3+1) 
.................... #define TOTAL_FILE_SIZE                 TOTAL_FILE_SIZE_8P3 
....................  
.................... // Summary: Macro indicating the max length of a LFN file name 
.................... // Description: The MAX_FILE_NAME_LENGTH_LFN macro indicates the maximum number of characters in an LFN file name. 
.................... #define MAX_FILE_NAME_LENGTH_LFN             256 
....................  
.................... // Summary: A mask that indicates the limit of directory entries in a sector 
.................... // Description: The MASK_MAX_FILE_ENTRY_LIMIT_BITS is used to indicate to the Cache_File_Entry function that a new sector needs to 
.................... //              be loaded. 
.................... #define MASK_MAX_FILE_ENTRY_LIMIT_BITS          0x0f 
....................  
.................... // Summary: Value used for shift operations to calculate the sector offset in a directory 
.................... // Description: The VALUE_BASED_ON_ENTRIES_PER_CLUSTER macro is used to calculate sector offsets for directories.  The position of the 
.................... //              entry is shifted by 4 bits (divided by 16, since there are 16 entries in a sector) to calculate how many sectors a 
.................... //              specified entry is offset from the beginning of the directory. 
.................... #define VALUE_BASED_ON_ENTRIES_PER_CLUSTER      4 
....................  
.................... // Summary: A value that will indicate that a dotdot directory entry points to the root. 
.................... // Description: The VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT macro is used as an absolute address when writing information to a dotdot entry 
.................... //              in a newly created directory.  If a dotdot entry points to the root directory, it's cluster value must be set to 0, 
.................... //              regardless of the actual cluster number of the root directory. 
.................... #define VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT     0 
....................  
.................... // Summary: MAcro indicating the length of an 8.3 file name in a directory entry 
.................... // Description: The FILE_NAME_SIZE_8P3 macro indicates the number of characters that an 8.3 file name will take up when packed in 
.................... //              a directory entry.  This value includes 8 characters for the name and 3 for the extension.  Note that the radix is not 
.................... //              stored in the directory entry. 
.................... #define FILE_NAME_SIZE_8P3           11 
.................... #define FILE_NAME_SIZE               FILE_NAME_SIZE_8P3 
....................  
....................  
.................... // Summary: Contains file information and is used to indicate which file to access. 
.................... // Description: The FSFILE structure is used to hold file information for an open file as it's being modified or accessed.  A pointer to  
.................... //              an open file's FSFILE structure will be passeed to any library function that will modify that file. 
.................... typedef struct 
.................... { 
....................     DISK    *       dsk;            // Pointer to a DISK structure 
....................     DWORD           cluster;        // The first cluster of the file 
....................     DWORD           ccls;           // The current cluster of the file 
....................     WORD            sec;            // The current sector in the current cluster of the file 
....................     WORD            pos;            // The position in the current sector 
....................     DWORD           seek;           // The absolute position in the file 
....................     DWORD           size;           // The size of the file 
....................     FILEFLAGS       flags;          // A structure containing file flags 
....................     WORD            time;           // The file's last update time 
....................     WORD            date;           // The file's last update date 
....................     char            name[FILE_NAME_SIZE_8P3];       // The short name of the file 
....................    #ifdef SUPPORT_LFN 
....................        BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNptr;           // Pointer to long file name in UTF16 format 
....................       unsigned short int utf16LFNlength;          // LFN length in terms of words excluding the NULL word at the last. 
....................    #endif 
....................     WORD            entry;          // The position of the file's directory entry in it's directory 
....................     WORD            chk;            // File structure checksum 
....................     WORD            attributes;     // The file attributes 
....................     DWORD           dirclus;        // The base cluster of the file's directory 
....................     DWORD           dirccls;        // The current cluster of the file's directory 
.................... } FSFILE; 
....................  
.................... /* Summary: Possible results of the FSGetDiskProperties() function. 
.................... ** Description: See the FSGetDiskProperties() function for more information. 
.................... */ 
.................... typedef enum 
.................... { 
....................     FS_GET_PROPERTIES_NO_ERRORS = 0, 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED, 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE, 
....................     FS_GET_PROPERTIES_STILL_WORKING = 0xFF 
.................... } FS_DISK_ERRORS; 
....................  
....................  
.................... /* Summary: Contains the disk search information, intermediate values, and results 
.................... ** Description: This structure is used in conjunction with the FSGetDiskProperties() 
.................... **              function.  See that function for more information about the usage. 
.................... */ 
.................... typedef struct 
.................... { 
....................     DISK *  disk;           /* pointer to the disk we are searching */ 
....................     BOOL    new_request;    /* is this a new request or a continued request */ 
....................     FS_DISK_ERRORS properties_status;  /* status of the last call of the function */ 
....................  
....................     struct 
....................     { 
....................         BYTE disk_format;           /* disk format: FAT12, FAT16, FAT32 */ 
....................         WORD sector_size;           /* sector size of the drive */ 
....................         BYTE sectors_per_cluster;   /* number of sectors per cluster */ 
....................         DWORD total_clusters;       /* the number of total clusters on the drive */ 
....................         DWORD free_clusters;        /* the number of free (unused) clusters on drive */ 
....................     } results;                      /* the results of the current search */ 
....................  
....................     struct 
....................     { 
....................         DWORD   c;      
....................         DWORD   curcls; 
....................         DWORD   EndClusterLimit; 
....................         DWORD   ClusterFailValue; 
....................     } private;      /* intermediate values used to continue searches.  This 
....................                          member should be used only by the FSGetDiskProperties() 
....................                          function */ 
....................  
.................... } FS_DISK_PROPERTIES; 
....................  
.................... // Summary: A structure used for searching for files on a device. 
.................... // Description: The SearchRec structure is used when searching for file on a device.  It contains parameters that will be loaded with 
.................... //              file information when a file is found.  It also contains the parameters that the user searched for, allowing further 
.................... //              searches to be perfomed in the same directory for additional files that meet the specified criteria. 
.................... typedef struct 
.................... { 
....................     char            filename[FILE_NAME_SIZE_8P3 + 2];   // The name of the file that has been found 
....................     unsigned char   attributes;                     // The attributes of the file that has been found 
....................     unsigned long   filesize;                       // The size of the file that has been found 
....................     unsigned long   timestamp;                      // The last modified time of the file that has been found (create time for directories) 
....................    #ifdef SUPPORT_LFN 
....................       BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNfound;          // Pointer to long file name found in UTF16 format 
....................       unsigned short int utf16LFNfoundLength;     // LFN Found length in terms of words including the NULL word at the last. 
....................    #endif 
....................     unsigned int    entry;                          // The directory entry of the last file found that matches the specified attributes. (Internal use only) 
....................     char            searchname[FILE_NAME_SIZE_8P3 + 2]; // The 8.3 format name specified when the user began the search. (Internal use only) 
....................     unsigned char   searchattr;                     // The attributes specified when the user began the search. (Internal use only) 
....................     unsigned long   cwdclus;                        // The directory that this search was performed in. (Internal use only) 
....................     unsigned char   initialized;                    // Check to determine if the structure was initialized by FindFirst (Internal use only) 
.................... } SearchRec; 
....................  
....................  
.................... /*************************************************************************** 
.................... * Prototypes                                                               * 
.................... ***************************************************************************/ 
....................  
....................  
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     int FSInit(void) 
....................   Summary: 
....................     Function to initialize the device. 
....................   Conditions: 
....................     The physical device should be connected to the microcontroller. 
....................   Input: 
....................     None 
....................   Return Values: 
....................     TRUE -  Initialization successful 
....................     FALSE - Initialization unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function initializes the file system stack & the interfacing device. 
....................     Initializes the static or dynamic memory slots for holding file 
....................     structures. Initializes the device with the DISKmount function. Loads  
....................     MBR and boot sector information. Initializes the current working 
....................     directory to the root directory for the device if directory support 
....................     is enabled. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... int FSInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * FSfopen (const char * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with ascii input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will open a ascii name file or directory on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * FSfopen(const char * fileName, const char *mode); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * wFSfopen (const unsigned short int * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * wFSfopen(const unsigned short int * fileName, const char *mode); 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................  
.................... /****************************************************************************** 
....................   Function: 
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode) 
....................   Summary: 
....................     Opens a file on PIC18 Microcontrollers where 'fileName' ROM string is given 
....................     in Ascii format. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to be opened (ROM) 
....................     mode -      The mode the file will be opened in (ROM) 
....................   Return Values: 
....................     FSFILE * - A pointer to the file object 
....................     NULL -     File could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file on PIC18 Microcontrollers where 'fileName' ROM string 
....................     is given in Ascii format.The FSfopenpgm function will copy a PIC18 ROM fileName and 
....................     mode argument into RAM arrays, and then pass those arrays to the FSfopen function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   ******************************************************************************/ 
....................  
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode); 
....................  
....................  
.................... /************************************************************************************** 
....................   Function: 
....................     int FindFirstpgm (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Find a file named with a ROM string on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName -  The name of the file to be found (ROM) 
....................     attr -      The attributes of the file to be found 
....................     rec -       Pointer to a search record to store the file info in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the given parameters was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirstpgm call on passed SearchRec object 
....................     will be lost.The FSerrno variable will be changed. 
....................   Description: 
....................     This function finds a file named with 'fileName' on PIC18. The FindFirstpgm 
....................     function will copy a PIC18 ROM fileName argument into a RAM array, and then 
....................     pass that array to the FindFirst function. 
....................   Remarks: 
....................     Call FindFirstpgm or FindFirst before calling FindNext. 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************************/ 
....................  
....................     int FindFirstpgm (const rom char * fileName, unsigned int attr, SearchRec * rec); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdirpgm (const rom char * path) 
....................   Summary: 
....................     Changes the CWD to the input path on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to (ROM) 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the CWD to the input path on PIC18.The FSchdirpgm function 
....................     passes a PIC18 ROM path pointer to the chdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM 
....................   **************************************************************************/ 
....................  
....................     int FSchdirpgm (const rom char * path); 
....................  
....................     #ifdef ALLOW_WRITES 
....................  
....................  
.................... /************************************************************* 
....................   Function: 
....................     int FSremovepgm (const rom char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC18 device 
....................   Conditions: 
....................     File not opened; file exists 
....................   Input: 
....................     fileName -  The name of the file to be deleted (ROM) 
....................   Return Values: 
....................     0 -  File was removed successfully 
....................     -1 - File could not be removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC18 device.The FSremovepgm function will copy a 
....................     PIC18 ROM fileName argument into a RAM array, and then pass that array 
....................     to the FSremove function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   *************************************************************/ 
....................  
....................         int FSremovepgm (const rom char * fileName); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdirpgm (const rom char * path) 
....................   Summary: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create (ROM) 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices.'FSmkdirpgm' creates the directories as per the input 
....................     string path.This function doesn't move the current working 
....................     directory setting. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arugments in ROM 
....................   **************************************************************************/ 
....................  
....................         int FSmkdirpgm (const rom char * path); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdirpgm (const rom char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     path -      The path of the directory to remove (ROM) 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................     This function deletes the directory as specified in the path. 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************/ 
....................  
....................         int FSrmdirpgm (const rom char * path, unsigned char rmsubdirs); 
....................  
....................  
.................... /***************************************************************** 
....................   Function: 
....................     int FSrenamepgm(const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the file with the ascii ROM string(PIC18) 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file (in ROM) 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -  File renamed successfully 
....................     -1 - File could not be renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the file with the ascii ROM string(PIC18).The Fsrenamepgm 
....................     function will copy the rom fileName specified by the user into a  
....................     RAM array and pass that array into the FSrename function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM.                        
....................   *****************************************************************/ 
....................  
....................         int FSrenamepgm (const rom char * fileName, FSFILE * fo); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************ 
....................   Function: 
....................     int FSfclose(FSFILE *fo) 
....................   Summary: 
....................     Update file information and free FSFILE objects 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to the file to close 
....................   Return Values: 
....................     0 -   File closed successfully  
....................     EOF - Error closing the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will update the directory entry for the  
....................     file pointed to by 'fo' with the information contained 
....................     in 'fo,' including the new file size and attributes. 
....................     Timestamp information will also be loaded based on the 
....................     method selected by the user and written to the entry 
....................     as the last modified time and date.  The file entry will 
....................     then be written to the device.  Finally, the memory 
....................     used for the specified file object will be freed from 
....................     the dynamic heap or the array of FSFILE objects. 
....................   Remarks: 
....................     A function to flush data to the device without closing the 
....................     file can be created by removing the portion of this 
....................     function that frees the memory and the line that clears 
....................     the write flag. 
....................   ************************************************************/ 
....................  
.................... int FSfclose(FSFILE *fo); 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     void FSrewind (FSFILE * fo) 
....................   Summary: 
....................     Set the current position in a file to the beginning 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The FSrewind funciton will reset the position of the 
....................     specified file to the beginning of the file.  This 
....................     functionality is faster than using FSfseek to reset 
....................     the position in the file. 
....................   Remarks: 
....................     None. 
....................   *********************************************************/ 
....................  
.................... void FSrewind (FSFILE *fo); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Read data from a file 
....................   Conditions: 
....................     File is opened in a read mode 
....................   Input: 
....................     ptr -     Destination buffer for read bytes 
....................     size -    Size of units in bytes 
....................     n -       Number of units to be read 
....................     stream -  File to be read from 
....................   Return: 
....................     size_t - number of units read 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfread function will read data from the specified file.  First, 
....................     the appropriate sector of the file is loaded.  Then, data is read into 
....................     the specified buffer until the specified number of bytes have been read. 
....................     When a cluster boundary is reached, a new cluster will be loaded.  The 
....................     parameters 'size' and 'n' indicate how much data to read.  'Size' 
....................     refers to the size of one object to read (in bytes), and 'n' will refer  
....................     to the number of these objects to read.  The value returned will be equal  
....................     to 'n' unless an error occured or the user tried to read beyond the end 
....................     of the file. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream); 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FSfseek(FSFILE *stream, long offset, int whence) 
....................   Summary: 
....................     Change the current position in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     stream -    Pointer to file structure 
....................     offset -    Offset from base location 
....................     whence -     
....................            - SEEK_SET -  Seek from start of file 
....................            - SEEK_CUR -  Seek from current location 
....................            - SEEK_END -  Seek from end of file (subtract offset) 
....................   Return Values: 
....................     0 -  Operation successful  
....................     -1 - Operation unsuccesful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfseek function will change the current position in the file to 
....................     one specified by the user.  First, an absolute offset is calculated 
....................     using the offset and base location passed in by the user.  Then, the 
....................     position variables are updated, and the sector number that corresponds 
....................     to the new location.  That sector is then loaded.  If the offset 
....................     falls exactly on a cluster boundary, a new cluster will be allocated 
....................     to the file and the position will be set to the first byte of that 
....................     cluster. 
....................   Remarks: 
....................     None                                                                
....................   **********************************************************************/ 
....................  
.................... int FSfseek(FSFILE *stream, long offset, int whence); 
....................  
....................  
.................... /******************************************************************* 
....................   Function: 
....................     long FSftell (FSFILE * fo) 
....................   Summary: 
....................     Determine the current location in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return: Current location in the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     The FSftell function will return the current position in the 
....................     file pointed to by 'fo' by returning the 'seek' variable in the 
....................     FSFILE object, which is used to keep track of the absolute 
....................     location of the current position in the file. 
....................   Remarks: 
....................     None                                                             
....................   *******************************************************************/ 
....................  
.................... long FSftell(FSFILE *fo); 
....................  
....................  
.................... /**************************************************** 
....................   Function: 
....................     int FSfeof( FSFILE * stream ) 
....................   Summary: 
....................     Indicate whether the current file position is at the end 
....................   Conditions: 
....................     File is open in a read mode 
....................   Input: 
....................     stream -  Pointer to the target file 
....................   Return Values: 
....................     Non-Zero - EOF reached  
....................     0 - Not at end of File 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfeof function will indicate that the end-of- 
....................     file has been reached for the specified file by 
....................     comparing the absolute location in the file to the 
....................     size of the file. 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... int FSfeof( FSFILE * stream ); 
....................  
....................  
.................... #ifdef ALLOW_FORMATS 
.................... /******************************************************************* 
....................   Function: 
....................     int FSformat (char mode, long int serialNumber, char * volumeID) 
....................   Summary: 
....................     Formats a device 
....................   Conditions: 
....................     The device must possess a valid master boot record. 
....................   Input: 
....................     mode -          - 0 - Just erase the FAT and root 
....................                     - 1 - Create a new boot sector 
....................     serialNumber -  Serial number to write to the card 
....................     volumeID -      Name of the card 
....................   Return Values: 
....................     0 -    Format was successful 
....................     EOF -  Format was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSformat function can be used to create a new boot sector 
....................     on a device, based on the information in the master boot record. 
....................     This function will first initialize the I/O pins and the device, 
....................     and then attempts to read the master boot record.  If the MBR 
....................     cannot be loaded successfully, the function will fail.  Next, if 
....................     the 'mode' argument is specified as '0' the existing boot sector 
....................     information will be loaded.  If the 'mode' argument is '1' an 
....................     entirely new boot sector will be constructed using the disk 
....................     values from the master boot record.  Once the boot sector has 
....................     been successfully loaded/created, the locations of the FAT and 
....................     root will be loaded from it, and they will be completely 
....................     erased.  If the user has specified a volumeID parameter, a  
....................     VOLUME attribute entry will be created in the root directory 
....................     to name the device. 
....................  
....................     FAT12, FAT16 and FAT32 formatting are supported. 
....................  
....................     Based on the number of sectors, the format function automatically 
....................     compute the smallest possible value for the cluster size in order to 
....................     accommodate the physical size of the media. In this case, if a media  
....................     with a big capacity is formatted, the format function may take a very 
....................     long time to write all the FAT tables.  
....................  
....................     Therefore, the FORMAT_SECTORS_PER_CLUSTER macro may be used to  
....................     specify the exact cluster size (in multiples of sector size). This  
....................     macro can be defined in FSconfig.h 
....................  
....................   Remarks: 
....................     Only devices with a sector size of 512 bytes are supported by the  
....................     format function                       
....................   *******************************************************************/ 
....................  
.................... int FSformat (char mode, long int serialNumber, char * volumeID); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_WRITES 
.................... /*************************************************************************** 
....................   Function: 
....................     int FSattrib (FSFILE * file, unsigned char attributes) 
....................   Summary: 
....................     Change the attributes of a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     file -        Pointer to file structure 
....................     attributes -  The attributes to set for the file 
....................                -  Attribute -      Value - Indications  
....................                -  ATTR_READ_ONLY - 0x01  - The read-only attribute 
....................                -  ATTR_HIDDEN -    0x02  - The hidden attribute  
....................                -  ATTR_SYSTEM -    0x04  - The system attribute  
....................                -  ATTR_ARCHIVE -   0x20  - The archive attribute 
....................   Return Values: 
....................     0 -  Attribute change was successful  
....................     -1 - Attribute change was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSattrib funciton will set the attributes of the specified file 
....................     to the attributes passed in by the user.  This function will load the 
....................     file entry, replace the attributes with the ones specified, and write 
....................     the attributes back.  If the specified file is a directory, the 
....................     directory attribute will be preserved. 
....................   Remarks: 
....................     None                                                                 
....................   ***************************************************************************/ 
....................  
.................... int FSattrib (FSFILE * file, unsigned char attributes); 
....................  
....................  
.................... /*************************************************************** 
....................   Function: 
....................     int FSrename (const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices. 
....................     First, it will search through the current working directory to ensure the 
....................     specified new filename is not already in use. If it isn't, the new filename 
....................     will be written to the file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None                                                         
....................   ***************************************************************/ 
....................  
.................... int FSrename (const char * fileName, FSFILE * fo); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*************************************************************** 
....................   Function: 
....................     int wFSrename (const rom unsigned short int * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices. First, it will search through the current 
....................     working directory to ensure the specified new UTF16 filename is not 
....................     already in use.  If it isn't, the new filename will be written to the 
....................     file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None 
....................   ***************************************************************/ 
....................  
.................... int wFSrename (const unsigned short int * fileName, FSFILE * fo); 
.................... #endif 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     int FSremove (const char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed  
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................     The FSremove function will attempt to find the specified file with the FILEfind 
....................     function.  If the file is found, it will be erased using the FILEerase function. 
....................     The user can also provide ascii alias name of the ascii long file name as the 
....................     input to this function to get it erased from the memory. 
....................   Remarks: 
....................     None                                        
....................   **********************************************************************/ 
....................  
.................... int FSremove (const char * fileName); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     int wFSremove (const unsigned short int * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed 
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................     The wFSremove function will attempt to find the specified UTF16 file 
....................     name with the FILEfind function. If the file is found, it will be erased 
....................     using the FILEerase function. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int wFSremove (const unsigned short int * fileName); 
.................... #endif 
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Write data to a file 
....................   Conditions: 
....................     File opened in FS_WRITE, FS_APPEND, FS_WRITE+, FS_APPEND+, FS_READ+ mode 
....................   Input: 
....................     data_to_write -     Pointer to source buffer 
....................     size -              Size of units in bytes 
....................     n -                 Number of units to transfer 
....................     stream -            Pointer to file structure 
....................   Return: 
....................     size_t - number of units written 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfwrite function will write data to a file.  First, the sector that 
....................     corresponds to the current position in the file will be loaded (if it hasn't 
....................     already been cached in the global data buffer).  Data will then be written to 
....................     the device from the specified buffer until the specified amount has been written. 
....................     If the end of a cluster is reached, the next cluster will be loaded, unless 
....................     the end-of-file flag for the specified file has been set.  If it has, a new 
....................     cluster will be allocated to the file.  Finally, the new position and filesize 
....................     will be stored in the FSFILE object.  The parameters 'size' and 'n' indicate how  
....................     much data to write.  'Size' refers to the size of one object to write (in bytes),  
....................     and 'n' will refer to the number of these objects to write.  The value returned  
....................     will be equal  to 'n' unless an error occured. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************************/ 
....................  
.................... size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream); 
....................  
.................... #endif 
....................  
.................... #ifdef ALLOW_DIRS 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdir (char * path) 
....................   Summary: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC). 
....................     The FSchdir function passes a RAM pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSchdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSchdir (unsigned short int * path) 
....................   Summary: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC).The FSchdir function passes a RAM 
....................     pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSchdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************** 
....................   Function: 
....................     char * FSgetcwd (char * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in Ascii format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in Ascii format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * FSgetcwd (char * path, int numbchars); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************** 
....................   Function: 
....................     char * wFSgetcwd (unsigned short int * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in UTF16 format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in UTF16 format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * wFSgetcwd (unsigned short int * path, int numbchars); 
.................... #endif 
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdir (char * path) 
....................   Summary: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSmkdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSmkdir (unsigned short int * path) 
....................   Summary: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSmkdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdir (char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int FSrmdir (char * path, unsigned char rmsubdirs); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs) 
....................   Summary: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs); 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................  
....................  
.................... /*********************************************************************************************************** 
....................   Function: 
....................     int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second) 
....................   Summary: 
....................     Manually set timestamp variables 
....................   Conditions: 
....................     USERDEFINEDCLOCK macro defined in FSconfig.h. 
....................   Input: 
....................     year -     The year (1980\-2107) 
....................     month -   The month (1\-12) 
....................     day -     The day of the month (1\-31) 
....................     hour -    The hour (0\-23) 
....................     minute -  The minute (0\-59) 
....................     second -  The second (0\-59) 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     Modifies global timing variables 
....................   Description: 
....................     Lets the user manually set the timing variables.  The values passed in will be converted to the format 
....................     used by the FAT timestamps. 
....................   Remarks: 
....................     Call this before creating a file or directory (set create time) and 
....................     before closing a file (set last access time, last modified time)                                         
....................   ***********************************************************************************************************/ 
....................  
.................... int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_FILESEARCH 
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................     The FindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*********************************************************************************** 
....................   Function: 
....................     int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous wFindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent wFindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................     The wFindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec); 
.................... #endif 
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FindNext (SearchRec * rec) 
....................   Summary: 
....................     Sequential search function 
....................   Conditions: 
....................     None 
....................   Input: 
....................     rec -  The structure to store the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No additional files matching the specified criteria were found 
....................   Side Effects: 
....................     Search criteria from previous FindNext call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     The FindNext function performs the same function as the FindFirst 
....................     funciton, except it does not copy any search parameters into the 
....................     SearchRec structure (only info about found files) and it begins 
....................     searching at the last directory entry offset at which a file was 
....................     found, rather than at the beginning of the current working 
....................     directory.If the return value of the function is 0 then "utf16LFNfoundLength" 
....................     indicates whether the file found was long file name or short file 
....................     name(8P3 format). The "utf16LFNfoundLength" is non-zero for long file name 
....................     and is zero for 8P3 format."utf16LFNfound" points to the address of long  
....................     file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling this function 
....................   **********************************************************************/ 
....................  
.................... int FindNext (SearchRec * rec);  
.................... #endif 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int FSfprintf (FSFILE * fptr, const char * fmt, ...) 
....................     // PIC18 
....................     int FSfpritnf (FSFILE * fptr, const rom char * fmt, ...) 
....................   Summary: 
....................     Function to write formatted strings to a file 
....................   Conditions: 
....................     For PIC18, integer promotion must be enabled in the project build 
....................     options menu.  File opened in a write mode. 
....................   Input: 
....................     fptr - A pointer to the file to write to. 
....................     fmt -  A string of characters and format specifiers to write to 
....................            the file 
....................     ... -  Additional arguments inserted in the string by format 
....................            specifiers 
....................   Returns: 
....................     The number of characters written to the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Writes a specially formatted string to a file. 
....................   Remarks: 
....................     Consult AN1045 for a full description of how to use format 
....................     specifiers.         
....................   **********************************************************************/ 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................     #ifdef __18CXX 
....................         int FSfprintf (FSFILE *fptr, const rom char *fmt, ...); 
....................     #else 
....................         int FSfprintf (FSFILE *fptr, const char * fmt, ...); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSerror (void) 
....................   Summary: 
....................     Return an error code for the last function call 
....................   Conditions: 
....................     The return value depends on the last function called. 
....................   Input: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Return Values: 
....................     FSInit       -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The physical media could not be initialized 
....................                  - CE_BAD_SECTOR_READ        The MBR or the boot sector could not be 
....................                                               read correctly 
....................                  - CE_BAD_PARITION           The MBR signature code was incorrect. 
....................                  - CE_NOT_FORMATTED          The boot sector signature code was incorrect or 
....................                                               indicates an invalid number of bytes per sector.  
....................                  - CE_CARDFAT32              The physical media is FAT32 type (only an error  
....................                                               when FAT32 support is disabled).  
....................                  - CE_UNSUPPORTED_FS         The device is formatted with an unsupported file  
....................                                               system (not FAT12 or 16). 
....................     FSfopen      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The device has not been initialized.  
....................                  - CE_TOO_MANY_FILES_OPEN    The function could not allocate any  
....................                                               additional file information to the array  
....................                                               of FSFILE structures or the heap.  
....................                  - CE_INVALID_FILENAME       The file name argument was invalid. 
....................                  - CE_INVALID_ARGUMENT       The user attempted to open a directory in a  
....................                                               write mode or specified an invalid mode argument.  
....................                  - CE_FILE_NOT_FOUND         The specified file (which was to be opened in read  
....................                                               mode) does not exist on the device.  
....................                  - CE_BADCACHEREAD           A read from the device failed. 
....................                  - CE_ERASE_FAIL             The existing file could not be erased (when opening  
....................                                               a file in FS_WRITE mode).  
....................                  - CE_DIR_FULL               The directory is full.  
....................                  - CE_DISK_FULL              The data memory section is full.  
....................                  - CE_WRITE_ERROR            A write to the device failed.  
....................                  - CE_SEEK_ERROR             The current position in the file could not be set to  
....................                                               the end (when the file was opened in FS_APPEND mode). 
....................     FSfclose     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer or the new file 
....................                                               entry information could not be written to the device. 
....................                  - CE_BADCACHEREAD           The file entry information could not be cached 
....................     FSfread      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITEONLY              The file was opened in a write-only mode. 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device.  
....................                  - CE_BAD_SECTOR_READ        The data sector could not be read.  
....................                  - CE_EOF                    The end of the file was reached. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be loaded. 
....................     FSfwrite     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_READONLY               The file was opened in a read-only mode.  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected. 
....................                  - CE_WRITE_ERROR            There was an error writing data to the device. 
....................                  - CE_BADCACHEREAD           The data sector to be modified could not be read from 
....................                                               the device.  
....................                  - CE_DISK_FULL              All data clusters on the device are in use. 
....................     FSfseek      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device.  
....................                  - CE_INVALID_ARGUMENT       The specified offset exceeds the size of the file.  
....................                  - CE_BADCACHEREAD           The sector that contains the new current position  
....................                                               could not be loaded. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be  
....................                                               loaded/allocated. 
....................     FSftell      -  
....................                  - CE_GOOD                   No Error 
....................     FSattrib     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The attribute argument was invalid.  
....................                  - CE_BADCACHEREAD           The existing file entry information could not be  
....................                                               loaded.  
....................                  - CE_WRITE_ERROR            The file entry information could not be written to  
....................                                               the device. 
....................     FSrename     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_FILENOTOPENED          A null file pointer was passed into the function.  
....................                  - CE_INVALID_FILENAME       The file name passed into the function was invalid.  
....................                  - CE_BADCACHEREAD           A read from the device failed.  
....................                  - CE_FILENAME_EXISTS        A file with the specified name already exists.  
....................                  - CE_WRITE_ERROR            The new file entry data could not be written to the  
....................                                               device. 
....................     FSfeof       - 
....................                  - CE_GOOD                   No Error 
....................     FSformat     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The device could not be initialized.  
....................                  - CE_BADCACHEREAD           The master boot record or boot sector could not be  
....................                                               loaded successfully.  
....................                  - CE_INVALID_ARGUMENT       The user selected to create their own boot sector on  
....................                                               a device that has no master boot record, or the mode  
....................                                               argument was invalid.  
....................                  - CE_WRITE_ERROR            The updated MBR/Boot sector could not be written to  
....................                                               the device. 
....................                  - CE_BAD_PARTITION          The calculated number of sectors per clusters was  
....................                                               invalid.  
....................                  - CE_NONSUPPORTED_SIZE      The card has too many sectors to be formatted as  
....................                                               FAT12 or FAT16. 
....................     FSremove     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         The specified file could not be found. 
....................                  - CE_ERASE_FAIL             The file could not be erased. 
....................     FSchdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed or the user tried to  
....................                                               change to a non-directory file. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_FOUND          Could not find a directory in the path. 
....................     FSgetcwd     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The user passed a 0-length buffer into the function. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the current working directory. 
....................     FSmkdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed. 
....................                  - CE_BADCACHEREAD           Could not successfully change to a recently created  
....................                                               directory to store its dir entry information, or  
....................                                               could not cache directory entry information.  
....................                  - CE_INVALID_FILENAME       One or more of the directory names has an invalid  
....................                                               format.  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device or the dot/dotdot entries could  
....................                                               not be written to a newly created directory. 
....................                  - CE_DIR_FULL               There are no available dir entries in the CWD. 
....................                  - CE_DISK_FULL              There are no available clusters in the data region of  
....................                                               the device.     
....................     FSrmdir      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_DIR_NOT_FOUND          The directory specified could not be found or the  
....................                                               function could not change to a subdirectory within  
....................                                               the directory to be deleted (when recursive delete is  
....................                                               enabled). 
....................                  - CE_INVALID_ARGUMENT       The user tried to remove the CWD or root directory.  
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_EMPTY          The directory to be deleted was not empty and  
....................                                               recursive subdirectory removal was disabled.  
....................                  - CE_ERASE_FAIL             The directory or one of the directories or files  
....................                                               within it could not be deleted.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the CWD. 
....................     SetClockVars - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The time values passed into the function were  
....................                                               invalid.     
....................     FindFirst    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found.  
....................                  - CE_BADCACHEREAD           The file information for the file that was found  
....................                                               could not be cached. 
....................     FindNext     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The SearchRec object was not initialized by a call to  
....................                                               FindFirst.  
....................                  - CE_INVALID_ARGUMENT       The SearchRec object was initialized in a different  
....................                                               directory from the CWD. 
....................                  - CE_INVALID_FILENAME       The filename is invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found. 
....................     FSfprintf    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            Characters could not be written to the file.                                                    
....................   Description: 
....................     The FSerror function will return the FSerrno variable.  This global 
....................     variable will have been set to an error value during the last call of a 
....................     library function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... int FSerror (void); 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     int FSCreateMBR (unsigned long firstSector, unsigned long numSectors) 
....................   Summary: 
....................     Creates a master boot record 
....................   Conditions: 
....................     The I/O pins for the device have been initialized by the InitIO function. 
....................   Input: 
....................     firstSector -  The first sector of the partition on the device (cannot 
....................                    be 0; that's the MBR) 
....................     numSectors -   The number of sectors available in memory (including the 
....................                    MBR) 
....................   Return Values: 
....................     0 -   MBR was created successfully 
....................     EOF - MBR could not be created 
....................   Side Effects: 
....................     None 
....................   Description:   
....................     This function can be used to create a master boot record for a device.  Note 
....................     that this function should not be used on a device that is already formatted 
....................     with a master boot record (i.e. most SD cards, CF cards, USB keys).  This 
....................     function will fill the global data buffer with appropriate partition information 
....................     for a FAT partition with a type determined by the number of sectors available 
....................     to the partition.  It will then write the MBR information to the first sector 
....................     on the device.  This function should be followed by a call to FSformat, which 
....................     will create a boot sector, root dir, and FAT appropriate the the information 
....................     contained in the new master boot record.  Note that FSformat only supports 
....................     FAT12 and FAT16 formatting at this time, and so cannot be used to format a 
....................     device with more than 0x3FFD5F sectors. 
....................   Remarks: 
....................     This function can damage the device being used, and should not be called 
....................     unless the user is sure about the size of the device and the first sector value. 
....................   *********************************************************************************/ 
....................  
.................... int FSCreateMBR (unsigned long firstSector, unsigned long numSectors); 
....................  
....................  
.................... #ifdef ALLOW_GET_DISK_PROPERTIES 
.................... /********************************************************************************* 
....................   Function: 
....................     void FSGetDiskProperties(FS_DISK_PROPERTIES* properties) 
....................   Summary: 
....................     Allows user to get the disk properties (size of disk, free space, etc) 
....................   Conditions: 
....................     1) ALLOW_GET_DISK_PROPERTIES must be defined in FSconfig.h 
....................     2) a FS_DISK_PROPERTIES object must be created before the function is called 
....................     3) the new_request member of the FS_DISK_PROPERTIES object must be set before 
....................         calling the function for the first time.  This will start a new search. 
....................     4) this function should not be called while there is a file open.  Close all 
....................         files before calling this function. 
....................   Input: 
....................     properties - a pointer to a FS_DISK_PROPERTIES object where the results should 
....................       be stored. 
....................   Return Values: 
....................     This function returns void.  The properties_status of the previous call of  
....................       this function is located in the properties.status field.  This field has  
....................       the following possible values: 
....................  
....................     FS_GET_PROPERTIES_NO_ERRORS - operation completed without error.  Results 
....................       are in the properties object passed into the function. 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED - there is no mounted disk.  Results in 
....................       properties object is not valid 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE - there was a failure trying to read a  
....................       cluster from the drive.  The results in the properties object is a partial 
....................       result up until the point of the failure. 
....................     FS_GET_PROPERTIES_STILL_WORKING - the search for free sectors is still in 
....................       process.  Continue calling this function with the same properties pointer  
....................       until either the function completes or until the partial results meets the 
....................       application needs.  The properties object contains the partial results of 
....................       the search and can be used by the application.   
....................   Side Effects: 
....................     Can cause errors if called when files are open.  Close all files before 
....................     calling this function. 
....................  
....................     Calling this function without setting the new_request member on the first 
....................     call can result in undefined behavior and results. 
....................  
....................     Calling this function after a result is returned other than 
....................     FS_GET_PROPERTIES_STILL_WORKING can result in undefined behavior and results. 
....................   Description:   
....................     This function returns the information about the mounted drive.  The results  
....................     member of the properties object passed into the function is populated with  
....................     the information about the drive.     
....................  
....................     Before starting a new request, the new_request member of the properties 
....................     input parameter should be set to TRUE.  This will initiate a new search 
....................     request. 
....................  
....................     This function will return before the search is complete with partial results. 
....................     All of the results except the free_clusters will be correct after the first 
....................     call.  The free_clusters will contain the number of free clusters found up 
....................     until that point, thus the free_clusters result will continue to grow until 
....................     the entire drive is searched.  If an application only needs to know that a  
....................     certain number of bytes is available and doesn't need to know the total free  
....................     size, then this function can be called until the required free size is 
....................     verified.  To continue a search, pass a pointer to the same FS_DISK_PROPERTIES 
....................     object that was passed in to create the search. 
....................  
....................     A new search request sould be made once this function has returned a value  
....................     other than FS_GET_PROPERTIES_STILL_WORKING.  Continuing a completed search 
....................     can result in undefined behavior or results. 
....................  
....................     Typical Usage: 
....................     <code> 
....................     FS_DISK_PROPERTIES disk_properties; 
....................  
....................     disk_properties.new_request = TRUE; 
....................  
....................     do 
....................     { 
....................         FSGetDiskProperties(&disk_properties); 
....................     } while (disk_properties.properties_status == FS_GET_PROPERTIES_STILL_WORKING); 
....................     </code> 
....................  
....................     results.disk_format - contains the format of the drive.  Valid results are  
....................       FAT12(1), FAT16(2), or FAT32(3). 
....................  
....................     results.sector_size - the sector size of the mounted drive.  Valid values are 
....................       512, 1024, 2048, and 4096. 
....................  
....................     results.sectors_per_cluster - the number sectors per cluster. 
....................  
....................     results.total_clusters - the number of total clusters on the drive.  This  
....................       can be used to calculate the total disk size (total_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................     results.free_clusters - the number of free (unallocated) clusters on the drive. 
....................       This can be used to calculate the total free disk size (free_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................   Remarks: 
....................     PIC24F size estimates: 
....................       Flash - 400 bytes (-Os setting) 
....................  
....................     PIC24F speed estimates: 
....................       Search takes approximately 7 seconds per Gigabyte of drive space.  Speed 
....................         will vary based on the number of sectors per cluster and the sector size. 
....................   *********************************************************************************/ 
.................... void FSGetDiskProperties(FS_DISK_PROPERTIES* properties); 
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE FILEget_next_cluster(FSFILE *fo, DWORD n) 
....................   Summary: 
....................     Step through a chain of clusters 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fo - The file to get the next cluster of 
....................     n -  Number of links in the FAT cluster chain to jump through 
....................   Return Values: 
....................     CE_GOOD - Operation successful 
....................     CE_BAD_SECTOR_READ - A bad read occured of a sector 
....................     CE_INVALID_CLUSTER - Invalid cluster value \> maxcls 
....................     CE_FAT_EOF - Fat attempt to read beyond EOF 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will load 'n' proximate clusters for a file from 
....................     the FAT on the device.  It will stop checking for clusters if the 
....................     ReadFAT function returns an error, if it reaches the last cluster in 
....................     a file, or if the device tries to read beyond the last cluster used 
....................     by the device. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... BYTE FILEget_next_cluster(FSFILE *fo, DWORD n); 
....................  
.................... #endif 
....................  
.................... #include "MDD File System/FSDefs.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSDefs.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.2.4 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  _FSDEF__H 
.................... #define  _FSDEF__H 
....................  
.................... #include "../GenericTypeDefs.h" 
....................  
.................... // Summary: An enumeration used for various error codes. 
.................... // Description: The CETYPE enumeration is used to indicate different error conditions during device operation. 
.................... typedef enum _CETYPE 
.................... { 
....................     CE_GOOD = 0,                    // No error 
....................     CE_ERASE_FAIL,                  // An erase failed 
....................     CE_NOT_PRESENT,                 // No device was present 
....................     CE_NOT_FORMATTED,               // The disk is of an unsupported format 
....................     CE_BAD_PARTITION,               // The boot record is bad 
....................     CE_UNSUPPORTED_FS,              // The file system type is unsupported 
....................     CE_INIT_ERROR,                  // An initialization error has occured 
....................     CE_NOT_INIT,                    // An operation was performed on an uninitialized device 
....................     CE_BAD_SECTOR_READ,             // A bad read of a sector occured 
....................     CE_WRITE_ERROR,                 // Could not write to a sector 
....................     CE_INVALID_CLUSTER,             // Invalid cluster value > maxcls 
....................     CE_FILE_NOT_FOUND,              // Could not find the file on the device 
....................     CE_DIR_NOT_FOUND,               // Could not find the directory 
....................     CE_BAD_FILE,                    // File is corrupted 
....................     CE_DONE,                        // No more files in this directory 
....................     CE_COULD_NOT_GET_CLUSTER,       // Could not load/allocate next cluster in file 
....................     CE_FILENAME_2_LONG,             // A specified file name is too long to use 
....................     CE_FILENAME_EXISTS,             // A specified filename already exists on the device 
....................     CE_INVALID_FILENAME,            // Invalid file name 
....................     CE_DELETE_DIR,                  // The user tried to delete a directory with FSremove 
....................     CE_DIR_FULL,                    // All root dir entry are taken 
....................     CE_DISK_FULL,                   // All clusters in partition are taken 
....................     CE_DIR_NOT_EMPTY,               // This directory is not empty yet, remove files before deleting 
....................     CE_NONSUPPORTED_SIZE,           // The disk is too big to format as FAT16 
....................     CE_WRITE_PROTECTED,             // Card is write protected 
....................     CE_FILENOTOPENED,               // File not opened for the write 
....................     CE_SEEK_ERROR,                  // File location could not be changed successfully 
....................     CE_BADCACHEREAD,                // Bad cache read 
....................     CE_CARDFAT32,                   // FAT 32 - card not supported 
....................     CE_READONLY,                    // The file is read-only 
....................     CE_WRITEONLY,                   // The file is write-only 
....................     CE_INVALID_ARGUMENT,            // Invalid argument 
....................     CE_TOO_MANY_FILES_OPEN,         // Too many files are already open 
....................     CE_UNSUPPORTED_SECTOR_SIZE,     // Unsupported sector size 
....................     CE_EOF = 61 
.................... } CETYPE; 
....................  
....................  
.................... // Summary: A macro indicating a dir entry was found 
.................... // Description: The FOUND macro indicates that a directory entry was found in the specified position 
.................... #define FOUND       0 
....................  
.................... // Summary: A macro indicating no dir entry was found 
.................... // Description: The NOT_FOUND macro indicates that the specified directory entry to load was deleted 
.................... #define NOT_FOUND   1 
....................  
.................... // Summary: A macro indicating that no more files were found 
.................... // Description: The NO_MORE macro indicates that there are no more directory entries to search for 
.................... #define NO_MORE     2 
....................  
....................  
....................  
.................... // Summary: A macro indicating the device is formatted with FAT12 
.................... // Description: The FAT12 macro is used to indicate that the file system on the device being accessed is a FAT12 file system. 
.................... #define FAT12       1 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT16 
.................... // Description: The FAT16 macro is used to indicate that the file system on the device being accessed is a FAT16 file system. 
.................... #define FAT16       2 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT32 
.................... // Description: The FAT32 macro is used to indicate that the file system on the device being accessed is a FAT32 file system. 
.................... #define FAT32       3 
....................  
....................  
....................  
.................... // Summary: A read-only attribute macro 
.................... // Description: A macro for the read-only attribute.  A file with this attribute should not be written to.  Note that this 
.................... //              attribute will not actually prevent a write to the file; that functionality is operating-system dependant.  The 
.................... //              user should take care not to write to a read-only file. 
.................... #define ATTR_READ_ONLY      0x01 
....................  
.................... // Summary: A hidden attribute macro 
.................... // Description: A macro for the hidden attribute.  A file with this attribute may be hidden from the user, depending on the 
.................... //              implementation of the operating system. 
.................... #define ATTR_HIDDEN         0x02 
....................  
.................... // Summary: A system attribute macro 
.................... // Description: A macro for the system attribute.  A file with this attribute is used by the operating system, and should not be 
.................... //              modified.  Note that this attribute will not actually prevent a write to the file. 
.................... #define ATTR_SYSTEM         0x04 
....................  
.................... // Summary: A volume attribute macro 
.................... // Description: A macro for the volume attribute.  If the first directory entry in the root directory has the volume attribute set, 
.................... //              the device will use the name in that directory entry as the volume name. 
.................... #define ATTR_VOLUME         0x08 
....................  
.................... // Summary: A macro for the attributes for a long-file name entry 
.................... // Description: A macro for the long-name attributes.  If a directory entry is used in a long-file name implementation, it will have 
.................... //              all four lower bits set.  This indicates that any software that does not support long file names should ignore that 
.................... //              entry. 
.................... #define ATTR_LONG_NAME      0x0f 
....................  
.................... // Summary: A directory attribute macro 
.................... // Description: A macro for the directory attribute.  If a directory entry has this attribute set, the file it points to is a directory- 
.................... //              type file, and will contain directory entries that point to additional directories or files. 
.................... #define ATTR_DIRECTORY      0x10 
....................  
.................... // Summary: An archive attribute macro 
.................... // Description: A macro for the archive attribute.  This attribute will indicate to some archiving programs that the file with this 
.................... //              attribute needs to be backed up.  Most operating systems create files with the archive attribute set. 
.................... #define ATTR_ARCHIVE        0x20 
....................  
.................... // Summary: A macro for all attributes 
.................... // Description: A macro for all attributes.  The search functions in this library require an argument that determines which attributes 
.................... //              a file is allowed to have in order to be found.  If ATTR_MASK is specified as this argument, any file may be found, regardless 
.................... //              of its attributes. 
.................... #define ATTR_MASK           0x3f 
....................  
....................  
....................  
.................... // Summary: A macro to indicate an empty FAT entry 
.................... // Description: The CLUSTER_EMPTY value is used to indicate that a FAT entry and it's corresponding cluster are available. 
.................... #define CLUSTER_EMPTY               0x0000  
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT12 
.................... // Description: The LAST_CLUSTER_FAT12 macro is used when reading the FAT to indicate that the next FAT12 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT12          0xff8 
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT16 
.................... // Description: The LAST_CLUSTER_FAT16 macro is used when reading the FAT to indicate that the next FAT16 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT16          0xfff8 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT12 
.................... // Description: The END_CLUSTER_FAT12 value is used as a comparison in FAT12 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT12           0xFF7 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT16 
.................... // Description: The END_CLUSTER_FAT16 value is used as a comparison in FAT16 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT16           0xFFF7 
....................  
.................... // Summary: A macro to indicate the failure of the ReadFAT function 
.................... // Description: The CLUSTER_FAIL_FAT16 macro is used by the ReadFAT function to indicate that an error occured reading a FAT12 or FAT16 
.................... //              file allocation table.  Note that since '0xFFF8' is used for the last cluster return value in the FAT16 implementation 
.................... //              the end-of-file value '0xFFFF' can be used to indicate an error condition. 
.................... #define CLUSTER_FAIL_FAT16          0xFFFF 
....................  
....................  
....................  
.................... #ifdef SUPPORT_FAT32 
....................     // Summary: A macro to indicate the last cluster value for FAT32 
....................     // Description: The LAST_CLUSTER_FAT32 macro is used when reading the FAT to indicate that the next FAT32 entry for a file contains 
....................     //              the end-of-file value. 
....................     #define LAST_CLUSTER_FAT32      0x0FFFFFF8 
....................  
....................     // Summary: A macro to indicate the last allocatable cluster for FAT32 
....................     // Description: The END_CLUSTER_FAT32 value is used as a comparison in FAT32 to determine that the firmware has reached the end of 
....................     //              the range of allowed allocatable clusters. 
....................     #define END_CLUSTER_FAT32       0x0FFFFFF7 
....................  
....................     // Summary: A macro to indicate the failure of the ReadFAT function 
....................     // Description: The CLUSTER_FAIL_FAT32 macro is used by the ReadFAT function to indicate that an error occured reading a FAT32 
....................     //              file allocation able. 
....................     #define CLUSTER_FAIL_FAT32      0x0FFFFFFF 
....................  
.................... #endif 
....................  
.................... // Summary: A macro indicating the number of bytes in a directory entry. 
.................... // Description: The NUMBER_OF_BYTES_IN_DIR_ENTRY macro represents the number of bytes in one directory entry.  It is used to calculate 
.................... //              the number of sectors in the root directory based on information in the boot sector. 
.................... #define NUMBER_OF_BYTES_IN_DIR_ENTRY    32 
....................  
....................  
....................  
.................... // Summary: A macro for a deleted dir entry marker. 
.................... // Description: The DIR_DEL macro is used to mark a directory entry as deleted.  When a file is deleted, this value will replace the 
.................... //              first character in the file name, and will indicate that the file the entry points to was deleted. 
.................... #define DIR_DEL             0xE5 
....................  
.................... // Summary: A macro for the last dir entry marker. 
.................... // Description: The DIR_EMPTY macro is used to indicate the last entry in a directory.  Since entries in use cannot start with a 0 and 
.................... //              deleted entries start with the DIR_DEL character, a 0 will mark the end of the in-use or previously used group of 
.................... //              entries in a directory 
.................... #define DIR_EMPTY           0 
....................  
....................  
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name 
.................... // Description: The DIR_NAMESIZE macro is used when validing the name portion of 8.3 filenames 
.................... #define DIR_NAMESIZE        8 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file extension 
.................... // Description: The DIR_EXTENSION macro is used when validating the extension portion of 8.3 filenames 
.................... #define DIR_EXTENSION       3 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name and extension 
.................... // Description: The DIR_NAMECOMP macro is used when validating 8.3 filenames 
.................... #define DIR_NAMECOMP        (DIR_NAMESIZE+DIR_EXTENSION) 
....................  
....................  
....................  
.................... // Summary: A macro to write a byte to RAM 
.................... // Description: The RAMwrite macro is used to write a byte of data to a RAM array 
.................... #define RAMwrite( a, f, d) *(a+f) = d 
....................  
.................... // Summary: A macro to read a byte from RAM 
.................... // Description: The RAMread macro is used to read a byte of data from a RAM array 
.................... #define RAMread( a, f)  *(a+f) 
....................  
.................... // Summary: A macro to read a 16-bit word from RAM 
.................... // Description: The RAMreadW macro is used to read two bytes of data from a RAM array 
.................... #define RAMreadW( a, f) *(WORD *)(a+f) 
....................  
.................... // Summary: A macro to read a 32-bit word from RAM 
.................... // Description: The RAMreadD macro is used to read four bytes of data from a RAM array 
.................... #define RAMreadD( a, f) *(DWORD *)(a+f) 
....................  
....................  
....................  
.................... #ifndef EOF 
....................     // Summary: Indicates error conditions or end-of-file conditions 
....................     // Description: The EOF macro is used to indicate error conditions in some function calls.  It is also used to indicate 
....................     //              that the end-of-file has been reached. 
....................     #define EOF             ((int)-1) 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing information about the device. 
.................... // Description: The DISK structure contains information about the device being accessed. 
.................... typedef struct 
.................... {  
....................     BYTE    *   buffer;         // Address of the global data buffer used to read and write file information 
....................     DWORD       firsts;         // Logical block address of the first sector of the FAT partition on the device 
....................     DWORD       fat;            // Logical block address of the FAT 
....................     DWORD       root;           // Logical block address of the root directory 
....................     DWORD       data;           // Logical block address of the data section of the device. 
....................     WORD        maxroot;        // The maximum number of entries in the root directory. 
....................     DWORD       maxcls;         // The maximum number of clusters in the partition. 
....................     DWORD       sectorSize;     // The size of a sector in bytes 
....................     DWORD       fatsize;        // The number of sectors in the FAT 
....................     BYTE        fatcopy;        // The number of copies of the FAT in the partition 
....................     BYTE        SecPerClus;     // The number of sectors per cluster in the data region 
....................     BYTE        type;           // The file system type of the partition (FAT12, FAT16 or FAT32) 
....................     BYTE        mount;          // Device mount flag (TRUE if disk was mounted successfully, FALSE otherwise) 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... } __attribute__ ((packed)) DISK; 
.................... #else 
.................... } DISK; 
.................... #endif 
....................  
....................  
.................... #if defined(__18CXX) && !defined(__CCS__) 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef unsigned short long SWORD; 
.................... #else 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef struct 
....................     { 
....................         unsigned char array[3]; 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) SWORD; 
.................... #else 
....................     } SWORD; 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT12 file system (in the boot sector) 
.................... // Description: The _BPB_FAT12 structure provides a layout of the "bios parameter block" in the boot sector of a FAT12 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BPS;               // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD BootSec_ResrvSec;          // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD BootSec_RootDirEnts;       // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD BootSec_SPF;               // Number of sectors per FAT 
....................     WORD BootSec_SPT;               // Number of sectors per track 
....................     WORD BootSec_HeadCnt;           // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD  BootSec_Reserved;        // Reserved space 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved2;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination    
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT12; 
.................... #else 
....................     } _BPB_FAT12; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT16 file system (in the boot sector) 
.................... // Description: The _BPB_FAT16 structure provides a layout of the "bios parameter block" in the boot sector of a FAT16 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD  BootSec_BPS;              // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD  BootSec_ResrvSec;         // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD  BootSec_RootDirEnts;      // Number of root directory entries 
....................     WORD  BootSec_TotSec16;         // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD  BootSec_SPF;              // Number of sectors per FAT 
....................     WORD  BootSec_SPT;              // Number of sectors per track 
....................     WORD  BootSec_HeadCnt;          // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved;         // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination      
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT16; 
.................... #else 
....................     } _BPB_FAT16; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT32 file system (in the boot sector) 
.................... // Description: The _BPB_FAT32 structure provides a layout of the "bios parameter block" in the boot sector of a FAT32 partition. 
.................... typedef struct { 
....................     SWORD BootSec_jmpBoot;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BytsPerSec;        // Number of bytes per sector 
....................     BYTE  BootSec_SecPerClus;       // Number of sectors per cluster 
....................     WORD BootSec_RsvdSecCnt;        // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_NumFATs;          // Number of FATs on the partition 
....................     WORD BootSec_RootEntCnt;        // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_Media;            // Media descriptor 
....................     WORD BootSec_FATSz16;           // Number of sectors per FAT 
....................     WORD BootSec_SecPerTrk;         // Number of sectors per track 
....................     WORD BootSec_NumHeads;          // Number of heads 
....................     DWORD BootSec_HiddSec;          // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     DWORD BootSec_FATSz32;          // Sectors per FAT (32 bits) 
....................     WORD BootSec_ExtFlags;          // Presently active FAT. Defined by bits 0-3 if bit 7 is 1. 
....................     WORD BootSec_FSVers;            // FAT32 filesystem version.  Should be 0:0 
....................     DWORD BootSec_RootClus;         // Start cluster of the root directory (should be 2) 
....................     WORD BootSec_FSInfo;            // File system information 
....................     WORD BootSec_BkBootSec;         // Backup boot sector address. 
....................     BYTE  BootSec_Reserved[12];     // Reserved space 
....................     BYTE  BootSec_DrvNum;           // Drive number 
....................     BYTE  BootSec_Reserved1;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLab[11];       // Volume Label 
....................     BYTE  BootSec_FilSysType[8];    // File system type in ASCII.  Not used for determination   
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT32; 
.................... #else 
....................     } _BPB_FAT32; 
.................... #endif 
....................  
....................  
.................... // Description: A macro for the boot sector bytes per sector value offset 
.................... #define BSI_BPS            11 
....................  
.................... // Description: A macro for the boot sector sector per cluster value offset 
.................... #define BSI_SPC            13 
....................  
.................... // Description: A macro for the boot sector reserved sector count value offset 
.................... #define BSI_RESRVSEC       14 
....................  
.................... // Description: A macro for the boot sector FAT count value offset 
.................... #define BSI_FATCOUNT       16 
....................  
.................... // Description: A macro for the boot sector root directory entry count value offset 
.................... #define BSI_ROOTDIRENTS    17 
....................  
.................... // Description: A macro for the boot sector 16-bit total sector count value offset 
.................... #define BSI_TOTSEC16       19 
....................  
.................... // Description: A macro for the boot sector sectors per FAT value offset 
.................... #define BSI_SPF            22 
....................  
.................... // Description: A macro for the boot sector 32-bit total sector count value offset 
.................... #define BSI_TOTSEC32       32 
....................  
.................... // Description: A macro for the boot sector boot signature offset 
.................... #define BSI_BOOTSIG        38 
....................  
.................... // Description: A macro for the boot sector file system type string offset 
.................... #define BSI_FSTYPE         54 
....................  
.................... // Description: A macro for the boot sector 32-bit sector per FAT value offset 
.................... #define  BSI_FATSZ32       36 
....................  
.................... // Description: A macro for the boot sector start cluster of root directory value offset 
.................... #define  BSI_ROOTCLUS      44 
....................  
.................... // Description: A macro for the FAT32 boot sector boot signature offset 
.................... #define  BSI_FAT32_BOOTSIG 66 
....................  
.................... // Description: A macro for the FAT32 boot sector file system type string offset 
.................... #define  BSI_FAT32_FSTYPE  82 
....................  
....................  
....................  
.................... // Summary: A partition table entry structure. 
.................... // Description: The PTE_MBR structure contains values found in a partition table entry in the MBR of a device. 
.................... typedef struct 
.................... { 
....................     BYTE      PTE_BootDes;            // The boot descriptor (should be 0x00 in a non-bootable device) 
....................     SWORD     PTE_FrstPartSect;       // The cylinder-head-sector address of the first sector of the partition 
....................     BYTE      PTE_FSDesc;             // The file system descriptor 
....................     SWORD     PTE_LstPartSect;        // The cylinder-head-sector address of the last sector of the partition 
....................     DWORD     PTE_FrstSect;           // The logical block address of the first sector of the partition 
....................     DWORD     PTE_NumSect;            // The number of sectors in a partition 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) PTE_MBR; 
.................... #else 
....................     } PTE_MBR; 
.................... #endif 
....................  
....................  
.................... // Summary: A structure of the organization of a master boot record. 
.................... // Description: The _PT_MBR structure has the same form as a master boot record.  When the MBR is loaded from the device, it will 
.................... //              be cast as a _PT_MBR structure so the MBR elements can be accessed. 
.................... typedef struct 
.................... { 
....................     BYTE        ConsChkRtn[446];        // Boot code 
....................     PTE_MBR     Partition0;             // The first partition table entry 
....................     PTE_MBR     Partition1;             // The second partition table entry 
....................     PTE_MBR     Partition2;             // The third partition table entry 
....................     PTE_MBR     Partition3;             // The fourth partition table entry 
....................     BYTE        Signature0;             // MBR signature code - equal to 0x55 
....................     BYTE        Signature1;             // MBR signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... }__attribute__((packed)) _PT_MBR; 
.................... #else 
.................... }_PT_MBR; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _PT_MBR structure 
.................... // Description: The PT_MBR pointer points to a _PT_MBR structure. 
.................... typedef _PT_MBR *  PT_MBR; 
....................  
....................  
....................  
.................... // Summary: A structure of the organization of a boot sector. 
.................... // Description: The _BootSec structure has the same form as a boot sector.  When the boot sector is loaded from the device, it will 
.................... //              be cast as a _BootSec structure so the boot sector elements can be accessed. 
.................... typedef struct 
.................... { 
....................     // A union of different bios parameter blocks 
....................     union 
....................     { 
....................         _BPB_FAT32  FAT_32; 
....................         _BPB_FAT16  FAT_16; 
....................         _BPB_FAT12  FAT_12; 
....................     }FAT; 
....................     BYTE    Reserved[512-sizeof(_BPB_FAT32)-2]; // Reserved space 
....................     BYTE    Signature0;         // Boot sector signature code - equal to 0x55 
....................     BYTE    Signature1;         // Boot sector signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BootSec; 
.................... #else 
....................     } _BootSec; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _BootSec structure 
.................... // Description: The BootSec pointer points to a _BootSec structure. 
.................... typedef _BootSec * BootSec; 
....................  
....................  
....................  
.................... // Summary: A macro indicating the offset for the master boot record 
.................... // Description: FO_MBR is a macro that indicates the addresss of the master boot record on the device.  When the device is initialized 
.................... //              this sector will be read 
.................... #define FO_MBR          0L 
....................  
....................  
....................  
.................... // Summary: A macro for the first boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_0 macro is used to determine that the first byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_0     0x55 
....................  
.................... // Summary: A macro for the second boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_1 macro is used to determine that the second byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_1     0xAA 
....................  
....................  
.................... typedef struct  
.................... { 
....................     BYTE    errorCode; 
....................     union  
....................     { 
....................         BYTE    value; 
....................         struct  
....................         { 
....................             BYTE    sectorSize  : 1; 
....................             BYTE    maxLUN      : 1; 
....................         }   bits; 
....................     } validityFlags; 
....................      
....................     WORD    sectorSize; 
....................     BYTE    maxLUN; 
.................... } MEDIA_INFORMATION; 
....................  
.................... typedef enum 
.................... { 
....................     MEDIA_NO_ERROR,                     // No errors 
....................     MEDIA_DEVICE_NOT_PRESENT,           // The requested device is not present 
....................     MEDIA_CANNOT_INITIALIZE             // Cannot initialize media 
.................... } MEDIA_ERRORS;                 
....................  
....................  
.................... #endif 
....................  
.................... #include "MDD File System/SD-SPI.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        SD-SPI.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  *                  FSconfig.h 
....................  *                  FSDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the "Company") for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef SDMMC_H 
.................... #define SDMMC_H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... #include "../FSconfig.h" 
.................... #include "FSDefs.h" 
....................  
....................  
.................... #ifdef __18CXX 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 4x prescale divider 
....................     #define   SYNC_MODE_FAST    0x00 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 16x prescale divider 
....................     #define   SYNC_MODE_MED     0x01 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 64x prescale divider 
....................     #define   SYNC_MODE_SLOW    0x02 
.................... #elif defined __PIC32MX__ 
....................     // Description: This macro is used to initialize a PIC32 SPI module 
....................     #define   SYNC_MODE_FAST    0x3E 
....................     // Description: This macro is used to initialize a PIC32 SPI module 
....................     #define   SYNC_MODE_SLOW    0x3C 
.................... #else 
....................     // Description: This macro indicates the SPI enable bit for 16-bit PICs 
....................     #ifndef MASTER_ENABLE_ON 
....................         #define  MASTER_ENABLE_ON       0x0020 
....................     #endif 
....................  
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module 
....................     #ifndef SYNC_MODE_FAST 
....................         #define   SYNC_MODE_FAST    0x3E 
....................     #endif 
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module 
....................     #ifndef SYNC_MODE_SLOW 
....................         #define   SYNC_MODE_SLOW    0x3C 
....................     #endif 
....................  
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module secondary prescaler 
....................     #ifndef SEC_PRESCAL_1_1 
....................         #define  SEC_PRESCAL_1_1        0x001c 
....................     #endif 
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module primary prescaler 
....................     #ifndef PRI_PRESCAL_1_1 
....................         #define  PRI_PRESCAL_1_1        0x0003 
....................     #endif 
.................... #endif 
....................  
....................  
....................  
.................... /*****************************************************************/ 
.................... /*                  Strcutures and defines                       */ 
.................... /*****************************************************************/ 
....................  
....................  
.................... // Description: This macro represents an SD card start single data block token (used for single block writes) 
.................... #define DATA_START_TOKEN            0xFE 
....................  
.................... // Description: This macro represents an SD card start multi-block data token (used for multi-block writes) 
.................... #define DATA_START_MULTI_BLOCK_TOKEN    0xFC 
....................  
.................... // Description: This macro represents an SD card stop transmission token.  This is used when finishing a multi block write sequence. 
.................... #define DATA_STOP_TRAN_TOKEN        0xFD 
....................  
.................... // Description: This macro represents an SD card data accepted token 
.................... #define DATA_ACCEPTED               0x05 
....................  
.................... // Description: This macro indicates that the SD card expects to transmit or receive more data 
.................... #define MOREDATA    !0 
....................  
.................... // Description: This macro indicates that the SD card does not expect to transmit or receive more data 
.................... #define NODATA      0 
....................  
.................... // Description: This macro represents a floating SPI bus condition 
.................... #define MMC_FLOATING_BUS    0xFF 
....................  
.................... // Description: This macro represents a bad SD card response byte 
.................... #define MMC_BAD_RESPONSE    MMC_FLOATING_BUS 
....................  
.................... // The SDMMC Commands 
....................  
.................... // Description: This macro defines the command code to reset the SD card 
.................... #define     cmdGO_IDLE_STATE        0 
.................... // Description: This macro defines the command code to initialize the SD card 
.................... #define     cmdSEND_OP_COND         1         
.................... // Description: This macro defined the command code to check for sector addressing 
.................... #define     cmdSEND_IF_COND         8 
.................... // Description: This macro defines the command code to get the Card Specific Data 
.................... #define     cmdSEND_CSD             9 
.................... // Description: This macro defines the command code to get the Card Information 
.................... #define     cmdSEND_CID             10 
.................... // Description: This macro defines the command code to stop transmission during a multi-block read 
.................... #define     cmdSTOP_TRANSMISSION    12 
.................... // Description: This macro defines the command code to get the card status information 
.................... #define     cmdSEND_STATUS          13 
.................... // Description: This macro defines the command code to set the block length of the card 
.................... #define     cmdSET_BLOCKLEN         16 
.................... // Description: This macro defines the command code to read one block from the card 
.................... #define     cmdREAD_SINGLE_BLOCK    17 
.................... // Description: This macro defines the command code to read multiple blocks from the card 
.................... #define     cmdREAD_MULTI_BLOCK     18 
.................... // Description: This macro defines the command code to tell the media how many blocks to pre-erase (for faster multi-block writes to follow) 
.................... //Note: This is an "application specific" command.  This tells the media how many blocks to pre-erase for the subsequent WRITE_MULTI_BLOCK 
.................... #define     cmdSET_WR_BLK_ERASE_COUNT   23 
.................... // Description: This macro defines the command code to write one block to the card 
.................... #define     cmdWRITE_SINGLE_BLOCK   24     
.................... // Description: This macro defines the command code to write multiple blocks to the card 
.................... #define     cmdWRITE_MULTI_BLOCK    25 
.................... // Description: This macro defines the command code to set the address of the start of an erase operation 
.................... #define     cmdTAG_SECTOR_START     32 
.................... // Description: This macro defines the command code to set the address of the end of an erase operation 
.................... #define     cmdTAG_SECTOR_END       33 
.................... // Description: This macro defines the command code to erase all previously selected blocks 
.................... #define     cmdERASE                38 
.................... //Description: This macro defines the command code to intitialize an SD card and provide the CSD register value. 
.................... //Note: this is an "application specific" command (specific to SD cards) and must be preceded by cmdAPP_CMD. 
.................... #define     cmdSD_SEND_OP_COND      41 
.................... // Description: This macro defines the command code to begin application specific command inputs 
.................... #define     cmdAPP_CMD              55 
.................... // Description: This macro defines the command code to get the OCR register information from the card 
.................... #define     cmdREAD_OCR             58 
.................... // Description: This macro defines the command code to disable CRC checking 
.................... #define     cmdCRC_ON_OFF           59 
....................  
....................  
.................... // Description: Enumeration of different SD response types 
.................... typedef enum 
.................... { 
....................     R1,     // R1 type response 
....................     R1b,    // R1b type response 
....................     R2,     // R2 type response 
....................     R3,     // R3 type response  
....................     R7      // R7 type response  
.................... }RESP; 
....................  
.................... // Summary: SD card command data structure 
.................... // Description: The typMMC_CMD structure is used to create a command table of information needed for each relevant SD command 
.................... typedef struct 
.................... { 
....................     BYTE      CmdCode;          // The command code 
....................     BYTE      CRC;              // The CRC value for that command 
....................     RESP    responsetype;       // The response type 
....................     BYTE    moredataexpected;   // Set to MOREDATA or NODATA, depending on whether more data is expected or not 
.................... } typMMC_CMD; 
....................  
....................  
.................... // Summary: An SD command packet 
.................... // Description: This union represents different ways to access an SD card command packet 
.................... typedef union 
.................... { 
....................     // This structure allows array-style access of command bytes 
....................     struct 
....................     { 
....................         #ifdef __18CXX 
....................             BYTE field[6];      // BYTE array 
....................         #else 
....................             BYTE field[7]; 
....................         #endif 
....................     }; 
....................     // This structure allows byte-wise access of packet command bytes 
....................     struct 
....................     { 
....................         BYTE crc;               // The CRC byte 
....................         #if defined __C30__ 
....................             BYTE c30filler;     // Filler space (since bitwise declarations can't cross a WORD boundary) 
....................         #elif defined __C32__ 
....................             BYTE c32filler[3];  // Filler space (since bitwise declarations can't cross a DWORD boundary) 
....................         #endif 
....................          
....................         BYTE addr0;             // Address byte 0 
....................         BYTE addr1;             // Address byte 1 
....................         BYTE addr2;             // Address byte 2 
....................         BYTE addr3;             // Address byte 3 
....................         BYTE cmd;               // Command code byte 
....................     }; 
....................     // This structure allows bitwise access to elements of the command bytes 
....................     struct 
....................     { 
....................         BYTE  END_BIT:1;        // Packet end bit 
....................         BYTE  CRC7:7;           // CRC value 
....................         DWORD     address;      // Address 
....................         BYTE  CMD_INDEX:6;      // Command code 
....................         BYTE  TRANSMIT_BIT:1;   // Transmit bit 
....................         BYTE  START_BIT:1;      // Packet start bit 
....................     }; 
.................... } CMD_PACKET; 
....................  
....................  
.................... // Summary: The format of an R1 type response 
.................... // Description: This union represents different ways to access an SD card R1 type response packet. 
.................... typedef union 
.................... { 
....................     BYTE _byte;                         // Byte-wise access 
....................     // This structure allows bitwise access of the response 
....................     struct 
....................     { 
....................         unsigned IN_IDLE_STATE:1;       // Card is in idle state 
....................         unsigned ERASE_RESET:1;         // Erase reset flag 
....................         unsigned ILLEGAL_CMD:1;         // Illegal command flag 
....................         unsigned CRC_ERR:1;             // CRC error flag 
....................         unsigned ERASE_SEQ_ERR:1;       // Erase sequence error flag 
....................         unsigned ADDRESS_ERR:1;         // Address error flag 
....................         unsigned PARAM_ERR:1;           // Parameter flag    
....................         unsigned B7:1;                  // Unused bit 7 
....................     }; 
.................... } RESPONSE_1; 
....................  
.................... // Summary: The format of an R2 type response 
.................... // Description: This union represents different ways to access an SD card R2 type response packet 
.................... typedef union 
.................... { 
....................     WORD _word; 
....................     struct 
....................     { 
....................         BYTE      _byte0; 
....................         BYTE      _byte1; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned IN_IDLE_STATE:1; 
....................         unsigned ERASE_RESET:1; 
....................         unsigned ILLEGAL_CMD:1; 
....................         unsigned CRC_ERR:1; 
....................         unsigned ERASE_SEQ_ERR:1; 
....................         unsigned ADDRESS_ERR:1; 
....................         unsigned PARAM_ERR:1; 
....................         unsigned B7:1; 
....................         unsigned CARD_IS_LOCKED:1; 
....................         unsigned WP_ERASE_SKIP_LK_FAIL:1; 
....................         unsigned ERROR:1; 
....................         unsigned CC_ERROR:1; 
....................         unsigned CARD_ECC_FAIL:1; 
....................         unsigned WP_VIOLATION:1; 
....................         unsigned ERASE_PARAM:1; 
....................         unsigned OUTRANGE_CSD_OVERWRITE:1; 
....................     }; 
.................... } RESPONSE_2; 
....................  
.................... // Summary: The format of an R7 or R3 type response 
.................... // Description: This union represents different ways to access an SD card R7 type response packet. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         BYTE _byte;                         // Byte-wise access 
....................         union 
....................         { 
....................             //Note: The SD card argument response field is 32-bit, big endian format. 
....................             //However, the C compiler stores 32-bit values in little endian in RAM. 
....................             //When writing to the _returnVal/argument bytes, make sure to byte 
....................             //swap the order from which it arrived over the SPI from the SD card. 
....................             DWORD _returnVal; 
....................             struct 
....................             { 
....................                 BYTE _byte0; 
....................                 BYTE _byte1; 
....................                 BYTE _byte2; 
....................                 BYTE _byte3; 
....................             };     
....................         }argument;     
....................     } bytewise; 
....................     // This structure allows bitwise access of the response 
....................     struct 
....................     { 
....................         struct 
....................         { 
....................             unsigned IN_IDLE_STATE:1;       // Card is in idle state 
....................             unsigned ERASE_RESET:1;         // Erase reset flag 
....................             unsigned ILLEGAL_CMD:1;         // Illegal command flag 
....................             unsigned CRC_ERR:1;             // CRC error flag 
....................             unsigned ERASE_SEQ_ERR:1;       // Erase sequence error flag 
....................             unsigned ADDRESS_ERR:1;         // Address error flag 
....................             unsigned PARAM_ERR:1;           // Parameter flag    
....................             unsigned B7:1;                  // Unused bit 7 
....................         }bits; 
....................         DWORD _returnVal; 
....................     } bitwise; 
.................... } RESPONSE_7; 
....................  
.................... // Summary: A union of responses from an SD card 
.................... // Description: The MMC_RESPONSE union represents any of the possible responses that an SD card can return after 
.................... //              being issued a command. 
.................... typedef union 
.................... { 
....................     RESPONSE_1  r1;   
....................     RESPONSE_2  r2; 
....................     RESPONSE_7  r7; 
.................... }MMC_RESPONSE; 
....................  
....................  
.................... // Summary: A description of the card specific data register 
.................... // Description: This union represents different ways to access information in a packet with SD card CSD informaiton.  For more 
.................... //              information on the CSD register, consult an SD card user's manual. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         DWORD _u320; 
....................         DWORD _u321; 
....................         DWORD _u322; 
....................         DWORD _u323; 
....................     }; 
....................     struct 
....................     { 
....................         BYTE _byte[16]; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned NOT_USED           :1; 
....................         unsigned CRC                :7; 
....................         unsigned ECC                :2; 
....................         unsigned FILE_FORMAT        :2; 
....................         unsigned TMP_WRITE_PROTECT  :1; 
....................         unsigned PERM_WRITE_PROTECT :1; 
....................         unsigned COPY               :1; 
....................         unsigned FILE_FORMAT_GRP    :1; 
....................         unsigned RESERVED_1         :5; 
....................         unsigned WRITE_BL_PARTIAL   :1; 
....................         unsigned WRITE_BL_LEN_L     :2; 
....................         unsigned WRITE_BL_LEN_H     :2; 
....................         unsigned R2W_FACTOR         :3; 
....................         unsigned DEFAULT_ECC        :2; 
....................         unsigned WP_GRP_ENABLE      :1; 
....................         unsigned WP_GRP_SIZE        :5; 
....................         unsigned ERASE_GRP_SIZE_L   :3; 
....................         unsigned ERASE_GRP_SIZE_H   :2; 
....................         unsigned SECTOR_SIZE        :5; 
....................         unsigned C_SIZE_MULT_L      :1; 
....................         unsigned C_SIZE_MULT_H      :2; 
....................         unsigned VDD_W_CURR_MAX     :3; 
....................         unsigned VDD_W_CUR_MIN      :3; 
....................         unsigned VDD_R_CURR_MAX     :3; 
....................         unsigned VDD_R_CURR_MIN     :3; 
....................         unsigned C_SIZE_L           :2; 
....................         unsigned C_SIZE_H           :8; 
....................         unsigned C_SIZE_U           :2; 
....................         unsigned RESERVED_2         :2; 
....................         unsigned DSR_IMP            :1; 
....................         unsigned READ_BLK_MISALIGN  :1; 
....................         unsigned WRITE_BLK_MISALIGN :1; 
....................         unsigned READ_BL_PARTIAL    :1; 
....................         unsigned READ_BL_LEN        :4; 
....................         unsigned CCC_L              :4; 
....................         unsigned CCC_H              :8; 
....................         unsigned TRAN_SPEED         :8; 
....................         unsigned NSAC               :8; 
....................         unsigned TAAC               :8; 
....................         unsigned RESERVED_3         :2; 
....................         unsigned SPEC_VERS          :4; 
....................         unsigned CSD_STRUCTURE      :2; 
....................     }; 
.................... } CSD; 
....................  
....................  
.................... // Summary: A description of the card information register 
.................... // Description: This union represents different ways to access information in a packet with SD card CID register informaiton.  For more 
.................... //              information on the CID register, consult an SD card user's manual. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         DWORD _u320; 
....................         DWORD _u321; 
....................         DWORD _u322; 
....................         DWORD _u323; 
....................     }; 
....................     struct 
....................     { 
....................         BYTE _byte[16]; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned    NOT_USED            :1; 
....................         unsigned    CRC                 :7; 
....................         unsigned    MDT                 :8; 
....................         DWORD       PSN; 
....................         unsigned    PRV                 :8; 
....................         char        PNM[6]; 
....................         WORD        OID; 
....................         unsigned    MID                 :8; 
....................     }; 
.................... } CID; 
....................  
.................... #ifndef FALSE 
....................     #define FALSE   0 
.................... #endif 
.................... #ifndef TRUE 
....................     #define TRUE    !FALSE 
.................... #endif 
....................  
.................... #define INPUT   1 
.................... #define OUTPUT  0 
....................  
....................  
.................... // Description: A delay prescaler 
.................... #define DELAY_PRESCALER   (BYTE)      8 
....................  
.................... // Description: An approximation of the number of cycles per delay loop of overhead 
.................... #define DELAY_OVERHEAD    (BYTE)      5 
....................  
.................... // Description: An approximate calculation of how many times to loop to delay 1 ms in the Delayms function 
.................... #define MILLISECDELAY   (WORD)      ((GetInstructionClock()/DELAY_PRESCALER/(WORD)1000) - DELAY_OVERHEAD) 
....................  
....................  
.................... // Desription: Media Response Delay Timeouts  
.................... #define NCR_TIMEOUT     (WORD)20        //Byte times before command response is expected (must be at least 8) 
.................... #define NAC_TIMEOUT     (DWORD)0x40000  //SPI byte times we should wait when performing read operations (should be at least 100ms for SD cards) 
.................... #define WRITE_TIMEOUT   (DWORD)0xA0000  //SPI byte times to wait before timing out when the media is performing a write operation (should be at least 250ms for SD cards). 
....................  
.................... // Summary: An enumeration of SD commands 
.................... // Description: This enumeration corresponds to the position of each command in the sdmmc_cmdtable array 
.................... //              These macros indicate to the SendMMCCmd function which element of the sdmmc_cmdtable array 
.................... //              to retrieve command code information from. 
.................... typedef enum 
.................... { 
....................     GO_IDLE_STATE, 
....................     SEND_OP_COND, 
....................     SEND_IF_COND, 
....................     SEND_CSD, 
....................     SEND_CID, 
....................     STOP_TRANSMISSION, 
....................     SEND_STATUS, 
....................     SET_BLOCKLEN, 
....................     READ_SINGLE_BLOCK, 
....................     READ_MULTI_BLOCK, 
....................     WRITE_SINGLE_BLOCK, 
....................     WRITE_MULTI_BLOCK, 
....................     TAG_SECTOR_START, 
....................     TAG_SECTOR_END, 
....................     ERASE, 
....................     APP_CMD, 
....................     READ_OCR, 
....................     CRC_ON_OFF, 
....................     SD_SEND_OP_COND, 
....................     SET_WR_BLK_ERASE_COUNT 
.................... }sdmmc_cmd; 
....................  
....................  
.................... #define SD_MODE_NORMAL  0 
.................... #define SD_MODE_HC      1 
....................  
....................  
.................... //Definition for a structure used when calling either MDD_SDSPI_AsyncReadTasks()  
.................... //function, or the MDD_SDSPI_AsyncWriteTasks() function. 
.................... typedef struct 
.................... { 
....................     WORD wNumBytes;         //Number of bytes to attempt to read or write in the next call to MDD_SDSPI_AsyncReadTasks() or MDD_SDSPI_AsyncWriteTasks.  May be updated between calls to the handler. 
....................     DWORD dwBytesRemaining; //Should be initialized to the total number of bytes that you wish to read or write.  This value is allowed to be greater than a single block size of the media. 
....................     BYTE* pBuffer;          //Pointer to where the read/written bytes should be copied to/from.  May be updated between calls to the handler function. 
....................     DWORD dwAddress;        //Starting block address to read or to write to on the media.  Should only get initialized, do not modify after that. 
....................     BYTE bStateVariable;    //State machine variable.  Should get initialized to ASYNC_READ_QUEUED or ASYNC_WRITE_QUEUED to start an operation.  After that, do not modify until the read or write is complete. 
.................... }ASYNC_IO;    
....................  
....................  
.................... //Response codes for the MDD_SDSPI_AsyncReadTasks() function. 
.................... //#define ASYNC_READ_COMPLETE             0x00 
.................... #define ASYNC_READ_BUSY                 0x01 
.................... //#define ASYNC_READ_NEW_PACKET_READY     0x02 
.................... //#define ASYNC_READ_ERROR                0xFF 
....................  
.................... //MDD_SDSPI_AsyncReadTasks() state machine variable values.  These are used internally to SD-SPI.c. 
.................... #define ASYNC_READ_COMPLETE             0x00 
.................... #define ASYNC_READ_QUEUED               0x01    //Initialize to this to start a read sequence 
.................... #define ASYNC_READ_WAIT_START_TOKEN     0x03 
.................... #define ASYNC_READ_NEW_PACKET_READY     0x02 
.................... #define ASYNC_READ_ABORT                0xFE 
.................... #define ASYNC_READ_ERROR                0xFF 
....................  
.................... //Possible return values when calling MDD_SDSPI_AsyncWriteTasks() 
.................... //#define ASYNC_WRITE_COMPLETE        0x00 
.................... #define ASYNC_WRITE_SEND_PACKET     0x02 
.................... #define ASYNC_WRITE_BUSY            0x03 
.................... //#define ASYNC_WRITE_ERROR           0xFF 
....................  
.................... //MDD_SDSPI_AsyncWriteTasks() state machine variable values.  These are used internally to SD-SPI.c. 
.................... #define ASYNC_WRITE_COMPLETE            0x00 
.................... #define ASYNC_WRITE_QUEUED              0x01    //Initialize to this to start a write sequence 
.................... #define ASYNC_WRITE_TRANSMIT_PACKET     0x02 
.................... #define ASYNC_WRITE_MEDIA_BUSY          0x03 
.................... #define ASYNC_STOP_TOKEN_SENT_WAIT_BUSY 0x04 
.................... #define ASYNC_WRITE_ABORT               0xFE 
.................... #define ASYNC_WRITE_ERROR               0xFF 
....................  
....................  
.................... //Constants 
.................... #define MEDIA_BLOCK_SIZE            512u  //Should always be 512 for v1 and v2 devices. 
.................... #define WRITE_RESPONSE_TOKEN_MASK   0x1F  //Bit mask to AND with the write token response byte from the media, to clear the don't care bits. 
....................  
....................  
....................  
.................... /***************************************************************************/ 
.................... /*                               Macros                                    */ 
.................... /***************************************************************************/ 
....................  
.................... // Description: A macro to send clock cycles to dummy-read the CRC 
.................... #define mReadCRC()              WriteSPIM(0xFF);WriteSPIM(0xFF); 
....................  
.................... // Description: A macro to send clock cycles to dummy-write the CRC 
.................... #define mSendCRC()              WriteSPIM(0xFF);WriteSPIM(0xFF); 
....................  
.................... // Description: A macro to send 8 clock cycles for SD timing requirements 
.................... #define mSend8ClkCycles()       WriteSPIM(0xFF); 
....................  
.................... /*****************************************************************************/ 
.................... /*                                 Public Prototypes                         */ 
.................... /*****************************************************************************/ 
....................  
.................... //These are the public API functions provided by SD-SPI.c 
.................... BYTE MDD_SDSPI_MediaDetect(void); 
.................... MEDIA_INFORMATION * MDD_SDSPI_MediaInitialize(void); 
.................... DWORD MDD_SDSPI_ReadCapacity(void); 
.................... WORD MDD_SDSPI_ReadSectorSize(void); 
.................... void MDD_SDSPI_InitIO(void); 
.................... BYTE MDD_SDSPI_SectorRead(DWORD sector_addr, BYTE* buffer); 
.................... BYTE MDD_SDSPI_SectorWrite(DWORD sector_addr, BYTE* buffer, BYTE allowWriteToZero); 
.................... BYTE MDD_SDSPI_AsyncReadTasks(ASYNC_IO*); 
.................... BYTE MDD_SDSPI_AsyncWriteTasks(ASYNC_IO*); 
.................... BYTE MDD_SDSPI_WriteProtectState(void); 
.................... BYTE MDD_SDSPI_ShutdownMedia(void); 
....................  
....................  
.................... #if defined __C30__ || defined __C32__ 
....................     extern BYTE ReadByte( BYTE* pBuffer, WORD index ); 
....................     extern WORD ReadWord( BYTE* pBuffer, WORD index ); 
....................     extern DWORD ReadDWord( BYTE* pBuffer, WORD index ); 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "string.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = beg; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "FSconfig.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSconfig.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Dependencies:    None 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _FS_DEF_ 
.................... #define _FS_DEF_ 
....................  
.................... //#include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // something to do with long filenames. 
.................... //#define SUPPORT_LFN 
....................  
.................... // Summary: A macro indicating the maximum number of concurrently open files 
.................... // Description: The FS_MAX_FILES_OPEN #define is only applicable when dynamic memory allocation is not used (FS_DYNAMIC_MEM is not defined). 
.................... //              This macro defines the maximum number of open files at any given time.  The amount of RAM used by FSFILE objects will 
.................... //              be equal to the size of an FSFILE object multipled by this macro value.  This value should be kept as small as possible 
.................... //              as dictated by the application.  This will reduce memory usage. 
.................... #define FS_MAX_FILES_OPEN    1 
....................  
....................  
.................... // if defined, MDD will be configured to use SST25 flash device. this definition 
.................... // should also define the size of the SST25 flash device. 
.................... // if not defined, will use SD card. 
.................... // #define  USE_SST25_INTERFACE  ((unsigned int32)2*1024*1024) 
....................  
.................... // Summary: A macro defining the size of a sector 
.................... // Description: The MEDIA_SECTOR_SIZE macro will define the size of a sector on the FAT file system.  This value must equal 512 bytes, 
.................... //              1024 bytes, 2048 bytes, or 4096 bytes.  The value of a sector will usually be 512 bytes. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define MEDIA_SECTOR_SIZE       4096   //erase size of SST25 flash device 
.................... #else 
.................... #define MEDIA_SECTOR_SIZE       512 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* *******************************************************************************************************/ 
.................... /************** Compiler options to enable/Disable Features based on user's application ******************/ 
.................... /* *******************************************************************************************************/ 
....................  
....................  
.................... // Summary: A macro to enable/disable file search functions. 
.................... // Description: The ALLOW_FILESEARCH definition can be commented out to disable file search functions in the library.  This will 
.................... //              prevent the use of the FindFirst and FindNext functions and reduce code size. 
.................... #define ALLOW_FILESEARCH 
....................  
.................... // Summary: A macro to enable/disable write functionality 
.................... // Description: The ALLOW_WRITES definition can be commented out to disable all operations that write to the device.  This will 
.................... //              greatly reduce code size. 
.................... #define ALLOW_WRITES 
....................  
....................  
.................... // Summary: A macro to enable/disable format functionality 
.................... // Description: The ALLOW_FORMATS definition can be commented out to disable formatting functionality.  This will prevent the use of 
.................... //              the FSformat function.  If formats are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define ALLOW_FORMATS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable directory operations. 
.................... // Description: The ALLOW_DIRS definition can be commented out to disable all directory functionality.  This will reduce code size. 
.................... //              If directories are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES in order to use 
.................... //              the FSmkdir or FSrmdir functions. 
.................... #define ALLOW_DIRS 
....................  
.................... // Summary: A macro to enable/disable PIC18 ROM functions. 
.................... // Description: The ALLOW_PGMFUNCTIONS definition can be commented out to disable all PIC18 functions that allow the user to pass string 
.................... //              arguments in ROM (denoted by the suffix -pgm).  Note that this functionality must be disabled when not using PIC18. 
.................... #if !defined(__CCS__) 
.................... #define ALLOW_PGMFUNCTIONS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable the FSfprintf function. 
.................... // Description: The ALLOW_FSFPRINTF definition can be commented out to disable the FSfprintf function.  This will save code space.  Note that 
.................... //              if FSfprintf is enabled and the PIC18 architecture is used, integer promotions must be enabled in the Project->Build Options 
.................... //              menu.  Write operations must be enabled to use FSfprintf. 
.................... //#define ALLOW_FSFPRINTF 
....................  
.................... // CCS added this config option to disable FAT12 to prevent recursion. 
.................... //__CCS__ added by ccs 
.................... //#define SUPPORT_FAT12 
....................  
.................... // Summary: A macro to enable/disable FAT32 support. 
.................... // Description: The SUPPORT_FAT32 definition can be commented out to disable support for FAT32 functionality.  This will save a small amount 
.................... //              of code space. 
.................... #define SUPPORT_FAT32 
....................  
....................  
....................  
.................... /**************************************************************************************************/ 
.................... // Select a method for updating file timestamps 
.................... /**************************************************************************************************/ 
....................  
.................... // Summary: A macro to enable RTCC based timestamp generation 
.................... // Description: The USEREALTIMECLOCK macro will configure the code to automatically 
.................... //              generate timestamp information for files from the RTCC module. The user 
.................... //              must enable and configure the RTCC module before creating or modifying 
.................... //              files.                                                                  
.................... //#define USEREALTIMECLOCK 
....................  
.................... // Summary: A macro to enable manual timestamp generation 
.................... // Description: The USERDEFINEDCLOCK macro will allow the user to manually set 
.................... //              timestamp information using the SetClockVars function. The user will 
.................... //              need to set the time variables immediately before creating or closing a 
.................... //              file or directory.                                                     
.................... #define USERDEFINEDCLOCK 
....................  
.................... // Summary: A macro to enable don't-care timestamp generation 
.................... // Description: The INCREMENTTIMESTAMP macro will set the create time of a file to a 
.................... //              static value and increment it when a file is updated. This timestamp 
.................... //              generation method should only be used in applications where file times 
.................... //              are not necessary.                                                     
.................... //#define INCREMENTTIMESTAMP 
....................  
....................  
.................... #ifdef __18CXX 
....................    #ifdef USEREALTIMECLOCK 
....................       #error Not all PIC18 devices have a Real-time clock and calander module 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    #ifndef __18CXX 
....................       #error The pgm functions are unneccessary when not using PIC18 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef USEREALTIMECLOCK 
....................     #ifndef USERDEFINEDCLOCK 
....................         #ifndef INCREMENTTIMESTAMP 
....................             #error Please enable USEREALTIMECLOCK, USERDEFINEDCLOCK, or INCREMENTTIMESTAMP 
....................         #endif 
....................     #endif 
.................... #endif 
....................  
.................... /************************************************************************/ 
.................... // Set this preprocessor option to '1' to use dynamic FSFILE object allocation.  It will 
.................... // be necessary to allocate a heap when dynamically allocating FSFILE objects. 
.................... // Set this option to '0' to use static FSFILE object allocation. 
.................... /************************************************************************/ 
....................  
.................... //#if 1  //from mirochip 
.................... #if defined(__PCH__) //__CCS__ 
....................     // Summary: A macro indicating that FSFILE objects will be allocated dynamically 
....................     // Description: The FS_DYNAMIC_MEM macro will cause FSFILE objects to be allocated from a dynamic heap.  If it is undefined, 
....................     //              the file objects will be allocated using a static array. 
....................    //#define FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................         // Description: Function pointer to a dynamic memory allocation function 
....................       #define FS_malloc   SRAMalloc 
....................         // Description: Function pointer to a dynamic memory free function 
....................       #define FS_free      SRAMfree 
....................    #else 
....................       #define FS_malloc   malloc 
....................       #define FS_free      free 
....................    #endif 
.................... #elif defined(__CCS__) 
....................    #error/warning Not using FS_DYNAMIC_MEM for PCD compiler 
.................... #endif 
....................  
....................  
.................... #ifdef __18CXX 
....................     /* Define the locations for the dataBuffer and FATbuffer; PLEASE CHECK THE LINKER FILE */ 
....................     #define DATA_BUFFER_ADDRESS      0x700 
....................     #define FAT_BUFFER_ADDRESS       0x900 
.................... #endif 
....................  
....................  
.................... // Function definitions 
.................... // Associate the physical layer functions with the correct physical layer 
.................... #ifdef USE_SD_INTERFACE_WITH_SPI       // SD-SPI.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_SDSPI_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_SDSPI_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_SDSPI_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_SDSPI_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_SDSPI_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_SDSPI_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_SDSPI_WriteProtectState 
....................  
....................     // Description: Function pointer to the Read Capacity Physical Layer function 
....................     #define MDD_ReadCapacity        MDD_SDSPI_ReadCapacity 
....................  
....................     // Description: Function pointer to the Read Sector Size Physical Layer Function 
....................     #define MDD_ReadSectorSize      MDD_SDSPI_ReadSectorSize 
....................  
.................... #elif defined USE_CF_INTERFACE_WITH_PMP       // CF-PMP.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFPMP_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFPMP_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFPMP_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFPMP_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFPMP_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFPMP_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFPMP_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFPMP_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFPMP_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFPMP_CFread 
....................  
.................... #elif defined USE_MANUAL_CF_INTERFACE         // CF-Bit transaction.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFBT_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFBT_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFBT_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFBT_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFBT_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFBT_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFBT_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFBT_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFBT_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFBT_CFread 
....................  
.................... #elif defined USE_USB_INTERFACE               // USB host MSD library 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     USBHostMSDSCSIMediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         USBHostMSDSCSIMediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          USBHostMSDSCSISectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         USBHostMSDSCSISectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO();               
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       USBHostMSDSCSIMediaReset 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   USBHostMSDSCSIWriteProtectState 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Global Variables 
....................  *****************************************************************************/ 
....................  
.................... // Description:  Used for the mass-storage library to determine capacity 
.................... DWORD MDD_SDSPI_finalLBA; 
.................... WORD gMediaSectorSize; 
.................... BYTE gSDMode; 
.................... static MEDIA_INFORMATION mediaInformation; 
.................... static ASYNC_IO ioInfo; //Declared global context, for fast/code efficient access 
....................  
....................  
.................... #ifdef __18CXX 
....................     // Summary: Table of SD card commands and parameters 
....................     // Description: The sdmmc_cmdtable contains an array of SD card commands, the corresponding CRC code, the 
....................     //              response type that the card will return, and a parameter indicating whether to expect 
....................     //              additional data from the card. 
....................     const rom typMMC_CMD sdmmc_cmdtable[] = 
.................... #else 
....................     const typMMC_CMD sdmmc_cmdtable[] = 
.................... #endif 
.................... { 
....................     // cmd                      crc     response 
....................     {cmdGO_IDLE_STATE,          0x95,   R1,     NODATA}, 
....................     {cmdSEND_OP_COND,           0xF9,   R1,     NODATA}, 
....................     {cmdSEND_IF_COND,            0x87,   R7,     NODATA}, 
....................     {cmdSEND_CSD,               0xAF,   R1,     MOREDATA}, 
....................     {cmdSEND_CID,               0x1B,   R1,     MOREDATA}, 
....................     {cmdSTOP_TRANSMISSION,      0xC3,   R1b,    NODATA}, 
....................     {cmdSEND_STATUS,            0xAF,   R2,     NODATA}, 
....................     {cmdSET_BLOCKLEN,           0xFF,   R1,     NODATA}, 
....................     {cmdREAD_SINGLE_BLOCK,      0xFF,   R1,     MOREDATA}, 
....................     {cmdREAD_MULTI_BLOCK,       0xFF,   R1,     MOREDATA}, 
....................     {cmdWRITE_SINGLE_BLOCK,     0xFF,   R1,     MOREDATA}, 
....................     {cmdWRITE_MULTI_BLOCK,      0xFF,   R1,     MOREDATA},  
....................     {cmdTAG_SECTOR_START,       0xFF,   R1,     NODATA}, 
....................     {cmdTAG_SECTOR_END,         0xFF,   R1,     NODATA}, 
....................     {cmdERASE,                  0xDF,   R1b,    NODATA}, 
....................     {cmdAPP_CMD,                0x73,   R1,     NODATA}, 
....................     {cmdREAD_OCR,               0x25,   R7,     NODATA}, 
....................     {cmdCRC_ON_OFF,             0x25,   R1,     NODATA}, 
....................     {cmdSD_SEND_OP_COND,        0xFF,   R7,     NODATA}, //Actual response is R3, but has same number of bytes as R7. 
....................     {cmdSET_WR_BLK_ERASE_COUNT, 0xFF,   R1,     NODATA} 
.................... }; 
....................  
....................  
....................  
....................  
.................... /****************************************************************************** 
....................  * Prototypes 
....................  *****************************************************************************/ 
.................... extern void Delayms(BYTE milliseconds); 
.................... BYTE MDD_SDSPI_ReadMedia(void); 
.................... MEDIA_INFORMATION * MDD_SDSPI_MediaInitialize(void); 
.................... MMC_RESPONSE SendMMCCmd(BYTE cmd, DWORD address); 
....................  
.................... #if defined __C30__ || defined __C32__ 
....................     void OpenSPIM ( unsigned int sync_mode); 
....................     void CloseSPIM( void ); 
....................     unsigned char WriteSPIM( unsigned char data_out ); 
.................... #elif defined __18CXX 
....................     void OpenSPIM ( unsigned char sync_mode); 
....................     void CloseSPIM( void ); 
....................     unsigned char WriteSPIM( unsigned char data_out ); 
....................  
....................     unsigned char WriteSPIManual(unsigned char data_out); 
....................     BYTE ReadMediaManual (void); 
....................     MMC_RESPONSE SendMMCCmdManual(BYTE cmd, DWORD address); 
.................... #endif 
.................... void InitSPISlowMode(void); 
....................  
.................... #if defined __18CXX 
.................... //Private function prototypes 
.................... static void PIC18_Optimized_SPI_Write_Packet(void); 
.................... static void PIC18_Optimized_SPI_Read_Packet(void); 
.................... #endif 
....................  
.................... //-------------Function name redirects------------------------------------------ 
.................... //During the media initialization sequence, it is 
.................... //necessary to clock the media at no more than 400kHz SPI speeds, since some 
.................... //media types power up in open drain output mode and cannot run fast initially. 
.................... //On PIC18 devices, when the CPU is run at full frequency, the standard SPI  
.................... //prescalars cannot reach a low enough SPI frequency.  Therefore, we initialize 
.................... //the card at low speed using bit-banged SPI on PIC18 devices.  On  
.................... //PIC32/PIC24/dsPIC devices, the SPI module is flexible enough to reach <400kHz 
.................... //speeds regardless of CPU frequency, and therefore bit-banged code is not  
.................... //necessary.  Therefore, we use function redirects where necessary, to point to 
.................... //the proper SPI related code, given the processor type. 
....................  
.................... #if defined __18CXX 
....................     #define SendMediaSlowCmd    SendMMCCmdManual 
....................     #define WriteSPISlow        WriteSPIManual 
.................... #else 
....................     #define SendMediaSlowCmd    SendMMCCmd 
....................     #define WriteSPISlow        WriteSPIM 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... #ifdef __PIC32MX__ 
.................... /********************************************************* 
....................   Function: 
....................     static inline __attribute__((always_inline)) unsigned char SPICacutateBRG (unsigned int pb_clk, unsigned int spi_clk) 
....................   Summary: 
....................     Calculate the PIC32 SPI BRG value 
....................   Conditions: 
....................     None 
....................   Input: 
....................     pb_clk -  The value of the PIC32 peripheral clock 
....................     spi_clk - The desired baud rate 
....................   Return: 
....................     The corresponding BRG register value. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The SPICalutateBRG function is used to determine an appropriate BRG register value for the PIC32 SPI module. 
....................   Remarks: 
....................     None                                                   
....................   *********************************************************/ 
....................  
.................... static inline __attribute__((always_inline)) unsigned char SPICalutateBRG(unsigned int pb_clk, unsigned int spi_clk) 
.................... { 
....................     unsigned int brg; 
....................  
....................     brg = pb_clk / (2 * spi_clk); 
....................  
....................     if(pb_clk % (2 * spi_clk)) 
....................         brg++; 
....................  
....................     if(brg > 0x100) 
....................         brg = 0x100; 
....................  
....................     if(brg) 
....................         brg--; 
....................  
....................     return (unsigned char) brg; 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     BYTE MDD_SDSPI_MediaDetect 
....................   Summary: 
....................     Determines whether an SD card is present 
....................   Conditions: 
....................     The MDD_MediaDetect function pointer must be configured 
....................     to point to this function in FSconfig.h 
....................   Input: 
....................     None 
....................   Return Values: 
....................     TRUE -  Card detected 
....................     FALSE - No card detected 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_MediaDetect function determine if an SD card is connected to  
....................     the microcontroller. 
....................     If the MEDIA_SOFT_DETECT is not defined, the detection is done by polling 
....................     the SD card detect pin. 
....................     The MicroSD connector does not have a card detect pin, and therefore a 
....................     software mechanism must be used. To do this, the SEND_STATUS command is sent  
....................     to the card. If the card is not answering with 0x00, the card is either not  
....................     present, not configured, or in an error state. If this is the case, we try 
....................     to reconfigure the card. If the configuration fails, we consider the card not  
....................     present (it still may be present, but malfunctioning). In order to use the  
....................     software card detect mechanism, the MEDIA_SOFT_DETECT macro must be defined. 
....................      
....................   Remarks: 
....................     None                                                   
....................   *********************************************************/ 
....................  
.................... BYTE MDD_SDSPI_MediaDetect (void) 
*
01462:  MOV     W5,[W15++]
.................... { 
.................... #ifndef MEDIA_SOFT_DETECT 
....................     return(!SD_CD); 
.................... #else 
....................    MMC_RESPONSE    response; 
01464:  CLR     FCC
01466:  CLR     FCE
01468:  CLR     FD0
....................  
....................     //First check if SPI module is enabled or not. 
....................    if (SPIENABLE == 0) 
0146A:  BTSC.B  241.7
0146C:  BRA     14CE
....................    { 
....................         unsigned char timeout; 
0146E:  CLR.B   FD2
....................  
....................       //If the SPI module is not enabled, then the media has evidently not 
....................       //been initialized.  Try to send CMD0 and CMD13 to reset the device and 
....................       //get it into SPI mode (if present), and then request the status of 
....................       //the media.  If this times out, then the card is presumably not physically 
....................       //present. 
....................        
....................       InitSPISlowMode(); 
01470:  CALL    ED0
....................        
....................         //Send CMD0 to reset the media 
....................        //If the card is physically present, then we should get a valid response. 
....................         timeout = 4; 
01474:  MOV.B   #4,W0L
01476:  MOV.B   W0L,FD2
....................         do 
....................         { 
....................             //Toggle chip select, to make media abandon whatever it may have been doing 
....................             //before.  This ensures the CMD0 is sent freshly after CS is asserted low, 
....................             //minimizing risk of SPI clock pulse master/slave syncronization problems,  
....................             //due to possible application noise on the SCK line. 
....................             SD_CS = 1; 
01478:  BSET.B  2F5.0
....................             WriteSPISlow(0xFF);   //Send some "extraneous" clock pulses.  If a previous 
0147A:  SETM.B  113C
0147C:  CALL    F36
....................                                   //command was terminated before it completed normally, 
....................                                   //the card might not have received the required clocking 
....................                                   //following the transfer. 
....................             SD_CS = 0; 
01480:  BCLR.B  2F5.0
....................             timeout--; 
01482:  DEC.B   0FD2
....................      
....................             //Send CMD0 to software reset the device 
....................             response = SendMediaSlowCmd(GO_IDLE_STATE, 0x0); 
01484:  CLR.B   111C
01486:  CLR     111E
01488:  CLR     1120
0148A:  CALL    F58
0148E:  MOV     W0,FCC
01490:  MOV     W1,FCE
01492:  MOV     W2,FD0
....................         } while((response.r1._byte != 0x01) && (timeout != 0)); 
01494:  MOV     FCC,W4
01496:  CP.B    W4L,#1
01498:  BRA     Z,149E
0149A:  CP0.B   FD2
0149C:  BRA     NZ,1478
....................  
....................        //Check if response was invalid (R1 response byte should be = 0x01 after GO_IDLE_STATE) 
....................        if(response.r1._byte != 0x01) 
0149E:  MOV     FCC,W4
014A0:  CP.B    W4L,#1
014A2:  BRA     Z,14B0
....................        { 
....................            CloseSPIM(); 
014A4:  CALL    1098
....................            return FALSE; 
014A8:  CLR.B   0
014AA:  BRA     1516
....................        }     
014AC:  GOTO    14CA
....................        else 
....................        { 
....................            //Card is presumably present.  The SDI pin should have a pull up resistor on 
....................            //it, so the odds of SDI "floating" to 0x01 after sending CMD0 is very 
....................            //remote, unless the media is genuinely present.  Therefore, we should 
....................            //try to perform a full card initialization sequence now. 
....................           MDD_SDSPI_MediaInitialize();    //Can block and take a long time to execute. 
014B0:  CALL    10FE
....................           if(mediaInformation.errorCode == MEDIA_NO_ERROR) 
014B4:  CP0.B   DA8
014B6:  BRA     NZ,14C2
....................           { 
....................              /* if the card was initialized correctly, it means it is present */ 
....................              return TRUE; 
014B8:  MOV.B   #1,W0L
014BA:  MOV.B   W0L,0
014BC:  BRA     1516
....................           } 
014BE:  GOTO    14CA
....................           else  
....................           { 
....................               CloseSPIM(); 
014C2:  CALL    1098
....................              return FALSE; 
014C6:  CLR.B   0
014C8:  BRA     1516
....................           }       
....................  
....................        }     
....................    }//if (SPIENABLE == 0) 
014CA:  GOTO    1512
....................    else 
....................    { 
....................        //The SPI module was already enabled.  This most likely means the media is 
....................        //present and has already been initialized.  However, it is possible that 
....................        //the user could have unplugged the media, in which case it is no longer 
....................        //present.  We should send it a command, to check the status. 
....................        response = SendMMCCmd(SEND_STATUS,0x0); 
014CE:  MOV.B   #6,W0L
014D0:  MOV.B   W0L,111C
014D2:  CLR     111E
014D4:  CLR     1120
014D6:  CALL    F58
014DA:  MOV     W0,FCC
014DC:  MOV     W1,FCE
014DE:  MOV     W2,FD0
....................        if((response.r2._word & 0xEC0C) != 0x0000) 
014E0:  MOV     #EC0C,W0
014E2:  AND     FCC,W0
014E4:  MOV     W0,W5
014E6:  CP0     W5
014E8:  BRA     Z,150C
....................        { 
....................            //The card didn't respond with the expected result.  This probably 
....................            //means it is no longer present.  We can try to re-initialized it, 
....................            //just to be doubly sure. 
....................           CloseSPIM(); 
014EA:  CALL    1098
....................           MDD_SDSPI_MediaInitialize();    //Can block and take a long time to execute. 
014EE:  CALL    10FE
....................           if(mediaInformation.errorCode == MEDIA_NO_ERROR) 
014F2:  CP0.B   DA8
014F4:  BRA     NZ,1500
....................           { 
....................              /* if the card was initialized correctly, it means it is present */ 
....................              return TRUE; 
014F6:  MOV.B   #1,W0L
014F8:  MOV.B   W0L,0
014FA:  BRA     1516
....................           } 
014FC:  GOTO    1508
....................           else  
....................           { 
....................               CloseSPIM(); 
01500:  CALL    1098
....................              return FALSE; 
01504:  CLR.B   0
01506:  BRA     1516
....................           } 
....................        } 
01508:  GOTO    1512
....................        else 
....................        { 
....................            //The CMD13 response to SEND_STATUS was valid.  This presumably 
....................            //means the card is present and working normally. 
....................            return TRUE; 
0150C:  MOV.B   #1,W0L
0150E:  MOV.B   W0L,0
01510:  BRA     1516
....................         }           
....................  
....................    } 
....................  
....................     //Should theoretically never execute to here.  All pathways should have  
....................     //already returned with the status. 
....................     return TRUE; 
01512:  MOV.B   #1,W0L
01514:  MOV.B   W0L,0
....................  
.................... #endif 
01516:  MOV     [--W15],W5
01518:  RETURN  
....................  
.................... }//end MediaDetect 
....................  
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     WORD MDD_SDSPI_ReadSectorSize (void) 
....................   Summary: 
....................     Determines the current sector size on the SD card 
....................   Conditions: 
....................     MDD_MediaInitialize() is complete 
....................   Input: 
....................     None 
....................   Return: 
....................     The size of the sectors for the physical media 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_ReadSectorSize function is used by the 
....................     USB mass storage class to return the card's sector 
....................     size to the PC on request. 
....................   Remarks: 
....................     None 
....................   *********************************************************/ 
....................  
.................... WORD MDD_SDSPI_ReadSectorSize(void) 
.................... { 
....................     return gMediaSectorSize; 
.................... } 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     DWORD MDD_SDSPI_ReadCapacity (void) 
....................   Summary: 
....................     Determines the current capacity of the SD card 
....................   Conditions: 
....................     MDD_MediaInitialize() is complete 
....................   Input: 
....................     None 
....................   Return: 
....................     The capacity of the device 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_ReadCapacity function is used by the 
....................     USB mass storage class to return the total number 
....................     of sectors on the card. 
....................   Remarks: 
....................     None 
....................   *********************************************************/ 
.................... DWORD MDD_SDSPI_ReadCapacity(void) 
.................... { 
....................     return (MDD_SDSPI_finalLBA); 
.................... } 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     WORD MDD_SDSPI_InitIO (void) 
....................   Summary: 
....................     Initializes the I/O lines connected to the card 
....................   Conditions: 
....................     MDD_MediaInitialize() is complete.  The MDD_InitIO 
....................     function pointer is pointing to this function. 
....................   Input: 
....................     None 
....................   Return: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_InitIO function initializes the I/O 
....................     pins connected to the SD card. 
....................   Remarks: 
....................     None 
....................   *********************************************************/ 
....................  
.................... void MDD_SDSPI_InitIO (void) 
.................... { 
....................     // Turn off the card 
....................    #if !defined(MEDIA_SOFT_DETECT) 
....................     SD_CD_TRIS = INPUT;            //Card Detect - input 
....................    #endif     
....................     SD_CS = 1;                     //Initialize Chip Select line 
*
00EB2:  BSET.B  2F5.0
....................     SD_CS_TRIS = OUTPUT;           //Card Select - output 
00EB4:  BCLR.B  2F1.0
....................    #if defined(SD_WE_TRIS) 
....................     SD_WE_TRIS = INPUT;            //Write Protect - input 
00EB6:  BSET.B  85A.0
....................    #endif 
....................  
.................... #if defined   (__dsPIC33E__) || defined (__PIC24E__) 
00EB8:  RETURN  
....................     SD_CS_ANSEL = 0; 
....................     SD_SCK_ANSEL = 0; 
....................     SD_SDI_ANSEL = 0; 
....................     SD_SDO_ANSEL = 0; 
.................... #endif     
.................... } 
....................  
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     BYTE MDD_SDSPI_ShutdownMedia (void) 
....................   Summary: 
....................     Disables the SD card 
....................   Conditions: 
....................     The MDD_ShutdownMedia function pointer is pointing  
....................     towards this function. 
....................   Input: 
....................     None 
....................   Return: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     This function will disable the SPI port and deselect 
....................     the SD card. 
....................   Remarks: 
....................     None 
....................   *********************************************************/ 
....................  
.................... BYTE MDD_SDSPI_ShutdownMedia(void) 
.................... { 
....................     // close the spi bus 
....................     CloseSPIM(); 
....................      
....................     // deselect the device 
....................     SD_CS = 1; 
....................  
....................     return 0; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     MMC_RESPONSE SendMMCCmd (BYTE cmd, DWORD address) 
....................   Summary: 
....................     Sends a command packet to the SD card. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     None. 
....................   Return Values: 
....................     MMC_RESPONSE    - The response from the card 
....................                     - Bit 0 - Idle state 
....................                     - Bit 1 - Erase Reset 
....................                     - Bit 2 - Illegal Command 
....................                     - Bit 3 - Command CRC Error 
....................                     - Bit 4 - Erase Sequence Error 
....................                     - Bit 5 - Address Error 
....................                     - Bit 6 - Parameter Error 
....................                     - Bit 7 - Unused. Always 0. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     SendMMCCmd prepares a command packet and sends it out over the SPI interface. 
....................     Response data of type 'R1' (as indicated by the SD/MMC product manual is returned. 
....................   Remarks: 
....................     None. 
....................   *****************************************************************************/ 
....................  
.................... MMC_RESPONSE SendMMCCmd(BYTE cmd, DWORD address) 
*
00F58:  MOV     W5,[W15++]
.................... { 
....................     MMC_RESPONSE    response; 
00F5A:  CLR     1122
00F5C:  CLR     1124
00F5E:  CLR     1126
....................     CMD_PACKET  CmdPacket; 
00F60:  CLR     1128
00F62:  CLR     112A
00F64:  CLR     112C
00F66:  CLR     112E
....................     WORD timeout; 
00F68:  CLR     1130
....................     DWORD longTimeout; 
00F6A:  CLR     1132
00F6C:  CLR     1134
....................      
....................     SD_CS = 0;                           //Select card 
00F6E:  BCLR.B  2F5.0
....................      
....................     // Copy over data 
....................     CmdPacket.cmd        = sdmmc_cmdtable[cmd].CmdCode; 
00F70:  MOV.B   111C,W0L
00F72:  CLR.B   1
00F74:  SL      W0,#2,W5
00F76:  MOV     #DBC,W4
00F78:  ADD     W5,W4,W0
00F7A:  MOV     112E,W4
00F7C:  MOV.B   [W0+#0],W4L
00F7E:  MOV     W4,112E
....................     CmdPacket.address    = address; 
00F80:  PUSH    111E
00F82:  POP     112A
00F84:  PUSH    1120
00F86:  POP     112C
....................     CmdPacket.crc        = sdmmc_cmdtable[cmd].CRC;       // Calc CRC here 
00F88:  MOV.B   111C,W0L
00F8A:  CLR.B   1
00F8C:  SL      W0,#2,W5
00F8E:  ADD     W5,#1,W5
00F90:  MOV     W5,W0
00F92:  MOV     #DBC,W4
00F94:  ADD     W0,W4,W0
00F96:  MOV     1128,W4
00F98:  MOV.B   [W0+#0],W4L
00F9A:  MOV     W4,1128
....................      
....................     CmdPacket.TRANSMIT_BIT = 1;             //Set Tranmission bit 
00F9C:  BSET.B  112E.6
....................  
....................      #ifdef __DEBUG_UART   
....................      PrintROMASCIIStringUART("SendMMCCmdFast cmd="); 
....................      PrintRAMBytesUART(((unsigned char*)&cmd), 1); 
....................      PrintROMASCIIStringUART(" cmd="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.cmd), 1); 
....................      PrintROMASCIIStringUART(" addy="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.address), 4); 
....................      PrintROMASCIIStringUART(" crc="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.crc), 1); 
....................      PrintROMASCIIStringUART(" type="); 
....................      char type; 
....................      type = sdmmc_cmdtable[cmd].responsetype; 
....................      PrintRAMBytesUART(((unsigned char*)&type), 1); 
....................      #endif 
....................  
....................     WriteSPIM(CmdPacket.cmd);                //Send Command 
00F9E:  MOV.B   112E,W0L
00FA0:  MOV.B   W0L,113C
00FA2:  CALL    F36
....................     WriteSPIM(CmdPacket.addr3);              //Most Significant Byte 
00FA6:  MOV.B   112D,W0L
00FA8:  MOV.B   W0L,113C
00FAA:  CALL    F36
....................     WriteSPIM(CmdPacket.addr2); 
00FAE:  MOV.B   112C,W0L
00FB0:  MOV.B   W0L,113C
00FB2:  CALL    F36
....................     WriteSPIM(CmdPacket.addr1); 
00FB6:  MOV.B   112B,W0L
00FB8:  MOV.B   W0L,113C
00FBA:  CALL    F36
....................     WriteSPIM(CmdPacket.addr0);              //Least Significant Byte 
00FBE:  MOV.B   112A,W0L
00FC0:  MOV.B   W0L,113C
00FC2:  CALL    F36
....................     WriteSPIM(CmdPacket.crc);                //Send CRC 
00FC6:  MOV.B   1128,W0L
00FC8:  MOV.B   W0L,113C
00FCA:  CALL    F36
....................  
....................     //Special handling for CMD12 (STOP_TRANSMISSION).  The very first byte after 
....................     //sending the command packet may contain bogus non-0xFF data.  This  
....................     //"residual data" byte should not be interpreted as the R1 response byte. 
....................     if(cmd == STOP_TRANSMISSION) 
00FCE:  MOV     111C,W4
00FD0:  CP.B    W4L,#5
00FD2:  BRA     NZ,FD8
....................     { 
....................         MDD_SDSPI_ReadMedia(); //Perform dummy read to fetch the residual non R1 byte 
00FD4:  CALL    F4A
....................     }  
....................  
....................     //Loop until we get a response from the media.  Delay (NCR) could be up  
....................     //to 8 SPI byte times.  First byte of response is always the equivalent of  
....................     //the R1 byte, even for R1b, R2, R3, R7 responses. 
....................     timeout = NCR_TIMEOUT; 
00FD8:  MOV     #14,W4
00FDA:  MOV     W4,1130
....................     do 
....................     { 
....................         response.r1._byte = MDD_SDSPI_ReadMedia(); 
00FDC:  CALL    F4A
00FE0:  MOV.B   W0L,1122
....................         timeout--; 
00FE2:  DEC     1130
....................        #ifdef __DEBUG_UART 
....................         if (response.r1._byte != MMC_FLOATING_BUS) 
....................         { 
....................             PrintROMASCIIStringUART(" r1="); 
....................             PrintRAMBytesUART(&response.r1._byte, 1); 
....................         } 
....................        #endif 
....................     }while((response.r1._byte == MMC_FLOATING_BUS) && (timeout != 0)); 
00FE4:  MOV     1122,W4
00FE6:  XOR.B   #FF,W4L
00FE8:  BRA     NZ,FEE
00FEA:  CP0     1130
00FEC:  BRA     NZ,FDC
....................      
....................     //Check if we should read more bytes, depending upon the response type expected.   
....................     if(sdmmc_cmdtable[cmd].responsetype == R2) 
00FEE:  MOV.B   111C,W0L
00FF0:  CLR.B   1
00FF2:  SL      W0,#2,W5
00FF4:  ADD     W5,#2,W5
00FF6:  MOV     W5,W0
00FF8:  MOV     #DBC,W4
00FFA:  ADD     W0,W4,W0
00FFC:  MOV.B   [W0],W4L
00FFE:  CP.B    W4L,#2
01000:  BRA     NZ,1010
....................     { 
....................         response.r2._byte1 = response.r1._byte; //We already received the first byte, just make sure it is in the correct location in the struct. 
01002:  MOV.B   1122,W0L
01004:  MOV.B   W0L,1123
....................         response.r2._byte0 = MDD_SDSPI_ReadMedia(); //Fetch the second byte of the response. 
01006:  CALL    F4A
0100A:  MOV.B   W0L,1122
....................         
....................        #ifdef __DEBUG_UART 
....................         PrintROMASCIIStringUART(" r2="); 
....................         PrintRAMBytesUART(&response.r2._byte0, 1); 
....................        #endif         
....................     } 
0100C:  GOTO    1074
....................     else if(sdmmc_cmdtable[cmd].responsetype == R1b) 
01010:  MOV.B   111C,W0L
01012:  CLR.B   1
01014:  SL      W0,#2,W5
01016:  ADD     W5,#2,W5
01018:  MOV     W5,W0
0101A:  MOV     #DBC,W4
0101C:  ADD     W0,W4,W0
0101E:  MOV.B   [W0],W4L
01020:  CP.B    W4L,#1
01022:  BRA     NZ,1048
....................     { 
....................         //Keep trying to read from the media, until it signals it is no longer 
....................         //busy.  It will continuously send 0x00 bytes until it is not busy. 
....................         //A non-zero value means it is ready for the next command. 
....................         //The R1b response is received after a CMD12 STOP_TRANSMISSION 
....................         //command, where the media card may be busy writing its internal buffer 
....................         //to the flash memory.  This can typically take a few milliseconds,  
....................         //with a recommended maximum timeout of 250ms or longer for SD cards. 
....................         longTimeout = WRITE_TIMEOUT; 
01024:  CLR     1132
01026:  MOV     #A,W4
01028:  MOV     W4,1134
....................         do 
....................         { 
....................             response.r1._byte = MDD_SDSPI_ReadMedia(); 
0102A:  CALL    F4A
0102E:  MOV.B   W0L,1122
....................             longTimeout--; 
01030:  DEC     1132
01032:  BTSS.B  42.0
01034:  DEC     1134
....................         }while((response.r1._byte == 0x00) && (longTimeout != 0)); 
01036:  CP0.B   1122
01038:  BRA     NZ,1042
0103A:  CP0     1132
0103C:  BRA     NZ,102A
0103E:  CP0     1134
01040:  BRA     NZ,102A
....................  
....................         response.r1._byte = 0x00; 
01042:  CLR.B   1122
....................     } 
01044:  GOTO    1074
....................     else if (sdmmc_cmdtable[cmd].responsetype == R7) //also used for response R3 type 
01048:  MOV.B   111C,W0L
0104A:  CLR.B   1
0104C:  SL      W0,#2,W5
0104E:  ADD     W5,#2,W5
01050:  MOV     W5,W0
01052:  MOV     #DBC,W4
01054:  ADD     W0,W4,W0
01056:  MOV.B   [W0],W4L
01058:  CP.B    W4L,#4
0105A:  BRA     NZ,1074
....................     { 
....................         //Fetch the other four bytes of the R3 or R7 response. 
....................         //Note: The SD card argument response field is 32-bit, big endian format. 
....................         //However, the C compiler stores 32-bit values in little endian in RAM. 
....................         //When writing to the _returnVal/argument bytes, make sure the order it  
....................         //gets stored in is correct.       
....................         response.r7.bytewise.argument._byte3 = MDD_SDSPI_ReadMedia(); 
0105C:  CALL    F4A
01060:  MOV.B   W0L,1127
....................         response.r7.bytewise.argument._byte2 = MDD_SDSPI_ReadMedia(); 
01062:  CALL    F4A
01066:  MOV.B   W0L,1126
....................         response.r7.bytewise.argument._byte1 = MDD_SDSPI_ReadMedia(); 
01068:  CALL    F4A
0106C:  MOV.B   W0L,1125
....................         response.r7.bytewise.argument._byte0 = MDD_SDSPI_ReadMedia(); 
0106E:  CALL    F4A
01072:  MOV.B   W0L,1124
....................     } 
....................  
....................     WriteSPIM(0xFF);    //Device requires at least 8 clock pulses after  
01074:  SETM.B  113C
01076:  CALL    F36
....................                              //the response has been sent, before if can process 
....................                              //the next command.  CS may be high or low. 
....................  
....................     // see if we are expecting more data or not 
....................     if(!(sdmmc_cmdtable[cmd].moredataexpected)) 
0107A:  MOV.B   111C,W0L
0107C:  CLR.B   1
0107E:  SL      W0,#2,W5
01080:  ADD     W5,#3,W5
01082:  MOV     W5,W0
01084:  MOV     #DBC,W4
01086:  ADD     W0,W4,W0
01088:  CP0.B   [W0]
0108A:  BRA     NZ,108E
....................         SD_CS = 1; 
0108C:  BSET.B  2F5.0
....................       
....................      #ifdef __DEBUG_UART 
....................      PrintROMASCIIStringUART(" r1="); 
....................      PrintRAMBytesUART(((unsigned char*)&response.r1._byte), 1); 
....................      #endif 
....................  
....................  
....................     #ifdef __DEBUG_UART   
....................     UARTSendLineFeedCarriageReturn(); 
....................     #endif 
....................  
....................     return(response); 
0108E:  MOV     1122,W0
01090:  MOV     1124,W1
01092:  MOV     1126,W2
01094:  MOV     [--W15],W5
01096:  RETURN  
.................... } 
....................  
.................... #ifdef __18CXX 
.................... /***************************************************************************** 
....................   Function: 
....................     MMC_RESPONSE SendMMCCmdManual (BYTE cmd, DWORD address) 
....................   Summary: 
....................     Sends a command packet to the SD card with bit-bang SPI. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     Need input cmd index into a rom table of implemented commands. 
....................     Also needs 4 bytes of data as address for some commands (also used for 
....................     other purposes in other commands). 
....................   Return Values: 
....................     Assuming an "R1" type of response, each bit will be set depending upon status: 
....................     MMC_RESPONSE    - The response from the card 
....................                     - Bit 0 - Idle state 
....................                     - Bit 1 - Erase Reset 
....................                     - Bit 2 - Illegal Command 
....................                     - Bit 3 - Command CRC Error 
....................                     - Bit 4 - Erase Sequence Error 
....................                     - Bit 5 - Address Error 
....................                     - Bit 6 - Parameter Error 
....................                     - Bit 7 - Unused. Always 0. 
....................     Other response types (ex: R3/R7) have up to 5 bytes of response.  The first 
....................     byte is always the same as the R1 response.  The contents of the other bytes  
....................     depends on the command. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     SendMMCCmd prepares a command packet and sends it out over the SPI interface. 
....................     Response data of type 'R1' (as indicated by the SD/MMC product manual is returned. 
....................     This function is intended to be used when the clock speed of a PIC18 device is 
....................     so high that the maximum SPI divider can't reduce the clock below the maximum 
....................     SD card initialization sequence speed. 
....................   Remarks: 
....................     None. 
....................   ***************************************************************************************/ 
.................... MMC_RESPONSE SendMMCCmdManual(BYTE cmd, DWORD address) 
.................... { 
....................     BYTE index; 
....................     MMC_RESPONSE    response; 
....................     CMD_PACKET  CmdPacket; 
....................     WORD timeout; 
....................      
....................     SD_CS = 0;                           //Select card 
....................      
....................     // Copy over data 
....................     CmdPacket.cmd        = sdmmc_cmdtable[cmd].CmdCode; 
....................     CmdPacket.address    = address; 
....................     CmdPacket.crc        = sdmmc_cmdtable[cmd].CRC;       // Calc CRC here 
....................     
....................     CmdPacket.TRANSMIT_BIT = 1;             //Set Tranmission bit 
....................  
....................      #ifdef __DEBUG_UART   
....................      PrintROMASCIIStringUART("SendMMCCmdManual cmd="); 
....................      PrintRAMBytesUART(((unsigned char*)&cmd), 1); 
....................      PrintROMASCIIStringUART(" cmd="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.cmd), 1); 
....................      PrintROMASCIIStringUART(" addy="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.address), 4); 
....................      PrintROMASCIIStringUART(" crc="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.crc), 1); 
....................      PrintROMASCIIStringUART(" type="); 
....................      char type; 
....................      type = sdmmc_cmdtable[cmd].responsetype; 
....................      PrintRAMBytesUART(((unsigned char*)&type), 1); 
....................      #endif 
....................  
....................     WriteSPIManual(CmdPacket.cmd);                //Send Command 
....................     WriteSPIManual(CmdPacket.addr3);              //Most Significant Byte 
....................     WriteSPIManual(CmdPacket.addr2); 
....................     WriteSPIManual(CmdPacket.addr1); 
....................     WriteSPIManual(CmdPacket.addr0);              //Least Significant Byte 
....................     WriteSPIManual(CmdPacket.crc);                //Send CRC 
....................  
....................     //Special handling for CMD12 (STOP_TRANSMISSION).  The very first byte after 
....................     //sending the command packet may contain bogus non-0xFF data.  This  
....................     //"residual data" byte should not be interpreted as the R1 response byte. 
....................     if(cmd == STOP_TRANSMISSION) 
....................     { 
....................         ReadMediaManual(); //Perform dummy read to fetch the residual non R1 byte 
....................     }  
....................  
....................     //Loop until we get a response from the media.  Delay (NCR) could be up  
....................     //to 8 SPI byte times.  First byte of response is always the equivalent of  
....................     //the R1 byte, even for R1b, R2, R3, R7 responses. 
....................     timeout = NCR_TIMEOUT; 
....................     do 
....................     { 
....................         response.r1._byte = ReadMediaManual(); 
....................         timeout--; 
....................     }while((response.r1._byte == MMC_FLOATING_BUS) && (timeout != 0)); 
....................      
....................  
....................      #ifdef __DEBUG_UART   
....................      PrintROMASCIIStringUART(" r1="); 
....................      PrintRAMBytesUART(((unsigned char*)&response.r1._byte), 1); 
....................      #endif 
....................  
....................     //Check if we should read more bytes, depending upon the response type expected.   
....................     if(sdmmc_cmdtable[cmd].responsetype == R2) 
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART(" getr2"); 
....................         #endif 
....................      
....................         response.r2._byte1 = response.r1._byte; //We already received the first byte, just make sure it is in the correct location in the struct. 
....................         response.r2._byte0 = ReadMediaManual(); //Fetch the second byte of the response. 
....................     } 
....................     else if(sdmmc_cmdtable[cmd].responsetype == R1b) 
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART(" getr1b"); 
....................         #endif     
....................         //Keep trying to read from the media, until it signals it is no longer 
....................         //busy.  It will continuously send 0x00 bytes until it is not busy. 
....................         //A non-zero value means it is ready for the next command. 
....................         timeout = 0xFFFF; 
....................         do 
....................         { 
....................             response.r1._byte = ReadMediaManual(); 
....................             timeout--; 
....................         }while((response.r1._byte == 0x00) && (timeout != 0)); 
....................  
....................         response.r1._byte = 0x00; 
....................     } 
....................     else if (sdmmc_cmdtable[cmd].responsetype == R7) //also used for response R3 type 
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART(" getr7"); 
....................         #endif     
....................         //Fetch the other four bytes of the R3 or R7 response. 
....................         //Note: The SD card argument response field is 32-bit, big endian format. 
....................         //However, the C compiler stores 32-bit values in little endian in RAM. 
....................         //When writing to the _returnVal/argument bytes, make sure the order it  
....................         //gets stored in is correct.       
....................         response.r7.bytewise.argument._byte3 = ReadMediaManual(); 
....................         response.r7.bytewise.argument._byte2 = ReadMediaManual(); 
....................         response.r7.bytewise.argument._byte1 = ReadMediaManual(); 
....................         response.r7.bytewise.argument._byte0 = ReadMediaManual(); 
....................     } 
....................      
....................  
....................     WriteSPIManual(0xFF);    //Device requires at least 8 clock pulses after  
....................                              //the response has been sent, before if can process 
....................                              //the next command.  CS may be high or low. 
....................  
....................     // see if we are expecting more data or not 
....................     if(!(sdmmc_cmdtable[cmd].moredataexpected)) 
....................     { 
....................        #ifdef __DEBUG_UART   
....................        PrintROMASCIIStringUART(" csup"); 
....................        #endif 
....................  
....................         SD_CS = 1; 
....................     } 
....................  
....................      #ifdef __DEBUG_UART   
....................      PrintROMASCIIStringUART(" r1="); 
....................      PrintRAMBytesUART(((unsigned char*)&response.r1._byte), 1); 
....................      #endif 
....................  
....................  
....................     #ifdef __DEBUG_UART   
....................     UARTSendLineFeedCarriageReturn(); 
....................     #endif 
....................  
....................     return(response); 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE MDD_SDSPI_SectorRead (DWORD sector_addr, BYTE * buffer) 
....................   Summary: 
....................     Reads a sector of data from an SD card. 
....................   Conditions: 
....................     The MDD_SectorRead function pointer must be pointing towards this function. 
....................   Input: 
....................     sector_addr - The address of the sector on the card. 
....................     buffer -      The buffer where the retrieved data will be stored.  If 
....................                   buffer is NULL, do not store the data anywhere. 
....................   Return Values: 
....................     TRUE -  The sector was read successfully 
....................     FALSE - The sector could not be read 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The MDD_SDSPI_SectorRead function reads a sector of data bytes (512 bytes)  
....................     of data from the SD card starting at the sector address and stores them in  
....................     the location pointed to by 'buffer.' 
....................   Remarks: 
....................     The card expects the address field in the command packet to be a byte address. 
....................     The sector_addr value is converted to a byte address by shifting it left nine 
....................     times (multiplying by 512). 
....................      
....................     This function performs a synchronous read operation.  In other words, this 
....................     function is a blocking function, and will not return until either the data 
....................     has fully been read, or, a timeout or other error occurred. 
....................   ***************************************************************************************/ 
.................... BYTE MDD_SDSPI_SectorRead(DWORD sector_addr, BYTE* buffer) 
.................... { 
....................     ASYNC_IO info; 
*
01722:  CLR     10F8
01724:  CLR     10FA
01726:  CLR     10FC
01728:  CLR     10FE
0172A:  CLR     1100
0172C:  CLR     1102
0172E:  CLR     1104
....................     BYTE status; 
01730:  CLR.B   1106
....................      
....................     //Initialize info structure for using the MDD_SDSPI_AsyncReadTasks() function. 
....................     info.wNumBytes = 512; 
01732:  MOV     #200,W4
01734:  MOV     W4,10F8
....................     info.dwBytesRemaining = 512; 
01736:  MOV     #200,W4
01738:  MOV     W4,10FA
0173A:  CLR     10FC
....................     info.pBuffer = buffer; 
0173C:  PUSH    10F6
0173E:  POP     10FE
....................     info.dwAddress = sector_addr; 
01740:  PUSH    10F2
01742:  POP     1100
01744:  PUSH    10F4
01746:  POP     1102
....................     info.bStateVariable = ASYNC_READ_QUEUED; 
01748:  MOV.B   #1,W0L
0174A:  MOV.B   W0L,1104
....................      
....................     //Blocking loop, until the state machine finishes reading the sector, 
....................     //or a timeout or other error occurs.  MDD_SDSPI_AsyncReadTasks() will always 
....................     //return either ASYNC_READ_COMPLETE or ASYNC_READ_FAILED eventually  
....................     //(could take awhile in the case of timeout), so this won't be a totally 
....................     //infinite blocking loop. 
....................     while(1) 
....................     { 
....................         status = MDD_SDSPI_AsyncReadTasks(&info); 
0174C:  MOV     #10F8,W4
0174E:  MOV     W4,110C
01750:  CALL    151A
01754:  MOV.B   W0L,1106
....................         if(status == ASYNC_READ_COMPLETE) 
01756:  CP0.B   1106
01758:  BRA     NZ,1764
....................         { 
....................             return TRUE; 
0175A:  MOV.B   #1,W0L
0175C:  MOV.B   W0L,0
0175E:  BRA     1774
....................         } 
01760:  GOTO    176E
....................         else if(status == ASYNC_READ_ERROR) 
01764:  MOV     1106,W4
01766:  XOR.B   #FF,W4L
01768:  BRA     NZ,176E
....................         { 
....................             return FALSE; 
0176A:  CLR.B   0
0176C:  BRA     1774
....................         }  
0176E:  GOTO    174C
....................     }        
....................  
....................     //Impossible to get here, but we will return a value anyay to avoid possible  
....................     //compiler warnings. 
....................     return FALSE; 
01772:  CLR.B   0
01774:  RETURN  
.................... }     
....................  
....................   
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE MDD_SDSPI_AsyncReadTasks(ASYNC_IO* info) 
....................   Summary: 
....................     Speed optimized, non-blocking, state machine based read function that reads  
....................     data packets from the media, and copies them to a user specified RAM buffer. 
....................   Pre-Conditions: 
....................     The ASYNC_IO structure must be initialized correctly, prior to calling 
....................     this function for the first time.  Certain parameters, such as the user 
....................     data buffer pointer (pBuffer) in the ASYNC_IO struct are allowed to be changed 
....................     by the application firmware, in between each call to MDD_SDSPI_AsyncReadTasks(). 
....................     Additionally, the media and microcontroller SPI module should have already  
....................     been initalized before using this function.  This function is mutually 
....................     exclusive with the MDD_SDSPI_AsyncWriteTasks() function.  Only one operation 
....................     (either one read or one write) is allowed to be in progress at a time, as 
....................     both functions share statically allocated resources and monopolize the SPI bus. 
....................   Input: 
....................     ASYNC_IO* info -        A pointer to a ASYNC_IO structure.  The  
....................                             structure contains information about how to complete 
....................                             the read operation (ex: number of total bytes to read, 
....................                             where to copy them once read, maximum number of bytes 
....................                             to return for each call to MDD_SDSPI_AsyncReadTasks(), etc.). 
....................   Return Values: 
....................     BYTE - Returns a status byte indicating the current state of the read  
....................             operation. The possible return values are: 
....................              
....................             ASYNC_READ_BUSY - Returned when the state machine is busy waiting for 
....................                              a data start token from the media.  The media has a 
....................                              random access time, which can often be quite long 
....................                              (<= ~3ms typ, with maximum of 100ms).  No data 
....................                              has been copied yet in this case, and the application 
....................                              should keep calling MDD_SDSPI_AsyncReadTasks() until either 
....................                              an error/timeout occurs, or ASYNC_READ_NEW_PACKET_READY 
....................                              is returned. 
....................             ASYNC_READ_NEW_PACKET_READY -   Returned after a single packet, of 
....................                                             the specified size (in info->numBytes), 
....................                                             is ready to be read from the  
....................                                             media and copied to the user  
....................                                             specified data buffer.  Often, after 
....................                                             receiving this return value, the  
....................                                             application firmware would want to 
....................                                             update the info->pReceiveBuffer pointer 
....................                                             before calling MDD_SDSPI_AsyncReadTasks() 
....................                                             again.  This way, the application can 
....................                                             begin fetching the next packet worth 
....................                                             of data, while still using/consuming 
....................                                             the previous packet of data. 
....................             ASYNC_READ_COMPLETE - Returned when all data bytes in the read  
....................                                  operation have been read and returned successfully, 
....................                                  and the media is now ready for the next operation. 
....................             ASYNC_READ_ERROR - Returned when some failure occurs.  This could be 
....................                                either due to a media timeout, or due to some other 
....................                                unknown type of error.  In this case, the  
....................                                MDD_SDSPI_AsyncReadTasks() handler will terminate 
....................                                the read attempt and will try to put the media  
....................                                back in a default state, ready for a new command.   
....................                                The application firmware may then retry the read 
....................                                attempt (if desired) by re-initializing the  
....................                                ASYNC_IO structure and setting the  
....................                                bStateVariable = ASYNC_READ_QUEUED. 
....................  
....................              
....................   Side Effects: 
....................     Uses the SPI bus and the media.  The media and SPI bus should not be 
....................     used by any other function until the read operation has either completed 
....................     successfully, or returned with the ASYNC_READ_ERROR condition. 
....................   Description: 
....................     Speed optimized, non-blocking, state machine based read function that reads  
....................     data packets from the media, and copies them to a user specified RAM buffer. 
....................     This function uses the multi-block read command (and stop transmission command)  
....................     to perform fast reads of data.  The total amount of data that will be returned  
....................     on any given call to MDD_SDSPI_AsyncReadTasks() will be the info->numBytes parameter. 
....................     However, if the function is called repeatedly, with info->bytesRemaining set 
....................     to a large number, this function can successfully fetch data sizes >> than 
....................     the block size (theoretically anything up to ~4GB, since bytesRemaining is  
....................     a 32-bit DWORD).  The application firmware should continue calling  
....................     MDD_SDSPI_AsyncReadTasks(), until the ASYNC_READ_COMPLETE value is returned  
....................     (or ASYNC_READ_ERROR), even if it has already received all of the data expected. 
....................     This is necessary, so the state machine can issue the CMD12 (STOP_TRANMISSION)  
....................     to terminate the multi-block read operation, once the total expected number  
....................     of bytes have been read.  This puts the media back into the default state  
....................     ready for a new command. 
....................      
....................     During normal/successful operations, calls to MDD_SDSPI_AsyncReadTasks()  
....................     would typically return: 
....................     1. ASYNC_READ_BUSY - repeatedly up to several milliseconds, then  
....................     2. ASYNC_READ_NEW_PACKET_READY - repeatedly, until 512 bytes [media read  
....................         block size] is received, then  
....................     3. Back to ASYNC_READ_BUSY (for awhile, may be short), then 
....................     4. Back to ASYNC_READ_NEW_PACKET_READY (repeatedly, until the next 512 byte 
....................        boundary, then back to #3, etc. 
....................     5. After all data is received successfully, then the function will return  
....................        ASYNC_READ_COMPLETE, for all subsequent calls (until a new read operation 
....................        is started, by re-initializing the ASYNC_IO structure, and re-calling 
....................        the function). 
....................      
....................   Remarks: 
....................     This function will monopolize the SPI module during the operation.  Do not 
....................     use the SPI module for any other purpose, while a fetch operation is in 
....................     progress.  Additionally, the ASYNC_IO structure must not be modified 
....................     in a different context, while the MDD_SDSPI_AsyncReadTasks() function is executing. 
....................     In between calls to MDD_SDSPI_AsyncReadTasks(), certain parameters, namely the 
....................     info->numBytes and info->pReceiveBuffer are allowed to change however. 
....................      
....................     The bytesRemaining value must always be an exact integer multiple of numBytes  
....................     for the function to operate correctly.  Additionally, it is recommended, although 
....................     not essential, for the bytesRemaining to be an integer multiple of the media 
....................     read block size. 
....................      
....................     When starting a read operation, the info->stateVariable must be initalized to 
....................     ASYNC_READ_QUEUED.  All other fields in the info structure should also be 
....................     initialized correctly. 
....................      
....................     The info->wNumBytes must always be less than or equal to the media block size, 
....................     (which is 512 bytes).  Additionally, info->wNumBytes must always be an exact  
....................     integer factor of the media block size (unless info->dwBytesRemaining is less 
....................     than the media block size).  Example values that are allowed for info->wNumBytes 
....................     are: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512. 
....................   *****************************************************************************/ 
....................  
.................... BYTE MDD_SDSPI_AsyncReadTasks(ASYNC_IO* info) 
*
0151A:  MOV     W5,[W15++]
.................... { 
....................     BYTE bData; 
0151C:  CLR.B   110E
....................     MMC_RESPONSE response; 
0151E:  CLR     1110
01520:  CLR     1112
01522:  CLR     1114
....................     static WORD blockCounter; 
....................     static DWORD longTimeoutCounter; 
....................     static BOOL SingleBlockRead; 
....................      
....................     //Check what state we are in, to decide what to do. 
....................     switch(info->bStateVariable) 
01524:  MOV     #C,W0
01526:  ADD     110C,W0
01528:  MOV     W0,W5
0152A:  MOV.B   [W5],W0L
0152C:  CLR.B   1
0152E:  XOR     #0,W0
01530:  BRA     Z,1548
01532:  XOR     #1,W0
01534:  BRA     Z,154C
01536:  XOR     #2,W0
01538:  BRA     Z,15DA
0153A:  XOR     #1,W0
0153C:  BRA     Z,163C
0153E:  XOR     #FC,W0
01540:  BRA     Z,16F6
01542:  XOR     #1,W0
01544:  BRA     Z,1710
01546:  BRA     1710
....................     { 
....................         case ASYNC_READ_COMPLETE: 
....................             return ASYNC_READ_COMPLETE; 
01548:  CLR.B   0
0154A:  BRA     171E
....................         case ASYNC_READ_QUEUED: 
....................             //Start the read request.   
....................              
....................             //Initialize some variables we will use later. 
....................             blockCounter = MEDIA_BLOCK_SIZE; //Counter will be used later for block boundary tracking 
0154C:  MOV     #200,W4
0154E:  MOV     W4,E0C
....................             ioInfo = *info; //Get local copy of structure, for quicker access with less code size 
01550:  MOV     110C,W0
01552:  MOV     #DAE,W1
01554:  MOV     W0,W2
01556:  REPEAT  #D
01558:  MOV.B   [W2++],[W1++]
....................  
....................             //SDHC cards are addressed on a 512 byte block basis.  This is 1:1 equivalent 
....................             //to LBA addressing.  For standard capacity media, the media is expecting 
....................             //a complete byte address.  Therefore, to convert from the LBA address to the 
....................             //byte address, we need to multiply by 512. 
....................             if (gSDMode == SD_MODE_NORMAL) 
0155A:  CP0.B   DA6
0155C:  BRA     NZ,156C
....................             { 
....................                 ioInfo.dwAddress <<= 9; //Equivalent to multiply by 512 
0155E:  MOV     #9,W4
01560:  INC     W4,W4
01562:  DEC     W4,W4
01564:  BRA     Z,156C
01566:  SL      DB6
01568:  RLC     DB8
0156A:  BRA     1562
....................             }   
....................             if(ioInfo.dwBytesRemaining <= MEDIA_BLOCK_SIZE) 
0156C:  MOV     DB2,W4
0156E:  CP      W4,#0
01570:  BRA     GTU,1598
01572:  BRA     NC,157C
01574:  MOV     DB0,W4
01576:  MOV     #200,W3
01578:  CP      W3,W4
0157A:  BRA     NC,1598
....................             { 
....................                 SingleBlockRead = TRUE; 
0157C:  BSET.B  85A.2
....................                 response = SendMMCCmd(READ_SINGLE_BLOCK, ioInfo.dwAddress); 
0157E:  MOV.B   #8,W0L
01580:  MOV.B   W0L,111C
01582:  PUSH    DB6
01584:  POP     111E
01586:  PUSH    DB8
01588:  POP     1120
0158A:  CALL    F58
0158E:  MOV     W0,1110
01590:  MOV     W1,1112
01592:  MOV     W2,1114
....................             }     
01594:  GOTO    15B0
....................             else 
....................             { 
....................                 SingleBlockRead = FALSE; 
01598:  BCLR.B  85A.2
....................                 response = SendMMCCmd(READ_MULTI_BLOCK, ioInfo.dwAddress); 
0159A:  MOV.B   #9,W0L
0159C:  MOV.B   W0L,111C
0159E:  PUSH    DB6
015A0:  POP     111E
015A2:  PUSH    DB8
015A4:  POP     1120
015A6:  CALL    F58
015AA:  MOV     W0,1110
015AC:  MOV     W1,1112
015AE:  MOV     W2,1114
....................             }     
....................             //Note: SendMMCmd() sends 8 SPI clock cycles after getting the 
....................             //response.  This meets the NAC min timing paramemter, so we don't 
....................             //need additional clocking here. 
....................              
....................             // Make sure the command was accepted successfully 
....................             if(response.r1._byte != 0x00) 
015B0:  CP0.B   1110
015B2:  BRA     Z,15C4
....................             { 
....................                 //Perhaps the card isn't initialized or present. 
....................                 info->bStateVariable = ASYNC_READ_ABORT; 
015B4:  MOV     #C,W0
015B6:  ADD     110C,W0
015B8:  MOV     W0,W5
015BA:  MOV.B   #FE,W0L
015BC:  MOV.B   W0L,[W5]
....................                 return ASYNC_READ_BUSY;  
015BE:  MOV.B   #1,W0L
015C0:  MOV.B   W0L,0
015C2:  BRA     171E
....................             } 
....................              
....................             //We successfully sent the READ_MULTI_BLOCK command to the media. 
....................             //We now need to keep polling the media until it sends us the data 
....................             //start token byte. 
....................             longTimeoutCounter = NAC_TIMEOUT; //prepare timeout counter for next state 
015C4:  CLR     E0E
015C6:  MOV     #4,W4
015C8:  MOV     W4,E10
....................             info->bStateVariable = ASYNC_READ_WAIT_START_TOKEN; 
015CA:  MOV     #C,W0
015CC:  ADD     110C,W0
015CE:  MOV     W0,W5
015D0:  MOV.B   #3,W0L
015D2:  MOV.B   W0L,[W5]
....................             return ASYNC_READ_BUSY; 
015D4:  MOV.B   #1,W0L
015D6:  MOV.B   W0L,0
015D8:  BRA     171E
....................         case ASYNC_READ_WAIT_START_TOKEN: 
....................             //In this case, we have already issued the READ_MULTI_BLOCK command 
....................             //to the media, and we need to keep polling the media until it sends 
....................             //us the data start token byte.  This could typically take a  
....................             //couple/few milliseconds, up to a maximum of 100ms. 
....................             if(longTimeoutCounter != 0x00000000) 
015DA:  CP0     E0E
015DC:  BRA     NZ,15E2
015DE:  CP0     E10
015E0:  BRA     Z,162C
....................             { 
....................                 longTimeoutCounter--; 
015E2:  DEC     0E0E
015E4:  BTSS.B  42.0
015E6:  DEC     0E10
....................                 bData = MDD_SDSPI_ReadMedia(); 
015E8:  CALL    F4A
015EC:  MOV.B   W0L,110E
....................                  
....................                 if(bData != MMC_FLOATING_BUS) 
015EE:  MOV     110E,W4
015F0:  XOR.B   #FF,W4L
015F2:  BRA     Z,1622
....................                 { 
....................                     if(bData == DATA_START_TOKEN) 
015F4:  MOV     110E,W4
015F6:  XOR.B   #FE,W4L
015F8:  BRA     NZ,160E
....................                     {    
....................                         //We got the start token.  Ready to receive the data 
....................                         //block now. 
....................                         info->bStateVariable = ASYNC_READ_NEW_PACKET_READY; 
015FA:  MOV     #C,W0
015FC:  ADD     110C,W0
015FE:  MOV     W0,W5
01600:  MOV.B   #2,W0L
01602:  MOV.B   W0L,[W5]
....................                         return ASYNC_READ_NEW_PACKET_READY; 
01604:  MOV.B   #2,W0L
01606:  MOV.B   W0L,0
01608:  BRA     171E
....................                     } 
0160A:  GOTO    161E
....................                     else 
....................                     { 
....................                         //We got an unexpected non-0xFF, non-start token byte back? 
....................                         //Some kind of error must have occurred.  
....................                         info->bStateVariable = ASYNC_READ_ABORT;  
0160E:  MOV     #C,W0
01610:  ADD     110C,W0
01612:  MOV     W0,W5
01614:  MOV.B   #FE,W0L
01616:  MOV.B   W0L,[W5]
....................                         return ASYNC_READ_BUSY; 
01618:  MOV.B   #1,W0L
0161A:  MOV.B   W0L,0
0161C:  BRA     171E
....................                     }         
....................                 } 
0161E:  GOTO    1628
....................                 else 
....................                 { 
....................                     //Media is still busy.  Start token not received yet. 
....................                     return ASYNC_READ_BUSY; 
01622:  MOV.B   #1,W0L
01624:  MOV.B   W0L,0
01626:  BRA     171E
....................                 }                     
....................             }  
01628:  GOTO    163C
....................             else 
....................             { 
....................                 //The media didn't respond with the start data token in the timeout 
....................                 //interval allowed.  Operation failed.  Abort the operation. 
....................                 info->bStateVariable = ASYNC_READ_ABORT;  
0162C:  MOV     #C,W0
0162E:  ADD     110C,W0
01630:  MOV     W0,W5
01632:  MOV.B   #FE,W0L
01634:  MOV.B   W0L,[W5]
....................                 return ASYNC_READ_BUSY;                 
01636:  MOV.B   #1,W0L
01638:  MOV.B   W0L,0
0163A:  BRA     171E
....................             }        
....................             //Should never execute to here 
....................              
....................         case ASYNC_READ_NEW_PACKET_READY: 
....................             //We have sent the READ_MULTI_BLOCK command and have successfully 
....................             //received the data start token byte.  Therefore, we are ready 
....................             //to receive raw data bytes from the media. 
....................             if(ioInfo.dwBytesRemaining != 0x00000000) 
0163C:  CP0     DB0
0163E:  BRA     NZ,1644
01640:  CP0     DB2
01642:  BRA     Z,16D2
....................             { 
....................                 //Re-update local copy of pointer and number of bytes to read in this 
....................                 //call.  These parameters are allowed to change between packets. 
....................                 ioInfo.wNumBytes = info->wNumBytes; 
01644:  MOV     #0,W0
01646:  ADD     110C,W0
01648:  MOV     [W0],[W15++]
0164A:  POP     DAE
....................                   ioInfo.pBuffer = info->pBuffer; 
0164C:  MOV     #6,W0
0164E:  ADD     110C,W0
01650:  MOV     [W0],[W15++]
01652:  POP     DB4
....................                    
....................                   //Update counters for state tracking and loop exit condition tracking. 
....................                 ioInfo.dwBytesRemaining -= ioInfo.wNumBytes; 
01654:  MOV     DB0,W4
01656:  MOV     DAE,W3
01658:  SUB     W4,W3,W0
0165A:  MOV     W0,DB0
0165C:  MOV     DB2,W4
0165E:  SUBB    W4,#0,W0
01660:  MOV     W0,DB2
....................                 blockCounter -= ioInfo.wNumBytes; 
01662:  MOV     E0C,W4
01664:  MOV     DAE,W3
01666:  SUB     W4,W3,W0
01668:  MOV     W0,E0C
....................  
....................                 //Now read a ioInfo.wNumBytes packet worth of SPI bytes,  
....................                 //and place the received bytes in the user specified pBuffer. 
....................                 //This operation directly dictates data thoroughput in the  
....................                 //application, therefore optimized code should be used for each  
....................                 //processor type. 
....................                #if defined __C30__ || defined __C32__ 
....................                 { 
....................                     //PIC24/dsPIC/PIC32 architecture is efficient with pointers. 
....................                     //Therefore, this code can provide good SPI bus utilization,  
....................                     //provided the compiler optimization level is 's' or '3'. 
....................                     BYTE* localPointer = ioInfo.pBuffer; 
....................                     WORD localCounter = ioInfo.wNumBytes; 
0166A:  PUSH    DB4
0166C:  POP     1116
0166E:  PUSH    DAE
01670:  POP     1118
....................                      
....................                     if(localCounter != 0x0000) 
01672:  CP0     1118
01674:  BRA     Z,16A0
....................                     { 
....................                         localPointer--; 
01676:  DEC     1116
....................                         while(1) 
....................                         { 
....................                             SPIBUF = 0xFF; 
01678:  MOV     #FF,W4
0167A:  MOV     W4,248
....................                             localPointer++; 
0167C:  INC     1116
....................                             if((--localCounter) == 0x0000) 
0167E:  DEC     1118
01680:  CP0     1118
01682:  BRA     NZ,1688
....................                             { 
....................                                break;  
01684:  GOTO    1696
....................                             }  
....................                             while(!SPISTAT_RBF); 
01688:  BTSS.B  240.0
0168A:  BRA     1688
....................                             *localPointer = (BYTE)SPIBUF; 
0168C:  MOV     1116,W5
0168E:  MOV     248,W0
01690:  MOV.B   W0L,[W5+#0]
01692:  GOTO    1678
....................                         } 
....................                         while(!SPISTAT_RBF); 
01696:  BTSS.B  240.0
01698:  BRA     1696
....................                         *localPointer = (BYTE)SPIBUF;   
0169A:  MOV     1116,W5
0169C:  MOV     248,W0
0169E:  MOV.B   W0L,[W5+#0]
....................                     }   
....................                 }     
....................                 #elif defined __18CXX 
....................                     PIC18_Optimized_SPI_Read_Packet(); 
....................                #endif    
....................  
....................                 //Check if we have received a multiple of the media block  
....................                 //size (ex: 512 bytes).  If so, the next two bytes are going to  
....................                 //be CRC values, rather than data bytes.   
....................                 if(blockCounter == 0) 
016A0:  CP0     E0C
016A2:  BRA     NZ,16C8
....................                 { 
....................                     //Read two bytes to receive the CRC-16 value on the data block. 
....................                     MDD_SDSPI_ReadMedia(); 
016A4:  CALL    F4A
....................                     MDD_SDSPI_ReadMedia(); 
016A8:  CALL    F4A
....................                     //Following sending of the CRC-16 value, the media may still 
....................                     //need more access time to internally fetch the next block. 
....................                     //Therefore, it will send back 0xFF idle value, until it is 
....................                     //ready.  Then it will send a new data start token, followed 
....................                     //by the next block of useful data. 
....................                     if(ioInfo.dwBytesRemaining != 0x00000000) 
016AC:  CP0     DB0
016AE:  BRA     NZ,16B4
016B0:  CP0     DB2
016B2:  BRA     Z,16BE
....................                     { 
....................                         info->bStateVariable = ASYNC_READ_WAIT_START_TOKEN; 
016B4:  MOV     #C,W0
016B6:  ADD     110C,W0
016B8:  MOV     W0,W5
016BA:  MOV.B   #3,W0L
016BC:  MOV.B   W0L,[W5]
....................                     } 
....................                     blockCounter = MEDIA_BLOCK_SIZE; 
016BE:  MOV     #200,W4
016C0:  MOV     W4,E0C
....................                     return ASYNC_READ_BUSY; 
016C2:  MOV.B   #1,W0L
016C4:  MOV.B   W0L,0
016C6:  BRA     171E
....................                 } 
....................                      
....................                 return ASYNC_READ_NEW_PACKET_READY; 
016C8:  MOV.B   #2,W0L
016CA:  MOV.B   W0L,0
016CC:  BRA     171E
....................             }//if(ioInfo.dwBytesRemaining != 0x00000000) 
016CE:  GOTO    16F6
....................             else 
....................             { 
....................                 //We completed the read operation successfully and have returned 
....................                 //all data bytes requested. 
....................                 //Send CMD12 to let the media know we are finished reading 
....................                 //blocks from it, if we sent a multi-block read request earlier. 
....................                 if(SingleBlockRead == FALSE) 
016D2:  BTSC.B  85A.2
016D4:  BRA     16E2
....................                 { 
....................                     SendMMCCmd(STOP_TRANSMISSION, 0x00000000); 
016D6:  MOV.B   #5,W0L
016D8:  MOV.B   W0L,111C
016DA:  CLR     111E
016DC:  CLR     1120
016DE:  CALL    F58
....................                 }     
....................                 SD_CS = 1;  //De-select media 
016E2:  BSET.B  2F5.0
....................                 mSend8ClkCycles();   
016E4:  SETM.B  113C
016E6:  CALL    F36
....................                 info->bStateVariable = ASYNC_READ_COMPLETE; 
016EA:  MOV     #C,W0
016EC:  ADD     110C,W0
016EE:  MOV     W0,W5
016F0:  CLR.B   [W5]
....................                 return ASYNC_READ_COMPLETE; 
016F2:  CLR.B   0
016F4:  BRA     171E
....................             } 
....................         case ASYNC_READ_ABORT: 
....................             //If the application firmware wants to cancel a read request. 
....................             info->bStateVariable = ASYNC_READ_ERROR; 
016F6:  MOV     #C,W0
016F8:  ADD     110C,W0
016FA:  MOV     W0,W5
016FC:  SETM.B  [W5]
....................             //Send CMD12 to terminate the multi-block read request. 
....................             response = SendMMCCmd(STOP_TRANSMISSION, 0x00000000); 
016FE:  MOV.B   #5,W0L
01700:  MOV.B   W0L,111C
01702:  CLR     111E
01704:  CLR     1120
01706:  CALL    F58
0170A:  MOV     W0,1110
0170C:  MOV     W1,1112
0170E:  MOV     W2,1114
....................             //Fall through to ASYNC_READ_ERROR/default case. 
....................         case ASYNC_READ_ERROR: 
....................         default: 
....................             //Some error must have happened. 
....................             SD_CS = 1;  //De-select media 
01710:  BSET.B  2F5.0
....................             mSend8ClkCycles();   
01712:  SETM.B  113C
01714:  CALL    F36
....................             return ASYNC_READ_ERROR;  
01718:  SETM.B  0
0171A:  BRA     171E
....................     }//switch(info->stateVariable)     
....................      
....................     //Should never get to here.  All pathways should have already returned. 
....................     return ASYNC_READ_ERROR; 
0171C:  SETM.B  0
0171E:  MOV     [--W15],W5
01720:  RETURN  
.................... }     
....................  
....................  
....................  
....................  
.................... #ifdef __18CXX 
.................... /***************************************************************************** 
....................   Function: 
....................     static void PIC18_Optimized_SPI_Read_Packet(void) 
....................   Summary: 
....................     A private function intended for use internal to the SD-SPI.c file. 
....................     This function reads a specified number of bytes from the SPI module, 
....................     at high speed for optimum thoroughput, and copies them into the user 
....................     specified RAM buffer. 
....................     This function is only implemented and used on PIC18 devices. 
....................   Pre-Conditions: 
....................     The ioInfo.wNumBytes must be pre-initialized prior to calling  
....................     PIC18_Optimized_SPI_Read_Packet(). 
....................     Additionally, the ioInfo.pBuffer must also be pre-initialized, prior 
....................     to calling PIC18_Optimized_SPI_Read_Packet(). 
....................   Input: 
....................     ioInfo.wNumBytes global variable, initialized to the number of bytes to read. 
....................     ioInfo.pBuffer global variable, initialize to point to the RAM location that 
....................         the read data should be copied to. 
....................   Return Values: 
....................     None (although the ioInfo.pBuffer RAM specified will contain new contents) 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     A private function intended for use internal to the SD-SPI.c file. 
....................     This function reads a specified number of bytes from the SPI module, 
....................     at high speed for optimum thoroughput, and copies them into the user 
....................     specified RAM buffer. 
....................     This function is only implemented and used on PIC18 devices. 
....................   Remarks: 
....................     This function is speed optimized, using inline assembly language code, and 
....................     makes use of C compiler managed resources.  It is currently written to work 
....................     with the Microchip MPLAB C18 compiler, and may need modification is built 
....................     with a different PIC18 compiler. 
....................   *****************************************************************************/ 
.................... static void PIC18_Optimized_SPI_Read_Packet(void) 
.................... { 
....................     static WORD FSR0Save; 
....................     static WORD PRODSave; 
....................  
....................     //Make sure the SPI_INTERRUPT_FLAG_ASM has been correctly defined, for the SPI 
....................     //module that is actually being used in the hardware. 
....................     #ifndef SPI_INTERRUPT_FLAG_ASM 
....................         #error "Please define SPI_INTERRUPT_FLAG_ASM.  Double click this message for more info." 
....................         //In the HardwareProfile - [platform name].h file for your project, please 
....................         //add a "#define SPI_INTERRUPT_FLAG_ASM  PIRx, y" definition, where 
....................         //PIRx is the PIR register holding the SSPxIF flag for the SPI module being used 
....................         //to interface with the SD/MMC card, and y is the bit number for the SSPxIF bit (ex: 0-7). 
....................     #endif 
....................  
....................     //Make sure at least one byte needs to be read. 
....................     if(ioInfo.wNumBytes == 0) 
....................     { 
....................         return; 
....................     } 
....................  
....................     //Context save C compiler managed registers that we will modify in this function. 
....................     FSR0Save = FSR0;     
....................     PRODSave = PROD;     
....................      
....................     //Using PRODH and PRODL as convenient 16-bit access bank counter 
....................     PROD = ioInfo.wNumBytes;    //ioInfo.wNumBytes holds the total number of bytes 
....................                                 //this function will read from SPI. 
....................     //Going to use the FSR0 directly.  This is non-conventional, but delivers 
....................     //better performance than using a normal C managed software RAM pointer. 
....................     FSR0 = (WORD)ioInfo.pBuffer; 
....................  
....................     //Initiate the first SPI operation 
....................     WREG = SPIBUF; 
....................     SPI_INTERRUPT_FLAG = 0; 
....................     SPIBUF = 0xFF; 
....................  
.................... #if defined(__CCS__) 
.................... //had to modify this code to get rid of -2 BRA and the ,0 for all byte access 
.................... #endif 
....................  
....................     //Highly speed efficient SPI read loop, written in inline assembly 
....................     //language for best performance.  Total number of bytes that will be fetched 
....................     //is exactly == the value of ioInfo.wNumBytes prior to calling this function. 
....................     _asm 
....................         bra     ASMSPIReadLoopEntryPoint 
....................      
.................... ASMSPIReadLoop: 
....................         //Wait until last hardware SPI transaction is complete 
....................         btfss   SPI_INTERRUPT_FLAG_ASM 
....................         bra     ASMSPIReadLoop 
....................         bcf     SPI_INTERRUPT_FLAG_ASM 
....................  
....................         //Save received byte and start the next transfer 
....................         movf    SPIBUF, 0    //Copy SPIBUF byte into WREG 
....................         setf    SPIBUF       //Write 0xFF to SPIBUF, to start a SPI transaction 
....................         movwf   POSTINC0     //Write the last received byte to the user's RAM buffer 
....................      
.................... ASMSPIReadLoopEntryPoint: 
....................         //Now decrement 16-bit counter for loop exit test condition 
....................         movlw   0x00 
....................         decf    PRODL, 1     //Decrement LSB 
....................         subwfb  PRODH, 1     //Decrement MSB, only if borrow from LSB decrement 
....................         //Check if anymore bytes remain to be sent 
....................         movf    PRODL, 0     //copy PRODL to WREG 
....................         iorwf   PRODH, 0     //Z bit will be set if both PRODL and PRODH == 0x00 
....................         bnz     ASMSPIReadLoop  //Go back and loop if our counter isn't = 0x0000. 
....................  
....................         //Wait until the very last SPI transaction is complete and save the byte 
.................... ASMSPIReadLoopEntryPoint2: 
....................         btfss   SPI_INTERRUPT_FLAG_ASM 
....................         bra     ASMSPIReadLoopEntryPoint2 
....................         movff   SPIBUF, POSTINC0 
....................     _endasm 
....................  
....................     SPI_INTERRUPT_FLAG = 0;     
....................  
....................     //Context restore C compiler managed registers 
....................     PROD = PRODSave; 
....................     FSR0 = FSR0Save;     
.................... }     
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE MDD_SDSPI_AsyncWriteTasks(ASYNC_IO* info) 
....................   Summary: 
....................     Speed optimized, non-blocking, state machine based write function that writes 
....................     data from the user specified buffer, onto the media, at the specified  
....................     media block address. 
....................   Pre-Conditions: 
....................     The ASYNC_IO structure must be initialized correctly, prior to calling 
....................     this function for the first time.  Certain parameters, such as the user 
....................     data buffer pointer (pBuffer) in the ASYNC_IO struct are allowed to be changed 
....................     by the application firmware, in between each call to MDD_SDSPI_AsyncWriteTasks(). 
....................     Additionally, the media and microcontroller SPI module should have already  
....................     been initalized before using this function.  This function is mutually 
....................     exclusive with the MDD_SDSPI_AsyncReadTasks() function.  Only one operation 
....................     (either one read or one write) is allowed to be in progress at a time, as 
....................     both functions share statically allocated resources and monopolize the SPI bus. 
....................   Input: 
....................     ASYNC_IO* info -        A pointer to a ASYNC_IO structure.  The  
....................                             structure contains information about how to complete 
....................                             the write operation (ex: number of total bytes to write, 
....................                             where to obtain the bytes from, number of bytes 
....................                             to write for each call to MDD_SDSPI_AsyncWriteTasks(), etc.). 
....................   Return Values: 
....................     BYTE - Returns a status byte indicating the current state of the write  
....................             operation. The possible return values are: 
....................              
....................             ASYNC_WRITE_BUSY - Returned when the state machine is busy waiting for 
....................                              the media to become ready to accept new data.  The  
....................                              media has write time, which can often be quite long 
....................                              (a few ms typ, with maximum of 250ms).  The application 
....................                              should keep calling MDD_SDSPI_AsyncWriteTasks() until either 
....................                              an error/timeout occurs, ASYNC_WRITE_SEND_PACKET 
....................                              is returned, or ASYNC_WRITE_COMPLETE is returned. 
....................             ASYNC_WRITE_SEND_PACKET -   Returned when the MDD_SDSPI_AsyncWriteTasks() 
....................                                         handler is ready to consume data and send 
....................                                         it to the media.  After ASYNC_WRITE_SEND_PACKET 
....................                                         is returned, the application should make certain 
....................                                         that the info->wNumBytes and pBuffer parameters 
....................                                         are correct, prior to calling  
....................                                         MDD_SDSPI_AsyncWriteTasks() again.  After 
....................                                         the function returns, the application is 
....................                                         then free to write new data into the pBuffer 
....................                                         RAM location.  
....................             ASYNC_WRITE_COMPLETE - Returned when all data bytes in the write 
....................                                  operation have been written to the media successfully, 
....................                                  and the media is now ready for the next operation. 
....................             ASYNC_WRITE_ERROR - Returned when some failure occurs.  This could be 
....................                                either due to a media timeout, or due to some other 
....................                                unknown type of error.  In this case, the  
....................                                MDD_SDSPI_AsyncWriteTasks() handler will terminate 
....................                                the write attempt and will try to put the media  
....................                                back in a default state, ready for a new command.   
....................                                The application firmware may then retry the write 
....................                                attempt (if desired) by re-initializing the  
....................                                ASYNC_IO structure and setting the  
....................                                bStateVariable = ASYNC_WRITE_QUEUED. 
....................  
....................              
....................   Side Effects: 
....................     Uses the SPI bus and the media.  The media and SPI bus should not be 
....................     used by any other function until the read operation has either completed 
....................     successfully, or returned with the ASYNC_WRITE_ERROR condition. 
....................   Description: 
....................     Speed optimized, non-blocking, state machine based write function that writes  
....................     data packets to the media, from a user specified RAM buffer. 
....................     This function uses either the single block or multi-block write command  
....................     to perform fast writes of the data.  The total amount of data that will be  
....................     written on any given call to MDD_SDSPI_AsyncWriteTasks() will be the  
....................     info->numBytes parameter. 
....................     However, if the function is called repeatedly, with info->dwBytesRemaining 
....................     set to a large number, this function can successfully write data sizes >> than 
....................     the block size (theoretically anything up to ~4GB, since dwBytesRemaining is  
....................     a 32-bit DWORD).  The application firmware should continue calling  
....................     MDD_SDSPI_AsyncWriteTasks(), until the ASYNC_WRITE_COMPLETE value is returned  
....................     (or ASYNC_WRITE_ERROR), even if it has already sent all of the data expected. 
....................     This is necessary, so the state machine can finish the write process and  
....................     terminate the multi-block write operation, once the total expected number  
....................     of bytes have been written.  This puts the media back into the default state  
....................     ready for a new command. 
....................      
....................     During normal/successful operations, calls to MDD_SDSPI_AsyncWriteTasks()  
....................     would typically return: 
....................     1. ASYNC_WRITE_SEND_PACKET - repeatedly, until 512 bytes [media read  
....................         block size] is received, then  
....................     2. ASYNC_WRITE_BUSY (for awhile, could be a long time, many milliseconds), then 
....................     3. Back to ASYNC_WRITE_SEND_PACKET (repeatedly, until the next 512 byte 
....................        boundary, then back to #2, etc. 
....................     4. After all data is copied successfully, then the function will return  
....................        ASYNC_WRITE_COMPLETE, for all subsequent calls (until a new write operation 
....................        is started, by re-initializing the ASYNC_IO structure, and re-calling 
....................        the function). 
....................      
....................   Remarks: 
....................     When starting a read operation, the info->stateVariable must be initalized to 
....................     ASYNC_WRITE_QUEUED.  All other fields in the info structure should also be 
....................     initialized correctly. 
....................  
....................     This function will monopolize the SPI module during the operation.  Do not 
....................     use the SPI module for any other purpose, while a write operation is in 
....................     progress.  Additionally, the ASYNC_IO structure must not be modified 
....................     in a different context, while the MDD_SDSPI_AsyncReadTasks() function is  
....................     actively executing. 
....................     In between calls to MDD_SDSPI_AsyncWriteTasks(), certain parameters, namely the 
....................     info->wNumBytes and info->pBuffer are allowed to change however. 
....................      
....................     The dwBytesRemaining value must always be an exact integer multiple of wNumBytes  
....................     for the function to operate correctly.  Additionally, it is required that 
....................     the wNumBytes parameter, must always be less than or equal to the media block size, 
....................     (which is 512 bytes).  Additionally, info->wNumBytes must always be an exact  
....................     integer factor of the media block size.  Example values that are allowed for 
....................     info->wNumBytes are: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512. 
....................   *****************************************************************************/ 
.................... BYTE MDD_SDSPI_AsyncWriteTasks(ASYNC_IO* info) 
*
02918:  MOV     W5,[W15++]
.................... { 
....................     static BYTE data_byte; 
....................     static WORD blockCounter; 
....................     static DWORD WriteTimeout; 
....................     static BYTE command; 
....................     DWORD preEraseBlockCount; 
0291A:  CLR     1102
0291C:  CLR     1104
....................     MMC_RESPONSE response; 
0291E:  CLR     1106
02920:  CLR     1108
02922:  CLR     110A
....................  
....................      
....................     //Check what state we are in, to decide what to do. 
....................     switch(info->bStateVariable) 
02924:  MOV     #C,W0
02926:  ADD     1100,W0
02928:  MOV     W0,W5
0292A:  MOV.B   [W5],W0L
0292C:  CLR.B   1
0292E:  XOR     #0,W0
02930:  BRA     Z,2948
02932:  XOR     #1,W0
02934:  BRA     Z,294C
02936:  XOR     #3,W0
02938:  BRA     Z,2A0C
0293A:  XOR     #1,W0
0293C:  BRA     Z,2AC2
0293E:  XOR     #7,W0
02940:  BRA     Z,2B5A
02942:  XOR     #FA,W0
02944:  BRA     Z,2B8C
02946:  BRA     2BA8
....................     { 
....................         case ASYNC_WRITE_COMPLETE: 
....................             return ASYNC_WRITE_COMPLETE; 
02948:  CLR.B   0
0294A:  BRA     2BBA
....................         case ASYNC_WRITE_QUEUED: 
....................             //Initiate the write sequence. 
....................             blockCounter = MEDIA_BLOCK_SIZE;    //Initialize counter.  Will be used later for block boundary tracking. 
0294C:  MOV     #200,W4
0294E:  MOV     W4,E12
....................  
....................             //Copy input structure into a statically allocated global instance  
....................             //of the structure, for faster local access of the parameters with  
....................             //smaller code size. 
....................             ioInfo = *info; 
02950:  MOV     1100,W0
02952:  MOV     #DAE,W1
02954:  MOV     W0,W2
02956:  REPEAT  #D
02958:  MOV.B   [W2++],[W1++]
....................  
....................             //Check if we are writing only a single block worth of data, or  
....................             //multiple blocks worth of data. 
....................             if(ioInfo.dwBytesRemaining <= MEDIA_BLOCK_SIZE) 
0295A:  MOV     DB2,W4
0295C:  CP      W4,#0
0295E:  BRA     GTU,2972
02960:  BRA     NC,296A
02962:  MOV     DB0,W4
02964:  MOV     #200,W3
02966:  CP      W3,W4
02968:  BRA     NC,2972
....................             { 
....................                 command = WRITE_SINGLE_BLOCK; 
0296A:  MOV.B   #A,W0L
0296C:  MOV.B   W0L,DAD
....................             }     
0296E:  GOTO    29C0
....................             else 
....................             { 
....................                 command = WRITE_MULTI_BLOCK; 
02972:  MOV.B   #B,W0L
02974:  MOV.B   W0L,DAD
....................                  
....................                 //Compute the number of blocks that we are going to be writing in this multi-block write operation. 
....................                 preEraseBlockCount = (ioInfo.dwBytesRemaining >> 9); //Divide by 512 to get the number of blocks to write 
02976:  MOV     #9,W4
02978:  PUSH    DB0
0297A:  POP     1102
0297C:  PUSH    DB2
0297E:  POP     1104
02980:  INC     W4,W4
02982:  DEC     W4,W4
02984:  BRA     Z,298C
02986:  LSR     1104
02988:  RRC     1102
0298A:  BRA     2982
....................                 //Always need to erase at least one block. 
....................                 if(preEraseBlockCount == 0) 
0298C:  CP0     1102
0298E:  BRA     NZ,299A
02990:  CP0     1104
02992:  BRA     NZ,299A
....................                 { 
....................                     preEraseBlockCount++;    
02994:  INC     1102
02996:  BTSC.B  42.1
02998:  INC     1104
....................                 }  
....................      
....................                 //Should send CMD55/ACMD23 to let the media know how many blocks it should  
....................                 //pre-erase.  This isn't essential, but it allows for faster multi-block  
....................                 //writes, and probably also reduces flash wear on the media. 
....................                 response = SendMMCCmd(APP_CMD, 0x00000000);    //Send CMD55 
0299A:  MOV.B   #F,W0L
0299C:  MOV.B   W0L,111C
0299E:  CLR     111E
029A0:  CLR     1120
029A2:  CALL    F58
029A6:  MOV     W0,1106
029A8:  MOV     W1,1108
029AA:  MOV     W2,110A
....................                 if(response.r1._byte == 0x00)   //Check if successful. 
029AC:  CP0.B   1106
029AE:  BRA     NZ,29C0
....................                 { 
....................                     SendMMCCmd(SET_WR_BLK_ERASE_COUNT , preEraseBlockCount);    //Send ACMD23         
029B0:  MOV.B   #13,W0L
029B2:  MOV.B   W0L,111C
029B4:  PUSH    1102
029B6:  POP     111E
029B8:  PUSH    1104
029BA:  POP     1120
029BC:  CALL    F58
....................                 } 
....................             }     
....................  
....................             //The info->dwAddress parameter is the block address. 
....................             //For standard capacity SD cards, the card expects a complete byte address. 
....................             //To convert the block address into a byte address, we multiply by the block size (512). 
....................             //For SDHC (high capacity) cards, the card expects a block address already, so no 
....................             //address cconversion is needed 
....................             if (gSDMode == SD_MODE_NORMAL)   
029C0:  CP0.B   DA6
029C2:  BRA     NZ,29D2
....................             { 
....................                 ioInfo.dwAddress <<= 9;   //<< 9 multiplies by 512 
029C4:  MOV     #9,W4
029C6:  INC     W4,W4
029C8:  DEC     W4,W4
029CA:  BRA     Z,29D2
029CC:  SL      DB6
029CE:  RLC     DB8
029D0:  BRA     29C8
....................             }     
....................  
....................             //Send the write single or write multi command, with the LBA or byte  
....................             //address (depeding upon SDHC or standard capacity card) 
....................             response = SendMMCCmd(command, ioInfo.dwAddress);     
029D2:  MOV.B   DAD,W0L
029D4:  MOV.B   W0L,111C
029D6:  PUSH    DB6
029D8:  POP     111E
029DA:  PUSH    DB8
029DC:  POP     1120
029DE:  CALL    F58
029E2:  MOV     W0,1106
029E4:  MOV     W1,1108
029E6:  MOV     W2,110A
....................  
....................             //See if it was accepted 
....................             if(response.r1._byte != 0x00) 
029E8:  CP0.B   1106
029EA:  BRA     Z,29FC
....................             { 
....................                 //Perhaps the card isn't initialized or present. 
....................                 info->bStateVariable = ASYNC_WRITE_ERROR; 
029EC:  MOV     #C,W0
029EE:  ADD     1100,W0
029F0:  MOV     W0,W5
029F2:  SETM.B  [W5]
....................                 return ASYNC_WRITE_ERROR;  
029F4:  SETM.B  0
029F6:  BRA     2BBA
....................             }     
029F8:  GOTO    2A06
....................             else 
....................             { 
....................                 //Card is ready to receive start token and data bytes. 
....................                 info->bStateVariable = ASYNC_WRITE_TRANSMIT_PACKET; 
029FC:  MOV     #C,W0
029FE:  ADD     1100,W0
02A00:  MOV     W0,W5
02A02:  MOV.B   #2,W0L
02A04:  MOV.B   W0L,[W5]
....................             }  
....................             return ASYNC_WRITE_SEND_PACKET;    
02A06:  MOV.B   #2,W0L
02A08:  MOV.B   W0L,0
02A0A:  BRA     2BBA
....................  
....................         case ASYNC_WRITE_TRANSMIT_PACKET: 
....................             //Check if we just finished programming a block, or we are starting 
....................             //for the first time.  In this case, we need to send the data start token. 
....................             if(blockCounter == MEDIA_BLOCK_SIZE) 
02A0C:  MOV     E12,W4
02A0E:  XOR     #200,W4
02A10:  BRA     NZ,2A2E
....................             { 
....................                 //Send the correct data start token, based on the type of write we are doing 
....................                 if(command == WRITE_MULTI_BLOCK) 
02A12:  MOV     DAC,W4
02A14:  LSR     W4,#8,W4
02A16:  CP.B    W4L,#B
02A18:  BRA     NZ,2A26
....................                 { 
....................                     WriteSPIM(DATA_START_MULTI_BLOCK_TOKEN);    
02A1A:  MOV.B   #FC,W0L
02A1C:  MOV.B   W0L,113C
02A1E:  CALL    F36
....................                 } 
02A22:  GOTO    2A2E
....................                 else 
....................                 { 
....................                     //Else must be a single block write 
....................                     WriteSPIM(DATA_START_TOKEN);    
02A26:  MOV.B   #FE,W0L
02A28:  MOV.B   W0L,113C
02A2A:  CALL    F36
....................                 }         
....................             }  
....................                 
....................             //Update local copy of pointer and byte count.  Application firmware 
....................             //is alllowed to change these between calls to this handler function. 
....................             ioInfo.wNumBytes = info->wNumBytes; 
02A2E:  MOV     #0,W0
02A30:  ADD     1100,W0
02A32:  MOV     [W0],[W15++]
02A34:  POP     DAE
....................             ioInfo.pBuffer = info->pBuffer; 
02A36:  MOV     #6,W0
02A38:  ADD     1100,W0
02A3A:  MOV     [W0],[W15++]
02A3C:  POP     DB4
....................              
....................             //Keep track of variables for loop/state exit conditions. 
....................             ioInfo.dwBytesRemaining -= ioInfo.wNumBytes; 
02A3E:  MOV     DB0,W4
02A40:  MOV     DAE,W3
02A42:  SUB     W4,W3,W0
02A44:  MOV     W0,DB0
02A46:  MOV     DB2,W4
02A48:  SUBB    W4,#0,W0
02A4A:  MOV     W0,DB2
....................             blockCounter -= ioInfo.wNumBytes; 
02A4C:  MOV     E12,W4
02A4E:  MOV     DAE,W3
02A50:  SUB     W4,W3,W0
02A52:  MOV     W0,E12
....................              
....................             //Now send a packet of raw data bytes to the media, over SPI. 
....................             //This code directly impacts data thoroughput in a significant way.   
....................             //Special care should be used to make sure this code is speed optimized. 
....................            #if defined __C30__ || defined __C32__ 
....................             { 
....................                 //PIC24/dsPIC/PIC32 architecture is efficient with pointers and  
....................                 //local variables due to the large number of WREGs available. 
....................                 //Therefore, this code gives good SPI bus utilization, provided 
....................                 //the compiler optimization level is 's' or '3'. 
....................                 BYTE* localPointer = ioInfo.pBuffer;     
....................                 WORD localCounter = ioInfo.wNumBytes; 
02A54:  PUSH    DB4
02A56:  POP     110C
02A58:  PUSH    DAE
02A5A:  POP     110E
....................                 do 
....................                 { 
....................                     SPIBUF = *localPointer++; 
02A5C:  MOV     110C,W0
02A5E:  INC     110C
02A60:  MOV     248,W4
02A62:  MOV.B   [W0+#0],W4L
02A64:  MOV     W4,248
02A66:  CLR.B   249
....................                     localCounter--; 
02A68:  DEC     110E
....................                     while(!SPISTAT_RBF); 
02A6A:  BTSS.B  240.0
02A6C:  BRA     2A6A
....................                     data_byte = SPIBUF; //Dummy read to clear SPISTAT_RBF 
02A6E:  MOV.B   248,W0L
02A70:  MOV.B   W0L,DA7
....................                 }while(localCounter);          
02A72:  CP0     110E
02A74:  BRA     NZ,2A5C
....................             }                        
....................             #elif defined __18CXX    
....................                 PIC18_Optimized_SPI_Write_Packet(); 
....................             #endif 
....................   
....................             //Check if we have finshed sending a 512 byte block.  If so, 
....................             //need to receive 16-bit CRC, and retrieve the data_response token 
....................             if(blockCounter == 0) 
02A76:  CP0     E12
02A78:  BRA     NZ,2ABC
....................             { 
....................                 blockCounter = MEDIA_BLOCK_SIZE;    //Re-initialize counter 
02A7A:  MOV     #200,W4
02A7C:  MOV     W4,E12
....................                  
....................                 //Add code to compute CRC, if using CRC. By default, the media  
....................                 //doesn't use CRC unless it is enabled manually during the card  
....................                 //initialization sequence. 
....................                 mSendCRC();  //Send 16-bit CRC for the data block just sent 
02A7E:  SETM.B  113C
02A80:  CALL    F36
02A84:  SETM.B  113C
02A86:  CALL    F36
....................                  
....................                 //Read response token byte from media, mask out top three don't  
....................                 //care bits, and check if there was an error 
....................                 if((MDD_SDSPI_ReadMedia() & WRITE_RESPONSE_TOKEN_MASK) != DATA_ACCEPTED) 
02A8A:  CALL    F4A
02A8E:  CLR.B   1
02A90:  AND     W0,#1F,W5
02A92:  CP      W5,#5
02A94:  BRA     Z,2AA6
....................                 { 
....................                     //Something went wrong.  Try and terminate as gracefully as  
....................                     //possible, so as allow possible recovery. 
....................                     info->bStateVariable = ASYNC_WRITE_ABORT;  
02A96:  MOV     #C,W0
02A98:  ADD     1100,W0
02A9A:  MOV     W0,W5
02A9C:  MOV.B   #FE,W0L
02A9E:  MOV.B   W0L,[W5]
....................                     return ASYNC_WRITE_BUSY; 
02AA0:  MOV.B   #3,W0L
02AA2:  MOV.B   W0L,0
02AA4:  BRA     2BBA
....................                 } 
....................                  
....................                 //The media will now send busy token (0x00) bytes until 
....................                 //it is internally ready again (after the block is successfully 
....................                 //writen and the card is ready to accept a new block. 
....................                 info->bStateVariable = ASYNC_WRITE_MEDIA_BUSY; 
02AA6:  MOV     #C,W0
02AA8:  ADD     1100,W0
02AAA:  MOV     W0,W5
02AAC:  MOV.B   #3,W0L
02AAE:  MOV.B   W0L,[W5]
....................                 WriteTimeout = WRITE_TIMEOUT;       //Initialize timeout counter 
02AB0:  CLR     E14
02AB2:  MOV     #A,W4
02AB4:  MOV     W4,E16
....................                 return ASYNC_WRITE_BUSY; 
02AB6:  MOV.B   #3,W0L
02AB8:  MOV.B   W0L,0
02ABA:  BRA     2BBA
....................             }//if(blockCounter == 0) 
....................              
....................             //If we get to here, we haven't reached a block boundary yet.  Keep  
....................             //on requesting packets of data from the application. 
....................             return ASYNC_WRITE_SEND_PACKET;    
02ABC:  MOV.B   #2,W0L
02ABE:  MOV.B   W0L,0
02AC0:  BRA     2BBA
....................  
....................         case ASYNC_WRITE_MEDIA_BUSY: 
....................             if(WriteTimeout != 0) 
02AC2:  CP0     E14
02AC4:  BRA     NZ,2ACA
02AC6:  CP0     E16
02AC8:  BRA     Z,2B4A
....................             { 
....................                 WriteTimeout--; 
02ACA:  DEC     0E14
02ACC:  BTSS.B  42.0
02ACE:  DEC     0E16
....................                 mSend8ClkCycles();  //Dummy read to gobble up a byte (ex: to ensure we meet NBR timing parameter) 
02AD0:  SETM.B  113C
02AD2:  CALL    F36
....................                 data_byte = MDD_SDSPI_ReadMedia();  //Poll the media.  Will return 0x00 if still busy.  Will return non-0x00 is ready for next data block. 
02AD6:  CALL    F4A
02ADA:  MOV.B   W0L,DA7
....................                 if(data_byte != 0x00) 
02ADC:  CP0.B   DA7
02ADE:  BRA     Z,2B40
....................                 { 
....................                     //The media is done and is no longer busy.  Go ahead and 
....................                     //either send the next packet of data to the media, or the stop 
....................                     //token if we are finshed. 
....................                     if(ioInfo.dwBytesRemaining == 0) 
02AE0:  CP0     DB0
02AE2:  BRA     NZ,2B2C
02AE4:  CP0     DB2
02AE6:  BRA     NZ,2B2C
....................                     { 
....................                         WriteTimeout = WRITE_TIMEOUT; 
02AE8:  CLR     E14
02AEA:  MOV     #A,W4
02AEC:  MOV     W4,E16
....................                         if(command == WRITE_MULTI_BLOCK) 
02AEE:  MOV     DAC,W4
02AF0:  LSR     W4,#8,W4
02AF2:  CP.B    W4L,#B
02AF4:  BRA     NZ,2B18
....................                         { 
....................                             //We finished sending all bytes of data.  Send the stop token byte. 
....................                             WriteSPIM(DATA_STOP_TRAN_TOKEN); 
02AF6:  MOV.B   #FD,W0L
02AF8:  MOV.B   W0L,113C
02AFA:  CALL    F36
....................                             //After sending the stop transmission token, we need to 
....................                             //gobble up one byte before checking for media busy (0x00). 
....................                             //This is to meet the NBR timing parameter.  During the NBR 
....................                             //interval the SD card may not respond with the busy signal, even 
....................                             //though it is internally busy. 
....................                             mSend8ClkCycles(); 
02AFE:  SETM.B  113C
02B00:  CALL    F36
....................                                                  
....................                             //The media still needs to finish internally writing. 
....................                             info->bStateVariable = ASYNC_STOP_TOKEN_SENT_WAIT_BUSY; 
02B04:  MOV     #C,W0
02B06:  ADD     1100,W0
02B08:  MOV     W0,W5
02B0A:  MOV.B   #4,W0L
02B0C:  MOV.B   W0L,[W5]
....................                             return ASYNC_WRITE_BUSY; 
02B0E:  MOV.B   #3,W0L
02B10:  MOV.B   W0L,0
02B12:  BRA     2BBA
....................                         } 
02B14:  GOTO    2B2C
....................                         else 
....................                         { 
....................                             //In this case we were doing a single block write, 
....................                             //so no stop token is necessary.  In this case we are 
....................                             //now fully complete with the write operation. 
....................                             SD_CS = 1;          //De-select media 
02B18:  BSET.B  2F5.0
....................                             mSend8ClkCycles();   
02B1A:  SETM.B  113C
02B1C:  CALL    F36
....................                             info->bStateVariable = ASYNC_WRITE_COMPLETE; 
02B20:  MOV     #C,W0
02B22:  ADD     1100,W0
02B24:  MOV     W0,W5
02B26:  CLR.B   [W5]
....................                             return ASYNC_WRITE_COMPLETE;                             
02B28:  CLR.B   0
02B2A:  BRA     2BBA
....................                         }                             
....................                          
....................                     } 
....................                     //Else we have more data to write in the multi-block write.     
....................                     info->bStateVariable = ASYNC_WRITE_TRANSMIT_PACKET;   
02B2C:  MOV     #C,W0
02B2E:  ADD     1100,W0
02B30:  MOV     W0,W5
02B32:  MOV.B   #2,W0L
02B34:  MOV.B   W0L,[W5]
....................                     return ASYNC_WRITE_SEND_PACKET;                     
02B36:  MOV.B   #2,W0L
02B38:  MOV.B   W0L,0
02B3A:  BRA     2BBA
....................                 }     
02B3C:  GOTO    2B46
....................                 else 
....................                 { 
....................                     //The media is still busy. 
....................                     return ASYNC_WRITE_BUSY; 
02B40:  MOV.B   #3,W0L
02B42:  MOV.B   W0L,0
02B44:  BRA     2BBA
....................                 }     
....................             } 
02B46:  GOTO    2B5A
....................             else 
....................             { 
....................                 //Timeout occurred.  Something went wrong.  The media should not  
....................                 //have taken this long to finish the write. 
....................                 info->bStateVariable = ASYNC_WRITE_ABORT; 
02B4A:  MOV     #C,W0
02B4C:  ADD     1100,W0
02B4E:  MOV     W0,W5
02B50:  MOV.B   #FE,W0L
02B52:  MOV.B   W0L,[W5]
....................                 return ASYNC_WRITE_BUSY; 
02B54:  MOV.B   #3,W0L
02B56:  MOV.B   W0L,0
02B58:  BRA     2BBA
....................             }         
....................          
....................         case ASYNC_STOP_TOKEN_SENT_WAIT_BUSY: 
....................             //We already sent the stop transmit token for the multi-block write  
....................             //operation.  Now all we need to do, is keep waiting until the card 
....................             //signals it is no longer busy.  Card will keep sending 0x00 bytes 
....................             //until it is no longer busy. 
....................             if(WriteTimeout != 0) 
02B5A:  CP0     E14
02B5C:  BRA     NZ,2B62
02B5E:  CP0     E16
02B60:  BRA     Z,2B8C
....................             { 
....................                 WriteTimeout--; 
02B62:  DEC     0E14
02B64:  BTSS.B  42.0
02B66:  DEC     0E16
....................                 data_byte = MDD_SDSPI_ReadMedia(); 
02B68:  CALL    F4A
02B6C:  MOV.B   W0L,DA7
....................                 //Check if card is no longer busy.   
....................                 if(data_byte != 0x00) 
02B6E:  CP0.B   DA7
02B70:  BRA     Z,2B86
....................                 { 
....................                     //If we get to here, multi-block write operation is fully 
....................                     //complete now.   
....................  
....................                     //Should send CMD13 (SEND_STATUS) after a programming sequence,  
....................                     //to confirm if it was successful or not inside the media. 
....................                                  
....................                     //Prepare to receive the next command. 
....................                     SD_CS = 1;          //De-select media 
02B72:  BSET.B  2F5.0
....................                     mSend8ClkCycles();  //NEC timing parameter clocking 
02B74:  SETM.B  113C
02B76:  CALL    F36
....................                     info->bStateVariable = ASYNC_WRITE_COMPLETE; 
02B7A:  MOV     #C,W0
02B7C:  ADD     1100,W0
02B7E:  MOV     W0,W5
02B80:  CLR.B   [W5]
....................                     return ASYNC_WRITE_COMPLETE; 
02B82:  CLR.B   0
02B84:  BRA     2BBA
....................                 } 
....................                 //If we get to here, the media is still busy with the write. 
....................                 return ASYNC_WRITE_BUSY;     
02B86:  MOV.B   #3,W0L
02B88:  MOV.B   W0L,0
02B8A:  BRA     2BBA
....................             }     
....................             //Timeout occurred.  Something went wrong.  Fall through to ASYNC_WRITE_ABORT. 
....................         case ASYNC_WRITE_ABORT: 
....................             //An error occurred, and we need to stop the write sequence so as to try and allow 
....................             //for recovery/re-attempt later. 
....................             SendMMCCmd(STOP_TRANSMISSION, 0x00000000); 
02B8C:  MOV.B   #5,W0L
02B8E:  MOV.B   W0L,111C
02B90:  CLR     111E
02B92:  CLR     1120
02B94:  CALL    F58
....................             SD_CS = 1;  //deselect media 
02B98:  BSET.B  2F5.0
....................             mSend8ClkCycles();  //After raising CS pin, media may not tri-state data out for 1 bit time. 
02B9A:  SETM.B  113C
02B9C:  CALL    F36
....................             info->bStateVariable = ASYNC_WRITE_ERROR;  
02BA0:  MOV     #C,W0
02BA2:  ADD     1100,W0
02BA4:  MOV     W0,W5
02BA6:  SETM.B  [W5]
....................             //Fall through to default case. 
....................         default: 
....................             //Used for ASYNC_WRITE_ERROR case. 
....................             return ASYNC_WRITE_ERROR;  
02BA8:  SETM.B  0
02BAA:  BRA     2BBA
....................     }//switch(info->stateVariable)     
....................      
....................  
....................     //Should never execute to here.  All pathways should have a hit a return already. 
....................     info->bStateVariable = ASYNC_WRITE_ABORT; 
02BAC:  MOV     #C,W0
02BAE:  ADD     1100,W0
02BB0:  MOV     W0,W5
02BB2:  MOV.B   #FE,W0L
02BB4:  MOV.B   W0L,[W5]
....................     return ASYNC_WRITE_BUSY; 
02BB6:  MOV.B   #3,W0L
02BB8:  MOV.B   W0L,0
02BBA:  MOV     [--W15],W5
02BBC:  RETURN  
.................... }  
....................  
....................  
.................... #ifdef __18CXX    
.................... /***************************************************************************** 
....................   Function: 
....................     static void PIC18_Optimized_SPI_Write_Packet(void) 
....................   Summary: 
....................     A private function intended for use internal to the SD-SPI.c file. 
....................     This function writes a specified number of bytes to the SPI module, 
....................     at high speed for optimum throughput, copied from the user specified RAM 
....................     buffer. 
....................     This function is only implemented and used on PIC18 devices. 
....................   Pre-Conditions: 
....................     The ioInfo.wNumBytes must be pre-initialized prior to calling  
....................     PIC18_Optimized_SPI_Write_Packet(). 
....................     Additionally, the ioInfo.pBuffer must also be pre-initialized, prior 
....................     to calling PIC18_Optimized_SPI_Write_Packet(). 
....................   Input: 
....................     ioInfo.wNumBytes global variable, initialized to the number of bytes to send 
....................     ioInfo.pBuffer global variable, initialized to point to the RAM location that 
....................         contains the data to send out the SPI port 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     A private function intended for use internal to the SD-SPI.c file. 
....................     This function writes a specified number of bytes to the SPI module, 
....................     at high speed for optimum throughput, copied from the user specified RAM 
....................     buffer. 
....................     This function is only implemented and used on PIC18 devices. 
....................   Remarks: 
....................     This function is speed optimized, using inline assembly language code, and 
....................     makes use of C compiler managed resources.  It is currently written to work 
....................     with the Microchip MPLAB C18 compiler, and may need modification if built 
....................     with a different PIC18 compiler. 
....................   *****************************************************************************/ 
.................... static void PIC18_Optimized_SPI_Write_Packet(void) 
.................... { 
....................     static BYTE bData; 
....................     static WORD FSR0Save; 
....................     static WORD PRODSave; 
....................  
....................     //Make sure the SPI_INTERRUPT_FLAG_ASM has been correctly defined, for the SPI 
....................     //module that is actually being used in the hardware. 
....................     #ifndef SPI_INTERRUPT_FLAG_ASM 
....................         #error Please add "#define SPI_INTERRUPT_FLAG_ASM  PIRx, Y" to your hardware profile.  Replace x and Y with appropriate numbers for your SPI module interrupt flag. 
....................     #endif 
....................      
....................     //Make sure at least one byte needs copying. 
....................     if(ioInfo.wNumBytes == 0) 
....................     { 
....................         return; 
....................     }     
....................  
....................     //Context save C compiler managed registers. 
....................     FSR0Save = FSR0;  
....................     PRODSave = PROD; 
....................      
....................     //Using PRODH and PRODL as 16 bit loop counter.  These are convenient since 
....................     //they are always in the access bank. 
....................     PROD = ioInfo.wNumBytes; 
....................     //Using FSR0 directly, for optimal SPI loop speed. 
....................     FSR0 = (WORD)ioInfo.pBuffer;  
....................  
.................... #if defined(__CCS__) 
.................... //had to modify this code to get rid of -2 BRA and the ,0 for all byte access 
.................... #endif 
....................  
....................  
....................     _asm 
....................         movf    POSTINC0, 0  //Fetch next byte to send and store in WREG 
....................         bra     ASMSPIXmitLoopEntryPoint 
.................... ASMSPIXmitLoop:     
....................         movf    POSTINC0, 0  //Pre-Fetch next byte to send and temporarily store in WREG 
....................         //Wait until last hardware SPI transaction is complete 
.................... ASMSPIXmitLoop2: 
....................         btfss   SPI_INTERRUPT_FLAG_ASM 
....................         bra     ASMSPIXmitLoop2 
....................          
.................... ASMSPIXmitLoopEntryPoint: 
....................         //Start the next SPI transaction 
....................         bcf     SPI_INTERRUPT_FLAG_ASM   //Clear interrupt flag 
....................         movwf   SPIBUF      //Write next byte to transmit to SSPBUF 
....................          
....................         //Now decrement byte counter for loop exit condition 
....................         movlw   0x00 
....................         decf    PRODL, 1     //Decrement LSB 
....................         subwfb  PRODH, 1    //Decrement MSB, only if borrow from LSB decrement 
....................         //Check if anymore bytes remain to be sent 
....................         movf    PRODL, 0     //copy PRODL to WREG 
....................         iorwf   PRODH, 0    //Z bit will be set if both PRODL and PRODH == 0x00 
....................         bnz     ASMSPIXmitLoop  //Go back and loop if our counter isn't = 0x0000. 
....................     _endasm 
....................  
....................     //Wait until the last SPI transaction is really complete.   
....................     //Above loop jumps out after the last byte is started, but not finished yet. 
....................     while(!SPI_INTERRUPT_FLAG); 
....................  
....................     //Leave SPI module in a "clean" state, ready for next transaction. 
....................     bData = SPIBUF;         //Dummy read to clear BF flag. 
....................     SPI_INTERRUPT_FLAG = 0; //Clear interrupt flag. 
....................     //Restore C compiler managed registers that we modified 
....................     PROD = PRODSave; 
....................     FSR0 = FSR0Save; 
.................... }     
.................... #endif     
....................  
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE MDD_SDSPI_SectorWrite (DWORD sector_addr, BYTE * buffer, BYTE allowWriteToZero) 
....................   Summary: 
....................     Writes a sector of data to an SD card. 
....................   Conditions: 
....................     The MDD_SectorWrite function pointer must be pointing to this function. 
....................   Input: 
....................     sector_addr -      The address of the sector on the card. 
....................     buffer -           The buffer with the data to write. 
....................     allowWriteToZero - 
....................                      - TRUE -  Writes to the 0 sector (MBR) are allowed 
....................                      - FALSE - Any write to the 0 sector will fail. 
....................   Return Values: 
....................     TRUE -  The sector was written successfully. 
....................     FALSE - The sector could not be written. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_SectorWrite function writes one sector of data (512 bytes)  
....................     of data from the location pointed to by 'buffer' to the specified sector of  
....................     the SD card. 
....................   Remarks: 
....................     The card expects the address field in the command packet to be a byte address. 
....................     The sector_addr value is ocnverted to a byte address by shifting it left nine 
....................     times (multiplying by 512). 
....................   ***************************************************************************************/ 
.................... BYTE MDD_SDSPI_SectorWrite(DWORD sector_addr, BYTE* buffer, BYTE allowWriteToZero) 
.................... { 
....................     static ASYNC_IO info; 
....................     BYTE status; 
02BBE:  CLR.B   10F9
....................      
....................     if(allowWriteToZero == FALSE) 
02BC0:  CP0.B   10F8
02BC2:  BRA     NZ,2BD0
....................     { 
....................         if(sector_addr == 0x00000000) 
02BC4:  CP0     10F2
02BC6:  BRA     NZ,2BD0
02BC8:  CP0     10F4
02BCA:  BRA     NZ,2BD0
....................         { 
....................             return FALSE; 
02BCC:  CLR.B   0
02BCE:  BRA     2C16
....................         }     
....................     }     
....................      
....................     //Initialize structure so we write a single sector worth of data. 
....................     info.wNumBytes = 512; 
02BD0:  MOV     #200,W4
02BD2:  MOV     W4,E18
....................     info.dwBytesRemaining = 512; 
02BD4:  MOV     #200,W4
02BD6:  MOV     W4,E1A
02BD8:  CLR     E1C
....................     info.pBuffer = buffer; 
02BDA:  PUSH    10F6
02BDC:  POP     E1E
....................     info.dwAddress = sector_addr; 
02BDE:  PUSH    10F2
02BE0:  POP     E20
02BE2:  PUSH    10F4
02BE4:  POP     E22
....................     info.bStateVariable = ASYNC_WRITE_QUEUED; 
02BE6:  MOV.B   #1,W0L
02BE8:  MOV.B   W0L,E24
....................      
....................     //Repeatedly call the write handler until the operation is complete (or a 
....................     //failure/timeout occurred). 
....................     while(1) 
....................     { 
....................         status = MDD_SDSPI_AsyncWriteTasks(&info); 
02BEA:  MOV     #E18,W4
02BEC:  MOV     W4,1100
02BEE:  CALL    2918
02BF2:  MOV.B   W0L,10F9
....................         if(status == ASYNC_WRITE_COMPLETE) 
02BF4:  CP0.B   10F9
02BF6:  BRA     NZ,2C02
....................         { 
....................             return TRUE; 
02BF8:  MOV.B   #1,W0L
02BFA:  MOV.B   W0L,0
02BFC:  BRA     2C16
....................         }     
02BFE:  GOTO    2C0E
....................         else if(status == ASYNC_WRITE_ERROR) 
02C02:  MOV     10F8,W4
02C04:  LSR     W4,#8,W4
02C06:  XOR.B   #FF,W4L
02C08:  BRA     NZ,2C0E
....................         { 
....................             return FALSE; 
02C0A:  CLR.B   0
02C0C:  BRA     2C16
....................         } 
02C0E:  GOTO    2BEA
....................     }     
....................     return TRUE; 
02C12:  MOV.B   #1,W0L
02C14:  MOV.B   W0L,0
02C16:  RETURN  
.................... }     
....................  
....................  
....................  
....................  
.................... /******************************************************************************* 
....................   Function: 
....................     BYTE MDD_SDSPI_WriteProtectState 
....................   Summary: 
....................     Indicates whether the card is write-protected. 
....................   Conditions: 
....................     The MDD_WriteProtectState function pointer must be pointing to this function. 
....................   Input: 
....................     None. 
....................   Return Values: 
....................     TRUE -  The card is write-protected 
....................     FALSE - The card is not write-protected 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_WriteProtectState function will determine if the SD card is 
....................     write protected by checking the electrical signal that corresponds to the 
....................     physical write-protect switch. 
....................   Remarks: 
....................     None 
.................... *******************************************************************************/ 
....................  
.................... BYTE MDD_SDSPI_WriteProtectState(void) 
.................... { 
....................    #if defined(SD_WE) 
....................     return(SD_WE); 
*
025A0:  CLR     W0
025A2:  BTSC.B  85A.1
025A4:  INC     W0,W0
....................    #else 
025A6:  RETURN  
....................     return(FALSE); 
....................    #endif 
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................   Function: 
....................     void Delayms (BYTE milliseconds) 
....................   Summary: 
....................     Delay. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     BYTE milliseconds - Number of ms to delay 
....................   Return: 
....................     None. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The Delayms function will delay a specified number of milliseconds.  Used for SPI 
....................     timing. 
....................   Remarks: 
....................     Depending on compiler revisions, this function may not delay for the exact  
....................     time specified.  This shouldn't create a significant problem. 
.................... *******************************************************************************/ 
....................  
.................... void Delayms(BYTE milliseconds) 
.................... { 
....................     BYTE    ms; 
*
0109C:  CLR.B   FFF
....................     DWORD   count; 
0109E:  CLR     1000
010A0:  CLR     1002
....................      
....................     ms = milliseconds; 
010A2:  MOV.B   FFE,W0L
010A4:  MOV.B   W0L,FFF
....................     while (ms--) 
010A6:  MOV.B   FFF,W0L
010A8:  DEC.B   0FFF
010AA:  CP0.B   W0L
010AC:  BRA     Z,10CA
....................     { 
....................         count = MILLISECDELAY; 
010AE:  MOV     #7CB,W4
010B0:  MOV     W4,1000
010B2:  CLR     1002
....................         while (count--); 
010B4:  MOV     1002,W1
010B6:  MOV     1000,W0
010B8:  DEC     1000
010BA:  BTSS.B  42.0
010BC:  DEC     1002
010BE:  CP0     W0
010C0:  BRA     NZ,10B4
010C2:  CP0     W1
010C4:  BRA     NZ,10B4
010C6:  GOTO    10A6
....................     } 
....................     Nop(); 
010CA:  NOP     
....................     return; 
010CC:  RETURN  
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................   Function: 
....................     void CloseSPIM (void) 
....................   Summary: 
....................     Disables the SPI module. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     None. 
....................   Return: 
....................     None. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     Disables the SPI module. 
....................   Remarks: 
....................     None. 
.................... *******************************************************************************/ 
....................  
.................... void CloseSPIM (void) 
.................... { 
.................... #if defined __C30__ || defined __C32__ 
....................  
....................     SPISTAT &= 0x7FFF; 
*
01098:  BCLR.B  241.7
....................  
.................... #elif defined __18CXX 
0109A:  RETURN  
....................  
....................     SPICON1 &= 0xDF; 
....................  
.................... #endif 
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     unsigned char WriteSPIM (unsigned char data_out) 
....................   Summary: 
....................     Writes data to the SD card. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     data_out - The data to write. 
....................   Return: 
....................     0. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The WriteSPIM function will write a byte of data from the microcontroller to the 
....................     SD card. 
....................   Remarks: 
....................     None. 
....................   ***************************************************************************************/ 
....................  
.................... unsigned char WriteSPIM( unsigned char data_out ) 
.................... { 
.................... #ifdef __PIC32MX__ 
....................     BYTE   clear; 
....................     putcSPI((BYTE)data_out); 
....................     clear = getcSPI(); 
....................     return ( 0 );                // return non-negative# 
.................... #elif defined __18CXX 
....................     BYTE clear; 
....................     clear = SPIBUF; 
....................     SPICON1 &= 0x7F;       //__PCH__ __CCS__  clear wcol 
....................     SPI_INTERRUPT_FLAG = 0; 
....................     SPIBUF = data_out; 
....................     if (SPICON1 & 0x80) 
....................         return -1; 
....................     else 
....................         while (!SPI_INTERRUPT_FLAG); 
....................     return 0; 
.................... #else 
....................     BYTE   clear; 
*
00F36:  CLR.B   113D
....................     SPIBUF = data_out;          // write byte to SSP1BUF register 
00F38:  MOV.B   113C,W0L
00F3A:  MOV.B   W0L,248
00F3C:  CLR.B   249
....................     while( !SPISTAT_RBF ); // wait until bus cycle complete 
00F3E:  BTSS.B  240.0
00F40:  BRA     F3E
....................     clear = SPIBUF; 
00F42:  MOV.B   248,W0L
00F44:  MOV.B   W0L,113D
....................     return ( 0 );                // return non-negative# 
00F46:  CLR.B   0
.................... #endif 
00F48:  RETURN  
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE MDD_SDSPI_ReadMedia (void) 
....................   Summary: 
....................     Reads a byte of data from the SD card. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     None. 
....................   Return: 
....................     The byte read. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_ReadMedia function will read one byte from the SPI port. 
....................   Remarks: 
....................     This function replaces ReadSPI, since some implementations of that function 
....................     will initialize SSPBUF/SPIBUF to 0x00 when reading.  The card expects 0xFF. 
....................   ***************************************************************************************/ 
.................... BYTE MDD_SDSPI_ReadMedia(void) 
.................... { 
....................  
.................... #ifdef __C32__ 
....................  
....................     putcSPI((BYTE)0xFF); 
....................     return (BYTE)getcSPI(); 
....................  
.................... #elif defined __18CXX 
....................     BYTE clear; 
....................     clear = SPIBUF; 
....................     SPI_INTERRUPT_FLAG = 0; 
....................     SPIBUF = 0xFF; 
....................     while (!SPI_INTERRUPT_FLAG); 
....................     return SPIBUF; 
....................  
.................... #else 
....................     SPIBUF = 0xFF;                              //Data Out - Logic ones 
00F4A:  MOV     #FF,W4
00F4C:  MOV     W4,248
....................     while(!SPISTAT_RBF);                     //Wait until cycle complete 
00F4E:  BTSS.B  240.0
00F50:  BRA     F4E
....................     return(SPIBUF);                             //Return with byte read 
00F52:  MOV.B   248,W0L
00F54:  MOV.B   W0L,0
.................... #endif 
00F56:  RETURN  
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     void OpenSPIM (unsigned int sync_mode) 
....................   Summary: 
....................     Initializes the SPI module 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     sync_mode - Input parameter that sets the SPI mode/speed. 
....................   Return: 
....................     None. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The OpenSPIM function will enable and configure the SPI module. 
....................   Remarks: 
....................     None. 
....................   ***************************************************************************************/ 
....................  
.................... #ifdef __18CXX 
.................... void OpenSPIM (unsigned char sync_mode) 
.................... #else 
.................... void OpenSPIM( unsigned int sync_mode) 
.................... #endif 
.................... { 
....................     SPISTAT = 0x0000;               // power on state  
*
00EBA:  CLR     240
....................  
....................     //SPI module initilization depends on processor type 
....................     #ifdef __PIC32MX__ 
....................         #if (GetSystemClock() <= 20000000) 
....................             SPIBRG = SPICalutateBRG(GetPeripheralClock(), 10000); 
....................         #else 
....................             SPIBRG = SPICalutateBRG(GetPeripheralClock(), SPI_FREQUENCY); 
....................         #endif 
....................         SPICON1bits.CKP = 1; 
....................         SPICON1bits.CKE = 0; 
....................     #elif defined __C30__ //must be PIC24 or dsPIC device 
....................         SPICON1 = 0x0000;              // power on state 
00EBC:  CLR     242
....................         SPICON1 |= sync_mode;          // select serial mode  
00EBE:  MOV     1006,W0
00EC0:  IOR     242
....................         SPICON1bits.CKP = 1; 
00EC2:  BSET.B  242.6
....................         SPICON1bits.CKE = 0; 
00EC4:  BCLR.B  243.0
....................     #else   //must be __18CXX (PIC18 processor) 
....................         SPICON1 = 0x00;          
....................         SPICON1 |= sync_mode;    
....................         SPISTATbits.CKE = 1; 
....................     #endif 
....................  
....................     SPICLOCK = 0; 
00EC6:  BCLR.B  2E8.3
....................     SPIOUT = 0;                  // define SDO1 as output (master or slave) 
00EC8:  BCLR.B  2E8.2
....................     SPIIN = 1;                  // define SDI1 as input (master or slave) 
00ECA:  BSET.B  2E8.6
....................     SPIENABLE = 1;             // enable synchronous serial port 
00ECC:  BSET.B  241.7
00ECE:  RETURN  
.................... } 
....................  
....................  
.................... #ifdef __18CXX 
.................... // Description: Delay value for the manual SPI clock 
.................... #define MANUAL_SPI_CLOCK_VALUE             1 
.................... /***************************************************************************** 
....................   Function: 
....................     unsigned char WriteSPIManual (unsigned char data_out) 
....................   Summary: 
....................     Write a character to the SD card with bit-bang SPI. 
....................   Conditions: 
....................     Make sure the SDI pin is pre-configured as a digital pin, if it is  
....................     multiplexed with analog functionality. 
....................   Input: 
....................     data_out - Data to send. 
....................   Return: 
....................     0. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     Writes a character to the SD card. 
....................   Remarks: 
....................     The WriteSPIManual function is for use on a PIC18 when the clock speed is so 
....................     high that the maximum SPI clock divider cannot reduce the SPI clock speed below 
....................     the maximum SD card initialization speed. 
....................   ***************************************************************************************/ 
.................... unsigned char WriteSPIManual(unsigned char data_out) 
.................... { 
....................     unsigned char i; 
....................     unsigned char clock; 
....................  
....................     SPICLOCKLAT = 0; 
....................     SPIOUTLAT = 1; 
....................     SPICLOCK = OUTPUT; 
....................     SPIOUT = OUTPUT; 
....................  
....................    //Loop to send out 8 bits of SDO data and associated SCK clock. 
....................    for(i = 0; i < 8; i++) 
....................    { 
....................       SPICLOCKLAT = 0; 
....................       if(data_out & 0x80) 
....................          SPIOUTLAT = 1; 
....................       else 
....................          SPIOUTLAT = 0; 
....................       data_out = data_out << 1;            //Bit shift, so next bit to send is in MSb position 
....................        clock = MANUAL_SPI_CLOCK_VALUE; 
....................        while (clock--); 
....................        SPICLOCKLAT = 1; 
....................        clock = MANUAL_SPI_CLOCK_VALUE; 
....................        while (clock--);              
....................    }    
....................     SPICLOCKLAT = 0; 
....................  
....................     return 0;  
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE ReadMediaManual (void) 
....................   Summary: 
....................     Reads a byte of data from the SD card. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     None. 
....................   Return: 
....................     The byte read. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_ReadMedia function will read one byte from the SPI port. 
....................   Remarks: 
....................     This function replaces ReadSPI, since some implementations of that function 
....................     will initialize SSPBUF/SPIBUF to 0x00 when reading.  The card expects 0xFF. 
....................     This function is for use on a PIC18 when the clock speed is so high that the 
....................     maximum SPI clock prescaler cannot reduce the SPI clock below the maximum SD card 
....................     initialization speed. 
....................   ***************************************************************************************/ 
.................... BYTE ReadMediaManual (void) 
.................... { 
....................     unsigned char i; 
....................     unsigned char clock; 
....................     unsigned char result = 0x00; 
....................  
....................     SPIOUTLAT = 1; 
....................     SPIOUT = OUTPUT; 
....................     SPIIN = INPUT; 
....................     SPICLOCKLAT = 0; 
....................     SPICLOCK = OUTPUT; 
....................   
....................     //Loop to send 8 clock pulses and read in the returned bits of data. Data "sent" will be = 0xFF 
....................    for(i = 0; i < 8u; i++) 
....................    { 
....................       SPICLOCKLAT = 0; 
....................        clock = MANUAL_SPI_CLOCK_VALUE; 
....................        while (clock--); 
....................        SPICLOCKLAT = 1; 
....................        clock = MANUAL_SPI_CLOCK_VALUE; 
....................        while (clock--); 
....................       result = result << 1;   //Bit shift the previous result.  We receive the byte MSb first. This operation makes LSb = 0.   
....................        if(SPIINPORT) 
....................           result++;         //Set the LSb if we detected a '1' on the SPIINPORT pin, otherwise leave as 0. 
....................    }    
....................     SPICLOCKLAT = 0; 
....................  
....................     return result; 
.................... }//end ReadMedia 
.................... #endif      // End __18CXX 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     void InitSPISlowMode(void) 
....................   Summary: 
....................     Initializes the SPI module to operate at low SPI frequency <= 400kHz. 
....................   Conditions: 
....................     Processor type and GetSystemClock() macro have to be defined correctly 
....................     to get the correct SPI frequency. 
....................   Input: 
....................     Uses GetSystemClock() macro value.  Should be #define in the hardwareprofile. 
....................   Return Values: 
....................     None.  Initializes the hardware SPI module (except on PIC18).  On PIC18, 
....................     The SPI is bit banged to achieve low frequencies, but this function still 
....................     initializes the I/O pins.  
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     This function initalizes and enables the SPI module, configured for low  
....................     SPI frequency, so as to be compatible with media cards which require <400kHz 
....................     SPI frequency during initialization. 
....................   Remarks: 
....................     None. 
....................   ***************************************************************************************/ 
.................... void InitSPISlowMode(void) 
.................... { 
....................     #if defined __C30__ || defined __C32__ 
00ED0:  MOV     W5,[W15++]
00ED2:  MOV     W6,[W15++]
00ED4:  MOV     #3,W4
00ED6:  MOV     W4,FFE
....................        #ifdef __PIC32MX__ 
....................           OpenSPI(SPI_START_CFG_1, SPI_START_CFG_2); 
....................            SPIBRG = SPICalutateBRG(GetPeripheralClock(), 400000); 
....................        #else //else C30 = PIC24/dsPIC devices 
....................           WORD spiconvalue = 0x0003; 
....................             WORD timeout; 
00ED8:  CLR     1000
....................            // Calculate the prescaler needed for the clock 
....................            timeout = GetSystemClock() / 400000; 
00EDA:  MOV     #50,W4
00EDC:  MOV     W4,1000
....................            // if timeout is less than 400k and greater than 100k use a 1:1 prescaler 
....................            if (timeout == 0) 
00EDE:  CP0     1000
00EE0:  BRA     NZ,EEE
....................            { 
....................                OpenSPIM (MASTER_ENABLE_ON | PRI_PRESCAL_1_1 | SEC_PRESCAL_1_1); 
00EE2:  MOV     #3F,W4
00EE4:  MOV     W4,1006
00EE6:  CALL    EBA
....................            } 
00EEA:  GOTO    F30
....................            else 
....................            { 
....................                while (timeout != 0) 
00EEE:  CP0     1000
00EF0:  BRA     Z,F18
....................                { 
....................                    if (timeout > 8) 
00EF2:  MOV     1000,W4
00EF4:  CP      W4,#8
00EF6:  BRA     LEU,F10
....................                    { 
....................                        spiconvalue--; 
00EF8:  DEC     0FFE
....................                        // round up 
....................                        if ((timeout % 4) != 0) 
00EFA:  MOV     1000,W0
00EFC:  AND     W0,#3,W5
00EFE:  CP0     W5
00F00:  BRA     Z,F08
....................                            timeout += 4; 
00F02:  MOV     1000,W4
00F04:  ADD     W4,#4,W4
00F06:  MOV     W4,1000
....................                        timeout /= 4; 
00F08:  LSR     1000
00F0A:  LSR     1000
....................                    } 
00F0C:  GOTO    F14
....................                    else 
....................                    { 
....................                        break; 
00F10:  GOTO    F18
....................                    } 
00F14:  GOTO    EEE
....................                } 
....................                 
....................                timeout--; 
00F18:  DEC     1000
....................             
....................                OpenSPIM (MASTER_ENABLE_ON | spiconvalue | ((~(timeout << 2)) & 0x1C)); 
00F1A:  MOV     FFE,W5
00F1C:  IOR     #20,W5
00F1E:  MOV     1000,W0
00F20:  SL      W0,#2,W0
00F22:  COM     W0,W0
00F24:  MOV     W0,W6
00F26:  AND     W6,#1C,W0
00F28:  IOR      W5,  W0,W5
00F2A:  MOV     W5,1006
00F2C:  CALL    EBA
....................            } 
....................        #endif   //#ifdef __PIC32MX__ (and corresponding #else)     
....................     #else //must be PIC18 device 
00F30:  MOV     [--W15],W6
00F32:  MOV     [--W15],W5
00F34:  RETURN  
....................         //Make sure the SPI module doesn't control the bus, will use  
....................         //bit-banged SPI instead, for slow mode initialization operation 
....................         SPICON1 = 0x00; 
....................         SPICLOCKLAT = 0; 
....................         SPIOUTLAT = 1; 
....................         SPICLOCK = OUTPUT; 
....................         SPIOUT = OUTPUT; 
....................     #endif //#if defined __C30__ || defined __C32__ 
.................... }     
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     MEDIA_INFORMATION *  MDD_SDSPI_MediaInitialize (void) 
....................   Summary: 
....................     Initializes the SD card. 
....................   Conditions: 
....................     The MDD_MediaInitialize function pointer must be pointing to this function. 
....................   Input: 
....................     None. 
....................   Return Values: 
....................     The function returns a pointer to the MEDIA_INFORMATION structure.  The 
....................     errorCode member may contain the following values: 
....................         * MEDIA_NO_ERROR - The media initialized successfully 
....................         * MEDIA_CANNOT_INITIALIZE - Cannot initialize the media.   
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     This function will send initialization commands to and SD card. 
....................   Remarks: 
....................     Psuedo code flow for the media initialization process is as follows: 
....................  
.................... ------------------------------------------------------------------------------------------- 
.................... SD Card SPI Initialization Sequence (for physical layer v1.x or v2.0 device) is as follows: 
.................... ------------------------------------------------------------------------------------------- 
.................... 0.  Power up tasks 
....................     a.  Initialize microcontroller SPI module to no more than 400kbps rate so as to support MMC devices. 
....................     b.  Add delay for SD card power up, prior to sending it any commands.  It wants the  
....................         longer of: 1ms, the Vdd ramp time (time from 2.7V to Vdd stable), and 74+ clock pulses. 
.................... 1.  Send CMD0 (GO_IDLE_STATE) with CS = 0.  This puts the media in SPI mode and software resets the SD/MMC card. 
.................... 2.  Send CMD8 (SEND_IF_COND).  This requests what voltage the card wants to run at.  
....................     Note: Some cards will not support this command. 
....................     a.  If illegal command response is received, this implies either a v1.x physical spec device, or not an SD card (ex: MMC). 
....................     b.  If normal response is received, then it must be a v2.0 or later SD memory card. 
....................  
.................... If v1.x device: 
.................... ----------------- 
.................... 3.  Send CMD1 repeatedly, until initialization complete (indicated by R1 response byte/idle bit == 0) 
.................... 4.  Basic initialization is complete.  May now switch to higher SPI frequencies. 
.................... 5.  Send CMD9 to read the CSD structure.  This will tell us the total flash size and other info which will be useful later. 
.................... 6.  Parse CSD structure bits (based on v1.x structure format) and extract useful information about the media. 
.................... 7.  The card is now ready to perform application data transfers. 
....................  
.................... If v2.0+ device: 
.................... ----------------- 
.................... 3.  Verify the voltage range is feasible.  If not, unusable card, should notify user that the card is incompatible with this host. 
.................... 4.  Send CMD58 (Read OCR). 
.................... 5.  Send CMD55, then ACMD41 (SD_SEND_OP_COND, with HCS = 1). 
....................     a.  Loop CMD55/ACMD41 until R1 response byte == 0x00 (indicating the card is no longer busy/no longer in idle state).   
.................... 6.  Send CMD58 (Get CCS). 
....................     a.  If CCS = 1 --> SDHC card. 
....................     b.  If CCS = 0 --> Standard capacity SD card (which is v2.0+). 
.................... 7.  Basic initialization is complete.  May now switch to higher SPI frequencies. 
.................... 8.  Send CMD9 to read the CSD structure.  This will tell us the total flash size and other info which will be useful later. 
.................... 9.  Parse CSD structure bits (based on v2.0 structure format) and extract useful information about the media. 
.................... 10. The card is now ready to perform application data transfers. 
.................... -------------------------------------------------------------------------------- 
.................... ********************************************************************************/ 
....................  
.................... MEDIA_INFORMATION *  MDD_SDSPI_MediaInitialize(void) 
*
010FE:  MOV     W5,[W15++]
01100:  MOV     W6,[W15++]
01102:  MOV     W7,[W15++]
.................... { 
....................     WORD timeout; 
01104:  CLR     FDA
....................     MMC_RESPONSE response; 
01106:  CLR     FDC
01108:  CLR     FDE
0110A:  CLR     FE0
....................    BYTE CSDResponse[20]; 
0110C:  CLR     FE2
0110E:  CLR     FE4
01110:  CLR     FE6
01112:  CLR     FE8
01114:  CLR     FEA
01116:  CLR     FEC
01118:  CLR     FEE
0111A:  CLR     FF0
0111C:  CLR     FF2
0111E:  CLR     FF4
....................    BYTE count, index; 
01120:  CLR.B   FF6
01122:  CLR.B   FF7
....................    DWORD c_size; 
01124:  CLR     FF8
01126:  CLR     FFA
....................    BYTE c_size_mult; 
01128:  CLR.B   FFC
....................    BYTE block_len; 
0112A:  CLR.B   FFD
....................     
....................    #ifdef __DEBUG_UART 
....................    InitUART(); 
....................    #endif 
....................   
....................     //Initialize global variables.  Will get updated later with valid data once 
....................     //the data is known. 
....................     mediaInformation.errorCode = MEDIA_NO_ERROR; 
0112C:  CLR.B   DA8
....................     mediaInformation.validityFlags.value = 0; 
0112E:  CLR.B   DA9
....................     MDD_SDSPI_finalLBA = 0x00000000;   //Will compute a valid size later, from the CSD register values we get from the card 
01130:  CLR     DA0
01132:  CLR     DA2
....................     gSDMode = SD_MODE_NORMAL;           //Will get updated later with real value, once we know based on initialization flow. 
01134:  CLR.B   DA6
....................  
....................     SD_CS = 1;               //Initialize Chip Select line (1 = card not selected) 
01136:  BSET.B  2F5.0
....................  
....................     //MMC media powers up in the open-drain mode and cannot handle a clock faster 
....................     //than 400kHz. Initialize SPI port to <= 400kHz 
....................     InitSPISlowMode();     
01138:  CALL    ED0
....................      
....................     #ifdef __DEBUG_UART   
....................     PrintROMASCIIStringUART("\r\n\r\nInitializing Media\r\n");  
....................     #endif 
....................  
....................     //Media wants the longer of: Vdd ramp time, 1 ms fixed delay, or 74+ clock pulses. 
....................     //According to spec, CS should be high during the 74+ clock pulses. 
....................     //In practice it is preferrable to wait much longer than 1ms, in case of 
....................     //contact bounce, or incomplete mechanical insertion (by the time we start 
....................     //accessing the media).  
....................     Delayms(30); 
0113C:  MOV.B   #1E,W0L
0113E:  MOV.B   W0L,FFE
01140:  CALL    109C
....................     SD_CS = 1; 
01144:  BSET.B  2F5.0
....................     //Generate 80 clock pulses. 
....................     for(timeout=0; timeout<10u; timeout++) 
01146:  CLR     FDA
01148:  MOV     FDA,W4
0114A:  CP      W4,#A
0114C:  BRA     C,115A
....................         WriteSPISlow(0xFF); 
0114E:  SETM.B  113C
01150:  CALL    F36
01154:  INC     0FDA
01156:  GOTO    1148
....................  
....................  
....................     // Send CMD0 (with CS = 0) to reset the media and put SD cards into SPI mode. 
....................     timeout = 100; 
0115A:  MOV     #64,W4
0115C:  MOV     W4,FDA
....................     do 
....................     { 
....................         //Toggle chip select, to make media abandon whatever it may have been doing 
....................         //before.  This ensures the CMD0 is sent freshly after CS is asserted low, 
....................         //minimizing risk of SPI clock pulse master/slave syncronization problems,  
....................         //due to possible application noise on the SCK line. 
....................         SD_CS = 1; 
0115E:  BSET.B  2F5.0
....................         WriteSPISlow(0xFF);   //Send some "extraneous" clock pulses.  If a previous 
01160:  SETM.B  113C
01162:  CALL    F36
....................                               //command was terminated before it completed normally, 
....................                               //the card might not have received the required clocking 
....................                               //following the transfer. 
....................         SD_CS = 0; 
01166:  BCLR.B  2F5.0
....................         timeout--; 
01168:  DEC     0FDA
....................  
....................         //Send CMD0 to software reset the device 
....................         response = SendMediaSlowCmd(GO_IDLE_STATE, 0x0); 
0116A:  CLR.B   111C
0116C:  CLR     111E
0116E:  CLR     1120
01170:  CALL    F58
01174:  MOV     W0,FDC
01176:  MOV     W1,FDE
01178:  MOV     W2,FE0
....................     }while((response.r1._byte != 0x01) && (timeout != 0)); 
0117A:  MOV     FDC,W4
0117C:  CP.B    W4L,#1
0117E:  BRA     Z,1184
01180:  CP0     FDA
01182:  BRA     NZ,115E
....................     //Check if all attempts failed and we timed out.  Normally, this won't happen, 
....................     //unless maybe the SD card was busy, because it was previously performing a 
....................     //read or write operation, when it was interrupted by the microcontroller getting 
....................     //reset or power cycled, without also resetting or power cycling the SD card. 
....................     //In this case, the SD card may still be busy (ex: trying to respond with the  
....................     //read request data), and may not be ready to process CMD0.  In this case, 
....................     //we can try to recover by issuing CMD12 (STOP_TRANSMISSION). 
....................     if(timeout == 0) 
01184:  CP0     FDA
01186:  BRA     NZ,11CC
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("Media failed CMD0 too many times. R1 response byte = "); 
....................         PrintRAMBytesUART(((unsigned char*)&response + 1), 1); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         PrintROMASCIIStringUART("Trying CMD12 to recover.\r\n"); 
....................         #endif 
....................  
....................         SD_CS = 1; 
01188:  BSET.B  2F5.0
....................         WriteSPISlow(0xFF);       //Send some "extraneous" clock pulses.  If a previous 
0118A:  SETM.B  113C
0118C:  CALL    F36
....................                                   //command was terminated before it completed normally, 
....................                                   //the card might not have received the required clocking 
....................                                   //following the transfer. 
....................         SD_CS = 0; 
01190:  BCLR.B  2F5.0
....................  
....................         //Send CMD12, to stop any read/write transaction that may have been in progress 
....................         response = SendMediaSlowCmd(STOP_TRANSMISSION, 0x0);    //Blocks until SD card signals non-busy 
01192:  MOV.B   #5,W0L
01194:  MOV.B   W0L,111C
01196:  CLR     111E
01198:  CLR     1120
0119A:  CALL    F58
0119E:  MOV     W0,FDC
011A0:  MOV     W1,FDE
011A2:  MOV     W2,FE0
....................         //Now retry to send send CMD0 to perform software reset on the media 
....................         response = SendMediaSlowCmd(GO_IDLE_STATE, 0x0);         
011A4:  CLR.B   111C
011A6:  CLR     111E
011A8:  CLR     1120
011AA:  CALL    F58
011AE:  MOV     W0,FDC
011B0:  MOV     W1,FDE
011B2:  MOV     W2,FE0
....................         if(response.r1._byte != 0x01) //Check if card in idle state now. 
011B4:  MOV     FDC,W4
011B6:  CP.B    W4L,#1
011B8:  BRA     Z,11C8
....................         { 
....................             //Card failed to process CMD0 yet again.  At this point, the proper thing 
....................             //to do would be to power cycle the card and retry, if the host  
....................             //circuitry supports disconnecting the SD card power.  Since the 
....................             //SD/MMC PICtail+ doesn't support software controlled power removal 
....................             //of the SD card, there is nothing that can be done with this hardware. 
....................             //Therefore, we just give up now.  The user needs to physically  
....................             //power cycle the media and/or the whole board. 
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("Media still failed CMD0. Cannot initialize card, returning.\r\n"); 
....................             #endif    
....................             mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE; 
011BA:  MOV.B   #2,W0L
011BC:  MOV.B   W0L,DA8
....................             return &mediaInformation; 
011BE:  MOV     #DA8,W4
011C0:  MOV     W4,0
011C2:  BRA     145A
....................         }             
011C4:  GOTO    11C8
....................         else 
....................         { 
....................             //Card successfully processed CMD0 and is now in the idle state. 
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("Media successfully processed CMD0 after CMD12.\r\n"); 
....................             #endif         
....................         }     
....................     }//if(timeout == 0) [for the CMD0 transmit loop] 
011C8:  GOTO    11CC
....................     else 
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("Media successfully processed CMD0.\r\n"); 
....................         #endif         
....................     }        
....................      
....................  
....................     //Send CMD8 (SEND_IF_COND) to specify/request the SD card interface condition (ex: indicate what voltage the host runs at). 
....................     //0x000001AA --> VHS = 0001b = 2.7V to 3.6V.  The 0xAA LSB is the check pattern, and is arbitrary, but 0xAA is recommended (good blend of 0's and '1's). 
....................     //The SD card has to echo back the check pattern correctly however, in the R7 response. 
....................     //If the SD card doesn't support the operating voltage range of the host, then it may not respond. 
....................     //If it does support the range, it will respond with a type R7 reponse packet (6 bytes/48 bits).            
....................     //Additionally, if the SD card is MMC or SD card v1.x spec device, then it may respond with 
....................     //invalid command.  If it is a v2.0 spec SD card, then it is mandatory that the card respond 
....................     //to CMD8. 
....................     response = SendMediaSlowCmd(SEND_IF_COND, 0x1AA);   //Note: If changing "0x1AA", CRC value in table must also change. 
011CC:  MOV.B   #2,W0L
011CE:  MOV.B   W0L,111C
011D0:  MOV     #1AA,W4
011D2:  MOV     W4,111E
011D4:  CLR     1120
011D6:  CALL    F58
011DA:  MOV     W0,FDC
011DC:  MOV     W1,FDE
011DE:  MOV     W2,FE0
....................     if(((response.r7.bytewise.argument._returnVal & 0xFFF) == 0x1AA) && (!response.r7.bitwise.bits.ILLEGAL_CMD)) 
011E0:  MOV     #FFF,W0
011E2:  AND     FDE,W0
011E4:  MOV     W0,W5
011E6:  CLR     W6
011E8:  MOV     #1AA,W4
011EA:  CP      W4,W5
011EC:  BRA     NZ,127C
011EE:  CP0     W6
011F0:  BRA     NZ,127C
011F2:  BTSC.B  FDC.2
011F4:  BRA     127C
....................       { 
....................         //If we get to here, the device supported the CMD8 command and didn't complain about our host 
....................         //voltage range. 
....................         //Most likely this means it is either a v2.0 spec standard or high capacity SD card (SDHC) 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("Media successfully processed CMD8. Response = "); 
....................         PrintRAMBytesUART(((unsigned char*)&response + 1), 4); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................  
....................       //Send CMD58 (Read OCR [operating conditions register]).  Reponse type is R3, which has 5 bytes. 
....................       //Byte 4 = normal R1 response byte, Bytes 3-0 are = OCR register value. 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("Sending CMD58.\r\n"); 
....................         #endif 
....................         response = SendMediaSlowCmd(READ_OCR, 0x0); 
011F6:  MOV.B   #10,W0L
011F8:  MOV.B   W0L,111C
011FA:  CLR     111E
011FC:  CLR     1120
011FE:  CALL    F58
01202:  MOV     W0,FDC
01204:  MOV     W1,FDE
01206:  MOV     W2,FE0
....................         //Now that we have the OCR register value in the reponse packet, we could parse 
....................         //the register contents and learn what voltage the SD card wants to run at. 
....................         //If our host circuitry has variable power supply capability, it could  
....................         //theoretically adjust the SD card Vdd to the minimum of the OCR to save power. 
....................        
....................       //Now send CMD55/ACMD41 in a loop, until the card is finished with its internal initialization. 
....................       //Note: SD card specs recommend >= 1 second timeout while waiting for ACMD41 to signal non-busy. 
....................       for(timeout = 0; timeout < 0xFFFF; timeout++) 
01208:  CLR     FDA
0120A:  MOV     FDA,W4
0120C:  MOV     #FFFF,W3
0120E:  CP      W3,W4
01210:  BRA     Z,1240
....................       {             
....................          //Send CMD55 (lets SD card know that the next command is application specific (going to be ACMD41)). 
....................          SendMediaSlowCmd(APP_CMD, 0x00000000); 
01212:  MOV.B   #F,W0L
01214:  MOV.B   W0L,111C
01216:  CLR     111E
01218:  CLR     1120
0121A:  CALL    F58
....................           
....................          //Send ACMD41.  This is to check if the SD card is finished booting up/ready for full frequency and all 
....................          //further commands.  Response is R3 type (6 bytes/48 bits, middle four bytes contain potentially useful data). 
....................             //Note: When sending ACMD41, the HCS bit is bit 30, and must be = 1 to tell SD card the host supports SDHC 
....................          response = SendMediaSlowCmd(SD_SEND_OP_COND,0x40000000); //bit 30 set 
0121E:  MOV.B   #12,W0L
01220:  MOV.B   W0L,111C
01222:  CLR     111E
01224:  MOV     #4000,W4
01226:  MOV     W4,1120
01228:  CALL    F58
0122C:  MOV     W0,FDC
0122E:  MOV     W1,FDE
01230:  MOV     W2,FE0
....................           
....................          //The R1 response should be = 0x00, meaning the card is now in the "standby" state, instead of 
....................          //the "idle" state (which is the default initialization state after CMD0 reset is issued).  Once 
....................          //in the "standby" state, the SD card is finished with basic intitialization and is ready  
....................          //for read/write and other commands. 
....................          if(response.r1._byte == 0) 
01232:  CP0.B   FDC
01234:  BRA     NZ,123A
....................          { 
....................               #ifdef __DEBUG_UART   
....................                 PrintROMASCIIStringUART("Media successfully processed CMD55/ACMD41 and is no longer busy.\r\n"); 
....................             #endif 
....................             break;  //Break out of for() loop.  Card is finished initializing. 
01236:  GOTO    1240
....................             }             
0123A:  INC     0FDA
0123C:  GOTO    120A
....................       }       
....................       if(timeout >= 0xFFFF) 
01240:  MOV     FDA,W4
01242:  MOV     #FFFF,W3
01244:  CP      W3,W4
01246:  BRA     NZ,124C
....................       { 
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("Media Timeout on CMD55/ACMD41.\r\n"); 
....................             #endif 
....................           mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE; 
01248:  MOV.B   #2,W0L
0124A:  MOV.B   W0L,DA8
....................         }             
....................        
....................        
....................         //Now send CMD58 (Read OCR register).  The OCR register contains important 
....................         //info we will want to know about the card (ex: standard capacity vs. SDHC). 
....................         response = SendMediaSlowCmd(READ_OCR, 0x0);  
0124C:  MOV.B   #10,W0L
0124E:  MOV.B   W0L,111C
01250:  CLR     111E
01252:  CLR     1120
01254:  CALL    F58
01258:  MOV     W0,FDC
0125A:  MOV     W1,FDE
0125C:  MOV     W2,FE0
....................  
....................       //Now check the CCS bit (OCR bit 30) in the OCR register, which is in our response packet. 
....................       //This will tell us if it is a SD high capacity (SDHC) or standard capacity device. 
....................       if(response.r7.bytewise.argument._returnVal & 0x40000000)    //Note the HCS bit is only valid when the busy bit is also set (indicating device ready). 
0125E:  MOV     #4000,W0
01260:  AND     FE0,W0
01262:  MOV     W0,W1
01264:  CLR     W0
01266:  CP0     W0
01268:  BRA     NZ,126E
0126A:  CP0     W1
0126C:  BRA     Z,1276
....................       { 
....................          gSDMode = SD_MODE_HC; 
0126E:  MOV.B   #1,W0L
01270:  MOV.B   W0L,DA6
....................           
....................           #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("Media successfully processed CMD58: SD card is SDHC v2.0 (or later) physical spec type.\r\n"); 
....................             #endif 
....................         }             
01272:  GOTO    1278
....................         else 
....................         { 
....................             gSDMode = SD_MODE_NORMAL; 
01276:  CLR.B   DA6
....................  
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("Media successfully processed CMD58: SD card is standard capacity v2.0 (or later) spec.\r\n"); 
....................             #endif 
....................         }  
....................         //SD Card should now be finished with initialization sequence.  Device should be ready 
....................         //for read/write commands. 
....................  
....................    }//if(((response.r7.bytewise._returnVal & 0xFFF) == 0x1AA) && (!response.r7.bitwise.bits.ILLEGAL_CMD)) 
01278:  GOTO    12B8
....................     else 
....................    { 
....................         //The CMD8 wasn't supported.  This means the card is not a v2.0 card. 
....................         //Presumably the card is v1.x device, standard capacity (not SDHC). 
....................  
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("CMD8 Unsupported: Media is most likely MMC or SD 1.x device.\r\n"); 
....................         #endif 
....................  
....................  
....................         SD_CS = 1;                              // deselect the devices 
0127C:  BSET.B  2F5.0
....................         Delayms(1); 
0127E:  MOV.B   #1,W0L
01280:  MOV.B   W0L,FFE
01282:  CALL    109C
....................         SD_CS = 0;                              // select the device 
01286:  BCLR.B  2F5.0
....................  
....................         //The CMD8 wasn't supported.  This means the card is definitely not a v2.0 SDHC card. 
....................         gSDMode = SD_MODE_NORMAL; 
01288:  CLR.B   DA6
....................        // According to the spec CMD1 must be repeated until the card is fully initialized 
....................        timeout = 0x1FFF; 
0128A:  MOV     #1FFF,W4
0128C:  MOV     W4,FDA
....................         do 
....................         { 
....................             //Send CMD1 to initialize the media. 
....................             response = SendMediaSlowCmd(SEND_OP_COND, 0x00000000);    //When argument is 0x00000000, this queries MMC cards for operating voltage range 
0128E:  MOV.B   #1,W0L
01290:  MOV.B   W0L,111C
01292:  CLR     111E
01294:  CLR     1120
01296:  CALL    F58
0129A:  MOV     W0,FDC
0129C:  MOV     W1,FDE
0129E:  MOV     W2,FE0
....................             timeout--; 
012A0:  DEC     0FDA
....................         }while((response.r1._byte != 0x00) && (timeout != 0)); 
012A2:  CP0.B   FDC
012A4:  BRA     Z,12AA
012A6:  CP0     FDA
012A8:  BRA     NZ,128E
....................         // see if it failed 
....................         if(timeout == 0) 
012AA:  CP0     FDA
012AC:  BRA     NZ,12B8
....................         { 
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("CMD1 failed.\r\n"); 
....................             #endif 
....................  
....................             mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE; 
012AE:  MOV.B   #2,W0L
012B0:  MOV.B   W0L,DA8
....................             SD_CS = 1;                              // deselect the devices 
012B2:  BSET.B  2F5.0
....................         } 
012B4:  GOTO    12B8
....................         else 
....................         { 
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("CMD1 Successfully processed, media is no longer busy.\r\n"); 
....................             #endif 
....................              
....................             //Set read/write block length to 512 bytes.  Note: commented out since 
....................             //this theoretically isn't necessary, since all cards v1 and v2 are  
....................             //required to support 512 byte block size, and this is supposed to be 
....................             //the default size selected on cards that support other sizes as well. 
....................             //response = SendMediaSlowCmd(SET_BLOCKLEN, 0x00000200);    //Set read/write block length to 512 bytes 
....................         } 
....................         
....................    } 
....................  
....................  
....................     //Temporarily deselect device 
....................     SD_CS = 1; 
012B8:  BSET.B  2F5.0
....................      
....................     //Basic initialization of media is now complete.  The card will now use push/pull 
....................     //outputs with fast drivers.  Therefore, we can now increase SPI speed to  
....................     //either the maximum of the microcontroller or maximum of media, whichever  
....................     //is slower.  MMC media is typically good for at least 20Mbps SPI speeds.   
....................     //SD cards would typically operate at up to 25Mbps or higher SPI speeds. 
....................     OpenSPIM(SYNC_MODE_FAST); 
012BA:  MOV     #3E,W4
012BC:  MOV     W4,1006
012BE:  CALL    EBA
....................  
....................    SD_CS = 0; 
012C2:  BCLR.B  2F5.0
....................  
....................    /* Send the CMD9 to read the CSD register */ 
....................     timeout = NCR_TIMEOUT; 
012C4:  MOV     #14,W4
012C6:  MOV     W4,FDA
....................     do 
....................     { 
....................         //Send CMD9: Read CSD data structure. 
....................       response = SendMMCCmd(SEND_CSD, 0x00); 
012C8:  MOV.B   #3,W0L
012CA:  MOV.B   W0L,111C
012CC:  CLR     111E
012CE:  CLR     1120
012D0:  CALL    F58
012D4:  MOV     W0,FDC
012D6:  MOV     W1,FDE
012D8:  MOV     W2,FE0
....................         timeout--; 
012DA:  DEC     0FDA
....................     }while((response.r1._byte != 0x00) && (timeout != 0)); 
012DC:  CP0.B   FDC
012DE:  BRA     Z,12E4
012E0:  CP0     FDA
012E2:  BRA     NZ,12C8
....................     if(timeout != 0x00) 
012E4:  CP0     FDA
012E6:  BRA     Z,12EC
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("CMD9 Successfully processed: Read CSD register.\r\n"); 
....................         PrintROMASCIIStringUART("CMD9 response R1 byte = "); 
....................         PrintRAMBytesUART((unsigned char*)&response, 1);  
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................     }     
012E8:  GOTO    12F8
....................     else 
....................     { 
....................         //Media failed to respond to the read CSD register operation. 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("Timeout occurred while processing CMD9 to read CSD register.\r\n"); 
....................         #endif 
....................          
....................         mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE; 
012EC:  MOV.B   #2,W0L
012EE:  MOV.B   W0L,DA8
....................         SD_CS = 1; 
012F0:  BSET.B  2F5.0
....................         return &mediaInformation; 
012F2:  MOV     #DA8,W4
012F4:  MOV     W4,0
012F6:  BRA     145A
....................     }     
....................  
....................    /* According to the simplified spec, section 7.2.6, the card will respond 
....................    with a standard response token, followed by a data block of 16 bytes 
....................    suffixed with a 16-bit CRC.*/ 
....................    index = 0; 
012F8:  CLR.B   FF7
....................    for (count = 0; count < 20u; count ++) 
012FA:  CLR.B   FF6
012FC:  MOV     FF6,W4
012FE:  CP.B    W4L,#14
01300:  BRA     C,1324
....................    { 
....................       CSDResponse[index] = MDD_SDSPI_ReadMedia(); 
01302:  MOV     FF6,W4
01304:  LSR     W4,#8,W4
01306:  MOV     #FE2,W3
01308:  ADD     W4,W3,W5
0130A:  CALL    F4A
0130E:  MOV.B   W0L,[W5]
....................       index++;          
01310:  INC.B   0FF7
....................       /* Hopefully the first byte is the datatoken, however, some cards do 
....................       not send the response token before the CSD register.*/ 
....................       if((count == 0) && (CSDResponse[0] == DATA_START_TOKEN)) 
01312:  CP0.B   FF6
01314:  BRA     NZ,131E
01316:  MOV     FE2,W4
01318:  XOR.B   #FE,W4L
0131A:  BRA     NZ,131E
....................       { 
....................          /* As the first byte was the datatoken, we can drop it. */ 
....................          index = 0; 
0131C:  CLR.B   FF7
....................       } 
0131E:  INC.B   0FF6
01320:  GOTO    12FC
....................    } 
....................  
....................     #ifdef __DEBUG_UART   
....................     PrintROMASCIIStringUART("CSD data structure contains: "); 
....................     PrintRAMBytesUART((unsigned char*)&CSDResponse, 20);  
....................     UARTSendLineFeedCarriageReturn(); 
....................     #endif 
....................      
....................  
....................  
....................    //Extract some fields from the response for computing the card capacity. 
....................    //Note: The structure format depends on if it is a CSD V1 or V2 device. 
....................    //Therefore, need to first determine version of the specs that the card  
....................    //is designed for, before interpreting the individual fields. 
....................  
....................    //------------------------------------------------------------- 
....................    //READ_BL_LEN: CSD Structure v1 cards always support 512 byte 
....................    //read and write block lengths.  Some v1 cards may optionally report 
....................    //READ_BL_LEN = 1024 or 2048 bytes (and therefore WRITE_BL_LEN also  
....................    //1024 or 2048).  However, even on these cards, 512 byte partial reads 
....................    //and 512 byte write are required to be supported. 
....................    //On CSD structure v2 cards, it is always required that READ_BL_LEN  
....................    //(and therefore WRITE_BL_LEN) be 512 bytes, and partial reads and 
....................    //writes are not allowed. 
....................    //Therefore, all cards support 512 byte reads/writes, but only a subset 
....................    //of cards support other sizes.  For best compatibility with all cards, 
....................    //and the simplest firmware design, it is therefore preferrable to  
....................    //simply ignore the READ_BL_LEN and WRITE_BL_LEN values altogether, 
....................    //and simply hardcode the read/write block size as 512 bytes. 
....................    //------------------------------------------------------------- 
....................    gMediaSectorSize = 512u; 
01324:  MOV     #200,W4
01326:  MOV     W4,DA4
....................    //mediaInformation.sectorSize = gMediaSectorSize; 
....................    mediaInformation.sectorSize = 512u; 
01328:  MOV     #200,W4
0132A:  MOV     W4,DAA
....................    mediaInformation.validityFlags.bits.sectorSize = TRUE; 
0132C:  BSET.B  DA9.0
....................    //------------------------------------------------------------- 
....................  
....................    //Calculate the MDD_SDSPI_finalLBA (see SD card physical layer simplified spec 2.0, section 5.3.2). 
....................    //In USB mass storage applications, we will need this information to  
....................    //correctly respond to SCSI get capacity requests.  Note: method of computing  
....................    //MDD_SDSPI_finalLBA depends on CSD structure spec version (either v1 or v2). 
....................    if(CSDResponse[0] & 0xC0)   //Check CSD_STRUCTURE field for v2+ struct device 
0132E:  MOV.B   FE2,W0L
01330:  AND     #C0,W0
01332:  CP0     W0
01334:  BRA     Z,1388
....................    { 
....................       //Must be a v2 device (or a reserved higher version, that doesn't currently exist) 
....................  
....................       //Extract the C_SIZE field from the response.  It is a 22-bit number in bit position 69:48.  This is different from v1.   
....................       //It spans bytes 7, 8, and 9 of the response. 
....................       c_size = (((DWORD)CSDResponse[7] & 0x3F) << 16) | ((WORD)CSDResponse[8] << 8) | CSDResponse[9]; 
01336:  MOV.B   FE9,W0L
01338:  MOV.B   W0L,W5L
0133A:  CLR.B   B
0133C:  MOV     #0,W6
0133E:  AND     #3F,W5
01340:  CLR     W6
01342:  MOV     W5,W6
01344:  MOV     #0,W5
01346:  MOV.B   FEA,W0L
01348:  MOV.B   W0L,E
0134A:  CLR.B   F
0134C:  MOV.B   W7L,W0L
0134E:  MOV.B   W0L,1
01350:  CLR.B   W0
01352:  IOR      W5,  W0,W5
01354:  MOV.B   FEB,W0L
01356:  CLR.B   1
01358:  MOV.B   W0L,FF8
0135A:  CLR.B   FF9
0135C:  MOV     W5,W0
0135E:  IOR     FF8
01360:  MOV     W6,FFA
....................        
....................       MDD_SDSPI_finalLBA = ((DWORD)(c_size + 1) * (WORD)(1024u)) - 1; //-1 on end is correction factor, since LBA = 0 is valid. 
01362:  MOV     FF8,W4
01364:  ADD     W4,#1,W4
01366:  MOV     W4,W5
01368:  MOV     FFA,W4
0136A:  ADDC    W4,#0,W4
0136C:  MOV     W4,W6
0136E:  MOV     #A,W4
01370:  INC     W4,W4
01372:  DEC     W4,W4
01374:  BRA     Z,137C
01376:  SL      W5,W5
01378:  RLC     W6,W6
0137A:  BRA     1372
0137C:  SUB     W5,#1,W0
0137E:  MOV     W0,DA0
01380:  SUBB    W6,#0,W0
01382:  MOV     W0,DA2
....................    } 
01384:  GOTO    143A
....................    else //if(CSDResponse[0] & 0xC0)   //Check CSD_STRUCTURE field for v1 struct device 
....................    { 
....................       //Must be a v1 device. 
....................       //Extract the C_SIZE field from the response.  It is a 12-bit number in bit position 73:62.   
....................       //Although it is only a 12-bit number, it spans bytes 6, 7, and 8, since it isn't byte aligned. 
....................       c_size = ((DWORD)CSDResponse[6] << 16) | ((WORD)CSDResponse[7] << 8) | CSDResponse[8];   //Get the bytes in the correct positions 
01388:  MOV.B   FE8,W0L
0138A:  MOV.B   W0L,A
0138C:  CLR.B   B
0138E:  MOV     #0,W6
01390:  MOV     W5,W6
01392:  MOV     #0,W5
01394:  MOV.B   FE9,W0L
01396:  MOV.B   W0L,W7L
01398:  CLR.B   F
0139A:  MOV.B   W7L,W0L
0139C:  MOV.B   W0L,1
0139E:  CLR.B   W0
013A0:  IOR      W5,  W0,W5
013A2:  MOV.B   FEA,W0L
013A4:  MOV.B   W0L,FF8
013A6:  CLR.B   FF9
013A8:  MOV     W5,W0
013AA:  IOR     FF8
013AC:  MOV     W6,FFA
....................       c_size &= 0x0003FFC0;   //Clear all bits that aren't part of the C_SIZE 
013AE:  MOV     #FFC0,W0
013B0:  AND     FF8
013B2:  MOV     FFA,W0
013B4:  AND     W0,#3,W0
013B6:  MOV     W0,FFA
....................       c_size = c_size >> 6;   //Shift value down, so the 12-bit C_SIZE is properly right justified in the DWORD. 
013B8:  MOV     #6,W4
013BA:  INC     W4,W4
013BC:  DEC     W4,W4
013BE:  BRA     Z,13C6
013C0:  LSR     FFA
013C2:  RRC     FF8
013C4:  BRA     13BC
....................        
....................       //Extract the C_SIZE_MULT field from the response.  It is a 3-bit number in bit position 49:47. 
....................       c_size_mult = ((WORD)((CSDResponse[9] & 0x03) << 1)) | ((WORD)((CSDResponse[10] & 0x80) >> 7)); 
013C6:  MOV.B   FEB,W0L
013C8:  CLR.B   1
013CA:  AND     W0,#3,W5
013CC:  SL      W5,#1,W5
013CE:  MOV     FEC,W6
013D0:  AND     #80,W6
013D2:  LSR     W6,#7,W0
013D4:  MOV.B   W0L,FFC
013D6:  MOV     W5,W0
013D8:  IOR.B   FFC
....................  
....................         //Extract the BLOCK_LEN field from the response. It is a 4-bit number in bit position 83:80. 
....................         block_len = CSDResponse[5] & 0x0F; 
013DA:  MOV.B   FE7,W0L
013DC:  AND.B   W0L,#F,W0L
013DE:  MOV.B   W0L,FFD
....................  
....................         block_len = 1 << (block_len - 9); //-9 because we report the size in sectors of 512 bytes each 
013E0:  MOV     FFC,W4
013E2:  LSR     W4,#8,W4
013E4:  SUB     W4,#9,W0
013E6:  MOV     W0,W4
013E8:  MOV     #1,W0
013EA:  SL      W0,W4,W0
013EC:  MOV.B   W0L,FFD
013EE:  MOV.B   W0L,FFD
....................        
....................       //Calculate the MDD_SDSPI_finalLBA (see SD card physical layer simplified spec 2.0, section 5.3.2). 
....................       //In USB mass storage applications, we will need this information to  
....................       //correctly respond to SCSI get capacity requests (which will cause MDD_SDSPI_ReadCapacity() to get called). 
....................       MDD_SDSPI_finalLBA = ((DWORD)(c_size + 1) * (WORD)((WORD)1 << (c_size_mult + 2)) * block_len) - 1;   //-1 on end is correction factor, since LBA = 0 is valid.       
013F0:  MOV     FF8,W4
013F2:  ADD     W4,#1,W4
013F4:  MOV     W4,W5
013F6:  MOV     FFA,W4
013F8:  ADDC    W4,#0,W4
013FA:  MOV     W4,W6
013FC:  MOV     FFC,W4
013FE:  CLR.B   9
01400:  ADD     W4,#2,W4
01402:  MOV     W4,W0
01404:  MOV     W0,W4
01406:  MOV     #1,W0
01408:  SL      W0,W4,W0
0140A:  MOV     W6,W1
0140C:  MOV     W0,W2
0140E:  MOV     #0,W3
01410:  MOV     W5,W0
01412:  CALL    10CE
01416:  MOV     W0,W5
01418:  MOV     W1,W6
0141A:  MOV     W0,[W15++]
0141C:  MOV.B   FFD,W0L
0141E:  MOV.B   W0L,W2L
01420:  MOV     [--W15],W0
01422:  CLR.B   5
01424:  MOV     #0,W3
01426:  MOV     W5,W0
01428:  MOV     W6,W1
0142A:  CALL    10CE
0142E:  MOV     W0,W5
01430:  MOV     W1,W6
01432:  SUB     W5,#1,W0
01434:  MOV     W0,DA0
01436:  SUBB    W6,#0,W0
01438:  MOV     W0,DA2
....................    }    
....................  
....................     //Turn off CRC7 if we can, might be an invalid cmd on some cards (CMD59) 
....................     //Note: POR default for the media is normally with CRC checking off in SPI  
....................     //mode anyway, so this is typically redundant. 
....................     SendMMCCmd(CRC_ON_OFF,0x0); 
0143A:  MOV.B   #11,W0L
0143C:  MOV.B   W0L,111C
0143E:  CLR     111E
01440:  CLR     1120
01442:  CALL    F58
....................  
....................     //Now set the block length to media sector size. It should be already set to this. 
....................     SendMMCCmd(SET_BLOCKLEN,gMediaSectorSize); 
01446:  MOV.B   #7,W0L
01448:  MOV.B   W0L,111C
0144A:  PUSH    DA4
0144C:  POP     111E
0144E:  CLR     1120
01450:  CALL    F58
....................  
....................     //Deselect media while not actively accessing the card. 
....................     SD_CS = 1; 
01454:  BSET.B  2F5.0
....................  
....................     #ifdef __DEBUG_UART   
....................     PrintROMASCIIStringUART("Returning from MediaInitialize() function.\r\n"); 
....................     #endif 
....................  
....................  
....................     return &mediaInformation; 
01456:  MOV     #DA8,W4
01458:  MOV     W4,0
0145A:  MOV     [--W15],W7
0145C:  MOV     [--W15],W6
0145E:  MOV     [--W15],W5
01460:  RETURN  
.................... }//end MediaInitialize 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... ////////////////////// 
.................... ///                /// 
.................... /// Useful Defines /// 
.................... ///                /// 
.................... ////////////////////// 
....................  
.................... #define COMMAND_SIZE 10 
.................... #define NUM_COMMANDS 13 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
....................  
....................  
.................... char commands[NUM_COMMANDS][COMMAND_SIZE]= 
.................... { 
....................    "del",      //option1=filename.  delete file. 
....................    "make",     //option1=filename.  create an empty file, give error if file already exists 
....................    "append",   //option1=filename, option2=string.  append string to end of file 
....................    "cd",    //option1=new cwd.  change working directory.  / is root. 
....................    "dir",    //show files in directory 
....................    "cat",    //option1=filename.  display full contents in ascii 
....................    "tail",  //option1=filename.  display the last 20 lines of file. 
....................    "mkdir", //option1=dir.  create directory.  see 'cd' for rules on dir 
....................    "rmdir",  //option1=dir.  remove directory.  see 'cd' for rules on dir. 
....................    "format",   // option1=media size in bytes. formats the media. 
....................    "help",   // help! 
....................    "mount",  //mount filesystem. 
....................    "info"    //get and display FS_DISK_PROPERTIES 
.................... }; 
....................  
.................... int1 g_IsMounted = FALSE; 
....................  
.................... //////////////////////////////// 
.................... ///                          /// 
.................... /// Function Implementations /// 
.................... ///                          /// 
.................... //////////////////////////////// 
....................  
.................... /* 
.................... Summary: Finds a command from the global list of commands. 
.................... Param: A pointer to the command string. 
.................... Returns: The command number if the command is found in the command list. 
....................          0xFF if the command isn't found 
.................... */ 
.................... int FindCommand(char *cmd) 
*
05C80:  MOV     W5,[W15++]
05C82:  MOV     W6,[W15++]
.................... { 
....................    char buf[COMMAND_SIZE]; 
05C84:  CLR     FCE
05C86:  CLR     FD0
05C88:  CLR     FD2
05C8A:  CLR     FD4
05C8C:  CLR     FD6
....................    int i; 
05C8E:  CLR     FD8
....................  
....................    for (i=0; i<NUM_COMMANDS; i++) 
05C90:  CLR     FD8
05C92:  MOV     FD8,W4
05C94:  CP      W4,#D
05C96:  BRA     GE,5CCC
....................    { 
....................       strcpy(buf, &commands[i][0]); 
05C98:  MOV     FD8,W4
05C9A:  MUL.UU  W4,#A,W0
05C9C:  MOV     W0,W5
05C9E:  MOV     #E26,W4
05CA0:  ADD     W5,W4,W6
05CA2:  MOV     #FCE,W1
05CA4:  MOV     W6,W2
05CA6:  MOV.B   [W2++],[W1]
05CA8:  CP0.B   [W1++]
05CAA:  BTSS.B  42.1
05CAC:  BRA     5CA6
....................       if (stricmp(buf, cmd)==0) 
05CAE:  MOV     #FCE,W4
05CB0:  MOV     W4,FDC
05CB2:  PUSH    FCC
05CB4:  POP     FDE
05CB6:  CALL    5BDA
05CBA:  SE      W0,W5
05CBC:  CP0     W5
05CBE:  BRA     NZ,5CC6
....................          return(i); 
05CC0:  PUSH    FD8
05CC2:  POP     0
05CC4:  BRA     5CD0
05CC6:  INC     0FD8
05CC8:  GOTO    5C92
....................    } 
....................  
....................    return(0xFF); 
05CCC:  MOV     #FF,W4
05CCE:  MOV     W4,0
05CD0:  MOV     [--W15],W6
05CD2:  MOV     [--W15],W5
05CD4:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Displays the current working directory. 
.................... Param: None. 
.................... Returns: None. 
.................... */ 
.................... void DisplayPrompt(void) 
.................... { 
....................    char scr[65], *p; 
*
059A4:  CLR     FCC
059A6:  CLR     FCE
059A8:  CLR     FD0
059AA:  CLR     FD2
059AC:  CLR     FD4
059AE:  CLR     FD6
059B0:  CLR     FD8
059B2:  CLR     FDA
059B4:  CLR     FDC
059B6:  CLR     FDE
059B8:  CLR     FE0
059BA:  CLR     FE2
059BC:  CLR     FE4
059BE:  CLR     FE6
059C0:  CLR     FE8
059C2:  CLR     FEA
059C4:  CLR     FEC
059C6:  CLR     FEE
059C8:  CLR     FF0
059CA:  CLR     FF2
059CC:  CLR     FF4
059CE:  CLR     FF6
059D0:  CLR     FF8
059D2:  CLR     FFA
059D4:  CLR     FFC
059D6:  CLR     FFE
059D8:  CLR     1000
059DA:  CLR     1002
059DC:  CLR     1004
059DE:  CLR     1006
059E0:  CLR     1008
059E2:  CLR     100A
059E4:  CLR.B   100C
059E6:  CLR     100E
....................  
....................    if (g_IsMounted) 
059E8:  BTSS.B  85A.3
059EA:  BRA     5A24
....................    { 
....................       p = FSgetcwd(scr, sizeof(scr)-1); 
059EC:  MOV     #FCC,W4
059EE:  MOV     W4,1010
059F0:  MOV     #40,W4
059F2:  MOV     W4,1012
059F4:  CALL    55BA
059F8:  MOV     W0,100E
....................       if (!p) 
059FA:  CP0     100E
059FC:  BRA     NZ,5A20
....................       { 
....................          sprintf(scr, "!!!ERROR!!!"); 
059FE:  MOV     #FCC,W4
05A00:  MOV     W4,EA8
05A02:  MOV     #0,W1
05A04:  MOV     W1,W0
05A06:  CLR.B   1
05A08:  CALL    210
05A0C:  INC     W1,W1
05A0E:  MOV     W1,[W15++]
05A10:  MOV     W0,[W15++]
05A12:  MOV     [--W15],W0
05A14:  CALL    2592
05A18:  MOV     [--W15],W1
05A1A:  MOV     #A,W0
05A1C:  CPSGT   W1,W0
05A1E:  BRA     5A04
....................       } 
....................    } 
05A20:  GOTO    5A46
....................    else 
....................    { 
....................       sprintf(scr, "!!!NOT MOUNTED!!!"); 
05A24:  MOV     #FCC,W4
05A26:  MOV     W4,EA8
05A28:  MOV     #0,W1
05A2A:  MOV     W1,W0
05A2C:  CLR.B   1
05A2E:  CALL    228
05A32:  INC     W1,W1
05A34:  MOV     W1,[W15++]
05A36:  MOV     W0,[W15++]
05A38:  MOV     [--W15],W0
05A3A:  CALL    2592
05A3E:  MOV     [--W15],W1
05A40:  MOV     #10,W0
05A42:  CPSGT   W1,W0
05A44:  BRA     5A2A
....................    } 
....................  
....................    printf("\r\n\n%s> ", scr); 
05A46:  BTSC.B  223.1
05A48:  BRA     5A46
05A4A:  MOV     #D,W4
05A4C:  MOV     W4,224
05A4E:  BTSC.B  223.1
05A50:  BRA     5A4E
05A52:  MOV     #A,W4
05A54:  MOV     W4,224
05A56:  BTSC.B  223.1
05A58:  BRA     5A56
05A5A:  MOV     #A,W4
05A5C:  MOV     W4,224
05A5E:  MOV     #FCC,W1
05A60:  CP0.B   [W1]
05A62:  BRA     Z,5A72
05A64:  BTSC.B  223.1
05A66:  BRA     5A64
05A68:  MOV.B   [W1+#0],W0L
05A6A:  MOV.B   W0L,224
05A6C:  CLR.B   225
05A6E:  INC     W1,W1
05A70:  BRA     5A60
05A72:  BTSC.B  223.1
05A74:  BRA     5A72
05A76:  MOV     #3E,W4
05A78:  MOV     W4,224
05A7A:  BTSC.B  223.1
05A7C:  BRA     5A7A
05A7E:  MOV     #20,W4
05A80:  MOV     W4,224
05A82:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Deletes a file. 
.................... Param: The full path of the file to delete. 
.................... Returns: None. 
.................... */ 
.................... void DeleteFile(char *fileName) 
.................... { 
....................    if (!g_IsMounted) 
*
05DE0:  BTSC.B  85A.3
05DE2:  BRA     5DFE
....................    { 
....................       printf("\r\nMedia not mounted, not going to delete file!"); 
05DE4:  MOV     #0,W1
05DE6:  MOV     W1,W0
05DE8:  CLR.B   1
05DEA:  CALL    246
05DEE:  INC     W1,W1
05DF0:  BTSC.B  223.1
05DF2:  BRA     5DF0
05DF4:  MOV     W0,224
05DF6:  MOV     #2D,W0
05DF8:  CPSGT   W1,W0
05DFA:  BRA     5DE6
....................       return; 
05DFC:  BRA     5E78
....................    } 
....................  
....................    printf("\r\nDeleting '%s': ", fileName); 
05DFE:  MOV     #0,W1
05E00:  MOV     W1,W0
05E02:  CLR.B   1
05E04:  CALL    282
05E08:  INC     W1,W1
05E0A:  BTSC.B  223.1
05E0C:  BRA     5E0A
05E0E:  MOV     W0,224
05E10:  MOV     #B,W0
05E12:  CPSGT   W1,W0
05E14:  BRA     5E00
05E16:  MOV     FCC,W1
05E18:  CP0.B   [W1]
05E1A:  BRA     Z,5E2A
05E1C:  BTSC.B  223.1
05E1E:  BRA     5E1C
05E20:  MOV.B   [W1+#0],W0L
05E22:  MOV.B   W0L,224
05E24:  CLR.B   225
05E26:  INC     W1,W1
05E28:  BRA     5E18
05E2A:  BTSC.B  223.1
05E2C:  BRA     5E2A
05E2E:  MOV     #27,W4
05E30:  MOV     W4,224
05E32:  BTSC.B  223.1
05E34:  BRA     5E32
05E36:  MOV     #3A,W4
05E38:  MOV     W4,224
05E3A:  BTSC.B  223.1
05E3C:  BRA     5E3A
05E3E:  MOV     #20,W4
05E40:  MOV     W4,224
....................    if(FSremove(fileName)) 
05E42:  PUSH    FCC
05E44:  POP     FD0
05E46:  CALL    5CD6
05E4A:  CP0     W0
05E4C:  BRA     Z,5E68
....................    { 
....................       printf("Error deleting file"); 
05E4E:  MOV     #0,W1
05E50:  MOV     W1,W0
05E52:  CLR.B   1
05E54:  CALL    2A0
05E58:  INC     W1,W1
05E5A:  BTSC.B  223.1
05E5C:  BRA     5E5A
05E5E:  MOV     W0,224
05E60:  MOV     #12,W0
05E62:  CPSGT   W1,W0
05E64:  BRA     5E50
....................       return; 
05E66:  BRA     5E78
....................    } 
....................    printf("OK"); 
05E68:  BTSC.B  223.1
05E6A:  BRA     5E68
05E6C:  MOV     #4F,W4
05E6E:  MOV     W4,224
05E70:  BTSC.B  223.1
05E72:  BRA     5E70
05E74:  MOV     #4B,W4
05E76:  MOV     W4,224
05E78:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Creates a file. 
.................... Param: The full path of the file to create. 
.................... Returns: None. 
.................... Example Usage: \> make "Log.txt" 
.................... */ 
.................... void MakeFile(char *fileName) 
05E7A:  CLR     FCE
.................... { 
....................    FSFILE *f = NULL; 
....................    int ret; 
05E7C:  CLR     FD0
....................  
....................    if (!g_IsMounted) 
05E7E:  BTSC.B  85A.3
05E80:  BRA     5E9C
....................    { 
....................       printf("\r\nMedia not mounted, not going to make file!"); 
05E82:  MOV     #0,W1
05E84:  MOV     W1,W0
05E86:  CLR.B   1
05E88:  CALL    2C0
05E8C:  INC     W1,W1
05E8E:  BTSC.B  223.1
05E90:  BRA     5E8E
05E92:  MOV     W0,224
05E94:  MOV     #2B,W0
05E96:  CPSGT   W1,W0
05E98:  BRA     5E84
....................       return; 
05E9A:  BRA     5F52
....................    } 
....................  
....................  //  printf("\r\nMaking file '%s': ", fileName); 
....................  
....................    f = FSfopen (fileName, "w"); 
05E9C:  MOV     #2,W3
05E9E:  MOV     #0,W2
05EA0:  MOV     #FD2,W1
05EA2:  MOV     W3,[W15++]
05EA4:  MOV     W2,W0
05EA6:  CALL    2FA
05EAA:  MOV     [--W15],W3
05EAC:  MOV.B   W0L,[W1++]
05EAE:  INC     W2,W2
05EB0:  DEC     W3,W3
05EB2:  BTSS.B  42.1
05EB4:  BRA     5EA2
05EB6:  PUSH    FCC
05EB8:  POP     101C
05EBA:  MOV     #FD2,W4
05EBC:  MOV     W4,101E
05EBE:  CALL    4A26
05EC2:  MOV     W0,FCE
....................    if (!f) 
05EC4:  CP0     FCE
05EC6:  BRA     NZ,5EF6
....................    { 
....................       printf("Error (open error %X)", FSerrno); 
05EC8:  MOV     #0,W1
05ECA:  MOV     W1,W0
05ECC:  CLR.B   1
05ECE:  CALL    308
05ED2:  INC     W1,W1
05ED4:  BTSC.B  223.1
05ED6:  BRA     5ED4
05ED8:  MOV     W0,224
05EDA:  MOV     #11,W0
05EDC:  CPSGT   W1,W0
05EDE:  BRA     5ECA
05EE0:  MOV.B   8B1,W0L
05EE2:  CLR.B   1
05EE4:  MOV     #704,W1
05EE6:  CALL    4E3C
05EEA:  BTSC.B  223.1
05EEC:  BRA     5EEA
05EEE:  MOV     #29,W4
05EF0:  MOV     W4,224
....................    } 
05EF2:  GOTO    5F52
....................    else 
....................    { 
....................       ret = FSfclose(f); 
05EF6:  PUSH    FCE
05EF8:  POP     101C
05EFA:  CALL    5142
05EFE:  MOV     W0,FD0
....................       if (ret) 
05F00:  CP0     FD0
05F02:  BRA     Z,5F42
....................       { 
....................          printf("Error (close error %X %X)", ret, FSerrno); 
05F04:  MOV     #0,W1
05F06:  MOV     W1,W0
05F08:  CLR.B   1
05F0A:  CALL    32A
05F0E:  INC     W1,W1
05F10:  BTSC.B  223.1
05F12:  BRA     5F10
05F14:  MOV     W0,224
05F16:  MOV     #12,W0
05F18:  CPSGT   W1,W0
05F1A:  BRA     5F06
05F1C:  MOV     FD0,W0
05F1E:  MOV     #704,W1
05F20:  CALL    4E3C
05F24:  BTSC.B  223.1
05F26:  BRA     5F24
05F28:  MOV     #20,W4
05F2A:  MOV     W4,224
05F2C:  MOV.B   8B1,W0L
05F2E:  CLR.B   1
05F30:  MOV     #704,W1
05F32:  CALL    4E3C
05F36:  BTSC.B  223.1
05F38:  BRA     5F36
05F3A:  MOV     #29,W4
05F3C:  MOV     W4,224
....................       } 
05F3E:  GOTO    5F52
....................       else 
....................       { 
....................          printf("OK"); 
05F42:  BTSC.B  223.1
05F44:  BRA     5F42
05F46:  MOV     #4F,W4
05F48:  MOV     W4,224
05F4A:  BTSC.B  223.1
05F4C:  BRA     5F4A
05F4E:  MOV     #4B,W4
05F50:  MOV     W4,224
....................       } 
....................    } 
05F52:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Append a string to a file. 
.................... Param: The full path of the file to append to. 
.................... Param: A pointer to a string to append to the file. 
.................... Returns: None. 
.................... Example Usage: \> append "Log.txt" "This will be appended to the end of Log.txt" 
.................... Note: A "\r\n" will be appended after the appendString. 
.................... */ 
.................... void AppendFile(char *fileName, char *appendString) 
*
05274:  MOV     W5,[W15++]
.................... { 
....................    FSFILE* f; 
05276:  CLR     FD0
....................    char newLine[]="\r\n"; 
05278:  MOV     #A0D,W4
0527A:  MOV     W4,FD2
0527C:  CLR.B   FD4
....................    int ret; 
0527E:  CLR     FD6
....................  
....................    if (!g_IsMounted) 
05280:  BTSC.B  85A.3
05282:  BRA     529E
....................    { 
....................       printf("\r\nMedia not mounted, not going to append file!"); 
05284:  MOV     #0,W1
05286:  MOV     W1,W0
05288:  CLR.B   1
0528A:  CALL    350
0528E:  INC     W1,W1
05290:  BTSC.B  223.1
05292:  BRA     5290
05294:  MOV     W0,224
05296:  MOV     #2D,W0
05298:  CPSGT   W1,W0
0529A:  BRA     5286
....................       return; 
0529C:  BRA     53F8
....................    } 
....................  
....................    printf("\r\nAppending '%s' to '%s': ", appendString, fileName); 
0529E:  MOV     #0,W1
052A0:  MOV     W1,W0
052A2:  CLR.B   1
052A4:  CALL    38C
052A8:  INC     W1,W1
052AA:  BTSC.B  223.1
052AC:  BRA     52AA
052AE:  MOV     W0,224
052B0:  MOV     #C,W0
052B2:  CPSGT   W1,W0
052B4:  BRA     52A0
052B6:  MOV     FCE,W1
052B8:  CP0.B   [W1]
052BA:  BRA     Z,52CA
052BC:  BTSC.B  223.1
052BE:  BRA     52BC
052C0:  MOV.B   [W1+#0],W0L
052C2:  MOV.B   W0L,224
052C4:  CLR.B   225
052C6:  INC     W1,W1
052C8:  BRA     52B8
052CA:  MOV     #F,W1
052CC:  MOV     W1,W0
052CE:  CLR.B   1
052D0:  CALL    38C
052D4:  INC     W1,W1
052D6:  BTSC.B  223.1
052D8:  BRA     52D6
052DA:  MOV     W0,224
052DC:  MOV     #14,W0
052DE:  CPSGT   W1,W0
052E0:  BRA     52CC
052E2:  MOV     FCC,W1
052E4:  CP0.B   [W1]
052E6:  BRA     Z,52F6
052E8:  BTSC.B  223.1
052EA:  BRA     52E8
052EC:  MOV.B   [W1+#0],W0L
052EE:  MOV.B   W0L,224
052F0:  CLR.B   225
052F2:  INC     W1,W1
052F4:  BRA     52E4
052F6:  BTSC.B  223.1
052F8:  BRA     52F6
052FA:  MOV     #27,W4
052FC:  MOV     W4,224
052FE:  BTSC.B  223.1
05300:  BRA     52FE
05302:  MOV     #3A,W4
05304:  MOV     W4,224
05306:  BTSC.B  223.1
05308:  BRA     5306
0530A:  MOV     #20,W4
0530C:  MOV     W4,224
....................    f = FSfopen(fileName, "a"); 
0530E:  MOV     #2,W3
05310:  MOV     #0,W2
05312:  MOV     #FD8,W1
05314:  MOV     W3,[W15++]
05316:  MOV     W2,W0
05318:  CALL    3B4
0531C:  MOV     [--W15],W3
0531E:  MOV.B   W0L,[W1++]
05320:  INC     W2,W2
05322:  DEC     W3,W3
05324:  BTSS.B  42.1
05326:  BRA     5314
05328:  PUSH    FCC
0532A:  POP     101C
0532C:  MOV     #FD8,W4
0532E:  MOV     W4,101E
05330:  CALL    4A26
05334:  MOV     W0,FD0
....................    if(!f) 
05336:  CP0     FD0
05338:  BRA     NZ,5366
....................    { 
....................       printf("Error (%X)", FSerrno); 
0533A:  MOV     #0,W1
0533C:  MOV     W1,W0
0533E:  CLR.B   1
05340:  CALL    3C2
05344:  INC     W1,W1
05346:  BTSC.B  223.1
05348:  BRA     5346
0534A:  MOV     W0,224
0534C:  MOV     #6,W0
0534E:  CPSGT   W1,W0
05350:  BRA     533C
05352:  MOV.B   8B1,W0L
05354:  CLR.B   1
05356:  MOV     #704,W1
05358:  CALL    4E3C
0535C:  BTSC.B  223.1
0535E:  BRA     535C
05360:  MOV     #29,W4
05362:  MOV     W4,224
....................       return; 
05364:  BRA     53F8
....................    } 
....................  
....................    FSfwrite(appendString, sizeof(char), strlen(appendString), f); 
05366:  PUSH    FCE
05368:  POP     1090
0536A:  CALL    25A8
0536E:  MOV     W0,W5
05370:  MOV     #1,W4
05372:  MOV     W4,FE4
05374:  PUSH    FCE
05376:  POP     FE2
05378:  MOV     W5,FE6
0537A:  PUSH    FD0
0537C:  POP     FE8
0537E:  CALL    4E70
....................    FSfwrite(newLine, sizeof(char), strlen(newLine), f); 
05382:  MOV     #FD2,W4
05384:  MOV     W4,1090
05386:  CALL    25A8
0538A:  MOV     W0,W5
0538C:  MOV     #1,W4
0538E:  MOV     W4,FE4
05390:  MOV     #FD2,W4
05392:  MOV     W4,FE2
05394:  MOV     W5,FE6
05396:  PUSH    FD0
05398:  POP     FE8
0539A:  CALL    4E70
....................  
....................    ret = FSfclose(f); 
0539E:  PUSH    FD0
053A0:  POP     101C
053A2:  CALL    5142
053A6:  MOV     W0,FD6
....................    if(ret) 
053A8:  CP0     FD6
053AA:  BRA     Z,53E8
....................    { 
....................       printf("Error (%X %X)", ret, FSerrno); 
053AC:  MOV     #0,W1
053AE:  MOV     W1,W0
053B0:  CLR.B   1
053B2:  CALL    3DA
053B6:  INC     W1,W1
053B8:  BTSC.B  223.1
053BA:  BRA     53B8
053BC:  MOV     W0,224
053BE:  MOV     #6,W0
053C0:  CPSGT   W1,W0
053C2:  BRA     53AE
053C4:  MOV     FD6,W0
053C6:  MOV     #704,W1
053C8:  CALL    4E3C
053CC:  BTSC.B  223.1
053CE:  BRA     53CC
053D0:  MOV     #20,W4
053D2:  MOV     W4,224
053D4:  MOV.B   8B1,W0L
053D6:  CLR.B   1
053D8:  MOV     #704,W1
053DA:  CALL    4E3C
053DE:  BTSC.B  223.1
053E0:  BRA     53DE
053E2:  MOV     #29,W4
053E4:  MOV     W4,224
....................       return; 
053E6:  BRA     53F8
....................    } 
....................    printf("OK"); 
053E8:  BTSC.B  223.1
053EA:  BRA     53E8
053EC:  MOV     #4F,W4
053EE:  MOV     W4,224
053F0:  BTSC.B  223.1
053F2:  BRA     53F0
053F4:  MOV     #4B,W4
053F6:  MOV     W4,224
053F8:  MOV     [--W15],W5
053FA:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Change the working directory. 
.................... Param: The new working directory to switch to. 
.................... Returns: None. 
.................... Example Usage: \> cd ftp/     -> /ftp/ 
....................                \ftp\> cd files/  -> /ftp/files/ 
....................                \ftp\files> cd..  -> /ftp/ 
....................                \ftp\> cd ..      -> / 
....................                \> cd /ftp/files/ -> /ftp/files/ 
....................  
.................... Note: Changing the directory to .. will go up a directory. 
.................... */ 
.................... void ChangeDirectory(char *newCWD) 
.................... { 
....................    if (!g_IsMounted) 
*
0651A:  BTSC.B  85A.3
0651C:  BRA     6538
....................    { 
....................       printf("\r\nMedia not mounted, not going to change directory!"); 
0651E:  MOV     #0,W1
06520:  MOV     W1,W0
06522:  CLR.B   1
06524:  CALL    3F4
06528:  INC     W1,W1
0652A:  BTSC.B  223.1
0652C:  BRA     652A
0652E:  MOV     W0,224
06530:  MOV     #32,W0
06532:  CPSGT   W1,W0
06534:  BRA     6520
....................       return; 
06536:  BRA     655C
....................    } 
....................  
....................    if (FSchdir(newCWD)) 
06538:  PUSH    FCC
0653A:  POP     1008
0653C:  CALL    650A
06540:  CP0     W0
06542:  BRA     Z,655C
....................    { 
....................       printf("\r\nError changing directory"); 
06544:  MOV     #0,W1
06546:  MOV     W1,W0
06548:  CLR.B   1
0654A:  CALL    434
0654E:  INC     W1,W1
06550:  BTSC.B  223.1
06552:  BRA     6550
06554:  MOV     W0,224
06556:  MOV     #19,W0
06558:  CPSGT   W1,W0
0655A:  BRA     6546
....................    } 
0655C:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Display the contents of the working directory. 
.................... Param: The full path of the directory contents to display. 
.................... Returns: None. 
.................... Example Usage: /> dir 
.................... */ 
.................... void DisplayDirectory(void) 
*
06AC8:  MOV     W5,[W15++]
.................... { 
....................    SearchRec s; 
06ACA:  CLR     FCC
06ACC:  CLR     FCE
06ACE:  CLR     FD0
06AD0:  CLR     FD2
06AD2:  CLR     FD4
06AD4:  CLR     FD6
06AD6:  CLR     FD8
06AD8:  CLR     FDA
06ADA:  CLR     FDC
06ADC:  CLR     FDE
06ADE:  CLR     FE0
06AE0:  CLR     FE2
06AE2:  CLR     FE4
06AE4:  CLR     FE6
06AE6:  CLR     FE8
06AE8:  CLR     FEA
06AEA:  CLR     FEC
06AEC:  CLR     FEE
06AEE:  CLR     FF0
06AF0:  CLR     FF2
06AF2:  CLR     FF4
06AF4:  CLR     FF6
....................    int ret; 
06AF6:  CLR     FF8
....................    char str[20]; 
06AF8:  CLR     FFA
06AFA:  CLR     FFC
06AFC:  CLR     FFE
06AFE:  CLR     1000
06B00:  CLR     1002
06B02:  CLR     1004
06B04:  CLR     1006
06B06:  CLR     1008
06B08:  CLR     100A
06B0A:  CLR     100C
....................  
....................    if (!g_IsMounted) 
06B0C:  BTSC.B  85A.3
06B0E:  BRA     6B2A
....................    { 
....................       printf("\r\nMedia not mounted, not going to display directory!"); 
06B10:  MOV     #0,W1
06B12:  MOV     W1,W0
06B14:  CLR.B   1
06B16:  CALL    45C
06B1A:  INC     W1,W1
06B1C:  BTSC.B  223.1
06B1E:  BRA     6B1C
06B20:  MOV     W0,224
06B22:  MOV     #33,W0
06B24:  CPSGT   W1,W0
06B26:  BRA     6B12
....................       return; 
06B28:  BRA     6C6C
....................    } 
....................  
....................    memset(&s, 0x00, sizeof(s)); 
06B2A:  MOV     #FCC,W1
06B2C:  MOV     #0,W2
06B2E:  REPEAT  #2B
06B30:  CLR.B   [W1++]
....................  
....................    ret = FindFirst("*.*", ATTR_MASK, &s); 
06B32:  MOV     #4,W3
06B34:  MOV     #0,W2
06B36:  MOV     #100E,W1
06B38:  MOV     W3,[W15++]
06B3A:  MOV     W2,W0
06B3C:  CALL    49C
06B40:  MOV     [--W15],W3
06B42:  MOV.B   W0L,[W1++]
06B44:  INC     W2,W2
06B46:  DEC     W3,W3
06B48:  BTSS.B  42.1
06B4A:  BRA     6B38
06B4C:  MOV     #100E,W4
06B4E:  MOV     W4,1012
06B50:  MOV     #3F,W4
06B52:  MOV     W4,1014
06B54:  MOV     #FCC,W4
06B56:  MOV     W4,1016
06B58:  CALL    655E
06B5C:  MOV     W0,FF8
....................  
....................    for(;;) 
....................    { 
....................       if (ret != 0) 
06B5E:  CP0     FF8
06B60:  BRA     Z,6BB0
....................       { 
....................          printf("\r\n\nDirectory search completed"); 
06B62:  MOV     #0,W1
06B64:  MOV     W1,W0
06B66:  CLR.B   1
06B68:  CALL    4AC
06B6C:  INC     W1,W1
06B6E:  BTSC.B  223.1
06B70:  BRA     6B6E
06B72:  MOV     W0,224
06B74:  MOV     #1C,W0
06B76:  CPSGT   W1,W0
06B78:  BRA     6B64
....................  
....................          if (FSerrno != CE_FILE_NOT_FOUND) 
06B7A:  MOV     8B0,W4
06B7C:  LSR     W4,#8,W4
06B7E:  CP.B    W4L,#B
06B80:  BRA     Z,6BAC
....................          { 
....................             printf(" (FSerrno = %u)", FSerrno); 
06B82:  MOV     #0,W1
06B84:  MOV     W1,W0
06B86:  CLR.B   1
06B88:  CALL    4D6
06B8C:  INC     W1,W1
06B8E:  BTSC.B  223.1
06B90:  BRA     6B8E
06B92:  MOV     W0,224
06B94:  MOV     #B,W0
06B96:  CPSGT   W1,W0
06B98:  BRA     6B84
06B9A:  MOV.B   8B1,W0L
06B9C:  CLR.B   1
06B9E:  MOV     #0,W4
06BA0:  CALL    23D6
06BA4:  BTSC.B  223.1
06BA6:  BRA     6BA4
06BA8:  MOV     #29,W4
06BAA:  MOV     W4,224
....................          } 
....................          break; 
06BAC:  GOTO    6C6C
....................       } 
....................  
....................       if ((s.attributes & ATTR_VOLUME) != ATTR_VOLUME) 
06BB0:  MOV.B   FD9,W0L
06BB2:  CLR.B   1
06BB4:  AND     W0,#8,W5
06BB6:  CP      W5,#8
06BB8:  BRA     Z,6C5E
....................       { 
....................          if ((s.attributes & ATTR_DIRECTORY) == ATTR_DIRECTORY) 
06BBA:  MOV.B   FD9,W0L
06BBC:  CLR.B   1
06BBE:  AND     W0,#10,W5
06BC0:  CP      W5,#10
06BC2:  BRA     NZ,6BEA
....................             sprintf(str, "<DIR>  "); 
06BC4:  MOV     #FFA,W4
06BC6:  MOV     W4,EA8
06BC8:  MOV     #0,W1
06BCA:  MOV     W1,W0
06BCC:  CLR.B   1
06BCE:  CALL    4F2
06BD2:  INC     W1,W1
06BD4:  MOV     W1,[W15++]
06BD6:  MOV     W0,[W15++]
06BD8:  MOV     [--W15],W0
06BDA:  CALL    2592
06BDE:  MOV     [--W15],W1
06BE0:  MOV     #6,W0
06BE2:  CPSGT   W1,W0
06BE4:  BRA     6BCA
06BE6:  GOTO    6C0C
....................          else 
....................             sprintf(str, "       "); 
06BEA:  MOV     #FFA,W4
06BEC:  MOV     W4,EA8
06BEE:  MOV     #0,W1
06BF0:  MOV     W1,W0
06BF2:  CLR.B   1
06BF4:  CALL    506
06BF8:  INC     W1,W1
06BFA:  MOV     W1,[W15++]
06BFC:  MOV     W0,[W15++]
06BFE:  MOV     [--W15],W0
06C00:  CALL    2592
06C04:  MOV     [--W15],W1
06C06:  MOV     #6,W0
06C08:  CPSGT   W1,W0
06C0A:  BRA     6BF0
....................  
....................          printf("\r\n%lu\t\t%s%s", s.filesize, str, s.filename); 
06C0C:  BTSC.B  223.1
06C0E:  BRA     6C0C
06C10:  MOV     #D,W4
06C12:  MOV     W4,224
06C14:  BTSC.B  223.1
06C16:  BRA     6C14
06C18:  MOV     #A,W4
06C1A:  MOV     W4,224
06C1C:  MOV     FDA,W0
06C1E:  MOV     FDC,W1
06C20:  MOV     #0,W4
06C22:  CALL    230E
06C26:  BTSC.B  223.1
06C28:  BRA     6C26
06C2A:  MOV     #9,W4
06C2C:  MOV     W4,224
06C2E:  BTSC.B  223.1
06C30:  BRA     6C2E
06C32:  MOV     #9,W4
06C34:  MOV     W4,224
06C36:  MOV     #FFA,W1
06C38:  CP0.B   [W1]
06C3A:  BRA     Z,6C4A
06C3C:  BTSC.B  223.1
06C3E:  BRA     6C3C
06C40:  MOV.B   [W1+#0],W0L
06C42:  MOV.B   W0L,224
06C44:  CLR.B   225
06C46:  INC     W1,W1
06C48:  BRA     6C38
06C4A:  MOV     #FCC,W1
06C4C:  CP0.B   [W1]
06C4E:  BRA     Z,6C5E
06C50:  BTSC.B  223.1
06C52:  BRA     6C50
06C54:  MOV.B   [W1+#0],W0L
06C56:  MOV.B   W0L,224
06C58:  CLR.B   225
06C5A:  INC     W1,W1
06C5C:  BRA     6C4C
....................       } 
....................  
....................       ret = FindNext(&s); 
06C5E:  MOV     #FCC,W4
06C60:  MOV     W4,1012
06C62:  CALL    6840
06C66:  MOV     W0,FF8
06C68:  GOTO    6B5E
....................    } 
06C6C:  MOV     [--W15],W5
06C6E:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Create a directory. 
.................... Param: The full path of the directory to create. 
.................... Returns: None. 
.................... Example Usage: /> mkdir "Backlog" 
.................... */ 
.................... void MakeDirectory(char *dir) 
.................... { 
....................    if (!g_IsMounted) 
*
07688:  BTSC.B  85A.3
0768A:  BRA     76A6
....................    { 
....................       printf("\r\nMedia not mounted, not going to make directory!"); 
0768C:  MOV     #0,W1
0768E:  MOV     W1,W0
07690:  CLR.B   1
07692:  CALL    51A
07696:  INC     W1,W1
07698:  BTSC.B  223.1
0769A:  BRA     7698
0769C:  MOV     W0,224
0769E:  MOV     #30,W0
076A0:  CPSGT   W1,W0
076A2:  BRA     768E
....................       return; 
076A4:  BRA     7732
....................    } 
....................  
....................    printf("\r\nMaking directory '%s': ", dir); 
076A6:  MOV     #0,W1
076A8:  MOV     W1,W0
076AA:  CLR.B   1
076AC:  CALL    558
076B0:  INC     W1,W1
076B2:  BTSC.B  223.1
076B4:  BRA     76B2
076B6:  MOV     W0,224
076B8:  MOV     #13,W0
076BA:  CPSGT   W1,W0
076BC:  BRA     76A8
076BE:  MOV     FCC,W1
076C0:  CP0.B   [W1]
076C2:  BRA     Z,76D2
076C4:  BTSC.B  223.1
076C6:  BRA     76C4
076C8:  MOV.B   [W1+#0],W0L
076CA:  MOV.B   W0L,224
076CC:  CLR.B   225
076CE:  INC     W1,W1
076D0:  BRA     76C0
076D2:  BTSC.B  223.1
076D4:  BRA     76D2
076D6:  MOV     #27,W4
076D8:  MOV     W4,224
076DA:  BTSC.B  223.1
076DC:  BRA     76DA
076DE:  MOV     #3A,W4
076E0:  MOV     W4,224
076E2:  BTSC.B  223.1
076E4:  BRA     76E2
076E6:  MOV     #20,W4
076E8:  MOV     W4,224
....................  
....................    if(FSmkdir(dir)) 
076EA:  PUSH    FCC
076EC:  POP     FD0
076EE:  CALL    7678
076F2:  CP0     W0
076F4:  BRA     Z,7722
....................    { 
....................       printf("Error creating directory (FSerrno = %u)", FSerrno); 
076F6:  MOV     #0,W1
076F8:  MOV     W1,W0
076FA:  CLR.B   1
076FC:  CALL    57E
07700:  INC     W1,W1
07702:  BTSC.B  223.1
07704:  BRA     7702
07706:  MOV     W0,224
07708:  MOV     #23,W0
0770A:  CPSGT   W1,W0
0770C:  BRA     76F8
0770E:  MOV.B   8B1,W0L
07710:  CLR.B   1
07712:  MOV     #0,W4
07714:  CALL    23D6
07718:  BTSC.B  223.1
0771A:  BRA     7718
0771C:  MOV     #29,W4
0771E:  MOV     W4,224
....................       return; 
07720:  BRA     7732
....................    } 
....................    printf("OK"); 
07722:  BTSC.B  223.1
07724:  BRA     7722
07726:  MOV     #4F,W4
07728:  MOV     W4,224
0772A:  BTSC.B  223.1
0772C:  BRA     772A
0772E:  MOV     #4B,W4
07730:  MOV     W4,224
07732:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Remove a directory. 
.................... Param: The full path of the directory to remove. 
.................... Returns: None. 
.................... Example Usage: /> rmdir "Backlog" 
.................... Note: The directory needs to be empty in order for this command to work. 
.................... */ 
.................... void RemoveDirectory(char *dir) 
.................... { 
....................    if (!g_IsMounted) 
*
07EBA:  BTSC.B  85A.3
07EBC:  BRA     7ED8
....................    { 
....................       printf("\r\nMedia not mounted, not going to remove directory!"); 
07EBE:  MOV     #0,W1
07EC0:  MOV     W1,W0
07EC2:  CLR.B   1
07EC4:  CALL    5B2
07EC8:  INC     W1,W1
07ECA:  BTSC.B  223.1
07ECC:  BRA     7ECA
07ECE:  MOV     W0,224
07ED0:  MOV     #32,W0
07ED2:  CPSGT   W1,W0
07ED4:  BRA     7EC0
....................       return; 
07ED6:  BRA     7F54
....................    } 
....................  
....................    printf("\r\nRemoving directory '%s': ", dir); 
07ED8:  MOV     #0,W1
07EDA:  MOV     W1,W0
07EDC:  CLR.B   1
07EDE:  CALL    5F2
07EE2:  INC     W1,W1
07EE4:  BTSC.B  223.1
07EE6:  BRA     7EE4
07EE8:  MOV     W0,224
07EEA:  MOV     #15,W0
07EEC:  CPSGT   W1,W0
07EEE:  BRA     7EDA
07EF0:  MOV     FCC,W1
07EF2:  CP0.B   [W1]
07EF4:  BRA     Z,7F04
07EF6:  BTSC.B  223.1
07EF8:  BRA     7EF6
07EFA:  MOV.B   [W1+#0],W0L
07EFC:  MOV.B   W0L,224
07EFE:  CLR.B   225
07F00:  INC     W1,W1
07F02:  BRA     7EF2
07F04:  BTSC.B  223.1
07F06:  BRA     7F04
07F08:  MOV     #27,W4
07F0A:  MOV     W4,224
07F0C:  BTSC.B  223.1
07F0E:  BRA     7F0C
07F10:  MOV     #3A,W4
07F12:  MOV     W4,224
07F14:  BTSC.B  223.1
07F16:  BRA     7F14
07F18:  MOV     #20,W4
07F1A:  MOV     W4,224
....................  
....................    if(FSrmdir(dir, FALSE)) 
07F1C:  CLR.B   FD2
07F1E:  PUSH    FCC
07F20:  POP     FD0
07F22:  CALL    7EA6
07F26:  CP0     W0
07F28:  BRA     Z,7F44
....................    { 
....................       printf("Error removing directory"); 
07F2A:  MOV     #0,W1
07F2C:  MOV     W1,W0
07F2E:  CLR.B   1
07F30:  CALL    61A
07F34:  INC     W1,W1
07F36:  BTSC.B  223.1
07F38:  BRA     7F36
07F3A:  MOV     W0,224
07F3C:  MOV     #17,W0
07F3E:  CPSGT   W1,W0
07F40:  BRA     7F2C
....................       return; 
07F42:  BRA     7F54
....................    } 
....................    printf("OK"); 
07F44:  BTSC.B  223.1
07F46:  BRA     7F44
07F48:  MOV     #4F,W4
07F4A:  MOV     W4,224
07F4C:  BTSC.B  223.1
07F4E:  BRA     7F4C
07F50:  MOV     #4B,W4
07F52:  MOV     W4,224
07F54:  RETURN  
.................... } 
....................  
.................... #define CAT_FROM_START  FALSE 
.................... #define CAT_FROM_END    TRUE 
.................... /* 
.................... Summary: Prints either all of or the last 80 characters in a file. 
.................... Param: The full path of the file to print off. 
.................... Param: If true, this function will print off the last 80 characters in the file. 
....................        If false, this funciton will print off the entire file. 
.................... Returns: None. 
.................... Example Usage: /> cat "Logs.txt" (this will display the entire file) 
.................... Example Usage: /> tail "Logs.txt" (this will display the last 80 characters in the file) 
.................... */ 
.................... void PrintFile(char *fileName, int1 startFromEnd) 
*
06E9A:  MOV     W5,[W15++]
.................... { 
....................    char scr[65]; 
06E9C:  CLR     FD0
06E9E:  CLR     FD2
06EA0:  CLR     FD4
06EA2:  CLR     FD6
06EA4:  CLR     FD8
06EA6:  CLR     FDA
06EA8:  CLR     FDC
06EAA:  CLR     FDE
06EAC:  CLR     FE0
06EAE:  CLR     FE2
06EB0:  CLR     FE4
06EB2:  CLR     FE6
06EB4:  CLR     FE8
06EB6:  CLR     FEA
06EB8:  CLR     FEC
06EBA:  CLR     FEE
06EBC:  CLR     FF0
06EBE:  CLR     FF2
06EC0:  CLR     FF4
06EC2:  CLR     FF6
06EC4:  CLR     FF8
06EC6:  CLR     FFA
06EC8:  CLR     FFC
06ECA:  CLR     FFE
06ECC:  CLR     1000
06ECE:  CLR     1002
06ED0:  CLR     1004
06ED2:  CLR     1006
06ED4:  CLR     1008
06ED6:  CLR     100A
06ED8:  CLR     100C
06EDA:  CLR     100E
06EDC:  CLR.B   1010
....................    size_t len; 
06EDE:  CLR     1012
....................    FSFILE* f; 
06EE0:  CLR     1014
....................  
....................    if (!g_IsMounted) 
06EE2:  BTSC.B  85A.3
06EE4:  BRA     6F00
....................    { 
....................       printf("\r\nMedia not mounted, not going to display file!"); 
06EE6:  MOV     #0,W1
06EE8:  MOV     W1,W0
06EEA:  CLR.B   1
06EEC:  CALL    640
06EF0:  INC     W1,W1
06EF2:  BTSC.B  223.1
06EF4:  BRA     6EF2
06EF6:  MOV     W0,224
06EF8:  MOV     #2E,W0
06EFA:  CPSGT   W1,W0
06EFC:  BRA     6EE8
....................       return; 
06EFE:  BRA     7000
....................    } 
....................  
....................    f = FSfopen(fileName, "r"); 
06F00:  MOV     #2,W3
06F02:  MOV     #0,W2
06F04:  MOV     #1016,W1
06F06:  MOV     W3,[W15++]
06F08:  MOV     W2,W0
06F0A:  CALL    67C
06F0E:  MOV     [--W15],W3
06F10:  MOV.B   W0L,[W1++]
06F12:  INC     W2,W2
06F14:  DEC     W3,W3
06F16:  BTSS.B  42.1
06F18:  BRA     6F06
06F1A:  PUSH    FCC
06F1C:  POP     101C
06F1E:  MOV     #1016,W4
06F20:  MOV     W4,101E
06F22:  CALL    4A26
06F26:  MOV     W0,1014
....................    if (!f) 
06F28:  CP0     1014
06F2A:  BRA     NZ,6F58
....................    { 
....................       printf("\r\nError opening file (Error %X)", FSerrno); 
06F2C:  MOV     #0,W1
06F2E:  MOV     W1,W0
06F30:  CLR.B   1
06F32:  CALL    68A
06F36:  INC     W1,W1
06F38:  BTSC.B  223.1
06F3A:  BRA     6F38
06F3C:  MOV     W0,224
06F3E:  MOV     #1B,W0
06F40:  CPSGT   W1,W0
06F42:  BRA     6F2E
06F44:  MOV.B   8B1,W0L
06F46:  CLR.B   1
06F48:  MOV     #704,W1
06F4A:  CALL    4E3C
06F4E:  BTSC.B  223.1
06F50:  BRA     6F4E
06F52:  MOV     #29,W4
06F54:  MOV     W4,224
....................       return; 
06F56:  BRA     7000
....................    } 
....................  
....................    printf("\r\n"); 
06F58:  BTSC.B  223.1
06F5A:  BRA     6F58
06F5C:  MOV     #D,W4
06F5E:  MOV     W4,224
06F60:  BTSC.B  223.1
06F62:  BRA     6F60
06F64:  MOV     #A,W4
06F66:  MOV     W4,224
....................  
....................    if(startFromEnd) 
06F68:  CP0.B   FCE
06F6A:  BRA     Z,6F7E
....................       FSfseek(f, 80, SEEK_END); 
06F6C:  PUSH    1014
06F6E:  POP     102C
06F70:  MOV     #50,W4
06F72:  MOV     W4,102E
06F74:  CLR     1030
06F76:  MOV     #2,W4
06F78:  MOV     W4,1032
06F7A:  CALL    4760
....................  
....................    do 
....................    { 
....................       len = FSfread(scr, sizeof(char), (sizeof(scr)-1), f); 
06F7E:  MOV     #1,W4
06F80:  MOV     W4,101E
06F82:  MOV     #FD0,W4
06F84:  MOV     W4,101C
06F86:  MOV     #40,W4
06F88:  MOV     W4,1020
06F8A:  PUSH    1014
06F8C:  POP     1022
06F8E:  CALL    6C70
06F92:  MOV     W0,1012
....................       if (FSerrno && (FSerrno != CE_EOF)) 
06F94:  CP0.B   8B1
06F96:  BRA     Z,6FD0
06F98:  MOV     8B0,W4
06F9A:  LSR     W4,#8,W4
06F9C:  XOR.B   #3D,W4L
06F9E:  BRA     Z,6FD0
....................       { 
....................          printf("\r\n!!! Error reading file (Error %X)", FSerrno); 
06FA0:  MOV     #0,W1
06FA2:  MOV     W1,W0
06FA4:  CLR.B   1
06FA6:  CALL    6B6
06FAA:  INC     W1,W1
06FAC:  BTSC.B  223.1
06FAE:  BRA     6FAC
06FB0:  MOV     W0,224
06FB2:  MOV     #1F,W0
06FB4:  CPSGT   W1,W0
06FB6:  BRA     6FA2
06FB8:  MOV.B   8B1,W0L
06FBA:  CLR.B   1
06FBC:  MOV     #704,W1
06FBE:  CALL    4E3C
06FC2:  BTSC.B  223.1
06FC4:  BRA     6FC2
06FC6:  MOV     #29,W4
06FC8:  MOV     W4,224
....................          len = 0; 
06FCA:  CLR     1012
....................          break; 
06FCC:  GOTO    6FF8
....................       } 
....................       if (len) 
06FD0:  CP0     1012
06FD2:  BRA     Z,6FF0
....................       { 
....................          scr[len] = 0; 
06FD4:  MOV     #FD0,W4
06FD6:  MOV     1012,W3
06FD8:  ADD     W3,W4,W5
06FDA:  CLR.B   [W5]
....................          //DEBUG_STR("PrintFile() got", len); 
....................          printf("%s", scr); 
06FDC:  MOV     #FD0,W1
06FDE:  CP0.B   [W1]
06FE0:  BRA     Z,6FF0
06FE2:  BTSC.B  223.1
06FE4:  BRA     6FE2
06FE6:  MOV.B   [W1+#0],W0L
06FE8:  MOV.B   W0L,224
06FEA:  CLR.B   225
06FEC:  INC     W1,W1
06FEE:  BRA     6FDE
....................       } 
....................    } while(FSerrno != CE_EOF); 
06FF0:  MOV     8B0,W4
06FF2:  LSR     W4,#8,W4
06FF4:  XOR.B   #3D,W4L
06FF6:  BRA     NZ,6F7E
....................  
....................    FSfclose(f); 
06FF8:  PUSH    1014
06FFA:  POP     101C
06FFC:  CALL    5142
07000:  MOV     [--W15],W5
07002:  RETURN  
.................... } 
....................  
.................... //***************************************************************************** 
.................... // Created Dacember 30, 2014 
.................... // Turn on power to card. 
.................... // This is done through Pin_RG9 
.................... //  This input into the function is as follows: 
.................... // Put power to the SD Card:  1 
.................... // Take away power to the SD Card: 0 
.................... //***************************************************************************** 
....................  
.................... void PowerSDCard(int8 state) 
.................... 	{ 
....................  
.................... 	if (state == 0) 
*
00E98:  MOV.B   FCC,W0L
00E9A:  SE      W0,W0
00E9C:  CP0     W0
00E9E:  BRA     NZ,EA4
.................... 		{ 
.................... 		TRISGbits.TRISG9 = OUTPUT; 
00EA0:  BCLR.B  2F1.1
.................... 		PORTGbits.RG9 =  0; 
00EA2:  BCLR.B  2F3.1
.................... 		//output_low(PIN_SDPOWER); 
.................... 		}	 
.................... 	if (state == 1) 
00EA4:  MOV.B   FCC,W0L
00EA6:  SE      W0,W0
00EA8:  CP      W0,#1
00EAA:  BRA     NZ,EB0
.................... 		{ 
.................... 		TRISGbits.TRISG9 = OUTPUT; 
00EAC:  BCLR.B  2F1.1
.................... 		PORTGbits.RG9 =  1; 
00EAE:  BSET.B  2F3.1
.................... 		} 
00EB0:  RETURN  
.................... 	} 
....................  
....................  
.................... void MountMedia(void) 
*
02488:  MOV     W5,[W15++]
0248A:  MOV     W6,[W15++]
0248C:  MOV     W7,[W15++]
0248E:  MOV     W8,[W15++]
.................... { 
....................    g_IsMounted = FALSE; 
02490:  BCLR.B  85A.3
....................  
....................  
.................... PowerSDCard(0);  //Power up the card 
02492:  CLR.B   FCC
02494:  CALL    E98
.................... 	 
....................  
....................    MDD_InitIO(); 
02498:  CALL    EB2
....................  
....................    if (!MDD_MediaDetect()) 
0249C:  CALL    1462
024A0:  CP0.B   W0L
024A2:  BRA     NZ,24BE
....................    { 
....................       printf("\r\nError, Media not found!"); 
024A4:  MOV     #0,W1
024A6:  MOV     W1,W0
024A8:  CLR.B   1
024AA:  CALL    6E6
024AE:  INC     W1,W1
024B0:  BTSC.B  223.1
024B2:  BRA     24B0
024B4:  MOV     W0,224
024B6:  MOV     #18,W0
024B8:  CPSGT   W1,W0
024BA:  BRA     24A6
....................       return; 
024BC:  BRA     2588
....................    } 
....................  
....................    if (FSInit()) 
024BE:  CALL    21DC
024C2:  CP0     W0
024C4:  BRA     Z,254E
....................    { 
....................       g_IsMounted = TRUE; 
024C6:  BSET.B  85A.3
....................  
....................       printf("\r\nOK (Sector Size=%LU, Sec Per Clus=%U, Type=%U)", 
....................             gDiskData.sectorSize, 
....................             gDiskData.SecPerClus, 
....................             gDiskData.type 
....................          ); 
024C8:  MOV     #0,W1
024CA:  MOV     W1,W0
024CC:  CLR.B   1
024CE:  CALL    70C
024D2:  INC     W1,W1
024D4:  BTSC.B  223.1
024D6:  BRA     24D4
024D8:  MOV     W0,224
024DA:  MOV     #11,W0
024DC:  CPSGT   W1,W0
024DE:  BRA     24CA
024E0:  MOV     #A,W1
024E2:  MOV     #D78,W2
024E4:  REPEAT  #3
024E6:  MOV.B   [W2++],[W1++]
024E8:  MOV     W5,W0
024EA:  MOV     W6,W1
024EC:  MOV     #0,W4
024EE:  CALL    230E
024F2:  MOV     #15,W1
024F4:  MOV     W1,W0
024F6:  CLR.B   1
024F8:  CALL    70C
024FC:  INC     W1,W1
024FE:  BTSC.B  223.1
02500:  BRA     24FE
02502:  MOV     W0,224
02504:  MOV     #23,W0
02506:  CPSGT   W1,W0
02508:  BRA     24F4
0250A:  MOV     #E,W1
0250C:  MOV     #D81,W2
0250E:  MOV.B   [W2++],[W1++]
02510:  MOV.B   W7L,W0L
02512:  CLR.B   1
02514:  MOV     #0,W4
02516:  CALL    23D6
0251A:  MOV     #26,W1
0251C:  MOV     W1,W0
0251E:  CLR.B   1
02520:  CALL    70C
02524:  INC     W1,W1
02526:  BTSC.B  223.1
02528:  BRA     2526
0252A:  MOV     W0,224
0252C:  MOV     #2C,W0
0252E:  CPSGT   W1,W0
02530:  BRA     251C
02532:  MOV     #10,W1
02534:  MOV     #D82,W2
02536:  MOV.B   [W2++],[W1++]
02538:  MOV.B   W8L,W0L
0253A:  CLR.B   1
0253C:  MOV     #0,W4
0253E:  CALL    23D6
02542:  BTSC.B  223.1
02544:  BRA     2542
02546:  MOV     #29,W4
02548:  MOV     W4,224
....................    } 
0254A:  GOTO    2588
....................    else 
....................    { 
....................       printf("\r\nError, file system not mounted (FSerrno=%U)!!!", FSerrno); 
0254E:  MOV     #0,W1
02550:  MOV     W1,W0
02552:  CLR.B   1
02554:  CALL    74A
02558:  INC     W1,W1
0255A:  BTSC.B  223.1
0255C:  BRA     255A
0255E:  MOV     W0,224
02560:  MOV     #29,W0
02562:  CPSGT   W1,W0
02564:  BRA     2550
02566:  MOV.B   8B1,W0L
02568:  CLR.B   1
0256A:  MOV     #0,W4
0256C:  CALL    23D6
02570:  MOV     #2C,W1
02572:  MOV     W1,W0
02574:  CLR.B   1
02576:  CALL    74A
0257A:  INC     W1,W1
0257C:  BTSC.B  223.1
0257E:  BRA     257C
02580:  MOV     W0,224
02582:  MOV     #2F,W0
02584:  CPSGT   W1,W0
02586:  BRA     2572
....................    } 
02588:  MOV     [--W15],W8
0258A:  MOV     [--W15],W7
0258C:  MOV     [--W15],W6
0258E:  MOV     [--W15],W5
02590:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Formats the media to a specified size. 
.................... Param: The size of the media, in kB, in string form. 
.................... Returns: None. 
.................... Example Usage: /> format 524288 (format a 512MB card) 
.................... */ 
.................... void FormatMedia(char *mediaSize) 
.................... { 
....................   #if !defined(ALLOW_FORMATS) 
....................    printf("\r\nError, formatting disabled!!!"); 
*
07F56:  MOV     #0,W1
07F58:  MOV     W1,W0
07F5A:  CLR.B   1
07F5C:  CALL    788
07F60:  INC     W1,W1
07F62:  BTSC.B  223.1
07F64:  BRA     7F62
07F66:  MOV     W0,224
07F68:  MOV     #1E,W0
07F6A:  CPSGT   W1,W0
07F6C:  BRA     7F58
....................   #else 
07F6E:  RETURN  
....................    uint32_t size; 
....................    int scr; 
....................    int1 ok = FALSE; 
....................    char c; 
....................    MEDIA_INFORMATION *m; 
....................  
....................    #define MEDIA_SERIAL_NUMBER   "123" 
....................    #define MEDIA_VOLUME_ID       "123" 
....................  
....................    g_IsMounted = FALSE; 
....................  
....................    MDD_InitIO(); 
....................  
....................    if (!MDD_MediaDetect()) 
....................    { 
....................       printf("\r\nError, media not found!"); 
....................       return; 
....................    } 
....................  
....................    m = MDD_MediaInitialize(); 
....................    if (m->errorCode != MEDIA_NO_ERROR) 
....................    { 
....................       printf("\r\nMedia not initialized (ec = %X), media not formatted!", m->errorCode); 
....................       return; 
....................    } 
....................  
....................    size = atoi32(mediaSize); 
....................    scr = strlen(mediaSize); 
....................    if (scr) 
....................    { 
....................       c = toupper(mediaSize[scr-1]); 
....................       if (c == 'K') 
....................          size *= (uint32_t)1024; 
....................       else if (c == 'M') 
....................          size *= (uint32_t)1024*1024; 
....................       else if (c == 'G') 
....................          size *= (uint32_t)1024*1024*1024; 
....................    } 
....................  
....................    printf("\r\nFormatting media (size=%LU, sector size=%LU): ", size, MEDIA_SECTOR_SIZE); 
....................  
....................    if (!FSCreateMBR(1, size/MEDIA_SECTOR_SIZE)) 
....................    { 
....................       if (!FSformat (1, MEDIA_SERIAL_NUMBER, MEDIA_VOLUME_ID)) 
....................       { 
....................          ok = TRUE; 
....................       } 
....................    } 
....................  
....................    if(!ok) 
....................    { 
....................       printf("Error formatting media"); 
....................       return; 
....................    } 
....................  
....................    MountMedia(); 
....................   #endif 
.................... } 
....................  
.................... void MediaInfo(void) 
*
08422:  MOV     W5,[W15++]
08424:  MOV     W6,[W15++]
.................... { 
....................    FS_DISK_PROPERTIES p; 
08426:  CLR     FCC
08428:  CLR     FCE
0842A:  CLR     FD0
0842C:  CLR     FD2
0842E:  CLR     FD4
08430:  CLR     FD6
08432:  CLR     FD8
08434:  CLR     FDA
08436:  CLR     FDC
08438:  CLR     FDE
0843A:  CLR     FE0
0843C:  CLR     FE2
0843E:  CLR     FE4
08440:  CLR     FE6
08442:  CLR     FE8
08444:  CLR     FEA
08446:  CLR     FEC
....................  
....................  
....................  
....................    if (g_IsMounted) 
08448:  BTSS.B  85A.3
0844A:  BRA     8590
....................    { 
....................       printf("\r\nGetting media info (this may take seconds to minutes)..."); 
0844C:  MOV     #0,W1
0844E:  MOV     W1,W0
08450:  CLR.B   1
08452:  CALL    7B4
08456:  INC     W1,W1
08458:  BTSC.B  223.1
0845A:  BRA     8458
0845C:  MOV     W0,224
0845E:  MOV     #39,W0
08460:  CPSGT   W1,W0
08462:  BRA     844E
....................       p.new_request = TRUE; 
08464:  BSET.B  FCE.0
....................  
....................       do 
....................       { 
....................          FSGetDiskProperties(&p); 
08466:  MOV     #FCC,W4
08468:  MOV     W4,FEE
0846A:  CALL    8152
....................       } while(p.properties_status == FS_GET_PROPERTIES_STILL_WORKING); 
0846E:  MOV     FCE,W4
08470:  LSR     W4,#8,W4
08472:  XOR.B   #FF,W4L
08474:  BRA     Z,8466
....................  
....................       if (p.properties_status == FS_GET_PROPERTIES_DISK_NOT_MOUNTED) 
08476:  MOV     FCE,W4
08478:  LSR     W4,#8,W4
0847A:  CP.B    W4L,#1
0847C:  BRA     NZ,849A
....................       { 
....................          printf("\r\n\nFile system thinks media isn't mounted, try mounting again!"); 
0847E:  MOV     #0,W1
08480:  MOV     W1,W0
08482:  CLR.B   1
08484:  CALL    7F8
08488:  INC     W1,W1
0848A:  BTSC.B  223.1
0848C:  BRA     848A
0848E:  MOV     W0,224
08490:  MOV     #3D,W0
08492:  CPSGT   W1,W0
08494:  BRA     8480
....................       } 
08496:  GOTO    858C
....................       else if (p.properties_status != FS_GET_PROPERTIES_NO_ERRORS) 
0849A:  CP0.B   FCF
0849C:  BRA     Z,84BA
....................       { 
....................          printf("\r\n\nError getting info"); 
0849E:  MOV     #0,W1
084A0:  MOV     W1,W0
084A2:  CLR.B   1
084A4:  CALL    83E
084A8:  INC     W1,W1
084AA:  BTSC.B  223.1
084AC:  BRA     84AA
084AE:  MOV     W0,224
084B0:  MOV     #14,W0
084B2:  CPSGT   W1,W0
084B4:  BRA     84A0
....................       } 
084B6:  GOTO    858C
....................       else 
....................       { 
....................          printf("\r\n\nBytes per sector: %LU", p.results.sector_size); 
084BA:  MOV     #0,W1
084BC:  MOV     W1,W0
084BE:  CLR.B   1
084C0:  CALL    860
084C4:  INC     W1,W1
084C6:  BTSC.B  223.1
084C8:  BRA     84C6
084CA:  MOV     W0,224
084CC:  MOV     #14,W0
084CE:  CPSGT   W1,W0
084D0:  BRA     84BC
084D2:  MOV     FD2,W0
084D4:  MOV     #0,W4
084D6:  CALL    23D6
....................          printf("\r\nSectors per cluster: %U", p.results.sectors_per_cluster); 
084DA:  MOV     #0,W1
084DC:  MOV     W1,W0
084DE:  CLR.B   1
084E0:  CALL    886
084E4:  INC     W1,W1
084E6:  BTSC.B  223.1
084E8:  BRA     84E6
084EA:  MOV     W0,224
084EC:  MOV     #16,W0
084EE:  CPSGT   W1,W0
084F0:  BRA     84DC
084F2:  MOV.B   FD4,W0L
084F4:  CLR.B   1
084F6:  MOV     #0,W4
084F8:  CALL    23D6
....................          printf("\r\nTotal size of media: %LU", p.results.total_clusters*p.results.sectors_per_cluster*p.results.sector_size); 
084FC:  MOV.B   FD4,W0L
084FE:  MOV.B   W0L,4
08500:  CLR.B   5
08502:  MOV     #0,W3
08504:  MOV     FD6,W0
08506:  MOV     FD8,W1
08508:  CALL    10CE
0850C:  MOV     W0,W5
0850E:  MOV     W1,W6
08510:  MOV     W5,W0
08512:  MOV     W6,W1
08514:  MOV     FD2,W2
08516:  MOV     #0,W3
08518:  CALL    10CE
0851C:  MOV     W0,W5
0851E:  MOV     W1,W6
08520:  MOV     #0,W1
08522:  MOV     W1,W0
08524:  CLR.B   1
08526:  MOV.B   0,W0L
08528:  CALL    8AC
0852C:  INC     W1,W1
0852E:  BTSC.B  223.1
08530:  BRA     852E
08532:  MOV     W0,224
08534:  MOV     #16,W0
08536:  CPSGT   W1,W0
08538:  BRA     8522
0853A:  MOV     W5,W0
0853C:  MOV     W6,W1
0853E:  MOV     #0,W4
08540:  CALL    230E
....................          printf("\r\nFree space of media: %LU", p.results.free_clusters*p.results.sectors_per_cluster*p.results.sector_size); 
08544:  MOV.B   FD4,W0L
08546:  MOV.B   W0L,4
08548:  CLR.B   5
0854A:  MOV     #0,W3
0854C:  MOV     FDA,W0
0854E:  MOV     FDC,W1
08550:  CALL    10CE
08554:  MOV     W0,W5
08556:  MOV     W1,W6
08558:  MOV     W5,W0
0855A:  MOV     W6,W1
0855C:  MOV     FD2,W2
0855E:  MOV     #0,W3
08560:  CALL    10CE
08564:  MOV     W0,W5
08566:  MOV     W1,W6
08568:  MOV     #0,W1
0856A:  MOV     W1,W0
0856C:  CLR.B   1
0856E:  MOV.B   0,W0L
08570:  CALL    8D4
08574:  INC     W1,W1
08576:  BTSC.B  223.1
08578:  BRA     8576
0857A:  MOV     W0,224
0857C:  MOV     #16,W0
0857E:  CPSGT   W1,W0
08580:  BRA     856A
08582:  MOV     W5,W0
08584:  MOV     W6,W1
08586:  MOV     #0,W4
08588:  CALL    230E
....................       } 
....................    } 
0858C:  GOTO    85A8
....................    else 
....................    { 
....................       printf("\r\nMedia not mounted, not getting info!"); 
08590:  MOV     #0,W1
08592:  MOV     W1,W0
08594:  CLR.B   1
08596:  CALL    8FC
0859A:  INC     W1,W1
0859C:  BTSC.B  223.1
0859E:  BRA     859C
085A0:  MOV     W0,224
085A2:  MOV     #25,W0
085A4:  CPSGT   W1,W0
085A6:  BRA     8592
....................    } 
085A8:  MOV     [--W15],W6
085AA:  MOV     [--W15],W5
085AC:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Shows a help prompt. 
.................... Param: None. 
.................... Returns: None. 
.................... Example Usage: /> help 
.................... */ 
.................... void ShowHelp() 
.................... { 
....................    printf("\r\nFAT Shell Help - Compiled with CCS C Compiler "); 
*
07F70:  MOV     #0,W1
07F72:  MOV     W1,W0
07F74:  CLR.B   1
07F76:  CALL    930
07F7A:  INC     W1,W1
07F7C:  BTSC.B  223.1
07F7E:  BRA     7F7C
07F80:  MOV     W0,224
07F82:  MOV     #2F,W0
07F84:  CPSGT   W1,W0
07F86:  BRA     7F72
....................   #if defined(__PCD__) 
....................    printf("PCD "); 
07F88:  MOV     #0,W1
07F8A:  MOV     W1,W0
07F8C:  CLR.B   1
07F8E:  CALL    96E
07F92:  INC     W1,W1
07F94:  BTSC.B  223.1
07F96:  BRA     7F94
07F98:  MOV     W0,224
07F9A:  MOV     #3,W0
07F9C:  CPSGT   W1,W0
07F9E:  BRA     7F8A
....................    printf(__PCD__); 
07FA0:  MOV     #0,W1
07FA2:  MOV     W1,W0
07FA4:  CLR.B   1
07FA6:  CALL    980
07FAA:  INC     W1,W1
07FAC:  BTSC.B  223.1
07FAE:  BRA     7FAC
07FB0:  MOV     W0,224
07FB2:  MOV     #4,W0
07FB4:  CPSGT   W1,W0
07FB6:  BRA     7FA2
....................   #else 
....................    printf("PCH "); 
....................    printf(__PCH__); 
....................   #endif 
....................    printf("\r\n mount --- initialize and mount file system.  required before file access"); 
07FB8:  MOV     #0,W1
07FBA:  MOV     W1,W0
07FBC:  CLR.B   1
07FBE:  CALL    992
07FC2:  INC     W1,W1
07FC4:  BTSC.B  223.1
07FC6:  BRA     7FC4
07FC8:  MOV     W0,224
07FCA:  MOV     #4A,W0
07FCC:  CPSGT   W1,W0
07FCE:  BRA     7FBA
....................    printf("\r\n del filename --- Deletes the file"); 
07FD0:  MOV     #0,W1
07FD2:  MOV     W1,W0
07FD4:  CLR.B   1
07FD6:  CALL    9E2
07FDA:  INC     W1,W1
07FDC:  BTSC.B  223.1
07FDE:  BRA     7FDC
07FE0:  MOV     W0,224
07FE2:  MOV     #23,W0
07FE4:  CPSGT   W1,W0
07FE6:  BRA     7FD2
....................    printf("\r\n make filename --- Creates an empty file"); 
07FE8:  MOV     #0,W1
07FEA:  MOV     W1,W0
07FEC:  CLR.B   1
07FEE:  CALL    A14
07FF2:  INC     W1,W1
07FF4:  BTSC.B  223.1
07FF6:  BRA     7FF4
07FF8:  MOV     W0,224
07FFA:  MOV     #29,W0
07FFC:  CPSGT   W1,W0
07FFE:  BRA     7FEA
....................    printf("\r\n append filename string --- Appends string to the end of the file"); 
08000:  MOV     #0,W1
08002:  MOV     W1,W0
08004:  CLR.B   1
08006:  CALL    A4E
0800A:  INC     W1,W1
0800C:  BTSC.B  223.1
0800E:  BRA     800C
08010:  MOV     W0,224
08012:  MOV     #42,W0
08014:  CPSGT   W1,W0
08016:  BRA     8002
....................    printf("\r\n cd dir --- Change the working directory"); 
08018:  MOV     #0,W1
0801A:  MOV     W1,W0
0801C:  CLR.B   1
0801E:  CALL    A98
08022:  INC     W1,W1
08024:  BTSC.B  223.1
08026:  BRA     8024
08028:  MOV     W0,224
0802A:  MOV     #29,W0
0802C:  CPSGT   W1,W0
0802E:  BRA     801A
....................    printf("\r\n dir --- Shows the contents of the directory"); 
08030:  MOV     #0,W1
08032:  MOV     W1,W0
08034:  CLR.B   1
08036:  CALL    AD2
0803A:  INC     W1,W1
0803C:  BTSC.B  223.1
0803E:  BRA     803C
08040:  MOV     W0,224
08042:  MOV     #2D,W0
08044:  CPSGT   W1,W0
08046:  BRA     8032
....................    printf("\r\n cat filename --- Displays content of file"); 
08048:  MOV     #0,W1
0804A:  MOV     W1,W0
0804C:  CLR.B   1
0804E:  CALL    B0E
08052:  INC     W1,W1
08054:  BTSC.B  223.1
08056:  BRA     8054
08058:  MOV     W0,224
0805A:  MOV     #2B,W0
0805C:  CPSGT   W1,W0
0805E:  BRA     804A
....................    printf("\r\n tail filename --- Displays the last 80 characters of file"); 
08060:  MOV     #0,W1
08062:  MOV     W1,W0
08064:  CLR.B   1
08066:  CALL    B48
0806A:  INC     W1,W1
0806C:  BTSC.B  223.1
0806E:  BRA     806C
08070:  MOV     W0,224
08072:  MOV     #3B,W0
08074:  CPSGT   W1,W0
08076:  BRA     8062
....................    printf("\r\n mkdir dir --- Create a directory"); 
08078:  MOV     #0,W1
0807A:  MOV     W1,W0
0807C:  CLR.B   1
0807E:  CALL    B8E
08082:  INC     W1,W1
08084:  BTSC.B  223.1
08086:  BRA     8084
08088:  MOV     W0,224
0808A:  MOV     #22,W0
0808C:  CPSGT   W1,W0
0808E:  BRA     807A
....................    printf("\r\n rmdir dir --- Deletes the directory"); 
08090:  MOV     #0,W1
08092:  MOV     W1,W0
08094:  CLR.B   1
08096:  CALL    BBE
0809A:  INC     W1,W1
0809C:  BTSC.B  223.1
0809E:  BRA     809C
080A0:  MOV     W0,224
080A2:  MOV     #25,W0
080A4:  CPSGT   W1,W0
080A6:  BRA     8092
....................    printf("\r\n format size --- Format card.  (Example: 'format 536870912' -or- 'format 512M' "); 
080A8:  MOV     #0,W1
080AA:  MOV     W1,W0
080AC:  CLR.B   1
080AE:  CALL    BF2
080B2:  INC     W1,W1
080B4:  BTSC.B  223.1
080B6:  BRA     80B4
080B8:  MOV     W0,224
080BA:  MOV     #50,W0
080BC:  CPSGT   W1,W0
080BE:  BRA     80AA
....................    printf("\r\n                 formats a 512MB card).  Creates MBR and Partition 0.  This is "); 
080C0:  MOV     #0,W1
080C2:  MOV     W1,W0
080C4:  CLR.B   1
080C6:  CALL    C46
080CA:  INC     W1,W1
080CC:  BTSC.B  223.1
080CE:  BRA     80CC
080D0:  MOV     W0,224
080D2:  MOV     #50,W0
080D4:  CPSGT   W1,W0
080D6:  BRA     80C2
....................    printf("\r\n                 not recommended on devices which you can use a computer to"); 
080D8:  MOV     #0,W1
080DA:  MOV     W1,W0
080DC:  CLR.B   1
080DE:  CALL    C9A
080E2:  INC     W1,W1
080E4:  BTSC.B  223.1
080E6:  BRA     80E4
080E8:  MOV     W0,224
080EA:  MOV     #4C,W0
080EC:  CPSGT   W1,W0
080EE:  BRA     80DA
....................    printf("\r\n                 format the drive (such as an SD or CF device)."); 
080F0:  MOV     #0,W1
080F2:  MOV     W1,W0
080F4:  CLR.B   1
080F6:  CALL    CEA
080FA:  INC     W1,W1
080FC:  BTSC.B  223.1
080FE:  BRA     80FC
08100:  MOV     W0,224
08102:  MOV     #40,W0
08104:  CPSGT   W1,W0
08106:  BRA     80F2
....................    printf("\r\n info --- Show some info about the media/file system.  Can take several seconds!"); 
08108:  MOV     #0,W1
0810A:  MOV     W1,W0
0810C:  CLR.B   1
0810E:  CALL    D32
08112:  INC     W1,W1
08114:  BTSC.B  223.1
08116:  BRA     8114
08118:  MOV     W0,224
0811A:  MOV     #51,W0
0811C:  CPSGT   W1,W0
0811E:  BRA     810A
....................    printf("\r\n help\tYou are here"); 
08120:  MOV     #0,W1
08122:  MOV     W1,W0
08124:  CLR.B   1
08126:  CALL    D86
0812A:  INC     W1,W1
0812C:  BTSC.B  223.1
0812E:  BRA     812C
08130:  MOV     W0,224
08132:  MOV     #13,W0
08134:  CPSGT   W1,W0
08136:  BRA     8122
....................    printf("\r\n\n Put a parameter in quotes if it has spaces"); 
08138:  MOV     #0,W1
0813A:  MOV     W1,W0
0813C:  CLR.B   1
0813E:  CALL    DA8
08142:  INC     W1,W1
08144:  BTSC.B  223.1
08146:  BRA     8144
08148:  MOV     W0,224
0814A:  MOV     #2D,W0
0814C:  CPSGT   W1,W0
0814E:  BRA     813A
....................  
....................    DEBUG_STR("SPICON1", SPICON1); 
....................    DEBUG_STR("SPISTAT", SPISTAT); 
08150:  RETURN  
.................... } 
....................  
.................... char * GetCMD(char *in) 
.................... { 
....................    char tokens[]=" \r\n"; 
*
05B72:  MOV     #D20,W4
05B74:  MOV     W4,FCE
05B76:  MOV     #A,W4
05B78:  MOV     W4,FD0
....................    return(strtok(in,tokens)); 
05B7A:  PUSH    FCC
05B7C:  POP     FDC
05B7E:  MOV     #FCE,W4
05B80:  MOV     W4,FDE
05B82:  CALL    5B12
05B86:  MOV     W0,0
05B88:  RETURN  
.................... } 
....................  
.................... char * GetOption(char *in) 
05B8A:  MOV     W5,[W15++]
.................... { 
....................    char tokensSpace[]=" \r\n"; 
05B8C:  MOV     #D20,W4
05B8E:  MOV     W4,FD2
05B90:  MOV     #A,W4
05B92:  MOV     W4,FD4
....................    char tokensQuote[]="\"\r\n"; 
05B94:  MOV     #D22,W4
05B96:  MOV     W4,FD6
05B98:  MOV     #A,W4
05B9A:  MOV     W4,FD8
....................  
....................    //trim leading spaces 
....................    while (*in==' ') 
05B9C:  MOV     FD0,W0
05B9E:  MOV.B   [W0],W4L
05BA0:  XOR.B   #20,W4L
05BA2:  BRA     NZ,5BAA
....................       in++; 
05BA4:  INC     0FD0
05BA6:  GOTO    5B9C
....................  
....................    //if first char is a quote, then end token on a quote.  ELSE end token on a space 
....................    if (*in == '\"') 
05BAA:  MOV     FD0,W0
05BAC:  MOV.B   [W0],W4L
05BAE:  XOR.B   #22,W4L
05BB0:  BRA     NZ,5BC6
....................       return(strtok(in,tokensQuote)); 
05BB2:  PUSH    FD0
05BB4:  POP     FDC
05BB6:  MOV     #FD6,W4
05BB8:  MOV     W4,FDE
05BBA:  CALL    5B12
05BBE:  MOV     W0,0
05BC0:  BRA     5BD6
05BC2:  GOTO    5BD6
....................    else 
....................       return(strtok(in,tokensSpace)); 
05BC6:  PUSH    FD0
05BC8:  POP     FDC
05BCA:  MOV     #FD2,W4
05BCC:  MOV     W4,FDE
05BCE:  CALL    5B12
05BD2:  MOV     W0,0
05BD4:  BRA     5BD6
05BD6:  MOV     [--W15],W5
05BD8:  RETURN  
.................... } 
....................  
.................... void main(void) 
*
085AE:  MOV     #47A0,W15
085B0:  MOV     #47FF,W0
085B2:  MOV     W0,20
085B4:  NOP     
085B6:  BSET.B  81.7
085B8:  MOV     #46,W0
085BA:  MOV.B   W0L,742
085BC:  MOV     #57,W0
085BE:  MOV.B   W0L,742
085C0:  BCLR.B  742.6
085C2:  MOV     #3F19,W0
085C4:  MOV     W0,6A4
085C6:  MOV     #3F2D,W0
085C8:  MOV     W0,6A8
085CA:  MOV     #8,W0
085CC:  MOV     W0,6D0
085CE:  MOV     #3,W0
085D0:  MOV     W0,6D4
085D2:  MOV     #7,W0
085D4:  MOV     W0,6DE
085D6:  MOV     #46,W0
085D8:  MOV.B   W0L,742
085DA:  MOV     #57,W0
085DC:  MOV.B   W0L,742
085DE:  BSET.B  742.6
085E0:  BSET.B  44.2
085E2:  MOV     #4,W0
085E4:  MOV     W0,34
085E6:  MOV     #85A,W0
085E8:  MOV     #1FD1,W1
085EA:  REPEAT  W1
085EC:  CLR     [W0++]
085EE:  CLR     744
085F0:  MOV     #8000,W4
085F2:  MOV     W4,220
085F4:  MOV     #400,W4
085F6:  MOV     W4,222
085F8:  BSET.B  220.3
085FA:  MOV     #1A0,W4
085FC:  MOV     W4,228
085FE:  BCLR.B  85A.1
08600:  SETM    8A4
08602:  SETM    8A6
08604:  CLR.B   899
08606:  CLR     8A8
08608:  SETM    8AA
0860A:  SETM    8AC
0860C:  CLR.B   8AE
0860E:  CLR.B   8AF
08610:  CLR.B   8B0
08612:  CLR.B   8BB
08614:  MOV     #928,W4
08616:  MOV     W4,95E
08618:  BCLR.B  85A.3
0861A:  CLR     EA8
0861C:  SETM    32C
0861E:  BRA     86D2
08620:  DATA    80,01,08
08622:  DATA    5A,00,80
08624:  DATA    02,08,5C
08626:  DATA    00,00,80
08628:  DATA    01,0D,A7
0862A:  DATA    00,80,01
0862C:  DATA    0D,AD,00
0862E:  DATA    80,4E,0D
08630:  DATA    BC,00,95
08632:  DATA    00,00,01
08634:  DATA    F9,00,00
08636:  DATA    08,87,04
08638:  DATA    00,09,AF
0863A:  DATA    00,01,0A
0863C:  DATA    1B,00,01
0863E:  DATA    0C,C3,01
08640:  DATA    00,0D,AF
08642:  DATA    02,00,10
08644:  DATA    FF,00,00
08646:  DATA    11,FF,00
08648:  DATA    01,12,FF
0864A:  DATA    00,01,18
0864C:  DATA    FF,00,01
0864E:  DATA    19,FF,00
08650:  DATA    01,20,FF
08652:  DATA    00,00,21
08654:  DATA    FF,00,00
08656:  DATA    26,DF,01
08658:  DATA    00,37,73
0865A:  DATA    00,00,3A
0865C:  DATA    25,04,00
0865E:  DATA    3B,25,00
08660:  DATA    00,29,FF
08662:  DATA    04,00,17
08664:  DATA    FF,40,1C
08666:  DATA    00,00,03
08668:  DATA    64,65,6C
0866A:  DATA    40,07,00
0866C:  DATA    00,04,6D
0866E:  DATA    61,6B,65
08670:  DATA    40,06,00
08672:  DATA    00,06,61
08674:  DATA    70,70,65
08676:  DATA    6E,64,40
08678:  DATA    04,00,00
0867A:  DATA    02,63,64
0867C:  DATA    40,08,00
0867E:  DATA    00,03,64
08680:  DATA    69,72,40
08682:  DATA    07,00,00
08684:  DATA    03,63,61
08686:  DATA    74,40,07
08688:  DATA    00,00,04
0868A:  DATA    74,61,69
0868C:  DATA    6C,40,06
0868E:  DATA    00,00,05
08690:  DATA    6D,6B,64
08692:  DATA    69,72,40
08694:  DATA    05,00,00
08696:  DATA    05,72,6D
08698:  DATA    64,69,72
0869A:  DATA    40,05,00
0869C:  DATA    00,06,66
0869E:  DATA    6F,72,6D
086A0:  DATA    61,74,40
086A2:  DATA    04,00,00
086A4:  DATA    04,68,65
086A6:  DATA    6C,70,40
086A8:  DATA    06,00,00
086AA:  DATA    05,6D,6F
086AC:  DATA    75,6E,74
086AE:  DATA    40,05,00
086B0:  DATA    00,05,69
086B2:  DATA    6E,66,6F
086B4:  DATA    00,00,00
086B6:  INC     W2,W2
086B8:  CP      W2,#1
086BA:  BRA     NZ,86C4
086BC:  TBLRDL  [W1],W3
086BE:  TBLRDH  [W1++],W4
086C0:  MOV.B   6,W0L
086C2:  RETURN  
086C4:  CP      W2,#2
086C6:  BRA     NZ,86CC
086C8:  MOV.B   7,W0L
086CA:  RETURN  
086CC:  MOV.B   8,W0L
086CE:  CLR     W2
086D0:  RETURN  
086D2:  MOV     #0,W6
086D4:  MOV     #0,W0
086D6:  MOV     W0,32
086D8:  MOV     #8620,W0
086DA:  MOV     W0,W1
086DC:  CLR     W2
086DE:  CALL    86B6
086E2:  MOV.B   W0L,B
086E4:  CALL    86B6
086E8:  MOV.B   W0L,A
086EA:  CP0     W5
086EC:  BRA     Z,8720
086EE:  BTSS    W5.F
086F0:  BRA     8700
086F2:  CALL    86B6
086F6:  MOV.B   W0L,D
086F8:  CALL    86B6
086FC:  MOV.B   W0L,C
086FE:  BCLR    W5.F
08700:  BTSS    W5.E
08702:  BRA     8714
08704:  BCLR    W5.E
08706:  DEC     W5,W5
08708:  CALL    86B6
0870C:  MOV.B   W0L,W7L
0870E:  REPEAT  W5
08710:  MOV.B   W7L,[W6++]
08712:  BRA     86DE
08714:  CALL    86B6
08718:  MOV.B   W0L,[W6++]
0871A:  DEC     W5,W5
0871C:  BRA     NZ,8714
0871E:  BRA     86DE
.................... { 
....................    char buffer[255]; 
08720:  CLR     EAA
08722:  CLR     EAC
08724:  CLR     EAE
08726:  CLR     EB0
08728:  CLR     EB2
0872A:  CLR     EB4
0872C:  CLR     EB6
0872E:  CLR     EB8
08730:  CLR     EBA
08732:  CLR     EBC
08734:  CLR     EBE
08736:  CLR     EC0
08738:  CLR     EC2
0873A:  CLR     EC4
0873C:  CLR     EC6
0873E:  CLR     EC8
08740:  CLR     ECA
08742:  CLR     ECC
08744:  CLR     ECE
08746:  CLR     ED0
08748:  CLR     ED2
0874A:  CLR     ED4
0874C:  CLR     ED6
0874E:  CLR     ED8
08750:  CLR     EDA
08752:  CLR     EDC
08754:  CLR     EDE
08756:  CLR     EE0
08758:  CLR     EE2
0875A:  CLR     EE4
0875C:  CLR     EE6
0875E:  CLR     EE8
08760:  CLR     EEA
08762:  CLR     EEC
08764:  CLR     EEE
08766:  CLR     EF0
08768:  CLR     EF2
0876A:  CLR     EF4
0876C:  CLR     EF6
0876E:  CLR     EF8
08770:  CLR     EFA
08772:  CLR     EFC
08774:  CLR     EFE
08776:  CLR     F00
08778:  CLR     F02
0877A:  CLR     F04
0877C:  CLR     F06
0877E:  CLR     F08
08780:  CLR     F0A
08782:  CLR     F0C
08784:  CLR     F0E
08786:  CLR     F10
08788:  CLR     F12
0878A:  CLR     F14
0878C:  CLR     F16
0878E:  CLR     F18
08790:  CLR     F1A
08792:  CLR     F1C
08794:  CLR     F1E
08796:  CLR     F20
08798:  CLR     F22
0879A:  CLR     F24
0879C:  CLR     F26
0879E:  CLR     F28
087A0:  CLR     F2A
087A2:  CLR     F2C
087A4:  CLR     F2E
087A6:  CLR     F30
087A8:  CLR     F32
087AA:  CLR     F34
087AC:  CLR     F36
087AE:  CLR     F38
087B0:  CLR     F3A
087B2:  CLR     F3C
087B4:  CLR     F3E
087B6:  CLR     F40
087B8:  CLR     F42
087BA:  CLR     F44
087BC:  CLR     F46
087BE:  CLR     F48
087C0:  CLR     F4A
087C2:  CLR     F4C
087C4:  CLR     F4E
087C6:  CLR     F50
087C8:  CLR     F52
087CA:  CLR     F54
087CC:  CLR     F56
087CE:  CLR     F58
087D0:  CLR     F5A
087D2:  CLR     F5C
087D4:  CLR     F5E
087D6:  CLR     F60
087D8:  CLR     F62
087DA:  CLR     F64
087DC:  CLR     F66
087DE:  CLR     F68
087E0:  CLR     F6A
087E2:  CLR     F6C
087E4:  CLR     F6E
087E6:  CLR     F70
087E8:  CLR     F72
087EA:  CLR     F74
087EC:  CLR     F76
087EE:  CLR     F78
087F0:  CLR     F7A
087F2:  CLR     F7C
087F4:  CLR     F7E
087F6:  CLR     F80
087F8:  CLR     F82
087FA:  CLR     F84
087FC:  CLR     F86
087FE:  CLR     F88
08800:  CLR     F8A
08802:  CLR     F8C
08804:  CLR     F8E
08806:  CLR     F90
08808:  CLR     F92
0880A:  CLR     F94
0880C:  CLR     F96
0880E:  CLR     F98
08810:  CLR     F9A
08812:  CLR     F9C
08814:  CLR     F9E
08816:  CLR     FA0
08818:  CLR     FA2
0881A:  CLR     FA4
0881C:  CLR     FA6
0881E:  CLR.B   FA8
....................    char *cmd, *option1, *option2; 
08820:  CLR     FAA
08822:  CLR     FAC
08824:  CLR     FAE
....................  
....................    int i;   // pointer to the buffer 
08826:  CLR     FB0
....................  
....................  
....................  
....................  
....................  
....................  //  HW_INIT(); 
....................  
....................  
....................    //printf("\r\n\nex_fat.c - MDD Example"); 
.................... MountMedia(); 
08828:  CALL    2488
....................  
....................             if (!g_IsMounted) 
0882C:  BTSC.B  85A.3
0882E:  BRA     8856
....................             { 
....................                sprintf(buffer, "mount"); 
08830:  MOV     #EAA,W4
08832:  MOV     W4,EA8
08834:  MOV     #0,W1
08836:  MOV     W1,W0
08838:  CLR.B   1
0883A:  CALL    DE4
0883E:  INC     W1,W1
08840:  MOV     W1,[W15++]
08842:  MOV     W0,[W15++]
08844:  MOV     [--W15],W0
08846:  CALL    2592
0884A:  MOV     [--W15],W1
0884C:  MOV     #4,W0
0884E:  CPSGT   W1,W0
08850:  BRA     8836
....................             } 
08852:  GOTO    8878
....................             else 
....................             { 
....................                sprintf(buffer, "append log.txt button pressed!!"); 
08856:  MOV     #EAA,W4
08858:  MOV     W4,EA8
0885A:  MOV     #0,W1
0885C:  MOV     W1,W0
0885E:  CLR.B   1
08860:  CALL    DF6
08864:  INC     W1,W1
08866:  MOV     W1,[W15++]
08868:  MOV     W0,[W15++]
0886A:  MOV     [--W15],W0
0886C:  CALL    2592
08870:  MOV     [--W15],W1
08872:  MOV     #1E,W0
08874:  CPSGT   W1,W0
08876:  BRA     885C
....................             } 
....................  
....................  
....................    // main loop 
....................  
....................  
.................... //option1 = GetOption(cmd + strlen(cmd) + 1); 
.................... //MakeFile("testfile.txt"); 
....................  
.................... AppendFile("testfile.txt", "Hello World"); 
08878:  MOV     #D,W3
0887A:  MOV     #0,W2
0887C:  MOV     #FB2,W1
0887E:  MOV     W3,[W15++]
08880:  MOV     W2,W0
08882:  CALL    E22
08886:  MOV     [--W15],W3
08888:  MOV.B   W0L,[W1++]
0888A:  INC     W2,W2
0888C:  DEC     W3,W3
0888E:  BTSS.B  42.1
08890:  BRA     887E
08892:  MOV     #C,W3
08894:  MOV     #0,W2
08896:  MOV     #FBF,W1
08898:  MOV     W3,[W15++]
0889A:  MOV     W2,W0
0889C:  CALL    E3C
088A0:  MOV     [--W15],W3
088A2:  MOV.B   W0L,[W1++]
088A4:  INC     W2,W2
088A6:  DEC     W3,W3
088A8:  BTSS.B  42.1
088AA:  BRA     8898
088AC:  MOV     #FB2,W4
088AE:  MOV     W4,FCC
088B0:  MOV     #FBF,W4
088B2:  MOV     W4,FCE
088B4:  CALL    5274
....................  
....................  
....................  
....................  
....................  
....................    for(;;) 
....................    { 
....................       i = 0; 
088B8:  CLR     FB0
....................  
....................       DisplayPrompt(); 
088BA:  CALL    59A4
....................  
....................   /*    for(;;) 
....................       { 
....................         #if 1 
....................          if (BUTTON_PRESSED()) 
....................          { 
....................             while(BUTTON_PRESSED()); 
....................             delay_ms(150); 
....................             if (!g_IsMounted) 
....................             { 
....................                sprintf(buffer, "mount"); 
....................             } 
....................             else 
....................             { 
....................                sprintf(buffer, "append log.txt button pressed!!"); 
....................             } 
....................             break; 
....................          } 
....................         #endif 
.................... */ 
....................          if (kbhit()) 
088BE:  BTSS.B  222.0
088C0:  BRA     8938
....................          { 
....................             buffer[i] = getch(); 
088C2:  MOV     #EAA,W4
088C4:  MOV     FB0,W3
088C6:  ADD     W3,W4,W5
088C8:  BTSS.B  222.0
088CA:  BRA     88C8
088CC:  MOV     226,W0
088CE:  MOV.B   W0L,[W5]
....................  
....................             // check for a backspace 
....................             if(buffer[i] != 8) 
088D0:  MOV     #EAA,W4
088D2:  MOV     FB0,W3
088D4:  ADD     W3,W4,W0
088D6:  MOV.B   [W0],W5L
088D8:  SE      W5,W5
088DA:  CP      W5,#8
088DC:  BRA     Z,88F8
....................             { 
....................                printf("%c", buffer[i]); 
088DE:  MOV     #EAA,W4
088E0:  MOV     FB0,W3
088E2:  ADD     W3,W4,W0
088E4:  MOV.B   [W0],W5L
088E6:  BTSC.B  223.1
088E8:  BRA     88E6
088EA:  PUSH    224
088EC:  MOV.B   W5L,[W15-#2]
088EE:  POP     224
088F0:  CLR.B   225
....................                i++; 
088F2:  INC     0FB0
....................             } 
088F4:  GOTO    891E
....................             else if(i > 0) 
088F8:  MOV     FB0,W4
088FA:  CP      W4,#0
088FC:  BRA     LE,891E
....................             { 
....................                // delete the last character 
....................                i--; 
088FE:  DEC     0FB0
....................                putc(8); 
08900:  MOV.B   #8,W0L
08902:  BTSC.B  223.1
08904:  BRA     8902
08906:  MOV.B   W0L,224
08908:  CLR.B   225
....................                putc(' '); 
0890A:  MOV.B   #20,W0L
0890C:  BTSC.B  223.1
0890E:  BRA     890C
08910:  MOV.B   W0L,224
08912:  CLR.B   225
....................                putc(8); 
08914:  MOV.B   #8,W0L
08916:  BTSC.B  223.1
08918:  BRA     8916
0891A:  MOV.B   W0L,224
0891C:  CLR.B   225
....................             } 
....................             buffer[i] = '\0'; 
0891E:  MOV     #EAA,W4
08920:  MOV     FB0,W3
08922:  ADD     W3,W4,W5
08924:  CLR.B   [W5]
....................             if (buffer[i - 1] == '\r') 
08926:  MOV     FB0,W4
08928:  SUB     W4,#1,W5
0892A:  MOV     #EAA,W4
0892C:  ADD     W5,W4,W0
0892E:  MOV.B   [W0],W4L
08930:  CP.B    W4L,#D
08932:  BRA     NZ,8938
....................                break; 
08934:  GOTO    893C
....................          } 
08938:  GOTO    88B8
....................       } 
....................  
....................       // parse the command and options 
....................       cmd = GetCMD(buffer); 
0893C:  MOV     #EAA,W4
0893E:  MOV     W4,FCC
08940:  CALL    5B72
08944:  MOV     W0,FAA
....................       option1 = GetOption(cmd + strlen(cmd) + 1); 
08946:  PUSH    FAA
08948:  POP     1090
0894A:  CALL    25A8
0894E:  MOV     FAA,W4
08950:  ADD     W0,W4,W5
08952:  ADD     W5,#1,W5
08954:  MOV     W5,FD0
08956:  CALL    5B8A
0895A:  MOV     W0,FAC
....................       option2 = GetOption(option1 + strlen(option1) + 1); 
0895C:  PUSH    FAC
0895E:  POP     1090
08960:  CALL    25A8
08964:  MOV     FAC,W4
08966:  ADD     W0,W4,W5
08968:  ADD     W5,#1,W5
0896A:  MOV     W5,FD0
0896C:  CALL    5B8A
08970:  MOV     W0,FAE
....................  
....................       if (cmd) 
08972:  CP0     FAA
08974:  BRA     Z,8A92
....................       { 
....................          switch(FindCommand(cmd)) 
08976:  PUSH    FAA
08978:  POP     FCC
0897A:  CALL    5C80
0897E:  XOR     #0,W0
08980:  BRA     Z,89B4
08982:  XOR     #1,W0
08984:  BRA     Z,89C0
08986:  XOR     #3,W0
08988:  BRA     Z,89CC
0898A:  XOR     #1,W0
0898C:  BRA     Z,89DC
0898E:  XOR     #7,W0
08990:  BRA     Z,89E8
08992:  XOR     #1,W0
08994:  BRA     Z,89F0
08996:  XOR     #3,W0
08998:  BRA     Z,89FE
0899A:  XOR     #1,W0
0899C:  BRA     Z,8A0E
0899E:  XOR     #F,W0
089A0:  BRA     Z,8A1A
089A2:  XOR     #1,W0
089A4:  BRA     Z,8A26
089A6:  XOR     #3,W0
089A8:  BRA     Z,8A32
089AA:  XOR     #1,W0
089AC:  BRA     Z,8A3A
089AE:  XOR     #7,W0
089B0:  BRA     Z,8A42
089B2:  BRA     8A4A
....................          { 
....................             case 0:  //del 
....................                DeleteFile(option1); 
089B4:  PUSH    FAC
089B6:  POP     FCC
089B8:  CALL    5DE0
....................                break; 
089BC:  GOTO    8A92
....................  
....................             case 1:  //make 
....................                MakeFile(option1); 
089C0:  PUSH    FAC
089C2:  POP     FCC
089C4:  CALL    5E7A
....................                break; 
089C8:  GOTO    8A92
....................  
....................             case 2:  //append 
....................                AppendFile(option1, option2); 
089CC:  PUSH    FAC
089CE:  POP     FCC
089D0:  PUSH    FAE
089D2:  POP     FCE
089D4:  CALL    5274
....................                break; 
089D8:  GOTO    8A92
....................  
....................             case 3:  //change directory 
....................                ChangeDirectory(option1); 
089DC:  PUSH    FAC
089DE:  POP     FCC
089E0:  CALL    651A
....................                break; 
089E4:  GOTO    8A92
....................  
....................             case 4:  //show directory contents 
....................                DisplayDirectory(); 
089E8:  CALL    6AC8
....................                break; 
089EC:  GOTO    8A92
....................  
....................             case 5:  //cat, display file 
....................                PrintFile(option1, CAT_FROM_START); 
089F0:  CLR.B   FCE
089F2:  PUSH    FAC
089F4:  POP     FCC
089F6:  CALL    6E9A
....................                break; 
089FA:  GOTO    8A92
....................  
....................             case 6:  //tail, display last 80 charachters 
....................                PrintFile(option1, CAT_FROM_END); 
089FE:  MOV.B   #1,W0L
08A00:  MOV.B   W0L,FCE
08A02:  PUSH    FAC
08A04:  POP     FCC
08A06:  CALL    6E9A
....................                break; 
08A0A:  GOTO    8A92
....................  
....................             case 7: //mkdir, make a directory 
....................                MakeDirectory(option1); 
08A0E:  PUSH    FAC
08A10:  POP     FCC
08A12:  CALL    7688
....................                break; 
08A16:  GOTO    8A92
....................  
....................             case 8: //rmdir, make a directory 
....................                RemoveDirectory(option1); 
08A1A:  PUSH    FAC
08A1C:  POP     FCC
08A1E:  CALL    7EBA
....................                break; 
08A22:  GOTO    8A92
....................  
....................             case 9: //format, format the card 
....................                FormatMedia(option1); 
08A26:  PUSH    FAC
08A28:  POP     FCC
08A2A:  CALL    7F56
....................                break; 
08A2E:  GOTO    8A92
....................  
....................             case 10: //help, display help 
....................                ShowHelp(); 
08A32:  CALL    7F70
....................                break; 
08A36:  GOTO    8A92
....................  
....................             case 11: //mount 
....................                MountMedia(); 
08A3A:  CALL    2488
....................                break; 
08A3E:  GOTO    8A92
....................  
....................             case 12: //info 
....................                MediaInfo(); 
08A42:  CALL    8422
....................                break; 
08A46:  GOTO    8A92
....................  
....................             default: 
....................                printf("\r\nUnknown Command '%s', use 'help' to get list of commands", cmd); 
08A4A:  MOV     #0,W1
08A4C:  MOV     W1,W0
08A4E:  CLR.B   1
08A50:  CALL    E54
08A54:  INC     W1,W1
08A56:  BTSC.B  223.1
08A58:  BRA     8A56
08A5A:  MOV     W0,224
08A5C:  MOV     #12,W0
08A5E:  CPSGT   W1,W0
08A60:  BRA     8A4C
08A62:  MOV     FAA,W1
08A64:  CP0.B   [W1]
08A66:  BRA     Z,8A76
08A68:  BTSC.B  223.1
08A6A:  BRA     8A68
08A6C:  MOV.B   [W1+#0],W0L
08A6E:  MOV.B   W0L,224
08A70:  CLR.B   225
08A72:  INC     W1,W1
08A74:  BRA     8A64
08A76:  MOV     #15,W1
08A78:  MOV     W1,W0
08A7A:  CLR.B   1
08A7C:  CALL    E54
08A80:  INC     W1,W1
08A82:  BTSC.B  223.1
08A84:  BRA     8A82
08A86:  MOV     W0,224
08A88:  MOV     #39,W0
08A8A:  CPSGT   W1,W0
08A8C:  BRA     8A78
....................                break; 
08A8E:  GOTO    8A92
....................          } 
....................       } 
....................    } 
....................  
08A92:  BRA     8A92
....................  

Configuration Fuses:
   Word  1L: 365F   WPOSTS16 WDT128 WINDIS NOWDT ICSP2 DEBUG NOWRT NOPROTECT NOJTAG
          H: FF00  
   Word  2L: 83F9   XT IOL1WAY NOOSCIO PR_PLL IESO
          H: FF00  
   Word  3L: FFFF   WPFP WPDIS NOWPCFG WPEND
          H: FF00  
   Word  4L: 0000  
          H: FF00  

   Some fuses have been forced to be compatible with the ICD debugger.
