CCS PCD C Compiler, Version 5.032, 17542               12-Mar-15 17:39

               Filename:   F:\Osmobot4PostProduction\SDCard\ex_fat.lst

               ROM used:   35584 bytes (20%)
                           Largest free fragment is 65536
               RAM used:   2037 (12%) at main() level
                           2403 (15%) worst case
               Stack used: 72 locations
               Stack size: 128

*
00000:  GOTO    85BE
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                           fat_ex.c                              //// 
.................... ////                                                                 //// 
.................... ////    This is a neat little shell utility that resembles a DOS or  //// 
.................... //// UNIX type shell in order to manipulate files on the FAT file    //// 
.................... //// system. This is mostly for demonstration purposes on how to use //// 
.................... //// some of the basic functionality of the FAT library.             //// 
.................... ////                                                                 //// 
.................... //// Type 'help' and press enter at the console prompt to get a list //// 
.................... //// of commands.                                                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  Version History:                                               //// 
.................... ////     FEB 14th 2011                                               //// 
.................... ////        * Updated example to use Microchip's MDD library.        //// 
.................... ////        * Code will not automatically init/mount file system.    //// 
.................... ////           'mount' command must be performed to do this.         //// 
.................... ////        * You cannot use path-names when performing file         //// 
.................... ////           actions (cat, tail, append, make, del).  Instead      //// 
.................... ////           you have to be in the proper directory, and file      //// 
.................... ////           actions happen to files in that directory.            //// 
.................... ////        * 'format' command can now have 'k', 'm' or 'g' postfix  //// 
.................... ////           for size (k = 1024, m=1024*1024, etc).                //// 
.................... ////        * 'info' command added.                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... // define this to make it compatible with the ex_boot_ldr.c bootloader. 
.................... // otherwise don't define this. 
.................... //#define __USE_MDD_BOOTLOADER__ 
.................... #define MEDIA_SOFT_DETECT    //This means it uses talking to the card to see if there is a card present 
.................... //#define __DEBUG_UART 
....................  
.................... #define ALLOW_GET_DISK_PROPERTIES   //used by 'info' command 
....................  
.................... #include "ex_mdd_common.h" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// 
.................... //// ex_mdd_common.h 
.................... //// 
.................... //// Common header file for CCS's MDD examples 
.................... //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //#define HW_CCS_3V_ETHERNET 
.................... //#define HW_CCS_DSP_AUDIO    //dsPIC33FJ 
.................... //#define HW_CCS_DSP_AUDIO2   //dsPIC33EP 
.................... #define HW_CCS_PIC24USB 
....................  
....................  
....................  
.................... #if defined(HW_CCS_PIC24USB) 
....................    #include <24FJ256GA106.h> 
.................... //////////// Standard Header file for the PIC24FJ256GA106 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ256GA106 
*
00200:  CLR     32
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    2E,2E,00
0020E:  DATA    00,00,00
00210:  CLR     32
00212:  MOV     #21C,W3
00214:  ADD     W3,W0,W0
00216:  TBLRDL.B[W0],W0L
00218:  CLR.B   1
0021A:  RETURN  
0021C:  DATA    21,21,00
0021E:  DATA    21,45,00
00220:  DATA    52,52,00
00222:  DATA    4F,52,00
00224:  DATA    21,21,00
00226:  DATA    21,00,00
00228:  CLR     32
0022A:  MOV     #234,W3
0022C:  ADD     W3,W0,W0
0022E:  TBLRDL.B[W0],W0L
00230:  CLR.B   1
00232:  RETURN  
00234:  DATA    21,21,00
00236:  DATA    21,4E,00
00238:  DATA    4F,54,00
0023A:  DATA    20,4D,00
0023C:  DATA    4F,55,00
0023E:  DATA    4E,54,00
00240:  DATA    45,44,00
00242:  DATA    21,21,00
00244:  DATA    21,00,00
00246:  CLR     32
00248:  MOV     #20,W3
0024A:  SUB     W0,W3,W3
0024C:  BRA     C,258
0024E:  MOV     #262,W3
00250:  ADD     W3,W0,W0
00252:  TBLRDL.B[W0],W0L
00254:  CLR.B   1
00256:  RETURN  
00258:  MOV     #262,W0
0025A:  ADD     W3,W3,W3
0025C:  ADD     W3,W0,W3
0025E:  TBLRDH  [W3],W0
00260:  RETURN  
00262:  DATA    0D,0A,6F
00264:  DATA    4D,65,20
00266:  DATA    64,69,64
00268:  DATA    61,20,65
0026A:  DATA    6E,6F,6C
0026C:  DATA    74,20,65
0026E:  DATA    6D,6F,74
00270:  DATA    75,6E,65
00272:  DATA    74,65,20
00274:  DATA    64,2C,66
00276:  DATA    20,6E,69
00278:  DATA    6F,74,6C
0027A:  DATA    20,67,65
0027C:  DATA    6F,69,21
0027E:  DATA    6E,67,00
00280:  DATA    20,74,00
00282:  CLR     32
00284:  MOV     #28E,W3
00286:  ADD     W3,W0,W0
00288:  TBLRDL.B[W0],W0L
0028A:  CLR.B   1
0028C:  RETURN  
0028E:  DATA    0D,0A,00
00290:  DATA    44,65,00
00292:  DATA    6C,65,00
00294:  DATA    74,69,00
00296:  DATA    6E,67,00
00298:  DATA    20,27,00
0029A:  DATA    25,73,00
0029C:  DATA    27,3A,00
0029E:  DATA    20,00,00
002A0:  CLR     32
002A2:  MOV     #2AC,W3
002A4:  ADD     W3,W0,W0
002A6:  TBLRDL.B[W0],W0L
002A8:  CLR.B   1
002AA:  RETURN  
002AC:  DATA    45,72,00
002AE:  DATA    72,6F,00
002B0:  DATA    72,20,00
002B2:  DATA    64,65,00
002B4:  DATA    6C,65,00
002B6:  DATA    74,69,00
002B8:  DATA    6E,67,00
002BA:  DATA    20,66,00
002BC:  DATA    69,6C,00
002BE:  DATA    65,00,00
002C0:  CLR     32
002C2:  MOV     #1E,W3
002C4:  SUB     W0,W3,W3
002C6:  BRA     C,2D2
002C8:  MOV     #2DC,W3
002CA:  ADD     W3,W0,W0
002CC:  TBLRDL.B[W0],W0L
002CE:  CLR.B   1
002D0:  RETURN  
002D2:  MOV     #2DC,W0
002D4:  ADD     W3,W3,W3
002D6:  ADD     W3,W0,W3
002D8:  TBLRDH  [W3],W0
002DA:  RETURN  
002DC:  DATA    0D,0A,20
002DE:  DATA    4D,65,74
002E0:  DATA    64,69,6F
002E2:  DATA    61,20,20
002E4:  DATA    6E,6F,6D
002E6:  DATA    74,20,61
002E8:  DATA    6D,6F,6B
002EA:  DATA    75,6E,65
002EC:  DATA    74,65,20
002EE:  DATA    64,2C,66
002F0:  DATA    20,6E,69
002F2:  DATA    6F,74,6C
002F4:  DATA    20,67,65
002F6:  DATA    6F,69,21
002F8:  DATA    6E,67,00
002FA:  CLR     32
002FC:  MOV     #306,W3
002FE:  ADD     W3,W0,W0
00300:  TBLRDL.B[W0],W0L
00302:  CLR.B   1
00304:  RETURN  
00306:  DATA    77,00,00
00308:  CLR     32
0030A:  MOV     #314,W3
0030C:  ADD     W3,W0,W0
0030E:  TBLRDL.B[W0],W0L
00310:  CLR.B   1
00312:  RETURN  
00314:  DATA    45,72,00
00316:  DATA    72,6F,00
00318:  DATA    72,20,00
0031A:  DATA    28,6F,00
0031C:  DATA    70,65,00
0031E:  DATA    6E,20,00
00320:  DATA    65,72,00
00322:  DATA    72,6F,00
00324:  DATA    72,20,00
00326:  DATA    25,58,00
00328:  DATA    29,00,00
0032A:  CLR     32
0032C:  MOV     #336,W3
0032E:  ADD     W3,W0,W0
00330:  TBLRDL.B[W0],W0L
00332:  CLR.B   1
00334:  RETURN  
00336:  DATA    45,72,00
00338:  DATA    72,6F,00
0033A:  DATA    72,20,00
0033C:  DATA    28,63,00
0033E:  DATA    6C,6F,00
00340:  DATA    73,65,00
00342:  DATA    20,65,00
00344:  DATA    72,72,00
00346:  DATA    6F,72,00
00348:  DATA    20,25,00
0034A:  DATA    58,20,00
0034C:  DATA    25,58,00
0034E:  DATA    29,00,00
00350:  CLR     32
00352:  MOV     #20,W3
00354:  SUB     W0,W3,W3
00356:  BRA     C,362
00358:  MOV     #36C,W3
0035A:  ADD     W3,W0,W0
0035C:  TBLRDL.B[W0],W0L
0035E:  CLR.B   1
00360:  RETURN  
00362:  MOV     #36C,W0
00364:  ADD     W3,W3,W3
00366:  ADD     W3,W0,W3
00368:  TBLRDH  [W3],W0
0036A:  RETURN  
0036C:  DATA    0D,0A,6F
0036E:  DATA    4D,65,20
00370:  DATA    64,69,61
00372:  DATA    61,20,70
00374:  DATA    6E,6F,70
00376:  DATA    74,20,65
00378:  DATA    6D,6F,6E
0037A:  DATA    75,6E,64
0037C:  DATA    74,65,20
0037E:  DATA    64,2C,66
00380:  DATA    20,6E,69
00382:  DATA    6F,74,6C
00384:  DATA    20,67,65
00386:  DATA    6F,69,21
00388:  DATA    6E,67,00
0038A:  DATA    20,74,00
0038C:  CLR     32
0038E:  MOV     #398,W3
00390:  ADD     W3,W0,W0
00392:  TBLRDL.B[W0],W0L
00394:  CLR.B   1
00396:  RETURN  
00398:  DATA    0D,0A,00
0039A:  DATA    41,70,00
0039C:  DATA    70,65,00
0039E:  DATA    6E,64,00
003A0:  DATA    69,6E,00
003A2:  DATA    67,20,00
003A4:  DATA    27,25,00
003A6:  DATA    73,27,00
003A8:  DATA    20,74,00
003AA:  DATA    6F,20,00
003AC:  DATA    27,25,00
003AE:  DATA    73,27,00
003B0:  DATA    3A,20,00
003B2:  DATA    00,00,00
003B4:  CLR     32
003B6:  MOV     #3C0,W3
003B8:  ADD     W3,W0,W0
003BA:  TBLRDL.B[W0],W0L
003BC:  CLR.B   1
003BE:  RETURN  
003C0:  DATA    61,00,00
003C2:  CLR     32
003C4:  MOV     #3CE,W3
003C6:  ADD     W3,W0,W0
003C8:  TBLRDL.B[W0],W0L
003CA:  CLR.B   1
003CC:  RETURN  
003CE:  DATA    45,72,00
003D0:  DATA    72,6F,00
003D2:  DATA    72,20,00
003D4:  DATA    28,25,00
003D6:  DATA    58,29,00
003D8:  DATA    00,00,00
003DA:  CLR     32
003DC:  MOV     #3E6,W3
003DE:  ADD     W3,W0,W0
003E0:  TBLRDL.B[W0],W0L
003E2:  CLR.B   1
003E4:  RETURN  
003E6:  DATA    45,72,00
003E8:  DATA    72,6F,00
003EA:  DATA    72,20,00
003EC:  DATA    28,25,00
003EE:  DATA    58,20,00
003F0:  DATA    25,58,00
003F2:  DATA    29,00,00
003F4:  CLR     32
003F6:  MOV     #24,W3
003F8:  SUB     W0,W3,W3
003FA:  BRA     C,406
003FC:  MOV     #410,W3
003FE:  ADD     W3,W0,W0
00400:  TBLRDL.B[W0],W0L
00402:  CLR.B   1
00404:  RETURN  
00406:  MOV     #410,W0
00408:  ADD     W3,W3,W3
0040A:  ADD     W3,W0,W3
0040C:  TBLRDH  [W3],W0
0040E:  RETURN  
00410:  DATA    0D,0A,61
00412:  DATA    4D,65,6E
00414:  DATA    64,69,67
00416:  DATA    61,20,65
00418:  DATA    6E,6F,20
0041A:  DATA    74,20,64
0041C:  DATA    6D,6F,69
0041E:  DATA    75,6E,72
00420:  DATA    74,65,65
00422:  DATA    64,2C,63
00424:  DATA    20,6E,74
00426:  DATA    6F,74,6F
00428:  DATA    20,67,72
0042A:  DATA    6F,69,79
0042C:  DATA    6E,67,21
0042E:  DATA    20,74,00
00430:  DATA    6F,20,00
00432:  DATA    63,68,00
00434:  CLR     32
00436:  MOV     #440,W3
00438:  ADD     W3,W0,W0
0043A:  TBLRDL.B[W0],W0L
0043C:  CLR.B   1
0043E:  RETURN  
00440:  DATA    0D,0A,00
00442:  DATA    45,72,00
00444:  DATA    72,6F,00
00446:  DATA    72,20,00
00448:  DATA    63,68,00
0044A:  DATA    61,6E,00
0044C:  DATA    67,69,00
0044E:  DATA    6E,67,00
00450:  DATA    20,64,00
00452:  DATA    69,72,00
00454:  DATA    65,63,00
00456:  DATA    74,6F,00
00458:  DATA    72,79,00
0045A:  DATA    00,00,00
0045C:  CLR     32
0045E:  MOV     #24,W3
00460:  SUB     W0,W3,W3
00462:  BRA     C,46E
00464:  MOV     #478,W3
00466:  ADD     W3,W0,W0
00468:  TBLRDL.B[W0],W0L
0046A:  CLR.B   1
0046C:  RETURN  
0046E:  MOV     #478,W0
00470:  ADD     W3,W3,W3
00472:  ADD     W3,W0,W3
00474:  TBLRDH  [W3],W0
00476:  RETURN  
00478:  DATA    0D,0A,73
0047A:  DATA    4D,65,70
0047C:  DATA    64,69,6C
0047E:  DATA    61,20,61
00480:  DATA    6E,6F,79
00482:  DATA    74,20,20
00484:  DATA    6D,6F,64
00486:  DATA    75,6E,69
00488:  DATA    74,65,72
0048A:  DATA    64,2C,65
0048C:  DATA    20,6E,63
0048E:  DATA    6F,74,74
00490:  DATA    20,67,6F
00492:  DATA    6F,69,72
00494:  DATA    6E,67,79
00496:  DATA    20,74,21
00498:  DATA    6F,20,00
0049A:  DATA    64,69,00
0049C:  CLR     32
0049E:  MOV     #4A8,W3
004A0:  ADD     W3,W0,W0
004A2:  TBLRDL.B[W0],W0L
004A4:  CLR.B   1
004A6:  RETURN  
004A8:  DATA    2A,2E,00
004AA:  DATA    2A,00,00
004AC:  CLR     32
004AE:  MOV     #4B8,W3
004B0:  ADD     W3,W0,W0
004B2:  TBLRDL.B[W0],W0L
004B4:  CLR.B   1
004B6:  RETURN  
004B8:  DATA    0D,0A,00
004BA:  DATA    0A,44,00
004BC:  DATA    69,72,00
004BE:  DATA    65,63,00
004C0:  DATA    74,6F,00
004C2:  DATA    72,79,00
004C4:  DATA    20,73,00
004C6:  DATA    65,61,00
004C8:  DATA    72,63,00
004CA:  DATA    68,20,00
004CC:  DATA    63,6F,00
004CE:  DATA    6D,70,00
004D0:  DATA    6C,65,00
004D2:  DATA    74,65,00
004D4:  DATA    64,00,00
004D6:  CLR     32
004D8:  MOV     #4E2,W3
004DA:  ADD     W3,W0,W0
004DC:  TBLRDL.B[W0],W0L
004DE:  CLR.B   1
004E0:  RETURN  
004E2:  DATA    20,28,00
004E4:  DATA    46,53,00
004E6:  DATA    65,72,00
004E8:  DATA    72,6E,00
004EA:  DATA    6F,20,00
004EC:  DATA    3D,20,00
004EE:  DATA    25,75,00
004F0:  DATA    29,00,00
004F2:  CLR     32
004F4:  MOV     #4FE,W3
004F6:  ADD     W3,W0,W0
004F8:  TBLRDL.B[W0],W0L
004FA:  CLR.B   1
004FC:  RETURN  
004FE:  DATA    3C,44,00
00500:  DATA    49,52,00
00502:  DATA    3E,20,00
00504:  DATA    20,00,00
00506:  CLR     32
00508:  MOV     #512,W3
0050A:  ADD     W3,W0,W0
0050C:  TBLRDL.B[W0],W0L
0050E:  CLR.B   1
00510:  RETURN  
00512:  DATA    20,20,00
00514:  DATA    20,20,00
00516:  DATA    20,20,00
00518:  DATA    20,00,00
0051A:  CLR     32
0051C:  MOV     #22,W3
0051E:  SUB     W0,W3,W3
00520:  BRA     C,52C
00522:  MOV     #536,W3
00524:  ADD     W3,W0,W0
00526:  TBLRDL.B[W0],W0L
00528:  CLR.B   1
0052A:  RETURN  
0052C:  MOV     #536,W0
0052E:  ADD     W3,W3,W3
00530:  ADD     W3,W0,W3
00532:  TBLRDH  [W3],W0
00534:  RETURN  
00536:  DATA    0D,0A,6D
00538:  DATA    4D,65,61
0053A:  DATA    64,69,6B
0053C:  DATA    61,20,65
0053E:  DATA    6E,6F,20
00540:  DATA    74,20,64
00542:  DATA    6D,6F,69
00544:  DATA    75,6E,72
00546:  DATA    74,65,65
00548:  DATA    64,2C,63
0054A:  DATA    20,6E,74
0054C:  DATA    6F,74,6F
0054E:  DATA    20,67,72
00550:  DATA    6F,69,79
00552:  DATA    6E,67,21
00554:  DATA    20,74,00
00556:  DATA    6F,20,00
00558:  CLR     32
0055A:  MOV     #564,W3
0055C:  ADD     W3,W0,W0
0055E:  TBLRDL.B[W0],W0L
00560:  CLR.B   1
00562:  RETURN  
00564:  DATA    0D,0A,00
00566:  DATA    4D,61,00
00568:  DATA    6B,69,00
0056A:  DATA    6E,67,00
0056C:  DATA    20,64,00
0056E:  DATA    69,72,00
00570:  DATA    65,63,00
00572:  DATA    74,6F,00
00574:  DATA    72,79,00
00576:  DATA    20,27,00
00578:  DATA    25,73,00
0057A:  DATA    27,3A,00
0057C:  DATA    20,00,00
0057E:  CLR     32
00580:  MOV     #58A,W3
00582:  ADD     W3,W0,W0
00584:  TBLRDL.B[W0],W0L
00586:  CLR.B   1
00588:  RETURN  
0058A:  DATA    45,72,00
0058C:  DATA    72,6F,00
0058E:  DATA    72,20,00
00590:  DATA    63,72,00
00592:  DATA    65,61,00
00594:  DATA    74,69,00
00596:  DATA    6E,67,00
00598:  DATA    20,64,00
0059A:  DATA    69,72,00
0059C:  DATA    65,63,00
0059E:  DATA    74,6F,00
005A0:  DATA    72,79,00
005A2:  DATA    20,28,00
005A4:  DATA    46,53,00
005A6:  DATA    65,72,00
005A8:  DATA    72,6E,00
005AA:  DATA    6F,20,00
005AC:  DATA    3D,20,00
005AE:  DATA    25,75,00
005B0:  DATA    29,00,00
005B2:  CLR     32
005B4:  MOV     #24,W3
005B6:  SUB     W0,W3,W3
005B8:  BRA     C,5C4
005BA:  MOV     #5CE,W3
005BC:  ADD     W3,W0,W0
005BE:  TBLRDL.B[W0],W0L
005C0:  CLR.B   1
005C2:  RETURN  
005C4:  MOV     #5CE,W0
005C6:  ADD     W3,W3,W3
005C8:  ADD     W3,W0,W3
005CA:  TBLRDH  [W3],W0
005CC:  RETURN  
005CE:  DATA    0D,0A,6D
005D0:  DATA    4D,65,6F
005D2:  DATA    64,69,76
005D4:  DATA    61,20,65
005D6:  DATA    6E,6F,20
005D8:  DATA    74,20,64
005DA:  DATA    6D,6F,69
005DC:  DATA    75,6E,72
005DE:  DATA    74,65,65
005E0:  DATA    64,2C,63
005E2:  DATA    20,6E,74
005E4:  DATA    6F,74,6F
005E6:  DATA    20,67,72
005E8:  DATA    6F,69,79
005EA:  DATA    6E,67,21
005EC:  DATA    20,74,00
005EE:  DATA    6F,20,00
005F0:  DATA    72,65,00
005F2:  CLR     32
005F4:  MOV     #5FE,W3
005F6:  ADD     W3,W0,W0
005F8:  TBLRDL.B[W0],W0L
005FA:  CLR.B   1
005FC:  RETURN  
005FE:  DATA    0D,0A,00
00600:  DATA    52,65,00
00602:  DATA    6D,6F,00
00604:  DATA    76,69,00
00606:  DATA    6E,67,00
00608:  DATA    20,64,00
0060A:  DATA    69,72,00
0060C:  DATA    65,63,00
0060E:  DATA    74,6F,00
00610:  DATA    72,79,00
00612:  DATA    20,27,00
00614:  DATA    25,73,00
00616:  DATA    27,3A,00
00618:  DATA    20,00,00
0061A:  CLR     32
0061C:  MOV     #626,W3
0061E:  ADD     W3,W0,W0
00620:  TBLRDL.B[W0],W0L
00622:  CLR.B   1
00624:  RETURN  
00626:  DATA    45,72,00
00628:  DATA    72,6F,00
0062A:  DATA    72,20,00
0062C:  DATA    72,65,00
0062E:  DATA    6D,6F,00
00630:  DATA    76,69,00
00632:  DATA    6E,67,00
00634:  DATA    20,64,00
00636:  DATA    69,72,00
00638:  DATA    65,63,00
0063A:  DATA    74,6F,00
0063C:  DATA    72,79,00
0063E:  DATA    00,00,00
00640:  CLR     32
00642:  MOV     #20,W3
00644:  SUB     W0,W3,W3
00646:  BRA     C,652
00648:  MOV     #65C,W3
0064A:  ADD     W3,W0,W0
0064C:  TBLRDL.B[W0],W0L
0064E:  CLR.B   1
00650:  RETURN  
00652:  MOV     #65C,W0
00654:  ADD     W3,W3,W3
00656:  ADD     W3,W0,W3
00658:  TBLRDH  [W3],W0
0065A:  RETURN  
0065C:  DATA    0D,0A,6F
0065E:  DATA    4D,65,20
00660:  DATA    64,69,64
00662:  DATA    61,20,69
00664:  DATA    6E,6F,73
00666:  DATA    74,20,70
00668:  DATA    6D,6F,6C
0066A:  DATA    75,6E,61
0066C:  DATA    74,65,79
0066E:  DATA    64,2C,20
00670:  DATA    20,6E,66
00672:  DATA    6F,74,69
00674:  DATA    20,67,6C
00676:  DATA    6F,69,65
00678:  DATA    6E,67,21
0067A:  DATA    20,74,00
0067C:  CLR     32
0067E:  MOV     #688,W3
00680:  ADD     W3,W0,W0
00682:  TBLRDL.B[W0],W0L
00684:  CLR.B   1
00686:  RETURN  
00688:  DATA    72,00,00
0068A:  CLR     32
0068C:  MOV     #696,W3
0068E:  ADD     W3,W0,W0
00690:  TBLRDL.B[W0],W0L
00692:  CLR.B   1
00694:  RETURN  
00696:  DATA    0D,0A,00
00698:  DATA    45,72,00
0069A:  DATA    72,6F,00
0069C:  DATA    72,20,00
0069E:  DATA    6F,70,00
006A0:  DATA    65,6E,00
006A2:  DATA    69,6E,00
006A4:  DATA    67,20,00
006A6:  DATA    66,69,00
006A8:  DATA    6C,65,00
006AA:  DATA    20,28,00
006AC:  DATA    45,72,00
006AE:  DATA    72,6F,00
006B0:  DATA    72,20,00
006B2:  DATA    25,58,00
006B4:  DATA    29,00,00
006B6:  CLR     32
006B8:  MOV     #6C2,W3
006BA:  ADD     W3,W0,W0
006BC:  TBLRDL.B[W0],W0L
006BE:  CLR.B   1
006C0:  RETURN  
006C2:  DATA    0D,0A,00
006C4:  DATA    21,21,00
006C6:  DATA    21,20,00
006C8:  DATA    45,72,00
006CA:  DATA    72,6F,00
006CC:  DATA    72,20,00
006CE:  DATA    72,65,00
006D0:  DATA    61,64,00
006D2:  DATA    69,6E,00
006D4:  DATA    67,20,00
006D6:  DATA    66,69,00
006D8:  DATA    6C,65,00
006DA:  DATA    20,28,00
006DC:  DATA    45,72,00
006DE:  DATA    72,6F,00
006E0:  DATA    72,20,00
006E2:  DATA    25,58,00
006E4:  DATA    29,00,00
006E6:  CLR     32
006E8:  MOV     #6F2,W3
006EA:  ADD     W3,W0,W0
006EC:  TBLRDL.B[W0],W0L
006EE:  CLR.B   1
006F0:  RETURN  
006F2:  DATA    0D,0A,00
006F4:  DATA    45,72,00
006F6:  DATA    72,6F,00
006F8:  DATA    72,2C,00
006FA:  DATA    20,4D,00
006FC:  DATA    65,64,00
006FE:  DATA    69,61,00
00700:  DATA    20,6E,00
00702:  DATA    6F,74,00
00704:  DATA    20,66,00
00706:  DATA    6F,75,00
00708:  DATA    6E,64,00
0070A:  DATA    21,00,00
0070C:  CLR     32
0070E:  MOV     #22,W3
00710:  SUB     W0,W3,W3
00712:  BRA     C,71E
00714:  MOV     #728,W3
00716:  ADD     W3,W0,W0
00718:  TBLRDL.B[W0],W0L
0071A:  CLR.B   1
0071C:  RETURN  
0071E:  MOV     #728,W0
00720:  ADD     W3,W3,W3
00722:  ADD     W3,W0,W3
00724:  TBLRDH  [W3],W0
00726:  RETURN  
00728:  DATA    0D,0A,73
0072A:  DATA    4F,4B,3D
0072C:  DATA    20,28,25
0072E:  DATA    53,65,55
00730:  DATA    63,74,2C
00732:  DATA    6F,72,20
00734:  DATA    20,53,54
00736:  DATA    69,7A,79
00738:  DATA    65,3D,70
0073A:  DATA    25,4C,65
0073C:  DATA    55,2C,3D
0073E:  DATA    20,53,25
00740:  DATA    65,63,55
00742:  DATA    20,50,29
00744:  DATA    65,72,00
00746:  DATA    20,43,00
00748:  DATA    6C,75,00
0074A:  CLR     32
0074C:  MOV     #22,W3
0074E:  SUB     W0,W3,W3
00750:  BRA     C,75C
00752:  MOV     #766,W3
00754:  ADD     W3,W0,W0
00756:  TBLRDL.B[W0],W0L
00758:  CLR.B   1
0075A:  RETURN  
0075C:  MOV     #766,W0
0075E:  ADD     W3,W3,W3
00760:  ADD     W3,W0,W3
00762:  TBLRDH  [W3],W0
00764:  RETURN  
00766:  DATA    0D,0A,46
00768:  DATA    45,72,53
0076A:  DATA    72,6F,65
0076C:  DATA    72,2C,72
0076E:  DATA    20,66,72
00770:  DATA    69,6C,6E
00772:  DATA    65,20,6F
00774:  DATA    73,79,3D
00776:  DATA    73,74,25
00778:  DATA    65,6D,55
0077A:  DATA    20,6E,29
0077C:  DATA    6F,74,21
0077E:  DATA    20,6D,21
00780:  DATA    6F,75,21
00782:  DATA    6E,74,00
00784:  DATA    65,64,00
00786:  DATA    20,28,00
00788:  CLR     32
0078A:  MOV     #794,W3
0078C:  ADD     W3,W0,W0
0078E:  TBLRDL.B[W0],W0L
00790:  CLR.B   1
00792:  RETURN  
00794:  DATA    0D,0A,00
00796:  DATA    45,72,00
00798:  DATA    72,6F,00
0079A:  DATA    72,2C,00
0079C:  DATA    20,66,00
0079E:  DATA    6F,72,00
007A0:  DATA    6D,61,00
007A2:  DATA    74,74,00
007A4:  DATA    69,6E,00
007A6:  DATA    67,20,00
007A8:  DATA    64,69,00
007AA:  DATA    73,61,00
007AC:  DATA    62,6C,00
007AE:  DATA    65,64,00
007B0:  DATA    21,21,00
007B2:  DATA    21,00,00
007B4:  CLR     32
007B6:  MOV     #28,W3
007B8:  SUB     W0,W3,W3
007BA:  BRA     C,7C6
007BC:  MOV     #7D0,W3
007BE:  ADD     W3,W0,W0
007C0:  TBLRDL.B[W0],W0L
007C2:  CLR.B   1
007C4:  RETURN  
007C6:  MOV     #7D0,W0
007C8:  ADD     W3,W3,W3
007CA:  ADD     W3,W0,W3
007CC:  TBLRDH  [W3],W0
007CE:  RETURN  
007D0:  DATA    0D,0A,6E
007D2:  DATA    47,65,64
007D4:  DATA    74,74,73
007D6:  DATA    69,6E,20
007D8:  DATA    67,20,74
007DA:  DATA    6D,65,6F
007DC:  DATA    64,69,20
007DE:  DATA    61,20,6D
007E0:  DATA    69,6E,69
007E2:  DATA    66,6F,6E
007E4:  DATA    20,28,75
007E6:  DATA    74,68,74
007E8:  DATA    69,73,65
007EA:  DATA    20,6D,73
007EC:  DATA    61,79,29
007EE:  DATA    20,74,2E
007F0:  DATA    61,6B,2E
007F2:  DATA    65,20,2E
007F4:  DATA    73,65,00
007F6:  DATA    63,6F,00
007F8:  CLR     32
007FA:  MOV     #2A,W3
007FC:  SUB     W0,W3,W3
007FE:  BRA     C,80A
00800:  MOV     #814,W3
00802:  ADD     W3,W0,W0
00804:  TBLRDL.B[W0],W0L
00806:  CLR.B   1
00808:  RETURN  
0080A:  MOV     #814,W0
0080C:  ADD     W3,W3,W3
0080E:  ADD     W3,W0,W3
00810:  TBLRDH  [W3],W0
00812:  RETURN  
00814:  DATA    0D,0A,20
00816:  DATA    0A,46,74
00818:  DATA    69,6C,72
0081A:  DATA    65,20,79
0081C:  DATA    73,79,20
0081E:  DATA    73,74,6D
00820:  DATA    65,6D,6F
00822:  DATA    20,74,75
00824:  DATA    68,69,6E
00826:  DATA    6E,6B,74
00828:  DATA    73,20,69
0082A:  DATA    6D,65,6E
0082C:  DATA    64,69,67
0082E:  DATA    61,20,20
00830:  DATA    69,73,61
00832:  DATA    6E,27,67
00834:  DATA    74,20,61
00836:  DATA    6D,6F,69
00838:  DATA    75,6E,6E
0083A:  DATA    74,65,21
0083C:  DATA    64,2C,00
0083E:  CLR     32
00840:  MOV     #84A,W3
00842:  ADD     W3,W0,W0
00844:  TBLRDL.B[W0],W0L
00846:  CLR.B   1
00848:  RETURN  
0084A:  DATA    0D,0A,00
0084C:  DATA    0A,45,00
0084E:  DATA    72,72,00
00850:  DATA    6F,72,00
00852:  DATA    20,67,00
00854:  DATA    65,74,00
00856:  DATA    74,69,00
00858:  DATA    6E,67,00
0085A:  DATA    20,69,00
0085C:  DATA    6E,66,00
0085E:  DATA    6F,00,00
00860:  CLR     32
00862:  MOV     #86C,W3
00864:  ADD     W3,W0,W0
00866:  TBLRDL.B[W0],W0L
00868:  CLR.B   1
0086A:  RETURN  
0086C:  DATA    0D,0A,00
0086E:  DATA    0A,42,00
00870:  DATA    79,74,00
00872:  DATA    65,73,00
00874:  DATA    20,70,00
00876:  DATA    65,72,00
00878:  DATA    20,73,00
0087A:  DATA    65,63,00
0087C:  DATA    74,6F,00
0087E:  DATA    72,3A,00
00880:  DATA    20,25,00
00882:  DATA    4C,55,00
00884:  DATA    00,00,00
00886:  CLR     32
00888:  MOV     #892,W3
0088A:  ADD     W3,W0,W0
0088C:  TBLRDL.B[W0],W0L
0088E:  CLR.B   1
00890:  RETURN  
00892:  DATA    0D,0A,00
00894:  DATA    53,65,00
00896:  DATA    63,74,00
00898:  DATA    6F,72,00
0089A:  DATA    73,20,00
0089C:  DATA    70,65,00
0089E:  DATA    72,20,00
008A0:  DATA    63,6C,00
008A2:  DATA    75,73,00
008A4:  DATA    74,65,00
008A6:  DATA    72,3A,00
008A8:  DATA    20,25,00
008AA:  DATA    55,00,00
008AC:  CLR     32
008AE:  MOV     #8B8,W3
008B0:  ADD     W3,W0,W0
008B2:  TBLRDL.B[W0],W0L
008B4:  CLR.B   1
008B6:  RETURN  
008B8:  DATA    0D,0A,00
008BA:  DATA    54,6F,00
008BC:  DATA    74,61,00
008BE:  DATA    6C,20,00
008C0:  DATA    73,69,00
008C2:  DATA    7A,65,00
008C4:  DATA    20,6F,00
008C6:  DATA    66,20,00
008C8:  DATA    6D,65,00
008CA:  DATA    64,69,00
008CC:  DATA    61,3A,00
008CE:  DATA    20,25,00
008D0:  DATA    4C,55,00
008D2:  DATA    00,00,00
008D4:  CLR     32
008D6:  MOV     #8E0,W3
008D8:  ADD     W3,W0,W0
008DA:  TBLRDL.B[W0],W0L
008DC:  CLR.B   1
008DE:  RETURN  
008E0:  DATA    0D,0A,00
008E2:  DATA    46,72,00
008E4:  DATA    65,65,00
008E6:  DATA    20,73,00
008E8:  DATA    70,61,00
008EA:  DATA    63,65,00
008EC:  DATA    20,6F,00
008EE:  DATA    66,20,00
008F0:  DATA    6D,65,00
008F2:  DATA    64,69,00
008F4:  DATA    61,3A,00
008F6:  DATA    20,25,00
008F8:  DATA    4C,55,00
008FA:  DATA    00,00,00
008FC:  CLR     32
008FE:  MOV     #908,W3
00900:  ADD     W3,W0,W0
00902:  TBLRDL.B[W0],W0L
00904:  CLR.B   1
00906:  RETURN  
00908:  DATA    0D,0A,00
0090A:  DATA    4D,65,00
0090C:  DATA    64,69,00
0090E:  DATA    61,20,00
00910:  DATA    6E,6F,00
00912:  DATA    74,20,00
00914:  DATA    6D,6F,00
00916:  DATA    75,6E,00
00918:  DATA    74,65,00
0091A:  DATA    64,2C,00
0091C:  DATA    20,6E,00
0091E:  DATA    6F,74,00
00920:  DATA    20,67,00
00922:  DATA    65,74,00
00924:  DATA    74,69,00
00926:  DATA    6E,67,00
00928:  DATA    20,69,00
0092A:  DATA    6E,66,00
0092C:  DATA    6F,21,00
0092E:  DATA    00,00,00
00930:  CLR     32
00932:  MOV     #22,W3
00934:  SUB     W0,W3,W3
00936:  BRA     C,942
00938:  MOV     #94C,W3
0093A:  ADD     W3,W0,W0
0093C:  TBLRDL.B[W0],W0L
0093E:  CLR.B   1
00940:  RETURN  
00942:  MOV     #94C,W0
00944:  ADD     W3,W3,W3
00946:  ADD     W3,W0,W3
00948:  TBLRDH  [W3],W0
0094A:  RETURN  
0094C:  DATA    0D,0A,43
0094E:  DATA    46,41,53
00950:  DATA    54,20,20
00952:  DATA    53,68,43
00954:  DATA    65,6C,20
00956:  DATA    6C,20,43
00958:  DATA    48,65,6F
0095A:  DATA    6C,70,6D
0095C:  DATA    20,2D,70
0095E:  DATA    20,43,69
00960:  DATA    6F,6D,6C
00962:  DATA    70,69,65
00964:  DATA    6C,65,72
00966:  DATA    64,20,20
00968:  DATA    77,69,00
0096A:  DATA    74,68,00
0096C:  DATA    20,43,00
0096E:  CLR     32
00970:  MOV     #97A,W3
00972:  ADD     W3,W0,W0
00974:  TBLRDL.B[W0],W0L
00976:  CLR.B   1
00978:  RETURN  
0097A:  DATA    50,43,00
0097C:  DATA    44,20,00
0097E:  DATA    00,00,00
00980:  CLR     32
00982:  MOV     #98C,W3
00984:  ADD     W3,W0,W0
00986:  TBLRDL.B[W0],W0L
00988:  CLR.B   1
0098A:  RETURN  
0098C:  DATA    35,2E,00
0098E:  DATA    30,33,00
00990:  DATA    32,00,00
00992:  CLR     32
00994:  MOV     #34,W3
00996:  SUB     W0,W3,W3
00998:  BRA     C,9A4
0099A:  MOV     #9AE,W3
0099C:  ADD     W3,W0,W0
0099E:  TBLRDL.B[W0],W0L
009A0:  CLR.B   1
009A2:  RETURN  
009A4:  MOV     #9AE,W0
009A6:  ADD     W3,W3,W3
009A8:  ADD     W3,W0,W3
009AA:  TBLRDH  [W3],W0
009AC:  RETURN  
009AE:  DATA    0D,0A,69
009B0:  DATA    20,6D,72
009B2:  DATA    6F,75,65
009B4:  DATA    6E,74,64
009B6:  DATA    20,2D,20
009B8:  DATA    2D,2D,62
009BA:  DATA    20,69,65
009BC:  DATA    6E,69,66
009BE:  DATA    74,69,6F
009C0:  DATA    61,6C,72
009C2:  DATA    69,7A,65
009C4:  DATA    65,20,20
009C6:  DATA    61,6E,66
009C8:  DATA    64,20,69
009CA:  DATA    6D,6F,6C
009CC:  DATA    75,6E,65
009CE:  DATA    74,20,20
009D0:  DATA    66,69,61
009D2:  DATA    6C,65,63
009D4:  DATA    20,73,63
009D6:  DATA    79,73,65
009D8:  DATA    74,65,73
009DA:  DATA    6D,2E,73
009DC:  DATA    20,20,00
009DE:  DATA    72,65,00
009E0:  DATA    71,75,00
009E2:  CLR     32
009E4:  MOV     #9EE,W3
009E6:  ADD     W3,W0,W0
009E8:  TBLRDL.B[W0],W0L
009EA:  CLR.B   1
009EC:  RETURN  
009EE:  DATA    0D,0A,00
009F0:  DATA    20,64,00
009F2:  DATA    65,6C,00
009F4:  DATA    20,66,00
009F6:  DATA    69,6C,00
009F8:  DATA    65,6E,00
009FA:  DATA    61,6D,00
009FC:  DATA    65,20,00
009FE:  DATA    2D,2D,00
00A00:  DATA    2D,20,00
00A02:  DATA    44,65,00
00A04:  DATA    6C,65,00
00A06:  DATA    74,65,00
00A08:  DATA    73,20,00
00A0A:  DATA    74,68,00
00A0C:  DATA    65,20,00
00A0E:  DATA    66,69,00
00A10:  DATA    6C,65,00
00A12:  DATA    00,00,00
00A14:  CLR     32
00A16:  MOV     #1E,W3
00A18:  SUB     W0,W3,W3
00A1A:  BRA     C,A26
00A1C:  MOV     #A30,W3
00A1E:  ADD     W3,W0,W0
00A20:  TBLRDL.B[W0],W0L
00A22:  CLR.B   1
00A24:  RETURN  
00A26:  MOV     #A30,W0
00A28:  ADD     W3,W3,W3
00A2A:  ADD     W3,W0,W3
00A2C:  TBLRDH  [W3],W0
00A2E:  RETURN  
00A30:  DATA    0D,0A,6E
00A32:  DATA    20,6D,20
00A34:  DATA    61,6B,65
00A36:  DATA    65,20,6D
00A38:  DATA    66,69,70
00A3A:  DATA    6C,65,74
00A3C:  DATA    6E,61,79
00A3E:  DATA    6D,65,20
00A40:  DATA    20,2D,66
00A42:  DATA    2D,2D,69
00A44:  DATA    20,43,6C
00A46:  DATA    72,65,65
00A48:  DATA    61,74,00
00A4A:  DATA    65,73,00
00A4C:  DATA    20,61,00
00A4E:  CLR     32
00A50:  MOV     #2E,W3
00A52:  SUB     W0,W3,W3
00A54:  BRA     C,A60
00A56:  MOV     #A6A,W3
00A58:  ADD     W3,W0,W0
00A5A:  TBLRDL.B[W0],W0L
00A5C:  CLR.B   1
00A5E:  RETURN  
00A60:  MOV     #A6A,W0
00A62:  ADD     W3,W3,W3
00A64:  ADD     W3,W0,W3
00A66:  TBLRDH  [W3],W0
00A68:  RETURN  
00A6A:  DATA    0D,0A,6F
00A6C:  DATA    20,61,20
00A6E:  DATA    70,70,74
00A70:  DATA    65,6E,68
00A72:  DATA    64,20,65
00A74:  DATA    66,69,20
00A76:  DATA    6C,65,65
00A78:  DATA    6E,61,6E
00A7A:  DATA    6D,65,64
00A7C:  DATA    20,73,20
00A7E:  DATA    74,72,6F
00A80:  DATA    69,6E,66
00A82:  DATA    67,20,20
00A84:  DATA    2D,2D,74
00A86:  DATA    2D,20,68
00A88:  DATA    41,70,65
00A8A:  DATA    70,65,20
00A8C:  DATA    6E,64,66
00A8E:  DATA    73,20,69
00A90:  DATA    73,74,6C
00A92:  DATA    72,69,65
00A94:  DATA    6E,67,00
00A96:  DATA    20,74,00
00A98:  CLR     32
00A9A:  MOV     #1E,W3
00A9C:  SUB     W0,W3,W3
00A9E:  BRA     C,AAA
00AA0:  MOV     #AB4,W3
00AA2:  ADD     W3,W0,W0
00AA4:  TBLRDL.B[W0],W0L
00AA6:  CLR.B   1
00AA8:  RETURN  
00AAA:  MOV     #AB4,W0
00AAC:  ADD     W3,W3,W3
00AAE:  ADD     W3,W0,W3
00AB0:  TBLRDH  [W3],W0
00AB2:  RETURN  
00AB4:  DATA    0D,0A,6E
00AB6:  DATA    20,63,67
00AB8:  DATA    64,20,20
00ABA:  DATA    64,69,64
00ABC:  DATA    72,20,69
00ABE:  DATA    2D,2D,72
00AC0:  DATA    2D,20,65
00AC2:  DATA    43,68,63
00AC4:  DATA    61,6E,74
00AC6:  DATA    67,65,6F
00AC8:  DATA    20,74,72
00ACA:  DATA    68,65,79
00ACC:  DATA    20,77,00
00ACE:  DATA    6F,72,00
00AD0:  DATA    6B,69,00
00AD2:  CLR     32
00AD4:  MOV     #20,W3
00AD6:  SUB     W0,W3,W3
00AD8:  BRA     C,AE4
00ADA:  MOV     #AEE,W3
00ADC:  ADD     W3,W0,W0
00ADE:  TBLRDL.B[W0],W0L
00AE0:  CLR.B   1
00AE2:  RETURN  
00AE4:  MOV     #AEE,W0
00AE6:  ADD     W3,W3,W3
00AE8:  ADD     W3,W0,W3
00AEA:  TBLRDH  [W3],W0
00AEC:  RETURN  
00AEE:  DATA    0D,0A,20
00AF0:  DATA    20,64,74
00AF2:  DATA    69,72,68
00AF4:  DATA    20,2D,65
00AF6:  DATA    2D,2D,20
00AF8:  DATA    20,53,64
00AFA:  DATA    68,6F,69
00AFC:  DATA    77,73,72
00AFE:  DATA    20,74,65
00B00:  DATA    68,65,63
00B02:  DATA    20,63,74
00B04:  DATA    6F,6E,6F
00B06:  DATA    74,65,72
00B08:  DATA    6E,74,79
00B0A:  DATA    73,20,00
00B0C:  DATA    6F,66,00
00B0E:  CLR     32
00B10:  MOV     #1E,W3
00B12:  SUB     W0,W3,W3
00B14:  BRA     C,B20
00B16:  MOV     #B2A,W3
00B18:  ADD     W3,W0,W0
00B1A:  TBLRDL.B[W0],W0L
00B1C:  CLR.B   1
00B1E:  RETURN  
00B20:  MOV     #B2A,W0
00B22:  ADD     W3,W3,W3
00B24:  ADD     W3,W0,W3
00B26:  TBLRDH  [W3],W0
00B28:  RETURN  
00B2A:  DATA    0D,0A,6F
00B2C:  DATA    20,63,6E
00B2E:  DATA    61,74,74
00B30:  DATA    20,66,65
00B32:  DATA    69,6C,6E
00B34:  DATA    65,6E,74
00B36:  DATA    61,6D,20
00B38:  DATA    65,20,6F
00B3A:  DATA    2D,2D,66
00B3C:  DATA    2D,20,20
00B3E:  DATA    44,69,66
00B40:  DATA    73,70,69
00B42:  DATA    6C,61,6C
00B44:  DATA    79,73,65
00B46:  DATA    20,63,00
00B48:  CLR     32
00B4A:  MOV     #2A,W3
00B4C:  SUB     W0,W3,W3
00B4E:  BRA     C,B5A
00B50:  MOV     #B64,W3
00B52:  ADD     W3,W0,W0
00B54:  TBLRDL.B[W0],W0L
00B56:  CLR.B   1
00B58:  RETURN  
00B5A:  MOV     #B64,W0
00B5C:  ADD     W3,W3,W3
00B5E:  ADD     W3,W0,W3
00B60:  TBLRDH  [W3],W0
00B62:  RETURN  
00B64:  DATA    0D,0A,63
00B66:  DATA    20,74,68
00B68:  DATA    61,69,61
00B6A:  DATA    6C,20,72
00B6C:  DATA    66,69,61
00B6E:  DATA    6C,65,63
00B70:  DATA    6E,61,74
00B72:  DATA    6D,65,65
00B74:  DATA    20,2D,72
00B76:  DATA    2D,2D,73
00B78:  DATA    20,44,20
00B7A:  DATA    69,73,6F
00B7C:  DATA    70,6C,66
00B7E:  DATA    61,79,20
00B80:  DATA    73,20,66
00B82:  DATA    74,68,69
00B84:  DATA    65,20,6C
00B86:  DATA    6C,61,65
00B88:  DATA    73,74,00
00B8A:  DATA    20,38,00
00B8C:  DATA    30,20,00
00B8E:  CLR     32
00B90:  MOV     #B9A,W3
00B92:  ADD     W3,W0,W0
00B94:  TBLRDL.B[W0],W0L
00B96:  CLR.B   1
00B98:  RETURN  
00B9A:  DATA    0D,0A,00
00B9C:  DATA    20,6D,00
00B9E:  DATA    6B,64,00
00BA0:  DATA    69,72,00
00BA2:  DATA    20,64,00
00BA4:  DATA    69,72,00
00BA6:  DATA    20,2D,00
00BA8:  DATA    2D,2D,00
00BAA:  DATA    20,43,00
00BAC:  DATA    72,65,00
00BAE:  DATA    61,74,00
00BB0:  DATA    65,20,00
00BB2:  DATA    61,20,00
00BB4:  DATA    64,69,00
00BB6:  DATA    72,65,00
00BB8:  DATA    63,74,00
00BBA:  DATA    6F,72,00
00BBC:  DATA    79,00,00
00BBE:  CLR     32
00BC0:  MOV     #BCA,W3
00BC2:  ADD     W3,W0,W0
00BC4:  TBLRDL.B[W0],W0L
00BC6:  CLR.B   1
00BC8:  RETURN  
00BCA:  DATA    0D,0A,00
00BCC:  DATA    20,72,00
00BCE:  DATA    6D,64,00
00BD0:  DATA    69,72,00
00BD2:  DATA    20,64,00
00BD4:  DATA    69,72,00
00BD6:  DATA    20,2D,00
00BD8:  DATA    2D,2D,00
00BDA:  DATA    20,44,00
00BDC:  DATA    65,6C,00
00BDE:  DATA    65,74,00
00BE0:  DATA    65,73,00
00BE2:  DATA    20,74,00
00BE4:  DATA    68,65,00
00BE6:  DATA    20,64,00
00BE8:  DATA    69,72,00
00BEA:  DATA    65,63,00
00BEC:  DATA    74,6F,00
00BEE:  DATA    72,79,00
00BF0:  DATA    00,00,00
00BF2:  CLR     32
00BF4:  MOV     #38,W3
00BF6:  SUB     W0,W3,W3
00BF8:  BRA     C,C04
00BFA:  MOV     #C0E,W3
00BFC:  ADD     W3,W0,W0
00BFE:  TBLRDL.B[W0],W0L
00C00:  CLR.B   1
00C02:  RETURN  
00C04:  MOV     #C0E,W0
00C06:  ADD     W3,W3,W3
00C08:  ADD     W3,W0,W3
00C0A:  TBLRDH  [W3],W0
00C0C:  RETURN  
00C0E:  DATA    0D,0A,30
00C10:  DATA    20,66,39
00C12:  DATA    6F,72,31
00C14:  DATA    6D,61,32
00C16:  DATA    74,20,27
00C18:  DATA    73,69,20
00C1A:  DATA    7A,65,2D
00C1C:  DATA    20,2D,6F
00C1E:  DATA    2D,2D,72
00C20:  DATA    20,46,2D
00C22:  DATA    6F,72,20
00C24:  DATA    6D,61,27
00C26:  DATA    74,20,66
00C28:  DATA    63,61,6F
00C2A:  DATA    72,64,72
00C2C:  DATA    2E,20,6D
00C2E:  DATA    20,28,61
00C30:  DATA    45,78,74
00C32:  DATA    61,6D,20
00C34:  DATA    70,6C,35
00C36:  DATA    65,3A,31
00C38:  DATA    20,27,32
00C3A:  DATA    66,6F,4D
00C3C:  DATA    72,6D,27
00C3E:  DATA    61,74,20
00C40:  DATA    20,35,00
00C42:  DATA    33,36,00
00C44:  DATA    38,37,00
00C46:  CLR     32
00C48:  MOV     #38,W3
00C4A:  SUB     W0,W3,W3
00C4C:  BRA     C,C58
00C4E:  MOV     #C62,W3
00C50:  ADD     W3,W0,W0
00C52:  TBLRDL.B[W0],W0L
00C54:  CLR.B   1
00C56:  RETURN  
00C58:  MOV     #C62,W0
00C5A:  ADD     W3,W3,W3
00C5C:  ADD     W3,W0,W3
00C5E:  TBLRDH  [W3],W0
00C60:  RETURN  
00C62:  DATA    0D,0A,6E
00C64:  DATA    20,20,64
00C66:  DATA    20,20,20
00C68:  DATA    20,20,50
00C6A:  DATA    20,20,61
00C6C:  DATA    20,20,72
00C6E:  DATA    20,20,74
00C70:  DATA    20,20,69
00C72:  DATA    20,20,74
00C74:  DATA    20,66,69
00C76:  DATA    6F,72,6F
00C78:  DATA    6D,61,6E
00C7A:  DATA    74,73,20
00C7C:  DATA    20,61,30
00C7E:  DATA    20,35,2E
00C80:  DATA    31,32,20
00C82:  DATA    4D,42,20
00C84:  DATA    20,63,54
00C86:  DATA    61,72,68
00C88:  DATA    64,29,69
00C8A:  DATA    2E,20,73
00C8C:  DATA    20,43,20
00C8E:  DATA    72,65,69
00C90:  DATA    61,74,73
00C92:  DATA    65,73,20
00C94:  DATA    20,4D,00
00C96:  DATA    42,52,00
00C98:  DATA    20,61,00
00C9A:  CLR     32
00C9C:  MOV     #34,W3
00C9E:  SUB     W0,W3,W3
00CA0:  BRA     C,CAC
00CA2:  MOV     #CB6,W3
00CA4:  ADD     W3,W0,W0
00CA6:  TBLRDL.B[W0],W0L
00CA8:  CLR.B   1
00CAA:  RETURN  
00CAC:  MOV     #CB6,W0
00CAE:  ADD     W3,W3,W3
00CB0:  ADD     W3,W0,W3
00CB2:  TBLRDH  [W3],W0
00CB4:  RETURN  
00CB6:  DATA    0D,0A,79
00CB8:  DATA    20,20,6F
00CBA:  DATA    20,20,75
00CBC:  DATA    20,20,20
00CBE:  DATA    20,20,63
00CC0:  DATA    20,20,61
00CC2:  DATA    20,20,6E
00CC4:  DATA    20,20,20
00CC6:  DATA    20,20,75
00CC8:  DATA    20,6E,73
00CCA:  DATA    6F,74,65
00CCC:  DATA    20,72,20
00CCE:  DATA    65,63,61
00CD0:  DATA    6F,6D,20
00CD2:  DATA    6D,65,63
00CD4:  DATA    6E,64,6F
00CD6:  DATA    65,64,6D
00CD8:  DATA    20,6F,70
00CDA:  DATA    6E,20,75
00CDC:  DATA    64,65,74
00CDE:  DATA    76,69,65
00CE0:  DATA    63,65,72
00CE2:  DATA    73,20,20
00CE4:  DATA    77,68,74
00CE6:  DATA    69,63,6F
00CE8:  DATA    68,20,00
00CEA:  CLR     32
00CEC:  MOV     #2C,W3
00CEE:  SUB     W0,W3,W3
00CF0:  BRA     C,CFC
00CF2:  MOV     #D06,W3
00CF4:  ADD     W3,W0,W0
00CF6:  TBLRDL.B[W0],W0L
00CF8:  CLR.B   1
00CFA:  RETURN  
00CFC:  MOV     #D06,W0
00CFE:  ADD     W3,W3,W3
00D00:  ADD     W3,W0,W3
00D02:  TBLRDH  [W3],W0
00D04:  RETURN  
00D06:  DATA    0D,0A,20
00D08:  DATA    20,20,61
00D0A:  DATA    20,20,6E
00D0C:  DATA    20,20,20
00D0E:  DATA    20,20,53
00D10:  DATA    20,20,44
00D12:  DATA    20,20,20
00D14:  DATA    20,20,6F
00D16:  DATA    20,20,72
00D18:  DATA    20,66,20
00D1A:  DATA    6F,72,43
00D1C:  DATA    6D,61,46
00D1E:  DATA    74,20,20
00D20:  DATA    74,68,64
00D22:  DATA    65,20,65
00D24:  DATA    64,72,76
00D26:  DATA    69,76,69
00D28:  DATA    65,20,63
00D2A:  DATA    28,73,65
00D2C:  DATA    75,63,29
00D2E:  DATA    68,20,2E
00D30:  DATA    61,73,00
00D32:  CLR     32
00D34:  MOV     #38,W3
00D36:  SUB     W0,W3,W3
00D38:  BRA     C,D44
00D3A:  MOV     #D4E,W3
00D3C:  ADD     W3,W0,W0
00D3E:  TBLRDL.B[W0],W0L
00D40:  CLR.B   1
00D42:  RETURN  
00D44:  MOV     #D4E,W0
00D46:  ADD     W3,W3,W3
00D48:  ADD     W3,W0,W3
00D4A:  TBLRDH  [W3],W0
00D4C:  RETURN  
00D4E:  DATA    0D,0A,20
00D50:  DATA    20,69,43
00D52:  DATA    6E,66,61
00D54:  DATA    6F,20,6E
00D56:  DATA    2D,2D,20
00D58:  DATA    2D,20,74
00D5A:  DATA    53,68,61
00D5C:  DATA    6F,77,6B
00D5E:  DATA    20,73,65
00D60:  DATA    6F,6D,20
00D62:  DATA    65,20,73
00D64:  DATA    69,6E,65
00D66:  DATA    66,6F,76
00D68:  DATA    20,61,65
00D6A:  DATA    62,6F,72
00D6C:  DATA    75,74,61
00D6E:  DATA    20,74,6C
00D70:  DATA    68,65,20
00D72:  DATA    20,6D,73
00D74:  DATA    65,64,65
00D76:  DATA    69,61,63
00D78:  DATA    2F,66,6F
00D7A:  DATA    69,6C,6E
00D7C:  DATA    65,20,64
00D7E:  DATA    73,79,73
00D80:  DATA    73,74,21
00D82:  DATA    65,6D,00
00D84:  DATA    2E,20,00
00D86:  CLR     32
00D88:  MOV     #D92,W3
00D8A:  ADD     W3,W0,W0
00D8C:  TBLRDL.B[W0],W0L
00D8E:  CLR.B   1
00D90:  RETURN  
00D92:  DATA    0D,0A,00
00D94:  DATA    20,68,00
00D96:  DATA    65,6C,00
00D98:  DATA    70,09,00
00D9A:  DATA    59,6F,00
00D9C:  DATA    75,20,00
00D9E:  DATA    61,72,00
00DA0:  DATA    65,20,00
00DA2:  DATA    68,65,00
00DA4:  DATA    72,65,00
00DA6:  DATA    00,00,00
00DA8:  CLR     32
00DAA:  MOV     #20,W3
00DAC:  SUB     W0,W3,W3
00DAE:  BRA     C,DBA
00DB0:  MOV     #DC4,W3
00DB2:  ADD     W3,W0,W0
00DB4:  TBLRDL.B[W0],W0L
00DB6:  CLR.B   1
00DB8:  RETURN  
00DBA:  MOV     #DC4,W0
00DBC:  ADD     W3,W3,W3
00DBE:  ADD     W3,W0,W3
00DC0:  TBLRDH  [W3],W0
00DC2:  RETURN  
00DC4:  DATA    0D,0A,20
00DC6:  DATA    0A,20,69
00DC8:  DATA    50,75,74
00DCA:  DATA    74,20,20
00DCC:  DATA    61,20,68
00DCE:  DATA    70,61,61
00DD0:  DATA    72,61,73
00DD2:  DATA    6D,65,20
00DD4:  DATA    74,65,73
00DD6:  DATA    72,20,70
00DD8:  DATA    69,6E,61
00DDA:  DATA    20,71,63
00DDC:  DATA    75,6F,65
00DDE:  DATA    74,65,73
00DE0:  DATA    73,20,00
00DE2:  DATA    69,66,00
00DE4:  CLR     32
00DE6:  MOV     #DF0,W3
00DE8:  ADD     W3,W0,W0
00DEA:  TBLRDL.B[W0],W0L
00DEC:  CLR.B   1
00DEE:  RETURN  
00DF0:  DATA    6D,6F,00
00DF2:  DATA    75,6E,00
00DF4:  DATA    74,00,00
00DF6:  CLR     32
00DF8:  MOV     #E02,W3
00DFA:  ADD     W3,W0,W0
00DFC:  TBLRDL.B[W0],W0L
00DFE:  CLR.B   1
00E00:  RETURN  
00E02:  DATA    61,70,00
00E04:  DATA    70,65,00
00E06:  DATA    6E,64,00
00E08:  DATA    20,6C,00
00E0A:  DATA    6F,67,00
00E0C:  DATA    2E,74,00
00E0E:  DATA    78,74,00
00E10:  DATA    20,62,00
00E12:  DATA    75,74,00
00E14:  DATA    74,6F,00
00E16:  DATA    6E,20,00
00E18:  DATA    70,72,00
00E1A:  DATA    65,73,00
00E1C:  DATA    73,65,00
00E1E:  DATA    64,21,00
00E20:  DATA    21,00,00
00E22:  CLR     32
00E24:  MOV     #E2E,W3
00E26:  ADD     W3,W0,W0
00E28:  TBLRDL.B[W0],W0L
00E2A:  CLR.B   1
00E2C:  RETURN  
00E2E:  DATA    74,65,00
00E30:  DATA    73,74,00
00E32:  DATA    66,69,00
00E34:  DATA    6C,65,00
00E36:  DATA    2E,74,00
00E38:  DATA    78,74,00
00E3A:  DATA    00,00,00
00E3C:  CLR     32
00E3E:  MOV     #E48,W3
00E40:  ADD     W3,W0,W0
00E42:  TBLRDL.B[W0],W0L
00E44:  CLR.B   1
00E46:  RETURN  
00E48:  DATA    48,65,00
00E4A:  DATA    6C,6C,00
00E4C:  DATA    6F,20,00
00E4E:  DATA    57,6F,00
00E50:  DATA    72,6C,00
00E52:  DATA    64,00,00
00E54:  CLR     32
00E56:  MOV     #28,W3
00E58:  SUB     W0,W3,W3
00E5A:  BRA     C,E66
00E5C:  MOV     #E70,W3
00E5E:  ADD     W3,W0,W0
00E60:  TBLRDL.B[W0],W0L
00E62:  CLR.B   1
00E64:  RETURN  
00E66:  MOV     #E70,W0
00E68:  ADD     W3,W3,W3
00E6A:  ADD     W3,W0,W3
00E6C:  TBLRDH  [W3],W0
00E6E:  RETURN  
00E70:  DATA    0D,0A,74
00E72:  DATA    55,6E,20
00E74:  DATA    6B,6E,6C
00E76:  DATA    6F,77,69
00E78:  DATA    6E,20,73
00E7A:  DATA    43,6F,74
00E7C:  DATA    6D,6D,20
00E7E:  DATA    61,6E,6F
00E80:  DATA    64,20,66
00E82:  DATA    27,25,20
00E84:  DATA    73,27,63
00E86:  DATA    2C,20,6F
00E88:  DATA    75,73,6D
00E8A:  DATA    65,20,6D
00E8C:  DATA    27,68,61
00E8E:  DATA    65,6C,6E
00E90:  DATA    70,27,64
00E92:  DATA    20,74,73
00E94:  DATA    6F,20,00
00E96:  DATA    67,65,00
*
010CE:  MOV     W5,[W15++]
010D0:  MOV     #C,W5
010D2:  REPEAT  #3
010D4:  MOV     [W5++],[W15++]
010D6:  MUL.UU  W0,W2,W4
010D8:  MUL.UU  W0,W3,W6
010DA:  BCLR.B  42.0
010DC:  ADD     W6,W5,W5
010DE:  ADDC    W7,#0,W8
010E0:  MUL.UU  W1,W2,W6
010E2:  ADDC    W6,W5,W5
010E4:  ADDC    W7,W8,W8
010E6:  MUL.UU  W1,W3,W6
010E8:  ADD     W6,W8,W8
010EA:  ADDC    #0,W7
010EC:  MOV     W7,W3
010EE:  MOV     W8,W2
010F0:  MOV     W5,W1
010F2:  MOV     W4,W0
010F4:  MOV     #12,W5
010F6:  REPEAT  #3
010F8:  MOV     [--W15],[W5--]
010FA:  MOV     [--W15],W5
010FC:  RETURN  
*
01AE6:  MOV     W5,[W15++]
01AE8:  MOV     #C,W5
01AEA:  REPEAT  #3
01AEC:  MOV     [W5++],[W15++]
01AEE:  MOV     #0,W9
01AF0:  BTSC.B  43.0
01AF2:  MOV     #1,W9
01AF4:  MOV     W9,[W15++]
01AF6:  CLR     W4
01AF8:  CLR     W5
01AFA:  CLR     W6
01AFC:  CLR     W7
01AFE:  XOR     W2,W3,W8
01B00:  BRA     Z,1B24
01B02:  MOV     #20,W8
01B04:  BCLR.B  42.0
01B06:  RLC     W0,W0
01B08:  RLC     W1,W1
01B0A:  RLC     W4,W4
01B0C:  RLC     W5,W5
01B0E:  CP      W5,W3
01B10:  BRA     NZ,1B14
01B12:  CPB     W4,W2
01B14:  BRA     NC,1B1C
01B16:  SUB     W4,W2,W4
01B18:  SUBB    W5,W3,W5
01B1A:  BSET.B  42.0
01B1C:  RLC     W6,W6
01B1E:  RLC     W7,W7
01B20:  DEC     W8,W8
01B22:  BRA     NZ,1B04
01B24:  MOV     W7,W1
01B26:  MOV     W6,W0
01B28:  MOV     [--W15],W9
01B2A:  CP0     W9
01B2C:  BRA     Z,1B30
01B2E:  MOV.D   W4,W0
01B30:  MOV     #12,W5
01B32:  REPEAT  #3
01B34:  MOV     [--W15],[W5--]
01B36:  MOV     [--W15],W5
01B38:  RETURN  
*
022CA:  MOV     W6,[W15++]
022CC:  MOV     W7,[W15++]
022CE:  MOV     W8,[W15++]
022D0:  MOV     W9,[W15++]
022D2:  CLR     W4
022D4:  CLR     W5
022D6:  CLR     W6
022D8:  CLR     W7
022DA:  XOR     W2,W3,W8
022DC:  BRA     Z,2300
022DE:  MOV     #20,W8
022E0:  BCLR.B  42.0
022E2:  RLC     W0,W0
022E4:  RLC     W1,W1
022E6:  RLC     W4,W4
022E8:  RLC     W5,W5
022EA:  CP      W5,W3
022EC:  BRA     NZ,22F0
022EE:  CPB     W4,W2
022F0:  BRA     NC,22F8
022F2:  SUB     W4,W2,W4
022F4:  SUBB    W5,W3,W5
022F6:  BSET.B  42.0
022F8:  RLC     W6,W6
022FA:  RLC     W7,W7
022FC:  DEC     W8,W8
022FE:  BRA     NZ,22E0
02300:  MOV     W7,W1
02302:  MOV     W6,W0
02304:  MOV     [--W15],W9
02306:  MOV     [--W15],W8
02308:  MOV     [--W15],W7
0230A:  MOV     [--W15],W6
0230C:  RETURN  
0230E:  MOV     W5,[W15++]
02310:  MOV     #C,W5
02312:  REPEAT  #7
02314:  MOV     [W5++],[W15++]
02316:  MOV     W0,W6
02318:  MOV     W1,W7
0231A:  MOV     W4,W12
0231C:  BCLR    W4.F
0231E:  CP0     W4
02320:  BRA     NZ,2326
02322:  MOV     #0,W5
02324:  BRA     2340
02326:  SUB.B   W4L,#B,W5L
02328:  BRA     NC,233E
0232A:  MOV     #30,W0
0232C:  BTSS    W12.F
0232E:  MOV     #20,W0
02330:  BTSC.B  223.1
02332:  BRA     2330
02334:  MOV     W0,224
02336:  DEC     W5,W5
02338:  BRA     NN,2330
0233A:  MOV     #A,W5
0233C:  BRA     2340
0233E:  MOV     W4,W5
02340:  MOV     #10,W8
02342:  MOV     #0,W9
02344:  LNK     #10
02346:  MOV     W12,[W14+W8]
02348:  DEC2    W8,W8
0234A:  BRA     NN,2346
0234C:  MOV     #A,W4
0234E:  BSET    W5.E
02350:  BTSC    W12.F
02352:  BSET    W5.F
02354:  MOV     W4,[W14]
02356:  MOV     W5,[W14+#2]
02358:  MOV     W6,W0
0235A:  MOV     W7,W1
0235C:  MOV     #CA00,W2
0235E:  MOV     #3B9A,W3
02360:  MOV     #2710,W8
02362:  BCLR    W13.F
02364:  BTG     W13.F
02366:  CALL    22CA
0236A:  BTSC    W13.F
0236C:  BRA     237C
0236E:  MOV     W0,[W14+#8]
02370:  MOV     W1,[W14+#A]
02372:  MOV     W0,W2
02374:  MOV     W1,W3
02376:  MOV     [W14+#4],W0
02378:  MOV     [W14+#6],W1
0237A:  BRA     2364
0237C:  MOV     W2,[W14+#8]
0237E:  MOV     W3,[W14+#A]
02380:  MOV     W4,[W14+#4]
02382:  MOV     W5,[W14+#6]
02384:  MOV     [W14],W4
02386:  MOV     [W14+#2],W5
02388:  MOV     #30,W6
0238A:  CP0     W0
0238C:  BRA     NZ,23B0
0238E:  BTSS    W5.E
02390:  BRA     23B4
02392:  DEC     W4,W4
02394:  MOV     W4,[W14]
02396:  CP0     W4
02398:  BRA     Z,23B4
0239A:  CP.B    W4L,W5L
0239C:  BTSC.B  42.0
0239E:  BRA     23BC
023A0:  MOV     #30,W6
023A2:  CP0     W0
023A4:  BRA     NZ,23B0
023A6:  BTSS    W5.E
023A8:  BRA     23B4
023AA:  BTSS    W5.F
023AC:  MOV     #20,W6
023AE:  BRA     23B4
023B0:  BCLR    W5.E
023B2:  MOV     W5,[W14+#2]
023B4:  ADD.B   W6L,W0L,W0L
023B6:  BTSC.B  223.1
023B8:  BRA     23B6
023BA:  MOV     W0,224
023BC:  MOV     [W14+#8],W0
023BE:  MOV     [W14+#A],W1
023C0:  MOV     #A,W2
023C2:  CLR     W3
023C4:  CP      W0,#1
023C6:  BRA     Z,23CA
023C8:  BRA     2364
023CA:  ULNK    
023CC:  MOV     #1A,W5
023CE:  REPEAT  #7
023D0:  MOV     [--W15],[W5--]
023D2:  MOV     [--W15],W5
023D4:  RETURN  
023D6:  MOV     W5,[W15++]
023D8:  MOV     #C,W5
023DA:  REPEAT  #3
023DC:  MOV     [W5++],[W15++]
023DE:  MOV     W0,W7
023E0:  MOV     W4,W9
023E2:  BCLR    W4.F
023E4:  CP0     W4
023E6:  BRA     NZ,23F4
023E8:  BTSC    W9.F
023EA:  BRA     23F0
023EC:  MOV     #0,W5
023EE:  BRA     240E
023F0:  MOV     #0,W5
023F2:  BRA     240E
023F4:  SUB.B   W4L,#6,W5L
023F6:  BRA     NC,240C
023F8:  MOV     #30,W0
023FA:  BTSS    W9.F
023FC:  MOV     #20,W0
023FE:  BTSC.B  223.1
02400:  BRA     23FE
02402:  MOV     W0,224
02404:  DEC     W5,W5
02406:  BRA     NN,23FE
02408:  MOV     #5,W5
0240A:  BRA     240E
0240C:  MOV     W4,W5
0240E:  MOV     #6,W4
02410:  BSET    W5.E
02412:  BTSC    W9.F
02414:  BSET    W5.F
02416:  MOV     #2710,W8
02418:  REPEAT  #11
0241A:  DIV.U   W7,W8
0241C:  CALL    2450
02420:  MOV     W1,W7
02422:  MOV     #3E8,W8
02424:  REPEAT  #11
02426:  DIV.U   W7,W8
02428:  CALL    2450
0242C:  MOV     W1,W7
0242E:  MOV     #64,W8
02430:  REPEAT  #11
02432:  DIV.U   W7,W8
02434:  CALL    2450
02438:  MOV     W1,W7
0243A:  MOV     #A,W8
0243C:  REPEAT  #11
0243E:  DIV.U   W7,W8
02440:  CALL    2450
02444:  MOV     #30,W0
02446:  ADD.B   W1L,W0L,W0L
02448:  BTSC.B  223.1
0244A:  BRA     2448
0244C:  MOV     W0,224
0244E:  BRA     247E
02450:  MOV     #30,W6
02452:  CP0     W0
02454:  BRA     NZ,2472
02456:  BTSS    W5.E
02458:  BRA     2474
0245A:  DEC     W4,W4
0245C:  CP.B    W4L,W5L
0245E:  BRA     Z,2464
02460:  BTSC.B  42.0
02462:  RETURN  
02464:  CP0     W0
02466:  BRA     NZ,2472
02468:  BTSS    W5.E
0246A:  BRA     2474
0246C:  BTSS    W5.F
0246E:  MOV     #20,W6
02470:  BRA     2474
02472:  BCLR    W5.E
02474:  ADD.B   W6L,W0L,W0L
02476:  BTSC.B  223.1
02478:  BRA     2476
0247A:  MOV     W0,224
0247C:  RETURN  
0247E:  MOV     #12,W5
02480:  REPEAT  #3
02482:  MOV     [--W15],[W5--]
02484:  MOV     [--W15],W5
02486:  RETURN  
*
02592:  MOV     W1,[W15++]
02594:  MOV     E4E,W1
02596:  MOV.B   W0L,[W1++]
02598:  CLR.B   [W1]
0259A:  MOV     [--W15],W1
0259C:  INC     0E4E
0259E:  RETURN  
*
045F6:  MOV     W5,[W15++]
045F8:  MOV     #C,W5
045FA:  REPEAT  #3
045FC:  MOV     [W5++],[W15++]
045FE:  MOV     #0,W9
04600:  BTSC.B  43.0
04602:  MOV     #1,W9
04604:  MOV     W9,[W15++]
04606:  XOR     W1,W3,W9
04608:  BTSS    W1.F
0460A:  BRA     4612
0460C:  COM     W1,W1
0460E:  NEG     W0,W0
04610:  ADDC    W1,#0,W1
04612:  BTSS    W3.F
04614:  BRA     461C
04616:  COM     W3,W3
04618:  NEG     W2,W2
0461A:  ADDC    W3,#0,W3
0461C:  XOR     W2,W3,W4
0461E:  BRA     Z,464A
04620:  CLR     W4
04622:  CLR     W5
04624:  CLR     W6
04626:  CLR     W7
04628:  MOV     #20,W8
0462A:  BCLR.B  42.0
0462C:  RLC     W0,W0
0462E:  RLC     W1,W1
04630:  RLC     W4,W4
04632:  RLC     W5,W5
04634:  CP      W5,W3
04636:  BRA     NZ,463A
04638:  CPB     W4,W2
0463A:  BRA     NC,4642
0463C:  SUB     W4,W2,W4
0463E:  SUBB    W5,W3,W5
04640:  BSET.B  42.0
04642:  RLC     W6,W6
04644:  RLC     W7,W7
04646:  DEC     W8,W8
04648:  BRA     NZ,462A
0464A:  BTSS    W9.F
0464C:  BRA     465C
0464E:  NEG     W6,W0
04650:  BRA     Z,4654
04652:  BRA     NZ,4658
04654:  NEG     W7,W1
04656:  BRA     4662
04658:  COM     W7,W1
0465A:  BRA     4662
0465C:  MOV     W7,W1
0465E:  MOV     W6,W0
04660:  BRA     4662
04662:  MOV     [--W15],W9
04664:  CP0     W9
04666:  BRA     Z,466A
04668:  MOV.D   W4,W0
0466A:  MOV     #12,W5
0466C:  REPEAT  #3
0466E:  MOV     [--W15],[W5--]
04670:  MOV     [--W15],W5
04672:  RETURN  
*
04E3C:  MOV     W0,W3
04E3E:  SWAP    W1
04E40:  MOV.B   #5,W4L
04E42:  DEC.B   0003
04E44:  DEC.B   0008
04E46:  BRA     Z,4E6E
04E48:  MOV     W3,W0
04E4A:  SL      W3,#4,W3
04E4C:  LSR     W0,#C,W0
04E4E:  AND     #F,W0
04E50:  BRA     NZ,4E5A
04E52:  CP.B    W4L,#1
04E54:  BRA     Z,4E5A
04E56:  BTSS.B  3.7
04E58:  BRA     4E42
04E5A:  ADD     #30,W0
04E5C:  MOV     #3A,W2
04E5E:  CP      W0,W2
04E60:  BRA     NC,4E64
04E62:  ADD.B   2,W0L
04E64:  BTSC.B  223.1
04E66:  BRA     4E64
04E68:  MOV     W0,224
04E6A:  BSET.B  3.7
04E6C:  BRA     4E42
04E6E:  RETURN  
....................  
.................... #list 
....................  
....................  
.................... //   #fuses HS,PR_PLL,NOWDT,ICSP2,PLL5  did noy like 
....................    #fuses HS,PR_PLL,NOWDT,ICSP2 
....................    //C30/XC16 compiler to CCS PCH compiler compatability. 
....................    //also includes the filesystem. 
....................    //since this changes some #device settings, this needs to be include 
....................    //fairly soon in the build process. 
....................    #include "filesystem\filesystem.h"  
.................... //see about.txt in filesystem/ for information 
....................  
.................... #ifndef __FILESYSTEM_H__ 
.................... #define __FILESYSTEM_H__ 
....................  
.................... // If you cannot find these files, then change your include path 
.................... // to include the "CCSIncludes" directory.  This directory contains 
.................... // files that help port code from Microchip C to CCS C. 
.................... #if defined(__PCH__) 
....................    #include <p18cxxx.h> //Microchip C18 C Compiler to CCS PCH Conversion 
.................... #elif defined(__PCD__) 
....................    #define __CONST_IS_READONLY__ //work around for a difference between how CCS and C30 treats 'const' pointers 
....................    #include <CCSIncludes\PCDxxxx.h>  //Microchip C30 C Compiler to CCS PCH Conversion 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... // pcdxxxx.h 
.................... // 
.................... // Microchip C30 to CCS conversion library. 
....................  
.................... #ifndef __PCDXXXX_H__ 
.................... #define __PCDXXXX_H__ 
....................  
.................... #case 
....................  
.................... #include "ccspics.h" 
.................... //C18/C30 defines to CCS device h mapping 
....................  
.................... #ifndef __DEFINES_TO_CCS_H__ 
.................... #define __DEFINES_TO_CCS_H__ 
....................  
.................... #define __CCS__ 
....................  
.................... #if defined(__dsPIC14000__) || (getenv("DEVICE")=="DSPIC14000") 
....................     #if !defined(__dsPIC14000__) 
....................         #define __dsPIC14000__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <14000.h> 
....................     #endif 
....................     #if !defined(__dsPIC140000__) 
....................         #define __dsPIC140000__ 
....................     #endif 
....................     #include "14000_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C242) || (getenv("DEVICE")=="PIC18C242") 
....................     #if !defined(__18C242) 
....................         #define __18C242 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C242.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C242_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C252) || (getenv("DEVICE")=="PIC18C252") 
....................     #if !defined(__18C252) 
....................         #define __18C252 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C252.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C252_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C442) || (getenv("DEVICE")=="PIC18C442") 
....................     #if !defined(__18C442) 
....................         #define __18C442 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C442.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C442_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C452) || (getenv("DEVICE")=="PIC18C452") 
....................     #if !defined(__18C452) 
....................         #define __18C452 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C452.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C452_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C601) || (getenv("DEVICE")=="PIC18C601") 
....................     #if !defined(__18C601) 
....................         #define __18C601 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C601.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C601_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C658) || (getenv("DEVICE")=="PIC18C658") 
....................     #if !defined(__18C658) 
....................         #define __18C658 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C658.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C658_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C801) || (getenv("DEVICE")=="PIC18C801") 
....................     #if !defined(__18C801) 
....................         #define __18C801 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C801.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C801_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C858) || (getenv("DEVICE")=="PIC18C858") 
....................     #if !defined(__18C858) 
....................         #define __18C858 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C858.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C858_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F1220) || (getenv("DEVICE")=="PIC18F1220") 
....................     #if !defined(__18F1220) 
....................         #define __18F1220 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F1220.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F1220_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F1230) || (getenv("DEVICE")=="PIC18F1230") 
....................     #if !defined(__18F1230) 
....................         #define __18F1230 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F1230.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F1230_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F1320) || (getenv("DEVICE")=="PIC18F1320") 
....................     #if !defined(__18F1320) 
....................         #define __18F1320 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F1320.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F1320_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F1330) || (getenv("DEVICE")=="PIC18F1330") 
....................     #if !defined(__18F1330) 
....................         #define __18F1330 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F1330.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F1330_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F13K22) || (getenv("DEVICE")=="PIC18F13K22") 
....................     #if !defined(__18F13K22) 
....................         #define __18F13K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F13K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F13K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F13K50) || (getenv("DEVICE")=="PIC18F13K50") 
....................     #if !defined(__18F13K50) 
....................         #define __18F13K50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F13K50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F13K50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F14K22) || (getenv("DEVICE")=="PIC18F14K22") 
....................     #if !defined(__18F14K22) 
....................         #define __18F14K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F14K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F14K22_registers.h" 
.................... #endif 
....................  
.................... /* 
.................... #if defined(__18F14K50-ICD) || (getenv("DEVICE")=="PIC18F14K50-ICD") 
....................     #if !defined(__18F14K50-ICD) 
....................         #define __18F14K50-ICD 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F14K50-ICD.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F14K50-ICD_registers.h" 
.................... #endif 
.................... */ 
....................  
.................... #if defined(__18F14K50) || (getenv("DEVICE")=="PIC18F14K50") 
....................     #if !defined(__18F14K50) 
....................         #define __18F14K50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F14K50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F14K50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2220) || (getenv("DEVICE")=="PIC18F2220") 
....................     #if !defined(__18F2220) 
....................         #define __18F2220 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2220.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2220_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2221) || (getenv("DEVICE")=="PIC18F2221") 
....................     #if !defined(__18F2221) 
....................         #define __18F2221 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2221.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2221_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2320) || (getenv("DEVICE")=="PIC18F2320") 
....................     #if !defined(__18F2320) 
....................         #define __18F2320 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2320.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2320_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2321) || (getenv("DEVICE")=="PIC18F2321") 
....................     #if !defined(__18F2321) 
....................         #define __18F2321 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2321.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2321_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2331) || (getenv("DEVICE")=="PIC18F2331") 
....................     #if !defined(__18F2331) 
....................         #define __18F2331 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2331.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2331_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F23K20) || (getenv("DEVICE")=="PIC18F23K20") 
....................     #if !defined(__18F23K20) 
....................         #define __18F23K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F23K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F23K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F23K22) || (getenv("DEVICE")=="PIC18F23K22") 
....................     #if !defined(__18F23K22) 
....................         #define __18F23K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F23K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F23K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2410) || (getenv("DEVICE")=="PIC18F2410") 
....................     #if !defined(__18F2410) 
....................         #define __18F2410 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2410.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2410_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F242) || (getenv("DEVICE")=="PIC18F242") 
....................     #if !defined(__18F242) 
....................         #define __18F242 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F242.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F242_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2420) || (getenv("DEVICE")=="PIC18F2420") 
....................     #if !defined(__18F2420) 
....................         #define __18F2420 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2420.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2420_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2423) || (getenv("DEVICE")=="PIC18F2423") 
....................     #if !defined(__18F2423) 
....................         #define __18F2423 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2423.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2423_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2431) || (getenv("DEVICE")=="PIC18F2431") 
....................     #if !defined(__18F2431) 
....................         #define __18F2431 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2431.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2431_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2439) || (getenv("DEVICE")=="PIC18F2439") 
....................     #if !defined(__18F2439) 
....................         #define __18F2439 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2439.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2439_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2450) || (getenv("DEVICE")=="PIC18F2450") 
....................     #if !defined(__18F2450) 
....................         #define __18F2450 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2450.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2450_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2455) || (getenv("DEVICE")=="PIC18F2455") 
....................     #if !defined(__18F2455) 
....................         #define __18F2455 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2455.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2455_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2458) || (getenv("DEVICE")=="PIC18F2458") 
....................     #if !defined(__18F2458) 
....................         #define __18F2458 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2458.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2458_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F248) || (getenv("DEVICE")=="PIC18F248") 
....................     #if !defined(__18F248) 
....................         #define __18F248 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F248.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F248_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2480) || (getenv("DEVICE")=="PIC18F2480") 
....................     #if !defined(__18F2480) 
....................         #define __18F2480 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2480.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2480_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24J10) || (getenv("DEVICE")=="PIC18F24J10") 
....................     #if !defined(__18F24J10) 
....................         #define __18F24J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24J11) || (getenv("DEVICE")=="PIC18F24J11") 
....................     #if !defined(__18F24J11) 
....................         #define __18F24J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24J50) || (getenv("DEVICE")=="PIC18F24J50") 
....................     #if !defined(__18F24J50) 
....................         #define __18F24J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24K20) || (getenv("DEVICE")=="PIC18F24K20") 
....................     #if !defined(__18F24K20) 
....................         #define __18F24K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24K22) || (getenv("DEVICE")=="PIC18F24K22") 
....................     #if !defined(__18F24K22) 
....................         #define __18F24K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24K50) || (getenv("DEVICE")=="PIC18F24K50") 
....................     #if !defined(__18F24K50) 
....................         #define __18F24K50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24K50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24K50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2510) || (getenv("DEVICE")=="PIC18F2510") 
....................     #if !defined(__18F2510) 
....................         #define __18F2510 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2510.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2515) || (getenv("DEVICE")=="PIC18F2515") 
....................     #if !defined(__18F2515) 
....................         #define __18F2515 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2515.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2515_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F252) || (getenv("DEVICE")=="PIC18F252") 
....................     #if !defined(__18F252) 
....................         #define __18F252 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F252.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F252_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2520) || (getenv("DEVICE")=="PIC18F2520") 
....................     #if !defined(__18F2520) 
....................         #define __18F2520 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2520.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2520_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2523) || (getenv("DEVICE")=="PIC18F2523") 
....................     #if !defined(__18F2523) 
....................         #define __18F2523 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2523.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2523_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2525) || (getenv("DEVICE")=="PIC18F2525") 
....................     #if !defined(__18F2525) 
....................         #define __18F2525 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2525.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2525_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2539) || (getenv("DEVICE")=="PIC18F2539") 
....................     #if !defined(__18F2539) 
....................         #define __18F2539 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2539.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2539_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2550) || (getenv("DEVICE")=="PIC18F2550") 
....................     #if !defined(__18F2550) 
....................         #define __18F2550 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2550.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2550_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2553) || (getenv("DEVICE")=="PIC18F2553") 
....................     #if !defined(__18F2553) 
....................         #define __18F2553 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2553.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2553_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F258) || (getenv("DEVICE")=="PIC18F258") 
....................     #if !defined(__18F258) 
....................         #define __18F258 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F258.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F258_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2580) || (getenv("DEVICE")=="PIC18F2580") 
....................     #if !defined(__18F2580) 
....................         #define __18F2580 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2580.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2580_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2585) || (getenv("DEVICE")=="PIC18F2585") 
....................     #if !defined(__18F2585) 
....................         #define __18F2585 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2585.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2585_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25J10) || (getenv("DEVICE")=="PIC18F25J10") 
....................     #if !defined(__18F25J10) 
....................         #define __18F25J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25J11) || (getenv("DEVICE")=="PIC18F25J11") 
....................     #if !defined(__18F25J11) 
....................         #define __18F25J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25J50) || (getenv("DEVICE")=="PIC18F25J50") 
....................     #if !defined(__18F25J50) 
....................         #define __18F25J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25K20) || (getenv("DEVICE")=="PIC18F25K20") 
....................     #if !defined(__18F25K20) 
....................         #define __18F25K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25K22) || (getenv("DEVICE")=="PIC18F25K22") 
....................     #if !defined(__18F25K22) 
....................         #define __18F25K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25K50) || (getenv("DEVICE")=="PIC18F25K50") 
....................     #if !defined(__18F25K50) 
....................         #define __18F25K50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25K50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25K50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25K80) || (getenv("DEVICE")=="PIC18F25K80") 
....................     #if !defined(__18F25K80) 
....................         #define __18F25K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2610) || (getenv("DEVICE")=="PIC18F2610") 
....................     #if !defined(__18F2610) 
....................         #define __18F2610 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2610.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2610_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2620) || (getenv("DEVICE")=="PIC18F2620") 
....................     #if !defined(__18F2620) 
....................         #define __18F2620 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2620.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2680) || (getenv("DEVICE")=="PIC18F2680") 
....................     #if !defined(__18F2680) 
....................         #define __18F2680 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2680.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2680_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2682) || (getenv("DEVICE")=="PIC18F2682") 
....................     #if !defined(__18F2682) 
....................         #define __18F2682 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2682.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2682_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2685) || (getenv("DEVICE")=="PIC18F2685") 
....................     #if !defined(__18F2685) 
....................         #define __18F2685 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2685.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2685_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26J11) || (getenv("DEVICE")=="PIC18F26J11") 
....................     #if !defined(__18F26J11) 
....................         #define __18F26J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26J13) || (getenv("DEVICE")=="PIC18F26J13") 
....................     #if !defined(__18F26J13) 
....................         #define __18F26J13 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26J13.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26J13_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26J50) || (getenv("DEVICE")=="PIC18F26J50") 
....................     #if !defined(__18F26J50) 
....................         #define __18F26J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26J53) || (getenv("DEVICE")=="PIC18F26J53") 
....................     #if !defined(__18F26J53) 
....................         #define __18F26J53 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26J53.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26J53_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26K20) || (getenv("DEVICE")=="PIC18F26K20") 
....................     #if !defined(__18F26K20) 
....................         #define __18F26K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26K22) || (getenv("DEVICE")=="PIC18F26K22") 
....................     #if !defined(__18F26K22) 
....................         #define __18F26K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26K80) || (getenv("DEVICE")=="PIC18F26K80") 
....................     #if !defined(__18F26K80) 
....................         #define __18F26K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F27J13) || (getenv("DEVICE")=="PIC18F27J13") 
....................     #if !defined(__18F27J13) 
....................         #define __18F27J13 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F27J13.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F27J13_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F27J53) || (getenv("DEVICE")=="PIC18F27J53") 
....................     #if !defined(__18F27J53) 
....................         #define __18F27J53 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F27J53.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F27J53_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4220) || (getenv("DEVICE")=="PIC18F4220") 
....................     #if !defined(__18F4220) 
....................         #define __18F4220 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4220.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4220_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4221) || (getenv("DEVICE")=="PIC18F4221") 
....................     #if !defined(__18F4221) 
....................         #define __18F4221 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4221.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4221_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4320) || (getenv("DEVICE")=="PIC18F4320") 
....................     #if !defined(__18F4320) 
....................         #define __18F4320 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4320.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4320_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4321) || (getenv("DEVICE")=="PIC18F4321") 
....................     #if !defined(__18F4321) 
....................         #define __18F4321 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4321.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4321_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4331) || (getenv("DEVICE")=="PIC18F4331") 
....................     #if !defined(__18F4331) 
....................         #define __18F4331 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4331.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4331_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F43K20) || (getenv("DEVICE")=="PIC18F43K20") 
....................     #if !defined(__18F43K20) 
....................         #define __18F43K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F43K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F43K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F43K22) || (getenv("DEVICE")=="PIC18F43K22") 
....................     #if !defined(__18F43K22) 
....................         #define __18F43K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F43K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F43K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4410) || (getenv("DEVICE")=="PIC18F4410") 
....................     #if !defined(__18F4410) 
....................         #define __18F4410 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4410.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4410_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F442) || (getenv("DEVICE")=="PIC18F442") 
....................     #if !defined(__18F442) 
....................         #define __18F442 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F442.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F442_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4420) || (getenv("DEVICE")=="PIC18F4420") 
....................     #if !defined(__18F4420) 
....................         #define __18F4420 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4420.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4420_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4423) || (getenv("DEVICE")=="PIC18F4423") 
....................     #if !defined(__18F4423) 
....................         #define __18F4423 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4423.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4423_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4431) || (getenv("DEVICE")=="PIC18F4431") 
....................     #if !defined(__18F4431) 
....................         #define __18F4431 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4431.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4431_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4439) || (getenv("DEVICE")=="PIC18F4439") 
....................     #if !defined(__18F4439) 
....................         #define __18F4439 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4439.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4439_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4450) || (getenv("DEVICE")=="PIC18F4450") 
....................     #if !defined(__18F4450) 
....................         #define __18F4450 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4450.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4450_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4455) || (getenv("DEVICE")=="PIC18F4455") 
....................     #if !defined(__18F4455) 
....................         #define __18F4455 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4455.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4455_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4458) || (getenv("DEVICE")=="PIC18F4458") 
....................     #if !defined(__18F4458) 
....................         #define __18F4458 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4458.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4458_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F448) || (getenv("DEVICE")=="PIC18F448") 
....................     #if !defined(__18F448) 
....................         #define __18F448 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F448.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F448_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4480) || (getenv("DEVICE")=="PIC18F4480") 
....................     #if !defined(__18F4480) 
....................         #define __18F4480 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4480.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4480_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F44J10) || (getenv("DEVICE")=="PIC18F44J10") 
....................     #if !defined(__18F44J10) 
....................         #define __18F44J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F44J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F44J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F44J11) || (getenv("DEVICE")=="PIC18F44J11") 
....................     #if !defined(__18F44J11) 
....................         #define __18F44J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F44J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F44J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F44J50) || (getenv("DEVICE")=="PIC18F44J50") 
....................     #if !defined(__18F44J50) 
....................         #define __18F44J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F44J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F44J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F44K20) || (getenv("DEVICE")=="PIC18F44K20") 
....................     #if !defined(__18F44K20) 
....................         #define __18F44K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F44K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F44K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F44K22) || (getenv("DEVICE")=="PIC18F44K22") 
....................     #if !defined(__18F44K22) 
....................         #define __18F44K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F44K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F44K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4510) || (getenv("DEVICE")=="PIC18F4510") 
....................     #if !defined(__18F4510) 
....................         #define __18F4510 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4510.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4515) || (getenv("DEVICE")=="PIC18F4515") 
....................     #if !defined(__18F4515) 
....................         #define __18F4515 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4515.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4515_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F452) || (getenv("DEVICE")=="PIC18F452") 
....................     #if !defined(__18F452) 
....................         #define __18F452 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F452.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F452_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4520) || (getenv("DEVICE")=="PIC18F4520") 
....................     #if !defined(__18F4520) 
....................         #define __18F4520 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4520.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4520_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4523) || (getenv("DEVICE")=="PIC18F4523") 
....................     #if !defined(__18F4523) 
....................         #define __18F4523 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4523.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4523_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4525) || (getenv("DEVICE")=="PIC18F4525") 
....................     #if !defined(__18F4525) 
....................         #define __18F4525 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4525.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4525_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4539) || (getenv("DEVICE")=="PIC18F4539") 
....................     #if !defined(__18F4539) 
....................         #define __18F4539 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4539.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4539_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4550) || (getenv("DEVICE")=="PIC18F4550") 
....................     #if !defined(__18F4550) 
....................         #define __18F4550 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4550.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4550_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4553) || (getenv("DEVICE")=="PIC18F4553") 
....................     #if !defined(__18F4553) 
....................         #define __18F4553 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4553.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4553_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F458) || (getenv("DEVICE")=="PIC18F458") 
....................     #if !defined(__18F458) 
....................         #define __18F458 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F458.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F458_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4580) || (getenv("DEVICE")=="PIC18F4580") 
....................     #if !defined(__18F4580) 
....................         #define __18F4580 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4580.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4580_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4585) || (getenv("DEVICE")=="PIC18F4585") 
....................     #if !defined(__18F4585) 
....................         #define __18F4585 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4585.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4585_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45J10) || (getenv("DEVICE")=="PIC18F45J10") 
....................     #if !defined(__18F45J10) 
....................         #define __18F45J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45J11) || (getenv("DEVICE")=="PIC18F45J11") 
....................     #if !defined(__18F45J11) 
....................         #define __18F45J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45J50) || (getenv("DEVICE")=="PIC18F45J50") 
....................     #if !defined(__18F45J50) 
....................         #define __18F45J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45K20) || (getenv("DEVICE")=="PIC18F45K20") 
....................     #if !defined(__18F45K20) 
....................         #define __18F45K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45K22) || (getenv("DEVICE")=="PIC18F45K22") 
....................     #if !defined(__18F45K22) 
....................         #define __18F45K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45K50) || (getenv("DEVICE")=="PIC18F45K50") 
....................     #if !defined(__18F45K50) 
....................         #define __18F45K50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45K50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45K50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45K80) || (getenv("DEVICE")=="PIC18F45K80") 
....................     #if !defined(__18F45K80) 
....................         #define __18F45K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4610) || (getenv("DEVICE")=="PIC18F4610") 
....................     #if !defined(__18F4610) 
....................         #define __18F4610 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4610.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4610_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4620) || (getenv("DEVICE")=="PIC18F4620") 
....................     #if !defined(__18F4620) 
....................         #define __18F4620 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4620.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4680) || (getenv("DEVICE")=="PIC18F4680") 
....................     #if !defined(__18F4680) 
....................         #define __18F4680 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4680.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4680_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4682) || (getenv("DEVICE")=="PIC18F4682") 
....................     #if !defined(__18F4682) 
....................         #define __18F4682 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4682.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4682_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4685) || (getenv("DEVICE")=="PIC18F4685") 
....................     #if !defined(__18F4685) 
....................         #define __18F4685 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4685.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4685_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46J11) || (getenv("DEVICE")=="PIC18F46J11") 
....................     #if !defined(__18F46J11) 
....................         #define __18F46J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46J13) || (getenv("DEVICE")=="PIC18F46J13") 
....................     #if !defined(__18F46J13) 
....................         #define __18F46J13 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46J13.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46J13_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46J50) || (getenv("DEVICE")=="PIC18F46J50") 
....................     #if !defined(__18F46J50) 
....................         #define __18F46J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46J53) || (getenv("DEVICE")=="PIC18F46J53") 
....................     #if !defined(__18F46J53) 
....................         #define __18F46J53 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46J53.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46J53_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46K20) || (getenv("DEVICE")=="PIC18F46K20") 
....................     #if !defined(__18F46K20) 
....................         #define __18F46K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46K22) || (getenv("DEVICE")=="PIC18F46K22") 
....................     #if !defined(__18F46K22) 
....................         #define __18F46K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46K80) || (getenv("DEVICE")=="PIC18F46K80") 
....................     #if !defined(__18F46K80) 
....................         #define __18F46K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F47J13) || (getenv("DEVICE")=="PIC18F47J13") 
....................     #if !defined(__18F47J13) 
....................         #define __18F47J13 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F47J13.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F47J13_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F47J53) || (getenv("DEVICE")=="PIC18F47J53") 
....................     #if !defined(__18F47J53) 
....................         #define __18F47J53 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F47J53.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F47J53_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6310) || (getenv("DEVICE")=="PIC18F6310") 
....................     #if !defined(__18F6310) 
....................         #define __18F6310 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6310.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6390) || (getenv("DEVICE")=="PIC18F6390") 
....................     #if !defined(__18F6390) 
....................         #define __18F6390 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6390.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6390_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6393) || (getenv("DEVICE")=="PIC18F6393") 
....................     #if !defined(__18F6393) 
....................         #define __18F6393 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6393.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6393_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F63J11) || (getenv("DEVICE")=="PIC18F63J11") 
....................     #if !defined(__18F63J11) 
....................         #define __18F63J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F63J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F63J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F63J90) || (getenv("DEVICE")=="PIC18F63J90") 
....................     #if !defined(__18F63J90) 
....................         #define __18F63J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F63J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F63J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6410) || (getenv("DEVICE")=="PIC18F6410") 
....................     #if !defined(__18F6410) 
....................         #define __18F6410 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6410.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6410_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6490) || (getenv("DEVICE")=="PIC18F6490") 
....................     #if !defined(__18F6490) 
....................         #define __18F6490 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6490.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6490_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6493) || (getenv("DEVICE")=="PIC18F6493") 
....................     #if !defined(__18F6493) 
....................         #define __18F6493 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6493.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6493_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F64J11) || (getenv("DEVICE")=="PIC18F64J11") 
....................     #if !defined(__18F64J11) 
....................         #define __18F64J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F64J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F64J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F64J90) || (getenv("DEVICE")=="PIC18F64J90") 
....................     #if !defined(__18F64J90) 
....................         #define __18F64J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F64J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F64J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6520) || (getenv("DEVICE")=="PIC18F6520") 
....................     #if !defined(__18F6520) 
....................         #define __18F6520 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6520.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6520_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6525) || (getenv("DEVICE")=="PIC18F6525") 
....................     #if !defined(__18F6525) 
....................         #define __18F6525 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6525.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6525_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6527) || (getenv("DEVICE")=="PIC18F6527") 
....................     #if !defined(__18F6527) 
....................         #define __18F6527 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6527.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6527_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6585) || (getenv("DEVICE")=="PIC18F6585") 
....................     #if !defined(__18F6585) 
....................         #define __18F6585 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6585.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6585_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J10) || (getenv("DEVICE")=="PIC18F65J10") 
....................     #if !defined(__18F65J10) 
....................         #define __18F65J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J11) || (getenv("DEVICE")=="PIC18F65J11") 
....................     #if !defined(__18F65J11) 
....................         #define __18F65J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J15) || (getenv("DEVICE")=="PIC18F65J15") 
....................     #if !defined(__18F65J15) 
....................         #define __18F65J15 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J15.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J15_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J50) || (getenv("DEVICE")=="PIC18F65J50") 
....................     #if !defined(__18F65J50) 
....................         #define __18F65J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J90) || (getenv("DEVICE")=="PIC18F65J90") 
....................     #if !defined(__18F65J90) 
....................         #define __18F65J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J94) || (getenv("DEVICE")=="PIC18F65J94") 
....................     #if !defined(__18F65J94) 
....................         #define __18F65J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65K22) || (getenv("DEVICE")=="PIC18F65K22") 
....................     #if !defined(__18F65K22) 
....................         #define __18F65K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65K80) || (getenv("DEVICE")=="PIC18F65K80") 
....................     #if !defined(__18F65K80) 
....................         #define __18F65K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65K90) || (getenv("DEVICE")=="PIC18F65K90") 
....................     #if !defined(__18F65K90) 
....................         #define __18F65K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6620) || (getenv("DEVICE")=="PIC18F6620") 
....................     #if !defined(__18F6620) 
....................         #define __18F6620 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6620.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6621) || (getenv("DEVICE")=="PIC18F6621") 
....................     #if !defined(__18F6621) 
....................         #define __18F6621 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6621.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6621_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6622) || (getenv("DEVICE")=="PIC18F6622") 
....................     #if !defined(__18F6622) 
....................         #define __18F6622 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6622.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6622_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6627) || (getenv("DEVICE")=="PIC18F6627") 
....................     #if !defined(__18F6627) 
....................         #define __18F6627 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6627.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6627_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6628) || (getenv("DEVICE")=="PIC18F6628") 
....................     #if !defined(__18F6628) 
....................         #define __18F6628 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6628.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6628_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6680) || (getenv("DEVICE")=="PIC18F6680") 
....................     #if !defined(__18F6680) 
....................         #define __18F6680 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6680.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6680_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J10) || (getenv("DEVICE")=="PIC18F66J10") 
....................     #if !defined(__18F66J10) 
....................         #define __18F66J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J11) || (getenv("DEVICE")=="PIC18F66J11") 
....................     #if !defined(__18F66J11) 
....................         #define __18F66J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J15) || (getenv("DEVICE")=="PIC18F66J15") 
....................     #if !defined(__18F66J15) 
....................         #define __18F66J15 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J15.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J15_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J16) || (getenv("DEVICE")=="PIC18F66J16") 
....................     #if !defined(__18F66J16) 
....................         #define __18F66J16 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J16.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J16_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J50) || (getenv("DEVICE")=="PIC18F66J50") 
....................     #if !defined(__18F66J50) 
....................         #define __18F66J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J55) || (getenv("DEVICE")=="PIC18F66J55") 
....................     #if !defined(__18F66J55) 
....................         #define __18F66J55 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J55.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J55_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J60) || (getenv("DEVICE")=="PIC18F66J60") 
....................     #if !defined(__18F66J60) 
....................         #define __18F66J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J65) || (getenv("DEVICE")=="PIC18F66J65") 
....................     #if !defined(__18F66J65) 
....................         #define __18F66J65 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J65.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J65_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J90) || (getenv("DEVICE")=="PIC18F66J90") 
....................     #if !defined(__18F66J90) 
....................         #define __18F66J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J93) || (getenv("DEVICE")=="PIC18F66J93") 
....................     #if !defined(__18F66J93) 
....................         #define __18F66J93 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J93.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J93_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J94) || (getenv("DEVICE")=="PIC18F66J94") 
....................     #if !defined(__18F66J94) 
....................         #define __18F66J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J99) || (getenv("DEVICE")=="PIC18F66J99") 
....................     #if !defined(__18F66J99) 
....................         #define __18F66J99 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J99.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J99_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66K22) || (getenv("DEVICE")=="PIC18F66K22") 
....................     #if !defined(__18F66K22) 
....................         #define __18F66K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66K80) || (getenv("DEVICE")=="PIC18F66K80") 
....................     #if !defined(__18F66K80) 
....................         #define __18F66K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66K90) || (getenv("DEVICE")=="PIC18F66K90") 
....................     #if !defined(__18F66K90) 
....................         #define __18F66K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6720) || (getenv("DEVICE")=="PIC18F6720") 
....................     #if !defined(__18F6720) 
....................         #define __18F6720 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6720.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6720_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6722) || (getenv("DEVICE")=="PIC18F6722") 
....................     #if !defined(__18F6722) 
....................         #define __18F6722 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6722.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6722_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6723) || (getenv("DEVICE")=="PIC18F6723") 
....................     #if !defined(__18F6723) 
....................         #define __18F6723 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6723.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6723_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J10) || (getenv("DEVICE")=="PIC18F67J10") 
....................     #if !defined(__18F67J10) 
....................         #define __18F67J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J11) || (getenv("DEVICE")=="PIC18F67J11") 
....................     #if !defined(__18F67J11) 
....................         #define __18F67J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J50) || (getenv("DEVICE")=="PIC18F67J50") 
....................     #if !defined(__18F67J50) 
....................         #define __18F67J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J60) || (getenv("DEVICE")=="PIC18F67J60") 
....................     #if !defined(__18F67J60) 
....................         #define __18F67J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J90) || (getenv("DEVICE")=="PIC18F67J90") 
....................     #if !defined(__18F67J90) 
....................         #define __18F67J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J93) || (getenv("DEVICE")=="PIC18F67J93") 
....................     #if !defined(__18F67J93) 
....................         #define __18F67J93 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J93.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J93_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J94) || (getenv("DEVICE")=="PIC18F67J94") 
....................     #if !defined(__18F67J94) 
....................         #define __18F67J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67K22) || (getenv("DEVICE")=="PIC18F67K22") 
....................     #if !defined(__18F67K22) 
....................         #define __18F67K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67K90) || (getenv("DEVICE")=="PIC18F67K90") 
....................     #if !defined(__18F67K90) 
....................         #define __18F67K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8310) || (getenv("DEVICE")=="PIC18F8310") 
....................     #if !defined(__18F8310) 
....................         #define __18F8310 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8310.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8390) || (getenv("DEVICE")=="PIC18F8390") 
....................     #if !defined(__18F8390) 
....................         #define __18F8390 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8390.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8390_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8393) || (getenv("DEVICE")=="PIC18F8393") 
....................     #if !defined(__18F8393) 
....................         #define __18F8393 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8393.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8393_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F83J11) || (getenv("DEVICE")=="PIC18F83J11") 
....................     #if !defined(__18F83J11) 
....................         #define __18F83J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F83J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F83J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F83J90) || (getenv("DEVICE")=="PIC18F83J90") 
....................     #if !defined(__18F83J90) 
....................         #define __18F83J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F83J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F83J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8410) || (getenv("DEVICE")=="PIC18F8410") 
....................     #if !defined(__18F8410) 
....................         #define __18F8410 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8410.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8410_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8490) || (getenv("DEVICE")=="PIC18F8490") 
....................     #if !defined(__18F8490) 
....................         #define __18F8490 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8490.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8490_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8493) || (getenv("DEVICE")=="PIC18F8493") 
....................     #if !defined(__18F8493) 
....................         #define __18F8493 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8493.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8493_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F84J11) || (getenv("DEVICE")=="PIC18F84J11") 
....................     #if !defined(__18F84J11) 
....................         #define __18F84J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F84J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F84J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F84J90) || (getenv("DEVICE")=="PIC18F84J90") 
....................     #if !defined(__18F84J90) 
....................         #define __18F84J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F84J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F84J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8520) || (getenv("DEVICE")=="PIC18F8520") 
....................     #if !defined(__18F8520) 
....................         #define __18F8520 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8520.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8520_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8525) || (getenv("DEVICE")=="PIC18F8525") 
....................     #if !defined(__18F8525) 
....................         #define __18F8525 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8525.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8525_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8527) || (getenv("DEVICE")=="PIC18F8527") 
....................     #if !defined(__18F8527) 
....................         #define __18F8527 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8527.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8527_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8585) || (getenv("DEVICE")=="PIC18F8585") 
....................     #if !defined(__18F8585) 
....................         #define __18F8585 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8585.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8585_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J10) || (getenv("DEVICE")=="PIC18F85J10") 
....................     #if !defined(__18F85J10) 
....................         #define __18F85J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J11) || (getenv("DEVICE")=="PIC18F85J11") 
....................     #if !defined(__18F85J11) 
....................         #define __18F85J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J15) || (getenv("DEVICE")=="PIC18F85J15") 
....................     #if !defined(__18F85J15) 
....................         #define __18F85J15 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J15.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J15_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J50) || (getenv("DEVICE")=="PIC18F85J50") 
....................     #if !defined(__18F85J50) 
....................         #define __18F85J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J90) || (getenv("DEVICE")=="PIC18F85J90") 
....................     #if !defined(__18F85J90) 
....................         #define __18F85J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J94) || (getenv("DEVICE")=="PIC18F85J94") 
....................     #if !defined(__18F85J94) 
....................         #define __18F85J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85K22) || (getenv("DEVICE")=="PIC18F85K22") 
....................     #if !defined(__18F85K22) 
....................         #define __18F85K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85K90) || (getenv("DEVICE")=="PIC18F85K90") 
....................     #if !defined(__18F85K90) 
....................         #define __18F85K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8620) || (getenv("DEVICE")=="PIC18F8620") 
....................     #if !defined(__18F8620) 
....................         #define __18F8620 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8620.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8621) || (getenv("DEVICE")=="PIC18F8621") 
....................     #if !defined(__18F8621) 
....................         #define __18F8621 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8621.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8621_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8622) || (getenv("DEVICE")=="PIC18F8622") 
....................     #if !defined(__18F8622) 
....................         #define __18F8622 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8622.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8622_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8627) || (getenv("DEVICE")=="PIC18F8627") 
....................     #if !defined(__18F8627) 
....................         #define __18F8627 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8627.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8627_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8628) || (getenv("DEVICE")=="PIC18F8628") 
....................     #if !defined(__18F8628) 
....................         #define __18F8628 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8628.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8628_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8680) || (getenv("DEVICE")=="PIC18F8680") 
....................     #if !defined(__18F8680) 
....................         #define __18F8680 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8680.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8680_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J10) || (getenv("DEVICE")=="PIC18F86J10") 
....................     #if !defined(__18F86J10) 
....................         #define __18F86J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J11) || (getenv("DEVICE")=="PIC18F86J11") 
....................     #if !defined(__18F86J11) 
....................         #define __18F86J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J15) || (getenv("DEVICE")=="PIC18F86J15") 
....................     #if !defined(__18F86J15) 
....................         #define __18F86J15 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J15.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J15_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J16) || (getenv("DEVICE")=="PIC18F86J16") 
....................     #if !defined(__18F86J16) 
....................         #define __18F86J16 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J16.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J16_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J50) || (getenv("DEVICE")=="PIC18F86J50") 
....................     #if !defined(__18F86J50) 
....................         #define __18F86J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J55) || (getenv("DEVICE")=="PIC18F86J55") 
....................     #if !defined(__18F86J55) 
....................         #define __18F86J55 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J55.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J55_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J60) || (getenv("DEVICE")=="PIC18F86J60") 
....................     #if !defined(__18F86J60) 
....................         #define __18F86J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J65) || (getenv("DEVICE")=="PIC18F86J65") 
....................     #if !defined(__18F86J65) 
....................         #define __18F86J65 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J65.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J65_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J72) || (getenv("DEVICE")=="PIC18F86J72") 
....................     #if !defined(__18F86J72) 
....................         #define __18F86J72 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J72.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J72_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J90) || (getenv("DEVICE")=="PIC18F86J90") 
....................     #if !defined(__18F86J90) 
....................         #define __18F86J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J93) || (getenv("DEVICE")=="PIC18F86J93") 
....................     #if !defined(__18F86J93) 
....................         #define __18F86J93 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J93.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J93_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J94) || (getenv("DEVICE")=="PIC18F86J94") 
....................     #if !defined(__18F86J94) 
....................         #define __18F86J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J99) || (getenv("DEVICE")=="PIC18F86J99") 
....................     #if !defined(__18F86J99) 
....................         #define __18F86J99 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J99.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J99_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86K22) || (getenv("DEVICE")=="PIC18F86K22") 
....................     #if !defined(__18F86K22) 
....................         #define __18F86K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86K90) || (getenv("DEVICE")=="PIC18F86K90") 
....................     #if !defined(__18F86K90) 
....................         #define __18F86K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8720) || (getenv("DEVICE")=="PIC18F8720") 
....................     #if !defined(__18F8720) 
....................         #define __18F8720 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8720.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8720_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8722) || (getenv("DEVICE")=="PIC18F8722") 
....................     #if !defined(__18F8722) 
....................         #define __18F8722 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8722.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8722_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8723) || (getenv("DEVICE")=="PIC18F8723") 
....................     #if !defined(__18F8723) 
....................         #define __18F8723 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8723.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8723_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J10) || (getenv("DEVICE")=="PIC18F87J10") 
....................     #if !defined(__18F87J10) 
....................         #define __18F87J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J11) || (getenv("DEVICE")=="PIC18F87J11") 
....................     #if !defined(__18F87J11) 
....................         #define __18F87J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J50) || (getenv("DEVICE")=="PIC18F87J50") 
....................     #if !defined(__18F87J50) 
....................         #define __18F87J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J60) || (getenv("DEVICE")=="PIC18F87J60") 
....................     #if !defined(__18F87J60) 
....................         #define __18F87J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J72) || (getenv("DEVICE")=="PIC18F87J72") 
....................     #if !defined(__18F87J72) 
....................         #define __18F87J72 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J72.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J72_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J90) || (getenv("DEVICE")=="PIC18F87J90") 
....................     #if !defined(__18F87J90) 
....................         #define __18F87J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J93) || (getenv("DEVICE")=="PIC18F87J93") 
....................     #if !defined(__18F87J93) 
....................         #define __18F87J93 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J93.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J93_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J94) || (getenv("DEVICE")=="PIC18F87J94") 
....................     #if !defined(__18F87J94) 
....................         #define __18F87J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87K22) || (getenv("DEVICE")=="PIC18F87K22") 
....................     #if !defined(__18F87K22) 
....................         #define __18F87K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87K90) || (getenv("DEVICE")=="PIC18F87K90") 
....................     #if !defined(__18F87K90) 
....................         #define __18F87K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F95J94) || (getenv("DEVICE")=="PIC18F95J94") 
....................     #if !defined(__18F95J94) 
....................         #define __18F95J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F95J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F95J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F96J60) || (getenv("DEVICE")=="PIC18F96J60") 
....................     #if !defined(__18F96J60) 
....................         #define __18F96J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F96J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F96J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F96J65) || (getenv("DEVICE")=="PIC18F96J65") 
....................     #if !defined(__18F96J65) 
....................         #define __18F96J65 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F96J65.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F96J65_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F96J94) || (getenv("DEVICE")=="PIC18F96J94") 
....................     #if !defined(__18F96J94) 
....................         #define __18F96J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F96J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F96J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F96J99) || (getenv("DEVICE")=="PIC18F96J99") 
....................     #if !defined(__18F96J99) 
....................         #define __18F96J99 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F96J99.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F96J99_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || (getenv("DEVICE")=="PIC18F97J60") 
....................     #if !defined(__18F97J60) 
....................         #define __18F97J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F97J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F97J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F97J94) || (getenv("DEVICE")=="PIC18F97J94") 
....................     #if !defined(__18F97J94) 
....................         #define __18F97J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F97J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F97J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC19111__) || (getenv("DEVICE")=="DSPIC19111") 
....................     #if !defined(__dsPIC19111__) 
....................         #define __dsPIC19111__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <19111.h> 
....................     #endif 
....................     #if !defined(__dsPIC191111__) 
....................         #define __dsPIC191111__ 
....................     #endif 
....................     #include "19111_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128GP202__) || (getenv("DEVICE")=="PIC24EP128GP202") 
....................     #if !defined(__PIC24EP128GP202__) 
....................         #define __PIC24EP128GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128GP204__) || (getenv("DEVICE")=="PIC24EP128GP204") 
....................     #if !defined(__PIC24EP128GP204__) 
....................         #define __PIC24EP128GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128GP206__) || (getenv("DEVICE")=="PIC24EP128GP206") 
....................     #if !defined(__PIC24EP128GP206__) 
....................         #define __PIC24EP128GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128MC202__) || (getenv("DEVICE")=="PIC24EP128MC202") 
....................     #if !defined(__PIC24EP128MC202__) 
....................         #define __PIC24EP128MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128MC202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128MC204__) || (getenv("DEVICE")=="PIC24EP128MC204") 
....................     #if !defined(__PIC24EP128MC204__) 
....................         #define __PIC24EP128MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128MC204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128MC206__) || (getenv("DEVICE")=="PIC24EP128MC206") 
....................     #if !defined(__PIC24EP128MC206__) 
....................         #define __PIC24EP128MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128MC206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256GP202__) || (getenv("DEVICE")=="PIC24EP256GP202") 
....................     #if !defined(__PIC24EP256GP202__) 
....................         #define __PIC24EP256GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256GP204__) || (getenv("DEVICE")=="PIC24EP256GP204") 
....................     #if !defined(__PIC24EP256GP204__) 
....................         #define __PIC24EP256GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256GP206__) || (getenv("DEVICE")=="PIC24EP256GP206") 
....................     #if !defined(__PIC24EP256GP206__) 
....................         #define __PIC24EP256GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256GU810__) || (getenv("DEVICE")=="PIC24EP256GU810") 
....................     #if !defined(__PIC24EP256GU810__) 
....................         #define __PIC24EP256GU810__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256GU810.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256GU810_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256GU814__) || (getenv("DEVICE")=="PIC24EP256GU814") 
....................     #if !defined(__PIC24EP256GU814__) 
....................         #define __PIC24EP256GU814__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256GU814.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256GU814_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256MC202__) || (getenv("DEVICE")=="PIC24EP256MC202") 
....................     #if !defined(__PIC24EP256MC202__) 
....................         #define __PIC24EP256MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256MC202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256MC204__) || (getenv("DEVICE")=="PIC24EP256MC204") 
....................     #if !defined(__PIC24EP256MC204__) 
....................         #define __PIC24EP256MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256MC204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256MC206__) || (getenv("DEVICE")=="PIC24EP256MC206") 
....................     #if !defined(__PIC24EP256MC206__) 
....................         #define __PIC24EP256MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256MC206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32GP202__) || (getenv("DEVICE")=="PIC24EP32GP202") 
....................     #if !defined(__PIC24EP32GP202__) 
....................         #define __PIC24EP32GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32GP203__) || (getenv("DEVICE")=="PIC24EP32GP203") 
....................     #if !defined(__PIC24EP32GP203__) 
....................         #define __PIC24EP32GP203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32GP203.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32GP203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32GP204__) || (getenv("DEVICE")=="PIC24EP32GP204") 
....................     #if !defined(__PIC24EP32GP204__) 
....................         #define __PIC24EP32GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32MC202__) || (getenv("DEVICE")=="PIC24EP32MC202") 
....................     #if !defined(__PIC24EP32MC202__) 
....................         #define __PIC24EP32MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32MC202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32MC203__) || (getenv("DEVICE")=="PIC24EP32MC203") 
....................     #if !defined(__PIC24EP32MC203__) 
....................         #define __PIC24EP32MC203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32MC203.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32MC203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32MC204__) || (getenv("DEVICE")=="PIC24EP32MC204") 
....................     #if !defined(__PIC24EP32MC204__) 
....................         #define __PIC24EP32MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32MC204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP512GP806__) || (getenv("DEVICE")=="PIC24EP512GP806") 
....................     #if !defined(__PIC24EP512GP806__) 
....................         #define __PIC24EP512GP806__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP512GP806.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP512GP806_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP512GU810__) || (getenv("DEVICE")=="PIC24EP512GU810") 
....................     #if !defined(__PIC24EP512GU810__) 
....................         #define __PIC24EP512GU810__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP512GU810.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP512GU810_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP512GU814__) || (getenv("DEVICE")=="PIC24EP512GU814") 
....................     #if !defined(__PIC24EP512GU814__) 
....................         #define __PIC24EP512GU814__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP512GU814.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP512GU814_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64GP202__) || (getenv("DEVICE")=="PIC24EP64GP202") 
....................     #if !defined(__PIC24EP64GP202__) 
....................         #define __PIC24EP64GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64GP203__) || (getenv("DEVICE")=="PIC24EP64GP203") 
....................     #if !defined(__PIC24EP64GP203__) 
....................         #define __PIC24EP64GP203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64GP203.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64GP203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64GP204__) || (getenv("DEVICE")=="PIC24EP64GP204") 
....................     #if !defined(__PIC24EP64GP204__) 
....................         #define __PIC24EP64GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64GP206__) || (getenv("DEVICE")=="PIC24EP64GP206") 
....................     #if !defined(__PIC24EP64GP206__) 
....................         #define __PIC24EP64GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64MC202__) || (getenv("DEVICE")=="PIC24EP64MC202") 
....................     #if !defined(__PIC24EP64MC202__) 
....................         #define __PIC24EP64MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64MC202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64MC203__) || (getenv("DEVICE")=="PIC24EP64MC203") 
....................     #if !defined(__PIC24EP64MC203__) 
....................         #define __PIC24EP64MC203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64MC203.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64MC203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64MC204__) || (getenv("DEVICE")=="PIC24EP64MC204") 
....................     #if !defined(__PIC24EP64MC204__) 
....................         #define __PIC24EP64MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64MC204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64MC206__) || (getenv("DEVICE")=="PIC24EP64MC206") 
....................     #if !defined(__PIC24EP64MC206__) 
....................         #define __PIC24EP64MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64MC206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F04KA200__) || (getenv("DEVICE")=="PIC24F04KA200") 
....................     #if !defined(__PIC24F04KA200__) 
....................         #define __PIC24F04KA200__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F04KA200.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F04KA200_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F04KA201__) || (getenv("DEVICE")=="PIC24F04KA201") 
....................     #if !defined(__PIC24F04KA201__) 
....................         #define __PIC24F04KA201__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F04KA201.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F04KA201_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F04KL100__) || (getenv("DEVICE")=="PIC24F04KL100") 
....................     #if !defined(__PIC24F04KL100__) 
....................         #define __PIC24F04KL100__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F04KL100.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F04KL100_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F04KL101__) || (getenv("DEVICE")=="PIC24F04KL101") 
....................     #if !defined(__PIC24F04KL101__) 
....................         #define __PIC24F04KL101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F04KL101.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F04KL101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KA101__) || (getenv("DEVICE")=="PIC24F08KA101") 
....................     #if !defined(__PIC24F08KA101__) 
....................         #define __PIC24F08KA101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KA101.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F08KA101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KA102__) || (getenv("DEVICE")=="PIC24F08KA102") 
....................     #if !defined(__PIC24F08KA102__) 
....................         #define __PIC24F08KA102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KA102.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F08KA102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL200__) || (getenv("DEVICE")=="PIC24F08KL200") 
....................     #if !defined(__PIC24F08KL200__) 
....................         #define __PIC24F08KL200__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL200.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL200_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL201__) || (getenv("DEVICE")=="PIC24F08KL201") 
....................     #if !defined(__PIC24F08KL201__) 
....................         #define __PIC24F08KL201__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL201.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL201_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL301__) || (getenv("DEVICE")=="PIC24F08KL301") 
....................     #if !defined(__PIC24F08KL301__) 
....................         #define __PIC24F08KL301__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL301.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL301_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL302__) || (getenv("DEVICE")=="PIC24F08KL302") 
....................     #if !defined(__PIC24F08KL302__) 
....................         #define __PIC24F08KL302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL302.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL401__) || (getenv("DEVICE")=="PIC24F08KL401") 
....................     #if !defined(__PIC24F08KL401__) 
....................         #define __PIC24F08KL401__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL401.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL401_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL402__) || (getenv("DEVICE")=="PIC24F08KL402") 
....................     #if !defined(__PIC24F08KL402__) 
....................         #define __PIC24F08KL402__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL402.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL402_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KM101__) || (getenv("DEVICE")=="PIC24F08KM101") 
....................     #if !defined(__PIC24F08KM101__) 
....................         #define __PIC24F08KM101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KM101.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KM101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KM102__) || (getenv("DEVICE")=="PIC24F08KM102") 
....................     #if !defined(__PIC24F08KM102__) 
....................         #define __PIC24F08KM102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KM102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KM102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KM202__) || (getenv("DEVICE")=="PIC24F08KM202") 
....................     #if !defined(__PIC24F08KM202__) 
....................         #define __PIC24F08KM202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KM202.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KM202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KM204__) || (getenv("DEVICE")=="PIC24F08KM204") 
....................     #if !defined(__PIC24F08KM204__) 
....................         #define __PIC24F08KM204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KM204.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KM204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KA101__) || (getenv("DEVICE")=="PIC24F16KA101") 
....................     #if !defined(__PIC24F16KA101__) 
....................         #define __PIC24F16KA101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KA101.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F16KA101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KA102__) || (getenv("DEVICE")=="PIC24F16KA102") 
....................     #if !defined(__PIC24F16KA102__) 
....................         #define __PIC24F16KA102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KA102.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F16KA102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KA301__) || (getenv("DEVICE")=="PIC24F16KA301") 
....................     #if !defined(__PIC24F16KA301__) 
....................         #define __PIC24F16KA301__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KA301.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F16KA301_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KA302__) || (getenv("DEVICE")=="PIC24F16KA302") 
....................     #if !defined(__PIC24F16KA302__) 
....................         #define __PIC24F16KA302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KA302.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F16KA302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KA304__) || (getenv("DEVICE")=="PIC24F16KA304") 
....................     #if !defined(__PIC24F16KA304__) 
....................         #define __PIC24F16KA304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KA304.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F16KA304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KL401__) || (getenv("DEVICE")=="PIC24F16KL401") 
....................     #if !defined(__PIC24F16KL401__) 
....................         #define __PIC24F16KL401__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KL401.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KL401_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KL402__) || (getenv("DEVICE")=="PIC24F16KL402") 
....................     #if !defined(__PIC24F16KL402__) 
....................         #define __PIC24F16KL402__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KL402.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KL402_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KM102__) || (getenv("DEVICE")=="PIC24F16KM102") 
....................     #if !defined(__PIC24F16KM102__) 
....................         #define __PIC24F16KM102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KM102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KM102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KM104__) || (getenv("DEVICE")=="PIC24F16KM104") 
....................     #if !defined(__PIC24F16KM104__) 
....................         #define __PIC24F16KM104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KM104.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KM104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KM202__) || (getenv("DEVICE")=="PIC24F16KM202") 
....................     #if !defined(__PIC24F16KM202__) 
....................         #define __PIC24F16KM202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KM202.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KM202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KM204__) || (getenv("DEVICE")=="PIC24F16KM204") 
....................     #if !defined(__PIC24F16KM204__) 
....................         #define __PIC24F16KM204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KM204.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KM204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F32KA301__) || (getenv("DEVICE")=="PIC24F32KA301") 
....................     #if !defined(__PIC24F32KA301__) 
....................         #define __PIC24F32KA301__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F32KA301.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F32KA301_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F32KA302__) || (getenv("DEVICE")=="PIC24F32KA302") 
....................     #if !defined(__PIC24F32KA302__) 
....................         #define __PIC24F32KA302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F32KA302.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F32KA302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F32KA304__) || (getenv("DEVICE")=="PIC24F32KA304") 
....................     #if !defined(__PIC24F32KA304__) 
....................         #define __PIC24F32KA304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F32KA304.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F32KA304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128DA106__) || (getenv("DEVICE")=="PIC24FJ128DA106") 
....................     #if !defined(__PIC24FJ128DA106__) 
....................         #define __PIC24FJ128DA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128DA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128DA106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128DA110__) || (getenv("DEVICE")=="PIC24FJ128DA110") 
....................     #if !defined(__PIC24FJ128DA110__) 
....................         #define __PIC24FJ128DA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128DA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128DA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128DA206__) || (getenv("DEVICE")=="PIC24FJ128DA206") 
....................     #if !defined(__PIC24FJ128DA206__) 
....................         #define __PIC24FJ128DA206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128DA206.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128DA206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128DA210__) || (getenv("DEVICE")=="PIC24FJ128DA210") 
....................     #if !defined(__PIC24FJ128DA210__) 
....................         #define __PIC24FJ128DA210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128DA210.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128DA210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA006__) || (getenv("DEVICE")=="PIC24FJ128GA006") 
....................     #if !defined(__PIC24FJ128GA006__) 
....................         #define __PIC24FJ128GA006__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA006.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA006_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA008__) || (getenv("DEVICE")=="PIC24FJ128GA008") 
....................     #if !defined(__PIC24FJ128GA008__) 
....................         #define __PIC24FJ128GA008__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA008.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA008_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA010__) || (getenv("DEVICE")=="PIC24FJ128GA010") 
....................     #if !defined(__PIC24FJ128GA010__) 
....................         #define __PIC24FJ128GA010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA010.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA106__) || (getenv("DEVICE")=="PIC24FJ128GA106") 
....................     #if !defined(__PIC24FJ128GA106__) 
....................         #define __PIC24FJ128GA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA108__) || (getenv("DEVICE")=="PIC24FJ128GA108") 
....................     #if !defined(__PIC24FJ128GA108__) 
....................         #define __PIC24FJ128GA108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA110__) || (getenv("DEVICE")=="PIC24FJ128GA110") 
....................     #if !defined(__PIC24FJ128GA110__) 
....................         #define __PIC24FJ128GA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA306__) || (getenv("DEVICE")=="PIC24FJ128GA306") 
....................     #if !defined(__PIC24FJ128GA306__) 
....................         #define __PIC24FJ128GA306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA306.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA308__) || (getenv("DEVICE")=="PIC24FJ128GA308") 
....................     #if !defined(__PIC24FJ128GA308__) 
....................         #define __PIC24FJ128GA308__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA308.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA308_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA310__) || (getenv("DEVICE")=="PIC24FJ128GA310") 
....................     #if !defined(__PIC24FJ128GA310__) 
....................         #define __PIC24FJ128GA310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA310.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GB106__) || (getenv("DEVICE")=="PIC24FJ128GB106") 
....................     #if !defined(__PIC24FJ128GB106__) 
....................         #define __PIC24FJ128GB106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GB106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GB106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GB108__) || (getenv("DEVICE")=="PIC24FJ128GB108") 
....................     #if !defined(__PIC24FJ128GB108__) 
....................         #define __PIC24FJ128GB108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GB108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GB108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GB110__) || (getenv("DEVICE")=="PIC24FJ128GB110") 
....................     #if !defined(__PIC24FJ128GB110__) 
....................         #define __PIC24FJ128GB110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GB110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GB110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GB206__) || (getenv("DEVICE")=="PIC24FJ128GB206") 
....................     #if !defined(__PIC24FJ128GB206__) 
....................         #define __PIC24FJ128GB206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GB206.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GB206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GB210__) || (getenv("DEVICE")=="PIC24FJ128GB210") 
....................     #if !defined(__PIC24FJ128GB210__) 
....................         #define __PIC24FJ128GB210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GB210.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GB210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ16GA002__) || (getenv("DEVICE")=="PIC24FJ16GA002") 
....................     #if !defined(__PIC24FJ16GA002__) 
....................         #define __PIC24FJ16GA002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ16GA002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ16GA002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ16GA004__) || (getenv("DEVICE")=="PIC24FJ16GA004") 
....................     #if !defined(__PIC24FJ16GA004__) 
....................         #define __PIC24FJ16GA004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ16GA004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ16GA004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ16MC101__) || (getenv("DEVICE")=="PIC24FJ16MC101") 
....................     #if !defined(__PIC24FJ16MC101__) 
....................         #define __PIC24FJ16MC101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ16MC101.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ16MC101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ16MC102__) || (getenv("DEVICE")=="PIC24FJ16MC102") 
....................     #if !defined(__PIC24FJ16MC102__) 
....................         #define __PIC24FJ16MC102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ16MC102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ16MC102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GA106__) || (getenv("DEVICE")=="PIC24FJ192GA106") 
....................     #if !defined(__PIC24FJ192GA106__) 
....................         #define __PIC24FJ192GA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GA106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GA108__) || (getenv("DEVICE")=="PIC24FJ192GA108") 
....................     #if !defined(__PIC24FJ192GA108__) 
....................         #define __PIC24FJ192GA108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GA108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GA108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GA110__) || (getenv("DEVICE")=="PIC24FJ192GA110") 
....................     #if !defined(__PIC24FJ192GA110__) 
....................         #define __PIC24FJ192GA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GB106__) || (getenv("DEVICE")=="PIC24FJ192GB106") 
....................     #if !defined(__PIC24FJ192GB106__) 
....................         #define __PIC24FJ192GB106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GB106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GB106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GB108__) || (getenv("DEVICE")=="PIC24FJ192GB108") 
....................     #if !defined(__PIC24FJ192GB108__) 
....................         #define __PIC24FJ192GB108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GB108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GB108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GB110__) || (getenv("DEVICE")=="PIC24FJ192GB110") 
....................     #if !defined(__PIC24FJ192GB110__) 
....................         #define __PIC24FJ192GB110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GB110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GB110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256DA106__) || (getenv("DEVICE")=="PIC24FJ256DA106") 
....................     #if !defined(__PIC24FJ256DA106__) 
....................         #define __PIC24FJ256DA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256DA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256DA106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256DA110__) || (getenv("DEVICE")=="PIC24FJ256DA110") 
....................     #if !defined(__PIC24FJ256DA110__) 
....................         #define __PIC24FJ256DA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256DA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256DA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256DA206__) || (getenv("DEVICE")=="PIC24FJ256DA206") 
....................     #if !defined(__PIC24FJ256DA206__) 
....................         #define __PIC24FJ256DA206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256DA206.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256DA206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256DA210__) || (getenv("DEVICE")=="PIC24FJ256DA210") 
....................     #if !defined(__PIC24FJ256DA210__) 
....................         #define __PIC24FJ256DA210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256DA210.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256DA210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GA106__) || (getenv("DEVICE")=="PIC24FJ256GA106") 
....................     #if !defined(__PIC24FJ256GA106__) 
....................         #define __PIC24FJ256GA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GA106_registers.h" 
.................... #word WREG0 = 0x000 
....................  
.................... #word WREG1 = 0x002 
....................  
.................... #word WREG2 = 0x004 
....................  
.................... #word WREG3 = 0x006 
....................  
.................... #word WREG4 = 0x008 
....................  
.................... #word WREG5 = 0x00A 
....................  
.................... #word WREG6 = 0x00C 
....................  
.................... #word WREG7 = 0x00E 
....................  
.................... #word WREG8 = 0x010 
....................  
.................... #word WREG9 = 0x012 
....................  
.................... #word WREG10 = 0x014 
....................  
.................... #word WREG11 = 0x016 
....................  
.................... #word WREG12 = 0x018 
....................  
.................... #word WREG13 = 0x01A 
....................  
.................... #word WREG14 = 0x01C 
....................  
.................... #word WREG15 = 0x01E 
....................  
.................... #word SPLIM = 0x020 
....................  
.................... #word PC = 0x02E 
....................  
.................... #word DSRPAG = 0x032 
....................  
.................... #word DSWPAG = 0x034 
....................  
.................... #word RCOUNT = 0x036 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int C:1; 
....................          unsigned int Z:1; 
....................          unsigned int OV:1; 
....................          unsigned int N:1; 
....................          unsigned int RA:1; 
....................          unsigned int IPL0:3; 
....................          unsigned int DC:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int IPL:3; 
....................       }; 
.................... } SRBITS; 
.................... SRBITS SRbits; 
.................... #word SRbits = 0x042 
.................... #word SR = 0x042 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :2; 
....................    unsigned int RES:1; 
....................    unsigned int IPL3:1; 
.................... } CORCONBITS; 
.................... CORCONBITS CORCONbits; 
.................... #word CORCONbits = 0x044 
.................... #word CORCON = 0x044 
....................  
.................... #word DISICNT = 0x052 
....................  
.................... #word TBLPAG = 0x054 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN0PDE:1; 
....................    unsigned int CN1PDE:1; 
....................    unsigned int CN2PDE:1; 
....................    unsigned int CN3PDE:1; 
....................    unsigned int CN4PDE:1; 
....................    unsigned int CN5PDE:1; 
....................    unsigned int CN6PDE:1; 
....................    unsigned int CN7PDE:1; 
....................    unsigned int CN8PDE:1; 
....................    unsigned int CN9PDE:1; 
....................    unsigned int CN10PDE:1; 
....................    unsigned int CN11PDE:1; 
....................    unsigned int CN12PDE:1; 
....................    unsigned int CN13PDE:1; 
....................    unsigned int CN14PDE:1; 
....................    unsigned int CN15PDE:1; 
.................... } CNPD1BITS; 
.................... CNPD1BITS CNPD1bits; 
.................... #word CNPD1bits = 0x056 
.................... #word CNPD1 = 0x056 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN16PDE:1; 
....................    unsigned int CN17PDE:1; 
....................    unsigned int CN18PDE:1; 
....................    unsigned int :3; 
....................    unsigned int CN22PDE:1; 
....................    unsigned int CN23PDE:1; 
....................    unsigned int CN24PDE:1; 
....................    unsigned int CN25PDE:1; 
....................    unsigned int CN26PDE:1; 
....................    unsigned int CN27PDE:1; 
....................    unsigned int CN28PDE:1; 
....................    unsigned int CN29PDE:1; 
....................    unsigned int CN30PDE:1; 
....................    unsigned int CN31PDE:1; 
.................... } CNPD2BITS; 
.................... CNPD2BITS CNPD2bits; 
.................... #word CNPD2bits = 0x058 
.................... #word CNPD2 = 0x058 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN32PDE:1; 
.................... } CNPD3BITS; 
.................... CNPD3BITS CNPD3bits; 
.................... #word CNPD3bits = 0x05A 
.................... #word CNPD3 = 0x05A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int CN49PDE:1; 
....................    unsigned int CN50PDE:1; 
....................    unsigned int CN51PDE:1; 
....................    unsigned int CN52PDE:1; 
....................    unsigned int CN53PDE:1; 
....................    unsigned int CN54PDE:1; 
....................    unsigned int CN55PDE:1; 
....................    unsigned int CN56PDE:1; 
....................    unsigned int :1; 
....................    unsigned int CN58PDE:1; 
....................    unsigned int CN59PDE:1; 
....................    unsigned int CN60PDE:1; 
....................    unsigned int CN61PDE:1; 
....................    unsigned int CN62PDE:1; 
....................    unsigned int CN63PDE:1; 
.................... } CNPD4BITS; 
.................... CNPD4BITS CNPD4bits; 
.................... #word CNPD4bits = 0x05C 
.................... #word CNPD4 = 0x05C 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN64PDE:1; 
....................    unsigned int CN65PDE:1; 
....................    unsigned int :2; 
....................    unsigned int CN68PDE:1; 
....................    unsigned int CN69PDE:1; 
....................    unsigned int :1; 
....................    unsigned int CN71PDE:1; 
.................... } CNPD5BITS; 
.................... CNPD5BITS CNPD5bits; 
.................... #word CNPD5bits = 0x05E 
.................... #word CNPD5 = 0x05E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :3; 
....................    unsigned int CN83PDE:1; 
....................    unsigned int CN84PDE:1; 
.................... } CNPD6BITS; 
.................... CNPD6BITS CNPD6bits; 
.................... #word CNPD6bits = 0x060 
.................... #word CNPD6 = 0x060 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN0IE:1; 
....................    unsigned int CN1IE:1; 
....................    unsigned int CN2IE:1; 
....................    unsigned int CN3IE:1; 
....................    unsigned int CN4IE:1; 
....................    unsigned int CN5IE:1; 
....................    unsigned int CN6IE:1; 
....................    unsigned int CN7IE:1; 
....................    unsigned int CN8IE:1; 
....................    unsigned int CN9IE:1; 
....................    unsigned int CN10IE:1; 
....................    unsigned int CN11IE:1; 
....................    unsigned int CN12IE:1; 
....................    unsigned int CN13IE:1; 
....................    unsigned int CN14IE:1; 
....................    unsigned int CN15IE:1; 
.................... } CNEN1BITS; 
.................... CNEN1BITS CNEN1bits; 
.................... #word CNEN1bits = 0x062 
.................... #word CNEN1 = 0x062 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN16IE:1; 
....................    unsigned int CN17IE:1; 
....................    unsigned int CN18IE:1; 
....................    unsigned int :3; 
....................    unsigned int CN22IE:1; 
....................    unsigned int CN23IE:1; 
....................    unsigned int CN24IE:1; 
....................    unsigned int CN25IE:1; 
....................    unsigned int CN26IE:1; 
....................    unsigned int CN27IE:1; 
....................    unsigned int CN28IE:1; 
....................    unsigned int CN29IE:1; 
....................    unsigned int CN30IE:1; 
....................    unsigned int CN31IE:1; 
.................... } CNEN2BITS; 
.................... CNEN2BITS CNEN2bits; 
.................... #word CNEN2bits = 0x064 
.................... #word CNEN2 = 0x064 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN32IE:1; 
.................... } CNEN3BITS; 
.................... CNEN3BITS CNEN3bits; 
.................... #word CNEN3bits = 0x066 
.................... #word CNEN3 = 0x066 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int CN49IE:1; 
....................    unsigned int CN50IE:1; 
....................    unsigned int CN51IE:1; 
....................    unsigned int CN52IE:1; 
....................    unsigned int CN53IE:1; 
....................    unsigned int CN54IE:1; 
....................    unsigned int CN55IE:1; 
....................    unsigned int CN56IE:1; 
....................    unsigned int :1; 
....................    unsigned int CN58IE:1; 
....................    unsigned int CN59IE:1; 
....................    unsigned int CN60IE:1; 
....................    unsigned int CN61IE:1; 
....................    unsigned int CN62IE:1; 
....................    unsigned int CN63IE:1; 
.................... } CNEN4BITS; 
.................... CNEN4BITS CNEN4bits; 
.................... #word CNEN4bits = 0x068 
.................... #word CNEN4 = 0x068 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN64IE:1; 
....................    unsigned int CN65IE:1; 
....................    unsigned int :2; 
....................    unsigned int CN68IE:1; 
....................    unsigned int CN69IE:1; 
....................    unsigned int :1; 
....................    unsigned int CN71IE:1; 
.................... } CNEN5BITS; 
.................... CNEN5BITS CNEN5bits; 
.................... #word CNEN5bits = 0x06A 
.................... #word CNEN5 = 0x06A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :3; 
....................    unsigned int CN83IE:1; 
....................    unsigned int CN84IE:1; 
.................... } CNEN6BITS; 
.................... CNEN6BITS CNEN6bits; 
.................... #word CNEN6bits = 0x06C 
.................... #word CNEN6 = 0x06C 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN0PUE:1; 
....................    unsigned int CN1PUE:1; 
....................    unsigned int CN2PUE:1; 
....................    unsigned int CN3PUE:1; 
....................    unsigned int CN4PUE:1; 
....................    unsigned int CN5PUE:1; 
....................    unsigned int CN6PUE:1; 
....................    unsigned int CN7PUE:1; 
....................    unsigned int CN8PUE:1; 
....................    unsigned int CN9PUE:1; 
....................    unsigned int CN10PUE:1; 
....................    unsigned int CN11PUE:1; 
....................    unsigned int CN12PUE:1; 
....................    unsigned int CN13PUE:1; 
....................    unsigned int CN14PUE:1; 
....................    unsigned int CN15PUE:1; 
.................... } CNPU1BITS; 
.................... CNPU1BITS CNPU1bits; 
.................... #word CNPU1bits = 0x06E 
.................... #word CNPU1 = 0x06E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN16PUE:1; 
....................    unsigned int CN17PUE:1; 
....................    unsigned int CN18PUE:1; 
....................    unsigned int :3; 
....................    unsigned int CN22PUE:1; 
....................    unsigned int CN23PUE:1; 
....................    unsigned int CN24PUE:1; 
....................    unsigned int CN25PUE:1; 
....................    unsigned int CN26PUE:1; 
....................    unsigned int CN27PUE:1; 
....................    unsigned int CN28PUE:1; 
....................    unsigned int CN29PUE:1; 
....................    unsigned int CN30PUE:1; 
....................    unsigned int CN31PUE:1; 
.................... } CNPU2BITS; 
.................... CNPU2BITS CNPU2bits; 
.................... #word CNPU2bits = 0x070 
.................... #word CNPU2 = 0x070 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN32PUE:1; 
.................... } CNPU3BITS; 
.................... CNPU3BITS CNPU3bits; 
.................... #word CNPU3bits = 0x072 
.................... #word CNPU3 = 0x072 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int CN49PUE:1; 
....................    unsigned int CN50PUE:1; 
....................    unsigned int CN51PUE:1; 
....................    unsigned int CN52PUE:1; 
....................    unsigned int CN53PUE:1; 
....................    unsigned int CN54PUE:1; 
....................    unsigned int CN55PUE:1; 
....................    unsigned int CN56PUE:1; 
....................    unsigned int :1; 
....................    unsigned int CN58PUE:1; 
....................    unsigned int CN59PUE:1; 
....................    unsigned int CN60PUE:1; 
....................    unsigned int CN61PUE:1; 
....................    unsigned int CN62PUE:1; 
....................    unsigned int CN63PUE:1; 
.................... } CNPU4BITS; 
.................... CNPU4BITS CNPU4bits; 
.................... #word CNPU4bits = 0x074 
.................... #word CNPU4 = 0x074 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN64PUE:1; 
....................    unsigned int CN65PUE:1; 
....................    unsigned int :2; 
....................    unsigned int CN68PUE:1; 
....................    unsigned int CN69PUE:1; 
....................    unsigned int :1; 
....................    unsigned int CN71PUE:1; 
.................... } CNPU5BITS; 
.................... CNPU5BITS CNPU5bits; 
.................... #word CNPU5bits = 0x076 
.................... #word CNPU5 = 0x076 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :3; 
....................    unsigned int CN83PUE:1; 
....................    unsigned int CN84PUE:1; 
.................... } CNPU6BITS; 
.................... CNPU6BITS CNPU6bits; 
.................... #word CNPU6bits = 0x078 
.................... #word CNPU6 = 0x078 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int OSCFAIL:1; 
....................    unsigned int STKERR:1; 
....................    unsigned int ADDRERR:1; 
....................    unsigned int MATHERR:1; 
....................    unsigned int :10; 
....................    unsigned int NSTDIS:1; 
.................... } INTCON1BITS; 
.................... INTCON1BITS INTCON1bits; 
.................... #word INTCON1bits = 0x080 
.................... #word INTCON1 = 0x080 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int INT0EP:1; 
....................    unsigned int INT1EP:1; 
....................    unsigned int INT2EP:1; 
....................    unsigned int INT3EP:1; 
....................    unsigned int INT4EP:1; 
....................    unsigned int :9; 
....................    unsigned int DISI:1; 
....................    unsigned int ALTIVT:1; 
.................... } INTCON2BITS; 
.................... INTCON2BITS INTCON2bits; 
.................... #word INTCON2bits = 0x082 
.................... #word INTCON2 = 0x082 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int INT0IF:1; 
....................    unsigned int IC1IF:1; 
....................    unsigned int OC1IF:1; 
....................    unsigned int T1IF:1; 
....................    unsigned int :1; 
....................    unsigned int IC2IF:1; 
....................    unsigned int OC2IF:1; 
....................    unsigned int T2IF:1; 
....................    unsigned int T3IF:1; 
....................    unsigned int SPF1IF:1; 
....................    unsigned int SPI1IF:1; 
....................    unsigned int U1RXIF:1; 
....................    unsigned int U1TXIF:1; 
....................    unsigned int AD1IF:1; 
.................... } IFS0BITS; 
.................... IFS0BITS IFS0bits; 
.................... #word IFS0bits = 0x084 
.................... #word IFS0 = 0x084 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SI2C1IF:1; 
....................    unsigned int MI2C1IF:1; 
....................    unsigned int CMIF:1; 
....................    unsigned int CNIF:1; 
....................    unsigned int INT1IF:1; 
....................    unsigned int :1; 
....................    unsigned int IC7IF:1; 
....................    unsigned int IC8IF:1; 
....................    unsigned int :1; 
....................    unsigned int OC3IF:1; 
....................    unsigned int OC4IF:1; 
....................    unsigned int T4IF:1; 
....................    unsigned int T5IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int U2RXIF:1; 
....................    unsigned int U2TXIF:1; 
.................... } IFS1BITS; 
.................... IFS1BITS IFS1bits; 
.................... #word IFS1bits = 0x086 
.................... #word IFS1 = 0x086 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPF2IF:1; 
....................    unsigned int SPI2IF:1; 
....................    unsigned int :3; 
....................    unsigned int IC3IF:1; 
....................    unsigned int IC4IF:1; 
....................    unsigned int IC5IF:1; 
....................    unsigned int IC6IF:1; 
....................    unsigned int OC5IF:1; 
....................    unsigned int OC6IF:1; 
....................    unsigned int OC7IF:1; 
....................    unsigned int OC8IF:1; 
....................    unsigned int PMPIF:1; 
.................... } IFS2BITS; 
.................... IFS2BITS IFS2bits; 
.................... #word IFS2bits = 0x088 
.................... #word IFS2 = 0x088 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int SI2C2IF:1; 
....................    unsigned int MI2C2IF:1; 
....................    unsigned int :2; 
....................    unsigned int INT3IF:1; 
....................    unsigned int INT4IF:1; 
....................    unsigned int :7; 
....................    unsigned int RTCIF:1; 
.................... } IFS3BITS; 
.................... IFS3BITS IFS3bits; 
.................... #word IFS3bits = 0x08A 
.................... #word IFS3 = 0x08A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int U1ERIF:1; 
....................    unsigned int U2ERIF:1; 
....................    unsigned int CRCIF:1; 
....................    unsigned int :4; 
....................    unsigned int LVDIF:1; 
....................    unsigned int :4; 
....................    unsigned int CTMUIF:1; 
.................... } IFS4BITS; 
.................... IFS4BITS IFS4bits; 
.................... #word IFS4bits = 0x08C 
.................... #word IFS4 = 0x08C 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int U3ERIF:1; 
....................    unsigned int U3RXIF:1; 
....................    unsigned int U3TXIF:1; 
....................    unsigned int SI2C3IF:1; 
....................    unsigned int MI2C3IF:1; 
....................    unsigned int USB1IF:1; 
....................    unsigned int U4ERIF:1; 
....................    unsigned int U4RXIF:1; 
....................    unsigned int U4TXIF:1; 
....................    unsigned int SPF3IF:1; 
....................    unsigned int SPI3IF:1; 
....................    unsigned int OC9IF:1; 
....................    unsigned int IC9IF:1; 
.................... } IFS5BITS; 
.................... IFS5BITS IFS5bits; 
.................... #word IFS5bits = 0x08E 
.................... #word IFS5 = 0x08E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int INT0IE:1; 
....................    unsigned int IC1IE:1; 
....................    unsigned int OC1IE:1; 
....................    unsigned int T1IE:1; 
....................    unsigned int :1; 
....................    unsigned int IC2IE:1; 
....................    unsigned int OC2IE:1; 
....................    unsigned int T2IE:1; 
....................    unsigned int T3IE:1; 
....................    unsigned int SPF1IE:1; 
....................    unsigned int SPI1IE:1; 
....................    unsigned int U1RXIE:1; 
....................    unsigned int U1TXIE:1; 
....................    unsigned int AD1IE:1; 
.................... } IEC0BITS; 
.................... IEC0BITS IEC0bits; 
.................... #word IEC0bits = 0x094 
.................... #word IEC0 = 0x094 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SI2C1IE:1; 
....................    unsigned int MI2C1IE:1; 
....................    unsigned int CMIE:1; 
....................    unsigned int CNIE:1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int :1; 
....................    unsigned int IC7IE:1; 
....................    unsigned int IC8IE:1; 
....................    unsigned int :1; 
....................    unsigned int OC3IE:1; 
....................    unsigned int OC4IE:1; 
....................    unsigned int T4IE:1; 
....................    unsigned int T5IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int U2RXIE:1; 
....................    unsigned int U2TXIE:1; 
.................... } IEC1BITS; 
.................... IEC1BITS IEC1bits; 
.................... #word IEC1bits = 0x096 
.................... #word IEC1 = 0x096 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPF2IE:1; 
....................    unsigned int SPI2IE:1; 
....................    unsigned int :3; 
....................    unsigned int IC3IE:1; 
....................    unsigned int IC4IE:1; 
....................    unsigned int IC5IE:1; 
....................    unsigned int IC6IE:1; 
....................    unsigned int OC5IE:1; 
....................    unsigned int OC6IE:1; 
....................    unsigned int OC7IE:1; 
....................    unsigned int OC8IE:1; 
....................    unsigned int PMPIE:1; 
.................... } IEC2BITS; 
.................... IEC2BITS IEC2bits; 
.................... #word IEC2bits = 0x098 
.................... #word IEC2 = 0x098 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int SI2C2IE:1; 
....................    unsigned int MI2C2IE:1; 
....................    unsigned int :2; 
....................    unsigned int INT3IE:1; 
....................    unsigned int INT4IE:1; 
....................    unsigned int :7; 
....................    unsigned int RTCIE:1; 
.................... } IEC3BITS; 
.................... IEC3BITS IEC3bits; 
.................... #word IEC3bits = 0x09A 
.................... #word IEC3 = 0x09A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int U1ERIE:1; 
....................    unsigned int U2ERIE:1; 
....................    unsigned int CRCIE:1; 
....................    unsigned int :4; 
....................    unsigned int LVDIE:1; 
....................    unsigned int :4; 
....................    unsigned int CTMUIE:1; 
.................... } IEC4BITS; 
.................... IEC4BITS IEC4bits; 
.................... #word IEC4bits = 0x09C 
.................... #word IEC4 = 0x09C 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int U3ERIE:1; 
....................    unsigned int U3RXIE:1; 
....................    unsigned int U3TXIE:1; 
....................    unsigned int SI2C3IE:1; 
....................    unsigned int MI2C3IE:1; 
....................    unsigned int USB1IE:1; 
....................    unsigned int U4ERIE:1; 
....................    unsigned int U4RXIE:1; 
....................    unsigned int U4TXIE:1; 
....................    unsigned int SPF3IE:1; 
....................    unsigned int SPI3IE:1; 
....................    unsigned int OC9IE:1; 
....................    unsigned int IC9IE:1; 
.................... } IEC5BITS; 
.................... IEC5BITS IEC5bits; 
.................... #word IEC5bits = 0x09E 
.................... #word IEC5 = 0x09E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int INT0IP0:3; 
....................          unsigned int :1; 
....................          unsigned int IC1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int T1IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int INT0IP:3; 
....................          unsigned int :1; 
....................          unsigned int IC1IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC1IP:3; 
....................          unsigned int :1; 
....................          unsigned int T1IP:3; 
....................       }; 
.................... } IPC0BITS; 
.................... IPC0BITS IPC0bits; 
.................... #word IPC0bits = 0x0A4 
.................... #word IPC0 = 0x0A4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int IC2IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC2IP0:3; 
....................          unsigned int :1; 
....................          unsigned int T2IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int IC2IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC2IP:3; 
....................          unsigned int :1; 
....................          unsigned int T2IP:3; 
....................       }; 
.................... } IPC1BITS; 
.................... IPC1BITS IPC1bits; 
.................... #word IPC1bits = 0x0A6 
.................... #word IPC1 = 0x0A6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int T3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int SPF1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int SPI1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int U1RXIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int T3IP:3; 
....................          unsigned int :1; 
....................          unsigned int SPF1IP:3; 
....................          unsigned int :1; 
....................          unsigned int SPI1IP:3; 
....................          unsigned int :1; 
....................          unsigned int U1RXIP:3; 
....................       }; 
.................... } IPC2BITS; 
.................... IPC2BITS IPC2bits; 
.................... #word IPC2bits = 0x0A8 
.................... #word IPC2 = 0x0A8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int U1TXIP0:3; 
....................          unsigned int :1; 
....................          unsigned int AD1IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int U1TXIP:3; 
....................          unsigned int :1; 
....................          unsigned int AD1IP:3; 
....................       }; 
.................... } IPC3BITS; 
.................... IPC3BITS IPC3bits; 
.................... #word IPC3bits = 0x0AA 
.................... #word IPC3 = 0x0AA 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SI2C1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int CMIP0:3; 
....................          unsigned int :1; 
....................          unsigned int CNIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int SI2C1IP:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C1IP:3; 
....................          unsigned int :1; 
....................          unsigned int CMIP:3; 
....................          unsigned int :1; 
....................          unsigned int CNIP:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int SI2C1P0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C1P0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int SI2C1P:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C1P:3; 
....................       }; 
.................... } IPC4BITS; 
.................... IPC4BITS IPC4bits; 
.................... #word IPC4bits = 0x0AC 
.................... #word IPC4 = 0x0AC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int INT1IP0:3; 
....................          unsigned int :5; 
....................          unsigned int IC7IP0:3; 
....................          unsigned int :1; 
....................          unsigned int IC8IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int INT1IP:3; 
....................          unsigned int :5; 
....................          unsigned int IC7IP:3; 
....................          unsigned int :1; 
....................          unsigned int IC8IP:3; 
....................       }; 
.................... } IPC5BITS; 
.................... IPC5BITS IPC5bits; 
.................... #word IPC5bits = 0x0AE 
.................... #word IPC5 = 0x0AE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int OC3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC4IP0:3; 
....................          unsigned int :1; 
....................          unsigned int T4IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int OC3IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC4IP:3; 
....................          unsigned int :1; 
....................          unsigned int T4IP:3; 
....................       }; 
.................... } IPC6BITS; 
.................... IPC6BITS IPC6bits; 
.................... #word IPC6bits = 0x0B0 
.................... #word IPC6 = 0x0B0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int T5IP0:3; 
....................          unsigned int :1; 
....................          unsigned int INT2IP0:3; 
....................          unsigned int :1; 
....................          unsigned int U2RXIP0:3; 
....................          unsigned int :1; 
....................          unsigned int U2TXIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int T5IP:3; 
....................          unsigned int :1; 
....................          unsigned int INT2IP:3; 
....................          unsigned int :1; 
....................          unsigned int U2RXIP:3; 
....................          unsigned int :1; 
....................          unsigned int U2TXIP:3; 
....................       }; 
.................... } IPC7BITS; 
.................... IPC7BITS IPC7bits; 
.................... #word IPC7bits = 0x0B2 
.................... #word IPC7 = 0x0B2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SPF2IP0:3; 
....................          unsigned int :1; 
....................          unsigned int SPI2IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int SPF2IP:3; 
....................          unsigned int :1; 
....................          unsigned int SPI2IP:3; 
....................       }; 
.................... } IPC8BITS; 
.................... IPC8BITS IPC8bits; 
.................... #word IPC8bits = 0x0B4 
.................... #word IPC8 = 0x0B4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int IC3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int IC4IP0:3; 
....................          unsigned int :1; 
....................          unsigned int IC5IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int IC3IP:3; 
....................          unsigned int :1; 
....................          unsigned int IC4IP:3; 
....................          unsigned int :1; 
....................          unsigned int IC5IP:3; 
....................       }; 
.................... } IPC9BITS; 
.................... IPC9BITS IPC9bits; 
.................... #word IPC9bits = 0x0B6 
.................... #word IPC9 = 0x0B6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IC6IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC5IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC6IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC7IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int IC6IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC5IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC6IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC7IP:3; 
....................       }; 
.................... } IPC10BITS; 
.................... IPC10BITS IPC10bits; 
.................... #word IPC10bits = 0x0B8 
.................... #word IPC10 = 0x0B8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OC8IP0:3; 
....................          unsigned int :1; 
....................          unsigned int PMPIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int OC8IP:3; 
....................          unsigned int :1; 
....................          unsigned int PMPIP:3; 
....................       }; 
.................... } IPC11BITS; 
.................... IPC11BITS IPC11bits; 
.................... #word IPC11bits = 0x0BA 
.................... #word IPC11 = 0x0BA 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int SI2C2IP0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C2IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int SI2C2IP:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C2IP:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int SI2C2P0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C2P0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int SI2C2P:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C2P:3; 
....................       }; 
.................... } IPC12BITS; 
.................... IPC12BITS IPC12bits; 
.................... #word IPC12bits = 0x0BC 
.................... #word IPC12 = 0x0BC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int INT3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int INT4IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int INT3IP:3; 
....................          unsigned int :1; 
....................          unsigned int INT4IP:3; 
....................       }; 
.................... } IPC13BITS; 
.................... IPC13BITS IPC13bits; 
.................... #word IPC13bits = 0x0BE 
.................... #word IPC13 = 0x0BE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int RTCIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int RTCIP:3; 
....................       }; 
.................... } IPC15BITS; 
.................... IPC15BITS IPC15bits; 
.................... #word IPC15bits = 0x0C2 
.................... #word IPC15 = 0x0C2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int U1ERIP0:3; 
....................          unsigned int :1; 
....................          unsigned int U2ERIP0:3; 
....................          unsigned int :1; 
....................          unsigned int CRCIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int U1ERIP:3; 
....................          unsigned int :1; 
....................          unsigned int U2ERIP:3; 
....................          unsigned int :1; 
....................          unsigned int CRCIP:3; 
....................       }; 
.................... } IPC16BITS; 
.................... IPC16BITS IPC16bits; 
.................... #word IPC16bits = 0x0C4 
.................... #word IPC16 = 0x0C4 
....................  
.................... #word IPC18 = 0x0C8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int CTMUIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int CTMUIP:3; 
....................       }; 
.................... } IPC19BITS; 
.................... IPC19BITS IPC19bits; 
.................... #word IPC19bits = 0x0CA 
.................... #word IPC19 = 0x0CA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int U3ERIP0:3; 
....................          unsigned int :1; 
....................          unsigned int U3RXIP0:3; 
....................          unsigned int :1; 
....................          unsigned int U3TXIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int U3ERIP:3; 
....................          unsigned int :1; 
....................          unsigned int U3RXIP:3; 
....................          unsigned int :1; 
....................          unsigned int U3TXIP:3; 
....................       }; 
.................... } IPC20BITS; 
.................... IPC20BITS IPC20bits; 
.................... #word IPC20bits = 0x0CC 
.................... #word IPC20 = 0x0CC 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SI2C3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int USB1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int U4ERIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int SI2C3IP:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C3IP:3; 
....................          unsigned int :1; 
....................          unsigned int USB1IP:3; 
....................          unsigned int :1; 
....................          unsigned int U4ERIP:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int SI2C3P0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C3P0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int SI2C3P:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C3P:3; 
....................       }; 
.................... } IPC21BITS; 
.................... IPC21BITS IPC21bits; 
.................... #word IPC21bits = 0x0CE 
.................... #word IPC21 = 0x0CE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int U4RXIP0:3; 
....................          unsigned int :1; 
....................          unsigned int U4TXIP0:3; 
....................          unsigned int :1; 
....................          unsigned int SPF3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int SPI3IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int U4RXIP:3; 
....................          unsigned int :1; 
....................          unsigned int U4TXIP:3; 
....................          unsigned int :1; 
....................          unsigned int SPF3IP:3; 
....................          unsigned int :1; 
....................          unsigned int SPI3IP:3; 
....................       }; 
.................... } IPC22BITS; 
.................... IPC22BITS IPC22bits; 
.................... #word IPC22bits = 0x0D0 
.................... #word IPC22 = 0x0D0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OC9IP0:3; 
....................          unsigned int :1; 
....................          unsigned int IC9IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int OC9IP:3; 
....................          unsigned int :1; 
....................          unsigned int IC9IP:3; 
....................       }; 
.................... } IPC23BITS; 
.................... IPC23BITS IPC23bits; 
.................... #word IPC23bits = 0x0D2 
.................... #word IPC23 = 0x0D2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int VECNUM0:7; 
....................          unsigned int :1; 
....................          unsigned int ILR0:4; 
....................          unsigned int :1; 
....................          unsigned int VHOLD:1; 
....................          unsigned int :1; 
....................          unsigned int CPUIRQ:1; 
....................       }; 
....................       struct { 
....................          unsigned int VECNUM:7; 
....................          unsigned int :1; 
....................          unsigned int ILR:4; 
....................       }; 
.................... } INTTREGBITS; 
.................... INTTREGBITS INTTREGbits; 
.................... #word INTTREGbits = 0x0E0 
.................... #word INTTREG = 0x0E0 
....................  
.................... #word TMR1 = 0x100 
....................  
.................... #word PR1 = 0x102 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int TCS:1; 
....................          unsigned int TSYNC:1; 
....................          unsigned int :1; 
....................          unsigned int TCKPS0:2; 
....................          unsigned int TGATE:1; 
....................          unsigned int :6; 
....................          unsigned int TSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int TON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int TCKPS:2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } T1CONBITS; 
.................... T1CONBITS T1CONbits; 
.................... #word T1CONbits = 0x104 
.................... #word T1CON = 0x104 
....................  
.................... #word TMR2 = 0x106 
....................  
.................... #word TMR3HLD = 0x108 
....................  
.................... #word TMR3 = 0x10A 
....................  
.................... #word PR2 = 0x10C 
....................  
.................... #word PR3 = 0x10E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int TCS:1; 
....................          unsigned int :1; 
....................          unsigned int T32:1; 
....................          unsigned int TCKPS0:2; 
....................          unsigned int TGATE:1; 
....................          unsigned int :6; 
....................          unsigned int TSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int TON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int TCKPS:2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } T2CONBITS; 
.................... T2CONBITS T2CONbits; 
.................... #word T2CONbits = 0x110 
.................... #word T2CON = 0x110 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int TCS:1; 
....................          unsigned int :2; 
....................          unsigned int TCKPS0:2; 
....................          unsigned int TGATE:1; 
....................          unsigned int :6; 
....................          unsigned int TSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int TON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :2; 
....................          unsigned int TCKPS:2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } T3CONBITS; 
.................... T3CONBITS T3CONbits; 
.................... #word T3CONbits = 0x112 
.................... #word T3CON = 0x112 
....................  
.................... #word TMR4 = 0x114 
....................  
.................... #word TMR5HLD = 0x116 
....................  
.................... #word TMR5 = 0x118 
....................  
.................... #word PR4 = 0x11A 
....................  
.................... #word PR5 = 0x11C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int TCS:1; 
....................          unsigned int :1; 
....................          unsigned int T45:1; 
....................          unsigned int TCKPS0:2; 
....................          unsigned int TGATE:1; 
....................          unsigned int :6; 
....................          unsigned int TSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int TON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int TCKPS:2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } T4CONBITS; 
.................... T4CONBITS T4CONbits; 
.................... #word T4CONbits = 0x11E 
.................... #word T4CON = 0x11E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int TCS:1; 
....................          unsigned int :2; 
....................          unsigned int TCKPS0:2; 
....................          unsigned int TGATE:1; 
....................          unsigned int :6; 
....................          unsigned int TSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int TON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :2; 
....................          unsigned int TCKPS:2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } T5CONBITS; 
.................... T5CONBITS T5CONbits; 
.................... #word T5CONbits = 0x120 
.................... #word T5CON = 0x120 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC1CON1BITS; 
.................... IC1CON1BITS IC1CON1bits; 
.................... #word IC1CON1bits = 0x140 
.................... #word IC1CON1 = 0x140 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC1CON2BITS; 
.................... IC1CON2BITS IC1CON2bits; 
.................... #word IC1CON2bits = 0x142 
.................... #word IC1CON2 = 0x142 
....................  
.................... #word IC1BUF = 0x144 
....................  
.................... #word IC1TMR = 0x146 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC2CON1BITS; 
.................... IC2CON1BITS IC2CON1bits; 
.................... #word IC2CON1bits = 0x148 
.................... #word IC2CON1 = 0x148 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC2CON2BITS; 
.................... IC2CON2BITS IC2CON2bits; 
.................... #word IC2CON2bits = 0x14A 
.................... #word IC2CON2 = 0x14A 
....................  
.................... #word IC2BUF = 0x14C 
....................  
.................... #word IC2TMR = 0x14E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC3CON1BITS; 
.................... IC3CON1BITS IC3CON1bits; 
.................... #word IC3CON1bits = 0x150 
.................... #word IC3CON1 = 0x150 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC3CON2BITS; 
.................... IC3CON2BITS IC3CON2bits; 
.................... #word IC3CON2bits = 0x152 
.................... #word IC3CON2 = 0x152 
....................  
.................... #word IC3BUF = 0x154 
....................  
.................... #word IC3TMR = 0x156 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC4CON1BITS; 
.................... IC4CON1BITS IC4CON1bits; 
.................... #word IC4CON1bits = 0x158 
.................... #word IC4CON1 = 0x158 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC4CON2BITS; 
.................... IC4CON2BITS IC4CON2bits; 
.................... #word IC4CON2bits = 0x15A 
.................... #word IC4CON2 = 0x15A 
....................  
.................... #word IC4BUF = 0x15C 
....................  
.................... #word IC4TMR = 0x15E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC5CON1BITS; 
.................... IC5CON1BITS IC5CON1bits; 
.................... #word IC5CON1bits = 0x160 
.................... #word IC5CON1 = 0x160 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC5CON2BITS; 
.................... IC5CON2BITS IC5CON2bits; 
.................... #word IC5CON2bits = 0x162 
.................... #word IC5CON2 = 0x162 
....................  
.................... #word IC5BUF = 0x164 
....................  
.................... #word IC5TMR = 0x166 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC6CON1BITS; 
.................... IC6CON1BITS IC6CON1bits; 
.................... #word IC6CON1bits = 0x168 
.................... #word IC6CON1 = 0x168 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC6CON2BITS; 
.................... IC6CON2BITS IC6CON2bits; 
.................... #word IC6CON2bits = 0x16A 
.................... #word IC6CON2 = 0x16A 
....................  
.................... #word IC6BUF = 0x16C 
....................  
.................... #word IC6TMR = 0x16E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC7CON1BITS; 
.................... IC7CON1BITS IC7CON1bits; 
.................... #word IC7CON1bits = 0x170 
.................... #word IC7CON1 = 0x170 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC7CON2BITS; 
.................... IC7CON2BITS IC7CON2bits; 
.................... #word IC7CON2bits = 0x172 
.................... #word IC7CON2 = 0x172 
....................  
.................... #word IC7BUF = 0x174 
....................  
.................... #word IC7TMR = 0x176 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC8CON1BITS; 
.................... IC8CON1BITS IC8CON1bits; 
.................... #word IC8CON1bits = 0x178 
.................... #word IC8CON1 = 0x178 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC8CON2BITS; 
.................... IC8CON2BITS IC8CON2bits; 
.................... #word IC8CON2bits = 0x17A 
.................... #word IC8CON2 = 0x17A 
....................  
.................... #word IC8BUF = 0x17C 
....................  
.................... #word IC8TMR = 0x17E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC9CON1BITS; 
.................... IC9CON1BITS IC9CON1bits; 
.................... #word IC9CON1bits = 0x180 
.................... #word IC9CON1 = 0x180 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC9CON2BITS; 
.................... IC9CON2BITS IC9CON2bits; 
.................... #word IC9CON2bits = 0x182 
.................... #word IC9CON2 = 0x182 
....................  
.................... #word IC9BUF = 0x184 
....................  
.................... #word IC9TMR = 0x186 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC1CON1BITS; 
.................... OC1CON1BITS OC1CON1bits; 
.................... #word OC1CON1bits = 0x190 
.................... #word OC1CON1 = 0x190 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC1CON2BITS; 
.................... OC1CON2BITS OC1CON2bits; 
.................... #word OC1CON2bits = 0x192 
.................... #word OC1CON2 = 0x192 
....................  
.................... #word OC1RS = 0x194 
....................  
.................... #word OC1R = 0x196 
....................  
.................... #word OC1TMR = 0x198 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC2CON1BITS; 
.................... OC2CON1BITS OC2CON1bits; 
.................... #word OC2CON1bits = 0x19A 
.................... #word OC2CON1 = 0x19A 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC2CON2BITS; 
.................... OC2CON2BITS OC2CON2bits; 
.................... #word OC2CON2bits = 0x19C 
.................... #word OC2CON2 = 0x19C 
....................  
.................... #word OC2RS = 0x19E 
....................  
.................... #word OC2R = 0x1A0 
....................  
.................... #word OC2TMR = 0x1A2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC3CON1BITS; 
.................... OC3CON1BITS OC3CON1bits; 
.................... #word OC3CON1bits = 0x1A4 
.................... #word OC3CON1 = 0x1A4 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC3CON2BITS; 
.................... OC3CON2BITS OC3CON2bits; 
.................... #word OC3CON2bits = 0x1A6 
.................... #word OC3CON2 = 0x1A6 
....................  
.................... #word OC3RS = 0x1A8 
....................  
.................... #word OC3R = 0x1AA 
....................  
.................... #word OC3TMR = 0x1AC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC4CON1BITS; 
.................... OC4CON1BITS OC4CON1bits; 
.................... #word OC4CON1bits = 0x1AE 
.................... #word OC4CON1 = 0x1AE 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC4CON2BITS; 
.................... OC4CON2BITS OC4CON2bits; 
.................... #word OC4CON2bits = 0x1B0 
.................... #word OC4CON2 = 0x1B0 
....................  
.................... #word OC4RS = 0x1B2 
....................  
.................... #word OC4R = 0x1B4 
....................  
.................... #word OC4TMR = 0x1B6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC5CON1BITS; 
.................... OC5CON1BITS OC5CON1bits; 
.................... #word OC5CON1bits = 0x1B8 
.................... #word OC5CON1 = 0x1B8 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC5CON2BITS; 
.................... OC5CON2BITS OC5CON2bits; 
.................... #word OC5CON2bits = 0x1BA 
.................... #word OC5CON2 = 0x1BA 
....................  
.................... #word OC5RS = 0x1BC 
....................  
.................... #word OC5R = 0x1BE 
....................  
.................... #word OC5TMR = 0x1C0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC6CON1BITS; 
.................... OC6CON1BITS OC6CON1bits; 
.................... #word OC6CON1bits = 0x1C2 
.................... #word OC6CON1 = 0x1C2 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC6CON2BITS; 
.................... OC6CON2BITS OC6CON2bits; 
.................... #word OC6CON2bits = 0x1C4 
.................... #word OC6CON2 = 0x1C4 
....................  
.................... #word OC6RS = 0x1C6 
....................  
.................... #word OC6R = 0x1C8 
....................  
.................... #word OC6TMR = 0x1CA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC7CON1BITS; 
.................... OC7CON1BITS OC7CON1bits; 
.................... #word OC7CON1bits = 0x1CC 
.................... #word OC7CON1 = 0x1CC 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC7CON2BITS; 
.................... OC7CON2BITS OC7CON2bits; 
.................... #word OC7CON2bits = 0x1CE 
.................... #word OC7CON2 = 0x1CE 
....................  
.................... #word OC7RS = 0x1D0 
....................  
.................... #word OC7R = 0x1D2 
....................  
.................... #word OC7TMR = 0x1D4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC8CON1BITS; 
.................... OC8CON1BITS OC8CON1bits; 
.................... #word OC8CON1bits = 0x1D6 
.................... #word OC8CON1 = 0x1D6 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC8CON2BITS; 
.................... OC8CON2BITS OC8CON2bits; 
.................... #word OC8CON2bits = 0x1D8 
.................... #word OC8CON2 = 0x1D8 
....................  
.................... #word OC8RS = 0x1DA 
....................  
.................... #word OC8R = 0x1DC 
....................  
.................... #word OC8TMR = 0x1DE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC9CON1BITS; 
.................... OC9CON1BITS OC9CON1bits; 
.................... #word OC9CON1bits = 0x1E0 
.................... #word OC9CON1 = 0x1E0 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC9CON2BITS; 
.................... OC9CON2BITS OC9CON2bits; 
.................... #word OC9CON2bits = 0x1E2 
.................... #word OC9CON2 = 0x1E2 
....................  
.................... #word OC9RS = 0x1E4 
....................  
.................... #word OC9R = 0x1E6 
....................  
.................... #word OC9TMR = 0x1E8 
....................  
.................... #word I2C1RCV = 0x200 
....................  
.................... #word I2C1TRN = 0x202 
....................  
.................... #word I2C1BRG = 0x204 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int STREN:1; 
....................    unsigned int GCEN:1; 
....................    unsigned int SMEN:1; 
....................    unsigned int DISSLW:1; 
....................    unsigned int A10M:1; 
....................    unsigned int IPMIEN:1; 
....................    unsigned int SCLREL:1; 
....................    unsigned int I2CSIDL:1; 
....................    unsigned int :1; 
....................    unsigned int I2CEN:1; 
.................... } I2C1CONBITS; 
.................... I2C1CONBITS I2C1CONbits; 
.................... #word I2C1CONbits = 0x206 
.................... #word I2C1CON = 0x206 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int TBF:1; 
....................          unsigned int RBF:1; 
....................          unsigned int R:1; 
....................          unsigned int S:1; 
....................          unsigned int P:1; 
....................          unsigned int D:1; 
....................          unsigned int I2COV:1; 
....................          unsigned int IWCOL:1; 
....................          unsigned int ADD10:1; 
....................          unsigned int GCSTAT:1; 
....................          unsigned int BCL:1; 
....................          unsigned int :3; 
....................          unsigned int TRSTAT:1; 
....................          unsigned int ACKSTAT:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int R_W:1; 
....................          unsigned int :2; 
....................          unsigned int D_A:1; 
....................       }; 
....................    }; 
.................... } I2C1STATBITS; 
.................... I2C1STATBITS I2C1STATbits; 
.................... #word I2C1STATbits = 0x208 
.................... #word I2C1STAT = 0x208 
....................  
.................... #word I2C1ADD = 0x20A 
....................  
.................... #word I2C1MSK = 0x20C 
....................  
.................... #word I2C2RCV = 0x210 
....................  
.................... #word I2C2TRN = 0x212 
....................  
.................... #word I2C2BRG = 0x214 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int STREN:1; 
....................    unsigned int GCEN:1; 
....................    unsigned int SMEN:1; 
....................    unsigned int DISSLW:1; 
....................    unsigned int A10M:1; 
....................    unsigned int IPMIEN:1; 
....................    unsigned int SCLREL:1; 
....................    unsigned int I2CSIDL:1; 
....................    unsigned int :1; 
....................    unsigned int I2CEN:1; 
.................... } I2C2CONBITS; 
.................... I2C2CONBITS I2C2CONbits; 
.................... #word I2C2CONbits = 0x216 
.................... #word I2C2CON = 0x216 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int TBF:1; 
....................          unsigned int RBF:1; 
....................          unsigned int R:1; 
....................          unsigned int S:1; 
....................          unsigned int P:1; 
....................          unsigned int D:1; 
....................          unsigned int I2COV:1; 
....................          unsigned int IWCOL:1; 
....................          unsigned int ADD10:1; 
....................          unsigned int GCSTAT:1; 
....................          unsigned int BCL:1; 
....................          unsigned int :3; 
....................          unsigned int TRSTAT:1; 
....................          unsigned int ACKSTAT:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int R_W:1; 
....................          unsigned int :2; 
....................          unsigned int D_A:1; 
....................       }; 
....................    }; 
.................... } I2C2STATBITS; 
.................... I2C2STATBITS I2C2STATbits; 
.................... #word I2C2STATbits = 0x218 
.................... #word I2C2STAT = 0x218 
....................  
.................... #word I2C2ADD = 0x21A 
....................  
.................... #word I2C2MSK = 0x21C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int STSEL:1; 
....................          unsigned int PDSEL0:2; 
....................          unsigned int BRGH:1; 
....................          unsigned int RXINV:1; 
....................          unsigned int ABAUD:1; 
....................          unsigned int LPBACK:1; 
....................          unsigned int WAKE:1; 
....................          unsigned int UEN0:2; 
....................          unsigned int :1; 
....................          unsigned int RTSMD:1; 
....................          unsigned int IREN:1; 
....................          unsigned int USIDL:1; 
....................          unsigned int :1; 
....................          unsigned int UARTEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int PDSEL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int UEN:2; 
....................       }; 
.................... } U1MODEBITS; 
.................... U1MODEBITS U1MODEbits; 
.................... #word U1MODEbits = 0x220 
.................... #word U1MODE = 0x220 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXDA:1; 
....................          unsigned int OERR:1; 
....................          unsigned int FERR:1; 
....................          unsigned int PERR:1; 
....................          unsigned int RIDLE:1; 
....................          unsigned int ADDEN:1; 
....................          unsigned int URXISEL0:2; 
....................          unsigned int TRMT:1; 
....................          unsigned int UTXBF:1; 
....................          unsigned int UTXEN:1; 
....................          unsigned int UTXBRK:1; 
....................          unsigned int :1; 
....................          unsigned int UTXISEL0:1; 
....................          unsigned int UTXINV:1; 
....................          unsigned int UTXISEL1:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int URXISEL:2; 
....................       }; 
.................... } U1STABITS; 
.................... U1STABITS U1STAbits; 
.................... #word U1STAbits = 0x222 
.................... #word U1STA = 0x222 
....................  
.................... #word U1TXREG = 0x224 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int UTXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int UTXREG:9; 
....................       }; 
.................... } U1TXREGBITS; 
.................... U1TXREGBITS U1TXREGbits; 
.................... #word U1TXREGbits = 0x224 
.................... #word U1TXREG = 0x224 
....................  
.................... #word U1RXREG = 0x226 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int URXREG:9; 
....................       }; 
.................... } U1RXREGBITS; 
.................... U1RXREGBITS U1RXREGbits; 
.................... #word U1RXREGbits = 0x226 
.................... #word U1RXREG = 0x226 
....................  
.................... #word U1BRG = 0x228 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int STSEL:1; 
....................          unsigned int PDSEL0:2; 
....................          unsigned int BRGH:1; 
....................          unsigned int RXINV:1; 
....................          unsigned int ABAUD:1; 
....................          unsigned int LPBACK:1; 
....................          unsigned int WAKE:1; 
....................          unsigned int UEN0:2; 
....................          unsigned int :1; 
....................          unsigned int RTSMD:1; 
....................          unsigned int IREN:1; 
....................          unsigned int USIDL:1; 
....................          unsigned int :1; 
....................          unsigned int UARTEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int PDSEL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int UEN:2; 
....................       }; 
.................... } U2MODEBITS; 
.................... U2MODEBITS U2MODEbits; 
.................... #word U2MODEbits = 0x230 
.................... #word U2MODE = 0x230 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXDA:1; 
....................          unsigned int OERR:1; 
....................          unsigned int FERR:1; 
....................          unsigned int PERR:1; 
....................          unsigned int RIDLE:1; 
....................          unsigned int ADDEN:1; 
....................          unsigned int URXISEL0:2; 
....................          unsigned int TRMT:1; 
....................          unsigned int UTXBF:1; 
....................          unsigned int UTXEN:1; 
....................          unsigned int UTXBRK:1; 
....................          unsigned int :1; 
....................          unsigned int UTXISEL0:1; 
....................          unsigned int UTXINV:1; 
....................          unsigned int UTXISEL1:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int URXISEL:2; 
....................       }; 
.................... } U2STABITS; 
.................... U2STABITS U2STAbits; 
.................... #word U2STAbits = 0x232 
.................... #word U2STA = 0x232 
....................  
.................... #word U2TXREG = 0x234 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int UTXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int UTXREG:9; 
....................       }; 
.................... } U2TXREGBITS; 
.................... U2TXREGBITS U2TXREGbits; 
.................... #word U2TXREGbits = 0x234 
.................... #word U2TXREG = 0x234 
....................  
.................... #word U2RXREG = 0x236 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int URXREG:9; 
....................       }; 
.................... } U2RXREGBITS; 
.................... U2RXREGBITS U2RXREGbits; 
.................... #word U2RXREGbits = 0x236 
.................... #word U2RXREG = 0x236 
....................  
.................... #word U2BRG = 0x238 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SPIRBF:1; 
....................          unsigned int SPITBF:1; 
....................          unsigned int SISEL0:3; 
....................          unsigned int SRXMPT:1; 
....................          unsigned int SPIROV:1; 
....................          unsigned int SRMPT:1; 
....................          unsigned int SPIBEC0:3; 
....................          unsigned int :2; 
....................          unsigned int SPISIDL:1; 
....................          unsigned int :1; 
....................          unsigned int SPIEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SISEL:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SPIBEC:3; 
....................          unsigned int :2; 
....................       }; 
.................... } SPI1STATBITS; 
.................... SPI1STATBITS SPI1STATbits; 
.................... #word SPI1STATbits = 0x240 
.................... #word SPI1STAT = 0x240 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PPRE0:2; 
....................          unsigned int SPRE0:3; 
....................          unsigned int MSTEN:1; 
....................          unsigned int CKP:1; 
....................          unsigned int SSEN:1; 
....................          unsigned int CKE:1; 
....................          unsigned int SMP:1; 
....................          unsigned int MODE16:1; 
....................          unsigned int DISSDO:1; 
....................          unsigned int DISSCK:1; 
....................       }; 
....................       struct { 
....................          unsigned int PPRE:2; 
....................          unsigned int SPRE:3; 
....................       }; 
.................... } SPI1CON1BITS; 
.................... SPI1CON1BITS SPI1CON1bits; 
.................... #word SPI1CON1bits = 0x242 
.................... #word SPI1CON1 = 0x242 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPIBEN:1; 
....................    unsigned int SPIFE:1; 
....................    unsigned int :11; 
....................    unsigned int SPIFPOL:1; 
....................    unsigned int SPIFSD:1; 
....................    unsigned int FRMEN:1; 
.................... } SPI1CON2BITS; 
.................... SPI1CON2BITS SPI1CON2bits; 
.................... #word SPI1CON2bits = 0x244 
.................... #word SPI1CON2 = 0x244 
....................  
.................... #word SPI1BUF = 0x248 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int STSEL:1; 
....................          unsigned int PDSEL0:2; 
....................          unsigned int BRGH:1; 
....................          unsigned int RXINV:1; 
....................          unsigned int ABAUD:1; 
....................          unsigned int LPBACK:1; 
....................          unsigned int WAKE:1; 
....................          unsigned int UEN0:2; 
....................          unsigned int :1; 
....................          unsigned int RTSMD:1; 
....................          unsigned int IREN:1; 
....................          unsigned int USIDL:1; 
....................          unsigned int :1; 
....................          unsigned int UARTEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int PDSEL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int UEN:2; 
....................       }; 
.................... } U3MODEBITS; 
.................... U3MODEBITS U3MODEbits; 
.................... #word U3MODEbits = 0x250 
.................... #word U3MODE = 0x250 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXDA:1; 
....................          unsigned int OERR:1; 
....................          unsigned int FERR:1; 
....................          unsigned int PERR:1; 
....................          unsigned int RIDLE:1; 
....................          unsigned int ADDEN:1; 
....................          unsigned int URXISEL0:2; 
....................          unsigned int TRMT:1; 
....................          unsigned int UTXBF:1; 
....................          unsigned int UTXEN:1; 
....................          unsigned int UTXBRK:1; 
....................          unsigned int :1; 
....................          unsigned int UTXISEL0:1; 
....................          unsigned int UTXINV:1; 
....................          unsigned int UTXISEL1:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int URXISEL:2; 
....................       }; 
.................... } U3STABITS; 
.................... U3STABITS U3STAbits; 
.................... #word U3STAbits = 0x252 
.................... #word U3STA = 0x252 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int UTXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int UTXREG:9; 
....................       }; 
.................... } U3TXREGBITS; 
.................... U3TXREGBITS U3TXREGbits; 
.................... #word U3TXREGbits = 0x254 
.................... #word U3TXREG = 0x254 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int URXREG:9; 
....................       }; 
.................... } U3RXREGBITS; 
.................... U3RXREGBITS U3RXREGbits; 
.................... #word U3RXREGbits = 0x256 
.................... #word U3RXREG = 0x256 
....................  
.................... #word U3BRG = 0x258 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SPIRBF:1; 
....................          unsigned int SPITBF:1; 
....................          unsigned int SISEL0:3; 
....................          unsigned int SRXMPT:1; 
....................          unsigned int SPIROV:1; 
....................          unsigned int SRMPT:1; 
....................          unsigned int SPIBEC0:3; 
....................          unsigned int :2; 
....................          unsigned int SPISIDL:1; 
....................          unsigned int :1; 
....................          unsigned int SPIEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SISEL:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SPIBEC:3; 
....................          unsigned int :2; 
....................       }; 
.................... } SPI2STATBITS; 
.................... SPI2STATBITS SPI2STATbits; 
.................... #word SPI2STATbits = 0x260 
.................... #word SPI2STAT = 0x260 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PPRE0:2; 
....................          unsigned int SPRE0:3; 
....................          unsigned int MSTEN:1; 
....................          unsigned int CKP:1; 
....................          unsigned int SSEN:1; 
....................          unsigned int CKE:1; 
....................          unsigned int SMP:1; 
....................          unsigned int MODE16:1; 
....................          unsigned int DISSDO:1; 
....................          unsigned int DISSCK:1; 
....................       }; 
....................       struct { 
....................          unsigned int PPRE:2; 
....................          unsigned int SPRE:3; 
....................       }; 
.................... } SPI2CON1BITS; 
.................... SPI2CON1BITS SPI2CON1bits; 
.................... #word SPI2CON1bits = 0x262 
.................... #word SPI2CON1 = 0x262 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPIBEN:1; 
....................    unsigned int SPIFE:1; 
....................    unsigned int :11; 
....................    unsigned int SPIFPOL:1; 
....................    unsigned int SPIFSD:1; 
....................    unsigned int FRMEN:1; 
.................... } SPI2CON2BITS; 
.................... SPI2CON2BITS SPI2CON2bits; 
.................... #word SPI2CON2bits = 0x264 
.................... #word SPI2CON2 = 0x264 
....................  
.................... #word SPI2BUF = 0x268 
....................  
.................... #word I2C3RCV = 0x270 
....................  
.................... #word I2C3TRN = 0x272 
....................  
.................... #word I2C3BRG = 0x274 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int STREN:1; 
....................    unsigned int GCEN:1; 
....................    unsigned int SMEN:1; 
....................    unsigned int DISSLW:1; 
....................    unsigned int A10M:1; 
....................    unsigned int IPMIEN:1; 
....................    unsigned int SCLREL:1; 
....................    unsigned int I2CSIDL:1; 
....................    unsigned int :1; 
....................    unsigned int I2CEN:1; 
.................... } I2C3CONBITS; 
.................... I2C3CONBITS I2C3CONbits; 
.................... #word I2C3CONbits = 0x276 
.................... #word I2C3CON = 0x276 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int TBF:1; 
....................          unsigned int RBF:1; 
....................          unsigned int R:1; 
....................          unsigned int S:1; 
....................          unsigned int P:1; 
....................          unsigned int D:1; 
....................          unsigned int I2COV:1; 
....................          unsigned int IWCOL:1; 
....................          unsigned int ADD10:1; 
....................          unsigned int GCSTAT:1; 
....................          unsigned int BCL:1; 
....................          unsigned int :3; 
....................          unsigned int TRSTAT:1; 
....................          unsigned int ACKSTAT:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int R_W:1; 
....................          unsigned int :2; 
....................          unsigned int D_A:1; 
....................       }; 
....................    }; 
.................... } I2C3STATBITS; 
.................... I2C3STATBITS I2C3STATbits; 
.................... #word I2C3STATbits = 0x278 
.................... #word I2C3STAT = 0x278 
....................  
.................... #word I2C3ADD = 0x27A 
....................  
.................... #word I2C3MSK = 0x27C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SPIRBF:1; 
....................          unsigned int SPITBF:1; 
....................          unsigned int SISEL0:3; 
....................          unsigned int SRXMPT:1; 
....................          unsigned int SPIROV:1; 
....................          unsigned int SRMPT:1; 
....................          unsigned int SPIBEC0:3; 
....................          unsigned int :2; 
....................          unsigned int SPISIDL:1; 
....................          unsigned int :1; 
....................          unsigned int SPIEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SISEL:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SPIBEC:3; 
....................          unsigned int :2; 
....................       }; 
.................... } SPI3STATBITS; 
.................... SPI3STATBITS SPI3STATbits; 
.................... #word SPI3STATbits = 0x280 
.................... #word SPI3STAT = 0x280 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PPRE0:2; 
....................          unsigned int SPRE0:3; 
....................          unsigned int MSTEN:1; 
....................          unsigned int CKP:1; 
....................          unsigned int SSEN:1; 
....................          unsigned int CKE:1; 
....................          unsigned int SMP:1; 
....................          unsigned int MODE16:1; 
....................          unsigned int DISSDO:1; 
....................          unsigned int DISSCK:1; 
....................       }; 
....................       struct { 
....................          unsigned int PPRE:2; 
....................          unsigned int SPRE:3; 
....................       }; 
.................... } SPI3CON1BITS; 
.................... SPI3CON1BITS SPI3CON1bits; 
.................... #word SPI3CON1bits = 0x282 
.................... #word SPI3CON1 = 0x282 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPIBEN:1; 
....................    unsigned int SPIFE:1; 
....................    unsigned int :11; 
....................    unsigned int SPIFPOL:1; 
....................    unsigned int SPIFSD:1; 
....................    unsigned int FRMEN:1; 
.................... } SPI3CON2BITS; 
.................... SPI3CON2BITS SPI3CON2bits; 
.................... #word SPI3CON2bits = 0x284 
.................... #word SPI3CON2 = 0x284 
....................  
.................... #word SPI3BUF = 0x288 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int STSEL:1; 
....................          unsigned int PDSEL0:2; 
....................          unsigned int BRGH:1; 
....................          unsigned int RXINV:1; 
....................          unsigned int ABAUD:1; 
....................          unsigned int LPBACK:1; 
....................          unsigned int WAKE:1; 
....................          unsigned int UEN0:2; 
....................          unsigned int :1; 
....................          unsigned int RTSMD:1; 
....................          unsigned int IREN:1; 
....................          unsigned int USIDL:1; 
....................          unsigned int :1; 
....................          unsigned int UARTEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int PDSEL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int UEN:2; 
....................       }; 
.................... } U4MODEBITS; 
.................... U4MODEBITS U4MODEbits; 
.................... #word U4MODEbits = 0x2B0 
.................... #word U4MODE = 0x2B0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXDA:1; 
....................          unsigned int OERR:1; 
....................          unsigned int FERR:1; 
....................          unsigned int PERR:1; 
....................          unsigned int RIDLE:1; 
....................          unsigned int ADDEN:1; 
....................          unsigned int URXISEL0:2; 
....................          unsigned int TRMT:1; 
....................          unsigned int UTXBF:1; 
....................          unsigned int UTXEN:1; 
....................          unsigned int UTXBRK:1; 
....................          unsigned int :1; 
....................          unsigned int UTXISEL0:1; 
....................          unsigned int UTXINV:1; 
....................          unsigned int UTXISEL1:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int URXISEL:2; 
....................       }; 
.................... } U4STABITS; 
.................... U4STABITS U4STAbits; 
.................... #word U4STAbits = 0x2B2 
.................... #word U4STA = 0x2B2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int UTXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int UTXREG:9; 
....................       }; 
.................... } U4TXREGBITS; 
.................... U4TXREGBITS U4TXREGbits; 
.................... #word U4TXREGbits = 0x2B4 
.................... #word U4TXREG = 0x2B4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int URXREG:9; 
....................       }; 
.................... } U4RXREGBITS; 
.................... U4RXREGBITS U4RXREGbits; 
.................... #word U4RXREGbits = 0x2B6 
.................... #word U4RXREG = 0x2B6 
....................  
.................... #word U4BRG = 0x2B8 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
....................    unsigned int TRISB8:1; 
....................    unsigned int TRISB9:1; 
....................    unsigned int TRISB10:1; 
....................    unsigned int TRISB11:1; 
....................    unsigned int TRISB12:1; 
....................    unsigned int TRISB13:1; 
....................    unsigned int TRISB14:1; 
....................    unsigned int TRISB15:1; 
.................... } TRISBBITS; 
.................... TRISBBITS TRISBbits; 
.................... #word TRISBbits = 0x2C8 
.................... #word TRISB = 0x2C8 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
....................    unsigned int RB8:1; 
....................    unsigned int RB9:1; 
....................    unsigned int RB10:1; 
....................    unsigned int RB11:1; 
....................    unsigned int RB12:1; 
....................    unsigned int RB13:1; 
....................    unsigned int RB14:1; 
....................    unsigned int RB15:1; 
.................... } PORTBBITS; 
.................... PORTBBITS PORTBbits; 
.................... #word PORTBbits = 0x2CA 
.................... #word PORTB = 0x2CA 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
....................    unsigned int LATB8:1; 
....................    unsigned int LATB9:1; 
....................    unsigned int LATB10:1; 
....................    unsigned int LATB11:1; 
....................    unsigned int LATB12:1; 
....................    unsigned int LATB13:1; 
....................    unsigned int LATB14:1; 
....................    unsigned int LATB15:1; 
.................... } LATBBITS; 
.................... LATBBITS LATBbits; 
.................... #word LATBbits = 0x2CC 
.................... #word LATB = 0x2CC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ODB0:16; 
....................       }; 
....................       struct { 
....................          unsigned int ODB:16; 
....................       }; 
.................... } ODCBBITS; 
.................... ODCBBITS ODCBbits; 
.................... #word ODCBbits = 0x2CE 
.................... #word ODCB = 0x2CE 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
....................    unsigned int TRISC8:1; 
....................    unsigned int TRISC9:1; 
....................    unsigned int TRISC10:1; 
....................    unsigned int TRISC11:1; 
....................    unsigned int TRISC12:1; 
....................    unsigned int TRISC13:1; 
....................    unsigned int TRISC14:1; 
....................    unsigned int TRISC15:1; 
.................... } TRISCBITS; 
.................... TRISCBITS TRISCbits; 
.................... #word TRISCbits = 0x2D0 
.................... #word TRISC = 0x2D0 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
....................    unsigned int RC8:1; 
....................    unsigned int RC9:1; 
....................    unsigned int RC10:1; 
....................    unsigned int RC11:1; 
....................    unsigned int RC12:1; 
....................    unsigned int RC13:1; 
....................    unsigned int RC14:1; 
....................    unsigned int RC15:1; 
.................... } PORTCBITS; 
.................... PORTCBITS PORTCbits; 
.................... #word PORTCbits = 0x2D2 
.................... #word PORTC = 0x2D2 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
....................    unsigned int LATC8:1; 
....................    unsigned int LATC9:1; 
....................    unsigned int LATC10:1; 
....................    unsigned int LATC11:1; 
....................    unsigned int LATC12:1; 
....................    unsigned int LATC13:1; 
....................    unsigned int LATC14:1; 
....................    unsigned int LATC15:1; 
.................... } LATCBITS; 
.................... LATCBITS LATCbits; 
.................... #word LATCbits = 0x2D4 
.................... #word LATC = 0x2D4 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :12; 
....................    unsigned int ODC12:4; 
.................... } ODCCBITS; 
.................... ODCCBITS ODCCbits; 
.................... #word ODCCbits = 0x2D6 
.................... #word ODCC = 0x2D6 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
....................    unsigned int TRISD8:1; 
....................    unsigned int TRISD9:1; 
....................    unsigned int TRISD10:1; 
....................    unsigned int TRISD11:1; 
....................    unsigned int TRISD12:1; 
....................    unsigned int TRISD13:1; 
....................    unsigned int TRISD14:1; 
....................    unsigned int TRISD15:1; 
.................... } TRISDBITS; 
.................... TRISDBITS TRISDbits; 
.................... #word TRISDbits = 0x2D8 
.................... #word TRISD = 0x2D8 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
....................    unsigned int RD8:1; 
....................    unsigned int RD9:1; 
....................    unsigned int RD10:1; 
....................    unsigned int RD11:1; 
....................    unsigned int RD12:1; 
....................    unsigned int RD13:1; 
....................    unsigned int RD14:1; 
....................    unsigned int RD15:1; 
.................... } PORTDBITS; 
.................... PORTDBITS PORTDbits; 
.................... #word PORTDbits = 0x2DA 
.................... #word PORTD = 0x2DA 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
....................    unsigned int LATD8:1; 
....................    unsigned int LATD9:1; 
....................    unsigned int LATD10:1; 
....................    unsigned int LATD11:1; 
....................    unsigned int LATD12:1; 
....................    unsigned int LATD13:1; 
....................    unsigned int LATD14:1; 
....................    unsigned int LATD15:1; 
.................... } LATDBITS; 
.................... LATDBITS LATDbits; 
.................... #word LATDbits = 0x2DC 
.................... #word LATD = 0x2DC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ODD0:12; 
....................       }; 
....................       struct { 
....................          unsigned int ODD:12; 
....................       }; 
.................... } ODCDBITS; 
.................... ODCDBITS ODCDbits; 
.................... #word ODCDbits = 0x2DE 
.................... #word ODCD = 0x2DE 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int TRISE3:1; 
....................    unsigned int TRISE4:1; 
....................    unsigned int TRISE5:1; 
....................    unsigned int TRISE6:1; 
....................    unsigned int TRISE7:1; 
....................    unsigned int TRISE8:1; 
....................    unsigned int TRISE9:1; 
....................    unsigned int TRISE10:1; 
....................    unsigned int TRISE11:1; 
....................    unsigned int TRISE12:1; 
....................    unsigned int TRISE13:1; 
....................    unsigned int TRISE14:1; 
....................    unsigned int TRISE15:1; 
.................... } TRISEBITS; 
.................... TRISEBITS TRISEbits; 
.................... #word TRISEbits = 0x2E0 
.................... #word TRISE = 0x2E0 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RE0:1; 
....................    unsigned int RE1:1; 
....................    unsigned int RE2:1; 
....................    unsigned int RE3:1; 
....................    unsigned int RE4:1; 
....................    unsigned int RE5:1; 
....................    unsigned int RE6:1; 
....................    unsigned int RE7:1; 
....................    unsigned int RE8:1; 
....................    unsigned int RE9:1; 
....................    unsigned int RE10:1; 
....................    unsigned int RE11:1; 
....................    unsigned int RE12:1; 
....................    unsigned int RE13:1; 
....................    unsigned int RE14:1; 
....................    unsigned int RE15:1; 
.................... } PORTEBITS; 
.................... PORTEBITS PORTEbits; 
.................... #word PORTEbits = 0x2E2 
.................... #word PORTE = 0x2E2 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
....................    unsigned int LATE8:1; 
....................    unsigned int LATE9:1; 
....................    unsigned int LATE10:1; 
....................    unsigned int LATE11:1; 
....................    unsigned int LATE12:1; 
....................    unsigned int LATE13:1; 
....................    unsigned int LATE14:1; 
....................    unsigned int LATE15:1; 
.................... } LATEBITS; 
.................... LATEBITS LATEbits; 
.................... #word LATEbits = 0x2E4 
.................... #word LATE = 0x2E4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ODE0:8; 
....................       }; 
....................       struct { 
....................          unsigned int ODE:8; 
....................       }; 
.................... } ODCEBITS; 
.................... ODCEBITS ODCEbits; 
.................... #word ODCEbits = 0x2E6 
.................... #word ODCE = 0x2E6 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISF0:1; 
....................    unsigned int TRISF1:1; 
....................    unsigned int TRISF2:1; 
....................    unsigned int TRISF3:1; 
....................    unsigned int TRISF4:1; 
....................    unsigned int TRISF5:1; 
....................    unsigned int TRISF6:1; 
....................    unsigned int TRISF7:1; 
....................    unsigned int TRISF8:1; 
....................    unsigned int TRISF9:1; 
....................    unsigned int TRISF10:1; 
....................    unsigned int TRISF11:1; 
....................    unsigned int TRISF12:1; 
....................    unsigned int TRISF13:1; 
....................    unsigned int TRISF14:1; 
....................    unsigned int TRISF15:1; 
.................... } TRISFBITS; 
.................... TRISFBITS TRISFbits; 
.................... #word TRISFbits = 0x2E8 
.................... #word TRISF = 0x2E8 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RF0:1; 
....................    unsigned int RF1:1; 
....................    unsigned int RF2:1; 
....................    unsigned int RF3:1; 
....................    unsigned int RF4:1; 
....................    unsigned int RF5:1; 
....................    unsigned int RF6:1; 
....................    unsigned int RF7:1; 
....................    unsigned int RF8:1; 
....................    unsigned int RF9:1; 
....................    unsigned int RF10:1; 
....................    unsigned int RF11:1; 
....................    unsigned int RF12:1; 
....................    unsigned int RF13:1; 
....................    unsigned int RF14:1; 
....................    unsigned int RF15:1; 
.................... } PORTFBITS; 
.................... PORTFBITS PORTFbits; 
.................... #word PORTFbits = 0x2EA 
.................... #word PORTF = 0x2EA 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATF0:1; 
....................    unsigned int LATF1:1; 
....................    unsigned int LATF2:1; 
....................    unsigned int LATF3:1; 
....................    unsigned int LATF4:1; 
....................    unsigned int LATF5:1; 
....................    unsigned int LATF6:1; 
....................    unsigned int LATF7:1; 
....................    unsigned int LATF8:1; 
....................    unsigned int LATF9:1; 
....................    unsigned int LATF10:1; 
....................    unsigned int LATF11:1; 
....................    unsigned int LATF12:1; 
....................    unsigned int LATF13:1; 
....................    unsigned int LATF14:1; 
....................    unsigned int LATF15:1; 
.................... } LATFBITS; 
.................... LATFBITS LATFbits; 
.................... #word LATFbits = 0x2EC 
.................... #word LATF = 0x2EC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ODF0:2; 
....................          unsigned int :1; 
....................          unsigned int ODF3:3; 
....................          unsigned int :1; 
....................          unsigned int ODF7:1; 
....................       }; 
....................       struct { 
....................          unsigned int ODF00:2; 
....................          unsigned int :1; 
....................          unsigned int ODF03:3; 
....................       }; 
.................... } ODCFBITS; 
.................... ODCFBITS ODCFbits; 
.................... #word ODCFbits = 0x2EE 
.................... #word ODCF = 0x2EE 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISG0:1; 
....................    unsigned int TRISG1:1; 
....................    unsigned int TRISG2:1; 
....................    unsigned int TRISG3:1; 
....................    unsigned int TRISG4:1; 
....................    unsigned int TRISG5:1; 
....................    unsigned int TRISG6:1; 
....................    unsigned int TRISG7:1; 
....................    unsigned int TRISG8:1; 
....................    unsigned int TRISG9:1; 
....................    unsigned int TRISG10:1; 
....................    unsigned int TRISG11:1; 
....................    unsigned int TRISG12:1; 
....................    unsigned int TRISG13:1; 
....................    unsigned int TRISG14:1; 
....................    unsigned int TRISG15:1; 
.................... } TRISGBITS; 
.................... TRISGBITS TRISGbits; 
.................... #word TRISGbits = 0x2F0 
.................... #word TRISG = 0x2F0 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RG0:1; 
....................    unsigned int RG1:1; 
....................    unsigned int RG2:1; 
....................    unsigned int RG3:1; 
....................    unsigned int RG4:1; 
....................    unsigned int RG5:1; 
....................    unsigned int RG6:1; 
....................    unsigned int RG7:1; 
....................    unsigned int RG8:1; 
....................    unsigned int RG9:1;   
....................    unsigned int RG10:1; 
....................    unsigned int RG11:1; 
....................    unsigned int RG12:1; 
....................    unsigned int RG13:1; 
....................    unsigned int RG14:1; 
....................    unsigned int RG15:1; 
.................... } PORTGBITS; 
.................... PORTGBITS PORTGbits; 
.................... #word PORTGbits = 0x2F2 
.................... #word PORTG = 0x2F2 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATG0:1; 
....................    unsigned int LATG1:1; 
....................    unsigned int LATG2:1; 
....................    unsigned int LATG3:1; 
....................    unsigned int LATG4:1; 
....................    unsigned int LATG5:1; 
....................    unsigned int LATG6:1; 
....................    unsigned int LATG7:1; 
....................    unsigned int LATG8:1; 
....................    unsigned int LATG9:1; 
....................    unsigned int LATG10:1; 
....................    unsigned int LATG11:1; 
....................    unsigned int LATG12:1; 
....................    unsigned int LATG13:1; 
....................    unsigned int LATG14:1; 
....................    unsigned int LATG15:1; 
.................... } LATGBITS; 
.................... LATGBITS LATGbits; 
.................... #word LATGbits = 0x2F4 
.................... #word LATG = 0x2F4 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :2; 
....................    unsigned int ODG2:2; 
....................    unsigned int :2; 
....................    unsigned int ODG6:4; 
.................... } ODCGBITS; 
.................... ODCGBITS ODCGbits; 
.................... #word ODCGbits = 0x2F6 
.................... #word ODCG = 0x2F6 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int PMPTTL:1; 
....................          unsigned int RTSECSEL:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int RTSECSEL0:1; 
....................       }; 
....................    }; 
.................... } PADCFG1BITS; 
.................... PADCFG1BITS PADCFG1bits; 
.................... #word PADCFG1bits = 0x2FC 
.................... #word PADCFG1 = 0x2FC 
....................  
.................... #word ADC1BUF0 = 0x300 
....................  
.................... #word ADC1BUF1 = 0x302 
....................  
.................... #word ADC1BUF2 = 0x304 
....................  
.................... #word ADC1BUF3 = 0x306 
....................  
.................... #word ADC1BUF4 = 0x308 
....................  
.................... #word ADC1BUF5 = 0x30A 
....................  
.................... #word ADC1BUF6 = 0x30C 
....................  
.................... #word ADC1BUF7 = 0x30E 
....................  
.................... #word ADC1BUF8 = 0x310 
....................  
.................... #word ADC1BUF9 = 0x312 
....................  
.................... #word ADC1BUFA = 0x314 
....................  
.................... #word ADC1BUFB = 0x316 
....................  
.................... #word ADC1BUFC = 0x318 
....................  
.................... #word ADC1BUFD = 0x31A 
....................  
.................... #word ADC1BUFE = 0x31C 
....................  
.................... #word ADC1BUFF = 0x31E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int DONE:1; 
....................          unsigned int SAMP:1; 
....................          unsigned int ASAM:1; 
....................          unsigned int :2; 
....................          unsigned int SSRC0:3; 
....................          unsigned int FORM0:2; 
....................          unsigned int :3; 
....................          unsigned int ADSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int ADON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :2; 
....................          unsigned int SSRC:3; 
....................          unsigned int FORM:2; 
....................          unsigned int :3; 
....................       }; 
.................... } AD1CON1BITS; 
.................... AD1CON1BITS AD1CON1bits; 
.................... #word AD1CON1bits = 0x320 
.................... #word AD1CON1 = 0x320 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ALTS:1; 
....................          unsigned int BUFM:1; 
....................          unsigned int SMPI0:5; 
....................          unsigned int BUFS:1; 
....................          unsigned int :2; 
....................          unsigned int CSCNA:1; 
....................          unsigned int :2; 
....................          unsigned int VCFG0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SMPI:5; 
....................          unsigned int :1; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :2; 
....................          unsigned int VCFG:3; 
....................       }; 
.................... } AD1CON2BITS; 
.................... AD1CON2BITS AD1CON2bits; 
.................... #word AD1CON2bits = 0x322 
.................... #word AD1CON2 = 0x322 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ADCS0:8; 
....................          unsigned int SAMC0:5; 
....................          unsigned int :2; 
....................          unsigned int ADRC:1; 
....................       }; 
....................       struct { 
....................          unsigned int ADCS:8; 
....................          unsigned int SAMC:5; 
....................          unsigned int :2; 
....................       }; 
.................... } AD1CON3BITS; 
.................... AD1CON3BITS AD1CON3bits; 
.................... #word AD1CON3bits = 0x324 
.................... #word AD1CON3 = 0x324 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CH0SA0:5; 
....................          unsigned int :2; 
....................          unsigned int CH0NA:1; 
....................          unsigned int CH0SB0:5; 
....................          unsigned int :2; 
....................          unsigned int CH0NB:1; 
....................       }; 
....................       struct { 
....................          unsigned int CH0SA:5; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int CH0SB:5; 
....................          unsigned int :2; 
....................       }; 
.................... } AD1CHSBITS; 
.................... AD1CHSBITS AD1CHSbits; 
.................... #word AD1CHSbits = 0x328 
.................... #word AD1CHS = 0x328 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :8; 
....................    unsigned int CSSL24:4; 
.................... } AD1CSSHBITS; 
.................... AD1CSSHBITS AD1CSSHbits; 
.................... #word AD1CSSHbits = 0x32E 
.................... #word AD1CSSH = 0x32E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CSSL0:16; 
....................       }; 
....................       struct { 
....................          unsigned int CSSL:16; 
....................       }; 
.................... } AD1CSSLBITS; 
.................... AD1CSSLBITS AD1CSSLbits; 
.................... #word AD1CSSLbits = 0x330 
.................... #word AD1CSSL = 0x330 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EDG1STAT:1; 
....................          unsigned int EDG2STAT:1; 
....................          unsigned int EDG1SEL0:2; 
....................          unsigned int EDG1POL:1; 
....................          unsigned int EDG2SEL0:2; 
....................          unsigned int EDG2POL:1; 
....................          unsigned int CTTRIG:1; 
....................          unsigned int IDISSEN:1; 
....................          unsigned int EDGSEQEN:1; 
....................          unsigned int EDGEN:1; 
....................          unsigned int TGEN:1; 
....................          unsigned int CTMUSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int CTMUEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int EDG1SEL:2; 
....................          unsigned int :1; 
....................          unsigned int EDG2SEL:2; 
....................       }; 
.................... } CTMUCONBITS; 
.................... CTMUCONBITS CTMUCONbits; 
.................... #word CTMUCONbits = 0x33C 
.................... #word CTMUCON = 0x33C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int IRNG0:2; 
....................          unsigned int ITRIM0:6; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int IRNG:2; 
....................          unsigned int ITRIM:6; 
....................       }; 
.................... } CTMUICONBITS; 
.................... CTMUICONBITS CTMUICONbits; 
.................... #word CTMUICONbits = 0x33E 
.................... #word CTMUICON = 0x33E 
....................  
.................... #word ADC1BUF10 = 0x340 
....................  
.................... #word ADC1BUF11 = 0x342 
....................  
.................... #word ADC1BUF12 = 0x344 
....................  
.................... #word ADC1BUF13 = 0x346 
....................  
.................... #word ADC1BUF14 = 0x348 
....................  
.................... #word ADC1BUF15 = 0x34A 
....................  
.................... #word ADC1BUF16 = 0x34C 
....................  
.................... #word ADC1BUF17 = 0x34E 
....................  
.................... #word ADC1BUF18 = 0x350 
....................  
.................... #word ADC1BUF19 = 0x352 
....................  
.................... #word ADC1BUF1A = 0x354 
....................  
.................... #word ADC1BUF1B = 0x356 
....................  
.................... #word ADC1BUF1C = 0x358 
....................  
.................... #word ADC1BUF1D = 0x35A 
....................  
.................... #word ADC1BUF1E = 0x35C 
....................  
.................... #word ADC1BUF1F = 0x35E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int VBUSVDIF:1; 
....................    unsigned int :1; 
....................    unsigned int SESENDIF:1; 
....................    unsigned int SESVDIF:1; 
....................    unsigned int ACTVIF:1; 
....................    unsigned int LSTATEIF:1; 
....................    unsigned int T1MSECIF:1; 
....................    unsigned int IDIF:1; 
.................... } U1OTGIRBITS; 
.................... U1OTGIRBITS U1OTGIRbits; 
.................... #word U1OTGIRbits = 0x480 
.................... #word U1OTGIR = 0x480 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int VBUSVDIE:1; 
....................    unsigned int :1; 
....................    unsigned int SESENDIE:1; 
....................    unsigned int SESVDIE:1; 
....................    unsigned int ACTVIE:1; 
....................    unsigned int LSTATEIE:1; 
....................    unsigned int T1MSECIE:1; 
....................    unsigned int IDIE:1; 
.................... } U1OTGIEBITS; 
.................... U1OTGIEBITS U1OTGIEbits; 
.................... #word U1OTGIEbits = 0x482 
.................... #word U1OTGIE = 0x482 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int VBUSVD:1; 
....................    unsigned int :1; 
....................    unsigned int SESEND:1; 
....................    unsigned int SESVD:1; 
....................    unsigned int :1; 
....................    unsigned int LSTATE:1; 
....................    unsigned int :1; 
....................    unsigned int ID:1; 
.................... } U1OTGSTATBITS; 
.................... U1OTGSTATBITS U1OTGSTATbits; 
.................... #word U1OTGSTATbits = 0x484 
.................... #word U1OTGSTAT = 0x484 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int VBUSDIS:1; 
....................    unsigned int VBUSCHG:1; 
....................    unsigned int OTGEN:1; 
....................    unsigned int VBUSON:1; 
....................    unsigned int DMPULDWN:1; 
....................    unsigned int DPPULDWN:1; 
....................    unsigned int DMPULUP:1; 
....................    unsigned int DPPULUP:1; 
.................... } U1OTGCONBITS; 
.................... U1OTGCONBITS U1OTGCONbits; 
.................... #word U1OTGCONbits = 0x486 
.................... #word U1OTGCON = 0x486 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int USBPWR:1; 
....................          unsigned int USUSPND:1; 
....................          unsigned int :2; 
....................          unsigned int USLPGRD:1; 
....................          unsigned int :2; 
....................          unsigned int UACTPND:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int USUSPEND:1; 
....................       }; 
....................    }; 
.................... } U1PWRCBITS; 
.................... U1PWRCBITS U1PWRCbits; 
.................... #word U1PWRCbits = 0x488 
.................... #word U1PWRC = 0x488 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int URSTIF:1; 
....................          unsigned int UERRIF:1; 
....................          unsigned int SOFIF:1; 
....................          unsigned int TRNIF:1; 
....................          unsigned int IDLEIF:1; 
....................          unsigned int RESUMEIF:1; 
....................          unsigned int ATTACHIF:1; 
....................          unsigned int STALLIF:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int DETACHIF:1; 
....................       }; 
....................    }; 
.................... } U1IRBITS; 
.................... U1IRBITS U1IRbits; 
.................... #word U1IRbits = 0x48A 
.................... #word U1IR = 0x48A 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int URSTIE:1; 
....................          unsigned int UERRIE:1; 
....................          unsigned int SOFIE:1; 
....................          unsigned int TRNIE:1; 
....................          unsigned int IDLEIE:1; 
....................          unsigned int RESUMEIE:1; 
....................          unsigned int ATTACHIE:1; 
....................          unsigned int STALLIE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int DETACHIE:1; 
....................       }; 
....................    }; 
.................... } U1IEBITS; 
.................... U1IEBITS U1IEbits; 
.................... #word U1IEbits = 0x48C 
.................... #word U1IE = 0x48C 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int PIDEF:1; 
....................          unsigned int CRC5EF:1; 
....................          unsigned int CRC16EF:1; 
....................          unsigned int DFN8EF:1; 
....................          unsigned int BTOEF:1; 
....................          unsigned int DMAEF:1; 
....................          unsigned int :1; 
....................          unsigned int BTSEF:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int EOFEF:1; 
....................       }; 
....................    }; 
.................... } U1EIRBITS; 
.................... U1EIRBITS U1EIRbits; 
.................... #word U1EIRbits = 0x48E 
.................... #word U1EIR = 0x48E 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int PIDEE:1; 
....................          unsigned int CRC5EE:1; 
....................          unsigned int CRC16EE:1; 
....................          unsigned int DFN8EE:1; 
....................          unsigned int BTOEE:1; 
....................          unsigned int DMAEE:1; 
....................          unsigned int :1; 
....................          unsigned int BTSEE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int EOFEE:1; 
....................       }; 
....................    }; 
.................... } U1EIEBITS; 
.................... U1EIEBITS U1EIEbits; 
.................... #word U1EIEbits = 0x490 
.................... #word U1EIE = 0x490 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int PPBI:1; 
....................          unsigned int DIR:1; 
....................          unsigned int ENDPT0:4; 
....................       }; 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ENDPT:4; 
....................       }; 
.................... } U1STATBITS; 
.................... U1STATBITS U1STATbits; 
.................... #word U1STATbits = 0x492 
.................... #word U1STAT = 0x492 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int USBEN:1; 
....................          unsigned int PPBRST:1; 
....................          unsigned int RESUME:1; 
....................          unsigned int HOSTEN:1; 
....................          unsigned int USBRST:1; 
....................          unsigned int PKTDIS:1; 
....................          unsigned int SE0:1; 
....................          unsigned int JSTATE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int SOFEN:1; 
....................          unsigned int :3; 
....................          unsigned int RESET:1; 
....................          unsigned int TOKBUSY:1; 
....................       }; 
....................    }; 
.................... } U1CONBITS; 
.................... U1CONBITS U1CONbits; 
.................... #word U1CONbits = 0x494 
.................... #word U1CON = 0x494 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int DEVADDR0:7; 
....................          unsigned int LOWSPDEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int DEVADDR:7; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :7; 
....................          unsigned int LSPDEN:1; 
....................       }; 
....................    }; 
.................... } U1ADDRBITS; 
.................... U1ADDRBITS U1ADDRbits; 
.................... #word U1ADDRbits = 0x496 
.................... #word U1ADDR = 0x496 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int BDTPTRL0:7; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int BDTPTRL:7; 
....................       }; 
.................... } U1BDTP1BITS; 
.................... U1BDTP1BITS U1BDTP1bits; 
.................... #word U1BDTP1bits = 0x498 
.................... #word U1BDTP1 = 0x498 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int FRM0:8; 
....................       }; 
....................       struct { 
....................          unsigned int FRM:8; 
....................       }; 
.................... } U1FRMLBITS; 
.................... U1FRMLBITS U1FRMLbits; 
.................... #word U1FRMLbits = 0x49A 
.................... #word U1FRML = 0x49A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int FRM8:3; 
.................... } U1FRMHBITS; 
.................... U1FRMHBITS U1FRMHbits; 
.................... #word U1FRMHbits = 0x49C 
.................... #word U1FRMH = 0x49C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EP0:4; 
....................          unsigned int PID0:4; 
....................       }; 
....................       struct { 
....................          unsigned int EP:4; 
....................          unsigned int PID:4; 
....................       }; 
.................... } U1TOKBITS; 
.................... U1TOKBITS U1TOKbits; 
.................... #word U1TOKbits = 0x49E 
.................... #word U1TOK = 0x49E 
....................  
.................... #word U1SOF = 0x4A0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CNT0:8; 
....................       }; 
....................       struct { 
....................          unsigned int CNT:8; 
....................       }; 
.................... } U1SOFBITS; 
.................... U1SOFBITS U1SOFbits; 
.................... #word U1SOFbits = 0x4A0 
.................... #word U1SOF = 0x4A0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PPB0:2; 
....................          unsigned int :2; 
....................          unsigned int USBSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int UOEMON:1; 
....................          unsigned int UTEYE:1; 
....................       }; 
....................       struct { 
....................          unsigned int PPB:2; 
....................          unsigned int :2; 
....................       }; 
.................... } U1CNFG1BITS; 
.................... U1CNFG1BITS U1CNFG1bits; 
.................... #word U1CNFG1bits = 0x4A6 
.................... #word U1CNFG1 = 0x4A6 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int UTRDIS:1; 
....................    unsigned int UVCMPDIS:1; 
....................    unsigned int UVBUSDIS:1; 
....................    unsigned int EXTI2CEN:1; 
....................    unsigned int PUVBUS:1; 
....................    unsigned int UVCMPSEL:1; 
.................... } U1CNFG2BITS; 
.................... U1CNFG2BITS U1CNFG2bits; 
.................... #word U1CNFG2bits = 0x4A8 
.................... #word U1CNFG2 = 0x4A8 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................          unsigned int :1; 
....................          unsigned int RETRYDIS:1; 
....................          unsigned int LSPD:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................          unsigned int :3; 
....................          unsigned int LOWSPD:1; 
....................       }; 
....................    }; 
.................... } U1EP0BITS; 
.................... U1EP0BITS U1EP0bits; 
.................... #word U1EP0bits = 0x4AA 
.................... #word U1EP0 = 0x4AA 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP1BITS; 
.................... U1EP1BITS U1EP1bits; 
.................... #word U1EP1bits = 0x4AC 
.................... #word U1EP1 = 0x4AC 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP2BITS; 
.................... U1EP2BITS U1EP2bits; 
.................... #word U1EP2bits = 0x4AE 
.................... #word U1EP2 = 0x4AE 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP3BITS; 
.................... U1EP3BITS U1EP3bits; 
.................... #word U1EP3bits = 0x4B0 
.................... #word U1EP3 = 0x4B0 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP4BITS; 
.................... U1EP4BITS U1EP4bits; 
.................... #word U1EP4bits = 0x4B2 
.................... #word U1EP4 = 0x4B2 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP5BITS; 
.................... U1EP5BITS U1EP5bits; 
.................... #word U1EP5bits = 0x4B4 
.................... #word U1EP5 = 0x4B4 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP6BITS; 
.................... U1EP6BITS U1EP6bits; 
.................... #word U1EP6bits = 0x4B6 
.................... #word U1EP6 = 0x4B6 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP7BITS; 
.................... U1EP7BITS U1EP7bits; 
.................... #word U1EP7bits = 0x4B8 
.................... #word U1EP7 = 0x4B8 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP8BITS; 
.................... U1EP8BITS U1EP8bits; 
.................... #word U1EP8bits = 0x4BA 
.................... #word U1EP8 = 0x4BA 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP9BITS; 
.................... U1EP9BITS U1EP9bits; 
.................... #word U1EP9bits = 0x4BC 
.................... #word U1EP9 = 0x4BC 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP10BITS; 
.................... U1EP10BITS U1EP10bits; 
.................... #word U1EP10bits = 0x4BE 
.................... #word U1EP10 = 0x4BE 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP11BITS; 
.................... U1EP11BITS U1EP11bits; 
.................... #word U1EP11bits = 0x4C0 
.................... #word U1EP11 = 0x4C0 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP12BITS; 
.................... U1EP12BITS U1EP12bits; 
.................... #word U1EP12bits = 0x4C2 
.................... #word U1EP12 = 0x4C2 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP13BITS; 
.................... U1EP13BITS U1EP13bits; 
.................... #word U1EP13bits = 0x4C4 
.................... #word U1EP13 = 0x4C4 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP14BITS; 
.................... U1EP14BITS U1EP14bits; 
.................... #word U1EP14bits = 0x4C6 
.................... #word U1EP14 = 0x4C6 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP15BITS; 
.................... U1EP15BITS U1EP15bits; 
.................... #word U1EP15bits = 0x4C8 
.................... #word U1EP15 = 0x4C8 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int PER0:8; 
....................          unsigned int DC0:8; 
....................       }; 
....................       struct { 
....................          unsigned int PER:8; 
....................          unsigned int DC:8; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int USBRS0:8; 
....................          unsigned int USBR0:8; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int USBRS:8; 
....................          unsigned int USBR:8; 
....................       }; 
.................... } U1PWMRRSBITS; 
.................... U1PWMRRSBITS U1PWMRRSbits; 
.................... #word U1PWMRRSbits = 0x4CC 
.................... #word U1PWMRRS = 0x4CC 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :8; 
....................    unsigned int CNTEN:1; 
....................    unsigned int PWMPOL:1; 
....................    unsigned int :5; 
....................    unsigned int PWMEN:1; 
.................... } U1PWMCONBITS; 
.................... U1PWMCONBITS U1PWMCONbits; 
.................... #word U1PWMCONbits = 0x4CE 
.................... #word U1PWMCON = 0x4CE 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int VBGEN:1; 
....................    unsigned int VBG2EN:1; 
....................    unsigned int VBG6EN:1; 
.................... } ANCFGBITS; 
.................... ANCFGBITS ANCFGbits; 
.................... #word ANCFGbits = 0x4DE 
.................... #word ANCFG = 0x4DE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ANSB0:16; 
....................       }; 
....................       struct { 
....................          unsigned int ANSB:16; 
....................       }; 
.................... } ANSBBITS; 
.................... ANSBBITS ANSBbits; 
.................... #word ANSBbits = 0x4E2 
.................... #word ANSB = 0x4E2 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :13; 
....................    unsigned int ANSC13:2; 
.................... } ANSCBITS; 
.................... ANSCBITS ANSCbits; 
.................... #word ANSCbits = 0x4E4 
.................... #word ANSC = 0x4E4 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :6; 
....................    unsigned int ANSD6:2; 
.................... } ANSDBITS; 
.................... ANSDBITS ANSDbits; 
.................... #word ANSDbits = 0x4E6 
.................... #word ANSD = 0x4E6 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int ANSF0:1; 
.................... } ANSFBITS; 
.................... ANSFBITS ANSFbits; 
.................... #word ANSFbits = 0x4EA 
.................... #word ANSF = 0x4EA 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :6; 
....................    unsigned int ANSG6:4; 
.................... } ANSGBITS; 
.................... ANSGBITS ANSGbits; 
.................... #word ANSGbits = 0x4EC 
.................... #word ANSG = 0x4EC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IRQM0:2; 
....................          unsigned int BUSKEEP:1; 
....................          unsigned int :1; 
....................          unsigned int ALMODE:1; 
....................          unsigned int ALP:1; 
....................          unsigned int CSF0:2; 
....................          unsigned int MODE0:2; 
....................          unsigned int :1; 
....................          unsigned int ADRMUX0:2; 
....................          unsigned int PSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int PMPEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int IRQM:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int CSF:2; 
....................          unsigned int MODE:2; 
....................          unsigned int :1; 
....................          unsigned int ADRMUX:2; 
....................       }; 
.................... } PMCON1BITS; 
.................... PMCON1BITS PMCON1bits; 
.................... #word PMCON1bits = 0x600 
.................... #word PMCON1 = 0x600 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int RADDR0:8; 
....................          unsigned int :4; 
....................          unsigned int TIMEOUT:1; 
....................          unsigned int ERROR:1; 
....................          unsigned int :1; 
....................          unsigned int BUSY:1; 
....................       }; 
....................       struct { 
....................          unsigned int RADDR:8; 
....................          unsigned int :4; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int RADDR16:4; 
....................          unsigned int RADDR20:4; 
....................       }; 
....................    }; 
.................... } PMCON2BITS; 
.................... PMCON2BITS PMCON2bits; 
.................... #word PMCON2bits = 0x602 
.................... #word PMCON2 = 0x602 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RES0:7; 
....................          unsigned int :1; 
....................          unsigned int AWAITE:1; 
....................          unsigned int AWAITM0:2; 
....................          unsigned int :1; 
....................          unsigned int PTBE0EN:1; 
....................          unsigned int PTBE1EN:1; 
....................          unsigned int PTRDEN:1; 
....................          unsigned int PTWREN:1; 
....................       }; 
....................       struct { 
....................          unsigned int RES:7; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int AWAITM:2; 
....................       }; 
.................... } PMCON3BITS; 
.................... PMCON3BITS PMCON3bits; 
.................... #word PMCON3bits = 0x604 
.................... #word PMCON3 = 0x604 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PTEN0:16; 
....................       }; 
....................       struct { 
....................          unsigned int PTEN:16; 
....................       }; 
.................... } PMCON4BITS; 
.................... PMCON4BITS PMCON4bits; 
.................... #word PMCON4bits = 0x606 
.................... #word PMCON4 = 0x606 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int PTSZ0:2; 
....................          unsigned int ACKP:1; 
....................          unsigned int SM:1; 
....................          unsigned int RDSP:1; 
....................          unsigned int WRSP:1; 
....................          unsigned int :1; 
....................          unsigned int BEP:1; 
....................          unsigned int CSPTEN:1; 
....................          unsigned int CSP:1; 
....................          unsigned int CSDIS:1; 
....................       }; 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int PTSZ:2; 
....................       }; 
.................... } PMCS1CFBITS; 
.................... PMCS1CFBITS PMCS1CFbits; 
.................... #word PMCS1CFbits = 0x608 
.................... #word PMCS1CF = 0x608 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :3; 
....................    unsigned int BASE11:1; 
....................    unsigned int :3; 
....................    unsigned int BASE15:5; 
....................    unsigned int BASE20:4; 
.................... } PMCS1BSBITS; 
.................... PMCS1BSBITS PMCS1BSbits; 
.................... #word PMCS1BSbits = 0x60A 
.................... #word PMCS1BS = 0x60A 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int DWAITE0:2; 
....................          unsigned int DWAITM0:4; 
....................          unsigned int DWAITB0:2; 
....................          unsigned int :6; 
....................          unsigned int ACKM0:2; 
....................       }; 
....................       struct { 
....................          unsigned int DWAITE:2; 
....................          unsigned int DWAITM:4; 
....................          unsigned int DWAITB:2; 
....................          unsigned int :6; 
....................          unsigned int ACKM:2; 
....................       }; 
.................... } PMCS1MDBITS; 
.................... PMCS1MDBITS PMCS1MDbits; 
.................... #word PMCS1MDbits = 0x60C 
.................... #word PMCS1MD = 0x60C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int PTSZ0:2; 
....................          unsigned int ACKP:1; 
....................          unsigned int SM:1; 
....................          unsigned int RDSP:1; 
....................          unsigned int WRSP:1; 
....................          unsigned int :1; 
....................          unsigned int BEP:1; 
....................          unsigned int CSPTEN:1; 
....................          unsigned int CSP:1; 
....................          unsigned int CSDIS:1; 
....................       }; 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int PTSZ:2; 
....................       }; 
.................... } PMCS2CFBITS; 
.................... PMCS2CFBITS PMCS2CFbits; 
.................... #word PMCS2CFbits = 0x60E 
.................... #word PMCS2CF = 0x60E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :3; 
....................    unsigned int BASE11:1; 
....................    unsigned int :3; 
....................    unsigned int BASE15:5; 
....................    unsigned int BASE20:4; 
.................... } PMCS2BSBITS; 
.................... PMCS2BSBITS PMCS2BSbits; 
.................... #word PMCS2BSbits = 0x610 
.................... #word PMCS2BS = 0x610 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int DWAITE0:2; 
....................          unsigned int DWAITM0:4; 
....................          unsigned int DWAITB0:2; 
....................          unsigned int :6; 
....................          unsigned int ACKM0:2; 
....................       }; 
....................       struct { 
....................          unsigned int DWAITE:2; 
....................          unsigned int DWAITM:4; 
....................          unsigned int DWAITB:2; 
....................          unsigned int :6; 
....................          unsigned int ACKM:2; 
....................       }; 
.................... } PMCS2MDBITS; 
.................... PMCS2MDBITS PMCS2MDbits; 
.................... #word PMCS2MDbits = 0x612 
.................... #word PMCS2MD = 0x612 
....................  
.................... #word PMDOUT1 = 0x614 
....................  
.................... #word PMDOUT2 = 0x616 
....................  
.................... #word PMDIN1 = 0x618 
....................  
.................... #word PMDIN2 = 0x61A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int OB0E:1; 
....................    unsigned int OB1E:1; 
....................    unsigned int OB2E:1; 
....................    unsigned int OB3E:1; 
....................    unsigned int :2; 
....................    unsigned int OBUF:1; 
....................    unsigned int OBE:1; 
....................    unsigned int IB0F:1; 
....................    unsigned int IB1F:1; 
....................    unsigned int IB2F:1; 
....................    unsigned int IB3F:1; 
....................    unsigned int :2; 
....................    unsigned int IBOV:1; 
....................    unsigned int IBF:1; 
.................... } PMSTATBITS; 
.................... PMSTATBITS PMSTATbits; 
.................... #word PMSTATbits = 0x61C 
.................... #word PMSTAT = 0x61C 
....................  
.................... #word ALRMVAL = 0x620 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ARPT0:8; 
....................          unsigned int ALRMPTR0:2; 
....................          unsigned int AMASK0:4; 
....................          unsigned int CHIME:1; 
....................          unsigned int ALRMEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int ARPT:8; 
....................          unsigned int ALRMPTR:2; 
....................          unsigned int AMASK:4; 
....................       }; 
.................... } ALCFGRPTBITS; 
.................... ALCFGRPTBITS ALCFGRPTbits; 
.................... #word ALCFGRPTbits = 0x622 
.................... #word ALCFGRPT = 0x622 
....................  
.................... #word RTCVAL = 0x624 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CAL0:1; 
....................          unsigned int CAL1:1; 
....................          unsigned int CAL2:1; 
....................          unsigned int CAL3:1; 
....................          unsigned int CAL4:1; 
....................          unsigned int CAL5:1; 
....................          unsigned int CAL6:1; 
....................          unsigned int CAL7:1; 
....................          unsigned int RTCPTR0:1; 
....................          unsigned int RTCPTR1:1; 
....................          unsigned int RTCOE:1; 
....................          unsigned int HALFSEC:1; 
....................          unsigned int RTCSYNC:1; 
....................          unsigned int RTCWREN:1; 
....................          unsigned int :1; 
....................          unsigned int RTCEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int CAL:8; 
....................          unsigned int RTCPTR:2; 
....................       }; 
.................... } RCFGCALBITS; 
.................... RCFGCALBITS RCFGCALbits; 
.................... #word RCFGCALbits = 0x626 
.................... #word RCFGCAL = 0x626 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
....................    unsigned int C3OUT:1; 
....................    unsigned int :5; 
....................    unsigned int C1EVT:1; 
....................    unsigned int C2EVT:1; 
....................    unsigned int C3EVT:1; 
....................    unsigned int :4; 
....................    unsigned int CMIDL:1; 
.................... } CMSTATBITS; 
.................... CMSTATBITS CMSTATbits; 
.................... #word CMSTATbits = 0x630 
.................... #word CMSTAT = 0x630 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CVR0:4; 
....................          unsigned int CVRSS:1; 
....................          unsigned int CVRR:1; 
....................          unsigned int CVROE:1; 
....................          unsigned int CVREN:1; 
....................          unsigned int CVREFM0:2; 
....................          unsigned int CVREFP:1; 
....................       }; 
....................       struct { 
....................          unsigned int CVR:4; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int CVREFM:2; 
....................       }; 
.................... } CVRCONBITS; 
.................... CVRCONBITS CVRCONbits; 
.................... #word CVRCONbits = 0x632 
.................... #word CVRCON = 0x632 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int CCH0:2; 
....................          unsigned int :2; 
....................          unsigned int CREF:1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL0:2; 
....................          unsigned int COUT:1; 
....................          unsigned int CEVT:1; 
....................          unsigned int :3; 
....................          unsigned int CPOL:1; 
....................          unsigned int COE:1; 
....................          unsigned int CON:1; 
....................       }; 
....................       struct { 
....................          unsigned int CCH:2; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int CEN:1; 
....................       }; 
....................    }; 
.................... } CM1CONBITS; 
.................... CM1CONBITS CM1CONbits; 
.................... #word CM1CONbits = 0x634 
.................... #word CM1CON = 0x634 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int CCH0:2; 
....................          unsigned int :2; 
....................          unsigned int CREF:1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL0:2; 
....................          unsigned int COUT:1; 
....................          unsigned int CEVT:1; 
....................          unsigned int :3; 
....................          unsigned int CPOL:1; 
....................          unsigned int COE:1; 
....................          unsigned int CON:1; 
....................       }; 
....................       struct { 
....................          unsigned int CCH:2; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int CEN:1; 
....................       }; 
....................    }; 
.................... } CM2CONBITS; 
.................... CM2CONBITS CM2CONbits; 
.................... #word CM2CONbits = 0x636 
.................... #word CM2CON = 0x636 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int CCH0:2; 
....................          unsigned int :2; 
....................          unsigned int CREF:1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL0:2; 
....................          unsigned int COUT:1; 
....................          unsigned int CEVT:1; 
....................          unsigned int :3; 
....................          unsigned int CPOL:1; 
....................          unsigned int COE:1; 
....................          unsigned int CON:1; 
....................       }; 
....................       struct { 
....................          unsigned int CCH:2; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int CEN:1; 
....................       }; 
....................    }; 
.................... } CM3CONBITS; 
.................... CM3CONBITS CM3CONbits; 
.................... #word CM3CONbits = 0x638 
.................... #word CM3CON = 0x638 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int LENDIAN:1; 
....................          unsigned int CRCGO:1; 
....................          unsigned int CRCISEL:1; 
....................          unsigned int CRCMPT:1; 
....................          unsigned int CRCFUL:1; 
....................          unsigned int VWORD0:5; 
....................          unsigned int CSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int CRCEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int VWORD:5; 
....................       }; 
.................... } CRCCON1BITS; 
.................... CRCCON1BITS CRCCON1bits; 
.................... #word CRCCON1bits = 0x640 
.................... #word CRCCON1 = 0x640 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PLEN0:5; 
....................          unsigned int :3; 
....................          unsigned int DWIDTH0:5; 
....................       }; 
....................       struct { 
....................          unsigned int PLEN:5; 
....................          unsigned int :3; 
....................          unsigned int DWIDTH:5; 
....................       }; 
.................... } CRCCON2BITS; 
.................... CRCCON2BITS CRCCON2bits; 
.................... #word CRCCON2bits = 0x642 
.................... #word CRCCON2 = 0x642 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int X1:15; 
.................... } CRCXORLBITS; 
.................... CRCXORLBITS CRCXORLbits; 
.................... #word CRCXORLbits = 0x644 
.................... #word CRCXORL = 0x644 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int X16:4; 
....................    unsigned int X20:10; 
....................    unsigned int X30:2; 
.................... } CRCXORHBITS; 
.................... CRCXORHBITS CRCXORHbits; 
.................... #word CRCXORHbits = 0x646 
.................... #word CRCXORH = 0x646 
....................  
.................... #word CRCDAT = 0x648 
....................  
.................... #word CRCWDAT = 0x64C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int INT1R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int INT1R:6; 
....................       }; 
.................... } RPINR0BITS; 
.................... RPINR0BITS RPINR0bits; 
.................... #word RPINR0bits = 0x680 
.................... #word RPINR0 = 0x680 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int INT2R0:6; 
....................          unsigned int :2; 
....................          unsigned int INT3R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int INT2R:6; 
....................          unsigned int :2; 
....................          unsigned int INT3R:6; 
....................       }; 
.................... } RPINR1BITS; 
.................... RPINR1BITS RPINR1bits; 
.................... #word RPINR1bits = 0x682 
.................... #word RPINR1 = 0x682 
....................  
.................... #word RPINR2 = 0x684 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int T2CKR0:6; 
....................          unsigned int :2; 
....................          unsigned int T3CKR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int T2CKR:6; 
....................          unsigned int :2; 
....................          unsigned int T3CKR:6; 
....................       }; 
.................... } RPINR3BITS; 
.................... RPINR3BITS RPINR3bits; 
.................... #word RPINR3bits = 0x686 
.................... #word RPINR3 = 0x686 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int T4CKR0:6; 
....................          unsigned int :2; 
....................          unsigned int T5CKR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int T4CKR:6; 
....................          unsigned int :2; 
....................          unsigned int T5CKR:6; 
....................       }; 
.................... } RPINR4BITS; 
.................... RPINR4BITS RPINR4bits; 
.................... #word RPINR4bits = 0x688 
.................... #word RPINR4 = 0x688 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IC1R0:6; 
....................          unsigned int :2; 
....................          unsigned int IC2R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int IC1R:6; 
....................          unsigned int :2; 
....................          unsigned int IC2R:6; 
....................       }; 
.................... } RPINR7BITS; 
.................... RPINR7BITS RPINR7bits; 
.................... #word RPINR7bits = 0x68E 
.................... #word RPINR7 = 0x68E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IC3R0:6; 
....................          unsigned int :2; 
....................          unsigned int IC4R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int IC3R:6; 
....................          unsigned int :2; 
....................          unsigned int IC4R:6; 
....................       }; 
.................... } RPINR8BITS; 
.................... RPINR8BITS RPINR8bits; 
.................... #word RPINR8bits = 0x690 
.................... #word RPINR8 = 0x690 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IC5R0:6; 
....................          unsigned int :2; 
....................          unsigned int IC6R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int IC5R:6; 
....................          unsigned int :2; 
....................          unsigned int IC6R:6; 
....................       }; 
.................... } RPINR9BITS; 
.................... RPINR9BITS RPINR9bits; 
.................... #word RPINR9bits = 0x692 
.................... #word RPINR9 = 0x692 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IC7R0:6; 
....................          unsigned int :2; 
....................          unsigned int IC8R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int IC7R:6; 
....................          unsigned int :2; 
....................          unsigned int IC8R:6; 
....................       }; 
.................... } RPINR10BITS; 
.................... RPINR10BITS RPINR10bits; 
.................... #word RPINR10bits = 0x694 
.................... #word RPINR10 = 0x694 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCFAR0:6; 
....................          unsigned int :2; 
....................          unsigned int OCFBR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int OCFAR:6; 
....................          unsigned int :2; 
....................          unsigned int OCFBR:6; 
....................       }; 
.................... } RPINR11BITS; 
.................... RPINR11BITS RPINR11bits; 
.................... #word RPINR11bits = 0x696 
.................... #word RPINR11 = 0x696 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int IC9R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int IC9R:6; 
....................       }; 
.................... } RPINR15BITS; 
.................... RPINR15BITS RPINR15bits; 
.................... #word RPINR15bits = 0x69E 
.................... #word RPINR15 = 0x69E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int U3RXR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int U3RXR:6; 
....................       }; 
.................... } RPINR17BITS; 
.................... RPINR17BITS RPINR17bits; 
.................... #word RPINR17bits = 0x6A2 
.................... #word RPINR17 = 0x6A2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int U1RXR0:6; 
....................          unsigned int :2; 
....................          unsigned int U1CTSR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int U1RXR:6; 
....................          unsigned int :2; 
....................          unsigned int U1CTSR:6; 
....................       }; 
.................... } RPINR18BITS; 
.................... RPINR18BITS RPINR18bits; 
.................... #word RPINR18bits = 0x6A4 
.................... #word RPINR18 = 0x6A4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int U2RXR0:6; 
....................          unsigned int :2; 
....................          unsigned int U2CTSR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int U2RXR:6; 
....................          unsigned int :2; 
....................          unsigned int U2CTSR:6; 
....................       }; 
.................... } RPINR19BITS; 
.................... RPINR19BITS RPINR19bits; 
.................... #word RPINR19bits = 0x6A6 
.................... #word RPINR19 = 0x6A6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SDI1R0:6; 
....................          unsigned int :2; 
....................          unsigned int SCK1R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int SDI1R:6; 
....................          unsigned int :2; 
....................          unsigned int SCK1R:6; 
....................       }; 
.................... } RPINR20BITS; 
.................... RPINR20BITS RPINR20bits; 
.................... #word RPINR20bits = 0x6A8 
.................... #word RPINR20 = 0x6A8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SS1R0:6; 
....................          unsigned int :2; 
....................          unsigned int U3CTSR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int SS1R:6; 
....................          unsigned int :2; 
....................          unsigned int U3CTSR:6; 
....................       }; 
.................... } RPINR21BITS; 
.................... RPINR21BITS RPINR21bits; 
.................... #word RPINR21bits = 0x6AA 
.................... #word RPINR21 = 0x6AA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SDI2R0:6; 
....................          unsigned int :2; 
....................          unsigned int SCK2R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int SDI2R:6; 
....................          unsigned int :2; 
....................          unsigned int SCK2R:6; 
....................       }; 
.................... } RPINR22BITS; 
.................... RPINR22BITS RPINR22bits; 
.................... #word RPINR22bits = 0x6AC 
.................... #word RPINR22 = 0x6AC 
....................  
.................... #word RPINR23 = 0x6AE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int U4RXR0:6; 
....................          unsigned int :2; 
....................          unsigned int U4CTSR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int U4RXR:6; 
....................          unsigned int :2; 
....................          unsigned int U4CTSR:6; 
....................       }; 
.................... } RPINR27BITS; 
.................... RPINR27BITS RPINR27bits; 
.................... #word RPINR27bits = 0x6B6 
.................... #word RPINR27 = 0x6B6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SDI3R0:6; 
....................          unsigned int :2; 
....................          unsigned int SCK3R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int SDI3R:6; 
....................          unsigned int :2; 
....................          unsigned int SCK3R:6; 
....................       }; 
.................... } RPINR28BITS; 
.................... RPINR28BITS RPINR28bits; 
.................... #word RPINR28bits = 0x6B8 
.................... #word RPINR28 = 0x6B8 
....................  
.................... #word RPINR29 = 0x6BA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP0R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP1R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP0R:6; 
....................          unsigned int :2; 
....................          unsigned int RP1R:6; 
....................       }; 
.................... } RPOR0BITS; 
.................... RPOR0BITS RPOR0bits; 
.................... #word RPOR0bits = 0x6C0 
.................... #word RPOR0 = 0x6C0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP2R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP3R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP2R:6; 
....................          unsigned int :2; 
....................          unsigned int RP3R:6; 
....................       }; 
.................... } RPOR1BITS; 
.................... RPOR1BITS RPOR1bits; 
.................... #word RPOR1bits = 0x6C2 
.................... #word RPOR1 = 0x6C2 
....................  
.................... #word RPOR2 = 0x6C4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP6R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP7R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP6R:6; 
....................          unsigned int :2; 
....................          unsigned int RP7R:6; 
....................       }; 
.................... } RPOR3BITS; 
.................... RPOR3BITS RPOR3bits; 
.................... #word RPOR3bits = 0x6C6 
.................... #word RPOR3 = 0x6C6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP8R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP9R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP8R:6; 
....................          unsigned int :2; 
....................          unsigned int RP9R:6; 
....................       }; 
.................... } RPOR4BITS; 
.................... RPOR4BITS RPOR4bits; 
.................... #word RPOR4bits = 0x6C8 
.................... #word RPOR4 = 0x6C8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP10R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP11R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP10R:6; 
....................          unsigned int :2; 
....................          unsigned int RP11R:6; 
....................       }; 
.................... } RPOR5BITS; 
.................... RPOR5BITS RPOR5bits; 
.................... #word RPOR5bits = 0x6CA 
.................... #word RPOR5 = 0x6CA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP12R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP13R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP12R:6; 
....................          unsigned int :2; 
....................          unsigned int RP13R:6; 
....................       }; 
.................... } RPOR6BITS; 
.................... RPOR6BITS RPOR6bits; 
.................... #word RPOR6bits = 0x6CC 
.................... #word RPOR6 = 0x6CC 
....................  
.................... #word RPOR7 = 0x6CE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP16R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP17R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP16R:6; 
....................          unsigned int :2; 
....................          unsigned int RP17R:6; 
....................       }; 
.................... } RPOR8BITS; 
.................... RPOR8BITS RPOR8bits; 
.................... #word RPOR8bits = 0x6D0 
.................... #word RPOR8 = 0x6D0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP18R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP19R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP18R:6; 
....................          unsigned int :2; 
....................          unsigned int RP19R:6; 
....................       }; 
.................... } RPOR9BITS; 
.................... RPOR9BITS RPOR9bits; 
.................... #word RPOR9bits = 0x6D2 
.................... #word RPOR9 = 0x6D2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP20R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP21R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP20R:6; 
....................          unsigned int :2; 
....................          unsigned int RP21R:6; 
....................       }; 
.................... } RPOR10BITS; 
.................... RPOR10BITS RPOR10bits; 
.................... #word RPOR10bits = 0x6D4 
.................... #word RPOR10 = 0x6D4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP22R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP23R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP22R:6; 
....................          unsigned int :2; 
....................          unsigned int RP23R:6; 
....................       }; 
.................... } RPOR11BITS; 
.................... RPOR11BITS RPOR11bits; 
.................... #word RPOR11bits = 0x6D6 
.................... #word RPOR11 = 0x6D6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP24R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP25R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP24R:6; 
....................          unsigned int :2; 
....................          unsigned int RP25R:6; 
....................       }; 
.................... } RPOR12BITS; 
.................... RPOR12BITS RPOR12bits; 
.................... #word RPOR12bits = 0x6D8 
.................... #word RPOR12 = 0x6D8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP26R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP27R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP26R:6; 
....................          unsigned int :2; 
....................          unsigned int RP27R:6; 
....................       }; 
.................... } RPOR13BITS; 
.................... RPOR13BITS RPOR13bits; 
.................... #word RPOR13bits = 0x6DA 
.................... #word RPOR13 = 0x6DA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP28R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP29R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP28R:6; 
....................          unsigned int :2; 
....................          unsigned int RP29R:6; 
....................       }; 
.................... } RPOR14BITS; 
.................... RPOR14BITS RPOR14bits; 
.................... #word RPOR14bits = 0x6DC 
.................... #word RPOR14 = 0x6DC 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int POR:1; 
....................          unsigned int BOR:1; 
....................          unsigned int IDLE:1; 
....................          unsigned int SLEEP:1; 
....................          unsigned int WDTO:1; 
....................          unsigned int SWDTEN:1; 
....................          unsigned int SWR:1; 
....................          unsigned int EXTR:1; 
....................          unsigned int VREGS:1; 
....................          unsigned int CM:1; 
....................          unsigned int :4; 
....................          unsigned int IOPUWR:1; 
....................          unsigned int TRAPR:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int PMSLP:1; 
....................       }; 
....................    }; 
.................... } RCONBITS; 
.................... RCONBITS RCONbits; 
.................... #word RCONbits = 0x740 
.................... #word RCON = 0x740 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int OSWEN:1; 
....................          unsigned int SOSCEN:1; 
....................          unsigned int POSCEN:1; 
....................          unsigned int CF:1; 
....................          unsigned int :1; 
....................          unsigned int LOCK:1; 
....................          unsigned int IOLOCK:1; 
....................          unsigned int CLKLOCK:1; 
....................          unsigned int NOSC0:3; 
....................          unsigned int :1; 
....................          unsigned int COSC0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int NOSC:3; 
....................          unsigned int :1; 
....................          unsigned int COSC:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int LPOSCEN:1; 
....................       }; 
....................    }; 
.................... } OSCCONBITS; 
.................... OSCCONBITS OSCCONbits; 
.................... #word OSCCONbits = 0x742 
.................... #word OSCCON = 0x742 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int PLLEN:1; 
....................          unsigned int CPDIV0:2; 
....................          unsigned int RCDIV0:3; 
....................          unsigned int DOZEN:1; 
....................          unsigned int DOZE0:3; 
....................          unsigned int ROI:1; 
....................       }; 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int :1; 
....................          unsigned int CPDIV:2; 
....................          unsigned int RCDIV:3; 
....................          unsigned int :1; 
....................          unsigned int DOZE:3; 
....................       }; 
.................... } CLKDIVBITS; 
.................... CLKDIVBITS CLKDIVbits; 
.................... #word CLKDIVbits = 0x744 
.................... #word CLKDIV = 0x744 
....................  
.................... #word OSCTUN = 0x748 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int RODIV0:4; 
....................          unsigned int ROSEL:1; 
....................          unsigned int ROSSLP:1; 
....................          unsigned int :1; 
....................          unsigned int ROEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int RODIV:4; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int ROON:1; 
....................       }; 
....................    }; 
.................... } REFOCONBITS; 
.................... REFOCONBITS REFOCONbits; 
.................... #word REFOCONbits = 0x74E 
.................... #word REFOCON = 0x74E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int NVMOP0:4; 
....................          unsigned int :2; 
....................          unsigned int ERASE:1; 
....................          unsigned int :6; 
....................          unsigned int WRERR:1; 
....................          unsigned int WREN:1; 
....................          unsigned int WR:1; 
....................       }; 
....................       struct { 
....................          unsigned int NVMOP:4; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } NVMCONBITS; 
.................... NVMCONBITS NVMCONbits; 
.................... #word NVMCONbits = 0x760 
.................... #word NVMCON = 0x760 
....................  
.................... #word NVMKEY = 0x766 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int ADC1MD:1; 
....................    unsigned int :2; 
....................    unsigned int SPI1MD:1; 
....................    unsigned int SPI2MD:1; 
....................    unsigned int U1MD:1; 
....................    unsigned int U2MD:1; 
....................    unsigned int I2C1MD:1; 
....................    unsigned int :3; 
....................    unsigned int T1MD:1; 
....................    unsigned int T2MD:1; 
....................    unsigned int T3MD:1; 
....................    unsigned int T4MD:1; 
....................    unsigned int T5MD:1; 
.................... } PMD1BITS; 
.................... PMD1BITS PMD1bits; 
.................... #word PMD1bits = 0x770 
.................... #word PMD1 = 0x770 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int OC1MD:1; 
....................    unsigned int OC2MD:1; 
....................    unsigned int OC3MD:1; 
....................    unsigned int OC4MD:1; 
....................    unsigned int OC5MD:1; 
....................    unsigned int OC6MD:1; 
....................    unsigned int OC7MD:1; 
....................    unsigned int OC8MD:1; 
....................    unsigned int IC1MD:1; 
....................    unsigned int IC2MD:1; 
....................    unsigned int IC3MD:1; 
....................    unsigned int IC4MD:1; 
....................    unsigned int IC5MD:1; 
....................    unsigned int IC6MD:1; 
....................    unsigned int IC7MD:1; 
....................    unsigned int IC8MD:1; 
.................... } PMD2BITS; 
.................... PMD2BITS PMD2bits; 
.................... #word PMD2bits = 0x772 
.................... #word PMD2 = 0x772 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int I2C2MD:1; 
....................          unsigned int I2C3MD:1; 
....................          unsigned int U3MD:1; 
....................          unsigned int :3; 
....................          unsigned int CRCMD:1; 
....................          unsigned int PMPMD:1; 
....................          unsigned int RTCCMD:1; 
....................          unsigned int CMPMD:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :7; 
....................          unsigned int CRCPMD:1; 
....................       }; 
....................    }; 
.................... } PMD3BITS; 
.................... PMD3BITS PMD3bits; 
.................... #word PMD3bits = 0x774 
.................... #word PMD3 = 0x774 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int USB1MD:1; 
....................    unsigned int LVDMD:1; 
....................    unsigned int CTMUMD:1; 
....................    unsigned int REFOMD:1; 
....................    unsigned int :1; 
....................    unsigned int U4MD:1; 
....................    unsigned int UPWMMD:1; 
.................... } PMD4BITS; 
.................... PMD4BITS PMD4bits; 
.................... #word PMD4bits = 0x776 
.................... #word PMD4 = 0x776 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int OC9MD:1; 
....................    unsigned int :7; 
....................    unsigned int IC9MD:1; 
.................... } PMD5BITS; 
.................... PMD5BITS PMD5bits; 
.................... #word PMD5bits = 0x778 
.................... #word PMD5 = 0x778 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPI3MD:1; 
.................... } PMD6BITS; 
.................... PMD6BITS PMD6bits; 
.................... #word PMD6bits = 0x77A 
.................... #word PMD6 = 0x77A 
....................  
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GA108__) || (getenv("DEVICE")=="PIC24FJ256GA108") 
....................     #if !defined(__PIC24FJ256GA108__) 
....................         #define __PIC24FJ256GA108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GA108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GA108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GA110__) || (getenv("DEVICE")=="PIC24FJ256GA110") 
....................     #if !defined(__PIC24FJ256GA110__) 
....................         #define __PIC24FJ256GA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GB106__) || (getenv("DEVICE")=="PIC24FJ256GB106") 
....................     #if !defined(__PIC24FJ256GB106__) 
....................         #define __PIC24FJ256GB106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GB106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GB106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GB108__) || (getenv("DEVICE")=="PIC24FJ256GB108") 
....................     #if !defined(__PIC24FJ256GB108__) 
....................         #define __PIC24FJ256GB108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GB108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GB108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GB110__) || (getenv("DEVICE")=="PIC24FJ256GB110") 
....................     #if !defined(__PIC24FJ256GB110__) 
....................         #define __PIC24FJ256GB110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GB110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GB110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GB206__) || (getenv("DEVICE")=="PIC24FJ256GB206") 
....................     #if !defined(__PIC24FJ256GB206__) 
....................         #define __PIC24FJ256GB206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GB206.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GB206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GB210__) || (getenv("DEVICE")=="PIC24FJ256GB210") 
....................     #if !defined(__PIC24FJ256GB210__) 
....................         #define __PIC24FJ256GB210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GB210.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GB210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GA002__) || (getenv("DEVICE")=="PIC24FJ32GA002") 
....................     #if !defined(__PIC24FJ32GA002__) 
....................         #define __PIC24FJ32GA002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GA002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GA002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GA004__) || (getenv("DEVICE")=="PIC24FJ32GA004") 
....................     #if !defined(__PIC24FJ32GA004__) 
....................         #define __PIC24FJ32GA004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GA004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GA004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GA102__) || (getenv("DEVICE")=="PIC24FJ32GA102") 
....................     #if !defined(__PIC24FJ32GA102__) 
....................         #define __PIC24FJ32GA102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GA102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GA102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GA104__) || (getenv("DEVICE")=="PIC24FJ32GA104") 
....................     #if !defined(__PIC24FJ32GA104__) 
....................         #define __PIC24FJ32GA104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GA104.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GA104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GB002__) || (getenv("DEVICE")=="PIC24FJ32GB002") 
....................     #if !defined(__PIC24FJ32GB002__) 
....................         #define __PIC24FJ32GB002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GB002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GB002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GB004__) || (getenv("DEVICE")=="PIC24FJ32GB004") 
....................     #if !defined(__PIC24FJ32GB004__) 
....................         #define __PIC24FJ32GB004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GB004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GB004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ48GA002__) || (getenv("DEVICE")=="PIC24FJ48GA002") 
....................     #if !defined(__PIC24FJ48GA002__) 
....................         #define __PIC24FJ48GA002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ48GA002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ48GA002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ48GA004__) || (getenv("DEVICE")=="PIC24FJ48GA004") 
....................     #if !defined(__PIC24FJ48GA004__) 
....................         #define __PIC24FJ48GA004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ48GA004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ48GA004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA002__) || (getenv("DEVICE")=="PIC24FJ64GA002") 
....................     #if !defined(__PIC24FJ64GA002__) 
....................         #define __PIC24FJ64GA002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA004__) || (getenv("DEVICE")=="PIC24FJ64GA004") 
....................     #if !defined(__PIC24FJ64GA004__) 
....................         #define __PIC24FJ64GA004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA006__) || (getenv("DEVICE")=="PIC24FJ64GA006") 
....................     #if !defined(__PIC24FJ64GA006__) 
....................         #define __PIC24FJ64GA006__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA006.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA006_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA008__) || (getenv("DEVICE")=="PIC24FJ64GA008") 
....................     #if !defined(__PIC24FJ64GA008__) 
....................         #define __PIC24FJ64GA008__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA008.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA008_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA010__) || (getenv("DEVICE")=="PIC24FJ64GA010") 
....................     #if !defined(__PIC24FJ64GA010__) 
....................         #define __PIC24FJ64GA010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA010.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA102__) || (getenv("DEVICE")=="PIC24FJ64GA102") 
....................     #if !defined(__PIC24FJ64GA102__) 
....................         #define __PIC24FJ64GA102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA104__) || (getenv("DEVICE")=="PIC24FJ64GA104") 
....................     #if !defined(__PIC24FJ64GA104__) 
....................         #define __PIC24FJ64GA104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA104.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA106__) || (getenv("DEVICE")=="PIC24FJ64GA106") 
....................     #if !defined(__PIC24FJ64GA106__) 
....................         #define __PIC24FJ64GA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA108__) || (getenv("DEVICE")=="PIC24FJ64GA108") 
....................     #if !defined(__PIC24FJ64GA108__) 
....................         #define __PIC24FJ64GA108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA110__) || (getenv("DEVICE")=="PIC24FJ64GA110") 
....................     #if !defined(__PIC24FJ64GA110__) 
....................         #define __PIC24FJ64GA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA306__) || (getenv("DEVICE")=="PIC24FJ64GA306") 
....................     #if !defined(__PIC24FJ64GA306__) 
....................         #define __PIC24FJ64GA306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA306.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA308__) || (getenv("DEVICE")=="PIC24FJ64GA308") 
....................     #if !defined(__PIC24FJ64GA308__) 
....................         #define __PIC24FJ64GA308__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA308.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA308_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA310__) || (getenv("DEVICE")=="PIC24FJ64GA310") 
....................     #if !defined(__PIC24FJ64GA310__) 
....................         #define __PIC24FJ64GA310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA310.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GB002__) || (getenv("DEVICE")=="PIC24FJ64GB002") 
....................     #if !defined(__PIC24FJ64GB002__) 
....................         #define __PIC24FJ64GB002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GB002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GB002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GB004__) || (getenv("DEVICE")=="PIC24FJ64GB004") 
....................     #if !defined(__PIC24FJ64GB004__) 
....................         #define __PIC24FJ64GB004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GB004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GB004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GB106__) || (getenv("DEVICE")=="PIC24FJ64GB106") 
....................     #if !defined(__PIC24FJ64GB106__) 
....................         #define __PIC24FJ64GB106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GB106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GB106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GB108__) || (getenv("DEVICE")=="PIC24FJ64GB108") 
....................     #if !defined(__PIC24FJ64GB108__) 
....................         #define __PIC24FJ64GB108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GB108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GB108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GB110__) || (getenv("DEVICE")=="PIC24FJ64GB110") 
....................     #if !defined(__PIC24FJ64GB110__) 
....................         #define __PIC24FJ64GB110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GB110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GB110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ96GA006__) || (getenv("DEVICE")=="PIC24FJ96GA006") 
....................     #if !defined(__PIC24FJ96GA006__) 
....................         #define __PIC24FJ96GA006__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ96GA006.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ96GA006_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ96GA008__) || (getenv("DEVICE")=="PIC24FJ96GA008") 
....................     #if !defined(__PIC24FJ96GA008__) 
....................         #define __PIC24FJ96GA008__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ96GA008.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ96GA008_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ96GA010__) || (getenv("DEVICE")=="PIC24FJ96GA010") 
....................     #if !defined(__PIC24FJ96GA010__) 
....................         #define __PIC24FJ96GA010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ96GA010.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ96GA010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV08KM101__) || (getenv("DEVICE")=="PIC24FV08KM101") 
....................     #if !defined(__PIC24FV08KM101__) 
....................         #define __PIC24FV08KM101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV08KM101.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV08KM101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV08KM102__) || (getenv("DEVICE")=="PIC24FV08KM102") 
....................     #if !defined(__PIC24FV08KM102__) 
....................         #define __PIC24FV08KM102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV08KM102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV08KM102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV08KM202__) || (getenv("DEVICE")=="PIC24FV08KM202") 
....................     #if !defined(__PIC24FV08KM202__) 
....................         #define __PIC24FV08KM202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV08KM202.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV08KM202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV08KM204__) || (getenv("DEVICE")=="PIC24FV08KM204") 
....................     #if !defined(__PIC24FV08KM204__) 
....................         #define __PIC24FV08KM204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV08KM204.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV08KM204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KA301__) || (getenv("DEVICE")=="PIC24FV16KA301") 
....................     #if !defined(__PIC24FV16KA301__) 
....................         #define __PIC24FV16KA301__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KA301.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV16KA301_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KA302__) || (getenv("DEVICE")=="PIC24FV16KA302") 
....................     #if !defined(__PIC24FV16KA302__) 
....................         #define __PIC24FV16KA302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KA302.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV16KA302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KA304__) || (getenv("DEVICE")=="PIC24FV16KA304") 
....................     #if !defined(__PIC24FV16KA304__) 
....................         #define __PIC24FV16KA304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KA304.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV16KA304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KM102__) || (getenv("DEVICE")=="PIC24FV16KM102") 
....................     #if !defined(__PIC24FV16KM102__) 
....................         #define __PIC24FV16KM102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KM102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV16KM102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KM104__) || (getenv("DEVICE")=="PIC24FV16KM104") 
....................     #if !defined(__PIC24FV16KM104__) 
....................         #define __PIC24FV16KM104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KM104.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV16KM104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KM202__) || (getenv("DEVICE")=="PIC24FV16KM202") 
....................     #if !defined(__PIC24FV16KM202__) 
....................         #define __PIC24FV16KM202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KM202.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV16KM202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KM204__) || (getenv("DEVICE")=="PIC24FV16KM204") 
....................     #if !defined(__PIC24FV16KM204__) 
....................         #define __PIC24FV16KM204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KM204.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV16KM204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV32KA301__) || (getenv("DEVICE")=="PIC24FV32KA301") 
....................     #if !defined(__PIC24FV32KA301__) 
....................         #define __PIC24FV32KA301__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV32KA301.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV32KA301_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV32KA302__) || (getenv("DEVICE")=="PIC24FV32KA302") 
....................     #if !defined(__PIC24FV32KA302__) 
....................         #define __PIC24FV32KA302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV32KA302.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV32KA302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV32KA304__) || (getenv("DEVICE")=="PIC24FV32KA304") 
....................     #if !defined(__PIC24FV32KA304__) 
....................         #define __PIC24FV32KA304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV32KA304.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV32KA304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP202__) || (getenv("DEVICE")=="PIC24HJ128GP202") 
....................     #if !defined(__PIC24HJ128GP202__) 
....................         #define __PIC24HJ128GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP204__) || (getenv("DEVICE")=="PIC24HJ128GP204") 
....................     #if !defined(__PIC24HJ128GP204__) 
....................         #define __PIC24HJ128GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP206__) || (getenv("DEVICE")=="PIC24HJ128GP206") 
....................     #if !defined(__PIC24HJ128GP206__) 
....................         #define __PIC24HJ128GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP206A__) || (getenv("DEVICE")=="PIC24HJ128GP206A") 
....................     #if !defined(__PIC24HJ128GP206A__) 
....................         #define __PIC24HJ128GP206A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP206A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP206A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP210__) || (getenv("DEVICE")=="PIC24HJ128GP210") 
....................     #if !defined(__PIC24HJ128GP210__) 
....................         #define __PIC24HJ128GP210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP210.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP210A__) || (getenv("DEVICE")=="PIC24HJ128GP210A") 
....................     #if !defined(__PIC24HJ128GP210A__) 
....................         #define __PIC24HJ128GP210A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP210A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP210A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP306__) || (getenv("DEVICE")=="PIC24HJ128GP306") 
....................     #if !defined(__PIC24HJ128GP306__) 
....................         #define __PIC24HJ128GP306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP306.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP306A__) || (getenv("DEVICE")=="PIC24HJ128GP306A") 
....................     #if !defined(__PIC24HJ128GP306A__) 
....................         #define __PIC24HJ128GP306A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP306A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP306A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP310__) || (getenv("DEVICE")=="PIC24HJ128GP310") 
....................     #if !defined(__PIC24HJ128GP310__) 
....................         #define __PIC24HJ128GP310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP310.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP310A__) || (getenv("DEVICE")=="PIC24HJ128GP310A") 
....................     #if !defined(__PIC24HJ128GP310A__) 
....................         #define __PIC24HJ128GP310A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP310A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP310A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP502__) || (getenv("DEVICE")=="PIC24HJ128GP502") 
....................     #if !defined(__PIC24HJ128GP502__) 
....................         #define __PIC24HJ128GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP502.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP504__) || (getenv("DEVICE")=="PIC24HJ128GP504") 
....................     #if !defined(__PIC24HJ128GP504__) 
....................         #define __PIC24HJ128GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP504.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP506__) || (getenv("DEVICE")=="PIC24HJ128GP506") 
....................     #if !defined(__PIC24HJ128GP506__) 
....................         #define __PIC24HJ128GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP506.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP506A__) || (getenv("DEVICE")=="PIC24HJ128GP506A") 
....................     #if !defined(__PIC24HJ128GP506A__) 
....................         #define __PIC24HJ128GP506A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP506A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP506A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP510__) || (getenv("DEVICE")=="PIC24HJ128GP510") 
....................     #if !defined(__PIC24HJ128GP510__) 
....................         #define __PIC24HJ128GP510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP510.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP510A__) || (getenv("DEVICE")=="PIC24HJ128GP510A") 
....................     #if !defined(__PIC24HJ128GP510A__) 
....................         #define __PIC24HJ128GP510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP510A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ12GP201__) || (getenv("DEVICE")=="PIC24HJ12GP201") 
....................     #if !defined(__PIC24HJ12GP201__) 
....................         #define __PIC24HJ12GP201__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ12GP201.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ12GP201_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ12GP202__) || (getenv("DEVICE")=="PIC24HJ12GP202") 
....................     #if !defined(__PIC24HJ12GP202__) 
....................         #define __PIC24HJ12GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ12GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ12GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ16GP304__) || (getenv("DEVICE")=="PIC24HJ16GP304") 
....................     #if !defined(__PIC24HJ16GP304__) 
....................         #define __PIC24HJ16GP304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ16GP304.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ16GP304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP206__) || (getenv("DEVICE")=="PIC24HJ256GP206") 
....................     #if !defined(__PIC24HJ256GP206__) 
....................         #define __PIC24HJ256GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP206A__) || (getenv("DEVICE")=="PIC24HJ256GP206A") 
....................     #if !defined(__PIC24HJ256GP206A__) 
....................         #define __PIC24HJ256GP206A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP206A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP206A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP210__) || (getenv("DEVICE")=="PIC24HJ256GP210") 
....................     #if !defined(__PIC24HJ256GP210__) 
....................         #define __PIC24HJ256GP210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP210.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP210A__) || (getenv("DEVICE")=="PIC24HJ256GP210A") 
....................     #if !defined(__PIC24HJ256GP210A__) 
....................         #define __PIC24HJ256GP210A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP210A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP210A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP610__) || (getenv("DEVICE")=="PIC24HJ256GP610") 
....................     #if !defined(__PIC24HJ256GP610__) 
....................         #define __PIC24HJ256GP610__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP610.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP610_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP610A__) || (getenv("DEVICE")=="PIC24HJ256GP610A") 
....................     #if !defined(__PIC24HJ256GP610A__) 
....................         #define __PIC24HJ256GP610A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP610A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP610A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ32GP202__) || (getenv("DEVICE")=="PIC24HJ32GP202") 
....................     #if !defined(__PIC24HJ32GP202__) 
....................         #define __PIC24HJ32GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ32GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ32GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ32GP204__) || (getenv("DEVICE")=="PIC24HJ32GP204") 
....................     #if !defined(__PIC24HJ32GP204__) 
....................         #define __PIC24HJ32GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ32GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ32GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ32GP302__) || (getenv("DEVICE")=="PIC24HJ32GP302") 
....................     #if !defined(__PIC24HJ32GP302__) 
....................         #define __PIC24HJ32GP302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ32GP302.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ32GP302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ32GP304__) || (getenv("DEVICE")=="PIC24HJ32GP304") 
....................     #if !defined(__PIC24HJ32GP304__) 
....................         #define __PIC24HJ32GP304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ32GP304.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ32GP304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP202__) || (getenv("DEVICE")=="PIC24HJ64GP202") 
....................     #if !defined(__PIC24HJ64GP202__) 
....................         #define __PIC24HJ64GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP204__) || (getenv("DEVICE")=="PIC24HJ64GP204") 
....................     #if !defined(__PIC24HJ64GP204__) 
....................         #define __PIC24HJ64GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP206__) || (getenv("DEVICE")=="PIC24HJ64GP206") 
....................     #if !defined(__PIC24HJ64GP206__) 
....................         #define __PIC24HJ64GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP206A__) || (getenv("DEVICE")=="PIC24HJ64GP206A") 
....................     #if !defined(__PIC24HJ64GP206A__) 
....................         #define __PIC24HJ64GP206A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP206A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP206A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP210__) || (getenv("DEVICE")=="PIC24HJ64GP210") 
....................     #if !defined(__PIC24HJ64GP210__) 
....................         #define __PIC24HJ64GP210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP210.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP210A__) || (getenv("DEVICE")=="PIC24HJ64GP210A") 
....................     #if !defined(__PIC24HJ64GP210A__) 
....................         #define __PIC24HJ64GP210A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP210A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP210A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP502__) || (getenv("DEVICE")=="PIC24HJ64GP502") 
....................     #if !defined(__PIC24HJ64GP502__) 
....................         #define __PIC24HJ64GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP502.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP504__) || (getenv("DEVICE")=="PIC24HJ64GP504") 
....................     #if !defined(__PIC24HJ64GP504__) 
....................         #define __PIC24HJ64GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP504.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP506__) || (getenv("DEVICE")=="PIC24HJ64GP506") 
....................     #if !defined(__PIC24HJ64GP506__) 
....................         #define __PIC24HJ64GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP506.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP506A__) || (getenv("DEVICE")=="PIC24HJ64GP506A") 
....................     #if !defined(__PIC24HJ64GP506A__) 
....................         #define __PIC24HJ64GP506A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP506A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP506A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP510__) || (getenv("DEVICE")=="PIC24HJ64GP510") 
....................     #if !defined(__PIC24HJ64GP510__) 
....................         #define __PIC24HJ64GP510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP510.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP510A__) || (getenv("DEVICE")=="PIC24HJ64GP510A") 
....................     #if !defined(__PIC24HJ64GP510A__) 
....................         #define __PIC24HJ64GP510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP510A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F1010__) || (getenv("DEVICE")=="DSPIC30F1010") 
....................     #if !defined(__dsPIC30F1010__) 
....................         #define __dsPIC30F1010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F1010.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F1010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F2010__) || (getenv("DEVICE")=="DSPIC30F2010") 
....................     #if !defined(__dsPIC30F2010__) 
....................         #define __dsPIC30F2010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F2010.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F2010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F2011__) || (getenv("DEVICE")=="DSPIC30F2011") 
....................     #if !defined(__dsPIC30F2011__) 
....................         #define __dsPIC30F2011__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F2011.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F2011_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F2012__) || (getenv("DEVICE")=="DSPIC30F2012") 
....................     #if !defined(__dsPIC30F2012__) 
....................         #define __dsPIC30F2012__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F2012.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F2012_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F2020__) || (getenv("DEVICE")=="DSPIC30F2020") 
....................     #if !defined(__dsPIC30F2020__) 
....................         #define __dsPIC30F2020__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F2020.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F2020_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F2023__) || (getenv("DEVICE")=="DSPIC30F2023") 
....................     #if !defined(__dsPIC30F2023__) 
....................         #define __dsPIC30F2023__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F2023.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F2023_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F3010__) || (getenv("DEVICE")=="DSPIC30F3010") 
....................     #if !defined(__dsPIC30F3010__) 
....................         #define __dsPIC30F3010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F3010.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F3010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F3011__) || (getenv("DEVICE")=="DSPIC30F3011") 
....................     #if !defined(__dsPIC30F3011__) 
....................         #define __dsPIC30F3011__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F3011.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F3011_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F3012__) || (getenv("DEVICE")=="DSPIC30F3012") 
....................     #if !defined(__dsPIC30F3012__) 
....................         #define __dsPIC30F3012__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F3012.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F3012_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F3013__) || (getenv("DEVICE")=="DSPIC30F3013") 
....................     #if !defined(__dsPIC30F3013__) 
....................         #define __dsPIC30F3013__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F3013.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F3013_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F3014__) || (getenv("DEVICE")=="DSPIC30F3014") 
....................     #if !defined(__dsPIC30F3014__) 
....................         #define __dsPIC30F3014__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F3014.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F3014_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F4011__) || (getenv("DEVICE")=="DSPIC30F4011") 
....................     #if !defined(__dsPIC30F4011__) 
....................         #define __dsPIC30F4011__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F4011.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F4011_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F4012__) || (getenv("DEVICE")=="DSPIC30F4012") 
....................     #if !defined(__dsPIC30F4012__) 
....................         #define __dsPIC30F4012__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F4012.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F4012_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F4013__) || (getenv("DEVICE")=="DSPIC30F4013") 
....................     #if !defined(__dsPIC30F4013__) 
....................         #define __dsPIC30F4013__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F4013.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F4013_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F5011__) || (getenv("DEVICE")=="DSPIC30F5011") 
....................     #if !defined(__dsPIC30F5011__) 
....................         #define __dsPIC30F5011__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F5011.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F5011_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F5013__) || (getenv("DEVICE")=="DSPIC30F5013") 
....................     #if !defined(__dsPIC30F5013__) 
....................         #define __dsPIC30F5013__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F5013.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F5013_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F5015__) || (getenv("DEVICE")=="DSPIC30F5015") 
....................     #if !defined(__dsPIC30F5015__) 
....................         #define __dsPIC30F5015__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F5015.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F5015_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F5016__) || (getenv("DEVICE")=="DSPIC30F5016") 
....................     #if !defined(__dsPIC30F5016__) 
....................         #define __dsPIC30F5016__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F5016.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F5016_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6010__) || (getenv("DEVICE")=="DSPIC30F6010") 
....................     #if !defined(__dsPIC30F6010__) 
....................         #define __dsPIC30F6010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6010.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6010A__) || (getenv("DEVICE")=="DSPIC30F6010A") 
....................     #if !defined(__dsPIC30F6010A__) 
....................         #define __dsPIC30F6010A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6010A.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6010A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6011__) || (getenv("DEVICE")=="DSPIC30F6011") 
....................     #if !defined(__dsPIC30F6011__) 
....................         #define __dsPIC30F6011__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6011.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6011_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6011A__) || (getenv("DEVICE")=="DSPIC30F6011A") 
....................     #if !defined(__dsPIC30F6011A__) 
....................         #define __dsPIC30F6011A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6011A.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6011A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6012__) || (getenv("DEVICE")=="DSPIC30F6012") 
....................     #if !defined(__dsPIC30F6012__) 
....................         #define __dsPIC30F6012__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6012.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6012_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6012A__) || (getenv("DEVICE")=="DSPIC30F6012A") 
....................     #if !defined(__dsPIC30F6012A__) 
....................         #define __dsPIC30F6012A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6012A.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6012A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6013__) || (getenv("DEVICE")=="DSPIC30F6013") 
....................     #if !defined(__dsPIC30F6013__) 
....................         #define __dsPIC30F6013__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6013.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6013_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6013A__) || (getenv("DEVICE")=="DSPIC30F6013A") 
....................     #if !defined(__dsPIC30F6013A__) 
....................         #define __dsPIC30F6013A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6013A.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6013A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6014__) || (getenv("DEVICE")=="DSPIC30F6014") 
....................     #if !defined(__dsPIC30F6014__) 
....................         #define __dsPIC30F6014__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6014.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6014_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6014A__) || (getenv("DEVICE")=="DSPIC30F6014A") 
....................     #if !defined(__dsPIC30F6014A__) 
....................         #define __dsPIC30F6014A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6014A.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6014A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6015__) || (getenv("DEVICE")=="DSPIC30F6015") 
....................     #if !defined(__dsPIC30F6015__) 
....................         #define __dsPIC30F6015__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6015.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6015_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM304__) || (getenv("DEVICE")=="DSPIC33EP128GM304") 
....................     #if !defined(__dsPIC33EP128GM304__) 
....................         #define __dsPIC33EP128GM304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM306__) || (getenv("DEVICE")=="DSPIC33EP128GM306") 
....................     #if !defined(__dsPIC33EP128GM306__) 
....................         #define __dsPIC33EP128GM306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM306.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM310__) || (getenv("DEVICE")=="DSPIC33EP128GM310") 
....................     #if !defined(__dsPIC33EP128GM310__) 
....................         #define __dsPIC33EP128GM310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM310.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM604__) || (getenv("DEVICE")=="DSPIC33EP128GM604") 
....................     #if !defined(__dsPIC33EP128GM604__) 
....................         #define __dsPIC33EP128GM604__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM604.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM604_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM706__) || (getenv("DEVICE")=="DSPIC33EP128GM706") 
....................     #if !defined(__dsPIC33EP128GM706__) 
....................         #define __dsPIC33EP128GM706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM710__) || (getenv("DEVICE")=="DSPIC33EP128GM710") 
....................     #if !defined(__dsPIC33EP128GM710__) 
....................         #define __dsPIC33EP128GM710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GP502__) || (getenv("DEVICE")=="DSPIC33EP128GP502") 
....................     #if !defined(__dsPIC33EP128GP502__) 
....................         #define __dsPIC33EP128GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GP502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GP504__) || (getenv("DEVICE")=="DSPIC33EP128GP504") 
....................     #if !defined(__dsPIC33EP128GP504__) 
....................         #define __dsPIC33EP128GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GP504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GP506__) || (getenv("DEVICE")=="DSPIC33EP128GP506") 
....................     #if !defined(__dsPIC33EP128GP506__) 
....................         #define __dsPIC33EP128GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GP506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC202__) || (getenv("DEVICE")=="DSPIC33EP128MC202") 
....................     #if !defined(__dsPIC33EP128MC202__) 
....................         #define __dsPIC33EP128MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC204__) || (getenv("DEVICE")=="DSPIC33EP128MC204") 
....................     #if !defined(__dsPIC33EP128MC204__) 
....................         #define __dsPIC33EP128MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC206__) || (getenv("DEVICE")=="DSPIC33EP128MC206") 
....................     #if !defined(__dsPIC33EP128MC206__) 
....................         #define __dsPIC33EP128MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC206.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC502__) || (getenv("DEVICE")=="DSPIC33EP128MC502") 
....................     #if !defined(__dsPIC33EP128MC502__) 
....................         #define __dsPIC33EP128MC502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC504__) || (getenv("DEVICE")=="DSPIC33EP128MC504") 
....................     #if !defined(__dsPIC33EP128MC504__) 
....................         #define __dsPIC33EP128MC504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC506__) || (getenv("DEVICE")=="DSPIC33EP128MC506") 
....................     #if !defined(__dsPIC33EP128MC506__) 
....................         #define __dsPIC33EP128MC506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM304__) || (getenv("DEVICE")=="DSPIC33EP256GM304") 
....................     #if !defined(__dsPIC33EP256GM304__) 
....................         #define __dsPIC33EP256GM304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM306__) || (getenv("DEVICE")=="DSPIC33EP256GM306") 
....................     #if !defined(__dsPIC33EP256GM306__) 
....................         #define __dsPIC33EP256GM306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM306.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM310__) || (getenv("DEVICE")=="DSPIC33EP256GM310") 
....................     #if !defined(__dsPIC33EP256GM310__) 
....................         #define __dsPIC33EP256GM310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM310.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM604__) || (getenv("DEVICE")=="DSPIC33EP256GM604") 
....................     #if !defined(__dsPIC33EP256GM604__) 
....................         #define __dsPIC33EP256GM604__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM604.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM604_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM706__) || (getenv("DEVICE")=="DSPIC33EP256GM706") 
....................     #if !defined(__dsPIC33EP256GM706__) 
....................         #define __dsPIC33EP256GM706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM710__) || (getenv("DEVICE")=="DSPIC33EP256GM710") 
....................     #if !defined(__dsPIC33EP256GM710__) 
....................         #define __dsPIC33EP256GM710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GP502__) || (getenv("DEVICE")=="DSPIC33EP256GP502") 
....................     #if !defined(__dsPIC33EP256GP502__) 
....................         #define __dsPIC33EP256GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GP502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GP504__) || (getenv("DEVICE")=="DSPIC33EP256GP504") 
....................     #if !defined(__dsPIC33EP256GP504__) 
....................         #define __dsPIC33EP256GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GP504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GP506__) || (getenv("DEVICE")=="DSPIC33EP256GP506") 
....................     #if !defined(__dsPIC33EP256GP506__) 
....................         #define __dsPIC33EP256GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GP506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC202__) || (getenv("DEVICE")=="DSPIC33EP256MC202") 
....................     #if !defined(__dsPIC33EP256MC202__) 
....................         #define __dsPIC33EP256MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC204__) || (getenv("DEVICE")=="DSPIC33EP256MC204") 
....................     #if !defined(__dsPIC33EP256MC204__) 
....................         #define __dsPIC33EP256MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC206__) || (getenv("DEVICE")=="DSPIC33EP256MC206") 
....................     #if !defined(__dsPIC33EP256MC206__) 
....................         #define __dsPIC33EP256MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC206.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC502__) || (getenv("DEVICE")=="DSPIC33EP256MC502") 
....................     #if !defined(__dsPIC33EP256MC502__) 
....................         #define __dsPIC33EP256MC502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC504__) || (getenv("DEVICE")=="DSPIC33EP256MC504") 
....................     #if !defined(__dsPIC33EP256MC504__) 
....................         #define __dsPIC33EP256MC504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC506__) || (getenv("DEVICE")=="DSPIC33EP256MC506") 
....................     #if !defined(__dsPIC33EP256MC506__) 
....................         #define __dsPIC33EP256MC506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MU806__) || (getenv("DEVICE")=="DSPIC33EP256MU806") 
....................     #if !defined(__dsPIC33EP256MU806__) 
....................         #define __dsPIC33EP256MU806__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MU806.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MU806_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MU810__) || (getenv("DEVICE")=="DSPIC33EP256MU810") 
....................     #if !defined(__dsPIC33EP256MU810__) 
....................         #define __dsPIC33EP256MU810__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MU810.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MU810_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MU814__) || (getenv("DEVICE")=="DSPIC33EP256MU814") 
....................     #if !defined(__dsPIC33EP256MU814__) 
....................         #define __dsPIC33EP256MU814__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MU814.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MU814_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32GP502__) || (getenv("DEVICE")=="DSPIC33EP32GP502") 
....................     #if !defined(__dsPIC33EP32GP502__) 
....................         #define __dsPIC33EP32GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32GP502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32GP503__) || (getenv("DEVICE")=="DSPIC33EP32GP503") 
....................     #if !defined(__dsPIC33EP32GP503__) 
....................         #define __dsPIC33EP32GP503__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32GP503.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32GP503_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32GP504__) || (getenv("DEVICE")=="DSPIC33EP32GP504") 
....................     #if !defined(__dsPIC33EP32GP504__) 
....................         #define __dsPIC33EP32GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32GP504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC202__) || (getenv("DEVICE")=="DSPIC33EP32MC202") 
....................     #if !defined(__dsPIC33EP32MC202__) 
....................         #define __dsPIC33EP32MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC203__) || (getenv("DEVICE")=="DSPIC33EP32MC203") 
....................     #if !defined(__dsPIC33EP32MC203__) 
....................         #define __dsPIC33EP32MC203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC203.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC204__) || (getenv("DEVICE")=="DSPIC33EP32MC204") 
....................     #if !defined(__dsPIC33EP32MC204__) 
....................         #define __dsPIC33EP32MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC502__) || (getenv("DEVICE")=="DSPIC33EP32MC502") 
....................     #if !defined(__dsPIC33EP32MC502__) 
....................         #define __dsPIC33EP32MC502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC503__) || (getenv("DEVICE")=="DSPIC33EP32MC503") 
....................     #if !defined(__dsPIC33EP32MC503__) 
....................         #define __dsPIC33EP32MC503__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC503.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC503_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC504__) || (getenv("DEVICE")=="DSPIC33EP32MC504") 
....................     #if !defined(__dsPIC33EP32MC504__) 
....................         #define __dsPIC33EP32MC504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM304__) || (getenv("DEVICE")=="DSPIC33EP512GM304") 
....................     #if !defined(__dsPIC33EP512GM304__) 
....................         #define __dsPIC33EP512GM304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM306__) || (getenv("DEVICE")=="DSPIC33EP512GM306") 
....................     #if !defined(__dsPIC33EP512GM306__) 
....................         #define __dsPIC33EP512GM306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM306.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM310__) || (getenv("DEVICE")=="DSPIC33EP512GM310") 
....................     #if !defined(__dsPIC33EP512GM310__) 
....................         #define __dsPIC33EP512GM310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM310.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM604__) || (getenv("DEVICE")=="DSPIC33EP512GM604") 
....................     #if !defined(__dsPIC33EP512GM604__) 
....................         #define __dsPIC33EP512GM604__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM604.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM604_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM706__) || (getenv("DEVICE")=="DSPIC33EP512GM706") 
....................     #if !defined(__dsPIC33EP512GM706__) 
....................         #define __dsPIC33EP512GM706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM710__) || (getenv("DEVICE")=="DSPIC33EP512GM710") 
....................     #if !defined(__dsPIC33EP512GM710__) 
....................         #define __dsPIC33EP512GM710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GP806__) || (getenv("DEVICE")=="DSPIC33EP512GP806") 
....................     #if !defined(__dsPIC33EP512GP806__) 
....................         #define __dsPIC33EP512GP806__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GP806.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GP806_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512MC806__) || (getenv("DEVICE")=="DSPIC33EP512MC806") 
....................     #if !defined(__dsPIC33EP512MC806__) 
....................         #define __dsPIC33EP512MC806__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512MC806.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512MC806_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512MU810__) || (getenv("DEVICE")=="DSPIC33EP512MU810") 
....................     #if !defined(__dsPIC33EP512MU810__) 
....................         #define __dsPIC33EP512MU810__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512MU810.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512MU810_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512MU814__) || (getenv("DEVICE")=="DSPIC33EP512MU814") 
....................     #if !defined(__dsPIC33EP512MU814__) 
....................         #define __dsPIC33EP512MU814__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512MU814.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512MU814_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64GP502__) || (getenv("DEVICE")=="DSPIC33EP64GP502") 
....................     #if !defined(__dsPIC33EP64GP502__) 
....................         #define __dsPIC33EP64GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64GP502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64GP503__) || (getenv("DEVICE")=="DSPIC33EP64GP503") 
....................     #if !defined(__dsPIC33EP64GP503__) 
....................         #define __dsPIC33EP64GP503__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64GP503.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64GP503_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64GP504__) || (getenv("DEVICE")=="DSPIC33EP64GP504") 
....................     #if !defined(__dsPIC33EP64GP504__) 
....................         #define __dsPIC33EP64GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64GP504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64GP506__) || (getenv("DEVICE")=="DSPIC33EP64GP506") 
....................     #if !defined(__dsPIC33EP64GP506__) 
....................         #define __dsPIC33EP64GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64GP506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC202__) || (getenv("DEVICE")=="DSPIC33EP64MC202") 
....................     #if !defined(__dsPIC33EP64MC202__) 
....................         #define __dsPIC33EP64MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC203__) || (getenv("DEVICE")=="DSPIC33EP64MC203") 
....................     #if !defined(__dsPIC33EP64MC203__) 
....................         #define __dsPIC33EP64MC203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC203.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC204__) || (getenv("DEVICE")=="DSPIC33EP64MC204") 
....................     #if !defined(__dsPIC33EP64MC204__) 
....................         #define __dsPIC33EP64MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC206__) || (getenv("DEVICE")=="DSPIC33EP64MC206") 
....................     #if !defined(__dsPIC33EP64MC206__) 
....................         #define __dsPIC33EP64MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC206.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC502__) || (getenv("DEVICE")=="DSPIC33EP64MC502") 
....................     #if !defined(__dsPIC33EP64MC502__) 
....................         #define __dsPIC33EP64MC502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC503__) || (getenv("DEVICE")=="DSPIC33EP64MC503") 
....................     #if !defined(__dsPIC33EP64MC503__) 
....................         #define __dsPIC33EP64MC503__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC503.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC503_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC504__) || (getenv("DEVICE")=="DSPIC33EP64MC504") 
....................     #if !defined(__dsPIC33EP64MC504__) 
....................         #define __dsPIC33EP64MC504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC506__) || (getenv("DEVICE")=="DSPIC33EP64MC506") 
....................     #if !defined(__dsPIC33EP64MC506__) 
....................         #define __dsPIC33EP64MC506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS001__) || (getenv("DEVICE")=="DSPIC33FJ06GS001") 
....................     #if !defined(__dsPIC33FJ06GS001__) 
....................         #define __dsPIC33FJ06GS001__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS001.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS001_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS101__) || (getenv("DEVICE")=="DSPIC33FJ06GS101") 
....................     #if !defined(__dsPIC33FJ06GS101__) 
....................         #define __dsPIC33FJ06GS101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS101.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS101A__) || (getenv("DEVICE")=="DSPIC33FJ06GS101A") 
....................     #if !defined(__dsPIC33FJ06GS101A__) 
....................         #define __dsPIC33FJ06GS101A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS101A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS101A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS102__) || (getenv("DEVICE")=="DSPIC33FJ06GS102") 
....................     #if !defined(__dsPIC33FJ06GS102__) 
....................         #define __dsPIC33FJ06GS102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS102.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS102A__) || (getenv("DEVICE")=="DSPIC33FJ06GS102A") 
....................     #if !defined(__dsPIC33FJ06GS102A__) 
....................         #define __dsPIC33FJ06GS102A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS102A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS102A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS202__) || (getenv("DEVICE")=="DSPIC33FJ06GS202") 
....................     #if !defined(__dsPIC33FJ06GS202__) 
....................         #define __dsPIC33FJ06GS202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS202A__) || (getenv("DEVICE")=="DSPIC33FJ06GS202A") 
....................     #if !defined(__dsPIC33FJ06GS202A__) 
....................         #define __dsPIC33FJ06GS202A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS202A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS202A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ09GS302__) || (getenv("DEVICE")=="DSPIC33FJ09GS302") 
....................     #if !defined(__dsPIC33FJ09GS302__) 
....................         #define __dsPIC33FJ09GS302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ09GS302.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ09GS302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP202__) || (getenv("DEVICE")=="DSPIC33FJ128GP202") 
....................     #if !defined(__dsPIC33FJ128GP202__) 
....................         #define __dsPIC33FJ128GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP204__) || (getenv("DEVICE")=="DSPIC33FJ128GP204") 
....................     #if !defined(__dsPIC33FJ128GP204__) 
....................         #define __dsPIC33FJ128GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP206__) || (getenv("DEVICE")=="DSPIC33FJ128GP206") 
....................     #if !defined(__dsPIC33FJ128GP206__) 
....................         #define __dsPIC33FJ128GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP206.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP206A__) || (getenv("DEVICE")=="DSPIC33FJ128GP206A") 
....................     #if !defined(__dsPIC33FJ128GP206A__) 
....................         #define __dsPIC33FJ128GP206A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP206A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP206A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP306__) || (getenv("DEVICE")=="DSPIC33FJ128GP306") 
....................     #if !defined(__dsPIC33FJ128GP306__) 
....................         #define __dsPIC33FJ128GP306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP306.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP306A__) || (getenv("DEVICE")=="DSPIC33FJ128GP306A") 
....................     #if !defined(__dsPIC33FJ128GP306A__) 
....................         #define __dsPIC33FJ128GP306A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP306A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP306A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP310__) || (getenv("DEVICE")=="DSPIC33FJ128GP310") 
....................     #if !defined(__dsPIC33FJ128GP310__) 
....................         #define __dsPIC33FJ128GP310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP310.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP310A__) || (getenv("DEVICE")=="DSPIC33FJ128GP310A") 
....................     #if !defined(__dsPIC33FJ128GP310A__) 
....................         #define __dsPIC33FJ128GP310A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP310A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP310A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP706__) || (getenv("DEVICE")=="DSPIC33FJ128GP706") 
....................     #if !defined(__dsPIC33FJ128GP706__) 
....................         #define __dsPIC33FJ128GP706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP706A__) || (getenv("DEVICE")=="DSPIC33FJ128GP706A") 
....................     #if !defined(__dsPIC33FJ128GP706A__) 
....................         #define __dsPIC33FJ128GP706A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP706A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP706A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP708__) || (getenv("DEVICE")=="DSPIC33FJ128GP708") 
....................     #if !defined(__dsPIC33FJ128GP708__) 
....................         #define __dsPIC33FJ128GP708__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP708.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP708_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP708A__) || (getenv("DEVICE")=="DSPIC33FJ128GP708A") 
....................     #if !defined(__dsPIC33FJ128GP708A__) 
....................         #define __dsPIC33FJ128GP708A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP708A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP708A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP710__) || (getenv("DEVICE")=="DSPIC33FJ128GP710") 
....................     #if !defined(__dsPIC33FJ128GP710__) 
....................         #define __dsPIC33FJ128GP710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP710A__) || (getenv("DEVICE")=="DSPIC33FJ128GP710A") 
....................     #if !defined(__dsPIC33FJ128GP710A__) 
....................         #define __dsPIC33FJ128GP710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP802__) || (getenv("DEVICE")=="DSPIC33FJ128GP802") 
....................     #if !defined(__dsPIC33FJ128GP802__) 
....................         #define __dsPIC33FJ128GP802__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP802.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP802_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP804__) || (getenv("DEVICE")=="DSPIC33FJ128GP804") 
....................     #if !defined(__dsPIC33FJ128GP804__) 
....................         #define __dsPIC33FJ128GP804__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP804.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP804_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC202__) || (getenv("DEVICE")=="DSPIC33FJ128MC202") 
....................     #if !defined(__dsPIC33FJ128MC202__) 
....................         #define __dsPIC33FJ128MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC204__) || (getenv("DEVICE")=="DSPIC33FJ128MC204") 
....................     #if !defined(__dsPIC33FJ128MC204__) 
....................         #define __dsPIC33FJ128MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC506__) || (getenv("DEVICE")=="DSPIC33FJ128MC506") 
....................     #if !defined(__dsPIC33FJ128MC506__) 
....................         #define __dsPIC33FJ128MC506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC506A__) || (getenv("DEVICE")=="DSPIC33FJ128MC506A") 
....................     #if !defined(__dsPIC33FJ128MC506A__) 
....................         #define __dsPIC33FJ128MC506A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC506A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC506A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC510__) || (getenv("DEVICE")=="DSPIC33FJ128MC510") 
....................     #if !defined(__dsPIC33FJ128MC510__) 
....................         #define __dsPIC33FJ128MC510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC510.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC510A__) || (getenv("DEVICE")=="DSPIC33FJ128MC510A") 
....................     #if !defined(__dsPIC33FJ128MC510A__) 
....................         #define __dsPIC33FJ128MC510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC510A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC706__) || (getenv("DEVICE")=="DSPIC33FJ128MC706") 
....................     #if !defined(__dsPIC33FJ128MC706__) 
....................         #define __dsPIC33FJ128MC706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC706A__) || (getenv("DEVICE")=="DSPIC33FJ128MC706A") 
....................     #if !defined(__dsPIC33FJ128MC706A__) 
....................         #define __dsPIC33FJ128MC706A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC706A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC706A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC708__) || (getenv("DEVICE")=="DSPIC33FJ128MC708") 
....................     #if !defined(__dsPIC33FJ128MC708__) 
....................         #define __dsPIC33FJ128MC708__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC708.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC708_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC708A__) || (getenv("DEVICE")=="DSPIC33FJ128MC708A") 
....................     #if !defined(__dsPIC33FJ128MC708A__) 
....................         #define __dsPIC33FJ128MC708A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC708A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC708A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC710__) || (getenv("DEVICE")=="DSPIC33FJ128MC710") 
....................     #if !defined(__dsPIC33FJ128MC710__) 
....................         #define __dsPIC33FJ128MC710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC710A__) || (getenv("DEVICE")=="DSPIC33FJ128MC710A") 
....................     #if !defined(__dsPIC33FJ128MC710A__) 
....................         #define __dsPIC33FJ128MC710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC802__) || (getenv("DEVICE")=="DSPIC33FJ128MC802") 
....................     #if !defined(__dsPIC33FJ128MC802__) 
....................         #define __dsPIC33FJ128MC802__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC802.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC802_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC804__) || (getenv("DEVICE")=="DSPIC33FJ128MC804") 
....................     #if !defined(__dsPIC33FJ128MC804__) 
....................         #define __dsPIC33FJ128MC804__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC804.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC804_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ12GP201__) || (getenv("DEVICE")=="DSPIC33FJ12GP201") 
....................     #if !defined(__dsPIC33FJ12GP201__) 
....................         #define __dsPIC33FJ12GP201__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ12GP201.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ12GP201_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ12GP202__) || (getenv("DEVICE")=="DSPIC33FJ12GP202") 
....................     #if !defined(__dsPIC33FJ12GP202__) 
....................         #define __dsPIC33FJ12GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ12GP202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ12GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ12MC201__) || (getenv("DEVICE")=="DSPIC33FJ12MC201") 
....................     #if !defined(__dsPIC33FJ12MC201__) 
....................         #define __dsPIC33FJ12MC201__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ12MC201.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ12MC201_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ12MC202__) || (getenv("DEVICE")=="DSPIC33FJ12MC202") 
....................     #if !defined(__dsPIC33FJ12MC202__) 
....................         #define __dsPIC33FJ12MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ12MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ12MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GP101__) || (getenv("DEVICE")=="DSPIC33FJ16GP101") 
....................     #if !defined(__dsPIC33FJ16GP101__) 
....................         #define __dsPIC33FJ16GP101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GP101.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GP101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GP102__) || (getenv("DEVICE")=="DSPIC33FJ16GP102") 
....................     #if !defined(__dsPIC33FJ16GP102__) 
....................         #define __dsPIC33FJ16GP102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GP102.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GP102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GP304__) || (getenv("DEVICE")=="DSPIC33FJ16GP304") 
....................     #if !defined(__dsPIC33FJ16GP304__) 
....................         #define __dsPIC33FJ16GP304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GP304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GP304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GS402__) || (getenv("DEVICE")=="DSPIC33FJ16GS402") 
....................     #if !defined(__dsPIC33FJ16GS402__) 
....................         #define __dsPIC33FJ16GS402__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GS402.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GS402_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GS404__) || (getenv("DEVICE")=="DSPIC33FJ16GS404") 
....................     #if !defined(__dsPIC33FJ16GS404__) 
....................         #define __dsPIC33FJ16GS404__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GS404.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GS404_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GS502__) || (getenv("DEVICE")=="DSPIC33FJ16GS502") 
....................     #if !defined(__dsPIC33FJ16GS502__) 
....................         #define __dsPIC33FJ16GS502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GS502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GS502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GS504__) || (getenv("DEVICE")=="DSPIC33FJ16GS504") 
....................     #if !defined(__dsPIC33FJ16GS504__) 
....................         #define __dsPIC33FJ16GS504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GS504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GS504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16MC101__) || (getenv("DEVICE")=="DSPIC33FJ16MC101") 
....................     #if !defined(__dsPIC33FJ16MC101__) 
....................         #define __dsPIC33FJ16MC101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16MC101.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16MC101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16MC102__) || (getenv("DEVICE")=="DSPIC33FJ16MC102") 
....................     #if !defined(__dsPIC33FJ16MC102__) 
....................         #define __dsPIC33FJ16MC102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16MC102.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16MC102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16MC304__) || (getenv("DEVICE")=="DSPIC33FJ16MC304") 
....................     #if !defined(__dsPIC33FJ16MC304__) 
....................         #define __dsPIC33FJ16MC304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16MC304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16MC304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP506__) || (getenv("DEVICE")=="DSPIC33FJ256GP506") 
....................     #if !defined(__dsPIC33FJ256GP506__) 
....................         #define __dsPIC33FJ256GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP506A__) || (getenv("DEVICE")=="DSPIC33FJ256GP506A") 
....................     #if !defined(__dsPIC33FJ256GP506A__) 
....................         #define __dsPIC33FJ256GP506A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP506A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP506A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP510__) || (getenv("DEVICE")=="DSPIC33FJ256GP510") 
....................     #if !defined(__dsPIC33FJ256GP510__) 
....................         #define __dsPIC33FJ256GP510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP510.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP510A__) || (getenv("DEVICE")=="DSPIC33FJ256GP510A") 
....................     #if !defined(__dsPIC33FJ256GP510A__) 
....................         #define __dsPIC33FJ256GP510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP510A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP710__) || (getenv("DEVICE")=="DSPIC33FJ256GP710") 
....................     #if !defined(__dsPIC33FJ256GP710__) 
....................         #define __dsPIC33FJ256GP710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP710A__) || (getenv("DEVICE")=="DSPIC33FJ256GP710A") 
....................     #if !defined(__dsPIC33FJ256GP710A__) 
....................         #define __dsPIC33FJ256GP710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256MC510__) || (getenv("DEVICE")=="DSPIC33FJ256MC510") 
....................     #if !defined(__dsPIC33FJ256MC510__) 
....................         #define __dsPIC33FJ256MC510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256MC510.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256MC510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256MC510A__) || (getenv("DEVICE")=="DSPIC33FJ256MC510A") 
....................     #if !defined(__dsPIC33FJ256MC510A__) 
....................         #define __dsPIC33FJ256MC510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256MC510A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256MC510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256MC710__) || (getenv("DEVICE")=="DSPIC33FJ256MC710") 
....................     #if !defined(__dsPIC33FJ256MC710__) 
....................         #define __dsPIC33FJ256MC710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256MC710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256MC710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256MC710A__) || (getenv("DEVICE")=="DSPIC33FJ256MC710A") 
....................     #if !defined(__dsPIC33FJ256MC710A__) 
....................         #define __dsPIC33FJ256MC710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256MC710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256MC710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP101__) || (getenv("DEVICE")=="DSPIC33FJ32GP101") 
....................     #if !defined(__dsPIC33FJ32GP101__) 
....................         #define __dsPIC33FJ32GP101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP101.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP102__) || (getenv("DEVICE")=="DSPIC33FJ32GP102") 
....................     #if !defined(__dsPIC33FJ32GP102__) 
....................         #define __dsPIC33FJ32GP102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP102.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP104__) || (getenv("DEVICE")=="DSPIC33FJ32GP104") 
....................     #if !defined(__dsPIC33FJ32GP104__) 
....................         #define __dsPIC33FJ32GP104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP104.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP202__) || (getenv("DEVICE")=="DSPIC33FJ32GP202") 
....................     #if !defined(__dsPIC33FJ32GP202__) 
....................         #define __dsPIC33FJ32GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP204__) || (getenv("DEVICE")=="DSPIC33FJ32GP204") 
....................     #if !defined(__dsPIC33FJ32GP204__) 
....................         #define __dsPIC33FJ32GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP302__) || (getenv("DEVICE")=="DSPIC33FJ32GP302") 
....................     #if !defined(__dsPIC33FJ32GP302__) 
....................         #define __dsPIC33FJ32GP302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP302.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP304__) || (getenv("DEVICE")=="DSPIC33FJ32GP304") 
....................     #if !defined(__dsPIC33FJ32GP304__) 
....................         #define __dsPIC33FJ32GP304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GS406__) || (getenv("DEVICE")=="DSPIC33FJ32GS406") 
....................     #if !defined(__dsPIC33FJ32GS406__) 
....................         #define __dsPIC33FJ32GS406__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GS406.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GS406_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GS606__) || (getenv("DEVICE")=="DSPIC33FJ32GS606") 
....................     #if !defined(__dsPIC33FJ32GS606__) 
....................         #define __dsPIC33FJ32GS606__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GS606.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GS606_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GS608__) || (getenv("DEVICE")=="DSPIC33FJ32GS608") 
....................     #if !defined(__dsPIC33FJ32GS608__) 
....................         #define __dsPIC33FJ32GS608__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GS608.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GS608_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GS610__) || (getenv("DEVICE")=="DSPIC33FJ32GS610") 
....................     #if !defined(__dsPIC33FJ32GS610__) 
....................         #define __dsPIC33FJ32GS610__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GS610.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GS610_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC101__) || (getenv("DEVICE")=="DSPIC33FJ32MC101") 
....................     #if !defined(__dsPIC33FJ32MC101__) 
....................         #define __dsPIC33FJ32MC101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC101.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC102__) || (getenv("DEVICE")=="DSPIC33FJ32MC102") 
....................     #if !defined(__dsPIC33FJ32MC102__) 
....................         #define __dsPIC33FJ32MC102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC102.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC104__) || (getenv("DEVICE")=="DSPIC33FJ32MC104") 
....................     #if !defined(__dsPIC33FJ32MC104__) 
....................         #define __dsPIC33FJ32MC104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC104.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC202__) || (getenv("DEVICE")=="DSPIC33FJ32MC202") 
....................     #if !defined(__dsPIC33FJ32MC202__) 
....................         #define __dsPIC33FJ32MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC204__) || (getenv("DEVICE")=="DSPIC33FJ32MC204") 
....................     #if !defined(__dsPIC33FJ32MC204__) 
....................         #define __dsPIC33FJ32MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC302__) || (getenv("DEVICE")=="DSPIC33FJ32MC302") 
....................     #if !defined(__dsPIC33FJ32MC302__) 
....................         #define __dsPIC33FJ32MC302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC302.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC304__) || (getenv("DEVICE")=="DSPIC33FJ32MC304") 
....................     #if !defined(__dsPIC33FJ32MC304__) 
....................         #define __dsPIC33FJ32MC304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP202__) || (getenv("DEVICE")=="DSPIC33FJ64GP202") 
....................     #if !defined(__dsPIC33FJ64GP202__) 
....................         #define __dsPIC33FJ64GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP204__) || (getenv("DEVICE")=="DSPIC33FJ64GP204") 
....................     #if !defined(__dsPIC33FJ64GP204__) 
....................         #define __dsPIC33FJ64GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP206__) || (getenv("DEVICE")=="DSPIC33FJ64GP206") 
....................     #if !defined(__dsPIC33FJ64GP206__) 
....................         #define __dsPIC33FJ64GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP206.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP206A__) || (getenv("DEVICE")=="DSPIC33FJ64GP206A") 
....................     #if !defined(__dsPIC33FJ64GP206A__) 
....................         #define __dsPIC33FJ64GP206A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP206A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP206A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP306__) || (getenv("DEVICE")=="DSPIC33FJ64GP306") 
....................     #if !defined(__dsPIC33FJ64GP306__) 
....................         #define __dsPIC33FJ64GP306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP306.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP306A__) || (getenv("DEVICE")=="DSPIC33FJ64GP306A") 
....................     #if !defined(__dsPIC33FJ64GP306A__) 
....................         #define __dsPIC33FJ64GP306A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP306A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP306A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP310__) || (getenv("DEVICE")=="DSPIC33FJ64GP310") 
....................     #if !defined(__dsPIC33FJ64GP310__) 
....................         #define __dsPIC33FJ64GP310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP310.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP310A__) || (getenv("DEVICE")=="DSPIC33FJ64GP310A") 
....................     #if !defined(__dsPIC33FJ64GP310A__) 
....................         #define __dsPIC33FJ64GP310A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP310A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP310A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP706__) || (getenv("DEVICE")=="DSPIC33FJ64GP706") 
....................     #if !defined(__dsPIC33FJ64GP706__) 
....................         #define __dsPIC33FJ64GP706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP706A__) || (getenv("DEVICE")=="DSPIC33FJ64GP706A") 
....................     #if !defined(__dsPIC33FJ64GP706A__) 
....................         #define __dsPIC33FJ64GP706A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP706A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP706A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP708__) || (getenv("DEVICE")=="DSPIC33FJ64GP708") 
....................     #if !defined(__dsPIC33FJ64GP708__) 
....................         #define __dsPIC33FJ64GP708__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP708.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP708_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP708A__) || (getenv("DEVICE")=="DSPIC33FJ64GP708A") 
....................     #if !defined(__dsPIC33FJ64GP708A__) 
....................         #define __dsPIC33FJ64GP708A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP708A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP708A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP710__) || (getenv("DEVICE")=="DSPIC33FJ64GP710") 
....................     #if !defined(__dsPIC33FJ64GP710__) 
....................         #define __dsPIC33FJ64GP710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP710A__) || (getenv("DEVICE")=="DSPIC33FJ64GP710A") 
....................     #if !defined(__dsPIC33FJ64GP710A__) 
....................         #define __dsPIC33FJ64GP710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP802__) || (getenv("DEVICE")=="DSPIC33FJ64GP802") 
....................     #if !defined(__dsPIC33FJ64GP802__) 
....................         #define __dsPIC33FJ64GP802__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP802.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP802_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP804__) || (getenv("DEVICE")=="DSPIC33FJ64GP804") 
....................     #if !defined(__dsPIC33FJ64GP804__) 
....................         #define __dsPIC33FJ64GP804__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP804.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP804_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GS406__) || (getenv("DEVICE")=="DSPIC33FJ64GS406") 
....................     #if !defined(__dsPIC33FJ64GS406__) 
....................         #define __dsPIC33FJ64GS406__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GS406.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GS406_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GS606__) || (getenv("DEVICE")=="DSPIC33FJ64GS606") 
....................     #if !defined(__dsPIC33FJ64GS606__) 
....................         #define __dsPIC33FJ64GS606__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GS606.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GS606_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GS608__) || (getenv("DEVICE")=="DSPIC33FJ64GS608") 
....................     #if !defined(__dsPIC33FJ64GS608__) 
....................         #define __dsPIC33FJ64GS608__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GS608.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GS608_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GS610__) || (getenv("DEVICE")=="DSPIC33FJ64GS610") 
....................     #if !defined(__dsPIC33FJ64GS610__) 
....................         #define __dsPIC33FJ64GS610__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GS610.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GS610_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC202__) || (getenv("DEVICE")=="DSPIC33FJ64MC202") 
....................     #if !defined(__dsPIC33FJ64MC202__) 
....................         #define __dsPIC33FJ64MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC204__) || (getenv("DEVICE")=="DSPIC33FJ64MC204") 
....................     #if !defined(__dsPIC33FJ64MC204__) 
....................         #define __dsPIC33FJ64MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC506__) || (getenv("DEVICE")=="DSPIC33FJ64MC506") 
....................     #if !defined(__dsPIC33FJ64MC506__) 
....................         #define __dsPIC33FJ64MC506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC506A__) || (getenv("DEVICE")=="DSPIC33FJ64MC506A") 
....................     #if !defined(__dsPIC33FJ64MC506A__) 
....................         #define __dsPIC33FJ64MC506A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC506A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC506A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC508__) || (getenv("DEVICE")=="DSPIC33FJ64MC508") 
....................     #if !defined(__dsPIC33FJ64MC508__) 
....................         #define __dsPIC33FJ64MC508__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC508.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC508_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC508A__) || (getenv("DEVICE")=="DSPIC33FJ64MC508A") 
....................     #if !defined(__dsPIC33FJ64MC508A__) 
....................         #define __dsPIC33FJ64MC508A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC508A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC508A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC510__) || (getenv("DEVICE")=="DSPIC33FJ64MC510") 
....................     #if !defined(__dsPIC33FJ64MC510__) 
....................         #define __dsPIC33FJ64MC510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC510.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC510A__) || (getenv("DEVICE")=="DSPIC33FJ64MC510A") 
....................     #if !defined(__dsPIC33FJ64MC510A__) 
....................         #define __dsPIC33FJ64MC510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC510A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC706__) || (getenv("DEVICE")=="DSPIC33FJ64MC706") 
....................     #if !defined(__dsPIC33FJ64MC706__) 
....................         #define __dsPIC33FJ64MC706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC706A__) || (getenv("DEVICE")=="DSPIC33FJ64MC706A") 
....................     #if !defined(__dsPIC33FJ64MC706A__) 
....................         #define __dsPIC33FJ64MC706A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC706A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC706A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC710__) || (getenv("DEVICE")=="DSPIC33FJ64MC710") 
....................     #if !defined(__dsPIC33FJ64MC710__) 
....................         #define __dsPIC33FJ64MC710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC710A__) || (getenv("DEVICE")=="DSPIC33FJ64MC710A") 
....................     #if !defined(__dsPIC33FJ64MC710A__) 
....................         #define __dsPIC33FJ64MC710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC802__) || (getenv("DEVICE")=="DSPIC33FJ64MC802") 
....................     #if !defined(__dsPIC33FJ64MC802__) 
....................         #define __dsPIC33FJ64MC802__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC802.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC802_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC804__) || (getenv("DEVICE")=="DSPIC33FJ64MC804") 
....................     #if !defined(__dsPIC33FJ64MC804__) 
....................         #define __dsPIC33FJ64MC804__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC804.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC804_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC81010__) || (getenv("DEVICE")=="DSPIC81010") 
....................     #if !defined(__dsPIC81010__) 
....................         #define __dsPIC81010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <81010.h> 
....................     #endif 
....................     #if !defined(__dsPIC810100__) 
....................         #define __dsPIC810100__ 
....................     #endif 
....................     #include "81010_registers.h" 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //#device PSV=16 
....................  
.................... #if defined(__CONST_IS_READONLY__) 
....................    #device CONST=READ_ONLY 
.................... #else 
....................    //this is normally how C30 operates 
....................    #device CONST=ROM 
.................... #endif 
....................  
.................... #device PASS_STRINGS=IN_RAM 
....................  
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #zero_ram 
.................... #zero_local_ram 
....................  
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
.................... #undef BYTE 
.................... #endif 
....................  
.................... #if defined(BOOLEAN) 
.................... #undef BOOLEAN 
.................... #endif 
....................  
.................... #define GetSystemClock()       getenv("CLOCK") 
.................... #define GetInstructionClock()  (GetSystemClock()/2) 
.................... #define GetPeripheralClock()   (GetSystemClock()/2) 
....................  
.................... //#define Reset()            reset_cpu()   //not needed, this is defined in Microchip's Compiler.h 
.................... //#define FAR                        //not needed, this is defined in Microchip's Compiler.h 
....................  
.................... #define ClrWdt()         restart_wdt() 
....................  
.................... #define Nop()            delay_cycles(1) 
....................  
.................... //#warning need eds support 
.................... #define __eds__ 
....................  
.................... #define __prog__  rom 
....................  
.................... #define __C30__ 
....................  
.................... #define __CCS_STDLIB_DYNAMIC_MEMORY__ 
....................  
.................... #endif 
....................  
.................... #else 
....................    #error PIC18 or dsPIC/PIC24 support ONLY 
.................... #endif 
....................  
.................... #include "HardwareProfile.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        HardwareProfile.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _MDD_HARDWAREPROFILE_H_ 
.................... #define _MDD_HARDWAREPROFILE_H_ 
....................  
.................... /*********************************************************************/ 
.................... /******************* Pin and Register Definitions ********************/ 
.................... /*********************************************************************/ 
....................  
.................... /* SD Card definitions: Change these to fit your application when using 
....................    an SD-card-based physical layer                                   */ 
.................... /* 
.................... #if (defined(HW_CCS_3V_ETHERNET)||defined(HW_CCS_46K20)) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)) 
.................... //CCS 18F67J60 3.3V Ethernet development kit with SD card 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................          
....................         // Chip Select Signal 
....................         #define SD_CS               PORTCbits.RC2 
....................         #define SD_CS_TRIS          TRISCbits.TRISC2 
....................          
....................         // Card detect signal 
....................         #define SD_CD               PORTEbits.RE5 
....................         #define SD_CD_TRIS          TRISEbits.TRISE5 
....................          
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................          
....................         // Defines for the HPC Explorer board 
....................         #define SPICLOCK            TRISCbits.TRISC3 
....................         #define SPIIN               TRISCbits.TRISC4 
....................         #define SPIOUT              TRISCbits.TRISC5 
....................      
....................         // Latch pins for SCK/SDI/SDO lines 
....................         #define SPICLOCKLAT         LATCbits.LATC3 
....................         #define SPIINLAT            LATCbits.LATC4 
....................         #define SPIOUTLAT           LATCbits.LATC5 
....................      
....................         // Port pins for SCK/SDI/SDO lines 
....................         #define SPICLOCKPORT        PORTCbits.RC3 
....................         #define SPIINPORT           PORTCbits.RC4 
....................         #define SPIOUTPORT          PORTCbits.RC5 
....................  
....................         // Registers for the SPI module you want to use 
....................         #define SPICON1             SSP1CON1 
....................         #define SPISTAT             SSP1STAT 
....................         #define SPIBUF              SSP1BUF 
....................         #define SPICON1bits         SSP1CON1bits 
....................         #define SPISTATbits         SSP1STATbits 
....................          
....................         #define PIR1_LOC   getenv("SFR:PIR1") 
....................         //#define SPI_INTERRUPT_FLAG_ASM PIR1_LOC,3 
....................         #define SPI_INTERRUPT_FLAG_ASM PIR1,3 
....................  
....................        //set SPI_INTERRUPT_FLAG to SPI1 interrupt flag. 
....................        //some PICs this bit is defined as SSP1IF and some PICs this is defined 
....................        //as SSPIF. 
....................         #if getenv("BIT_VALID:SSP1IF") 
....................          #bit SPI_INTERRUPT_FLAG=getenv("BIT:SSP1IF") 
....................         #else 
....................          #bit SPI_INTERRUPT_FLAG=getenv("BIT:SSPIF") 
....................         #endif 
....................      
....................         #define SPIENABLE           SPICON1bits.SSPEN 
.................... #endif   //HW_CCS_3V_ETHERNET 
....................  
.................... // ccs dsp analog board with (33hj) sd connector 
.................... #if defined(HW_CCS_DSP_AUDIO) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATDbits.LATD8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISDbits.TRISD8 
....................                  
....................          //NO SD_CD or SD_CD_TRIS 
....................          #define MEDIA_SOFT_DETECT 
....................  
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI2CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI2STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI2BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI2STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI2STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI2CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI2STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISFbits.TRISF4 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISFbits.TRISF5 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISBbits.TRISB15 
.................... #endif 
....................  
.................... // ccs dsp analog board (33ep) with sd connector 
.................... #if defined(HW_CCS_DSP_AUDIO2) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATDbits.LATD8 //PIN_D8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISDbits.TRISD8 
....................         #define SD_CS_ANSEL         ANSELEbits.ANSE8 
....................          
....................          //NO SD_CD or SD_CD_TRIS   //PIN_E1 
....................          #define SD_CD              PORTEbits.RE1 
....................          #define SD_CD_TRIS              TRISEbits.TRISE1 
....................  
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................  
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI1CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI1STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI1BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI1STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI1STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI1CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI1STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISGbits.TRISG6 
....................         #define SD_SCK_ANSEL        ANSELGbits.ANSG6 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISGbits.TRISG7 
....................         #define SD_SDI_ANSEL        ANSELGbits.ANSG7 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISGbits.TRISG8 
....................         #define SD_SDO_ANSEL        ANSELGbits.ANSG8 
.................... #endif 
....................  
.................... #if defined(HW_CCS_DSP_AUDIO) && defined(USE_SST25_INTERFACE) 
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................          
....................         //chip select pin of SST25 
....................         #define FLASH_SELECT_PIN PIN_F1 
....................          
....................         //configure sst25 library spi stream 
....................         #use spi(SPI2, MODE=0, BITS=8, baud=1000000, STREAM=SPI_SST25, FORCE_HW) 
....................         #define FLASH_STREAM SPI_SST25 
.................... #endif 
....................  
.................... */ 
.................... #if defined(HW_CCS_PIC24USB) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
.................... // ccs dsp analog board with sd connector 
....................  
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATGbits.LATG8      //pin_G8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISGbits.TRISG8 
....................  
.................... //This is the old setup  December 30, 2014 
....................         // Description: SD-SPI Chip Select Output bit 
....................         //#define SD_CS            LATBbits.LATB14      //pin_b14 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         //#define SD_CS_TRIS          TRISBbits.TRISB14 
....................  
....................         #define SD_CD            PORTBbits.RB12      //pin_b12 
....................         #define SD_CD_TRIS          TRISBbits.TRISB12 
....................  
....................          //NO SD_WE_TRIS         
....................          int1 SD_WE_TRIS; 
....................          int1 SD_WE=0; 
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI1CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI1STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI1BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI1STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI1STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI1CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI1STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The main SPI control register 
....................         //#define SPICON1             SPI2CON1 
....................         // Description: The SPI status register 
....................         //#define SPISTAT             SPI2STAT 
....................         // Description: The SPI Buffer 
....................         //#define SPIBUF              SPI2BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         //#define SPISTAT_RBF         SPI2STATbits.SPIRBF 
....................         //#define SPISTAT_TBF         SPI2STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         //#define SPICON1bits         SPI2CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         //#define SPISTATbits         SPI2STATbits 
....................         // Description: The enable bit for the SPI module 
....................         //#define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................  
....................        // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISFbits.TRISF3 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISFbits.TRISF6 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISFbits.TRISF2 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         //#define SPICLOCK            TRISGbits.TRISG6 
....................         // Description: The TRIS bit for the SDI pin 
....................         //#define SPIIN               TRISGbits.TRISG7 
....................         // Description: The TRIS bit for the SDO pin 
....................         //#define SPIOUT              TRISGbits.TRISG8 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #include "FSConfig.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSconfig.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Dependencies:    None 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _FS_DEF_ 
.................... #define _FS_DEF_ 
....................  
.................... //#include "Compiler.h" 
.................... #include "HardwareProfile.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        HardwareProfile.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _MDD_HARDWAREPROFILE_H_ 
.................... #define _MDD_HARDWAREPROFILE_H_ 
....................  
.................... /*********************************************************************/ 
.................... /******************* Pin and Register Definitions ********************/ 
.................... /*********************************************************************/ 
....................  
.................... /* SD Card definitions: Change these to fit your application when using 
....................    an SD-card-based physical layer                                   */ 
.................... /* 
.................... #if (defined(HW_CCS_3V_ETHERNET)||defined(HW_CCS_46K20)) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)) 
.................... //CCS 18F67J60 3.3V Ethernet development kit with SD card 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................          
....................         // Chip Select Signal 
....................         #define SD_CS               PORTCbits.RC2 
....................         #define SD_CS_TRIS          TRISCbits.TRISC2 
....................          
....................         // Card detect signal 
....................         #define SD_CD               PORTEbits.RE5 
....................         #define SD_CD_TRIS          TRISEbits.TRISE5 
....................          
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................          
....................         // Defines for the HPC Explorer board 
....................         #define SPICLOCK            TRISCbits.TRISC3 
....................         #define SPIIN               TRISCbits.TRISC4 
....................         #define SPIOUT              TRISCbits.TRISC5 
....................      
....................         // Latch pins for SCK/SDI/SDO lines 
....................         #define SPICLOCKLAT         LATCbits.LATC3 
....................         #define SPIINLAT            LATCbits.LATC4 
....................         #define SPIOUTLAT           LATCbits.LATC5 
....................      
....................         // Port pins for SCK/SDI/SDO lines 
....................         #define SPICLOCKPORT        PORTCbits.RC3 
....................         #define SPIINPORT           PORTCbits.RC4 
....................         #define SPIOUTPORT          PORTCbits.RC5 
....................  
....................         // Registers for the SPI module you want to use 
....................         #define SPICON1             SSP1CON1 
....................         #define SPISTAT             SSP1STAT 
....................         #define SPIBUF              SSP1BUF 
....................         #define SPICON1bits         SSP1CON1bits 
....................         #define SPISTATbits         SSP1STATbits 
....................          
....................         #define PIR1_LOC   getenv("SFR:PIR1") 
....................         //#define SPI_INTERRUPT_FLAG_ASM PIR1_LOC,3 
....................         #define SPI_INTERRUPT_FLAG_ASM PIR1,3 
....................  
....................        //set SPI_INTERRUPT_FLAG to SPI1 interrupt flag. 
....................        //some PICs this bit is defined as SSP1IF and some PICs this is defined 
....................        //as SSPIF. 
....................         #if getenv("BIT_VALID:SSP1IF") 
....................          #bit SPI_INTERRUPT_FLAG=getenv("BIT:SSP1IF") 
....................         #else 
....................          #bit SPI_INTERRUPT_FLAG=getenv("BIT:SSPIF") 
....................         #endif 
....................      
....................         #define SPIENABLE           SPICON1bits.SSPEN 
.................... #endif   //HW_CCS_3V_ETHERNET 
....................  
.................... // ccs dsp analog board with (33hj) sd connector 
.................... #if defined(HW_CCS_DSP_AUDIO) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATDbits.LATD8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISDbits.TRISD8 
....................                  
....................          //NO SD_CD or SD_CD_TRIS 
....................          #define MEDIA_SOFT_DETECT 
....................  
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI2CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI2STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI2BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI2STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI2STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI2CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI2STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISFbits.TRISF4 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISFbits.TRISF5 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISBbits.TRISB15 
.................... #endif 
....................  
.................... // ccs dsp analog board (33ep) with sd connector 
.................... #if defined(HW_CCS_DSP_AUDIO2) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATDbits.LATD8 //PIN_D8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISDbits.TRISD8 
....................         #define SD_CS_ANSEL         ANSELEbits.ANSE8 
....................          
....................          //NO SD_CD or SD_CD_TRIS   //PIN_E1 
....................          #define SD_CD              PORTEbits.RE1 
....................          #define SD_CD_TRIS              TRISEbits.TRISE1 
....................  
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................  
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI1CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI1STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI1BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI1STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI1STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI1CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI1STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISGbits.TRISG6 
....................         #define SD_SCK_ANSEL        ANSELGbits.ANSG6 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISGbits.TRISG7 
....................         #define SD_SDI_ANSEL        ANSELGbits.ANSG7 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISGbits.TRISG8 
....................         #define SD_SDO_ANSEL        ANSELGbits.ANSG8 
.................... #endif 
....................  
.................... #if defined(HW_CCS_DSP_AUDIO) && defined(USE_SST25_INTERFACE) 
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................          
....................         //chip select pin of SST25 
....................         #define FLASH_SELECT_PIN PIN_F1 
....................          
....................         //configure sst25 library spi stream 
....................         #use spi(SPI2, MODE=0, BITS=8, baud=1000000, STREAM=SPI_SST25, FORCE_HW) 
....................         #define FLASH_STREAM SPI_SST25 
.................... #endif 
....................  
.................... */ 
.................... #if defined(HW_CCS_PIC24USB) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
.................... // ccs dsp analog board with sd connector 
....................  
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATGbits.LATG8      //pin_G8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISGbits.TRISG8 
....................  
.................... //This is the old setup  December 30, 2014 
....................         // Description: SD-SPI Chip Select Output bit 
....................         //#define SD_CS            LATBbits.LATB14      //pin_b14 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         //#define SD_CS_TRIS          TRISBbits.TRISB14 
....................  
....................         #define SD_CD            PORTBbits.RB12      //pin_b12 
....................         #define SD_CD_TRIS          TRISBbits.TRISB12 
....................  
....................          //NO SD_WE_TRIS         
....................          int1 SD_WE_TRIS; 
....................          int1 SD_WE=0; 
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI1CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI1STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI1BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI1STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI1STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI1CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI1STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The main SPI control register 
....................         //#define SPICON1             SPI2CON1 
....................         // Description: The SPI status register 
....................         //#define SPISTAT             SPI2STAT 
....................         // Description: The SPI Buffer 
....................         //#define SPIBUF              SPI2BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         //#define SPISTAT_RBF         SPI2STATbits.SPIRBF 
....................         //#define SPISTAT_TBF         SPI2STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         //#define SPICON1bits         SPI2CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         //#define SPISTATbits         SPI2STATbits 
....................         // Description: The enable bit for the SPI module 
....................         //#define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................  
....................        // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISFbits.TRISF3 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISFbits.TRISF6 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISFbits.TRISF2 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         //#define SPICLOCK            TRISGbits.TRISG6 
....................         // Description: The TRIS bit for the SDI pin 
....................         //#define SPIIN               TRISGbits.TRISG7 
....................         // Description: The TRIS bit for the SDO pin 
....................         //#define SPIOUT              TRISGbits.TRISG8 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // something to do with long filenames. 
.................... //#define SUPPORT_LFN 
....................  
.................... // Summary: A macro indicating the maximum number of concurrently open files 
.................... // Description: The FS_MAX_FILES_OPEN #define is only applicable when dynamic memory allocation is not used (FS_DYNAMIC_MEM is not defined). 
.................... //              This macro defines the maximum number of open files at any given time.  The amount of RAM used by FSFILE objects will 
.................... //              be equal to the size of an FSFILE object multipled by this macro value.  This value should be kept as small as possible 
.................... //              as dictated by the application.  This will reduce memory usage. 
.................... #define FS_MAX_FILES_OPEN    1 
....................  
....................  
.................... // if defined, MDD will be configured to use SST25 flash device. this definition 
.................... // should also define the size of the SST25 flash device. 
.................... // if not defined, will use SD card. 
.................... // #define  USE_SST25_INTERFACE  ((unsigned int32)2*1024*1024) 
....................  
.................... // Summary: A macro defining the size of a sector 
.................... // Description: The MEDIA_SECTOR_SIZE macro will define the size of a sector on the FAT file system.  This value must equal 512 bytes, 
.................... //              1024 bytes, 2048 bytes, or 4096 bytes.  The value of a sector will usually be 512 bytes. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define MEDIA_SECTOR_SIZE       4096   //erase size of SST25 flash device 
.................... #else 
.................... #define MEDIA_SECTOR_SIZE       512 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* *******************************************************************************************************/ 
.................... /************** Compiler options to enable/Disable Features based on user's application ******************/ 
.................... /* *******************************************************************************************************/ 
....................  
....................  
.................... // Summary: A macro to enable/disable file search functions. 
.................... // Description: The ALLOW_FILESEARCH definition can be commented out to disable file search functions in the library.  This will 
.................... //              prevent the use of the FindFirst and FindNext functions and reduce code size. 
.................... #define ALLOW_FILESEARCH 
....................  
.................... // Summary: A macro to enable/disable write functionality 
.................... // Description: The ALLOW_WRITES definition can be commented out to disable all operations that write to the device.  This will 
.................... //              greatly reduce code size. 
.................... #define ALLOW_WRITES 
....................  
....................  
.................... // Summary: A macro to enable/disable format functionality 
.................... // Description: The ALLOW_FORMATS definition can be commented out to disable formatting functionality.  This will prevent the use of 
.................... //              the FSformat function.  If formats are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define ALLOW_FORMATS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable directory operations. 
.................... // Description: The ALLOW_DIRS definition can be commented out to disable all directory functionality.  This will reduce code size. 
.................... //              If directories are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES in order to use 
.................... //              the FSmkdir or FSrmdir functions. 
.................... #define ALLOW_DIRS 
....................  
.................... // Summary: A macro to enable/disable PIC18 ROM functions. 
.................... // Description: The ALLOW_PGMFUNCTIONS definition can be commented out to disable all PIC18 functions that allow the user to pass string 
.................... //              arguments in ROM (denoted by the suffix -pgm).  Note that this functionality must be disabled when not using PIC18. 
.................... #if !defined(__CCS__) 
.................... #define ALLOW_PGMFUNCTIONS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable the FSfprintf function. 
.................... // Description: The ALLOW_FSFPRINTF definition can be commented out to disable the FSfprintf function.  This will save code space.  Note that 
.................... //              if FSfprintf is enabled and the PIC18 architecture is used, integer promotions must be enabled in the Project->Build Options 
.................... //              menu.  Write operations must be enabled to use FSfprintf. 
.................... //#define ALLOW_FSFPRINTF 
....................  
.................... // CCS added this config option to disable FAT12 to prevent recursion. 
.................... //__CCS__ added by ccs 
.................... //#define SUPPORT_FAT12 
....................  
.................... // Summary: A macro to enable/disable FAT32 support. 
.................... // Description: The SUPPORT_FAT32 definition can be commented out to disable support for FAT32 functionality.  This will save a small amount 
.................... //              of code space. 
.................... #define SUPPORT_FAT32 
....................  
....................  
....................  
.................... /**************************************************************************************************/ 
.................... // Select a method for updating file timestamps 
.................... /**************************************************************************************************/ 
....................  
.................... // Summary: A macro to enable RTCC based timestamp generation 
.................... // Description: The USEREALTIMECLOCK macro will configure the code to automatically 
.................... //              generate timestamp information for files from the RTCC module. The user 
.................... //              must enable and configure the RTCC module before creating or modifying 
.................... //              files.                                                                  
.................... //#define USEREALTIMECLOCK 
....................  
.................... // Summary: A macro to enable manual timestamp generation 
.................... // Description: The USERDEFINEDCLOCK macro will allow the user to manually set 
.................... //              timestamp information using the SetClockVars function. The user will 
.................... //              need to set the time variables immediately before creating or closing a 
.................... //              file or directory.                                                     
.................... #define USERDEFINEDCLOCK 
....................  
.................... // Summary: A macro to enable don't-care timestamp generation 
.................... // Description: The INCREMENTTIMESTAMP macro will set the create time of a file to a 
.................... //              static value and increment it when a file is updated. This timestamp 
.................... //              generation method should only be used in applications where file times 
.................... //              are not necessary.                                                     
.................... //#define INCREMENTTIMESTAMP 
....................  
....................  
.................... #ifdef __18CXX 
....................    #ifdef USEREALTIMECLOCK 
....................       #error Not all PIC18 devices have a Real-time clock and calander module 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    #ifndef __18CXX 
....................       #error The pgm functions are unneccessary when not using PIC18 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef USEREALTIMECLOCK 
....................     #ifndef USERDEFINEDCLOCK 
....................         #ifndef INCREMENTTIMESTAMP 
....................             #error Please enable USEREALTIMECLOCK, USERDEFINEDCLOCK, or INCREMENTTIMESTAMP 
....................         #endif 
....................     #endif 
.................... #endif 
....................  
.................... /************************************************************************/ 
.................... // Set this preprocessor option to '1' to use dynamic FSFILE object allocation.  It will 
.................... // be necessary to allocate a heap when dynamically allocating FSFILE objects. 
.................... // Set this option to '0' to use static FSFILE object allocation. 
.................... /************************************************************************/ 
....................  
.................... //#if 1  //from mirochip 
.................... #if defined(__PCH__) //__CCS__ 
....................     // Summary: A macro indicating that FSFILE objects will be allocated dynamically 
....................     // Description: The FS_DYNAMIC_MEM macro will cause FSFILE objects to be allocated from a dynamic heap.  If it is undefined, 
....................     //              the file objects will be allocated using a static array. 
....................    //#define FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................         // Description: Function pointer to a dynamic memory allocation function 
....................       #define FS_malloc   SRAMalloc 
....................         // Description: Function pointer to a dynamic memory free function 
....................       #define FS_free      SRAMfree 
....................    #else 
....................       #define FS_malloc   malloc 
....................       #define FS_free      free 
....................    #endif 
.................... #elif defined(__CCS__) 
....................    #error/warning Not using FS_DYNAMIC_MEM for PCD compiler 
.................... #endif 
....................  
....................  
.................... #ifdef __18CXX 
....................     /* Define the locations for the dataBuffer and FATbuffer; PLEASE CHECK THE LINKER FILE */ 
....................     #define DATA_BUFFER_ADDRESS      0x700 
....................     #define FAT_BUFFER_ADDRESS       0x900 
.................... #endif 
....................  
....................  
.................... // Function definitions 
.................... // Associate the physical layer functions with the correct physical layer 
.................... #ifdef USE_SD_INTERFACE_WITH_SPI       // SD-SPI.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_SDSPI_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_SDSPI_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_SDSPI_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_SDSPI_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_SDSPI_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_SDSPI_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_SDSPI_WriteProtectState 
....................  
....................     // Description: Function pointer to the Read Capacity Physical Layer function 
....................     #define MDD_ReadCapacity        MDD_SDSPI_ReadCapacity 
....................  
....................     // Description: Function pointer to the Read Sector Size Physical Layer Function 
....................     #define MDD_ReadSectorSize      MDD_SDSPI_ReadSectorSize 
....................  
.................... #elif defined USE_CF_INTERFACE_WITH_PMP       // CF-PMP.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFPMP_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFPMP_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFPMP_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFPMP_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFPMP_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFPMP_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFPMP_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFPMP_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFPMP_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFPMP_CFread 
....................  
.................... #elif defined USE_MANUAL_CF_INTERFACE         // CF-Bit transaction.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFBT_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFBT_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFBT_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFBT_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFBT_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFBT_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFBT_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFBT_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFBT_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFBT_CFread 
....................  
.................... #elif defined USE_USB_INTERFACE               // USB host MSD library 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     USBHostMSDSCSIMediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         USBHostMSDSCSIMediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          USBHostMSDSCSISectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         USBHostMSDSCSISectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO();               
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       USBHostMSDSCSIMediaReset 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   USBHostMSDSCSIWriteProtectState 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #include "MDD File System\FSIO.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSIO.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  *                  FSconfig.h 
....................  *                  FSDefs.h 
....................  *                  stddef.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.4.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  FS_DOT_H 
.................... #define  FS_DOT_H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "../FSconfig.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSconfig.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Dependencies:    None 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _FS_DEF_ 
.................... #define _FS_DEF_ 
....................  
.................... //#include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // something to do with long filenames. 
.................... //#define SUPPORT_LFN 
....................  
.................... // Summary: A macro indicating the maximum number of concurrently open files 
.................... // Description: The FS_MAX_FILES_OPEN #define is only applicable when dynamic memory allocation is not used (FS_DYNAMIC_MEM is not defined). 
.................... //              This macro defines the maximum number of open files at any given time.  The amount of RAM used by FSFILE objects will 
.................... //              be equal to the size of an FSFILE object multipled by this macro value.  This value should be kept as small as possible 
.................... //              as dictated by the application.  This will reduce memory usage. 
.................... #define FS_MAX_FILES_OPEN    1 
....................  
....................  
.................... // if defined, MDD will be configured to use SST25 flash device. this definition 
.................... // should also define the size of the SST25 flash device. 
.................... // if not defined, will use SD card. 
.................... // #define  USE_SST25_INTERFACE  ((unsigned int32)2*1024*1024) 
....................  
.................... // Summary: A macro defining the size of a sector 
.................... // Description: The MEDIA_SECTOR_SIZE macro will define the size of a sector on the FAT file system.  This value must equal 512 bytes, 
.................... //              1024 bytes, 2048 bytes, or 4096 bytes.  The value of a sector will usually be 512 bytes. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define MEDIA_SECTOR_SIZE       4096   //erase size of SST25 flash device 
.................... #else 
.................... #define MEDIA_SECTOR_SIZE       512 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* *******************************************************************************************************/ 
.................... /************** Compiler options to enable/Disable Features based on user's application ******************/ 
.................... /* *******************************************************************************************************/ 
....................  
....................  
.................... // Summary: A macro to enable/disable file search functions. 
.................... // Description: The ALLOW_FILESEARCH definition can be commented out to disable file search functions in the library.  This will 
.................... //              prevent the use of the FindFirst and FindNext functions and reduce code size. 
.................... #define ALLOW_FILESEARCH 
....................  
.................... // Summary: A macro to enable/disable write functionality 
.................... // Description: The ALLOW_WRITES definition can be commented out to disable all operations that write to the device.  This will 
.................... //              greatly reduce code size. 
.................... #define ALLOW_WRITES 
....................  
....................  
.................... // Summary: A macro to enable/disable format functionality 
.................... // Description: The ALLOW_FORMATS definition can be commented out to disable formatting functionality.  This will prevent the use of 
.................... //              the FSformat function.  If formats are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define ALLOW_FORMATS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable directory operations. 
.................... // Description: The ALLOW_DIRS definition can be commented out to disable all directory functionality.  This will reduce code size. 
.................... //              If directories are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES in order to use 
.................... //              the FSmkdir or FSrmdir functions. 
.................... #define ALLOW_DIRS 
....................  
.................... // Summary: A macro to enable/disable PIC18 ROM functions. 
.................... // Description: The ALLOW_PGMFUNCTIONS definition can be commented out to disable all PIC18 functions that allow the user to pass string 
.................... //              arguments in ROM (denoted by the suffix -pgm).  Note that this functionality must be disabled when not using PIC18. 
.................... #if !defined(__CCS__) 
.................... #define ALLOW_PGMFUNCTIONS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable the FSfprintf function. 
.................... // Description: The ALLOW_FSFPRINTF definition can be commented out to disable the FSfprintf function.  This will save code space.  Note that 
.................... //              if FSfprintf is enabled and the PIC18 architecture is used, integer promotions must be enabled in the Project->Build Options 
.................... //              menu.  Write operations must be enabled to use FSfprintf. 
.................... //#define ALLOW_FSFPRINTF 
....................  
.................... // CCS added this config option to disable FAT12 to prevent recursion. 
.................... //__CCS__ added by ccs 
.................... //#define SUPPORT_FAT12 
....................  
.................... // Summary: A macro to enable/disable FAT32 support. 
.................... // Description: The SUPPORT_FAT32 definition can be commented out to disable support for FAT32 functionality.  This will save a small amount 
.................... //              of code space. 
.................... #define SUPPORT_FAT32 
....................  
....................  
....................  
.................... /**************************************************************************************************/ 
.................... // Select a method for updating file timestamps 
.................... /**************************************************************************************************/ 
....................  
.................... // Summary: A macro to enable RTCC based timestamp generation 
.................... // Description: The USEREALTIMECLOCK macro will configure the code to automatically 
.................... //              generate timestamp information for files from the RTCC module. The user 
.................... //              must enable and configure the RTCC module before creating or modifying 
.................... //              files.                                                                  
.................... //#define USEREALTIMECLOCK 
....................  
.................... // Summary: A macro to enable manual timestamp generation 
.................... // Description: The USERDEFINEDCLOCK macro will allow the user to manually set 
.................... //              timestamp information using the SetClockVars function. The user will 
.................... //              need to set the time variables immediately before creating or closing a 
.................... //              file or directory.                                                     
.................... #define USERDEFINEDCLOCK 
....................  
.................... // Summary: A macro to enable don't-care timestamp generation 
.................... // Description: The INCREMENTTIMESTAMP macro will set the create time of a file to a 
.................... //              static value and increment it when a file is updated. This timestamp 
.................... //              generation method should only be used in applications where file times 
.................... //              are not necessary.                                                     
.................... //#define INCREMENTTIMESTAMP 
....................  
....................  
.................... #ifdef __18CXX 
....................    #ifdef USEREALTIMECLOCK 
....................       #error Not all PIC18 devices have a Real-time clock and calander module 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    #ifndef __18CXX 
....................       #error The pgm functions are unneccessary when not using PIC18 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef USEREALTIMECLOCK 
....................     #ifndef USERDEFINEDCLOCK 
....................         #ifndef INCREMENTTIMESTAMP 
....................             #error Please enable USEREALTIMECLOCK, USERDEFINEDCLOCK, or INCREMENTTIMESTAMP 
....................         #endif 
....................     #endif 
.................... #endif 
....................  
.................... /************************************************************************/ 
.................... // Set this preprocessor option to '1' to use dynamic FSFILE object allocation.  It will 
.................... // be necessary to allocate a heap when dynamically allocating FSFILE objects. 
.................... // Set this option to '0' to use static FSFILE object allocation. 
.................... /************************************************************************/ 
....................  
.................... //#if 1  //from mirochip 
.................... #if defined(__PCH__) //__CCS__ 
....................     // Summary: A macro indicating that FSFILE objects will be allocated dynamically 
....................     // Description: The FS_DYNAMIC_MEM macro will cause FSFILE objects to be allocated from a dynamic heap.  If it is undefined, 
....................     //              the file objects will be allocated using a static array. 
....................    //#define FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................         // Description: Function pointer to a dynamic memory allocation function 
....................       #define FS_malloc   SRAMalloc 
....................         // Description: Function pointer to a dynamic memory free function 
....................       #define FS_free      SRAMfree 
....................    #else 
....................       #define FS_malloc   malloc 
....................       #define FS_free      free 
....................    #endif 
.................... #elif defined(__CCS__) 
....................    #error/warning Not using FS_DYNAMIC_MEM for PCD compiler 
.................... #endif 
....................  
....................  
.................... #ifdef __18CXX 
....................     /* Define the locations for the dataBuffer and FATbuffer; PLEASE CHECK THE LINKER FILE */ 
....................     #define DATA_BUFFER_ADDRESS      0x700 
....................     #define FAT_BUFFER_ADDRESS       0x900 
.................... #endif 
....................  
....................  
.................... // Function definitions 
.................... // Associate the physical layer functions with the correct physical layer 
.................... #ifdef USE_SD_INTERFACE_WITH_SPI       // SD-SPI.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_SDSPI_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_SDSPI_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_SDSPI_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_SDSPI_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_SDSPI_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_SDSPI_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_SDSPI_WriteProtectState 
....................  
....................     // Description: Function pointer to the Read Capacity Physical Layer function 
....................     #define MDD_ReadCapacity        MDD_SDSPI_ReadCapacity 
....................  
....................     // Description: Function pointer to the Read Sector Size Physical Layer Function 
....................     #define MDD_ReadSectorSize      MDD_SDSPI_ReadSectorSize 
....................  
.................... #elif defined USE_CF_INTERFACE_WITH_PMP       // CF-PMP.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFPMP_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFPMP_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFPMP_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFPMP_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFPMP_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFPMP_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFPMP_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFPMP_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFPMP_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFPMP_CFread 
....................  
.................... #elif defined USE_MANUAL_CF_INTERFACE         // CF-Bit transaction.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFBT_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFBT_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFBT_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFBT_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFBT_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFBT_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFBT_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFBT_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFBT_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFBT_CFread 
....................  
.................... #elif defined USE_USB_INTERFACE               // USB host MSD library 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     USBHostMSDSCSIMediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         USBHostMSDSCSIMediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          USBHostMSDSCSISectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         USBHostMSDSCSISectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO();               
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       USBHostMSDSCSIMediaReset 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   USBHostMSDSCSIWriteProtectState 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "FSDefs.h"  
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSDefs.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.2.4 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  _FSDEF__H 
.................... #define  _FSDEF__H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
....................  
.................... // Summary: An enumeration used for various error codes. 
.................... // Description: The CETYPE enumeration is used to indicate different error conditions during device operation. 
.................... typedef enum _CETYPE 
.................... { 
....................     CE_GOOD = 0,                    // No error 
....................     CE_ERASE_FAIL,                  // An erase failed 
....................     CE_NOT_PRESENT,                 // No device was present 
....................     CE_NOT_FORMATTED,               // The disk is of an unsupported format 
....................     CE_BAD_PARTITION,               // The boot record is bad 
....................     CE_UNSUPPORTED_FS,              // The file system type is unsupported 
....................     CE_INIT_ERROR,                  // An initialization error has occured 
....................     CE_NOT_INIT,                    // An operation was performed on an uninitialized device 
....................     CE_BAD_SECTOR_READ,             // A bad read of a sector occured 
....................     CE_WRITE_ERROR,                 // Could not write to a sector 
....................     CE_INVALID_CLUSTER,             // Invalid cluster value > maxcls 
....................     CE_FILE_NOT_FOUND,              // Could not find the file on the device 
....................     CE_DIR_NOT_FOUND,               // Could not find the directory 
....................     CE_BAD_FILE,                    // File is corrupted 
....................     CE_DONE,                        // No more files in this directory 
....................     CE_COULD_NOT_GET_CLUSTER,       // Could not load/allocate next cluster in file 
....................     CE_FILENAME_2_LONG,             // A specified file name is too long to use 
....................     CE_FILENAME_EXISTS,             // A specified filename already exists on the device 
....................     CE_INVALID_FILENAME,            // Invalid file name 
....................     CE_DELETE_DIR,                  // The user tried to delete a directory with FSremove 
....................     CE_DIR_FULL,                    // All root dir entry are taken 
....................     CE_DISK_FULL,                   // All clusters in partition are taken 
....................     CE_DIR_NOT_EMPTY,               // This directory is not empty yet, remove files before deleting 
....................     CE_NONSUPPORTED_SIZE,           // The disk is too big to format as FAT16 
....................     CE_WRITE_PROTECTED,             // Card is write protected 
....................     CE_FILENOTOPENED,               // File not opened for the write 
....................     CE_SEEK_ERROR,                  // File location could not be changed successfully 
....................     CE_BADCACHEREAD,                // Bad cache read 
....................     CE_CARDFAT32,                   // FAT 32 - card not supported 
....................     CE_READONLY,                    // The file is read-only 
....................     CE_WRITEONLY,                   // The file is write-only 
....................     CE_INVALID_ARGUMENT,            // Invalid argument 
....................     CE_TOO_MANY_FILES_OPEN,         // Too many files are already open 
....................     CE_UNSUPPORTED_SECTOR_SIZE,     // Unsupported sector size 
....................     CE_EOF = 61 
.................... } CETYPE; 
....................  
....................  
.................... // Summary: A macro indicating a dir entry was found 
.................... // Description: The FOUND macro indicates that a directory entry was found in the specified position 
.................... #define FOUND       0 
....................  
.................... // Summary: A macro indicating no dir entry was found 
.................... // Description: The NOT_FOUND macro indicates that the specified directory entry to load was deleted 
.................... #define NOT_FOUND   1 
....................  
.................... // Summary: A macro indicating that no more files were found 
.................... // Description: The NO_MORE macro indicates that there are no more directory entries to search for 
.................... #define NO_MORE     2 
....................  
....................  
....................  
.................... // Summary: A macro indicating the device is formatted with FAT12 
.................... // Description: The FAT12 macro is used to indicate that the file system on the device being accessed is a FAT12 file system. 
.................... #define FAT12       1 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT16 
.................... // Description: The FAT16 macro is used to indicate that the file system on the device being accessed is a FAT16 file system. 
.................... #define FAT16       2 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT32 
.................... // Description: The FAT32 macro is used to indicate that the file system on the device being accessed is a FAT32 file system. 
.................... #define FAT32       3 
....................  
....................  
....................  
.................... // Summary: A read-only attribute macro 
.................... // Description: A macro for the read-only attribute.  A file with this attribute should not be written to.  Note that this 
.................... //              attribute will not actually prevent a write to the file; that functionality is operating-system dependant.  The 
.................... //              user should take care not to write to a read-only file. 
.................... #define ATTR_READ_ONLY      0x01 
....................  
.................... // Summary: A hidden attribute macro 
.................... // Description: A macro for the hidden attribute.  A file with this attribute may be hidden from the user, depending on the 
.................... //              implementation of the operating system. 
.................... #define ATTR_HIDDEN         0x02 
....................  
.................... // Summary: A system attribute macro 
.................... // Description: A macro for the system attribute.  A file with this attribute is used by the operating system, and should not be 
.................... //              modified.  Note that this attribute will not actually prevent a write to the file. 
.................... #define ATTR_SYSTEM         0x04 
....................  
.................... // Summary: A volume attribute macro 
.................... // Description: A macro for the volume attribute.  If the first directory entry in the root directory has the volume attribute set, 
.................... //              the device will use the name in that directory entry as the volume name. 
.................... #define ATTR_VOLUME         0x08 
....................  
.................... // Summary: A macro for the attributes for a long-file name entry 
.................... // Description: A macro for the long-name attributes.  If a directory entry is used in a long-file name implementation, it will have 
.................... //              all four lower bits set.  This indicates that any software that does not support long file names should ignore that 
.................... //              entry. 
.................... #define ATTR_LONG_NAME      0x0f 
....................  
.................... // Summary: A directory attribute macro 
.................... // Description: A macro for the directory attribute.  If a directory entry has this attribute set, the file it points to is a directory- 
.................... //              type file, and will contain directory entries that point to additional directories or files. 
.................... #define ATTR_DIRECTORY      0x10 
....................  
.................... // Summary: An archive attribute macro 
.................... // Description: A macro for the archive attribute.  This attribute will indicate to some archiving programs that the file with this 
.................... //              attribute needs to be backed up.  Most operating systems create files with the archive attribute set. 
.................... #define ATTR_ARCHIVE        0x20 
....................  
.................... // Summary: A macro for all attributes 
.................... // Description: A macro for all attributes.  The search functions in this library require an argument that determines which attributes 
.................... //              a file is allowed to have in order to be found.  If ATTR_MASK is specified as this argument, any file may be found, regardless 
.................... //              of its attributes. 
.................... #define ATTR_MASK           0x3f 
....................  
....................  
....................  
.................... // Summary: A macro to indicate an empty FAT entry 
.................... // Description: The CLUSTER_EMPTY value is used to indicate that a FAT entry and it's corresponding cluster are available. 
.................... #define CLUSTER_EMPTY               0x0000  
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT12 
.................... // Description: The LAST_CLUSTER_FAT12 macro is used when reading the FAT to indicate that the next FAT12 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT12          0xff8 
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT16 
.................... // Description: The LAST_CLUSTER_FAT16 macro is used when reading the FAT to indicate that the next FAT16 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT16          0xfff8 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT12 
.................... // Description: The END_CLUSTER_FAT12 value is used as a comparison in FAT12 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT12           0xFF7 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT16 
.................... // Description: The END_CLUSTER_FAT16 value is used as a comparison in FAT16 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT16           0xFFF7 
....................  
.................... // Summary: A macro to indicate the failure of the ReadFAT function 
.................... // Description: The CLUSTER_FAIL_FAT16 macro is used by the ReadFAT function to indicate that an error occured reading a FAT12 or FAT16 
.................... //              file allocation table.  Note that since '0xFFF8' is used for the last cluster return value in the FAT16 implementation 
.................... //              the end-of-file value '0xFFFF' can be used to indicate an error condition. 
.................... #define CLUSTER_FAIL_FAT16          0xFFFF 
....................  
....................  
....................  
.................... #ifdef SUPPORT_FAT32 
....................     // Summary: A macro to indicate the last cluster value for FAT32 
....................     // Description: The LAST_CLUSTER_FAT32 macro is used when reading the FAT to indicate that the next FAT32 entry for a file contains 
....................     //              the end-of-file value. 
....................     #define LAST_CLUSTER_FAT32      0x0FFFFFF8 
....................  
....................     // Summary: A macro to indicate the last allocatable cluster for FAT32 
....................     // Description: The END_CLUSTER_FAT32 value is used as a comparison in FAT32 to determine that the firmware has reached the end of 
....................     //              the range of allowed allocatable clusters. 
....................     #define END_CLUSTER_FAT32       0x0FFFFFF7 
....................  
....................     // Summary: A macro to indicate the failure of the ReadFAT function 
....................     // Description: The CLUSTER_FAIL_FAT32 macro is used by the ReadFAT function to indicate that an error occured reading a FAT32 
....................     //              file allocation able. 
....................     #define CLUSTER_FAIL_FAT32      0x0FFFFFFF 
....................  
.................... #endif 
....................  
.................... // Summary: A macro indicating the number of bytes in a directory entry. 
.................... // Description: The NUMBER_OF_BYTES_IN_DIR_ENTRY macro represents the number of bytes in one directory entry.  It is used to calculate 
.................... //              the number of sectors in the root directory based on information in the boot sector. 
.................... #define NUMBER_OF_BYTES_IN_DIR_ENTRY    32 
....................  
....................  
....................  
.................... // Summary: A macro for a deleted dir entry marker. 
.................... // Description: The DIR_DEL macro is used to mark a directory entry as deleted.  When a file is deleted, this value will replace the 
.................... //              first character in the file name, and will indicate that the file the entry points to was deleted. 
.................... #define DIR_DEL             0xE5 
....................  
.................... // Summary: A macro for the last dir entry marker. 
.................... // Description: The DIR_EMPTY macro is used to indicate the last entry in a directory.  Since entries in use cannot start with a 0 and 
.................... //              deleted entries start with the DIR_DEL character, a 0 will mark the end of the in-use or previously used group of 
.................... //              entries in a directory 
.................... #define DIR_EMPTY           0 
....................  
....................  
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name 
.................... // Description: The DIR_NAMESIZE macro is used when validing the name portion of 8.3 filenames 
.................... #define DIR_NAMESIZE        8 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file extension 
.................... // Description: The DIR_EXTENSION macro is used when validating the extension portion of 8.3 filenames 
.................... #define DIR_EXTENSION       3 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name and extension 
.................... // Description: The DIR_NAMECOMP macro is used when validating 8.3 filenames 
.................... #define DIR_NAMECOMP        (DIR_NAMESIZE+DIR_EXTENSION) 
....................  
....................  
....................  
.................... // Summary: A macro to write a byte to RAM 
.................... // Description: The RAMwrite macro is used to write a byte of data to a RAM array 
.................... #define RAMwrite( a, f, d) *(a+f) = d 
....................  
.................... // Summary: A macro to read a byte from RAM 
.................... // Description: The RAMread macro is used to read a byte of data from a RAM array 
.................... #define RAMread( a, f)  *(a+f) 
....................  
.................... // Summary: A macro to read a 16-bit word from RAM 
.................... // Description: The RAMreadW macro is used to read two bytes of data from a RAM array 
.................... #define RAMreadW( a, f) *(WORD *)(a+f) 
....................  
.................... // Summary: A macro to read a 32-bit word from RAM 
.................... // Description: The RAMreadD macro is used to read four bytes of data from a RAM array 
.................... #define RAMreadD( a, f) *(DWORD *)(a+f) 
....................  
....................  
....................  
.................... #ifndef EOF 
....................     // Summary: Indicates error conditions or end-of-file conditions 
....................     // Description: The EOF macro is used to indicate error conditions in some function calls.  It is also used to indicate 
....................     //              that the end-of-file has been reached. 
....................     #define EOF             ((int)-1) 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing information about the device. 
.................... // Description: The DISK structure contains information about the device being accessed. 
.................... typedef struct 
.................... {  
....................     BYTE    *   buffer;         // Address of the global data buffer used to read and write file information 
....................     DWORD       firsts;         // Logical block address of the first sector of the FAT partition on the device 
....................     DWORD       fat;            // Logical block address of the FAT 
....................     DWORD       root;           // Logical block address of the root directory 
....................     DWORD       data;           // Logical block address of the data section of the device. 
....................     WORD        maxroot;        // The maximum number of entries in the root directory. 
....................     DWORD       maxcls;         // The maximum number of clusters in the partition. 
....................     DWORD       sectorSize;     // The size of a sector in bytes 
....................     DWORD       fatsize;        // The number of sectors in the FAT 
....................     BYTE        fatcopy;        // The number of copies of the FAT in the partition 
....................     BYTE        SecPerClus;     // The number of sectors per cluster in the data region 
....................     BYTE        type;           // The file system type of the partition (FAT12, FAT16 or FAT32) 
....................     BYTE        mount;          // Device mount flag (TRUE if disk was mounted successfully, FALSE otherwise) 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... } __attribute__ ((packed)) DISK; 
.................... #else 
.................... } DISK; 
.................... #endif 
....................  
....................  
.................... #if defined(__18CXX) && !defined(__CCS__) 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef unsigned short long SWORD; 
.................... #else 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef struct 
....................     { 
....................         unsigned char array[3]; 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) SWORD; 
.................... #else 
....................     } SWORD; 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT12 file system (in the boot sector) 
.................... // Description: The _BPB_FAT12 structure provides a layout of the "bios parameter block" in the boot sector of a FAT12 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BPS;               // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD BootSec_ResrvSec;          // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD BootSec_RootDirEnts;       // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD BootSec_SPF;               // Number of sectors per FAT 
....................     WORD BootSec_SPT;               // Number of sectors per track 
....................     WORD BootSec_HeadCnt;           // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD  BootSec_Reserved;        // Reserved space 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved2;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination    
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT12; 
.................... #else 
....................     } _BPB_FAT12; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT16 file system (in the boot sector) 
.................... // Description: The _BPB_FAT16 structure provides a layout of the "bios parameter block" in the boot sector of a FAT16 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD  BootSec_BPS;              // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD  BootSec_ResrvSec;         // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD  BootSec_RootDirEnts;      // Number of root directory entries 
....................     WORD  BootSec_TotSec16;         // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD  BootSec_SPF;              // Number of sectors per FAT 
....................     WORD  BootSec_SPT;              // Number of sectors per track 
....................     WORD  BootSec_HeadCnt;          // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved;         // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination      
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT16; 
.................... #else 
....................     } _BPB_FAT16; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT32 file system (in the boot sector) 
.................... // Description: The _BPB_FAT32 structure provides a layout of the "bios parameter block" in the boot sector of a FAT32 partition. 
.................... typedef struct { 
....................     SWORD BootSec_jmpBoot;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BytsPerSec;        // Number of bytes per sector 
....................     BYTE  BootSec_SecPerClus;       // Number of sectors per cluster 
....................     WORD BootSec_RsvdSecCnt;        // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_NumFATs;          // Number of FATs on the partition 
....................     WORD BootSec_RootEntCnt;        // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_Media;            // Media descriptor 
....................     WORD BootSec_FATSz16;           // Number of sectors per FAT 
....................     WORD BootSec_SecPerTrk;         // Number of sectors per track 
....................     WORD BootSec_NumHeads;          // Number of heads 
....................     DWORD BootSec_HiddSec;          // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     DWORD BootSec_FATSz32;          // Sectors per FAT (32 bits) 
....................     WORD BootSec_ExtFlags;          // Presently active FAT. Defined by bits 0-3 if bit 7 is 1. 
....................     WORD BootSec_FSVers;            // FAT32 filesystem version.  Should be 0:0 
....................     DWORD BootSec_RootClus;         // Start cluster of the root directory (should be 2) 
....................     WORD BootSec_FSInfo;            // File system information 
....................     WORD BootSec_BkBootSec;         // Backup boot sector address. 
....................     BYTE  BootSec_Reserved[12];     // Reserved space 
....................     BYTE  BootSec_DrvNum;           // Drive number 
....................     BYTE  BootSec_Reserved1;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLab[11];       // Volume Label 
....................     BYTE  BootSec_FilSysType[8];    // File system type in ASCII.  Not used for determination   
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT32; 
.................... #else 
....................     } _BPB_FAT32; 
.................... #endif 
....................  
....................  
.................... // Description: A macro for the boot sector bytes per sector value offset 
.................... #define BSI_BPS            11 
....................  
.................... // Description: A macro for the boot sector sector per cluster value offset 
.................... #define BSI_SPC            13 
....................  
.................... // Description: A macro for the boot sector reserved sector count value offset 
.................... #define BSI_RESRVSEC       14 
....................  
.................... // Description: A macro for the boot sector FAT count value offset 
.................... #define BSI_FATCOUNT       16 
....................  
.................... // Description: A macro for the boot sector root directory entry count value offset 
.................... #define BSI_ROOTDIRENTS    17 
....................  
.................... // Description: A macro for the boot sector 16-bit total sector count value offset 
.................... #define BSI_TOTSEC16       19 
....................  
.................... // Description: A macro for the boot sector sectors per FAT value offset 
.................... #define BSI_SPF            22 
....................  
.................... // Description: A macro for the boot sector 32-bit total sector count value offset 
.................... #define BSI_TOTSEC32       32 
....................  
.................... // Description: A macro for the boot sector boot signature offset 
.................... #define BSI_BOOTSIG        38 
....................  
.................... // Description: A macro for the boot sector file system type string offset 
.................... #define BSI_FSTYPE         54 
....................  
.................... // Description: A macro for the boot sector 32-bit sector per FAT value offset 
.................... #define  BSI_FATSZ32       36 
....................  
.................... // Description: A macro for the boot sector start cluster of root directory value offset 
.................... #define  BSI_ROOTCLUS      44 
....................  
.................... // Description: A macro for the FAT32 boot sector boot signature offset 
.................... #define  BSI_FAT32_BOOTSIG 66 
....................  
.................... // Description: A macro for the FAT32 boot sector file system type string offset 
.................... #define  BSI_FAT32_FSTYPE  82 
....................  
....................  
....................  
.................... // Summary: A partition table entry structure. 
.................... // Description: The PTE_MBR structure contains values found in a partition table entry in the MBR of a device. 
.................... typedef struct 
.................... { 
....................     BYTE      PTE_BootDes;            // The boot descriptor (should be 0x00 in a non-bootable device) 
....................     SWORD     PTE_FrstPartSect;       // The cylinder-head-sector address of the first sector of the partition 
....................     BYTE      PTE_FSDesc;             // The file system descriptor 
....................     SWORD     PTE_LstPartSect;        // The cylinder-head-sector address of the last sector of the partition 
....................     DWORD     PTE_FrstSect;           // The logical block address of the first sector of the partition 
....................     DWORD     PTE_NumSect;            // The number of sectors in a partition 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) PTE_MBR; 
.................... #else 
....................     } PTE_MBR; 
.................... #endif 
....................  
....................  
.................... // Summary: A structure of the organization of a master boot record. 
.................... // Description: The _PT_MBR structure has the same form as a master boot record.  When the MBR is loaded from the device, it will 
.................... //              be cast as a _PT_MBR structure so the MBR elements can be accessed. 
.................... typedef struct 
.................... { 
....................     BYTE        ConsChkRtn[446];        // Boot code 
....................     PTE_MBR     Partition0;             // The first partition table entry 
....................     PTE_MBR     Partition1;             // The second partition table entry 
....................     PTE_MBR     Partition2;             // The third partition table entry 
....................     PTE_MBR     Partition3;             // The fourth partition table entry 
....................     BYTE        Signature0;             // MBR signature code - equal to 0x55 
....................     BYTE        Signature1;             // MBR signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... }__attribute__((packed)) _PT_MBR; 
.................... #else 
.................... }_PT_MBR; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _PT_MBR structure 
.................... // Description: The PT_MBR pointer points to a _PT_MBR structure. 
.................... typedef _PT_MBR *  PT_MBR; 
....................  
....................  
....................  
.................... // Summary: A structure of the organization of a boot sector. 
.................... // Description: The _BootSec structure has the same form as a boot sector.  When the boot sector is loaded from the device, it will 
.................... //              be cast as a _BootSec structure so the boot sector elements can be accessed. 
.................... typedef struct 
.................... { 
....................     // A union of different bios parameter blocks 
....................     union 
....................     { 
....................         _BPB_FAT32  FAT_32; 
....................         _BPB_FAT16  FAT_16; 
....................         _BPB_FAT12  FAT_12; 
....................     }FAT; 
....................     BYTE    Reserved[512-sizeof(_BPB_FAT32)-2]; // Reserved space 
....................     BYTE    Signature0;         // Boot sector signature code - equal to 0x55 
....................     BYTE    Signature1;         // Boot sector signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BootSec; 
.................... #else 
....................     } _BootSec; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _BootSec structure 
.................... // Description: The BootSec pointer points to a _BootSec structure. 
.................... typedef _BootSec * BootSec; 
....................  
....................  
....................  
.................... // Summary: A macro indicating the offset for the master boot record 
.................... // Description: FO_MBR is a macro that indicates the addresss of the master boot record on the device.  When the device is initialized 
.................... //              this sector will be read 
.................... #define FO_MBR          0L 
....................  
....................  
....................  
.................... // Summary: A macro for the first boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_0 macro is used to determine that the first byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_0     0x55 
....................  
.................... // Summary: A macro for the second boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_1 macro is used to determine that the second byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_1     0xAA 
....................  
....................  
.................... typedef struct  
.................... { 
....................     BYTE    errorCode; 
....................     union  
....................     { 
....................         BYTE    value; 
....................         struct  
....................         { 
....................             BYTE    sectorSize  : 1; 
....................             BYTE    maxLUN      : 1; 
....................         }   bits; 
....................     } validityFlags; 
....................      
....................     WORD    sectorSize; 
....................     BYTE    maxLUN; 
.................... } MEDIA_INFORMATION; 
....................  
.................... typedef enum 
.................... { 
....................     MEDIA_NO_ERROR,                     // No errors 
....................     MEDIA_DEVICE_NOT_PRESENT,           // The requested device is not present 
....................     MEDIA_CANNOT_INITIALIZE             // Cannot initialize media 
.................... } MEDIA_ERRORS;                 
....................  
....................  
.................... #endif 
....................  
.................... #include "stddef.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... #ifdef USE_SD_INTERFACE_WITH_SPI 
....................     #include    "SD-SPI.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        SD-SPI.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  *                  FSconfig.h 
....................  *                  FSDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the "Company") for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef SDMMC_H 
.................... #define SDMMC_H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "../FSconfig.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSconfig.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Dependencies:    None 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _FS_DEF_ 
.................... #define _FS_DEF_ 
....................  
.................... //#include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // something to do with long filenames. 
.................... //#define SUPPORT_LFN 
....................  
.................... // Summary: A macro indicating the maximum number of concurrently open files 
.................... // Description: The FS_MAX_FILES_OPEN #define is only applicable when dynamic memory allocation is not used (FS_DYNAMIC_MEM is not defined). 
.................... //              This macro defines the maximum number of open files at any given time.  The amount of RAM used by FSFILE objects will 
.................... //              be equal to the size of an FSFILE object multipled by this macro value.  This value should be kept as small as possible 
.................... //              as dictated by the application.  This will reduce memory usage. 
.................... #define FS_MAX_FILES_OPEN    1 
....................  
....................  
.................... // if defined, MDD will be configured to use SST25 flash device. this definition 
.................... // should also define the size of the SST25 flash device. 
.................... // if not defined, will use SD card. 
.................... // #define  USE_SST25_INTERFACE  ((unsigned int32)2*1024*1024) 
....................  
.................... // Summary: A macro defining the size of a sector 
.................... // Description: The MEDIA_SECTOR_SIZE macro will define the size of a sector on the FAT file system.  This value must equal 512 bytes, 
.................... //              1024 bytes, 2048 bytes, or 4096 bytes.  The value of a sector will usually be 512 bytes. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define MEDIA_SECTOR_SIZE       4096   //erase size of SST25 flash device 
.................... #else 
.................... #define MEDIA_SECTOR_SIZE       512 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* *******************************************************************************************************/ 
.................... /************** Compiler options to enable/Disable Features based on user's application ******************/ 
.................... /* *******************************************************************************************************/ 
....................  
....................  
.................... // Summary: A macro to enable/disable file search functions. 
.................... // Description: The ALLOW_FILESEARCH definition can be commented out to disable file search functions in the library.  This will 
.................... //              prevent the use of the FindFirst and FindNext functions and reduce code size. 
.................... #define ALLOW_FILESEARCH 
....................  
.................... // Summary: A macro to enable/disable write functionality 
.................... // Description: The ALLOW_WRITES definition can be commented out to disable all operations that write to the device.  This will 
.................... //              greatly reduce code size. 
.................... #define ALLOW_WRITES 
....................  
....................  
.................... // Summary: A macro to enable/disable format functionality 
.................... // Description: The ALLOW_FORMATS definition can be commented out to disable formatting functionality.  This will prevent the use of 
.................... //              the FSformat function.  If formats are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define ALLOW_FORMATS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable directory operations. 
.................... // Description: The ALLOW_DIRS definition can be commented out to disable all directory functionality.  This will reduce code size. 
.................... //              If directories are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES in order to use 
.................... //              the FSmkdir or FSrmdir functions. 
.................... #define ALLOW_DIRS 
....................  
.................... // Summary: A macro to enable/disable PIC18 ROM functions. 
.................... // Description: The ALLOW_PGMFUNCTIONS definition can be commented out to disable all PIC18 functions that allow the user to pass string 
.................... //              arguments in ROM (denoted by the suffix -pgm).  Note that this functionality must be disabled when not using PIC18. 
.................... #if !defined(__CCS__) 
.................... #define ALLOW_PGMFUNCTIONS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable the FSfprintf function. 
.................... // Description: The ALLOW_FSFPRINTF definition can be commented out to disable the FSfprintf function.  This will save code space.  Note that 
.................... //              if FSfprintf is enabled and the PIC18 architecture is used, integer promotions must be enabled in the Project->Build Options 
.................... //              menu.  Write operations must be enabled to use FSfprintf. 
.................... //#define ALLOW_FSFPRINTF 
....................  
.................... // CCS added this config option to disable FAT12 to prevent recursion. 
.................... //__CCS__ added by ccs 
.................... //#define SUPPORT_FAT12 
....................  
.................... // Summary: A macro to enable/disable FAT32 support. 
.................... // Description: The SUPPORT_FAT32 definition can be commented out to disable support for FAT32 functionality.  This will save a small amount 
.................... //              of code space. 
.................... #define SUPPORT_FAT32 
....................  
....................  
....................  
.................... /**************************************************************************************************/ 
.................... // Select a method for updating file timestamps 
.................... /**************************************************************************************************/ 
....................  
.................... // Summary: A macro to enable RTCC based timestamp generation 
.................... // Description: The USEREALTIMECLOCK macro will configure the code to automatically 
.................... //              generate timestamp information for files from the RTCC module. The user 
.................... //              must enable and configure the RTCC module before creating or modifying 
.................... //              files.                                                                  
.................... //#define USEREALTIMECLOCK 
....................  
.................... // Summary: A macro to enable manual timestamp generation 
.................... // Description: The USERDEFINEDCLOCK macro will allow the user to manually set 
.................... //              timestamp information using the SetClockVars function. The user will 
.................... //              need to set the time variables immediately before creating or closing a 
.................... //              file or directory.                                                     
.................... #define USERDEFINEDCLOCK 
....................  
.................... // Summary: A macro to enable don't-care timestamp generation 
.................... // Description: The INCREMENTTIMESTAMP macro will set the create time of a file to a 
.................... //              static value and increment it when a file is updated. This timestamp 
.................... //              generation method should only be used in applications where file times 
.................... //              are not necessary.                                                     
.................... //#define INCREMENTTIMESTAMP 
....................  
....................  
.................... #ifdef __18CXX 
....................    #ifdef USEREALTIMECLOCK 
....................       #error Not all PIC18 devices have a Real-time clock and calander module 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    #ifndef __18CXX 
....................       #error The pgm functions are unneccessary when not using PIC18 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef USEREALTIMECLOCK 
....................     #ifndef USERDEFINEDCLOCK 
....................         #ifndef INCREMENTTIMESTAMP 
....................             #error Please enable USEREALTIMECLOCK, USERDEFINEDCLOCK, or INCREMENTTIMESTAMP 
....................         #endif 
....................     #endif 
.................... #endif 
....................  
.................... /************************************************************************/ 
.................... // Set this preprocessor option to '1' to use dynamic FSFILE object allocation.  It will 
.................... // be necessary to allocate a heap when dynamically allocating FSFILE objects. 
.................... // Set this option to '0' to use static FSFILE object allocation. 
.................... /************************************************************************/ 
....................  
.................... //#if 1  //from mirochip 
.................... #if defined(__PCH__) //__CCS__ 
....................     // Summary: A macro indicating that FSFILE objects will be allocated dynamically 
....................     // Description: The FS_DYNAMIC_MEM macro will cause FSFILE objects to be allocated from a dynamic heap.  If it is undefined, 
....................     //              the file objects will be allocated using a static array. 
....................    //#define FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................         // Description: Function pointer to a dynamic memory allocation function 
....................       #define FS_malloc   SRAMalloc 
....................         // Description: Function pointer to a dynamic memory free function 
....................       #define FS_free      SRAMfree 
....................    #else 
....................       #define FS_malloc   malloc 
....................       #define FS_free      free 
....................    #endif 
.................... #elif defined(__CCS__) 
....................    #error/warning Not using FS_DYNAMIC_MEM for PCD compiler 
.................... #endif 
....................  
....................  
.................... #ifdef __18CXX 
....................     /* Define the locations for the dataBuffer and FATbuffer; PLEASE CHECK THE LINKER FILE */ 
....................     #define DATA_BUFFER_ADDRESS      0x700 
....................     #define FAT_BUFFER_ADDRESS       0x900 
.................... #endif 
....................  
....................  
.................... // Function definitions 
.................... // Associate the physical layer functions with the correct physical layer 
.................... #ifdef USE_SD_INTERFACE_WITH_SPI       // SD-SPI.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_SDSPI_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_SDSPI_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_SDSPI_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_SDSPI_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_SDSPI_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_SDSPI_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_SDSPI_WriteProtectState 
....................  
....................     // Description: Function pointer to the Read Capacity Physical Layer function 
....................     #define MDD_ReadCapacity        MDD_SDSPI_ReadCapacity 
....................  
....................     // Description: Function pointer to the Read Sector Size Physical Layer Function 
....................     #define MDD_ReadSectorSize      MDD_SDSPI_ReadSectorSize 
....................  
.................... #elif defined USE_CF_INTERFACE_WITH_PMP       // CF-PMP.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFPMP_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFPMP_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFPMP_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFPMP_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFPMP_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFPMP_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFPMP_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFPMP_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFPMP_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFPMP_CFread 
....................  
.................... #elif defined USE_MANUAL_CF_INTERFACE         // CF-Bit transaction.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFBT_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFBT_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFBT_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFBT_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFBT_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFBT_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFBT_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFBT_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFBT_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFBT_CFread 
....................  
.................... #elif defined USE_USB_INTERFACE               // USB host MSD library 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     USBHostMSDSCSIMediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         USBHostMSDSCSIMediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          USBHostMSDSCSISectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         USBHostMSDSCSISectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO();               
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       USBHostMSDSCSIMediaReset 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   USBHostMSDSCSIWriteProtectState 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "FSDefs.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSDefs.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.2.4 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  _FSDEF__H 
.................... #define  _FSDEF__H 
....................  
.................... #include "../GenericTypeDefs.h" 
....................  
.................... // Summary: An enumeration used for various error codes. 
.................... // Description: The CETYPE enumeration is used to indicate different error conditions during device operation. 
.................... typedef enum _CETYPE 
.................... { 
....................     CE_GOOD = 0,                    // No error 
....................     CE_ERASE_FAIL,                  // An erase failed 
....................     CE_NOT_PRESENT,                 // No device was present 
....................     CE_NOT_FORMATTED,               // The disk is of an unsupported format 
....................     CE_BAD_PARTITION,               // The boot record is bad 
....................     CE_UNSUPPORTED_FS,              // The file system type is unsupported 
....................     CE_INIT_ERROR,                  // An initialization error has occured 
....................     CE_NOT_INIT,                    // An operation was performed on an uninitialized device 
....................     CE_BAD_SECTOR_READ,             // A bad read of a sector occured 
....................     CE_WRITE_ERROR,                 // Could not write to a sector 
....................     CE_INVALID_CLUSTER,             // Invalid cluster value > maxcls 
....................     CE_FILE_NOT_FOUND,              // Could not find the file on the device 
....................     CE_DIR_NOT_FOUND,               // Could not find the directory 
....................     CE_BAD_FILE,                    // File is corrupted 
....................     CE_DONE,                        // No more files in this directory 
....................     CE_COULD_NOT_GET_CLUSTER,       // Could not load/allocate next cluster in file 
....................     CE_FILENAME_2_LONG,             // A specified file name is too long to use 
....................     CE_FILENAME_EXISTS,             // A specified filename already exists on the device 
....................     CE_INVALID_FILENAME,            // Invalid file name 
....................     CE_DELETE_DIR,                  // The user tried to delete a directory with FSremove 
....................     CE_DIR_FULL,                    // All root dir entry are taken 
....................     CE_DISK_FULL,                   // All clusters in partition are taken 
....................     CE_DIR_NOT_EMPTY,               // This directory is not empty yet, remove files before deleting 
....................     CE_NONSUPPORTED_SIZE,           // The disk is too big to format as FAT16 
....................     CE_WRITE_PROTECTED,             // Card is write protected 
....................     CE_FILENOTOPENED,               // File not opened for the write 
....................     CE_SEEK_ERROR,                  // File location could not be changed successfully 
....................     CE_BADCACHEREAD,                // Bad cache read 
....................     CE_CARDFAT32,                   // FAT 32 - card not supported 
....................     CE_READONLY,                    // The file is read-only 
....................     CE_WRITEONLY,                   // The file is write-only 
....................     CE_INVALID_ARGUMENT,            // Invalid argument 
....................     CE_TOO_MANY_FILES_OPEN,         // Too many files are already open 
....................     CE_UNSUPPORTED_SECTOR_SIZE,     // Unsupported sector size 
....................     CE_EOF = 61 
.................... } CETYPE; 
....................  
....................  
.................... // Summary: A macro indicating a dir entry was found 
.................... // Description: The FOUND macro indicates that a directory entry was found in the specified position 
.................... #define FOUND       0 
....................  
.................... // Summary: A macro indicating no dir entry was found 
.................... // Description: The NOT_FOUND macro indicates that the specified directory entry to load was deleted 
.................... #define NOT_FOUND   1 
....................  
.................... // Summary: A macro indicating that no more files were found 
.................... // Description: The NO_MORE macro indicates that there are no more directory entries to search for 
.................... #define NO_MORE     2 
....................  
....................  
....................  
.................... // Summary: A macro indicating the device is formatted with FAT12 
.................... // Description: The FAT12 macro is used to indicate that the file system on the device being accessed is a FAT12 file system. 
.................... #define FAT12       1 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT16 
.................... // Description: The FAT16 macro is used to indicate that the file system on the device being accessed is a FAT16 file system. 
.................... #define FAT16       2 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT32 
.................... // Description: The FAT32 macro is used to indicate that the file system on the device being accessed is a FAT32 file system. 
.................... #define FAT32       3 
....................  
....................  
....................  
.................... // Summary: A read-only attribute macro 
.................... // Description: A macro for the read-only attribute.  A file with this attribute should not be written to.  Note that this 
.................... //              attribute will not actually prevent a write to the file; that functionality is operating-system dependant.  The 
.................... //              user should take care not to write to a read-only file. 
.................... #define ATTR_READ_ONLY      0x01 
....................  
.................... // Summary: A hidden attribute macro 
.................... // Description: A macro for the hidden attribute.  A file with this attribute may be hidden from the user, depending on the 
.................... //              implementation of the operating system. 
.................... #define ATTR_HIDDEN         0x02 
....................  
.................... // Summary: A system attribute macro 
.................... // Description: A macro for the system attribute.  A file with this attribute is used by the operating system, and should not be 
.................... //              modified.  Note that this attribute will not actually prevent a write to the file. 
.................... #define ATTR_SYSTEM         0x04 
....................  
.................... // Summary: A volume attribute macro 
.................... // Description: A macro for the volume attribute.  If the first directory entry in the root directory has the volume attribute set, 
.................... //              the device will use the name in that directory entry as the volume name. 
.................... #define ATTR_VOLUME         0x08 
....................  
.................... // Summary: A macro for the attributes for a long-file name entry 
.................... // Description: A macro for the long-name attributes.  If a directory entry is used in a long-file name implementation, it will have 
.................... //              all four lower bits set.  This indicates that any software that does not support long file names should ignore that 
.................... //              entry. 
.................... #define ATTR_LONG_NAME      0x0f 
....................  
.................... // Summary: A directory attribute macro 
.................... // Description: A macro for the directory attribute.  If a directory entry has this attribute set, the file it points to is a directory- 
.................... //              type file, and will contain directory entries that point to additional directories or files. 
.................... #define ATTR_DIRECTORY      0x10 
....................  
.................... // Summary: An archive attribute macro 
.................... // Description: A macro for the archive attribute.  This attribute will indicate to some archiving programs that the file with this 
.................... //              attribute needs to be backed up.  Most operating systems create files with the archive attribute set. 
.................... #define ATTR_ARCHIVE        0x20 
....................  
.................... // Summary: A macro for all attributes 
.................... // Description: A macro for all attributes.  The search functions in this library require an argument that determines which attributes 
.................... //              a file is allowed to have in order to be found.  If ATTR_MASK is specified as this argument, any file may be found, regardless 
.................... //              of its attributes. 
.................... #define ATTR_MASK           0x3f 
....................  
....................  
....................  
.................... // Summary: A macro to indicate an empty FAT entry 
.................... // Description: The CLUSTER_EMPTY value is used to indicate that a FAT entry and it's corresponding cluster are available. 
.................... #define CLUSTER_EMPTY               0x0000  
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT12 
.................... // Description: The LAST_CLUSTER_FAT12 macro is used when reading the FAT to indicate that the next FAT12 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT12          0xff8 
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT16 
.................... // Description: The LAST_CLUSTER_FAT16 macro is used when reading the FAT to indicate that the next FAT16 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT16          0xfff8 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT12 
.................... // Description: The END_CLUSTER_FAT12 value is used as a comparison in FAT12 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT12           0xFF7 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT16 
.................... // Description: The END_CLUSTER_FAT16 value is used as a comparison in FAT16 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT16           0xFFF7 
....................  
.................... // Summary: A macro to indicate the failure of the ReadFAT function 
.................... // Description: The CLUSTER_FAIL_FAT16 macro is used by the ReadFAT function to indicate that an error occured reading a FAT12 or FAT16 
.................... //              file allocation table.  Note that since '0xFFF8' is used for the last cluster return value in the FAT16 implementation 
.................... //              the end-of-file value '0xFFFF' can be used to indicate an error condition. 
.................... #define CLUSTER_FAIL_FAT16          0xFFFF 
....................  
....................  
....................  
.................... #ifdef SUPPORT_FAT32 
....................     // Summary: A macro to indicate the last cluster value for FAT32 
....................     // Description: The LAST_CLUSTER_FAT32 macro is used when reading the FAT to indicate that the next FAT32 entry for a file contains 
....................     //              the end-of-file value. 
....................     #define LAST_CLUSTER_FAT32      0x0FFFFFF8 
....................  
....................     // Summary: A macro to indicate the last allocatable cluster for FAT32 
....................     // Description: The END_CLUSTER_FAT32 value is used as a comparison in FAT32 to determine that the firmware has reached the end of 
....................     //              the range of allowed allocatable clusters. 
....................     #define END_CLUSTER_FAT32       0x0FFFFFF7 
....................  
....................     // Summary: A macro to indicate the failure of the ReadFAT function 
....................     // Description: The CLUSTER_FAIL_FAT32 macro is used by the ReadFAT function to indicate that an error occured reading a FAT32 
....................     //              file allocation able. 
....................     #define CLUSTER_FAIL_FAT32      0x0FFFFFFF 
....................  
.................... #endif 
....................  
.................... // Summary: A macro indicating the number of bytes in a directory entry. 
.................... // Description: The NUMBER_OF_BYTES_IN_DIR_ENTRY macro represents the number of bytes in one directory entry.  It is used to calculate 
.................... //              the number of sectors in the root directory based on information in the boot sector. 
.................... #define NUMBER_OF_BYTES_IN_DIR_ENTRY    32 
....................  
....................  
....................  
.................... // Summary: A macro for a deleted dir entry marker. 
.................... // Description: The DIR_DEL macro is used to mark a directory entry as deleted.  When a file is deleted, this value will replace the 
.................... //              first character in the file name, and will indicate that the file the entry points to was deleted. 
.................... #define DIR_DEL             0xE5 
....................  
.................... // Summary: A macro for the last dir entry marker. 
.................... // Description: The DIR_EMPTY macro is used to indicate the last entry in a directory.  Since entries in use cannot start with a 0 and 
.................... //              deleted entries start with the DIR_DEL character, a 0 will mark the end of the in-use or previously used group of 
.................... //              entries in a directory 
.................... #define DIR_EMPTY           0 
....................  
....................  
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name 
.................... // Description: The DIR_NAMESIZE macro is used when validing the name portion of 8.3 filenames 
.................... #define DIR_NAMESIZE        8 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file extension 
.................... // Description: The DIR_EXTENSION macro is used when validating the extension portion of 8.3 filenames 
.................... #define DIR_EXTENSION       3 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name and extension 
.................... // Description: The DIR_NAMECOMP macro is used when validating 8.3 filenames 
.................... #define DIR_NAMECOMP        (DIR_NAMESIZE+DIR_EXTENSION) 
....................  
....................  
....................  
.................... // Summary: A macro to write a byte to RAM 
.................... // Description: The RAMwrite macro is used to write a byte of data to a RAM array 
.................... #define RAMwrite( a, f, d) *(a+f) = d 
....................  
.................... // Summary: A macro to read a byte from RAM 
.................... // Description: The RAMread macro is used to read a byte of data from a RAM array 
.................... #define RAMread( a, f)  *(a+f) 
....................  
.................... // Summary: A macro to read a 16-bit word from RAM 
.................... // Description: The RAMreadW macro is used to read two bytes of data from a RAM array 
.................... #define RAMreadW( a, f) *(WORD *)(a+f) 
....................  
.................... // Summary: A macro to read a 32-bit word from RAM 
.................... // Description: The RAMreadD macro is used to read four bytes of data from a RAM array 
.................... #define RAMreadD( a, f) *(DWORD *)(a+f) 
....................  
....................  
....................  
.................... #ifndef EOF 
....................     // Summary: Indicates error conditions or end-of-file conditions 
....................     // Description: The EOF macro is used to indicate error conditions in some function calls.  It is also used to indicate 
....................     //              that the end-of-file has been reached. 
....................     #define EOF             ((int)-1) 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing information about the device. 
.................... // Description: The DISK structure contains information about the device being accessed. 
.................... typedef struct 
.................... {  
....................     BYTE    *   buffer;         // Address of the global data buffer used to read and write file information 
....................     DWORD       firsts;         // Logical block address of the first sector of the FAT partition on the device 
....................     DWORD       fat;            // Logical block address of the FAT 
....................     DWORD       root;           // Logical block address of the root directory 
....................     DWORD       data;           // Logical block address of the data section of the device. 
....................     WORD        maxroot;        // The maximum number of entries in the root directory. 
....................     DWORD       maxcls;         // The maximum number of clusters in the partition. 
....................     DWORD       sectorSize;     // The size of a sector in bytes 
....................     DWORD       fatsize;        // The number of sectors in the FAT 
....................     BYTE        fatcopy;        // The number of copies of the FAT in the partition 
....................     BYTE        SecPerClus;     // The number of sectors per cluster in the data region 
....................     BYTE        type;           // The file system type of the partition (FAT12, FAT16 or FAT32) 
....................     BYTE        mount;          // Device mount flag (TRUE if disk was mounted successfully, FALSE otherwise) 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... } __attribute__ ((packed)) DISK; 
.................... #else 
.................... } DISK; 
.................... #endif 
....................  
....................  
.................... #if defined(__18CXX) && !defined(__CCS__) 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef unsigned short long SWORD; 
.................... #else 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef struct 
....................     { 
....................         unsigned char array[3]; 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) SWORD; 
.................... #else 
....................     } SWORD; 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT12 file system (in the boot sector) 
.................... // Description: The _BPB_FAT12 structure provides a layout of the "bios parameter block" in the boot sector of a FAT12 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BPS;               // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD BootSec_ResrvSec;          // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD BootSec_RootDirEnts;       // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD BootSec_SPF;               // Number of sectors per FAT 
....................     WORD BootSec_SPT;               // Number of sectors per track 
....................     WORD BootSec_HeadCnt;           // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD  BootSec_Reserved;        // Reserved space 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved2;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination    
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT12; 
.................... #else 
....................     } _BPB_FAT12; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT16 file system (in the boot sector) 
.................... // Description: The _BPB_FAT16 structure provides a layout of the "bios parameter block" in the boot sector of a FAT16 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD  BootSec_BPS;              // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD  BootSec_ResrvSec;         // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD  BootSec_RootDirEnts;      // Number of root directory entries 
....................     WORD  BootSec_TotSec16;         // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD  BootSec_SPF;              // Number of sectors per FAT 
....................     WORD  BootSec_SPT;              // Number of sectors per track 
....................     WORD  BootSec_HeadCnt;          // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved;         // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination      
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT16; 
.................... #else 
....................     } _BPB_FAT16; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT32 file system (in the boot sector) 
.................... // Description: The _BPB_FAT32 structure provides a layout of the "bios parameter block" in the boot sector of a FAT32 partition. 
.................... typedef struct { 
....................     SWORD BootSec_jmpBoot;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BytsPerSec;        // Number of bytes per sector 
....................     BYTE  BootSec_SecPerClus;       // Number of sectors per cluster 
....................     WORD BootSec_RsvdSecCnt;        // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_NumFATs;          // Number of FATs on the partition 
....................     WORD BootSec_RootEntCnt;        // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_Media;            // Media descriptor 
....................     WORD BootSec_FATSz16;           // Number of sectors per FAT 
....................     WORD BootSec_SecPerTrk;         // Number of sectors per track 
....................     WORD BootSec_NumHeads;          // Number of heads 
....................     DWORD BootSec_HiddSec;          // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     DWORD BootSec_FATSz32;          // Sectors per FAT (32 bits) 
....................     WORD BootSec_ExtFlags;          // Presently active FAT. Defined by bits 0-3 if bit 7 is 1. 
....................     WORD BootSec_FSVers;            // FAT32 filesystem version.  Should be 0:0 
....................     DWORD BootSec_RootClus;         // Start cluster of the root directory (should be 2) 
....................     WORD BootSec_FSInfo;            // File system information 
....................     WORD BootSec_BkBootSec;         // Backup boot sector address. 
....................     BYTE  BootSec_Reserved[12];     // Reserved space 
....................     BYTE  BootSec_DrvNum;           // Drive number 
....................     BYTE  BootSec_Reserved1;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLab[11];       // Volume Label 
....................     BYTE  BootSec_FilSysType[8];    // File system type in ASCII.  Not used for determination   
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT32; 
.................... #else 
....................     } _BPB_FAT32; 
.................... #endif 
....................  
....................  
.................... // Description: A macro for the boot sector bytes per sector value offset 
.................... #define BSI_BPS            11 
....................  
.................... // Description: A macro for the boot sector sector per cluster value offset 
.................... #define BSI_SPC            13 
....................  
.................... // Description: A macro for the boot sector reserved sector count value offset 
.................... #define BSI_RESRVSEC       14 
....................  
.................... // Description: A macro for the boot sector FAT count value offset 
.................... #define BSI_FATCOUNT       16 
....................  
.................... // Description: A macro for the boot sector root directory entry count value offset 
.................... #define BSI_ROOTDIRENTS    17 
....................  
.................... // Description: A macro for the boot sector 16-bit total sector count value offset 
.................... #define BSI_TOTSEC16       19 
....................  
.................... // Description: A macro for the boot sector sectors per FAT value offset 
.................... #define BSI_SPF            22 
....................  
.................... // Description: A macro for the boot sector 32-bit total sector count value offset 
.................... #define BSI_TOTSEC32       32 
....................  
.................... // Description: A macro for the boot sector boot signature offset 
.................... #define BSI_BOOTSIG        38 
....................  
.................... // Description: A macro for the boot sector file system type string offset 
.................... #define BSI_FSTYPE         54 
....................  
.................... // Description: A macro for the boot sector 32-bit sector per FAT value offset 
.................... #define  BSI_FATSZ32       36 
....................  
.................... // Description: A macro for the boot sector start cluster of root directory value offset 
.................... #define  BSI_ROOTCLUS      44 
....................  
.................... // Description: A macro for the FAT32 boot sector boot signature offset 
.................... #define  BSI_FAT32_BOOTSIG 66 
....................  
.................... // Description: A macro for the FAT32 boot sector file system type string offset 
.................... #define  BSI_FAT32_FSTYPE  82 
....................  
....................  
....................  
.................... // Summary: A partition table entry structure. 
.................... // Description: The PTE_MBR structure contains values found in a partition table entry in the MBR of a device. 
.................... typedef struct 
.................... { 
....................     BYTE      PTE_BootDes;            // The boot descriptor (should be 0x00 in a non-bootable device) 
....................     SWORD     PTE_FrstPartSect;       // The cylinder-head-sector address of the first sector of the partition 
....................     BYTE      PTE_FSDesc;             // The file system descriptor 
....................     SWORD     PTE_LstPartSect;        // The cylinder-head-sector address of the last sector of the partition 
....................     DWORD     PTE_FrstSect;           // The logical block address of the first sector of the partition 
....................     DWORD     PTE_NumSect;            // The number of sectors in a partition 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) PTE_MBR; 
.................... #else 
....................     } PTE_MBR; 
.................... #endif 
....................  
....................  
.................... // Summary: A structure of the organization of a master boot record. 
.................... // Description: The _PT_MBR structure has the same form as a master boot record.  When the MBR is loaded from the device, it will 
.................... //              be cast as a _PT_MBR structure so the MBR elements can be accessed. 
.................... typedef struct 
.................... { 
....................     BYTE        ConsChkRtn[446];        // Boot code 
....................     PTE_MBR     Partition0;             // The first partition table entry 
....................     PTE_MBR     Partition1;             // The second partition table entry 
....................     PTE_MBR     Partition2;             // The third partition table entry 
....................     PTE_MBR     Partition3;             // The fourth partition table entry 
....................     BYTE        Signature0;             // MBR signature code - equal to 0x55 
....................     BYTE        Signature1;             // MBR signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... }__attribute__((packed)) _PT_MBR; 
.................... #else 
.................... }_PT_MBR; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _PT_MBR structure 
.................... // Description: The PT_MBR pointer points to a _PT_MBR structure. 
.................... typedef _PT_MBR *  PT_MBR; 
....................  
....................  
....................  
.................... // Summary: A structure of the organization of a boot sector. 
.................... // Description: The _BootSec structure has the same form as a boot sector.  When the boot sector is loaded from the device, it will 
.................... //              be cast as a _BootSec structure so the boot sector elements can be accessed. 
.................... typedef struct 
.................... { 
....................     // A union of different bios parameter blocks 
....................     union 
....................     { 
....................         _BPB_FAT32  FAT_32; 
....................         _BPB_FAT16  FAT_16; 
....................         _BPB_FAT12  FAT_12; 
....................     }FAT; 
....................     BYTE    Reserved[512-sizeof(_BPB_FAT32)-2]; // Reserved space 
....................     BYTE    Signature0;         // Boot sector signature code - equal to 0x55 
....................     BYTE    Signature1;         // Boot sector signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BootSec; 
.................... #else 
....................     } _BootSec; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _BootSec structure 
.................... // Description: The BootSec pointer points to a _BootSec structure. 
.................... typedef _BootSec * BootSec; 
....................  
....................  
....................  
.................... // Summary: A macro indicating the offset for the master boot record 
.................... // Description: FO_MBR is a macro that indicates the addresss of the master boot record on the device.  When the device is initialized 
.................... //              this sector will be read 
.................... #define FO_MBR          0L 
....................  
....................  
....................  
.................... // Summary: A macro for the first boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_0 macro is used to determine that the first byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_0     0x55 
....................  
.................... // Summary: A macro for the second boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_1 macro is used to determine that the second byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_1     0xAA 
....................  
....................  
.................... typedef struct  
.................... { 
....................     BYTE    errorCode; 
....................     union  
....................     { 
....................         BYTE    value; 
....................         struct  
....................         { 
....................             BYTE    sectorSize  : 1; 
....................             BYTE    maxLUN      : 1; 
....................         }   bits; 
....................     } validityFlags; 
....................      
....................     WORD    sectorSize; 
....................     BYTE    maxLUN; 
.................... } MEDIA_INFORMATION; 
....................  
.................... typedef enum 
.................... { 
....................     MEDIA_NO_ERROR,                     // No errors 
....................     MEDIA_DEVICE_NOT_PRESENT,           // The requested device is not present 
....................     MEDIA_CANNOT_INITIALIZE             // Cannot initialize media 
.................... } MEDIA_ERRORS;                 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #ifdef __18CXX 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 4x prescale divider 
....................     #define   SYNC_MODE_FAST    0x00 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 16x prescale divider 
....................     #define   SYNC_MODE_MED     0x01 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 64x prescale divider 
....................     #define   SYNC_MODE_SLOW    0x02 
.................... #elif defined __PIC32MX__ 
....................     // Description: This macro is used to initialize a PIC32 SPI module 
....................     #define   SYNC_MODE_FAST    0x3E 
....................     // Description: This macro is used to initialize a PIC32 SPI module 
....................     #define   SYNC_MODE_SLOW    0x3C 
.................... #else 
....................     // Description: This macro indicates the SPI enable bit for 16-bit PICs 
....................     #ifndef MASTER_ENABLE_ON 
....................         #define  MASTER_ENABLE_ON       0x0020 
....................     #endif 
....................  
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module 
....................     #ifndef SYNC_MODE_FAST 
....................         #define   SYNC_MODE_FAST    0x3E 
....................     #endif 
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module 
....................     #ifndef SYNC_MODE_SLOW 
....................         #define   SYNC_MODE_SLOW    0x3C 
....................     #endif 
....................  
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module secondary prescaler 
....................     #ifndef SEC_PRESCAL_1_1 
....................         #define  SEC_PRESCAL_1_1        0x001c 
....................     #endif 
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module primary prescaler 
....................     #ifndef PRI_PRESCAL_1_1 
....................         #define  PRI_PRESCAL_1_1        0x0003 
....................     #endif 
.................... #endif 
....................  
....................  
....................  
.................... /*****************************************************************/ 
.................... /*                  Strcutures and defines                       */ 
.................... /*****************************************************************/ 
....................  
....................  
.................... // Description: This macro represents an SD card start single data block token (used for single block writes) 
.................... #define DATA_START_TOKEN            0xFE 
....................  
.................... // Description: This macro represents an SD card start multi-block data token (used for multi-block writes) 
.................... #define DATA_START_MULTI_BLOCK_TOKEN    0xFC 
....................  
.................... // Description: This macro represents an SD card stop transmission token.  This is used when finishing a multi block write sequence. 
.................... #define DATA_STOP_TRAN_TOKEN        0xFD 
....................  
.................... // Description: This macro represents an SD card data accepted token 
.................... #define DATA_ACCEPTED               0x05 
....................  
.................... // Description: This macro indicates that the SD card expects to transmit or receive more data 
.................... #define MOREDATA    !0 
....................  
.................... // Description: This macro indicates that the SD card does not expect to transmit or receive more data 
.................... #define NODATA      0 
....................  
.................... // Description: This macro represents a floating SPI bus condition 
.................... #define MMC_FLOATING_BUS    0xFF 
....................  
.................... // Description: This macro represents a bad SD card response byte 
.................... #define MMC_BAD_RESPONSE    MMC_FLOATING_BUS 
....................  
.................... // The SDMMC Commands 
....................  
.................... // Description: This macro defines the command code to reset the SD card 
.................... #define     cmdGO_IDLE_STATE        0 
.................... // Description: This macro defines the command code to initialize the SD card 
.................... #define     cmdSEND_OP_COND         1         
.................... // Description: This macro defined the command code to check for sector addressing 
.................... #define     cmdSEND_IF_COND         8 
.................... // Description: This macro defines the command code to get the Card Specific Data 
.................... #define     cmdSEND_CSD             9 
.................... // Description: This macro defines the command code to get the Card Information 
.................... #define     cmdSEND_CID             10 
.................... // Description: This macro defines the command code to stop transmission during a multi-block read 
.................... #define     cmdSTOP_TRANSMISSION    12 
.................... // Description: This macro defines the command code to get the card status information 
.................... #define     cmdSEND_STATUS          13 
.................... // Description: This macro defines the command code to set the block length of the card 
.................... #define     cmdSET_BLOCKLEN         16 
.................... // Description: This macro defines the command code to read one block from the card 
.................... #define     cmdREAD_SINGLE_BLOCK    17 
.................... // Description: This macro defines the command code to read multiple blocks from the card 
.................... #define     cmdREAD_MULTI_BLOCK     18 
.................... // Description: This macro defines the command code to tell the media how many blocks to pre-erase (for faster multi-block writes to follow) 
.................... //Note: This is an "application specific" command.  This tells the media how many blocks to pre-erase for the subsequent WRITE_MULTI_BLOCK 
.................... #define     cmdSET_WR_BLK_ERASE_COUNT   23 
.................... // Description: This macro defines the command code to write one block to the card 
.................... #define     cmdWRITE_SINGLE_BLOCK   24     
.................... // Description: This macro defines the command code to write multiple blocks to the card 
.................... #define     cmdWRITE_MULTI_BLOCK    25 
.................... // Description: This macro defines the command code to set the address of the start of an erase operation 
.................... #define     cmdTAG_SECTOR_START     32 
.................... // Description: This macro defines the command code to set the address of the end of an erase operation 
.................... #define     cmdTAG_SECTOR_END       33 
.................... // Description: This macro defines the command code to erase all previously selected blocks 
.................... #define     cmdERASE                38 
.................... //Description: This macro defines the command code to intitialize an SD card and provide the CSD register value. 
.................... //Note: this is an "application specific" command (specific to SD cards) and must be preceded by cmdAPP_CMD. 
.................... #define     cmdSD_SEND_OP_COND      41 
.................... // Description: This macro defines the command code to begin application specific command inputs 
.................... #define     cmdAPP_CMD              55 
.................... // Description: This macro defines the command code to get the OCR register information from the card 
.................... #define     cmdREAD_OCR             58 
.................... // Description: This macro defines the command code to disable CRC checking 
.................... #define     cmdCRC_ON_OFF           59 
....................  
....................  
.................... // Description: Enumeration of different SD response types 
.................... typedef enum 
.................... { 
....................     R1,     // R1 type response 
....................     R1b,    // R1b type response 
....................     R2,     // R2 type response 
....................     R3,     // R3 type response  
....................     R7      // R7 type response  
.................... }RESP; 
....................  
.................... // Summary: SD card command data structure 
.................... // Description: The typMMC_CMD structure is used to create a command table of information needed for each relevant SD command 
.................... typedef struct 
.................... { 
....................     BYTE      CmdCode;          // The command code 
....................     BYTE      CRC;              // The CRC value for that command 
....................     RESP    responsetype;       // The response type 
....................     BYTE    moredataexpected;   // Set to MOREDATA or NODATA, depending on whether more data is expected or not 
.................... } typMMC_CMD; 
....................  
....................  
.................... // Summary: An SD command packet 
.................... // Description: This union represents different ways to access an SD card command packet 
.................... typedef union 
.................... { 
....................     // This structure allows array-style access of command bytes 
....................     struct 
....................     { 
....................         #ifdef __18CXX 
....................             BYTE field[6];      // BYTE array 
....................         #else 
....................             BYTE field[7]; 
....................         #endif 
....................     }; 
....................     // This structure allows byte-wise access of packet command bytes 
....................     struct 
....................     { 
....................         BYTE crc;               // The CRC byte 
....................         #if defined __C30__ 
....................             BYTE c30filler;     // Filler space (since bitwise declarations can't cross a WORD boundary) 
....................         #elif defined __C32__ 
....................             BYTE c32filler[3];  // Filler space (since bitwise declarations can't cross a DWORD boundary) 
....................         #endif 
....................          
....................         BYTE addr0;             // Address byte 0 
....................         BYTE addr1;             // Address byte 1 
....................         BYTE addr2;             // Address byte 2 
....................         BYTE addr3;             // Address byte 3 
....................         BYTE cmd;               // Command code byte 
....................     }; 
....................     // This structure allows bitwise access to elements of the command bytes 
....................     struct 
....................     { 
....................         BYTE  END_BIT:1;        // Packet end bit 
....................         BYTE  CRC7:7;           // CRC value 
....................         DWORD     address;      // Address 
....................         BYTE  CMD_INDEX:6;      // Command code 
....................         BYTE  TRANSMIT_BIT:1;   // Transmit bit 
....................         BYTE  START_BIT:1;      // Packet start bit 
....................     }; 
.................... } CMD_PACKET; 
....................  
....................  
.................... // Summary: The format of an R1 type response 
.................... // Description: This union represents different ways to access an SD card R1 type response packet. 
.................... typedef union 
.................... { 
....................     BYTE _byte;                         // Byte-wise access 
....................     // This structure allows bitwise access of the response 
....................     struct 
....................     { 
....................         unsigned IN_IDLE_STATE:1;       // Card is in idle state 
....................         unsigned ERASE_RESET:1;         // Erase reset flag 
....................         unsigned ILLEGAL_CMD:1;         // Illegal command flag 
....................         unsigned CRC_ERR:1;             // CRC error flag 
....................         unsigned ERASE_SEQ_ERR:1;       // Erase sequence error flag 
....................         unsigned ADDRESS_ERR:1;         // Address error flag 
....................         unsigned PARAM_ERR:1;           // Parameter flag    
....................         unsigned B7:1;                  // Unused bit 7 
....................     }; 
.................... } RESPONSE_1; 
....................  
.................... // Summary: The format of an R2 type response 
.................... // Description: This union represents different ways to access an SD card R2 type response packet 
.................... typedef union 
.................... { 
....................     WORD _word; 
....................     struct 
....................     { 
....................         BYTE      _byte0; 
....................         BYTE      _byte1; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned IN_IDLE_STATE:1; 
....................         unsigned ERASE_RESET:1; 
....................         unsigned ILLEGAL_CMD:1; 
....................         unsigned CRC_ERR:1; 
....................         unsigned ERASE_SEQ_ERR:1; 
....................         unsigned ADDRESS_ERR:1; 
....................         unsigned PARAM_ERR:1; 
....................         unsigned B7:1; 
....................         unsigned CARD_IS_LOCKED:1; 
....................         unsigned WP_ERASE_SKIP_LK_FAIL:1; 
....................         unsigned ERROR:1; 
....................         unsigned CC_ERROR:1; 
....................         unsigned CARD_ECC_FAIL:1; 
....................         unsigned WP_VIOLATION:1; 
....................         unsigned ERASE_PARAM:1; 
....................         unsigned OUTRANGE_CSD_OVERWRITE:1; 
....................     }; 
.................... } RESPONSE_2; 
....................  
.................... // Summary: The format of an R7 or R3 type response 
.................... // Description: This union represents different ways to access an SD card R7 type response packet. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         BYTE _byte;                         // Byte-wise access 
....................         union 
....................         { 
....................             //Note: The SD card argument response field is 32-bit, big endian format. 
....................             //However, the C compiler stores 32-bit values in little endian in RAM. 
....................             //When writing to the _returnVal/argument bytes, make sure to byte 
....................             //swap the order from which it arrived over the SPI from the SD card. 
....................             DWORD _returnVal; 
....................             struct 
....................             { 
....................                 BYTE _byte0; 
....................                 BYTE _byte1; 
....................                 BYTE _byte2; 
....................                 BYTE _byte3; 
....................             };     
....................         }argument;     
....................     } bytewise; 
....................     // This structure allows bitwise access of the response 
....................     struct 
....................     { 
....................         struct 
....................         { 
....................             unsigned IN_IDLE_STATE:1;       // Card is in idle state 
....................             unsigned ERASE_RESET:1;         // Erase reset flag 
....................             unsigned ILLEGAL_CMD:1;         // Illegal command flag 
....................             unsigned CRC_ERR:1;             // CRC error flag 
....................             unsigned ERASE_SEQ_ERR:1;       // Erase sequence error flag 
....................             unsigned ADDRESS_ERR:1;         // Address error flag 
....................             unsigned PARAM_ERR:1;           // Parameter flag    
....................             unsigned B7:1;                  // Unused bit 7 
....................         }bits; 
....................         DWORD _returnVal; 
....................     } bitwise; 
.................... } RESPONSE_7; 
....................  
.................... // Summary: A union of responses from an SD card 
.................... // Description: The MMC_RESPONSE union represents any of the possible responses that an SD card can return after 
.................... //              being issued a command. 
.................... typedef union 
.................... { 
....................     RESPONSE_1  r1;   
....................     RESPONSE_2  r2; 
....................     RESPONSE_7  r7; 
.................... }MMC_RESPONSE; 
....................  
....................  
.................... // Summary: A description of the card specific data register 
.................... // Description: This union represents different ways to access information in a packet with SD card CSD informaiton.  For more 
.................... //              information on the CSD register, consult an SD card user's manual. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         DWORD _u320; 
....................         DWORD _u321; 
....................         DWORD _u322; 
....................         DWORD _u323; 
....................     }; 
....................     struct 
....................     { 
....................         BYTE _byte[16]; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned NOT_USED           :1; 
....................         unsigned CRC                :7; 
....................         unsigned ECC                :2; 
....................         unsigned FILE_FORMAT        :2; 
....................         unsigned TMP_WRITE_PROTECT  :1; 
....................         unsigned PERM_WRITE_PROTECT :1; 
....................         unsigned COPY               :1; 
....................         unsigned FILE_FORMAT_GRP    :1; 
....................         unsigned RESERVED_1         :5; 
....................         unsigned WRITE_BL_PARTIAL   :1; 
....................         unsigned WRITE_BL_LEN_L     :2; 
....................         unsigned WRITE_BL_LEN_H     :2; 
....................         unsigned R2W_FACTOR         :3; 
....................         unsigned DEFAULT_ECC        :2; 
....................         unsigned WP_GRP_ENABLE      :1; 
....................         unsigned WP_GRP_SIZE        :5; 
....................         unsigned ERASE_GRP_SIZE_L   :3; 
....................         unsigned ERASE_GRP_SIZE_H   :2; 
....................         unsigned SECTOR_SIZE        :5; 
....................         unsigned C_SIZE_MULT_L      :1; 
....................         unsigned C_SIZE_MULT_H      :2; 
....................         unsigned VDD_W_CURR_MAX     :3; 
....................         unsigned VDD_W_CUR_MIN      :3; 
....................         unsigned VDD_R_CURR_MAX     :3; 
....................         unsigned VDD_R_CURR_MIN     :3; 
....................         unsigned C_SIZE_L           :2; 
....................         unsigned C_SIZE_H           :8; 
....................         unsigned C_SIZE_U           :2; 
....................         unsigned RESERVED_2         :2; 
....................         unsigned DSR_IMP            :1; 
....................         unsigned READ_BLK_MISALIGN  :1; 
....................         unsigned WRITE_BLK_MISALIGN :1; 
....................         unsigned READ_BL_PARTIAL    :1; 
....................         unsigned READ_BL_LEN        :4; 
....................         unsigned CCC_L              :4; 
....................         unsigned CCC_H              :8; 
....................         unsigned TRAN_SPEED         :8; 
....................         unsigned NSAC               :8; 
....................         unsigned TAAC               :8; 
....................         unsigned RESERVED_3         :2; 
....................         unsigned SPEC_VERS          :4; 
....................         unsigned CSD_STRUCTURE      :2; 
....................     }; 
.................... } CSD; 
....................  
....................  
.................... // Summary: A description of the card information register 
.................... // Description: This union represents different ways to access information in a packet with SD card CID register informaiton.  For more 
.................... //              information on the CID register, consult an SD card user's manual. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         DWORD _u320; 
....................         DWORD _u321; 
....................         DWORD _u322; 
....................         DWORD _u323; 
....................     }; 
....................     struct 
....................     { 
....................         BYTE _byte[16]; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned    NOT_USED            :1; 
....................         unsigned    CRC                 :7; 
....................         unsigned    MDT                 :8; 
....................         DWORD       PSN; 
....................         unsigned    PRV                 :8; 
....................         char        PNM[6]; 
....................         WORD        OID; 
....................         unsigned    MID                 :8; 
....................     }; 
.................... } CID; 
....................  
.................... #ifndef FALSE 
....................     #define FALSE   0 
.................... #endif 
.................... #ifndef TRUE 
....................     #define TRUE    !FALSE 
.................... #endif 
....................  
.................... #define INPUT   1 
.................... #define OUTPUT  0 
....................  
....................  
.................... // Description: A delay prescaler 
.................... #define DELAY_PRESCALER   (BYTE)      8 
....................  
.................... // Description: An approximation of the number of cycles per delay loop of overhead 
.................... #define DELAY_OVERHEAD    (BYTE)      5 
....................  
.................... // Description: An approximate calculation of how many times to loop to delay 1 ms in the Delayms function 
.................... #define MILLISECDELAY   (WORD)      ((GetInstructionClock()/DELAY_PRESCALER/(WORD)1000) - DELAY_OVERHEAD) 
....................  
....................  
.................... // Desription: Media Response Delay Timeouts  
.................... #define NCR_TIMEOUT     (WORD)20        //Byte times before command response is expected (must be at least 8) 
.................... #define NAC_TIMEOUT     (DWORD)0x40000  //SPI byte times we should wait when performing read operations (should be at least 100ms for SD cards) 
.................... #define WRITE_TIMEOUT   (DWORD)0xA0000  //SPI byte times to wait before timing out when the media is performing a write operation (should be at least 250ms for SD cards). 
....................  
.................... // Summary: An enumeration of SD commands 
.................... // Description: This enumeration corresponds to the position of each command in the sdmmc_cmdtable array 
.................... //              These macros indicate to the SendMMCCmd function which element of the sdmmc_cmdtable array 
.................... //              to retrieve command code information from. 
.................... typedef enum 
.................... { 
....................     GO_IDLE_STATE, 
....................     SEND_OP_COND, 
....................     SEND_IF_COND, 
....................     SEND_CSD, 
....................     SEND_CID, 
....................     STOP_TRANSMISSION, 
....................     SEND_STATUS, 
....................     SET_BLOCKLEN, 
....................     READ_SINGLE_BLOCK, 
....................     READ_MULTI_BLOCK, 
....................     WRITE_SINGLE_BLOCK, 
....................     WRITE_MULTI_BLOCK, 
....................     TAG_SECTOR_START, 
....................     TAG_SECTOR_END, 
....................     ERASE, 
....................     APP_CMD, 
....................     READ_OCR, 
....................     CRC_ON_OFF, 
....................     SD_SEND_OP_COND, 
....................     SET_WR_BLK_ERASE_COUNT 
.................... }sdmmc_cmd; 
....................  
....................  
.................... #define SD_MODE_NORMAL  0 
.................... #define SD_MODE_HC      1 
....................  
....................  
.................... //Definition for a structure used when calling either MDD_SDSPI_AsyncReadTasks()  
.................... //function, or the MDD_SDSPI_AsyncWriteTasks() function. 
.................... typedef struct 
.................... { 
....................     WORD wNumBytes;         //Number of bytes to attempt to read or write in the next call to MDD_SDSPI_AsyncReadTasks() or MDD_SDSPI_AsyncWriteTasks.  May be updated between calls to the handler. 
....................     DWORD dwBytesRemaining; //Should be initialized to the total number of bytes that you wish to read or write.  This value is allowed to be greater than a single block size of the media. 
....................     BYTE* pBuffer;          //Pointer to where the read/written bytes should be copied to/from.  May be updated between calls to the handler function. 
....................     DWORD dwAddress;        //Starting block address to read or to write to on the media.  Should only get initialized, do not modify after that. 
....................     BYTE bStateVariable;    //State machine variable.  Should get initialized to ASYNC_READ_QUEUED or ASYNC_WRITE_QUEUED to start an operation.  After that, do not modify until the read or write is complete. 
.................... }ASYNC_IO;    
....................  
....................  
.................... //Response codes for the MDD_SDSPI_AsyncReadTasks() function. 
.................... #define ASYNC_READ_COMPLETE             0x00 
.................... #define ASYNC_READ_BUSY                 0x01 
.................... #define ASYNC_READ_NEW_PACKET_READY     0x02 
.................... #define ASYNC_READ_ERROR                0xFF 
....................  
.................... //MDD_SDSPI_AsyncReadTasks() state machine variable values.  These are used internally to SD-SPI.c. 
.................... #define ASYNC_READ_COMPLETE             0x00 
.................... #define ASYNC_READ_QUEUED               0x01    //Initialize to this to start a read sequence 
.................... #define ASYNC_READ_WAIT_START_TOKEN     0x03 
.................... #define ASYNC_READ_NEW_PACKET_READY     0x02 
.................... #define ASYNC_READ_ABORT                0xFE 
.................... #define ASYNC_READ_ERROR                0xFF 
....................  
.................... //Possible return values when calling MDD_SDSPI_AsyncWriteTasks() 
.................... #define ASYNC_WRITE_COMPLETE        0x00 
.................... #define ASYNC_WRITE_SEND_PACKET     0x02 
.................... #define ASYNC_WRITE_BUSY            0x03 
.................... #define ASYNC_WRITE_ERROR           0xFF 
....................  
.................... //MDD_SDSPI_AsyncWriteTasks() state machine variable values.  These are used internally to SD-SPI.c. 
.................... #define ASYNC_WRITE_COMPLETE            0x00 
.................... #define ASYNC_WRITE_QUEUED              0x01    //Initialize to this to start a write sequence 
.................... #define ASYNC_WRITE_TRANSMIT_PACKET     0x02 
.................... #define ASYNC_WRITE_MEDIA_BUSY          0x03 
.................... #define ASYNC_STOP_TOKEN_SENT_WAIT_BUSY 0x04 
.................... #define ASYNC_WRITE_ABORT               0xFE 
.................... #define ASYNC_WRITE_ERROR               0xFF 
....................  
....................  
.................... //Constants 
.................... #define MEDIA_BLOCK_SIZE            512u  //Should always be 512 for v1 and v2 devices. 
.................... #define WRITE_RESPONSE_TOKEN_MASK   0x1F  //Bit mask to AND with the write token response byte from the media, to clear the don't care bits. 
....................  
....................  
....................  
.................... /***************************************************************************/ 
.................... /*                               Macros                                    */ 
.................... /***************************************************************************/ 
....................  
.................... // Description: A macro to send clock cycles to dummy-read the CRC 
.................... #define mReadCRC()              WriteSPIM(0xFF);WriteSPIM(0xFF); 
....................  
.................... // Description: A macro to send clock cycles to dummy-write the CRC 
.................... #define mSendCRC()              WriteSPIM(0xFF);WriteSPIM(0xFF); 
....................  
.................... // Description: A macro to send 8 clock cycles for SD timing requirements 
.................... #define mSend8ClkCycles()       WriteSPIM(0xFF); 
....................  
.................... /*****************************************************************************/ 
.................... /*                                 Public Prototypes                         */ 
.................... /*****************************************************************************/ 
....................  
.................... //These are the public API functions provided by SD-SPI.c 
.................... BYTE MDD_SDSPI_MediaDetect(void); 
.................... MEDIA_INFORMATION * MDD_SDSPI_MediaInitialize(void); 
.................... DWORD MDD_SDSPI_ReadCapacity(void); 
.................... WORD MDD_SDSPI_ReadSectorSize(void); 
.................... void MDD_SDSPI_InitIO(void); 
.................... BYTE MDD_SDSPI_SectorRead(DWORD sector_addr, BYTE* buffer); 
.................... BYTE MDD_SDSPI_SectorWrite(DWORD sector_addr, BYTE* buffer, BYTE allowWriteToZero); 
.................... BYTE MDD_SDSPI_AsyncReadTasks(ASYNC_IO*); 
.................... BYTE MDD_SDSPI_AsyncWriteTasks(ASYNC_IO*); 
.................... BYTE MDD_SDSPI_WriteProtectState(void); 
.................... BYTE MDD_SDSPI_ShutdownMedia(void); 
....................  
....................  
.................... #if defined __C30__ || defined __C32__ 
....................     extern BYTE ReadByte( BYTE* pBuffer, WORD index ); 
....................     extern WORD ReadWord( BYTE* pBuffer, WORD index ); 
....................     extern DWORD ReadDWord( BYTE* pBuffer, WORD index ); 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #endif 
.................... #ifdef USE_CF_INTERFACE_WITH_PMP 
....................     #include    "CF-PMP.h" 
.................... #endif 
.................... #ifdef USE_MANUAL_CF_INTERFACE 
....................     #include    "CF- Bit transaction.h" 
.................... #endif 
.................... #ifdef USE_USB_INTERFACE 
....................     #include    "usb_host_msd_scsi.h" 
.................... #endif 
.................... #ifdef USE_INTERNAL_FLASH 
....................     #include    "Internal Flash.h" 
.................... #endif 
....................  
....................  
.................... /*******************************************************************/ 
.................... /*                     Strunctures and defines                     */ 
.................... /*******************************************************************/ 
....................  
.................... #ifndef FALSE 
....................     // Summary: False value 
....................     // Description:  This macro will indicate that a condition is false. 
....................     #define FALSE   0 
.................... #endif 
.................... #ifndef TRUE 
....................     // Summary: True value 
....................     // Description: This macro will indicate that a condition is true. 
....................     #define TRUE    !FALSE  // True value 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #ifndef SEEK_SET 
....................     // Summary: Macro for the FSfseek SEEK_SET base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed  
....................     //              relative to the beginning of the file. 
....................     #define SEEK_SET 0 
....................  
.................... #endif 
.................... #ifndef SEEK_CUR 
....................  
....................     // Summary: Macro for the FSfseek SEEK_CUR base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the current location of the file 
....................     #define SEEK_CUR 1 
....................  
.................... #endif 
.................... #ifndef SEEK_END 
....................  
....................     // Summary: Macro for the FSfseek SEEK_END base location 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the end of the file.  For this macro, the offset value will be subtracted from 
....................     //              the end location of the file by default. 
....................     #define SEEK_END 2 
....................  
.................... #endif 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file. 
.................... #define FS_APPEND   "a" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file. 
.................... #define FS_WRITE    "w" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file. 
.................... #define FS_READ "r" 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file 
.................... //              or read from the file. 
.................... #define FS_APPENDPLUS   "a+" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file or read from the file. 
.................... #define FS_WRITEPLUS    "w+" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file or write to the file. 
.................... #define FS_READPLUS     "r+" 
....................  
.................... #ifndef intmax_t 
....................     #ifdef __PIC24F__ 
....................         // Summary: A data type indicating the maximum integer size in an architecture 
....................         // Description: The intmax_t data type refers to the maximum-sized data type on any given architecture.  This 
....................         //              data type can be specified as a format specifier size specification for the FSfprintf function. 
....................         #define intmax_t long long 
....................     #elif defined __PIC24H__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC30F__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC33F__ 
....................         #define intmax_t long long 
....................     #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary:  Indicates flag conditions for a file object 
.................... // Description: The FILEFLAGS structure is used to indicate conditions in a file.  It contains three flags: 'write' indicates 
.................... //              that the file was opened in a mode that allows writes, 'read' indicates that the file was opened in a mode 
.................... //              that allows reads, and 'FileWriteEOF' indicates that additional data that is written to the file will increase 
.................... //              the file size. 
.................... typedef struct 
.................... { 
....................     unsigned    write :1;           // Indicates a file was opened in a mode that allows writes 
....................     unsigned    read :1;            // Indicates a file was opened in a mode that allows reads 
....................     unsigned    FileWriteEOF :1;    // Indicates the current position in a file is at the end of the file 
.................... }FILEFLAGS; 
....................  
....................  
....................  
.................... // Summary: Indicates how to search for file entries in the FILEfind function 
.................... // Description: The values in the SEARCH_TYPE enumeration are used internally by the library to indicate how the FILEfind function 
.................... //              how to perform a search.  The 'LOOK_FOR_EMPTY_ENTRY' value indicates that FILEfind should search for an empty file entry. 
.................... //              The 'LOOK_FOR_MATCHING_ENTRY' value indicates that FILEfind should search for an entry that matches the FSFILE object 
.................... //              that was passed into the FILEfind function. 
.................... typedef enum{ 
....................     LOOK_FOR_EMPTY_ENTRY = 0, 
....................     LOOK_FOR_MATCHING_ENTRY 
.................... } SEARCH_TYPE; 
....................  
....................  
....................  
.................... // Summary: Macro indicating the length of a 8.3 file name 
.................... // Description: The TOTAL_FILE_SIZE_8P3 macro indicates the maximum number of characters in an 8.3 file name.  This value includes 
.................... //              8 characters for the name, three for the extentsion, and 1 for the radix ('.') 
.................... #define TOTAL_FILE_SIZE_8P3             (8+3+1) 
.................... #define TOTAL_FILE_SIZE                 TOTAL_FILE_SIZE_8P3 
....................  
.................... // Summary: Macro indicating the max length of a LFN file name 
.................... // Description: The MAX_FILE_NAME_LENGTH_LFN macro indicates the maximum number of characters in an LFN file name. 
.................... #define MAX_FILE_NAME_LENGTH_LFN             256 
....................  
.................... // Summary: A mask that indicates the limit of directory entries in a sector 
.................... // Description: The MASK_MAX_FILE_ENTRY_LIMIT_BITS is used to indicate to the Cache_File_Entry function that a new sector needs to 
.................... //              be loaded. 
.................... #define MASK_MAX_FILE_ENTRY_LIMIT_BITS          0x0f 
....................  
.................... // Summary: Value used for shift operations to calculate the sector offset in a directory 
.................... // Description: The VALUE_BASED_ON_ENTRIES_PER_CLUSTER macro is used to calculate sector offsets for directories.  The position of the 
.................... //              entry is shifted by 4 bits (divided by 16, since there are 16 entries in a sector) to calculate how many sectors a 
.................... //              specified entry is offset from the beginning of the directory. 
.................... #define VALUE_BASED_ON_ENTRIES_PER_CLUSTER      4 
....................  
.................... // Summary: A value that will indicate that a dotdot directory entry points to the root. 
.................... // Description: The VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT macro is used as an absolute address when writing information to a dotdot entry 
.................... //              in a newly created directory.  If a dotdot entry points to the root directory, it's cluster value must be set to 0, 
.................... //              regardless of the actual cluster number of the root directory. 
.................... #define VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT     0 
....................  
.................... // Summary: MAcro indicating the length of an 8.3 file name in a directory entry 
.................... // Description: The FILE_NAME_SIZE_8P3 macro indicates the number of characters that an 8.3 file name will take up when packed in 
.................... //              a directory entry.  This value includes 8 characters for the name and 3 for the extension.  Note that the radix is not 
.................... //              stored in the directory entry. 
.................... #define FILE_NAME_SIZE_8P3           11 
.................... #define FILE_NAME_SIZE               FILE_NAME_SIZE_8P3 
....................  
....................  
.................... // Summary: Contains file information and is used to indicate which file to access. 
.................... // Description: The FSFILE structure is used to hold file information for an open file as it's being modified or accessed.  A pointer to  
.................... //              an open file's FSFILE structure will be passeed to any library function that will modify that file. 
.................... typedef struct 
.................... { 
....................     DISK    *       dsk;            // Pointer to a DISK structure 
....................     DWORD           cluster;        // The first cluster of the file 
....................     DWORD           ccls;           // The current cluster of the file 
....................     WORD            sec;            // The current sector in the current cluster of the file 
....................     WORD            pos;            // The position in the current sector 
....................     DWORD           seek;           // The absolute position in the file 
....................     DWORD           size;           // The size of the file 
....................     FILEFLAGS       flags;          // A structure containing file flags 
....................     WORD            time;           // The file's last update time 
....................     WORD            date;           // The file's last update date 
....................     char            name[FILE_NAME_SIZE_8P3];       // The short name of the file 
....................    #ifdef SUPPORT_LFN 
....................        BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNptr;           // Pointer to long file name in UTF16 format 
....................       unsigned short int utf16LFNlength;          // LFN length in terms of words excluding the NULL word at the last. 
....................    #endif 
....................     WORD            entry;          // The position of the file's directory entry in it's directory 
....................     WORD            chk;            // File structure checksum 
....................     WORD            attributes;     // The file attributes 
....................     DWORD           dirclus;        // The base cluster of the file's directory 
....................     DWORD           dirccls;        // The current cluster of the file's directory 
.................... } FSFILE; 
....................  
.................... /* Summary: Possible results of the FSGetDiskProperties() function. 
.................... ** Description: See the FSGetDiskProperties() function for more information. 
.................... */ 
.................... typedef enum 
.................... { 
....................     FS_GET_PROPERTIES_NO_ERRORS = 0, 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED, 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE, 
....................     FS_GET_PROPERTIES_STILL_WORKING = 0xFF 
.................... } FS_DISK_ERRORS; 
....................  
....................  
.................... /* Summary: Contains the disk search information, intermediate values, and results 
.................... ** Description: This structure is used in conjunction with the FSGetDiskProperties() 
.................... **              function.  See that function for more information about the usage. 
.................... */ 
.................... typedef struct 
.................... { 
....................     DISK *  disk;           /* pointer to the disk we are searching */ 
....................     BOOL    new_request;    /* is this a new request or a continued request */ 
....................     FS_DISK_ERRORS properties_status;  /* status of the last call of the function */ 
....................  
....................     struct 
....................     { 
....................         BYTE disk_format;           /* disk format: FAT12, FAT16, FAT32 */ 
....................         WORD sector_size;           /* sector size of the drive */ 
....................         BYTE sectors_per_cluster;   /* number of sectors per cluster */ 
....................         DWORD total_clusters;       /* the number of total clusters on the drive */ 
....................         DWORD free_clusters;        /* the number of free (unused) clusters on drive */ 
....................     } results;                      /* the results of the current search */ 
....................  
....................     struct 
....................     { 
....................         DWORD   c;      
....................         DWORD   curcls; 
....................         DWORD   EndClusterLimit; 
....................         DWORD   ClusterFailValue; 
....................     } private;      /* intermediate values used to continue searches.  This 
....................                          member should be used only by the FSGetDiskProperties() 
....................                          function */ 
....................  
.................... } FS_DISK_PROPERTIES; 
....................  
.................... // Summary: A structure used for searching for files on a device. 
.................... // Description: The SearchRec structure is used when searching for file on a device.  It contains parameters that will be loaded with 
.................... //              file information when a file is found.  It also contains the parameters that the user searched for, allowing further 
.................... //              searches to be perfomed in the same directory for additional files that meet the specified criteria. 
.................... typedef struct 
.................... { 
....................     char            filename[FILE_NAME_SIZE_8P3 + 2];   // The name of the file that has been found 
....................     unsigned char   attributes;                     // The attributes of the file that has been found 
....................     unsigned long   filesize;                       // The size of the file that has been found 
....................     unsigned long   timestamp;                      // The last modified time of the file that has been found (create time for directories) 
....................    #ifdef SUPPORT_LFN 
....................       BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNfound;          // Pointer to long file name found in UTF16 format 
....................       unsigned short int utf16LFNfoundLength;     // LFN Found length in terms of words including the NULL word at the last. 
....................    #endif 
....................     unsigned int    entry;                          // The directory entry of the last file found that matches the specified attributes. (Internal use only) 
....................     char            searchname[FILE_NAME_SIZE_8P3 + 2]; // The 8.3 format name specified when the user began the search. (Internal use only) 
....................     unsigned char   searchattr;                     // The attributes specified when the user began the search. (Internal use only) 
....................     unsigned long   cwdclus;                        // The directory that this search was performed in. (Internal use only) 
....................     unsigned char   initialized;                    // Check to determine if the structure was initialized by FindFirst (Internal use only) 
.................... } SearchRec; 
....................  
....................  
.................... /*************************************************************************** 
.................... * Prototypes                                                               * 
.................... ***************************************************************************/ 
....................  
....................  
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     int FSInit(void) 
....................   Summary: 
....................     Function to initialize the device. 
....................   Conditions: 
....................     The physical device should be connected to the microcontroller. 
....................   Input: 
....................     None 
....................   Return Values: 
....................     TRUE -  Initialization successful 
....................     FALSE - Initialization unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function initializes the file system stack & the interfacing device. 
....................     Initializes the static or dynamic memory slots for holding file 
....................     structures. Initializes the device with the DISKmount function. Loads  
....................     MBR and boot sector information. Initializes the current working 
....................     directory to the root directory for the device if directory support 
....................     is enabled. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... int FSInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * FSfopen (const char * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with ascii input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will open a ascii name file or directory on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * FSfopen(const char * fileName, const char *mode); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * wFSfopen (const unsigned short int * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * wFSfopen(const unsigned short int * fileName, const char *mode); 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................  
.................... /****************************************************************************** 
....................   Function: 
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode) 
....................   Summary: 
....................     Opens a file on PIC18 Microcontrollers where 'fileName' ROM string is given 
....................     in Ascii format. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to be opened (ROM) 
....................     mode -      The mode the file will be opened in (ROM) 
....................   Return Values: 
....................     FSFILE * - A pointer to the file object 
....................     NULL -     File could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file on PIC18 Microcontrollers where 'fileName' ROM string 
....................     is given in Ascii format.The FSfopenpgm function will copy a PIC18 ROM fileName and 
....................     mode argument into RAM arrays, and then pass those arrays to the FSfopen function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   ******************************************************************************/ 
....................  
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode); 
....................  
....................  
.................... /************************************************************************************** 
....................   Function: 
....................     int FindFirstpgm (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Find a file named with a ROM string on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName -  The name of the file to be found (ROM) 
....................     attr -      The attributes of the file to be found 
....................     rec -       Pointer to a search record to store the file info in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the given parameters was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirstpgm call on passed SearchRec object 
....................     will be lost.The FSerrno variable will be changed. 
....................   Description: 
....................     This function finds a file named with 'fileName' on PIC18. The FindFirstpgm 
....................     function will copy a PIC18 ROM fileName argument into a RAM array, and then 
....................     pass that array to the FindFirst function. 
....................   Remarks: 
....................     Call FindFirstpgm or FindFirst before calling FindNext. 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************************/ 
....................  
....................     int FindFirstpgm (const rom char * fileName, unsigned int attr, SearchRec * rec); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdirpgm (const rom char * path) 
....................   Summary: 
....................     Changes the CWD to the input path on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to (ROM) 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the CWD to the input path on PIC18.The FSchdirpgm function 
....................     passes a PIC18 ROM path pointer to the chdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM 
....................   **************************************************************************/ 
....................  
....................     int FSchdirpgm (const rom char * path); 
....................  
....................     #ifdef ALLOW_WRITES 
....................  
....................  
.................... /************************************************************* 
....................   Function: 
....................     int FSremovepgm (const rom char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC18 device 
....................   Conditions: 
....................     File not opened; file exists 
....................   Input: 
....................     fileName -  The name of the file to be deleted (ROM) 
....................   Return Values: 
....................     0 -  File was removed successfully 
....................     -1 - File could not be removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC18 device.The FSremovepgm function will copy a 
....................     PIC18 ROM fileName argument into a RAM array, and then pass that array 
....................     to the FSremove function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   *************************************************************/ 
....................  
....................         int FSremovepgm (const rom char * fileName); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdirpgm (const rom char * path) 
....................   Summary: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create (ROM) 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices.'FSmkdirpgm' creates the directories as per the input 
....................     string path.This function doesn't move the current working 
....................     directory setting. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arugments in ROM 
....................   **************************************************************************/ 
....................  
....................         int FSmkdirpgm (const rom char * path); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdirpgm (const rom char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     path -      The path of the directory to remove (ROM) 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................     This function deletes the directory as specified in the path. 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************/ 
....................  
....................         int FSrmdirpgm (const rom char * path, unsigned char rmsubdirs); 
....................  
....................  
.................... /***************************************************************** 
....................   Function: 
....................     int FSrenamepgm(const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the file with the ascii ROM string(PIC18) 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file (in ROM) 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -  File renamed successfully 
....................     -1 - File could not be renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the file with the ascii ROM string(PIC18).The Fsrenamepgm 
....................     function will copy the rom fileName specified by the user into a  
....................     RAM array and pass that array into the FSrename function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM.                        
....................   *****************************************************************/ 
....................  
....................         int FSrenamepgm (const rom char * fileName, FSFILE * fo); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************ 
....................   Function: 
....................     int FSfclose(FSFILE *fo) 
....................   Summary: 
....................     Update file information and free FSFILE objects 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to the file to close 
....................   Return Values: 
....................     0 -   File closed successfully  
....................     EOF - Error closing the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will update the directory entry for the  
....................     file pointed to by 'fo' with the information contained 
....................     in 'fo,' including the new file size and attributes. 
....................     Timestamp information will also be loaded based on the 
....................     method selected by the user and written to the entry 
....................     as the last modified time and date.  The file entry will 
....................     then be written to the device.  Finally, the memory 
....................     used for the specified file object will be freed from 
....................     the dynamic heap or the array of FSFILE objects. 
....................   Remarks: 
....................     A function to flush data to the device without closing the 
....................     file can be created by removing the portion of this 
....................     function that frees the memory and the line that clears 
....................     the write flag. 
....................   ************************************************************/ 
....................  
.................... int FSfclose(FSFILE *fo); 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     void FSrewind (FSFILE * fo) 
....................   Summary: 
....................     Set the current position in a file to the beginning 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The FSrewind funciton will reset the position of the 
....................     specified file to the beginning of the file.  This 
....................     functionality is faster than using FSfseek to reset 
....................     the position in the file. 
....................   Remarks: 
....................     None. 
....................   *********************************************************/ 
....................  
.................... void FSrewind (FSFILE *fo); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Read data from a file 
....................   Conditions: 
....................     File is opened in a read mode 
....................   Input: 
....................     ptr -     Destination buffer for read bytes 
....................     size -    Size of units in bytes 
....................     n -       Number of units to be read 
....................     stream -  File to be read from 
....................   Return: 
....................     size_t - number of units read 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfread function will read data from the specified file.  First, 
....................     the appropriate sector of the file is loaded.  Then, data is read into 
....................     the specified buffer until the specified number of bytes have been read. 
....................     When a cluster boundary is reached, a new cluster will be loaded.  The 
....................     parameters 'size' and 'n' indicate how much data to read.  'Size' 
....................     refers to the size of one object to read (in bytes), and 'n' will refer  
....................     to the number of these objects to read.  The value returned will be equal  
....................     to 'n' unless an error occured or the user tried to read beyond the end 
....................     of the file. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream); 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FSfseek(FSFILE *stream, long offset, int whence) 
....................   Summary: 
....................     Change the current position in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     stream -    Pointer to file structure 
....................     offset -    Offset from base location 
....................     whence -     
....................            - SEEK_SET -  Seek from start of file 
....................            - SEEK_CUR -  Seek from current location 
....................            - SEEK_END -  Seek from end of file (subtract offset) 
....................   Return Values: 
....................     0 -  Operation successful  
....................     -1 - Operation unsuccesful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfseek function will change the current position in the file to 
....................     one specified by the user.  First, an absolute offset is calculated 
....................     using the offset and base location passed in by the user.  Then, the 
....................     position variables are updated, and the sector number that corresponds 
....................     to the new location.  That sector is then loaded.  If the offset 
....................     falls exactly on a cluster boundary, a new cluster will be allocated 
....................     to the file and the position will be set to the first byte of that 
....................     cluster. 
....................   Remarks: 
....................     None                                                                
....................   **********************************************************************/ 
....................  
.................... int FSfseek(FSFILE *stream, long offset, int whence); 
....................  
....................  
.................... /******************************************************************* 
....................   Function: 
....................     long FSftell (FSFILE * fo) 
....................   Summary: 
....................     Determine the current location in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return: Current location in the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     The FSftell function will return the current position in the 
....................     file pointed to by 'fo' by returning the 'seek' variable in the 
....................     FSFILE object, which is used to keep track of the absolute 
....................     location of the current position in the file. 
....................   Remarks: 
....................     None                                                             
....................   *******************************************************************/ 
....................  
.................... long FSftell(FSFILE *fo); 
....................  
....................  
.................... /**************************************************** 
....................   Function: 
....................     int FSfeof( FSFILE * stream ) 
....................   Summary: 
....................     Indicate whether the current file position is at the end 
....................   Conditions: 
....................     File is open in a read mode 
....................   Input: 
....................     stream -  Pointer to the target file 
....................   Return Values: 
....................     Non-Zero - EOF reached  
....................     0 - Not at end of File 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfeof function will indicate that the end-of- 
....................     file has been reached for the specified file by 
....................     comparing the absolute location in the file to the 
....................     size of the file. 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... int FSfeof( FSFILE * stream ); 
....................  
....................  
.................... #ifdef ALLOW_FORMATS 
.................... /******************************************************************* 
....................   Function: 
....................     int FSformat (char mode, long int serialNumber, char * volumeID) 
....................   Summary: 
....................     Formats a device 
....................   Conditions: 
....................     The device must possess a valid master boot record. 
....................   Input: 
....................     mode -          - 0 - Just erase the FAT and root 
....................                     - 1 - Create a new boot sector 
....................     serialNumber -  Serial number to write to the card 
....................     volumeID -      Name of the card 
....................   Return Values: 
....................     0 -    Format was successful 
....................     EOF -  Format was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSformat function can be used to create a new boot sector 
....................     on a device, based on the information in the master boot record. 
....................     This function will first initialize the I/O pins and the device, 
....................     and then attempts to read the master boot record.  If the MBR 
....................     cannot be loaded successfully, the function will fail.  Next, if 
....................     the 'mode' argument is specified as '0' the existing boot sector 
....................     information will be loaded.  If the 'mode' argument is '1' an 
....................     entirely new boot sector will be constructed using the disk 
....................     values from the master boot record.  Once the boot sector has 
....................     been successfully loaded/created, the locations of the FAT and 
....................     root will be loaded from it, and they will be completely 
....................     erased.  If the user has specified a volumeID parameter, a  
....................     VOLUME attribute entry will be created in the root directory 
....................     to name the device. 
....................  
....................     FAT12, FAT16 and FAT32 formatting are supported. 
....................  
....................     Based on the number of sectors, the format function automatically 
....................     compute the smallest possible value for the cluster size in order to 
....................     accommodate the physical size of the media. In this case, if a media  
....................     with a big capacity is formatted, the format function may take a very 
....................     long time to write all the FAT tables.  
....................  
....................     Therefore, the FORMAT_SECTORS_PER_CLUSTER macro may be used to  
....................     specify the exact cluster size (in multiples of sector size). This  
....................     macro can be defined in FSconfig.h 
....................  
....................   Remarks: 
....................     Only devices with a sector size of 512 bytes are supported by the  
....................     format function                       
....................   *******************************************************************/ 
....................  
.................... int FSformat (char mode, long int serialNumber, char * volumeID); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_WRITES 
.................... /*************************************************************************** 
....................   Function: 
....................     int FSattrib (FSFILE * file, unsigned char attributes) 
....................   Summary: 
....................     Change the attributes of a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     file -        Pointer to file structure 
....................     attributes -  The attributes to set for the file 
....................                -  Attribute -      Value - Indications  
....................                -  ATTR_READ_ONLY - 0x01  - The read-only attribute 
....................                -  ATTR_HIDDEN -    0x02  - The hidden attribute  
....................                -  ATTR_SYSTEM -    0x04  - The system attribute  
....................                -  ATTR_ARCHIVE -   0x20  - The archive attribute 
....................   Return Values: 
....................     0 -  Attribute change was successful  
....................     -1 - Attribute change was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSattrib funciton will set the attributes of the specified file 
....................     to the attributes passed in by the user.  This function will load the 
....................     file entry, replace the attributes with the ones specified, and write 
....................     the attributes back.  If the specified file is a directory, the 
....................     directory attribute will be preserved. 
....................   Remarks: 
....................     None                                                                 
....................   ***************************************************************************/ 
....................  
.................... int FSattrib (FSFILE * file, unsigned char attributes); 
....................  
....................  
.................... /*************************************************************** 
....................   Function: 
....................     int FSrename (const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices. 
....................     First, it will search through the current working directory to ensure the 
....................     specified new filename is not already in use. If it isn't, the new filename 
....................     will be written to the file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None                                                         
....................   ***************************************************************/ 
....................  
.................... int FSrename (const char * fileName, FSFILE * fo); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*************************************************************** 
....................   Function: 
....................     int wFSrename (const rom unsigned short int * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices. First, it will search through the current 
....................     working directory to ensure the specified new UTF16 filename is not 
....................     already in use.  If it isn't, the new filename will be written to the 
....................     file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None 
....................   ***************************************************************/ 
....................  
.................... int wFSrename (const unsigned short int * fileName, FSFILE * fo); 
.................... #endif 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     int FSremove (const char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed  
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................     The FSremove function will attempt to find the specified file with the FILEfind 
....................     function.  If the file is found, it will be erased using the FILEerase function. 
....................     The user can also provide ascii alias name of the ascii long file name as the 
....................     input to this function to get it erased from the memory. 
....................   Remarks: 
....................     None                                        
....................   **********************************************************************/ 
....................  
.................... int FSremove (const char * fileName); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     int wFSremove (const unsigned short int * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed 
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................     The wFSremove function will attempt to find the specified UTF16 file 
....................     name with the FILEfind function. If the file is found, it will be erased 
....................     using the FILEerase function. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int wFSremove (const unsigned short int * fileName); 
.................... #endif 
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Write data to a file 
....................   Conditions: 
....................     File opened in FS_WRITE, FS_APPEND, FS_WRITE+, FS_APPEND+, FS_READ+ mode 
....................   Input: 
....................     data_to_write -     Pointer to source buffer 
....................     size -              Size of units in bytes 
....................     n -                 Number of units to transfer 
....................     stream -            Pointer to file structure 
....................   Return: 
....................     size_t - number of units written 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfwrite function will write data to a file.  First, the sector that 
....................     corresponds to the current position in the file will be loaded (if it hasn't 
....................     already been cached in the global data buffer).  Data will then be written to 
....................     the device from the specified buffer until the specified amount has been written. 
....................     If the end of a cluster is reached, the next cluster will be loaded, unless 
....................     the end-of-file flag for the specified file has been set.  If it has, a new 
....................     cluster will be allocated to the file.  Finally, the new position and filesize 
....................     will be stored in the FSFILE object.  The parameters 'size' and 'n' indicate how  
....................     much data to write.  'Size' refers to the size of one object to write (in bytes),  
....................     and 'n' will refer to the number of these objects to write.  The value returned  
....................     will be equal  to 'n' unless an error occured. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************************/ 
....................  
.................... size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream); 
....................  
.................... #endif 
....................  
.................... #ifdef ALLOW_DIRS 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdir (char * path) 
....................   Summary: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC). 
....................     The FSchdir function passes a RAM pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSchdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSchdir (unsigned short int * path) 
....................   Summary: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC).The FSchdir function passes a RAM 
....................     pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSchdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************** 
....................   Function: 
....................     char * FSgetcwd (char * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in Ascii format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in Ascii format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * FSgetcwd (char * path, int numbchars); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************** 
....................   Function: 
....................     char * wFSgetcwd (unsigned short int * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in UTF16 format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in UTF16 format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * wFSgetcwd (unsigned short int * path, int numbchars); 
.................... #endif 
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdir (char * path) 
....................   Summary: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSmkdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSmkdir (unsigned short int * path) 
....................   Summary: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSmkdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdir (char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int FSrmdir (char * path, unsigned char rmsubdirs); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs) 
....................   Summary: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs); 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................  
....................  
.................... /*********************************************************************************************************** 
....................   Function: 
....................     int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second) 
....................   Summary: 
....................     Manually set timestamp variables 
....................   Conditions: 
....................     USERDEFINEDCLOCK macro defined in FSconfig.h. 
....................   Input: 
....................     year -     The year (1980\-2107) 
....................     month -   The month (1\-12) 
....................     day -     The day of the month (1\-31) 
....................     hour -    The hour (0\-23) 
....................     minute -  The minute (0\-59) 
....................     second -  The second (0\-59) 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     Modifies global timing variables 
....................   Description: 
....................     Lets the user manually set the timing variables.  The values passed in will be converted to the format 
....................     used by the FAT timestamps. 
....................   Remarks: 
....................     Call this before creating a file or directory (set create time) and 
....................     before closing a file (set last access time, last modified time)                                         
....................   ***********************************************************************************************************/ 
....................  
.................... int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_FILESEARCH 
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................     The FindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*********************************************************************************** 
....................   Function: 
....................     int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous wFindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent wFindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................     The wFindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec); 
.................... #endif 
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FindNext (SearchRec * rec) 
....................   Summary: 
....................     Sequential search function 
....................   Conditions: 
....................     None 
....................   Input: 
....................     rec -  The structure to store the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No additional files matching the specified criteria were found 
....................   Side Effects: 
....................     Search criteria from previous FindNext call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     The FindNext function performs the same function as the FindFirst 
....................     funciton, except it does not copy any search parameters into the 
....................     SearchRec structure (only info about found files) and it begins 
....................     searching at the last directory entry offset at which a file was 
....................     found, rather than at the beginning of the current working 
....................     directory.If the return value of the function is 0 then "utf16LFNfoundLength" 
....................     indicates whether the file found was long file name or short file 
....................     name(8P3 format). The "utf16LFNfoundLength" is non-zero for long file name 
....................     and is zero for 8P3 format."utf16LFNfound" points to the address of long  
....................     file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling this function 
....................   **********************************************************************/ 
....................  
.................... int FindNext (SearchRec * rec);  
.................... #endif 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int FSfprintf (FSFILE * fptr, const char * fmt, ...) 
....................     // PIC18 
....................     int FSfpritnf (FSFILE * fptr, const rom char * fmt, ...) 
....................   Summary: 
....................     Function to write formatted strings to a file 
....................   Conditions: 
....................     For PIC18, integer promotion must be enabled in the project build 
....................     options menu.  File opened in a write mode. 
....................   Input: 
....................     fptr - A pointer to the file to write to. 
....................     fmt -  A string of characters and format specifiers to write to 
....................            the file 
....................     ... -  Additional arguments inserted in the string by format 
....................            specifiers 
....................   Returns: 
....................     The number of characters written to the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Writes a specially formatted string to a file. 
....................   Remarks: 
....................     Consult AN1045 for a full description of how to use format 
....................     specifiers.         
....................   **********************************************************************/ 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................     #ifdef __18CXX 
....................         int FSfprintf (FSFILE *fptr, const rom char *fmt, ...); 
....................     #else 
....................         int FSfprintf (FSFILE *fptr, const char * fmt, ...); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSerror (void) 
....................   Summary: 
....................     Return an error code for the last function call 
....................   Conditions: 
....................     The return value depends on the last function called. 
....................   Input: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Return Values: 
....................     FSInit       -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The physical media could not be initialized 
....................                  - CE_BAD_SECTOR_READ        The MBR or the boot sector could not be 
....................                                               read correctly 
....................                  - CE_BAD_PARITION           The MBR signature code was incorrect. 
....................                  - CE_NOT_FORMATTED          The boot sector signature code was incorrect or 
....................                                               indicates an invalid number of bytes per sector.  
....................                  - CE_CARDFAT32              The physical media is FAT32 type (only an error  
....................                                               when FAT32 support is disabled).  
....................                  - CE_UNSUPPORTED_FS         The device is formatted with an unsupported file  
....................                                               system (not FAT12 or 16). 
....................     FSfopen      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The device has not been initialized.  
....................                  - CE_TOO_MANY_FILES_OPEN    The function could not allocate any  
....................                                               additional file information to the array  
....................                                               of FSFILE structures or the heap.  
....................                  - CE_INVALID_FILENAME       The file name argument was invalid. 
....................                  - CE_INVALID_ARGUMENT       The user attempted to open a directory in a  
....................                                               write mode or specified an invalid mode argument.  
....................                  - CE_FILE_NOT_FOUND         The specified file (which was to be opened in read  
....................                                               mode) does not exist on the device.  
....................                  - CE_BADCACHEREAD           A read from the device failed. 
....................                  - CE_ERASE_FAIL             The existing file could not be erased (when opening  
....................                                               a file in FS_WRITE mode).  
....................                  - CE_DIR_FULL               The directory is full.  
....................                  - CE_DISK_FULL              The data memory section is full.  
....................                  - CE_WRITE_ERROR            A write to the device failed.  
....................                  - CE_SEEK_ERROR             The current position in the file could not be set to  
....................                                               the end (when the file was opened in FS_APPEND mode). 
....................     FSfclose     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer or the new file 
....................                                               entry information could not be written to the device. 
....................                  - CE_BADCACHEREAD           The file entry information could not be cached 
....................     FSfread      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITEONLY              The file was opened in a write-only mode. 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device.  
....................                  - CE_BAD_SECTOR_READ        The data sector could not be read.  
....................                  - CE_EOF                    The end of the file was reached. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be loaded. 
....................     FSfwrite     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_READONLY               The file was opened in a read-only mode.  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected. 
....................                  - CE_WRITE_ERROR            There was an error writing data to the device. 
....................                  - CE_BADCACHEREAD           The data sector to be modified could not be read from 
....................                                               the device.  
....................                  - CE_DISK_FULL              All data clusters on the device are in use. 
....................     FSfseek      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device.  
....................                  - CE_INVALID_ARGUMENT       The specified offset exceeds the size of the file.  
....................                  - CE_BADCACHEREAD           The sector that contains the new current position  
....................                                               could not be loaded. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be  
....................                                               loaded/allocated. 
....................     FSftell      -  
....................                  - CE_GOOD                   No Error 
....................     FSattrib     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The attribute argument was invalid.  
....................                  - CE_BADCACHEREAD           The existing file entry information could not be  
....................                                               loaded.  
....................                  - CE_WRITE_ERROR            The file entry information could not be written to  
....................                                               the device. 
....................     FSrename     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_FILENOTOPENED          A null file pointer was passed into the function.  
....................                  - CE_INVALID_FILENAME       The file name passed into the function was invalid.  
....................                  - CE_BADCACHEREAD           A read from the device failed.  
....................                  - CE_FILENAME_EXISTS        A file with the specified name already exists.  
....................                  - CE_WRITE_ERROR            The new file entry data could not be written to the  
....................                                               device. 
....................     FSfeof       - 
....................                  - CE_GOOD                   No Error 
....................     FSformat     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The device could not be initialized.  
....................                  - CE_BADCACHEREAD           The master boot record or boot sector could not be  
....................                                               loaded successfully.  
....................                  - CE_INVALID_ARGUMENT       The user selected to create their own boot sector on  
....................                                               a device that has no master boot record, or the mode  
....................                                               argument was invalid.  
....................                  - CE_WRITE_ERROR            The updated MBR/Boot sector could not be written to  
....................                                               the device. 
....................                  - CE_BAD_PARTITION          The calculated number of sectors per clusters was  
....................                                               invalid.  
....................                  - CE_NONSUPPORTED_SIZE      The card has too many sectors to be formatted as  
....................                                               FAT12 or FAT16. 
....................     FSremove     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         The specified file could not be found. 
....................                  - CE_ERASE_FAIL             The file could not be erased. 
....................     FSchdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed or the user tried to  
....................                                               change to a non-directory file. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_FOUND          Could not find a directory in the path. 
....................     FSgetcwd     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The user passed a 0-length buffer into the function. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the current working directory. 
....................     FSmkdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed. 
....................                  - CE_BADCACHEREAD           Could not successfully change to a recently created  
....................                                               directory to store its dir entry information, or  
....................                                               could not cache directory entry information.  
....................                  - CE_INVALID_FILENAME       One or more of the directory names has an invalid  
....................                                               format.  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device or the dot/dotdot entries could  
....................                                               not be written to a newly created directory. 
....................                  - CE_DIR_FULL               There are no available dir entries in the CWD. 
....................                  - CE_DISK_FULL              There are no available clusters in the data region of  
....................                                               the device.     
....................     FSrmdir      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_DIR_NOT_FOUND          The directory specified could not be found or the  
....................                                               function could not change to a subdirectory within  
....................                                               the directory to be deleted (when recursive delete is  
....................                                               enabled). 
....................                  - CE_INVALID_ARGUMENT       The user tried to remove the CWD or root directory.  
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_EMPTY          The directory to be deleted was not empty and  
....................                                               recursive subdirectory removal was disabled.  
....................                  - CE_ERASE_FAIL             The directory or one of the directories or files  
....................                                               within it could not be deleted.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the CWD. 
....................     SetClockVars - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The time values passed into the function were  
....................                                               invalid.     
....................     FindFirst    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found.  
....................                  - CE_BADCACHEREAD           The file information for the file that was found  
....................                                               could not be cached. 
....................     FindNext     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The SearchRec object was not initialized by a call to  
....................                                               FindFirst.  
....................                  - CE_INVALID_ARGUMENT       The SearchRec object was initialized in a different  
....................                                               directory from the CWD. 
....................                  - CE_INVALID_FILENAME       The filename is invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found. 
....................     FSfprintf    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            Characters could not be written to the file.                                                    
....................   Description: 
....................     The FSerror function will return the FSerrno variable.  This global 
....................     variable will have been set to an error value during the last call of a 
....................     library function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... int FSerror (void); 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     int FSCreateMBR (unsigned long firstSector, unsigned long numSectors) 
....................   Summary: 
....................     Creates a master boot record 
....................   Conditions: 
....................     The I/O pins for the device have been initialized by the InitIO function. 
....................   Input: 
....................     firstSector -  The first sector of the partition on the device (cannot 
....................                    be 0; that's the MBR) 
....................     numSectors -   The number of sectors available in memory (including the 
....................                    MBR) 
....................   Return Values: 
....................     0 -   MBR was created successfully 
....................     EOF - MBR could not be created 
....................   Side Effects: 
....................     None 
....................   Description:   
....................     This function can be used to create a master boot record for a device.  Note 
....................     that this function should not be used on a device that is already formatted 
....................     with a master boot record (i.e. most SD cards, CF cards, USB keys).  This 
....................     function will fill the global data buffer with appropriate partition information 
....................     for a FAT partition with a type determined by the number of sectors available 
....................     to the partition.  It will then write the MBR information to the first sector 
....................     on the device.  This function should be followed by a call to FSformat, which 
....................     will create a boot sector, root dir, and FAT appropriate the the information 
....................     contained in the new master boot record.  Note that FSformat only supports 
....................     FAT12 and FAT16 formatting at this time, and so cannot be used to format a 
....................     device with more than 0x3FFD5F sectors. 
....................   Remarks: 
....................     This function can damage the device being used, and should not be called 
....................     unless the user is sure about the size of the device and the first sector value. 
....................   *********************************************************************************/ 
....................  
.................... int FSCreateMBR (unsigned long firstSector, unsigned long numSectors); 
....................  
....................  
.................... #ifdef ALLOW_GET_DISK_PROPERTIES 
.................... /********************************************************************************* 
....................   Function: 
....................     void FSGetDiskProperties(FS_DISK_PROPERTIES* properties) 
....................   Summary: 
....................     Allows user to get the disk properties (size of disk, free space, etc) 
....................   Conditions: 
....................     1) ALLOW_GET_DISK_PROPERTIES must be defined in FSconfig.h 
....................     2) a FS_DISK_PROPERTIES object must be created before the function is called 
....................     3) the new_request member of the FS_DISK_PROPERTIES object must be set before 
....................         calling the function for the first time.  This will start a new search. 
....................     4) this function should not be called while there is a file open.  Close all 
....................         files before calling this function. 
....................   Input: 
....................     properties - a pointer to a FS_DISK_PROPERTIES object where the results should 
....................       be stored. 
....................   Return Values: 
....................     This function returns void.  The properties_status of the previous call of  
....................       this function is located in the properties.status field.  This field has  
....................       the following possible values: 
....................  
....................     FS_GET_PROPERTIES_NO_ERRORS - operation completed without error.  Results 
....................       are in the properties object passed into the function. 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED - there is no mounted disk.  Results in 
....................       properties object is not valid 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE - there was a failure trying to read a  
....................       cluster from the drive.  The results in the properties object is a partial 
....................       result up until the point of the failure. 
....................     FS_GET_PROPERTIES_STILL_WORKING - the search for free sectors is still in 
....................       process.  Continue calling this function with the same properties pointer  
....................       until either the function completes or until the partial results meets the 
....................       application needs.  The properties object contains the partial results of 
....................       the search and can be used by the application.   
....................   Side Effects: 
....................     Can cause errors if called when files are open.  Close all files before 
....................     calling this function. 
....................  
....................     Calling this function without setting the new_request member on the first 
....................     call can result in undefined behavior and results. 
....................  
....................     Calling this function after a result is returned other than 
....................     FS_GET_PROPERTIES_STILL_WORKING can result in undefined behavior and results. 
....................   Description:   
....................     This function returns the information about the mounted drive.  The results  
....................     member of the properties object passed into the function is populated with  
....................     the information about the drive.     
....................  
....................     Before starting a new request, the new_request member of the properties 
....................     input parameter should be set to TRUE.  This will initiate a new search 
....................     request. 
....................  
....................     This function will return before the search is complete with partial results. 
....................     All of the results except the free_clusters will be correct after the first 
....................     call.  The free_clusters will contain the number of free clusters found up 
....................     until that point, thus the free_clusters result will continue to grow until 
....................     the entire drive is searched.  If an application only needs to know that a  
....................     certain number of bytes is available and doesn't need to know the total free  
....................     size, then this function can be called until the required free size is 
....................     verified.  To continue a search, pass a pointer to the same FS_DISK_PROPERTIES 
....................     object that was passed in to create the search. 
....................  
....................     A new search request sould be made once this function has returned a value  
....................     other than FS_GET_PROPERTIES_STILL_WORKING.  Continuing a completed search 
....................     can result in undefined behavior or results. 
....................  
....................     Typical Usage: 
....................     <code> 
....................     FS_DISK_PROPERTIES disk_properties; 
....................  
....................     disk_properties.new_request = TRUE; 
....................  
....................     do 
....................     { 
....................         FSGetDiskProperties(&disk_properties); 
....................     } while (disk_properties.properties_status == FS_GET_PROPERTIES_STILL_WORKING); 
....................     </code> 
....................  
....................     results.disk_format - contains the format of the drive.  Valid results are  
....................       FAT12(1), FAT16(2), or FAT32(3). 
....................  
....................     results.sector_size - the sector size of the mounted drive.  Valid values are 
....................       512, 1024, 2048, and 4096. 
....................  
....................     results.sectors_per_cluster - the number sectors per cluster. 
....................  
....................     results.total_clusters - the number of total clusters on the drive.  This  
....................       can be used to calculate the total disk size (total_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................     results.free_clusters - the number of free (unallocated) clusters on the drive. 
....................       This can be used to calculate the total free disk size (free_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................   Remarks: 
....................     PIC24F size estimates: 
....................       Flash - 400 bytes (-Os setting) 
....................  
....................     PIC24F speed estimates: 
....................       Search takes approximately 7 seconds per Gigabyte of drive space.  Speed 
....................         will vary based on the number of sectors per cluster and the sector size. 
....................   *********************************************************************************/ 
.................... void FSGetDiskProperties(FS_DISK_PROPERTIES* properties); 
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE FILEget_next_cluster(FSFILE *fo, DWORD n) 
....................   Summary: 
....................     Step through a chain of clusters 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fo - The file to get the next cluster of 
....................     n -  Number of links in the FAT cluster chain to jump through 
....................   Return Values: 
....................     CE_GOOD - Operation successful 
....................     CE_BAD_SECTOR_READ - A bad read occured of a sector 
....................     CE_INVALID_CLUSTER - Invalid cluster value \> maxcls 
....................     CE_FAT_EOF - Fat attempt to read beyond EOF 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will load 'n' proximate clusters for a file from 
....................     the FAT on the device.  It will stop checking for clusters if the 
....................     ReadFAT function returns an error, if it reaches the last cluster in 
....................     a file, or if the device tries to read beyond the last cluster used 
....................     by the device. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... BYTE FILEget_next_cluster(FSFILE *fo, DWORD n); 
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
....................    #use fast_io(ALL) 
....................  
....................  //  #use delay(clock=32M) 
.................... #use delay( crystal=8mhz, clock=32mhz ) 
*
05A84:  CP0     W0
05A86:  BTSC.B  42.1
05A88:  BRA     5A92
05A8A:  REPEAT  #3E7B
05A8C:  NOP     
05A8E:  DEC     W0,W0
05A90:  BRA     NZ,5A8A
05A92:  RETURN  
....................  
....................    #pin_select U1TX = PIN_D5 
....................    #pin_select U1RX = PIN_D4 
....................     
....................    //hardwareprofile.h is using spi2 for sd card, so pin select those 
....................   // #pin_select SDI2 = PIN_F5 
....................   // #pin_select SDO2 = PIN_B15 
....................   // #pin_select SCK2OUT = PIN_F4 
....................  
....................    #pin_select SDI1 = PIN_F6 
....................    #pin_select SDO1 = PIN_F2 
....................    #pin_select SCK1OUT = PIN_F3 
....................  
....................  
....................  
.................... //   #pin_select SDI2 = PIN_F6 
.................... //   #pin_select SDO2 = PIN_F2 
.................... //   #pin_select SCK2OUT = PIN_F3 
....................  
....................    #define AN_HOST_VOLTAGE 2 
....................    #define AN_POT          0 
....................  
.................... //   #define MY_ANALOG_PORTS (sAN2 | sAN0) 
....................     
.................... //   #define MY_ADC_SETUP    (ADC_CLOCK_INTERNAL|ADC_TAD_MUL_2) 
....................     
....................    #use rs232(UART1, baud=9600, stream=STREAM_USER_UART) 
....................    #define PIN_SDPOWER  PIN_G9 
....................    #define PIN_LED1  PIN_B11 
....................    #define PIN_LED2  PIN_B10 
....................    #define PIN_LED3  PIN_B9 
....................  
....................    #define GREEN_LED    PIN_B11 
....................    #define YELLOW_LED   PIN_B10 
....................    #define RED_LED      PIN_B9 
....................     
....................    #define LED_ON(x)    output_high(x) 
....................    #define LED_OFF(x)   output_low(x) 
....................     
....................    #define BUTTON_PRESSED()   !input(PIN_F0) 
.................... #endif 
....................  
.................... #if defined(__DEBUG_UART) 
....................    // these are microchip's style debugs 
....................    #define InitUART() 
....................    #define PrintROMASCIIStringUART(s)  fprintf(STREAM_USER_UART, s) 
....................    void PrintRAMBytesUART(char *p, unsigned int16 n)  
....................    { 
....................       while(n--) 
....................       { 
....................          fprintf(STREAM_USER_UART, "%X ", *p++); 
....................       } 
....................    } 
....................    #define UARTSendLineFeedCarriageReturn() fprintf(STREAM_USER_UART, "\r\n") 
.................... #endif 
....................  
.................... #if 0 
....................    #warning CCS Debugs Enabled 
....................     
....................   #if defined(__PCH__)  //uart1 
....................    #bit UART_TBE=getenv("BIT:TX1IF") 
....................    //#define WAIT_FOR_TX()   while(!UART_TBE) 
....................    #define WAIT_FOR_TX() 
....................   #else  //uart2 
....................    #word U2STA=getenv("SFR:U2STA") 
....................    #bit U2STA_TRMT=U2STA.8 
....................    #define UART_TBE  U2STA_TRMT 
....................    #define WAIT_FOR_TX()   while(!UART_TBE) 
....................   #endif 
....................        
....................    // application level debugs 
....................    #define DEBUG_STR(str, x) printf("\r\n"); printf("%s", str); printf(" 0x%LX", x); WAIT_FOR_TX() 
....................    #define DEBUG_STR2(str1, str2) printf("\r\n%s '%s'", str1, str2); WAIT_FOR_TX() 
....................     
....................    // library level debugs 
....................    #define DEBUG_FS_STR(str, x) printf("\r\n"); printf("%s", str); printf(" 0x%LX", x); WAIT_FOR_TX() 
....................    #define DEBUG_FS_STR2(str1, str2) printf("\r\n%s '%s'", str1, str2); WAIT_FOR_TX() 
....................     
....................    void DEBUG_FS_ARRAY(unsigned int8 *p, unsigned int16 len) 
....................    { 
....................       unsigned int16 i=0; 
....................       while(i < len) 
....................       { 
....................          if ((i%32) == 0) 
....................             printf("\r\n0x%LX: ", i); 
....................          printf("%02X", *p++); 
....................          i++; 
....................       } 
....................    } 
.................... #endif 
....................  
.................... #if defined(DEBUG_STR) 
.................... #include <pcd_traps.c> 
.................... #endif 
....................  
.................... #ifndef HW_INIT 
.................... #define HW_INIT() 
.................... #endif 
....................  
.................... //#if defined(__PCD__) 
.................... #if 0 
....................    #define DEBUG_SPI()  printf("\r\n0x260=%LX 0x262=%LX 0x264=%LX\r\n", (unsigned int16*)*0x260, (unsigned int16*)*0x262, (unsigned int16*)*0x264); 
.................... #else 
....................    #define DEBUG_SPI() 
.................... #endif 
....................  
.................... // disable application level debug macros if not defined 
.................... #ifndef DEBUG_STR 
....................  #define DEBUG_STR(str, x) 
....................  #define DEBUG_STR2(str1, str2) 
.................... #endif 
....................  
.................... // disable library level debug macros if not defined 
.................... #ifndef DEBUG_FS_STR 
....................  #define DEBUG_FS_STR(str, x) 
....................  #define DEBUG_FS_STR2(str1, str2) 
....................  #define DEBUG_FS_ARRAY(p, len) 
.................... #endif 
....................  
.................... #if defined(__USE_MDD_BOOTLOADER__) 
.................... #include "ex_mdd_boot.h" 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "filesystem\filesystem.c" 
.................... //see about.txt in filesystem/ for information 
....................  
.................... #ifndef __FILESYSTEM_C__ 
.................... #define __FILESYSTEM_C__ 
....................  
.................... #include "FSConfig.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSconfig.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Dependencies:    None 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _FS_DEF_ 
.................... #define _FS_DEF_ 
....................  
.................... //#include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // something to do with long filenames. 
.................... //#define SUPPORT_LFN 
....................  
.................... // Summary: A macro indicating the maximum number of concurrently open files 
.................... // Description: The FS_MAX_FILES_OPEN #define is only applicable when dynamic memory allocation is not used (FS_DYNAMIC_MEM is not defined). 
.................... //              This macro defines the maximum number of open files at any given time.  The amount of RAM used by FSFILE objects will 
.................... //              be equal to the size of an FSFILE object multipled by this macro value.  This value should be kept as small as possible 
.................... //              as dictated by the application.  This will reduce memory usage. 
.................... #define FS_MAX_FILES_OPEN    1 
....................  
....................  
.................... // if defined, MDD will be configured to use SST25 flash device. this definition 
.................... // should also define the size of the SST25 flash device. 
.................... // if not defined, will use SD card. 
.................... // #define  USE_SST25_INTERFACE  ((unsigned int32)2*1024*1024) 
....................  
.................... // Summary: A macro defining the size of a sector 
.................... // Description: The MEDIA_SECTOR_SIZE macro will define the size of a sector on the FAT file system.  This value must equal 512 bytes, 
.................... //              1024 bytes, 2048 bytes, or 4096 bytes.  The value of a sector will usually be 512 bytes. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define MEDIA_SECTOR_SIZE       4096   //erase size of SST25 flash device 
.................... #else 
.................... #define MEDIA_SECTOR_SIZE       512 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* *******************************************************************************************************/ 
.................... /************** Compiler options to enable/Disable Features based on user's application ******************/ 
.................... /* *******************************************************************************************************/ 
....................  
....................  
.................... // Summary: A macro to enable/disable file search functions. 
.................... // Description: The ALLOW_FILESEARCH definition can be commented out to disable file search functions in the library.  This will 
.................... //              prevent the use of the FindFirst and FindNext functions and reduce code size. 
.................... #define ALLOW_FILESEARCH 
....................  
.................... // Summary: A macro to enable/disable write functionality 
.................... // Description: The ALLOW_WRITES definition can be commented out to disable all operations that write to the device.  This will 
.................... //              greatly reduce code size. 
.................... #define ALLOW_WRITES 
....................  
....................  
.................... // Summary: A macro to enable/disable format functionality 
.................... // Description: The ALLOW_FORMATS definition can be commented out to disable formatting functionality.  This will prevent the use of 
.................... //              the FSformat function.  If formats are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define ALLOW_FORMATS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable directory operations. 
.................... // Description: The ALLOW_DIRS definition can be commented out to disable all directory functionality.  This will reduce code size. 
.................... //              If directories are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES in order to use 
.................... //              the FSmkdir or FSrmdir functions. 
.................... #define ALLOW_DIRS 
....................  
.................... // Summary: A macro to enable/disable PIC18 ROM functions. 
.................... // Description: The ALLOW_PGMFUNCTIONS definition can be commented out to disable all PIC18 functions that allow the user to pass string 
.................... //              arguments in ROM (denoted by the suffix -pgm).  Note that this functionality must be disabled when not using PIC18. 
.................... #if !defined(__CCS__) 
.................... #define ALLOW_PGMFUNCTIONS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable the FSfprintf function. 
.................... // Description: The ALLOW_FSFPRINTF definition can be commented out to disable the FSfprintf function.  This will save code space.  Note that 
.................... //              if FSfprintf is enabled and the PIC18 architecture is used, integer promotions must be enabled in the Project->Build Options 
.................... //              menu.  Write operations must be enabled to use FSfprintf. 
.................... //#define ALLOW_FSFPRINTF 
....................  
.................... // CCS added this config option to disable FAT12 to prevent recursion. 
.................... //__CCS__ added by ccs 
.................... //#define SUPPORT_FAT12 
....................  
.................... // Summary: A macro to enable/disable FAT32 support. 
.................... // Description: The SUPPORT_FAT32 definition can be commented out to disable support for FAT32 functionality.  This will save a small amount 
.................... //              of code space. 
.................... #define SUPPORT_FAT32 
....................  
....................  
....................  
.................... /**************************************************************************************************/ 
.................... // Select a method for updating file timestamps 
.................... /**************************************************************************************************/ 
....................  
.................... // Summary: A macro to enable RTCC based timestamp generation 
.................... // Description: The USEREALTIMECLOCK macro will configure the code to automatically 
.................... //              generate timestamp information for files from the RTCC module. The user 
.................... //              must enable and configure the RTCC module before creating or modifying 
.................... //              files.                                                                  
.................... //#define USEREALTIMECLOCK 
....................  
.................... // Summary: A macro to enable manual timestamp generation 
.................... // Description: The USERDEFINEDCLOCK macro will allow the user to manually set 
.................... //              timestamp information using the SetClockVars function. The user will 
.................... //              need to set the time variables immediately before creating or closing a 
.................... //              file or directory.                                                     
.................... #define USERDEFINEDCLOCK 
....................  
.................... // Summary: A macro to enable don't-care timestamp generation 
.................... // Description: The INCREMENTTIMESTAMP macro will set the create time of a file to a 
.................... //              static value and increment it when a file is updated. This timestamp 
.................... //              generation method should only be used in applications where file times 
.................... //              are not necessary.                                                     
.................... //#define INCREMENTTIMESTAMP 
....................  
....................  
.................... #ifdef __18CXX 
....................    #ifdef USEREALTIMECLOCK 
....................       #error Not all PIC18 devices have a Real-time clock and calander module 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    #ifndef __18CXX 
....................       #error The pgm functions are unneccessary when not using PIC18 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef USEREALTIMECLOCK 
....................     #ifndef USERDEFINEDCLOCK 
....................         #ifndef INCREMENTTIMESTAMP 
....................             #error Please enable USEREALTIMECLOCK, USERDEFINEDCLOCK, or INCREMENTTIMESTAMP 
....................         #endif 
....................     #endif 
.................... #endif 
....................  
.................... /************************************************************************/ 
.................... // Set this preprocessor option to '1' to use dynamic FSFILE object allocation.  It will 
.................... // be necessary to allocate a heap when dynamically allocating FSFILE objects. 
.................... // Set this option to '0' to use static FSFILE object allocation. 
.................... /************************************************************************/ 
....................  
.................... //#if 1  //from mirochip 
.................... #if defined(__PCH__) //__CCS__ 
....................     // Summary: A macro indicating that FSFILE objects will be allocated dynamically 
....................     // Description: The FS_DYNAMIC_MEM macro will cause FSFILE objects to be allocated from a dynamic heap.  If it is undefined, 
....................     //              the file objects will be allocated using a static array. 
....................    //#define FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................         // Description: Function pointer to a dynamic memory allocation function 
....................       #define FS_malloc   SRAMalloc 
....................         // Description: Function pointer to a dynamic memory free function 
....................       #define FS_free      SRAMfree 
....................    #else 
....................       #define FS_malloc   malloc 
....................       #define FS_free      free 
....................    #endif 
.................... #elif defined(__CCS__) 
....................    #error/warning Not using FS_DYNAMIC_MEM for PCD compiler 
.................... #endif 
....................  
....................  
.................... #ifdef __18CXX 
....................     /* Define the locations for the dataBuffer and FATbuffer; PLEASE CHECK THE LINKER FILE */ 
....................     #define DATA_BUFFER_ADDRESS      0x700 
....................     #define FAT_BUFFER_ADDRESS       0x900 
.................... #endif 
....................  
....................  
.................... // Function definitions 
.................... // Associate the physical layer functions with the correct physical layer 
.................... #ifdef USE_SD_INTERFACE_WITH_SPI       // SD-SPI.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_SDSPI_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_SDSPI_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_SDSPI_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_SDSPI_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_SDSPI_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_SDSPI_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_SDSPI_WriteProtectState 
....................  
....................     // Description: Function pointer to the Read Capacity Physical Layer function 
....................     #define MDD_ReadCapacity        MDD_SDSPI_ReadCapacity 
....................  
....................     // Description: Function pointer to the Read Sector Size Physical Layer Function 
....................     #define MDD_ReadSectorSize      MDD_SDSPI_ReadSectorSize 
....................  
.................... #elif defined USE_CF_INTERFACE_WITH_PMP       // CF-PMP.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFPMP_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFPMP_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFPMP_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFPMP_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFPMP_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFPMP_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFPMP_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFPMP_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFPMP_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFPMP_CFread 
....................  
.................... #elif defined USE_MANUAL_CF_INTERFACE         // CF-Bit transaction.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFBT_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFBT_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFBT_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFBT_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFBT_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFBT_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFBT_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFBT_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFBT_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFBT_CFread 
....................  
.................... #elif defined USE_USB_INTERFACE               // USB host MSD library 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     USBHostMSDSCSIMediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         USBHostMSDSCSIMediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          USBHostMSDSCSISectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         USBHostMSDSCSISectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO();               
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       USBHostMSDSCSIMediaReset 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   USBHostMSDSCSIWriteProtectState 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #if defined(USE_SST25_INTERFACE) 
.................... #include "sst25vf_mdd.c" 
.................... #endif 
....................  
.................... #if defined(FS_DYNAMIC_MEM) 
....................  #if defined(__PCH__) 
....................   #include "salloc.c" 
....................  #else 
....................   #include <stdlibm.h> 
....................  #endif 
.................... #endif 
....................  
.................... #include "fsio.c" 
.................... /****************************************************************************** 
.................... * 
.................... *               Microchip Memory Disk Drive File System 
.................... * 
.................... ****************************************************************************** 
.................... * FileName:           FSIO.c 
.................... * Dependencies:       GenericTypeDefs.h 
.................... *                     FSIO.h 
.................... *                     Physical interface include file (SD-SPI.h, CF-PMP.h, ...) 
.................... *                     string.h 
.................... *                     stdlib.h 
.................... *                     FSDefs.h 
.................... *                     ctype.h 
.................... *                     salloc.h 
.................... * Processor:          PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
.................... * Compiler:           C18/C30/C32 
.................... * Company:            Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * The software supplied herewith by Microchip Technology Incorporated 
.................... * (the Company) for its PICmicro Microcontroller is intended and 
.................... * supplied to you, the Companys customer, for use solely and 
.................... * exclusively on Microchip PICmicro Microcontroller products. The 
.................... * software is owned by the Company and/or its supplier, and is 
.................... * protected under applicable copyright laws. All rights are reserved. 
.................... * Any use in violation of the foregoing restrictions may subject the 
.................... * user to criminal sanctions under applicable laws, as well as to 
.................... * civil liability for the breach of the terms and conditions of this 
.................... * license. 
.................... * 
.................... * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
.................... * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
.................... * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
.................... * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
.................... * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
.................... * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
.................... * 
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev     Description 
....................   -----   ----------- 
....................   1.2.5   Fixed bug that prevented writes to alternate FAT tables 
....................           Fixed bug that prevented FAT being updated when media is re-inserted 
....................  
....................   1.2.6   Fixed bug that resulted in a bus error when attempts to read a invalid memory region 
....................           Fixed bug that prevented the Windows Explorer to show the Date Creation field for directories 
....................  
....................   x.x.x   Fixed issue on some USB drives where the information written 
....................             to the drive is cached in a RAM for 500ms before it is 
....................             written to the flash unless the sector is accessed again. 
....................           Add some error recovery for FAT32 systems when there is 
....................             corruption in the boot sector. 
....................  
....................   1.3.0   Modified to support Long File Name(LFN) format 
....................   1.3.4   1) Initialized some of the local variables to default values 
....................              to remove non-critical compiler warnings for code sanitation. 
....................           2) The sector size of the media device is obtained from the MBR of media.So, 
....................              instead of using the hard coded macro "DIRENTRIES_PER_SECTOR", the variables 
....................              "dirEntriesPerSector" & "disk->sectorSize" are used in the code. Refer 
....................              "Cache_File_Entry","EraseCluster" & "writeDotEntries" fucntions to see 
....................              the change. 
....................   1.3.6   1) The function "FILEget_next_cluster" is made public. 
....................           2) Modified "FILEfind" function such that when using 8.3 format 
....................              the file searches are not considered as case sensitive. 
....................           3) In function 'CacheTime', the variables 'ptr1' & 'ptr0' are not used 
....................              when compiled for PIC32. So there definitions were removed for PIC32. 
....................           4) Modified "rmdirhelper", "FormatDirName" & "writeDotEntries" functions 
....................              to remove non-critical warnings during compilation. 
....................           5) Updated comments in most of the function header blocks. 
....................   1.4.0   1) While creating files in LFN format with file name length as 13,26,39,52...etc(multiples of 13), 
....................              MDD library was creating incorrect directory entries. To fix this issue, 
....................              functions "FILEfind", "CreateFileEntry", "Alias_LFN_Object", "FormatFileName", 
....................              "FormatDirName", "FSgetcwd", "GetPreviousEntry" & "rmdirhelper" were modified. 
....................              Now "utf16LFNlength" variable part of "FSFILE" structure, indicates LFN length 
....................              excluding the NULL word at the last. 
....................           2) When creating large number of files in LFN format, some files were not getting created in disk. 
....................              To fix this issue,function "FILEfind" was modified. 
....................           3) Modified "FSformat" function to initialize "disk->sectorSize" to default value. 
....................           4) Modified "CreateFileEntry" & "FindEmptyEntries" functions to remove unnecessary 
....................              assignments & optimize the code. 
....................           5) Modified "FSfopen" function to prevent creating an empty file in the directory, when SD card 
....................              is write protected. 
....................           6) Variable "entry" in "writeDotEntries" function is made volatile & properly typecasted 
....................              in it's usage. 
....................           7) Modified "FSFopen" function so that when you try to open a file that doesn't exist on the disk, 
....................              variable "FSerrno" is assigned to CE_FILE_NOT_FOUND. 
....................   1.4.2   1) Minor Modification in "CreateFileEntry" function to fix a bug for file name lengths of 
....................              26,39....characters (multiples of 13) 
....................           2) Fixed the LoadMBR() function to scan all of the MBR entries and return success on the first 
....................              supported drive or fail after the 4 table entries. 
.................... ********************************************************************/ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *					dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *					Microchip C30 v3.01 or higher 
....................  *					Microchip C18 v3.13 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006	Original, copied from old Compiler.h 
....................  * 11/07/2007	Reorganized and simplified 
....................  * 03/31/2010	Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__PCH__) 
....................    #include <p18cxxx.h> 
.................... #elif defined(__PCD__) 
....................    #include <CCSIncludes\PCDxxxx.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... // pcdxxxx.h 
.................... // 
.................... // Microchip C30 to CCS conversion library. 
....................  
.................... #ifndef __PCDXXXX_H__ 
.................... #define __PCDXXXX_H__ 
....................  
.................... #case 
....................  
.................... #include "ccspics.h" 
....................  
.................... //#device PSV=16 
....................  
.................... #if defined(__CONST_IS_READONLY__) 
....................    #device CONST=READ_ONLY 
.................... #else 
....................    //this is normally how C30 operates 
....................    #device CONST=ROM 
.................... #endif 
....................  
.................... #device PASS_STRINGS=IN_RAM 
....................  
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #zero_ram 
.................... #zero_local_ram 
....................  
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
.................... #undef BYTE 
.................... #endif 
....................  
.................... #if defined(BOOLEAN) 
.................... #undef BOOLEAN 
.................... #endif 
....................  
.................... #define GetSystemClock()       getenv("CLOCK") 
.................... #define GetInstructionClock()  (GetSystemClock()/2) 
.................... #define GetPeripheralClock()   (GetSystemClock()/2) 
....................  
.................... //#define Reset()            reset_cpu()   //not needed, this is defined in Microchip's Compiler.h 
.................... //#define FAR                        //not needed, this is defined in Microchip's Compiler.h 
....................  
.................... #define ClrWdt()         restart_wdt() 
....................  
.................... #define Nop()            delay_cycles(1) 
....................  
.................... //#warning need eds support 
.................... #define __eds__ 
....................  
.................... #define __prog__  rom 
....................  
.................... #define __C30__ 
....................  
.................... #define __CCS_STDLIB_DYNAMIC_MEMORY__ 
....................  
.................... #endif 
....................  
.................... #elif defined(__18CXX) && !defined(HI_TECH_C)	 
.................... 	// PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)	 
.................... 	// PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
.................... 	#if !defined(__18CXX) 
.................... 		#define __18CXX 
.................... 	#endif 
....................     #define COMPILER_HITECH_PICC18 
.................... 	#include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p30fxxxx.h> 
.................... #elif defined(__C30__)		// Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p30sim.h> 
.................... 	// Define some useful inline assembly functions which are normally in the  
.................... 	// processor header files, but absent from the generic p30sim.h file. 
.................... 	#if !defined(Nop) 
.................... 		#define Nop()    __builtin_nop() 
.................... 		#define ClrWdt() {__asm__ volatile ("clrwdt");} 
.................... 		#define Sleep()  {__asm__ volatile ("pwrsav #0");} 
.................... 		#define Idle()   {__asm__ volatile ("pwrsav #1");} 
.................... 	#endif 
.................... #elif defined(__PIC32MX__)	// Microchip C32 compiler 
.................... 	#if !defined(__C32__) 
.................... 		#define __C32__ 
.................... 	#endif 
....................     #define COMPILER_MPLAB_C32 
.................... 	#include <p32xxxx.h> 
.................... 	#include <plib.h> 
.................... #else 
.................... 	#error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
*
040AC:  MOV     W5,[W15++]
.................... { 
....................   unsigned char *s; 
040AE:  CLR     FF6
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
040B0:  PUSH    FF0
040B2:  POP     FF6
040B4:  CP0     FF4
040B6:  BRA     Z,40D0
040B8:  MOV     FF2,W0
040BA:  CP0.B   [W0]
040BC:  BRA     Z,40D0
....................      *s++ = *s2++; 
040BE:  MOV     FF6,W0
040C0:  INC     0FF6
040C2:  MOV     W0,W5
040C4:  MOV     FF2,W0
040C6:  INC     0FF2
040C8:  MOV.B   [W0],[W5]
040CA:  DEC     0FF4
040CC:  GOTO    40B4
....................   for (; n > 0; n--) 
040D0:  CP0     FF4
040D2:  BRA     Z,40E2
....................      *s++ = '\0'; 
040D4:  MOV     FF6,W0
040D6:  INC     0FF6
040D8:  MOV     W0,W5
040DA:  CLR.B   [W5]
040DC:  DEC     0FF4
040DE:  GOTO    40D0
....................  
....................   return(s1); 
040E2:  PUSH    FF0
040E4:  POP     0
040E6:  MOV     [--W15],W5
040E8:  RETURN  
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
*
05AE2:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *sc1, *sc2; 
05AE4:  CLR     F92
05AE6:  CLR     F94
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
05AE8:  PUSH    F8E
05AEA:  POP     F92
05AEC:  MOV     F92,W0
05AEE:  CP0.B   [W0]
05AF0:  BRA     Z,5B1C
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
05AF2:  PUSH    F90
05AF4:  POP     F94
05AF6:  MOV     F94,W0
05AF8:  CP0.B   [W0]
05AFA:  BRA     Z,5B16
....................          if (*sc1 == *sc2) 
05AFC:  MOV     F92,W0
05AFE:  MOV.B   [W0],W5L
05B00:  MOV     F94,W0
05B02:  MOV     W0,W4
05B04:  MOV.B   [W4],W0L
05B06:  CP.B    W5L,W0L
05B08:  BRA     NZ,5B10
....................             return(sc1); 
05B0A:  PUSH    F92
05B0C:  POP     0
05B0E:  BRA     5B1E
05B10:  INC     0F94
05B12:  GOTO    5AF6
05B16:  INC     0F92
05B18:  GOTO    5AEC
....................    return(0); 
05B1C:  CLR     0
05B1E:  MOV     [--W15],W5
05B20:  RETURN  
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
*
05A94:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *sc1, *sc2; 
05A96:  CLR     F92
05A98:  CLR     F94
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
05A9A:  PUSH    F8E
05A9C:  POP     F92
05A9E:  MOV     F92,W0
05AA0:  CP0.B   [W0]
05AA2:  BRA     Z,5AD8
....................       for (sc2 = s2; ; sc2++) 
05AA4:  PUSH    F90
05AA6:  POP     F94
....................     if (*sc2 == '\0') 
05AA8:  MOV     F94,W0
05AAA:  CP0.B   [W0]
05AAC:  BRA     NZ,5ABA
....................        return(sc1 - s1); 
05AAE:  MOV     F92,W4
05AB0:  MOV     F8E,W3
05AB2:  SUB     W4,W3,W0
05AB4:  BRA     5ADE
05AB6:  GOTO    5ACC
....................          else if (*sc1 == *sc2) 
05ABA:  MOV     F92,W0
05ABC:  MOV.B   [W0],W5L
05ABE:  MOV     F94,W0
05AC0:  MOV     W0,W4
05AC2:  MOV.B   [W4],W0L
05AC4:  CP.B    W5L,W0L
05AC6:  BRA     NZ,5ACC
....................             break; 
05AC8:  GOTO    5AD2
05ACC:  INC     0F94
05ACE:  GOTO    5AA8
05AD2:  INC     0F92
05AD4:  GOTO    5A9E
....................    return(sc1 - s1); 
05AD8:  MOV     F92,W4
05ADA:  MOV     F8E,W3
05ADC:  SUB     W4,W3,W0
05ADE:  MOV     [--W15],W5
05AE0:  RETURN  
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
*
05B22:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *beg, *end; 
05B24:  CLR     F86
05B26:  CLR     F88
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
05B28:  CP0     F82
05B2A:  BRA     Z,5B32
05B2C:  MOV     F82,W0
05B2E:  GOTO    5B34
05B32:  MOV     802,W0
05B34:  MOV     W0,F86
....................    beg += strspn(beg, s2); 
05B36:  PUSH    F86
05B38:  POP     F8E
05B3A:  PUSH    F84
05B3C:  POP     F90
05B3E:  CALL    5A94
05B42:  MOV.B   W0L,W5L
05B44:  ZE      W5,W5
05B46:  CLR.B   B
05B48:  MOV.B   W5L,W0L
05B4A:  ADD     F86
....................    if (*beg == '\0') 
05B4C:  MOV     F86,W0
05B4E:  CP0.B   [W0]
05B50:  BRA     NZ,5B5C
....................    { 
....................       *save = beg; 
05B52:  MOV     802,W5
05B54:  MOV     F86,W0
05B56:  MOV.B   W0L,[W5+#0]
....................       return(0); 
05B58:  CLR     0
05B5A:  BRA     5B7E
....................    } 
....................    end = strpbrk(beg, s2); 
05B5C:  PUSH    F86
05B5E:  POP     F8E
05B60:  PUSH    F84
05B62:  POP     F90
05B64:  CALL    5AE2
05B68:  MOV     W0,F88
....................    if (*end != '\0') 
05B6A:  MOV     F88,W0
05B6C:  CP0.B   [W0]
05B6E:  BRA     Z,5B76
....................    { 
....................       *end = '\0'; 
05B70:  MOV     F88,W5
05B72:  CLR.B   [W5]
....................       end++; 
05B74:  INC     0F88
....................    } 
....................    save = end; 
05B76:  PUSH    F88
05B78:  POP     802
....................    return(beg); 
05B7A:  PUSH    F86
05B7C:  POP     0
05B7E:  MOV     [--W15],W5
05B80:  RETURN  
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
*
025A8:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *sc; 
025AA:  CLR     1038
....................  
....................    for (sc = s; *sc != 0; sc++); 
025AC:  PUSH    1036
025AE:  POP     1038
025B0:  MOV     1038,W0
025B2:  CP0.B   [W0]
025B4:  BRA     Z,25BC
025B6:  INC     1038
025B8:  GOTO    25B0
....................    return(sc - s); 
025BC:  MOV     1038,W4
025BE:  MOV     1036,W3
025C0:  SUB     W4,W3,W0
025C2:  MOV     W0,0
025C4:  MOV     [--W15],W5
025C6:  RETURN  
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
*
05BEA:  MOV     W5,[W15++]
05BEC:  MOV     W6,[W15++]
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
05BEE:  MOV     F82,W0
05BF0:  MOV.B   [W0],W5L
05BF2:  MOV     F84,W0
05BF4:  MOV     W0,W4
05BF6:  MOV.B   [W4],W0L
05BF8:  CP.B    W5L,W0L
05BFA:  BRA     Z,5C60
05BFC:  MOV     F82,W0
05BFE:  MOV.B   [W0],W5L
05C00:  MOV     #41,W4
05C02:  CP.B    W4L,W5L
05C04:  BRA     GTU,5C0E
05C06:  MOV     #5A,W4
05C08:  CP.B    W4L,W5L
05C0A:  BRA     NC,5C0E
05C0C:  BRA     5C1A
05C0E:  MOV     #61,W4
05C10:  CP.B    W4L,W5L
05C12:  BRA     GTU,5C74
05C14:  MOV     #7A,W4
05C16:  CP.B    W4L,W5L
05C18:  BRA     NC,5C74
05C1A:  MOV     F84,W0
05C1C:  MOV.B   [W0],W5L
05C1E:  MOV     #41,W4
05C20:  CP.B    W4L,W5L
05C22:  BRA     GTU,5C2C
05C24:  MOV     #5A,W4
05C26:  CP.B    W4L,W5L
05C28:  BRA     NC,5C2C
05C2A:  BRA     5C38
05C2C:  MOV     #61,W4
05C2E:  CP.B    W4L,W5L
05C30:  BRA     GTU,5C74
05C32:  MOV     #7A,W4
05C34:  CP.B    W4L,W5L
05C36:  BRA     NC,5C74
05C38:  MOV     F82,W0
05C3A:  MOV.B   [W0],W5L
05C3C:  MOV     F84,W0
05C3E:  MOV.B   [W0],W4L
05C40:  CLR.B   9
05C42:  MOV     #20,W3
05C44:  ADD     W4,W3,W0
05C46:  CLR.B   B
05C48:  CP      W5,W0
05C4A:  BRA     Z,5C60
05C4C:  MOV     F84,W0
05C4E:  MOV.B   [W0],W5L
05C50:  MOV     F82,W0
05C52:  MOV.B   [W0],W4L
05C54:  CLR.B   9
05C56:  MOV     #20,W3
05C58:  ADD     W4,W3,W0
05C5A:  CLR.B   B
05C5C:  CP      W5,W0
05C5E:  BRA     NZ,5C74
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
05C60:  MOV     F82,W0
05C62:  CP0.B   [W0]
05C64:  BRA     NZ,5C6A
....................        return(0); 
05C66:  CLR.B   0
05C68:  BRA     5C8A
05C6A:  MOV     F82,W0
05C6C:  INC     0F82
05C6E:  INC     0F84
05C70:  GOTO    5BEE
....................  return((*s1 < *s2) ? -1: 1); 
05C74:  MOV     F82,W0
05C76:  MOV.B   [W0],W5L
05C78:  MOV     F84,W0
05C7A:  MOV     W0,W4
05C7C:  MOV.B   [W4],W0L
05C7E:  CP.B    W5L,W0L
05C80:  BRA     C,5C88
05C82:  SETM.B  W0
05C84:  GOTO    5C8A
05C88:  MOV.B   #1,W0L
05C8A:  MOV     [--W15],W6
05C8C:  MOV     [--W15],W5
05C8E:  RETURN  
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = beg; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = beg; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PIC32MX__) 
.................... 	#define PTR_BASE		unsigned long 
.................... 	#define ROM_PTR_BASE	unsigned long 
.................... #elif defined(__C30__) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
.................... 	#define memcmppgm2ram(a,b,c)	memcmp(a,b,c) 
.................... 	#define strcmppgm2ram(a,b)		strcmp(a,b) 
.................... 	#define memcpypgm2ram(a,b,c)	memcpy(a,b,c) 
.................... 	#define strcpypgm2ram(a,b)		strcpy(a,b) 
.................... 	#define strncpypgm2ram(a,b,c)	strncpy(a,b,c) 
.................... 	#define strstrrampgm(a,b)		strstr(a,b) 
.................... 	#define	strlenpgm(a)			strlen(a) 
.................... 	#define strchrpgm(a,b)			strchr(a,b) 
.................... 	#define strcatpgm2ram(a,b)		strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
.................... 	#define	__attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
.................... 	// Microchip C18 specific defines 
.................... 	#if defined(COMPILER_MPLAB_C18) 
.................... 	    #define ROM                 	rom 
.................... 	#endif 
.................... 	 
.................... 	// HI TECH PICC-18 specific defines 
.................... 	#if defined(COMPILER_HITECH_PICC18) 
.................... 	    #define ROM                 	const 
.................... 		#define rom 
.................... 	    #define Nop()               	asm("NOP"); 
.................... 		#define ClrWdt()				asm("CLRWDT"); 
.................... 	    #define Reset()					asm("RESET"); 
.................... 	#endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
.................... 	#define	ROM						const 
....................  
.................... 	// 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
.................... 	#if defined(__C30__) 
.................... 		#define Reset()				asm("reset") 
....................         #define FAR                 __attribute__((far)) 
.................... 	#endif 
....................  
.................... 	// 32-bit specific defines (PIC32) 
.................... 	#if defined(__PIC32MX__) 
.................... 		#define persistent 
.................... 		#define far 
....................         #define FAR 
.................... 		#define Reset()				SoftReset() 
.................... 		#define ClrWdt()			(WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
.................... 		// MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
.................... 		// Nop() function. However, version 1.05 has Nop() declared as _nop(). 
.................... 		#if !defined(Nop) && (__C32_VERSION__ <= 104) 
.................... 			#define Nop()				asm("nop") 
.................... 		#endif 
.................... 	#endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "MDD File System/FSIO.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSIO.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  *                  FSconfig.h 
....................  *                  FSDefs.h 
....................  *                  stddef.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.4.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  FS_DOT_H 
.................... #define  FS_DOT_H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... #include "../FSconfig.h" 
.................... #include "FSDefs.h"  
.................... #include "stddef.h" 
....................  
.................... #ifdef USE_SD_INTERFACE_WITH_SPI 
....................     #include    "SD-SPI.h" 
.................... #endif 
.................... #ifdef USE_CF_INTERFACE_WITH_PMP 
....................     #include    "CF-PMP.h" 
.................... #endif 
.................... #ifdef USE_MANUAL_CF_INTERFACE 
....................     #include    "CF- Bit transaction.h" 
.................... #endif 
.................... #ifdef USE_USB_INTERFACE 
....................     #include    "usb_host_msd_scsi.h" 
.................... #endif 
.................... #ifdef USE_INTERNAL_FLASH 
....................     #include    "Internal Flash.h" 
.................... #endif 
....................  
....................  
.................... /*******************************************************************/ 
.................... /*                     Strunctures and defines                     */ 
.................... /*******************************************************************/ 
....................  
.................... #ifndef FALSE 
....................     // Summary: False value 
....................     // Description:  This macro will indicate that a condition is false. 
....................     #define FALSE   0 
.................... #endif 
.................... #ifndef TRUE 
....................     // Summary: True value 
....................     // Description: This macro will indicate that a condition is true. 
....................     #define TRUE    !FALSE  // True value 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #ifndef SEEK_SET 
....................     // Summary: Macro for the FSfseek SEEK_SET base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed  
....................     //              relative to the beginning of the file. 
....................     #define SEEK_SET 0 
....................  
.................... #endif 
.................... #ifndef SEEK_CUR 
....................  
....................     // Summary: Macro for the FSfseek SEEK_CUR base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the current location of the file 
....................     #define SEEK_CUR 1 
....................  
.................... #endif 
.................... #ifndef SEEK_END 
....................  
....................     // Summary: Macro for the FSfseek SEEK_END base location 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the end of the file.  For this macro, the offset value will be subtracted from 
....................     //              the end location of the file by default. 
....................     #define SEEK_END 2 
....................  
.................... #endif 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file. 
.................... #define FS_APPEND   "a" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file. 
.................... #define FS_WRITE    "w" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file. 
.................... #define FS_READ "r" 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file 
.................... //              or read from the file. 
.................... #define FS_APPENDPLUS   "a+" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file or read from the file. 
.................... #define FS_WRITEPLUS    "w+" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file or write to the file. 
.................... #define FS_READPLUS     "r+" 
....................  
.................... #ifndef intmax_t 
....................     #ifdef __PIC24F__ 
....................         // Summary: A data type indicating the maximum integer size in an architecture 
....................         // Description: The intmax_t data type refers to the maximum-sized data type on any given architecture.  This 
....................         //              data type can be specified as a format specifier size specification for the FSfprintf function. 
....................         #define intmax_t long long 
....................     #elif defined __PIC24H__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC30F__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC33F__ 
....................         #define intmax_t long long 
....................     #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary:  Indicates flag conditions for a file object 
.................... // Description: The FILEFLAGS structure is used to indicate conditions in a file.  It contains three flags: 'write' indicates 
.................... //              that the file was opened in a mode that allows writes, 'read' indicates that the file was opened in a mode 
.................... //              that allows reads, and 'FileWriteEOF' indicates that additional data that is written to the file will increase 
.................... //              the file size. 
.................... typedef struct 
.................... { 
....................     unsigned    write :1;           // Indicates a file was opened in a mode that allows writes 
....................     unsigned    read :1;            // Indicates a file was opened in a mode that allows reads 
....................     unsigned    FileWriteEOF :1;    // Indicates the current position in a file is at the end of the file 
.................... }FILEFLAGS; 
....................  
....................  
....................  
.................... // Summary: Indicates how to search for file entries in the FILEfind function 
.................... // Description: The values in the SEARCH_TYPE enumeration are used internally by the library to indicate how the FILEfind function 
.................... //              how to perform a search.  The 'LOOK_FOR_EMPTY_ENTRY' value indicates that FILEfind should search for an empty file entry. 
.................... //              The 'LOOK_FOR_MATCHING_ENTRY' value indicates that FILEfind should search for an entry that matches the FSFILE object 
.................... //              that was passed into the FILEfind function. 
.................... typedef enum{ 
....................     LOOK_FOR_EMPTY_ENTRY = 0, 
....................     LOOK_FOR_MATCHING_ENTRY 
.................... } SEARCH_TYPE; 
....................  
....................  
....................  
.................... // Summary: Macro indicating the length of a 8.3 file name 
.................... // Description: The TOTAL_FILE_SIZE_8P3 macro indicates the maximum number of characters in an 8.3 file name.  This value includes 
.................... //              8 characters for the name, three for the extentsion, and 1 for the radix ('.') 
.................... #define TOTAL_FILE_SIZE_8P3             (8+3+1) 
.................... #define TOTAL_FILE_SIZE                 TOTAL_FILE_SIZE_8P3 
....................  
.................... // Summary: Macro indicating the max length of a LFN file name 
.................... // Description: The MAX_FILE_NAME_LENGTH_LFN macro indicates the maximum number of characters in an LFN file name. 
.................... #define MAX_FILE_NAME_LENGTH_LFN             256 
....................  
.................... // Summary: A mask that indicates the limit of directory entries in a sector 
.................... // Description: The MASK_MAX_FILE_ENTRY_LIMIT_BITS is used to indicate to the Cache_File_Entry function that a new sector needs to 
.................... //              be loaded. 
.................... #define MASK_MAX_FILE_ENTRY_LIMIT_BITS          0x0f 
....................  
.................... // Summary: Value used for shift operations to calculate the sector offset in a directory 
.................... // Description: The VALUE_BASED_ON_ENTRIES_PER_CLUSTER macro is used to calculate sector offsets for directories.  The position of the 
.................... //              entry is shifted by 4 bits (divided by 16, since there are 16 entries in a sector) to calculate how many sectors a 
.................... //              specified entry is offset from the beginning of the directory. 
.................... #define VALUE_BASED_ON_ENTRIES_PER_CLUSTER      4 
....................  
.................... // Summary: A value that will indicate that a dotdot directory entry points to the root. 
.................... // Description: The VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT macro is used as an absolute address when writing information to a dotdot entry 
.................... //              in a newly created directory.  If a dotdot entry points to the root directory, it's cluster value must be set to 0, 
.................... //              regardless of the actual cluster number of the root directory. 
.................... #define VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT     0 
....................  
.................... // Summary: MAcro indicating the length of an 8.3 file name in a directory entry 
.................... // Description: The FILE_NAME_SIZE_8P3 macro indicates the number of characters that an 8.3 file name will take up when packed in 
.................... //              a directory entry.  This value includes 8 characters for the name and 3 for the extension.  Note that the radix is not 
.................... //              stored in the directory entry. 
.................... #define FILE_NAME_SIZE_8P3           11 
.................... #define FILE_NAME_SIZE               FILE_NAME_SIZE_8P3 
....................  
....................  
.................... // Summary: Contains file information and is used to indicate which file to access. 
.................... // Description: The FSFILE structure is used to hold file information for an open file as it's being modified or accessed.  A pointer to  
.................... //              an open file's FSFILE structure will be passeed to any library function that will modify that file. 
.................... typedef struct 
.................... { 
....................     DISK    *       dsk;            // Pointer to a DISK structure 
....................     DWORD           cluster;        // The first cluster of the file 
....................     DWORD           ccls;           // The current cluster of the file 
....................     WORD            sec;            // The current sector in the current cluster of the file 
....................     WORD            pos;            // The position in the current sector 
....................     DWORD           seek;           // The absolute position in the file 
....................     DWORD           size;           // The size of the file 
....................     FILEFLAGS       flags;          // A structure containing file flags 
....................     WORD            time;           // The file's last update time 
....................     WORD            date;           // The file's last update date 
....................     char            name[FILE_NAME_SIZE_8P3];       // The short name of the file 
....................    #ifdef SUPPORT_LFN 
....................        BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNptr;           // Pointer to long file name in UTF16 format 
....................       unsigned short int utf16LFNlength;          // LFN length in terms of words excluding the NULL word at the last. 
....................    #endif 
....................     WORD            entry;          // The position of the file's directory entry in it's directory 
....................     WORD            chk;            // File structure checksum 
....................     WORD            attributes;     // The file attributes 
....................     DWORD           dirclus;        // The base cluster of the file's directory 
....................     DWORD           dirccls;        // The current cluster of the file's directory 
.................... } FSFILE; 
....................  
.................... /* Summary: Possible results of the FSGetDiskProperties() function. 
.................... ** Description: See the FSGetDiskProperties() function for more information. 
.................... */ 
.................... typedef enum 
.................... { 
....................     FS_GET_PROPERTIES_NO_ERRORS = 0, 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED, 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE, 
....................     FS_GET_PROPERTIES_STILL_WORKING = 0xFF 
.................... } FS_DISK_ERRORS; 
....................  
....................  
.................... /* Summary: Contains the disk search information, intermediate values, and results 
.................... ** Description: This structure is used in conjunction with the FSGetDiskProperties() 
.................... **              function.  See that function for more information about the usage. 
.................... */ 
.................... typedef struct 
.................... { 
....................     DISK *  disk;           /* pointer to the disk we are searching */ 
....................     BOOL    new_request;    /* is this a new request or a continued request */ 
....................     FS_DISK_ERRORS properties_status;  /* status of the last call of the function */ 
....................  
....................     struct 
....................     { 
....................         BYTE disk_format;           /* disk format: FAT12, FAT16, FAT32 */ 
....................         WORD sector_size;           /* sector size of the drive */ 
....................         BYTE sectors_per_cluster;   /* number of sectors per cluster */ 
....................         DWORD total_clusters;       /* the number of total clusters on the drive */ 
....................         DWORD free_clusters;        /* the number of free (unused) clusters on drive */ 
....................     } results;                      /* the results of the current search */ 
....................  
....................     struct 
....................     { 
....................         DWORD   c;      
....................         DWORD   curcls; 
....................         DWORD   EndClusterLimit; 
....................         DWORD   ClusterFailValue; 
....................     } private;      /* intermediate values used to continue searches.  This 
....................                          member should be used only by the FSGetDiskProperties() 
....................                          function */ 
....................  
.................... } FS_DISK_PROPERTIES; 
....................  
.................... // Summary: A structure used for searching for files on a device. 
.................... // Description: The SearchRec structure is used when searching for file on a device.  It contains parameters that will be loaded with 
.................... //              file information when a file is found.  It also contains the parameters that the user searched for, allowing further 
.................... //              searches to be perfomed in the same directory for additional files that meet the specified criteria. 
.................... typedef struct 
.................... { 
....................     char            filename[FILE_NAME_SIZE_8P3 + 2];   // The name of the file that has been found 
....................     unsigned char   attributes;                     // The attributes of the file that has been found 
....................     unsigned long   filesize;                       // The size of the file that has been found 
....................     unsigned long   timestamp;                      // The last modified time of the file that has been found (create time for directories) 
....................    #ifdef SUPPORT_LFN 
....................       BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNfound;          // Pointer to long file name found in UTF16 format 
....................       unsigned short int utf16LFNfoundLength;     // LFN Found length in terms of words including the NULL word at the last. 
....................    #endif 
....................     unsigned int    entry;                          // The directory entry of the last file found that matches the specified attributes. (Internal use only) 
....................     char            searchname[FILE_NAME_SIZE_8P3 + 2]; // The 8.3 format name specified when the user began the search. (Internal use only) 
....................     unsigned char   searchattr;                     // The attributes specified when the user began the search. (Internal use only) 
....................     unsigned long   cwdclus;                        // The directory that this search was performed in. (Internal use only) 
....................     unsigned char   initialized;                    // Check to determine if the structure was initialized by FindFirst (Internal use only) 
.................... } SearchRec; 
....................  
....................  
.................... /*************************************************************************** 
.................... * Prototypes                                                               * 
.................... ***************************************************************************/ 
....................  
....................  
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     int FSInit(void) 
....................   Summary: 
....................     Function to initialize the device. 
....................   Conditions: 
....................     The physical device should be connected to the microcontroller. 
....................   Input: 
....................     None 
....................   Return Values: 
....................     TRUE -  Initialization successful 
....................     FALSE - Initialization unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function initializes the file system stack & the interfacing device. 
....................     Initializes the static or dynamic memory slots for holding file 
....................     structures. Initializes the device with the DISKmount function. Loads  
....................     MBR and boot sector information. Initializes the current working 
....................     directory to the root directory for the device if directory support 
....................     is enabled. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... int FSInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * FSfopen (const char * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with ascii input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will open a ascii name file or directory on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * FSfopen(const char * fileName, const char *mode); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * wFSfopen (const unsigned short int * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * wFSfopen(const unsigned short int * fileName, const char *mode); 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................  
.................... /****************************************************************************** 
....................   Function: 
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode) 
....................   Summary: 
....................     Opens a file on PIC18 Microcontrollers where 'fileName' ROM string is given 
....................     in Ascii format. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to be opened (ROM) 
....................     mode -      The mode the file will be opened in (ROM) 
....................   Return Values: 
....................     FSFILE * - A pointer to the file object 
....................     NULL -     File could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file on PIC18 Microcontrollers where 'fileName' ROM string 
....................     is given in Ascii format.The FSfopenpgm function will copy a PIC18 ROM fileName and 
....................     mode argument into RAM arrays, and then pass those arrays to the FSfopen function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   ******************************************************************************/ 
....................  
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode); 
....................  
....................  
.................... /************************************************************************************** 
....................   Function: 
....................     int FindFirstpgm (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Find a file named with a ROM string on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName -  The name of the file to be found (ROM) 
....................     attr -      The attributes of the file to be found 
....................     rec -       Pointer to a search record to store the file info in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the given parameters was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirstpgm call on passed SearchRec object 
....................     will be lost.The FSerrno variable will be changed. 
....................   Description: 
....................     This function finds a file named with 'fileName' on PIC18. The FindFirstpgm 
....................     function will copy a PIC18 ROM fileName argument into a RAM array, and then 
....................     pass that array to the FindFirst function. 
....................   Remarks: 
....................     Call FindFirstpgm or FindFirst before calling FindNext. 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************************/ 
....................  
....................     int FindFirstpgm (const rom char * fileName, unsigned int attr, SearchRec * rec); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdirpgm (const rom char * path) 
....................   Summary: 
....................     Changes the CWD to the input path on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to (ROM) 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the CWD to the input path on PIC18.The FSchdirpgm function 
....................     passes a PIC18 ROM path pointer to the chdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM 
....................   **************************************************************************/ 
....................  
....................     int FSchdirpgm (const rom char * path); 
....................  
....................     #ifdef ALLOW_WRITES 
....................  
....................  
.................... /************************************************************* 
....................   Function: 
....................     int FSremovepgm (const rom char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC18 device 
....................   Conditions: 
....................     File not opened; file exists 
....................   Input: 
....................     fileName -  The name of the file to be deleted (ROM) 
....................   Return Values: 
....................     0 -  File was removed successfully 
....................     -1 - File could not be removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC18 device.The FSremovepgm function will copy a 
....................     PIC18 ROM fileName argument into a RAM array, and then pass that array 
....................     to the FSremove function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   *************************************************************/ 
....................  
....................         int FSremovepgm (const rom char * fileName); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdirpgm (const rom char * path) 
....................   Summary: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create (ROM) 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices.'FSmkdirpgm' creates the directories as per the input 
....................     string path.This function doesn't move the current working 
....................     directory setting. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arugments in ROM 
....................   **************************************************************************/ 
....................  
....................         int FSmkdirpgm (const rom char * path); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdirpgm (const rom char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     path -      The path of the directory to remove (ROM) 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................     This function deletes the directory as specified in the path. 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************/ 
....................  
....................         int FSrmdirpgm (const rom char * path, unsigned char rmsubdirs); 
....................  
....................  
.................... /***************************************************************** 
....................   Function: 
....................     int FSrenamepgm(const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the file with the ascii ROM string(PIC18) 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file (in ROM) 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -  File renamed successfully 
....................     -1 - File could not be renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the file with the ascii ROM string(PIC18).The Fsrenamepgm 
....................     function will copy the rom fileName specified by the user into a  
....................     RAM array and pass that array into the FSrename function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM.                        
....................   *****************************************************************/ 
....................  
....................         int FSrenamepgm (const rom char * fileName, FSFILE * fo); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************ 
....................   Function: 
....................     int FSfclose(FSFILE *fo) 
....................   Summary: 
....................     Update file information and free FSFILE objects 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to the file to close 
....................   Return Values: 
....................     0 -   File closed successfully  
....................     EOF - Error closing the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will update the directory entry for the  
....................     file pointed to by 'fo' with the information contained 
....................     in 'fo,' including the new file size and attributes. 
....................     Timestamp information will also be loaded based on the 
....................     method selected by the user and written to the entry 
....................     as the last modified time and date.  The file entry will 
....................     then be written to the device.  Finally, the memory 
....................     used for the specified file object will be freed from 
....................     the dynamic heap or the array of FSFILE objects. 
....................   Remarks: 
....................     A function to flush data to the device without closing the 
....................     file can be created by removing the portion of this 
....................     function that frees the memory and the line that clears 
....................     the write flag. 
....................   ************************************************************/ 
....................  
.................... int FSfclose(FSFILE *fo); 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     void FSrewind (FSFILE * fo) 
....................   Summary: 
....................     Set the current position in a file to the beginning 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The FSrewind funciton will reset the position of the 
....................     specified file to the beginning of the file.  This 
....................     functionality is faster than using FSfseek to reset 
....................     the position in the file. 
....................   Remarks: 
....................     None. 
....................   *********************************************************/ 
....................  
.................... void FSrewind (FSFILE *fo); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Read data from a file 
....................   Conditions: 
....................     File is opened in a read mode 
....................   Input: 
....................     ptr -     Destination buffer for read bytes 
....................     size -    Size of units in bytes 
....................     n -       Number of units to be read 
....................     stream -  File to be read from 
....................   Return: 
....................     size_t - number of units read 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfread function will read data from the specified file.  First, 
....................     the appropriate sector of the file is loaded.  Then, data is read into 
....................     the specified buffer until the specified number of bytes have been read. 
....................     When a cluster boundary is reached, a new cluster will be loaded.  The 
....................     parameters 'size' and 'n' indicate how much data to read.  'Size' 
....................     refers to the size of one object to read (in bytes), and 'n' will refer  
....................     to the number of these objects to read.  The value returned will be equal  
....................     to 'n' unless an error occured or the user tried to read beyond the end 
....................     of the file. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream); 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FSfseek(FSFILE *stream, long offset, int whence) 
....................   Summary: 
....................     Change the current position in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     stream -    Pointer to file structure 
....................     offset -    Offset from base location 
....................     whence -     
....................            - SEEK_SET -  Seek from start of file 
....................            - SEEK_CUR -  Seek from current location 
....................            - SEEK_END -  Seek from end of file (subtract offset) 
....................   Return Values: 
....................     0 -  Operation successful  
....................     -1 - Operation unsuccesful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfseek function will change the current position in the file to 
....................     one specified by the user.  First, an absolute offset is calculated 
....................     using the offset and base location passed in by the user.  Then, the 
....................     position variables are updated, and the sector number that corresponds 
....................     to the new location.  That sector is then loaded.  If the offset 
....................     falls exactly on a cluster boundary, a new cluster will be allocated 
....................     to the file and the position will be set to the first byte of that 
....................     cluster. 
....................   Remarks: 
....................     None                                                                
....................   **********************************************************************/ 
....................  
.................... int FSfseek(FSFILE *stream, long offset, int whence); 
....................  
....................  
.................... /******************************************************************* 
....................   Function: 
....................     long FSftell (FSFILE * fo) 
....................   Summary: 
....................     Determine the current location in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return: Current location in the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     The FSftell function will return the current position in the 
....................     file pointed to by 'fo' by returning the 'seek' variable in the 
....................     FSFILE object, which is used to keep track of the absolute 
....................     location of the current position in the file. 
....................   Remarks: 
....................     None                                                             
....................   *******************************************************************/ 
....................  
.................... long FSftell(FSFILE *fo); 
....................  
....................  
.................... /**************************************************** 
....................   Function: 
....................     int FSfeof( FSFILE * stream ) 
....................   Summary: 
....................     Indicate whether the current file position is at the end 
....................   Conditions: 
....................     File is open in a read mode 
....................   Input: 
....................     stream -  Pointer to the target file 
....................   Return Values: 
....................     Non-Zero - EOF reached  
....................     0 - Not at end of File 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfeof function will indicate that the end-of- 
....................     file has been reached for the specified file by 
....................     comparing the absolute location in the file to the 
....................     size of the file. 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... int FSfeof( FSFILE * stream ); 
....................  
....................  
.................... #ifdef ALLOW_FORMATS 
.................... /******************************************************************* 
....................   Function: 
....................     int FSformat (char mode, long int serialNumber, char * volumeID) 
....................   Summary: 
....................     Formats a device 
....................   Conditions: 
....................     The device must possess a valid master boot record. 
....................   Input: 
....................     mode -          - 0 - Just erase the FAT and root 
....................                     - 1 - Create a new boot sector 
....................     serialNumber -  Serial number to write to the card 
....................     volumeID -      Name of the card 
....................   Return Values: 
....................     0 -    Format was successful 
....................     EOF -  Format was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSformat function can be used to create a new boot sector 
....................     on a device, based on the information in the master boot record. 
....................     This function will first initialize the I/O pins and the device, 
....................     and then attempts to read the master boot record.  If the MBR 
....................     cannot be loaded successfully, the function will fail.  Next, if 
....................     the 'mode' argument is specified as '0' the existing boot sector 
....................     information will be loaded.  If the 'mode' argument is '1' an 
....................     entirely new boot sector will be constructed using the disk 
....................     values from the master boot record.  Once the boot sector has 
....................     been successfully loaded/created, the locations of the FAT and 
....................     root will be loaded from it, and they will be completely 
....................     erased.  If the user has specified a volumeID parameter, a  
....................     VOLUME attribute entry will be created in the root directory 
....................     to name the device. 
....................  
....................     FAT12, FAT16 and FAT32 formatting are supported. 
....................  
....................     Based on the number of sectors, the format function automatically 
....................     compute the smallest possible value for the cluster size in order to 
....................     accommodate the physical size of the media. In this case, if a media  
....................     with a big capacity is formatted, the format function may take a very 
....................     long time to write all the FAT tables.  
....................  
....................     Therefore, the FORMAT_SECTORS_PER_CLUSTER macro may be used to  
....................     specify the exact cluster size (in multiples of sector size). This  
....................     macro can be defined in FSconfig.h 
....................  
....................   Remarks: 
....................     Only devices with a sector size of 512 bytes are supported by the  
....................     format function                       
....................   *******************************************************************/ 
....................  
.................... int FSformat (char mode, long int serialNumber, char * volumeID); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_WRITES 
.................... /*************************************************************************** 
....................   Function: 
....................     int FSattrib (FSFILE * file, unsigned char attributes) 
....................   Summary: 
....................     Change the attributes of a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     file -        Pointer to file structure 
....................     attributes -  The attributes to set for the file 
....................                -  Attribute -      Value - Indications  
....................                -  ATTR_READ_ONLY - 0x01  - The read-only attribute 
....................                -  ATTR_HIDDEN -    0x02  - The hidden attribute  
....................                -  ATTR_SYSTEM -    0x04  - The system attribute  
....................                -  ATTR_ARCHIVE -   0x20  - The archive attribute 
....................   Return Values: 
....................     0 -  Attribute change was successful  
....................     -1 - Attribute change was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSattrib funciton will set the attributes of the specified file 
....................     to the attributes passed in by the user.  This function will load the 
....................     file entry, replace the attributes with the ones specified, and write 
....................     the attributes back.  If the specified file is a directory, the 
....................     directory attribute will be preserved. 
....................   Remarks: 
....................     None                                                                 
....................   ***************************************************************************/ 
....................  
.................... int FSattrib (FSFILE * file, unsigned char attributes); 
....................  
....................  
.................... /*************************************************************** 
....................   Function: 
....................     int FSrename (const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices. 
....................     First, it will search through the current working directory to ensure the 
....................     specified new filename is not already in use. If it isn't, the new filename 
....................     will be written to the file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None                                                         
....................   ***************************************************************/ 
....................  
.................... int FSrename (const char * fileName, FSFILE * fo); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*************************************************************** 
....................   Function: 
....................     int wFSrename (const rom unsigned short int * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices. First, it will search through the current 
....................     working directory to ensure the specified new UTF16 filename is not 
....................     already in use.  If it isn't, the new filename will be written to the 
....................     file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None 
....................   ***************************************************************/ 
....................  
.................... int wFSrename (const unsigned short int * fileName, FSFILE * fo); 
.................... #endif 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     int FSremove (const char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed  
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................     The FSremove function will attempt to find the specified file with the FILEfind 
....................     function.  If the file is found, it will be erased using the FILEerase function. 
....................     The user can also provide ascii alias name of the ascii long file name as the 
....................     input to this function to get it erased from the memory. 
....................   Remarks: 
....................     None                                        
....................   **********************************************************************/ 
....................  
.................... int FSremove (const char * fileName); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     int wFSremove (const unsigned short int * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed 
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................     The wFSremove function will attempt to find the specified UTF16 file 
....................     name with the FILEfind function. If the file is found, it will be erased 
....................     using the FILEerase function. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int wFSremove (const unsigned short int * fileName); 
.................... #endif 
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Write data to a file 
....................   Conditions: 
....................     File opened in FS_WRITE, FS_APPEND, FS_WRITE+, FS_APPEND+, FS_READ+ mode 
....................   Input: 
....................     data_to_write -     Pointer to source buffer 
....................     size -              Size of units in bytes 
....................     n -                 Number of units to transfer 
....................     stream -            Pointer to file structure 
....................   Return: 
....................     size_t - number of units written 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfwrite function will write data to a file.  First, the sector that 
....................     corresponds to the current position in the file will be loaded (if it hasn't 
....................     already been cached in the global data buffer).  Data will then be written to 
....................     the device from the specified buffer until the specified amount has been written. 
....................     If the end of a cluster is reached, the next cluster will be loaded, unless 
....................     the end-of-file flag for the specified file has been set.  If it has, a new 
....................     cluster will be allocated to the file.  Finally, the new position and filesize 
....................     will be stored in the FSFILE object.  The parameters 'size' and 'n' indicate how  
....................     much data to write.  'Size' refers to the size of one object to write (in bytes),  
....................     and 'n' will refer to the number of these objects to write.  The value returned  
....................     will be equal  to 'n' unless an error occured. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************************/ 
....................  
.................... size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream); 
....................  
.................... #endif 
....................  
.................... #ifdef ALLOW_DIRS 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdir (char * path) 
....................   Summary: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC). 
....................     The FSchdir function passes a RAM pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSchdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSchdir (unsigned short int * path) 
....................   Summary: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC).The FSchdir function passes a RAM 
....................     pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSchdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************** 
....................   Function: 
....................     char * FSgetcwd (char * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in Ascii format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in Ascii format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * FSgetcwd (char * path, int numbchars); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************** 
....................   Function: 
....................     char * wFSgetcwd (unsigned short int * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in UTF16 format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in UTF16 format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * wFSgetcwd (unsigned short int * path, int numbchars); 
.................... #endif 
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdir (char * path) 
....................   Summary: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSmkdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSmkdir (unsigned short int * path) 
....................   Summary: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSmkdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdir (char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int FSrmdir (char * path, unsigned char rmsubdirs); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs) 
....................   Summary: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs); 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................  
....................  
.................... /*********************************************************************************************************** 
....................   Function: 
....................     int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second) 
....................   Summary: 
....................     Manually set timestamp variables 
....................   Conditions: 
....................     USERDEFINEDCLOCK macro defined in FSconfig.h. 
....................   Input: 
....................     year -     The year (1980\-2107) 
....................     month -   The month (1\-12) 
....................     day -     The day of the month (1\-31) 
....................     hour -    The hour (0\-23) 
....................     minute -  The minute (0\-59) 
....................     second -  The second (0\-59) 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     Modifies global timing variables 
....................   Description: 
....................     Lets the user manually set the timing variables.  The values passed in will be converted to the format 
....................     used by the FAT timestamps. 
....................   Remarks: 
....................     Call this before creating a file or directory (set create time) and 
....................     before closing a file (set last access time, last modified time)                                         
....................   ***********************************************************************************************************/ 
....................  
.................... int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_FILESEARCH 
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................     The FindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*********************************************************************************** 
....................   Function: 
....................     int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous wFindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent wFindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................     The wFindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec); 
.................... #endif 
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FindNext (SearchRec * rec) 
....................   Summary: 
....................     Sequential search function 
....................   Conditions: 
....................     None 
....................   Input: 
....................     rec -  The structure to store the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No additional files matching the specified criteria were found 
....................   Side Effects: 
....................     Search criteria from previous FindNext call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     The FindNext function performs the same function as the FindFirst 
....................     funciton, except it does not copy any search parameters into the 
....................     SearchRec structure (only info about found files) and it begins 
....................     searching at the last directory entry offset at which a file was 
....................     found, rather than at the beginning of the current working 
....................     directory.If the return value of the function is 0 then "utf16LFNfoundLength" 
....................     indicates whether the file found was long file name or short file 
....................     name(8P3 format). The "utf16LFNfoundLength" is non-zero for long file name 
....................     and is zero for 8P3 format."utf16LFNfound" points to the address of long  
....................     file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling this function 
....................   **********************************************************************/ 
....................  
.................... int FindNext (SearchRec * rec);  
.................... #endif 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int FSfprintf (FSFILE * fptr, const char * fmt, ...) 
....................     // PIC18 
....................     int FSfpritnf (FSFILE * fptr, const rom char * fmt, ...) 
....................   Summary: 
....................     Function to write formatted strings to a file 
....................   Conditions: 
....................     For PIC18, integer promotion must be enabled in the project build 
....................     options menu.  File opened in a write mode. 
....................   Input: 
....................     fptr - A pointer to the file to write to. 
....................     fmt -  A string of characters and format specifiers to write to 
....................            the file 
....................     ... -  Additional arguments inserted in the string by format 
....................            specifiers 
....................   Returns: 
....................     The number of characters written to the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Writes a specially formatted string to a file. 
....................   Remarks: 
....................     Consult AN1045 for a full description of how to use format 
....................     specifiers.         
....................   **********************************************************************/ 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................     #ifdef __18CXX 
....................         int FSfprintf (FSFILE *fptr, const rom char *fmt, ...); 
....................     #else 
....................         int FSfprintf (FSFILE *fptr, const char * fmt, ...); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSerror (void) 
....................   Summary: 
....................     Return an error code for the last function call 
....................   Conditions: 
....................     The return value depends on the last function called. 
....................   Input: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Return Values: 
....................     FSInit       -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The physical media could not be initialized 
....................                  - CE_BAD_SECTOR_READ        The MBR or the boot sector could not be 
....................                                               read correctly 
....................                  - CE_BAD_PARITION           The MBR signature code was incorrect. 
....................                  - CE_NOT_FORMATTED          The boot sector signature code was incorrect or 
....................                                               indicates an invalid number of bytes per sector.  
....................                  - CE_CARDFAT32              The physical media is FAT32 type (only an error  
....................                                               when FAT32 support is disabled).  
....................                  - CE_UNSUPPORTED_FS         The device is formatted with an unsupported file  
....................                                               system (not FAT12 or 16). 
....................     FSfopen      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The device has not been initialized.  
....................                  - CE_TOO_MANY_FILES_OPEN    The function could not allocate any  
....................                                               additional file information to the array  
....................                                               of FSFILE structures or the heap.  
....................                  - CE_INVALID_FILENAME       The file name argument was invalid. 
....................                  - CE_INVALID_ARGUMENT       The user attempted to open a directory in a  
....................                                               write mode or specified an invalid mode argument.  
....................                  - CE_FILE_NOT_FOUND         The specified file (which was to be opened in read  
....................                                               mode) does not exist on the device.  
....................                  - CE_BADCACHEREAD           A read from the device failed. 
....................                  - CE_ERASE_FAIL             The existing file could not be erased (when opening  
....................                                               a file in FS_WRITE mode).  
....................                  - CE_DIR_FULL               The directory is full.  
....................                  - CE_DISK_FULL              The data memory section is full.  
....................                  - CE_WRITE_ERROR            A write to the device failed.  
....................                  - CE_SEEK_ERROR             The current position in the file could not be set to  
....................                                               the end (when the file was opened in FS_APPEND mode). 
....................     FSfclose     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer or the new file 
....................                                               entry information could not be written to the device. 
....................                  - CE_BADCACHEREAD           The file entry information could not be cached 
....................     FSfread      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITEONLY              The file was opened in a write-only mode. 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device.  
....................                  - CE_BAD_SECTOR_READ        The data sector could not be read.  
....................                  - CE_EOF                    The end of the file was reached. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be loaded. 
....................     FSfwrite     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_READONLY               The file was opened in a read-only mode.  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected. 
....................                  - CE_WRITE_ERROR            There was an error writing data to the device. 
....................                  - CE_BADCACHEREAD           The data sector to be modified could not be read from 
....................                                               the device.  
....................                  - CE_DISK_FULL              All data clusters on the device are in use. 
....................     FSfseek      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device.  
....................                  - CE_INVALID_ARGUMENT       The specified offset exceeds the size of the file.  
....................                  - CE_BADCACHEREAD           The sector that contains the new current position  
....................                                               could not be loaded. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be  
....................                                               loaded/allocated. 
....................     FSftell      -  
....................                  - CE_GOOD                   No Error 
....................     FSattrib     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The attribute argument was invalid.  
....................                  - CE_BADCACHEREAD           The existing file entry information could not be  
....................                                               loaded.  
....................                  - CE_WRITE_ERROR            The file entry information could not be written to  
....................                                               the device. 
....................     FSrename     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_FILENOTOPENED          A null file pointer was passed into the function.  
....................                  - CE_INVALID_FILENAME       The file name passed into the function was invalid.  
....................                  - CE_BADCACHEREAD           A read from the device failed.  
....................                  - CE_FILENAME_EXISTS        A file with the specified name already exists.  
....................                  - CE_WRITE_ERROR            The new file entry data could not be written to the  
....................                                               device. 
....................     FSfeof       - 
....................                  - CE_GOOD                   No Error 
....................     FSformat     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The device could not be initialized.  
....................                  - CE_BADCACHEREAD           The master boot record or boot sector could not be  
....................                                               loaded successfully.  
....................                  - CE_INVALID_ARGUMENT       The user selected to create their own boot sector on  
....................                                               a device that has no master boot record, or the mode  
....................                                               argument was invalid.  
....................                  - CE_WRITE_ERROR            The updated MBR/Boot sector could not be written to  
....................                                               the device. 
....................                  - CE_BAD_PARTITION          The calculated number of sectors per clusters was  
....................                                               invalid.  
....................                  - CE_NONSUPPORTED_SIZE      The card has too many sectors to be formatted as  
....................                                               FAT12 or FAT16. 
....................     FSremove     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         The specified file could not be found. 
....................                  - CE_ERASE_FAIL             The file could not be erased. 
....................     FSchdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed or the user tried to  
....................                                               change to a non-directory file. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_FOUND          Could not find a directory in the path. 
....................     FSgetcwd     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The user passed a 0-length buffer into the function. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the current working directory. 
....................     FSmkdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed. 
....................                  - CE_BADCACHEREAD           Could not successfully change to a recently created  
....................                                               directory to store its dir entry information, or  
....................                                               could not cache directory entry information.  
....................                  - CE_INVALID_FILENAME       One or more of the directory names has an invalid  
....................                                               format.  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device or the dot/dotdot entries could  
....................                                               not be written to a newly created directory. 
....................                  - CE_DIR_FULL               There are no available dir entries in the CWD. 
....................                  - CE_DISK_FULL              There are no available clusters in the data region of  
....................                                               the device.     
....................     FSrmdir      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_DIR_NOT_FOUND          The directory specified could not be found or the  
....................                                               function could not change to a subdirectory within  
....................                                               the directory to be deleted (when recursive delete is  
....................                                               enabled). 
....................                  - CE_INVALID_ARGUMENT       The user tried to remove the CWD or root directory.  
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_EMPTY          The directory to be deleted was not empty and  
....................                                               recursive subdirectory removal was disabled.  
....................                  - CE_ERASE_FAIL             The directory or one of the directories or files  
....................                                               within it could not be deleted.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the CWD. 
....................     SetClockVars - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The time values passed into the function were  
....................                                               invalid.     
....................     FindFirst    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found.  
....................                  - CE_BADCACHEREAD           The file information for the file that was found  
....................                                               could not be cached. 
....................     FindNext     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The SearchRec object was not initialized by a call to  
....................                                               FindFirst.  
....................                  - CE_INVALID_ARGUMENT       The SearchRec object was initialized in a different  
....................                                               directory from the CWD. 
....................                  - CE_INVALID_FILENAME       The filename is invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found. 
....................     FSfprintf    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            Characters could not be written to the file.                                                    
....................   Description: 
....................     The FSerror function will return the FSerrno variable.  This global 
....................     variable will have been set to an error value during the last call of a 
....................     library function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... int FSerror (void); 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     int FSCreateMBR (unsigned long firstSector, unsigned long numSectors) 
....................   Summary: 
....................     Creates a master boot record 
....................   Conditions: 
....................     The I/O pins for the device have been initialized by the InitIO function. 
....................   Input: 
....................     firstSector -  The first sector of the partition on the device (cannot 
....................                    be 0; that's the MBR) 
....................     numSectors -   The number of sectors available in memory (including the 
....................                    MBR) 
....................   Return Values: 
....................     0 -   MBR was created successfully 
....................     EOF - MBR could not be created 
....................   Side Effects: 
....................     None 
....................   Description:   
....................     This function can be used to create a master boot record for a device.  Note 
....................     that this function should not be used on a device that is already formatted 
....................     with a master boot record (i.e. most SD cards, CF cards, USB keys).  This 
....................     function will fill the global data buffer with appropriate partition information 
....................     for a FAT partition with a type determined by the number of sectors available 
....................     to the partition.  It will then write the MBR information to the first sector 
....................     on the device.  This function should be followed by a call to FSformat, which 
....................     will create a boot sector, root dir, and FAT appropriate the the information 
....................     contained in the new master boot record.  Note that FSformat only supports 
....................     FAT12 and FAT16 formatting at this time, and so cannot be used to format a 
....................     device with more than 0x3FFD5F sectors. 
....................   Remarks: 
....................     This function can damage the device being used, and should not be called 
....................     unless the user is sure about the size of the device and the first sector value. 
....................   *********************************************************************************/ 
....................  
.................... int FSCreateMBR (unsigned long firstSector, unsigned long numSectors); 
....................  
....................  
.................... #ifdef ALLOW_GET_DISK_PROPERTIES 
.................... /********************************************************************************* 
....................   Function: 
....................     void FSGetDiskProperties(FS_DISK_PROPERTIES* properties) 
....................   Summary: 
....................     Allows user to get the disk properties (size of disk, free space, etc) 
....................   Conditions: 
....................     1) ALLOW_GET_DISK_PROPERTIES must be defined in FSconfig.h 
....................     2) a FS_DISK_PROPERTIES object must be created before the function is called 
....................     3) the new_request member of the FS_DISK_PROPERTIES object must be set before 
....................         calling the function for the first time.  This will start a new search. 
....................     4) this function should not be called while there is a file open.  Close all 
....................         files before calling this function. 
....................   Input: 
....................     properties - a pointer to a FS_DISK_PROPERTIES object where the results should 
....................       be stored. 
....................   Return Values: 
....................     This function returns void.  The properties_status of the previous call of  
....................       this function is located in the properties.status field.  This field has  
....................       the following possible values: 
....................  
....................     FS_GET_PROPERTIES_NO_ERRORS - operation completed without error.  Results 
....................       are in the properties object passed into the function. 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED - there is no mounted disk.  Results in 
....................       properties object is not valid 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE - there was a failure trying to read a  
....................       cluster from the drive.  The results in the properties object is a partial 
....................       result up until the point of the failure. 
....................     FS_GET_PROPERTIES_STILL_WORKING - the search for free sectors is still in 
....................       process.  Continue calling this function with the same properties pointer  
....................       until either the function completes or until the partial results meets the 
....................       application needs.  The properties object contains the partial results of 
....................       the search and can be used by the application.   
....................   Side Effects: 
....................     Can cause errors if called when files are open.  Close all files before 
....................     calling this function. 
....................  
....................     Calling this function without setting the new_request member on the first 
....................     call can result in undefined behavior and results. 
....................  
....................     Calling this function after a result is returned other than 
....................     FS_GET_PROPERTIES_STILL_WORKING can result in undefined behavior and results. 
....................   Description:   
....................     This function returns the information about the mounted drive.  The results  
....................     member of the properties object passed into the function is populated with  
....................     the information about the drive.     
....................  
....................     Before starting a new request, the new_request member of the properties 
....................     input parameter should be set to TRUE.  This will initiate a new search 
....................     request. 
....................  
....................     This function will return before the search is complete with partial results. 
....................     All of the results except the free_clusters will be correct after the first 
....................     call.  The free_clusters will contain the number of free clusters found up 
....................     until that point, thus the free_clusters result will continue to grow until 
....................     the entire drive is searched.  If an application only needs to know that a  
....................     certain number of bytes is available and doesn't need to know the total free  
....................     size, then this function can be called until the required free size is 
....................     verified.  To continue a search, pass a pointer to the same FS_DISK_PROPERTIES 
....................     object that was passed in to create the search. 
....................  
....................     A new search request sould be made once this function has returned a value  
....................     other than FS_GET_PROPERTIES_STILL_WORKING.  Continuing a completed search 
....................     can result in undefined behavior or results. 
....................  
....................     Typical Usage: 
....................     <code> 
....................     FS_DISK_PROPERTIES disk_properties; 
....................  
....................     disk_properties.new_request = TRUE; 
....................  
....................     do 
....................     { 
....................         FSGetDiskProperties(&disk_properties); 
....................     } while (disk_properties.properties_status == FS_GET_PROPERTIES_STILL_WORKING); 
....................     </code> 
....................  
....................     results.disk_format - contains the format of the drive.  Valid results are  
....................       FAT12(1), FAT16(2), or FAT32(3). 
....................  
....................     results.sector_size - the sector size of the mounted drive.  Valid values are 
....................       512, 1024, 2048, and 4096. 
....................  
....................     results.sectors_per_cluster - the number sectors per cluster. 
....................  
....................     results.total_clusters - the number of total clusters on the drive.  This  
....................       can be used to calculate the total disk size (total_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................     results.free_clusters - the number of free (unallocated) clusters on the drive. 
....................       This can be used to calculate the total free disk size (free_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................   Remarks: 
....................     PIC24F size estimates: 
....................       Flash - 400 bytes (-Os setting) 
....................  
....................     PIC24F speed estimates: 
....................       Search takes approximately 7 seconds per Gigabyte of drive space.  Speed 
....................         will vary based on the number of sectors per cluster and the sector size. 
....................   *********************************************************************************/ 
.................... void FSGetDiskProperties(FS_DISK_PROPERTIES* properties); 
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE FILEget_next_cluster(FSFILE *fo, DWORD n) 
....................   Summary: 
....................     Step through a chain of clusters 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fo - The file to get the next cluster of 
....................     n -  Number of links in the FAT cluster chain to jump through 
....................   Return Values: 
....................     CE_GOOD - Operation successful 
....................     CE_BAD_SECTOR_READ - A bad read occured of a sector 
....................     CE_INVALID_CLUSTER - Invalid cluster value \> maxcls 
....................     CE_FAT_EOF - Fat attempt to read beyond EOF 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will load 'n' proximate clusters for a file from 
....................     the FAT on the device.  It will stop checking for clusters if the 
....................     ReadFAT function returns an error, if it reaches the last cluster in 
....................     a file, or if the device tries to read beyond the last cluster used 
....................     by the device. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... BYTE FILEget_next_cluster(FSFILE *fo, DWORD n); 
....................  
.................... #endif 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "string.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = beg; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "ctype.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include "MDD File System/FSDefs.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSDefs.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.2.4 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  _FSDEF__H 
.................... #define  _FSDEF__H 
....................  
.................... #include "../GenericTypeDefs.h" 
....................  
.................... // Summary: An enumeration used for various error codes. 
.................... // Description: The CETYPE enumeration is used to indicate different error conditions during device operation. 
.................... typedef enum _CETYPE 
.................... { 
....................     CE_GOOD = 0,                    // No error 
....................     CE_ERASE_FAIL,                  // An erase failed 
....................     CE_NOT_PRESENT,                 // No device was present 
....................     CE_NOT_FORMATTED,               // The disk is of an unsupported format 
....................     CE_BAD_PARTITION,               // The boot record is bad 
....................     CE_UNSUPPORTED_FS,              // The file system type is unsupported 
....................     CE_INIT_ERROR,                  // An initialization error has occured 
....................     CE_NOT_INIT,                    // An operation was performed on an uninitialized device 
....................     CE_BAD_SECTOR_READ,             // A bad read of a sector occured 
....................     CE_WRITE_ERROR,                 // Could not write to a sector 
....................     CE_INVALID_CLUSTER,             // Invalid cluster value > maxcls 
....................     CE_FILE_NOT_FOUND,              // Could not find the file on the device 
....................     CE_DIR_NOT_FOUND,               // Could not find the directory 
....................     CE_BAD_FILE,                    // File is corrupted 
....................     CE_DONE,                        // No more files in this directory 
....................     CE_COULD_NOT_GET_CLUSTER,       // Could not load/allocate next cluster in file 
....................     CE_FILENAME_2_LONG,             // A specified file name is too long to use 
....................     CE_FILENAME_EXISTS,             // A specified filename already exists on the device 
....................     CE_INVALID_FILENAME,            // Invalid file name 
....................     CE_DELETE_DIR,                  // The user tried to delete a directory with FSremove 
....................     CE_DIR_FULL,                    // All root dir entry are taken 
....................     CE_DISK_FULL,                   // All clusters in partition are taken 
....................     CE_DIR_NOT_EMPTY,               // This directory is not empty yet, remove files before deleting 
....................     CE_NONSUPPORTED_SIZE,           // The disk is too big to format as FAT16 
....................     CE_WRITE_PROTECTED,             // Card is write protected 
....................     CE_FILENOTOPENED,               // File not opened for the write 
....................     CE_SEEK_ERROR,                  // File location could not be changed successfully 
....................     CE_BADCACHEREAD,                // Bad cache read 
....................     CE_CARDFAT32,                   // FAT 32 - card not supported 
....................     CE_READONLY,                    // The file is read-only 
....................     CE_WRITEONLY,                   // The file is write-only 
....................     CE_INVALID_ARGUMENT,            // Invalid argument 
....................     CE_TOO_MANY_FILES_OPEN,         // Too many files are already open 
....................     CE_UNSUPPORTED_SECTOR_SIZE,     // Unsupported sector size 
....................     CE_EOF = 61 
.................... } CETYPE; 
....................  
....................  
.................... // Summary: A macro indicating a dir entry was found 
.................... // Description: The FOUND macro indicates that a directory entry was found in the specified position 
.................... #define FOUND       0 
....................  
.................... // Summary: A macro indicating no dir entry was found 
.................... // Description: The NOT_FOUND macro indicates that the specified directory entry to load was deleted 
.................... #define NOT_FOUND   1 
....................  
.................... // Summary: A macro indicating that no more files were found 
.................... // Description: The NO_MORE macro indicates that there are no more directory entries to search for 
.................... #define NO_MORE     2 
....................  
....................  
....................  
.................... // Summary: A macro indicating the device is formatted with FAT12 
.................... // Description: The FAT12 macro is used to indicate that the file system on the device being accessed is a FAT12 file system. 
.................... #define FAT12       1 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT16 
.................... // Description: The FAT16 macro is used to indicate that the file system on the device being accessed is a FAT16 file system. 
.................... #define FAT16       2 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT32 
.................... // Description: The FAT32 macro is used to indicate that the file system on the device being accessed is a FAT32 file system. 
.................... #define FAT32       3 
....................  
....................  
....................  
.................... // Summary: A read-only attribute macro 
.................... // Description: A macro for the read-only attribute.  A file with this attribute should not be written to.  Note that this 
.................... //              attribute will not actually prevent a write to the file; that functionality is operating-system dependant.  The 
.................... //              user should take care not to write to a read-only file. 
.................... #define ATTR_READ_ONLY      0x01 
....................  
.................... // Summary: A hidden attribute macro 
.................... // Description: A macro for the hidden attribute.  A file with this attribute may be hidden from the user, depending on the 
.................... //              implementation of the operating system. 
.................... #define ATTR_HIDDEN         0x02 
....................  
.................... // Summary: A system attribute macro 
.................... // Description: A macro for the system attribute.  A file with this attribute is used by the operating system, and should not be 
.................... //              modified.  Note that this attribute will not actually prevent a write to the file. 
.................... #define ATTR_SYSTEM         0x04 
....................  
.................... // Summary: A volume attribute macro 
.................... // Description: A macro for the volume attribute.  If the first directory entry in the root directory has the volume attribute set, 
.................... //              the device will use the name in that directory entry as the volume name. 
.................... #define ATTR_VOLUME         0x08 
....................  
.................... // Summary: A macro for the attributes for a long-file name entry 
.................... // Description: A macro for the long-name attributes.  If a directory entry is used in a long-file name implementation, it will have 
.................... //              all four lower bits set.  This indicates that any software that does not support long file names should ignore that 
.................... //              entry. 
.................... #define ATTR_LONG_NAME      0x0f 
....................  
.................... // Summary: A directory attribute macro 
.................... // Description: A macro for the directory attribute.  If a directory entry has this attribute set, the file it points to is a directory- 
.................... //              type file, and will contain directory entries that point to additional directories or files. 
.................... #define ATTR_DIRECTORY      0x10 
....................  
.................... // Summary: An archive attribute macro 
.................... // Description: A macro for the archive attribute.  This attribute will indicate to some archiving programs that the file with this 
.................... //              attribute needs to be backed up.  Most operating systems create files with the archive attribute set. 
.................... #define ATTR_ARCHIVE        0x20 
....................  
.................... // Summary: A macro for all attributes 
.................... // Description: A macro for all attributes.  The search functions in this library require an argument that determines which attributes 
.................... //              a file is allowed to have in order to be found.  If ATTR_MASK is specified as this argument, any file may be found, regardless 
.................... //              of its attributes. 
.................... #define ATTR_MASK           0x3f 
....................  
....................  
....................  
.................... // Summary: A macro to indicate an empty FAT entry 
.................... // Description: The CLUSTER_EMPTY value is used to indicate that a FAT entry and it's corresponding cluster are available. 
.................... #define CLUSTER_EMPTY               0x0000  
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT12 
.................... // Description: The LAST_CLUSTER_FAT12 macro is used when reading the FAT to indicate that the next FAT12 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT12          0xff8 
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT16 
.................... // Description: The LAST_CLUSTER_FAT16 macro is used when reading the FAT to indicate that the next FAT16 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT16          0xfff8 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT12 
.................... // Description: The END_CLUSTER_FAT12 value is used as a comparison in FAT12 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT12           0xFF7 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT16 
.................... // Description: The END_CLUSTER_FAT16 value is used as a comparison in FAT16 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT16           0xFFF7 
....................  
.................... // Summary: A macro to indicate the failure of the ReadFAT function 
.................... // Description: The CLUSTER_FAIL_FAT16 macro is used by the ReadFAT function to indicate that an error occured reading a FAT12 or FAT16 
.................... //              file allocation table.  Note that since '0xFFF8' is used for the last cluster return value in the FAT16 implementation 
.................... //              the end-of-file value '0xFFFF' can be used to indicate an error condition. 
.................... #define CLUSTER_FAIL_FAT16          0xFFFF 
....................  
....................  
....................  
.................... #ifdef SUPPORT_FAT32 
....................     // Summary: A macro to indicate the last cluster value for FAT32 
....................     // Description: The LAST_CLUSTER_FAT32 macro is used when reading the FAT to indicate that the next FAT32 entry for a file contains 
....................     //              the end-of-file value. 
....................     #define LAST_CLUSTER_FAT32      0x0FFFFFF8 
....................  
....................     // Summary: A macro to indicate the last allocatable cluster for FAT32 
....................     // Description: The END_CLUSTER_FAT32 value is used as a comparison in FAT32 to determine that the firmware has reached the end of 
....................     //              the range of allowed allocatable clusters. 
....................     #define END_CLUSTER_FAT32       0x0FFFFFF7 
....................  
....................     // Summary: A macro to indicate the failure of the ReadFAT function 
....................     // Description: The CLUSTER_FAIL_FAT32 macro is used by the ReadFAT function to indicate that an error occured reading a FAT32 
....................     //              file allocation able. 
....................     #define CLUSTER_FAIL_FAT32      0x0FFFFFFF 
....................  
.................... #endif 
....................  
.................... // Summary: A macro indicating the number of bytes in a directory entry. 
.................... // Description: The NUMBER_OF_BYTES_IN_DIR_ENTRY macro represents the number of bytes in one directory entry.  It is used to calculate 
.................... //              the number of sectors in the root directory based on information in the boot sector. 
.................... #define NUMBER_OF_BYTES_IN_DIR_ENTRY    32 
....................  
....................  
....................  
.................... // Summary: A macro for a deleted dir entry marker. 
.................... // Description: The DIR_DEL macro is used to mark a directory entry as deleted.  When a file is deleted, this value will replace the 
.................... //              first character in the file name, and will indicate that the file the entry points to was deleted. 
.................... #define DIR_DEL             0xE5 
....................  
.................... // Summary: A macro for the last dir entry marker. 
.................... // Description: The DIR_EMPTY macro is used to indicate the last entry in a directory.  Since entries in use cannot start with a 0 and 
.................... //              deleted entries start with the DIR_DEL character, a 0 will mark the end of the in-use or previously used group of 
.................... //              entries in a directory 
.................... #define DIR_EMPTY           0 
....................  
....................  
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name 
.................... // Description: The DIR_NAMESIZE macro is used when validing the name portion of 8.3 filenames 
.................... #define DIR_NAMESIZE        8 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file extension 
.................... // Description: The DIR_EXTENSION macro is used when validating the extension portion of 8.3 filenames 
.................... #define DIR_EXTENSION       3 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name and extension 
.................... // Description: The DIR_NAMECOMP macro is used when validating 8.3 filenames 
.................... #define DIR_NAMECOMP        (DIR_NAMESIZE+DIR_EXTENSION) 
....................  
....................  
....................  
.................... // Summary: A macro to write a byte to RAM 
.................... // Description: The RAMwrite macro is used to write a byte of data to a RAM array 
.................... #define RAMwrite( a, f, d) *(a+f) = d 
....................  
.................... // Summary: A macro to read a byte from RAM 
.................... // Description: The RAMread macro is used to read a byte of data from a RAM array 
.................... #define RAMread( a, f)  *(a+f) 
....................  
.................... // Summary: A macro to read a 16-bit word from RAM 
.................... // Description: The RAMreadW macro is used to read two bytes of data from a RAM array 
.................... #define RAMreadW( a, f) *(WORD *)(a+f) 
....................  
.................... // Summary: A macro to read a 32-bit word from RAM 
.................... // Description: The RAMreadD macro is used to read four bytes of data from a RAM array 
.................... #define RAMreadD( a, f) *(DWORD *)(a+f) 
....................  
....................  
....................  
.................... #ifndef EOF 
....................     // Summary: Indicates error conditions or end-of-file conditions 
....................     // Description: The EOF macro is used to indicate error conditions in some function calls.  It is also used to indicate 
....................     //              that the end-of-file has been reached. 
....................     #define EOF             ((int)-1) 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing information about the device. 
.................... // Description: The DISK structure contains information about the device being accessed. 
.................... typedef struct 
.................... {  
....................     BYTE    *   buffer;         // Address of the global data buffer used to read and write file information 
....................     DWORD       firsts;         // Logical block address of the first sector of the FAT partition on the device 
....................     DWORD       fat;            // Logical block address of the FAT 
....................     DWORD       root;           // Logical block address of the root directory 
....................     DWORD       data;           // Logical block address of the data section of the device. 
....................     WORD        maxroot;        // The maximum number of entries in the root directory. 
....................     DWORD       maxcls;         // The maximum number of clusters in the partition. 
....................     DWORD       sectorSize;     // The size of a sector in bytes 
....................     DWORD       fatsize;        // The number of sectors in the FAT 
....................     BYTE        fatcopy;        // The number of copies of the FAT in the partition 
....................     BYTE        SecPerClus;     // The number of sectors per cluster in the data region 
....................     BYTE        type;           // The file system type of the partition (FAT12, FAT16 or FAT32) 
....................     BYTE        mount;          // Device mount flag (TRUE if disk was mounted successfully, FALSE otherwise) 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... } __attribute__ ((packed)) DISK; 
.................... #else 
.................... } DISK; 
.................... #endif 
....................  
....................  
.................... #if defined(__18CXX) && !defined(__CCS__) 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef unsigned short long SWORD; 
.................... #else 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef struct 
....................     { 
....................         unsigned char array[3]; 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) SWORD; 
.................... #else 
....................     } SWORD; 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT12 file system (in the boot sector) 
.................... // Description: The _BPB_FAT12 structure provides a layout of the "bios parameter block" in the boot sector of a FAT12 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BPS;               // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD BootSec_ResrvSec;          // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD BootSec_RootDirEnts;       // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD BootSec_SPF;               // Number of sectors per FAT 
....................     WORD BootSec_SPT;               // Number of sectors per track 
....................     WORD BootSec_HeadCnt;           // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD  BootSec_Reserved;        // Reserved space 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved2;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination    
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT12; 
.................... #else 
....................     } _BPB_FAT12; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT16 file system (in the boot sector) 
.................... // Description: The _BPB_FAT16 structure provides a layout of the "bios parameter block" in the boot sector of a FAT16 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD  BootSec_BPS;              // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD  BootSec_ResrvSec;         // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD  BootSec_RootDirEnts;      // Number of root directory entries 
....................     WORD  BootSec_TotSec16;         // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD  BootSec_SPF;              // Number of sectors per FAT 
....................     WORD  BootSec_SPT;              // Number of sectors per track 
....................     WORD  BootSec_HeadCnt;          // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved;         // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination      
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT16; 
.................... #else 
....................     } _BPB_FAT16; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT32 file system (in the boot sector) 
.................... // Description: The _BPB_FAT32 structure provides a layout of the "bios parameter block" in the boot sector of a FAT32 partition. 
.................... typedef struct { 
....................     SWORD BootSec_jmpBoot;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BytsPerSec;        // Number of bytes per sector 
....................     BYTE  BootSec_SecPerClus;       // Number of sectors per cluster 
....................     WORD BootSec_RsvdSecCnt;        // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_NumFATs;          // Number of FATs on the partition 
....................     WORD BootSec_RootEntCnt;        // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_Media;            // Media descriptor 
....................     WORD BootSec_FATSz16;           // Number of sectors per FAT 
....................     WORD BootSec_SecPerTrk;         // Number of sectors per track 
....................     WORD BootSec_NumHeads;          // Number of heads 
....................     DWORD BootSec_HiddSec;          // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     DWORD BootSec_FATSz32;          // Sectors per FAT (32 bits) 
....................     WORD BootSec_ExtFlags;          // Presently active FAT. Defined by bits 0-3 if bit 7 is 1. 
....................     WORD BootSec_FSVers;            // FAT32 filesystem version.  Should be 0:0 
....................     DWORD BootSec_RootClus;         // Start cluster of the root directory (should be 2) 
....................     WORD BootSec_FSInfo;            // File system information 
....................     WORD BootSec_BkBootSec;         // Backup boot sector address. 
....................     BYTE  BootSec_Reserved[12];     // Reserved space 
....................     BYTE  BootSec_DrvNum;           // Drive number 
....................     BYTE  BootSec_Reserved1;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLab[11];       // Volume Label 
....................     BYTE  BootSec_FilSysType[8];    // File system type in ASCII.  Not used for determination   
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT32; 
.................... #else 
....................     } _BPB_FAT32; 
.................... #endif 
....................  
....................  
.................... // Description: A macro for the boot sector bytes per sector value offset 
.................... #define BSI_BPS            11 
....................  
.................... // Description: A macro for the boot sector sector per cluster value offset 
.................... #define BSI_SPC            13 
....................  
.................... // Description: A macro for the boot sector reserved sector count value offset 
.................... #define BSI_RESRVSEC       14 
....................  
.................... // Description: A macro for the boot sector FAT count value offset 
.................... #define BSI_FATCOUNT       16 
....................  
.................... // Description: A macro for the boot sector root directory entry count value offset 
.................... #define BSI_ROOTDIRENTS    17 
....................  
.................... // Description: A macro for the boot sector 16-bit total sector count value offset 
.................... #define BSI_TOTSEC16       19 
....................  
.................... // Description: A macro for the boot sector sectors per FAT value offset 
.................... #define BSI_SPF            22 
....................  
.................... // Description: A macro for the boot sector 32-bit total sector count value offset 
.................... #define BSI_TOTSEC32       32 
....................  
.................... // Description: A macro for the boot sector boot signature offset 
.................... #define BSI_BOOTSIG        38 
....................  
.................... // Description: A macro for the boot sector file system type string offset 
.................... #define BSI_FSTYPE         54 
....................  
.................... // Description: A macro for the boot sector 32-bit sector per FAT value offset 
.................... #define  BSI_FATSZ32       36 
....................  
.................... // Description: A macro for the boot sector start cluster of root directory value offset 
.................... #define  BSI_ROOTCLUS      44 
....................  
.................... // Description: A macro for the FAT32 boot sector boot signature offset 
.................... #define  BSI_FAT32_BOOTSIG 66 
....................  
.................... // Description: A macro for the FAT32 boot sector file system type string offset 
.................... #define  BSI_FAT32_FSTYPE  82 
....................  
....................  
....................  
.................... // Summary: A partition table entry structure. 
.................... // Description: The PTE_MBR structure contains values found in a partition table entry in the MBR of a device. 
.................... typedef struct 
.................... { 
....................     BYTE      PTE_BootDes;            // The boot descriptor (should be 0x00 in a non-bootable device) 
....................     SWORD     PTE_FrstPartSect;       // The cylinder-head-sector address of the first sector of the partition 
....................     BYTE      PTE_FSDesc;             // The file system descriptor 
....................     SWORD     PTE_LstPartSect;        // The cylinder-head-sector address of the last sector of the partition 
....................     DWORD     PTE_FrstSect;           // The logical block address of the first sector of the partition 
....................     DWORD     PTE_NumSect;            // The number of sectors in a partition 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) PTE_MBR; 
.................... #else 
....................     } PTE_MBR; 
.................... #endif 
....................  
....................  
.................... // Summary: A structure of the organization of a master boot record. 
.................... // Description: The _PT_MBR structure has the same form as a master boot record.  When the MBR is loaded from the device, it will 
.................... //              be cast as a _PT_MBR structure so the MBR elements can be accessed. 
.................... typedef struct 
.................... { 
....................     BYTE        ConsChkRtn[446];        // Boot code 
....................     PTE_MBR     Partition0;             // The first partition table entry 
....................     PTE_MBR     Partition1;             // The second partition table entry 
....................     PTE_MBR     Partition2;             // The third partition table entry 
....................     PTE_MBR     Partition3;             // The fourth partition table entry 
....................     BYTE        Signature0;             // MBR signature code - equal to 0x55 
....................     BYTE        Signature1;             // MBR signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... }__attribute__((packed)) _PT_MBR; 
.................... #else 
.................... }_PT_MBR; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _PT_MBR structure 
.................... // Description: The PT_MBR pointer points to a _PT_MBR structure. 
.................... typedef _PT_MBR *  PT_MBR; 
....................  
....................  
....................  
.................... // Summary: A structure of the organization of a boot sector. 
.................... // Description: The _BootSec structure has the same form as a boot sector.  When the boot sector is loaded from the device, it will 
.................... //              be cast as a _BootSec structure so the boot sector elements can be accessed. 
.................... typedef struct 
.................... { 
....................     // A union of different bios parameter blocks 
....................     union 
....................     { 
....................         _BPB_FAT32  FAT_32; 
....................         _BPB_FAT16  FAT_16; 
....................         _BPB_FAT12  FAT_12; 
....................     }FAT; 
....................     BYTE    Reserved[512-sizeof(_BPB_FAT32)-2]; // Reserved space 
....................     BYTE    Signature0;         // Boot sector signature code - equal to 0x55 
....................     BYTE    Signature1;         // Boot sector signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BootSec; 
.................... #else 
....................     } _BootSec; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _BootSec structure 
.................... // Description: The BootSec pointer points to a _BootSec structure. 
.................... typedef _BootSec * BootSec; 
....................  
....................  
....................  
.................... // Summary: A macro indicating the offset for the master boot record 
.................... // Description: FO_MBR is a macro that indicates the addresss of the master boot record on the device.  When the device is initialized 
.................... //              this sector will be read 
.................... #define FO_MBR          0L 
....................  
....................  
....................  
.................... // Summary: A macro for the first boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_0 macro is used to determine that the first byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_0     0x55 
....................  
.................... // Summary: A macro for the second boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_1 macro is used to determine that the second byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_1     0xAA 
....................  
....................  
.................... typedef struct  
.................... { 
....................     BYTE    errorCode; 
....................     union  
....................     { 
....................         BYTE    value; 
....................         struct  
....................         { 
....................             BYTE    sectorSize  : 1; 
....................             BYTE    maxLUN      : 1; 
....................         }   bits; 
....................     } validityFlags; 
....................      
....................     WORD    sectorSize; 
....................     BYTE    maxLUN; 
.................... } MEDIA_INFORMATION; 
....................  
.................... typedef enum 
.................... { 
....................     MEDIA_NO_ERROR,                     // No errors 
....................     MEDIA_DEVICE_NOT_PRESENT,           // The requested device is not present 
....................     MEDIA_CANNOT_INITIALIZE             // Cannot initialize media 
.................... } MEDIA_ERRORS;                 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_FSFPRINTF 
.................... #include "stdarg.h" 
.................... #endif 
....................  
.................... #ifdef FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................       #include "salloc.h" 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef ALLOW_WRITES 
....................    #ifdef ALLOW_FORMATS 
....................       #error Write functions must be enabled to use the format function 
....................    #endif 
....................    #ifdef ALLOW_FSFPRINTF 
....................       #error Write functions must be enabled to use the FSfprintf function 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef USEREALTIMECLOCK 
....................     #ifdef USERDEFINEDCLOCK 
....................         #error Please select only one timestamp clocking mode in FSconfig.h 
....................     #endif 
....................     #ifdef INCREMENTTIMESTAMP 
....................         #error Please select only one timestamp clocking mode in FSconfig.h 
....................     #endif 
.................... #elif defined USERDEFINEDCLOCK 
....................     #ifdef INCREMENTTIMESTAMP 
....................         #error Please select only one timestamp clocking mode in FSconfig.h 
....................     #endif 
.................... #endif 
.................... /*****************************************************************************/ 
.................... /*                         Global Variables                                  */ 
.................... /*****************************************************************************/ 
....................  
.................... #ifndef FS_DYNAMIC_MEM 
....................     FSFILE  gFileArray[FS_MAX_FILES_OPEN];      // Array that contains file information (static allocation) 
....................     BYTE    gFileSlotOpen[FS_MAX_FILES_OPEN];   // Array that indicates which elements of gFileArray are available for use 
....................    #ifdef SUPPORT_LFN 
....................       // Array that stores long file name (static allocation) 
....................       unsigned short int lfnData[FS_MAX_FILES_OPEN][257]; 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef SUPPORT_LFN 
....................    #ifdef ALLOW_FILESEARCH 
....................       // Array that stores long file name for File Search operation (static allocation) 
....................       unsigned short int recordSearchName[257]; 
....................       unsigned short int recordFoundName[257]; 
....................       unsigned short int recordSearchLength; 
....................    #endif 
....................    unsigned short int fileFoundString[261]; 
.................... #endif 
....................  
.................... #if defined(USEREALTIMECLOCK) || defined(USERDEFINEDCLOCK) 
.................... // Timing variables 
.................... BYTE    gTimeCrtMS;     // Global time variable (for timestamps) used to indicate create time (milliseconds) 
.................... WORD    gTimeCrtTime;   // Global time variable (for timestamps) used to indicate create time 
.................... WORD    gTimeCrtDate;   // Global time variable (for timestamps) used to indicate create date 
.................... WORD    gTimeAccDate;   // Global time variable (for timestamps) used to indicate last access date 
.................... WORD    gTimeWrtTime;   // Global time variable (for timestamps) used to indicate last update time 
.................... WORD    gTimeWrtDate;   // Global time variable (for timestamps) used to indicate last update date 
.................... #endif 
....................  
.................... DWORD       gLastFATSectorRead = 0xFFFFFFFF;    // Global variable indicating which FAT sector was read last 
.................... BYTE        gNeedFATWrite = FALSE;              // Global variable indicating that there is information that needs to be written to the FAT 
.................... FSFILE  *   gBufferOwner = NULL;                // Global variable indicating which file is using the data buffer 
.................... DWORD       gLastDataSectorRead = 0xFFFFFFFF;   // Global variable indicating which data sector was read last 
.................... BYTE        gNeedDataWrite = FALSE;             // Global variable indicating that there is information that needs to be written to the data section 
.................... BYTE        nextClusterIsLast = FALSE;          // Global variable indicating that the entries in a directory align with a cluster boundary 
....................  
.................... BYTE    gBufferZeroed = FALSE;      // Global variable indicating that the data buffer contains all zeros 
....................  
.................... DWORD   FatRootDirClusterValue;     // Global variable containing the cluster number of the root dir (0 for FAT12/16) 
....................  
.................... BYTE    FSerrno;                    // Global error variable.  Set to one of many error codes after each function call. 
....................  
.................... DWORD   TempClusterCalc;            // Global variable used to store the calculated value of the cluster of a specified sector. 
.................... BYTE    dirCleared;                 // Global variable used by the "recursive" FSrmdir function to indicate that all subdirectories and files have been deleted from the target directory. 
.................... BYTE    recache = FALSE;            // Global variable used by the "recursive" FSrmdir function to indicate that additional cache reads are needed. 
.................... FSFILE  tempCWDobj;                 // Global variable used to preserve the current working directory information. 
.................... FSFILE  gFileTemp;                  // Global variable used for file operations. 
....................  
.................... FSFILE   cwd;               // Global current working directory 
.................... FSFILE * cwdptr = &cwd;     // Pointer to the current working directory 
....................  
.................... #ifdef __18CXX 
....................     #pragma udata dataBuffer = DATA_BUFFER_ADDRESS 
....................     BYTE gDataBuffer[MEDIA_SECTOR_SIZE];    // The global data sector buffer 
....................     #pragma udata FATBuffer = FAT_BUFFER_ADDRESS 
....................     BYTE gFATBuffer[MEDIA_SECTOR_SIZE];     // The global FAT sector buffer 
....................     #pragma udata 
.................... #endif 
....................  
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................     BYTE __attribute__ ((aligned(4)))   gDataBuffer[MEDIA_SECTOR_SIZE];     // The global data sector buffer 
....................     BYTE __attribute__ ((aligned(4)))   gFATBuffer[MEDIA_SECTOR_SIZE];      // The global FAT sector buffer 
.................... #endif 
....................  
.................... DISK gDiskData;         // Global structure containing device information. 
....................  
.................... /* Global Variables to handle ASCII & UTF16 file operations */ 
.................... char *asciiFilename; 
.................... unsigned short int fileNameLength; 
.................... #ifdef SUPPORT_LFN 
....................    unsigned short int *utf16Filename; 
....................    BOOL   utfModeFileName = FALSE; 
....................    BOOL   twoByteMode = FALSE; 
.................... #endif 
.................... /************************************************************************/ 
.................... /*                        Structures and defines                        */ 
.................... /************************************************************************/ 
....................  
.................... // Directory entry structure 
.................... typedef struct 
.................... { 
....................     char      DIR_Name[DIR_NAMESIZE];           // File name 
....................     char      DIR_Extension[DIR_EXTENSION];     // File extension 
....................     BYTE      DIR_Attr;                         // File attributes 
....................     BYTE      DIR_NTRes;                        // Reserved byte 
....................     BYTE      DIR_CrtTimeTenth;                 // Create time (millisecond field) 
....................     WORD      DIR_CrtTime;                      // Create time (second, minute, hour field) 
....................     WORD      DIR_CrtDate;                      // Create date 
....................     WORD      DIR_LstAccDate;                   // Last access date 
....................     WORD      DIR_FstClusHI;                    // High word of the entry's first cluster number 
....................     WORD      DIR_WrtTime;                      // Last update time 
....................     WORD      DIR_WrtDate;                      // Last update date 
....................     WORD      DIR_FstClusLO;                    // Low word of the entry's first cluster number 
....................     DWORD     DIR_FileSize;                     // The 32-bit file size 
.................... }_DIRENTRY; 
....................  
.................... typedef _DIRENTRY * DIRENTRY;                   // A pointer to a directory entry structure 
....................  
.................... #define DIRECTORY 0x12          // Value indicating that the CreateFileEntry function will be creating a directory 
....................  
.................... #define DIRENTRIES_PER_SECTOR   (MEDIA_SECTOR_SIZE / 32)        // The number of directory entries in a sector 
....................  
.................... // Maximum number of UTF16 words in single Root directory entry 
.................... #define MAX_UTF16_CHARS_IN_LFN_ENTRY      (BYTE)13 
....................  
.................... // Long File Name Entry 
.................... typedef struct 
.................... { 
....................    BYTE LFN_SequenceNo;   // Sequence number, 
....................    BYTE LFN_Part1[10];    // File name part 1 
....................    BYTE LFN_Attribute;    // File attribute 
....................    BYTE LFN_Type;      // LFN Type 
....................    BYTE LFN_Checksum;     // Checksum 
....................    unsigned short int LFN_Part2[6];    // File name part 2 
....................    unsigned short int LFN_Reserved2;   // Reserved for future use 
....................    unsigned short int LFN_Part3[2];     // File name part 3 
.................... }LFN_ENTRY; 
....................  
.................... /* Summary: Possible type of file or directory name. 
.................... ** Description: See the FormatFileName() & FormatDirName() function for more information. 
.................... */ 
.................... typedef enum 
.................... { 
....................     NAME_8P3_ASCII_CAPS_TYPE, 
....................     NAME_8P3_ASCII_MIXED_TYPE, 
....................     NAME_8P3_UTF16_TYPE, // SUBTYPES OF 8P3 UTF16 TYPE 
....................        NAME_8P3_UTF16_ASCII_CAPS_TYPE, 
....................        NAME_8P3_UTF16_ASCII_MIXED_TYPE, 
....................        NAME_8P3_UTF16_NONASCII_TYPE, 
....................     NAME_LFN_TYPE, 
....................     NAME_ERROR 
.................... } FILE_DIR_NAME_TYPE; 
....................  
.................... // internal errors 
.................... #define CE_FAT_EOF            60   // Error that indicates an attempt to read FAT entries beyond the end of the file 
.................... //#define CE_EOF                61   // Error that indicates that the end of the file has been reached 
....................  
.................... typedef FSFILE   * FILEOBJ;         // Pointer to an FSFILE object 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................  
.................... #define _FLAG_MINUS 0x1             // FSfprintf minus flag indicator 
.................... #define _FLAG_PLUS  0x2             // FSfprintf plus flag indicator 
.................... #define _FLAG_SPACE 0x4             // FSfprintf space flag indicator 
.................... #define _FLAG_OCTO  0x8             // FSfprintf octothorpe (hash mark) flag indicator 
.................... #define _FLAG_ZERO  0x10            // FSfprintf zero flag indicator 
.................... #define _FLAG_SIGNED 0x80           // FSfprintf signed flag indicator 
....................  
.................... #ifdef __18CXX 
....................     #define _FMT_UNSPECIFIED 0      // FSfprintf unspecified argument size flag 
....................     #define _FMT_LONG 1             // FSfprintf 32-bit argument size flag 
....................     #define _FMT_SHRTLONG 2         // FSfprintf 24-bit argument size flag 
....................     #define _FMT_BYTE   3           // FSfprintf 8-bit argument size flag 
.................... #else 
....................     #define _FMT_UNSPECIFIED 0      // FSfprintf unspecified argument size flag 
....................     #define _FMT_LONGLONG 1         // FSfprintf 64-bit argument size flag 
....................     #define _FMT_LONG 2             // FSfprintf 32-bit argument size flag 
....................     #define _FMT_BYTE 3             // FSfprintf 8-bit argument size flag 
.................... #endif 
....................  
.................... #ifdef __18CXX 
....................     static const rom char s_digits[] = "0123456789abcdef";      // FSfprintf table of conversion digits 
.................... #else 
....................     static const char s_digits[] = "0123456789abcdef";          // FSfprintf table of conversion digits 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /************************************************************************************/ 
.................... /*                               Prototypes                                         */ 
.................... /************************************************************************************/ 
....................  
.................... DWORD ReadFAT (DISK *dsk, DWORD ccls); 
.................... DIRENTRY Cache_File_Entry( FILEOBJ fo, WORD * curEntry, BYTE ForceRead); 
.................... BYTE Fill_File_Object(FILEOBJ fo, WORD *fHandle); 
.................... DWORD Cluster2Sector(DISK * disk, DWORD cluster); 
.................... DIRENTRY LoadDirAttrib(FILEOBJ fo, WORD *fHandle); 
.................... #ifdef INCREMENTTIMESTAMP 
....................     void IncrementTimeStamp(DIRENTRY dir); 
.................... #elif defined USEREALTIMECLOCK 
....................     void CacheTime (void); 
.................... #endif 
....................  
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................     BYTE ReadByte( BYTE* pBuffer, WORD index ); 
....................     WORD ReadWord( BYTE* pBuffer, WORD index ); 
....................     DWORD ReadDWord( BYTE* pBuffer, WORD index ); 
.................... #endif 
....................  
.................... void FileObjectCopy(FILEOBJ foDest,FILEOBJ foSource); 
.................... FILE_DIR_NAME_TYPE ValidateChars(BYTE mode); 
.................... BYTE FormatFileName( const char* fileName, FILEOBJ fptr, BYTE mode); 
.................... CETYPE FILEfind( FILEOBJ foDest, FILEOBJ foCompareTo, BYTE cmd, BYTE mode); 
.................... CETYPE FILEopen (FILEOBJ fo, WORD *fHandle, char type); 
.................... #if defined(SUPPORT_LFN) 
.................... BOOL Alias_LFN_Object(FILEOBJ fo); 
.................... BYTE Fill_LFN_Object(FILEOBJ fo, LFN_ENTRY *lfno, WORD *fHandle); 
.................... #endif 
....................  
.................... // Write functions 
.................... #ifdef ALLOW_WRITES 
....................     BYTE Write_File_Entry( FILEOBJ fo, WORD * curEntry); 
....................     BYTE flushData (void); 
....................     CETYPE FILEerase( FILEOBJ fo, WORD *fHandle, BYTE EraseClusters); 
....................     BYTE FILEallocate_new_cluster( FILEOBJ fo, BYTE mode); 
....................     BYTE FAT_erase_cluster_chain (DWORD cluster, DISK * dsk); 
....................     DWORD FATfindEmptyCluster(FILEOBJ fo); 
....................     BYTE FindEmptyEntries(FILEOBJ fo, WORD *fHandle); 
....................     BYTE PopulateEntries(FILEOBJ fo, WORD *fHandle, BYTE mode); 
....................     CETYPE FILECreateHeadCluster( FILEOBJ fo, DWORD *cluster); 
....................     BYTE EraseCluster(DISK *disk, DWORD cluster); 
....................     CETYPE CreateFirstCluster(FILEOBJ fo); 
....................     DWORD WriteFAT (DISK *dsk, DWORD ccls, DWORD value, BYTE forceWrite); 
....................     CETYPE CreateFileEntry(FILEOBJ fo, WORD *fHandle, BYTE mode, BOOL createFirstCluster); 
.................... #endif 
....................  
.................... // Directory functions 
.................... #ifdef ALLOW_DIRS 
....................     BYTE GetPreviousEntry (FSFILE * fo); 
....................     BYTE FormatDirName (char * string,FILEOBJ fptr, BYTE mode); 
....................     int CreateDIR (char * path); 
....................     BYTE writeDotEntries (DISK * dsk, DWORD dotAddress, DWORD dotdotAddress); 
....................     int eraseDir (char * path); 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     #ifdef ALLOW_WRITES 
....................         int mkdirhelper (BYTE mode, char * ramptr, const rom char * romptr); 
....................         int rmdirhelper (BYTE mode, char * ramptr, const rom char * romptr, unsigned char rmsubdirs); 
....................     #endif 
.................... int chdirhelper (BYTE mode, char * ramptr, const rom char * romptr); 
.................... #else 
....................     #ifdef ALLOW_WRITES 
....................         int mkdirhelper (BYTE mode, char * ramptr, char * romptr); 
....................         int rmdirhelper (BYTE mode, char * ramptr, char * romptr, unsigned char rmsubdirs); 
....................     #endif 
....................     int chdirhelper (BYTE mode, char * ramptr, char * romptr); 
.................... #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................     #ifdef __18CXX 
....................         int FSvfprintf (auto FSFILE *handle, auto const rom char *formatString, auto va_list ap); 
....................     #else 
....................         int FSvfprintf (FSFILE *handle, const char *formatString, va_list ap); 
....................     #endif 
....................     int FSputc (char c, FSFILE * file); 
....................     unsigned char str_put_n_chars (FSFILE * handle, unsigned char n, char c); 
.................... #endif 
....................  
.................... BYTE DISKmount( DISK *dsk); 
.................... BYTE LoadMBR(DISK *dsk); 
.................... BYTE LoadBootSector(DISK *dsk); 
.................... DWORD GetFullClusterNumber(DIRENTRY entry); 
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     int FSInit(void) 
....................   Summary: 
....................     Function to initialize the device. 
....................   Conditions: 
....................     The physical device should be connected to the microcontroller. 
....................   Input: 
....................     None 
....................   Return Values: 
....................     TRUE -  Initialization successful 
....................     FALSE - Initialization unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function initializes the file system stack & the interfacing device. 
....................     Initializes the static or dynamic memory slots for holding file 
....................     structures. Initializes the device with the DISKmount function. Loads 
....................     MBR and boot sector information. Initializes the current working 
....................     directory to the root directory for the device if directory support 
....................     is enabled. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... int FSInit(void) 
*
021DC:  MOV     W5,[W15++]
.................... { 
....................     int fIndex; 
021DE:  CLR     F72
.................... #ifndef FS_DYNAMIC_MEM 
....................     for( fIndex = 0; fIndex < FS_MAX_FILES_OPEN; fIndex++ ) 
021E0:  CLR     F72
021E2:  MOV     F72,W4
021E4:  CP      W4,#1
021E6:  BRA     GE,21F8
....................         gFileSlotOpen[fIndex] = TRUE; 
021E8:  MOV     #801,W4
021EA:  MOV     F72,W3
021EC:  ADD     W3,W4,W5
021EE:  MOV.B   #1,W0L
021F0:  MOV.B   W0L,[W5]
021F2:  INC     0F72
021F4:  GOTO    21E2
.................... #else 
....................     #ifdef __18CXX 
....................         SRAMInitHeap(); 
....................     #endif 
.................... #endif 
....................  
....................     gBufferZeroed = FALSE; 
021F8:  CLR.B   856
....................     gNeedFATWrite = FALSE; 
021FA:  CLR.B   83F
....................     gLastFATSectorRead = 0xFFFFFFFF; 
021FC:  SETM    84A
021FE:  SETM    84C
....................     gLastDataSectorRead = 0xFFFFFFFF; 
02200:  SETM    850
02202:  SETM    852
....................  
....................     MDD_InitIO(); 
02204:  CALL    EB2
....................  
....................     if(DISKmount(&gDiskData) == CE_GOOD) 
02208:  MOV     #D08,W5
0220A:  MOV     W5,F78
0220C:  CALL    211A
02210:  CP0.B   W0L
02212:  BRA     NZ,22C4
....................     { 
....................     // Initialize the current working directory to the root 
.................... #ifdef ALLOW_DIRS 
....................         cwdptr->dsk = &gDiskData; 
02214:  MOV     904,W4
02216:  ADD     W4,#0,W4
02218:  MOV     W4,W0
0221A:  MOV     W0,W5
0221C:  MOV.B   #8,W0L
0221E:  MOV.B   W0L,[W5]
02220:  MOV.B   #D,W0L
02222:  MOV.B   W0L,[W5+#1]
....................         cwdptr->sec = 0; 
02224:  MOV     #A,W0
02226:  ADD     904,W0
02228:  MOV     W0,W5
0222A:  CLR.B   [W5]
0222C:  MOV.B   #0,W0L
0222E:  MOV.B   W0L,[W5+#1]
....................         cwdptr->pos = 0; 
02230:  MOV     #C,W0
02232:  ADD     904,W0
02234:  MOV     W0,W5
02236:  CLR.B   [W5]
02238:  MOV.B   #0,W0L
0223A:  MOV.B   W0L,[W5+#1]
....................         cwdptr->seek = 0; 
0223C:  MOV     #E,W0
0223E:  ADD     904,W0
02240:  MOV     W0,W5
02242:  CLR.B   [W5]
02244:  MOV.B   #0,W0L
02246:  MOV.B   W0L,[W5+#1]
02248:  MOV.B   #0,W0L
0224A:  MOV.B   W0L,[W5+#2]
0224C:  MOV.B   #0,W0L
0224E:  MOV.B   W0L,[W5+#3]
....................         cwdptr->size = 0; 
02250:  MOV     #12,W0
02252:  ADD     904,W0
02254:  MOV     W0,W5
02256:  CLR.B   [W5]
02258:  MOV.B   #0,W0L
0225A:  MOV.B   W0L,[W5+#1]
0225C:  MOV.B   #0,W0L
0225E:  MOV.B   W0L,[W5+#2]
02260:  MOV.B   #0,W0L
02262:  MOV.B   W0L,[W5+#3]
....................         cwdptr->name[0] = '\\'; 
02264:  MOV     #1C,W0
02266:  ADD     904,W0
02268:  MOV     W0,W5
0226A:  MOV.B   #5C,W0L
0226C:  MOV.B   W0L,[W5]
....................         for (fIndex = 1; fIndex < 11; fIndex++) 
0226E:  MOV     #1,W4
02270:  MOV     W4,F72
02272:  MOV     F72,W4
02274:  CP      W4,#B
02276:  BRA     GE,228A
....................         { 
....................             cwdptr->name[fIndex] = 0x20; 
02278:  MOV     #1C,W0
0227A:  ADD     F72,W0
0227C:  MOV     904,W4
0227E:  ADD     W0,W4,W5
02280:  MOV.B   #20,W0L
02282:  MOV.B   W0L,[W5]
02284:  INC     0F72
02286:  GOTO    2272
....................         } 
....................         cwdptr->entry = 0; 
0228A:  MOV     #28,W0
0228C:  ADD     904,W0
0228E:  MOV     W0,W5
02290:  CLR.B   [W5]
02292:  MOV.B   #0,W0L
02294:  MOV.B   W0L,[W5+#1]
....................         cwdptr->attributes = ATTR_DIRECTORY; 
02296:  MOV     #2C,W0
02298:  ADD     904,W0
0229A:  MOV     W0,W5
0229C:  MOV.B   #10,W0L
0229E:  MOV.B   W0L,[W5]
022A0:  MOV.B   #0,W0L
022A2:  MOV.B   W0L,[W5+#1]
....................         // "FatRootDirClusterValue" indicates the root 
....................         cwdptr->dirclus = FatRootDirClusterValue; 
022A4:  MOV     #2E,W0
022A6:  ADD     904,W0
022A8:  MOV     W0,W5
022AA:  MOV     #858,W4
022AC:  MOV     [W4++],[W5++]
022AE:  MOV     [W4++],[W5++]
....................         cwdptr->dirccls = FatRootDirClusterValue; 
022B0:  MOV     #32,W0
022B2:  ADD     904,W0
022B4:  MOV     W0,W5
022B6:  MOV     #858,W4
022B8:  MOV     [W4++],[W5++]
022BA:  MOV     [W4++],[W5++]
....................    #if defined(SUPPORT_LFN) 
....................       // Initialize default values for LFN support 
....................         cwdptr->AsciiEncodingType = TRUE; 
....................         cwdptr->utf16LFNlength = 0x0000; 
....................    #endif 
.................... #endif 
....................  
....................         FSerrno = 0; 
022BC:  CLR.B   857
....................         return TRUE; 
022BE:  MOV     #1,W4
022C0:  MOV     W4,0
022C2:  BRA     22C6
....................     } 
....................  
....................     return FALSE; 
022C4:  CLR     0
022C6:  MOV     [--W15],W5
022C8:  RETURN  
.................... } 
....................  
....................  
.................... /******************************************************************************** 
....................   Function: 
....................     CETYPE FILEfind (FILEOBJ foDest, FILEOBJ foCompareTo, BYTE cmd, BYTE mode) 
....................   Summary 
....................     Finds a file on the device 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     foDest -       FSFILE object containing information of the file found 
....................     foCompareTo -  FSFILE object containing the name/attr of the file to be 
....................                    found 
....................     cmd - 
....................         -          LOOK_FOR_EMPTY_ENTRY: Search for empty entry. 
....................         -          LOOK_FOR_MATCHING_ENTRY: Search for matching entry. 
....................     mode - 
....................          -         0: Match file exactly with default attributes. 
....................          -         1: Match file to user-specified attributes. 
....................   Return Values: 
....................     CE_GOOD -            File found. 
....................     CE_FILE_NOT_FOUND -  File not found. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The FILEfind function will sequentially cache directory entries within 
....................     the current working directory into the foDest FSFILE object.  If the cmd 
....................     parameter is specified as LOOK_FOR_EMPTY_ENTRY the search will continue 
....................     until an empty directory entry is found. If the cmd parameter is specified 
....................     as LOOK_FOR_MATCHING_ENTRY these entries will be compared to the foCompareTo 
....................     object until a match is found or there are no more entries in the current 
....................     working directory. If the mode is specified a '0' the attributes of the FSFILE 
....................     entries are irrelevant. If the mode is specified as '1' the attributes of the 
....................     foDest entry must match the attributes specified in the foCompareTo file and 
....................     partial string search characters may bypass portions of the comparison. 
....................   Remarks: 
....................     None 
....................   ********************************************************************************/ 
....................  
.................... CETYPE FILEfind( FILEOBJ foDest, FILEOBJ foCompareTo, BYTE cmd, BYTE mode) 
*
036BE:  MOV     W5,[W15++]
*
036C8:  MOV     [W0],[W15++]
036CA:  POP     100C
036CC:  MOV.B   #B,W0L
036CE:  MOV.B   W0L,100E
.................... { 
....................     WORD   attrib, compareAttrib; 
*
036C0:  CLR     1008
036C2:  CLR     100A
036C4:  MOV     #28,W0
036C6:  ADD     1002,W0
....................     WORD   fHandle = foDest->entry;                  // current entry counter 
....................     CETYPE   statusB = CE_FILE_NOT_FOUND; 
....................     BYTE   character,test,state,index; 
*
036D0:  CLR.B   100F
036D2:  CLR.B   1010
036D4:  CLR.B   1011
036D6:  CLR.B   1012
....................  
....................    #if defined(SUPPORT_LFN) 
....................  
....................     LFN_ENTRY lfnObject;   // Long File Name Object 
....................    unsigned char *dst = (unsigned char *)&fileFoundString[0]; 
....................    unsigned short int *templfnPtr = (unsigned short int *)foCompareTo -> utf16LFNptr; 
....................    UINT16_VAL tempShift; 
....................    short int   fileCompareLfnIndex,fileFoundLfnIndex = 0,fileFoundMaxLfnIndex = 0,lfnCountIndex,fileFoundLength = 0; 
....................    BOOL  lfnFirstCheck = FALSE,foundSFN,foundLFN,fileFoundDotPosition = FALSE,fileCompareDotPosition; 
....................    BYTE  lfnCompareMaxSequenceNum = 0,lfnFoundMaxSequenceNum,reminder = 0; 
....................    char  tempDst[13]; 
....................    fileNameLength = foCompareTo->utf16LFNlength; 
....................  
....................    // If 'fileNameLength' is non zero then it means that file name is of LFN format. 
....................    // If 'fileNameLength' is zero then it means that file name is of 8.3 format 
....................    if(fileNameLength) 
....................    { 
....................       // Find out the number of root entries for the given LFN 
....................       reminder = fileNameLength % MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................       index = fileNameLength/MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................       if(reminder || (fileNameLength < MAX_UTF16_CHARS_IN_LFN_ENTRY)) 
....................       { 
....................          index++; 
....................       } 
....................  
....................       // The maximum sequence number of the LFN 
....................       lfnCompareMaxSequenceNum = index; 
....................    } 
....................    #endif 
....................  
....................                                               #ifdef __DEBUG_UART   
....................                                                 PrintROMASCIIStringUART("FILEfind foCompareTo="); 
....................                                                 PrintRAMBytesUART(((unsigned char*)foCompareTo->name), 13); 
....................                                                #endif  
....................  
....................     // reset the cluster 
....................     foDest->dirccls = foDest->dirclus; 
036D8:  MOV     #32,W0
036DA:  ADD     1002,W0
036DC:  MOV     W0,W5
036DE:  MOV     #2E,W0
036E0:  ADD     1002,W0
036E2:  MOV     [W0++],[W5++]
036E4:  MOV     [W0++],[W5++]
....................    // Attribute to be compared as per application layer request 
....................     compareAttrib = 0xFFFF ^ foCompareTo->attributes; 
036E6:  MOV     #2C,W0
036E8:  ADD     1004,W0
036EA:  MOV     W0,W4
036EC:  MOV     [W4],W0
036EE:  MOV     W0,W4
036F0:  MOV     #FFFF,W0
036F2:  XOR     W0,W4,W0
036F4:  MOV     W0,100A
....................  
....................     if (fHandle == 0) 
036F6:  CP0     100C
036F8:  BRA     NZ,3718
....................     { 
....................         if (Cache_File_Entry(foDest, &fHandle, TRUE) == NULL) 
036FA:  MOV.B   #1,W0L
036FC:  MOV.B   W0L,102C
036FE:  PUSH    1002
03700:  POP     1028
03702:  MOV     #100C,W4
03704:  MOV     W4,102A
03706:  CALL    31E4
0370A:  MOV     W0,W5
0370C:  CP0     W5
0370E:  BRA     NZ,3714
....................         { 
....................             statusB = CE_BADCACHEREAD; 
03710:  MOV.B   #1B,W0L
03712:  MOV.B   W0L,100E
....................         } 
....................     } 
03714:  GOTO    373A
....................     else 
....................     { 
....................       // Maximum 16 entries possible 
....................         if ((fHandle & MASK_MAX_FILE_ENTRY_LIMIT_BITS) != 0) 
03718:  MOV     100C,W0
0371A:  AND     W0,#F,W5
0371C:  CP0     W5
0371E:  BRA     Z,373A
....................         { 
....................             if (Cache_File_Entry (foDest, &fHandle, TRUE) == NULL) 
03720:  MOV.B   #1,W0L
03722:  MOV.B   W0L,102C
03724:  PUSH    1002
03726:  POP     1028
03728:  MOV     #100C,W4
0372A:  MOV     W4,102A
0372C:  CALL    31E4
03730:  MOV     W0,W5
03732:  CP0     W5
03734:  BRA     NZ,373A
....................             { 
....................                 statusB = CE_BADCACHEREAD; 
03736:  MOV.B   #1B,W0L
03738:  MOV.B   W0L,100E
....................             } 
....................         } 
....................     } 
....................  
....................     if (statusB != CE_BADCACHEREAD) 
0373A:  MOV     100E,W4
0373C:  CP.B    W4L,#1B
0373E:  BRA     Z,395C
....................     { 
....................         // Loop until you reach the end or find the file 
....................         while(1) 
....................         { 
....................             if(statusB != CE_GOOD) //First time entry always here 
03740:  CP0.B   100E
03742:  BRA     Z,3762
....................             { 
....................             #if defined(SUPPORT_LFN) 
....................                foundSFN = FALSE; 
....................                foundLFN = FALSE; 
....................  
....................                    state = Fill_LFN_Object(foDest,&lfnObject,&fHandle); 
....................             #else 
....................                    state = Fill_File_Object(foDest, &fHandle); 
03744:  PUSH    1002
03746:  POP     1018
03748:  MOV     #100C,W4
0374A:  MOV     W4,101A
0374C:  CALL    34D8
03750:  MOV.B   W0L,1011
....................             #endif 
....................  
....................                 if(state == NO_MORE) // Reached the end of available files. Comparision over and file not found so quit. 
03752:  MOV     1010,W4
03754:  LSR     W4,#8,W4
03756:  CP.B    W4L,#2
03758:  BRA     NZ,375E
....................                 { 
....................                     break; 
0375A:  GOTO    395C
....................                 } 
....................             } 
0375E:  GOTO    3766
....................             else // statusB == CE_GOOD then exit 
....................             { 
....................                 break; // Code below intializes"statusB = CE_GOOD;" so, if no problem in the filled file, Exit the while loop. 
03762:  GOTO    395C
....................             } 
....................  
....................             if(state == FOUND) // Validate the correct matching of filled file data with the required(to be found) one. 
03766:  CP0.B   1011
03768:  BRA     NZ,3950
....................             { 
....................             #if defined(SUPPORT_LFN) 
....................  
....................             if(lfnObject.LFN_Attribute != ATTR_LONG_NAME) 
....................             { 
....................                lfnFirstCheck = FALSE; 
....................  
....................                *dst = lfnObject.LFN_SequenceNo; 
....................                for(index = 0;index < 10;index++) 
....................                   dst[index + 1] = lfnObject.LFN_Part1[index]; 
....................                foundSFN = TRUE; 
....................             } 
....................             else 
....................             { 
....................                if(lfnObject.LFN_SequenceNo & 0x40) 
....................                { 
....................                   lfnFoundMaxSequenceNum = lfnObject.LFN_SequenceNo & 0x1F; 
....................  
....................                   if((mode == 0x00) && ((fileNameLength && (lfnFoundMaxSequenceNum != lfnCompareMaxSequenceNum)) || 
....................                      (!fileNameLength && (lfnFoundMaxSequenceNum != 0x01)))) 
....................                   { 
.................... //                     fHandle = fHandle + lfnFoundMaxSequenceNum + 1; 
....................                      fHandle++; 
....................                      continue; 
....................                   } 
....................  
....................                   fileFoundLfnIndex = (lfnObject.LFN_SequenceNo & 0xBF) * MAX_UTF16_CHARS_IN_LFN_ENTRY - 1; 
....................                   fileCompareLfnIndex = fileFoundLfnIndex; 
....................  
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part3[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part3[0]; 
....................  
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[5]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[4]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[3]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[2]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[0]; 
....................  
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[8]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[9]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[6]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[7]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[4]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[5]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[2]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[3]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[0]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................  
....................  
....................                   fileFoundLength = fileCompareLfnIndex + 1; 
....................                   for(index = 1;index <= MAX_UTF16_CHARS_IN_LFN_ENTRY;index++) 
....................                   { 
....................                      if(fileFoundString[fileFoundLfnIndex + index] == 0x0000) 
....................                         fileFoundLength = fileFoundLfnIndex + index; 
....................                   } 
....................  
....................                   if(mode == 0x00) 
....................                   { 
....................                      if((fileNameLength != fileFoundLength) && fileNameLength) 
....................                      { 
.................... //                        fHandle = fHandle + lfnFoundMaxSequenceNum + 1; 
....................                         fHandle++; 
....................                         continue; 
....................                      } 
....................                   } 
....................  
....................                   fileFoundMaxLfnIndex = fileFoundLength - 1; 
....................                   lfnFirstCheck = TRUE; 
....................                } 
....................                else if(lfnFirstCheck == TRUE) 
....................                { 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part3[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part3[0]; 
....................  
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[5]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[4]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[3]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[2]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[0]; 
....................  
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[8]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[9]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[6]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[7]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[4]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[5]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[2]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[3]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[0]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                } 
....................                else 
....................                   { 
....................                      fHandle++; 
....................                   continue; 
....................                } 
....................  
....................                   if(fileFoundLfnIndex > 0) 
....................                   { 
....................                      fHandle++; 
....................                   continue; 
....................                } 
....................  
....................                foundLFN = TRUE; 
....................             } 
....................  
....................             lfnFirstCheck = FALSE; 
....................             statusB = CE_GOOD; 
....................                  switch (mode) 
....................                  { 
....................                      case 0: 
....................  
....................                      // Copy the contents of any SFN found to temporary string 
....................                      // for future comparision tests 
....................                      for(index = 0;index < FILE_NAME_SIZE_8P3;index++) 
....................                         tempDst[index] = dst[index]; 
....................  
....................                      // Try to deduce the original name from the found SFN 
....................                      if(dst[8] != ' ') 
....................                      { 
....................                         for(index = 0;index < 8;index++) 
....................                         { 
....................                            if(dst[index] == ' ') 
....................                               break; 
....................                         } 
....................                         tempDst[index++] = '.'; 
....................                         tempDst[index++] = dst[8]; 
....................  
....................                         if(dst[9] != ' ') 
....................                            tempDst[index++] = dst[9]; 
....................                         else 
....................                            tempDst[index++] = 0x00; 
....................  
....................                         if(dst[10] != ' ') 
....................                            tempDst[index++] = dst[10]; 
....................                         else 
....................                            tempDst[index++] = 0x00; 
....................                      } 
....................                            else 
....................                      { 
....................                               for(index = 0;index < 8;index++) 
....................                         { 
....................                            if(tempDst[index] == ' ') 
....................                               break; 
....................                         } 
....................                      } 
....................  
....................                      // Terminate the string using the NULL value 
....................                      tempDst[index] = 0x00; 
....................  
....................                             if(fileNameLength) 
....................                             { 
....................                               if(foundLFN) 
....................                               { 
....................                                  // see if we are a volume id or hidden, ignore 
....................                                  // search for one. if status = TRUE we found one 
....................                                  for(fileCompareLfnIndex = 0;fileCompareLfnIndex < fileNameLength;fileCompareLfnIndex++) 
....................                                  { 
....................                                 if(foCompareTo -> AsciiEncodingType) 
....................                                 { 
....................                                            // get the source character 
....................                                            character = (BYTE)templfnPtr[fileCompareLfnIndex]; 
....................                                            // get the destination character 
....................                                            test = (BYTE)fileFoundString[fileCompareLfnIndex]; 
....................                                            if((fileFoundString[fileCompareLfnIndex] > 0xFF) || (tolower(character) != tolower(test))) 
....................                                            { 
....................                                              statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                              break; 
....................                                            } 
....................                                 } 
....................                                 else 
....................                                 { 
....................                                    if(templfnPtr[fileCompareLfnIndex] != fileFoundString[fileCompareLfnIndex]) 
....................                                    { 
....................                                            statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                                    } 
....................                                 } 
....................                                  }// for loop 
....................                         } 
....................                         else if(foundSFN && foCompareTo -> AsciiEncodingType) 
....................                         { 
....................                                  if(strlen(tempDst) != fileNameLength) 
....................                                     statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                  else 
....................                                  { 
....................                                     for(fileCompareLfnIndex = 0;fileCompareLfnIndex < fileNameLength;fileCompareLfnIndex++) 
....................                                     { 
....................                                        // get the source character 
....................                                        character = (BYTE)templfnPtr[fileCompareLfnIndex]; 
....................                                        // get the destination character 
....................                                        test = tempDst[fileCompareLfnIndex]; 
....................                                        if(tolower(character) != tolower(test)) 
....................                                        { 
....................                                           statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                           break; 
....................                                        } 
....................                                     }// for loop 
....................                            } 
....................                         } 
....................                         else 
....................                         { 
....................                                  statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                         } 
....................                      } 
....................                      else 
....................                             { 
....................                              if(foundLFN) 
....................                              { 
....................                                  if(strlen(tempDst) != fileFoundLength) 
....................                                     statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                  else 
....................                                  { 
....................                                     for(fileCompareLfnIndex = 0;fileCompareLfnIndex < fileFoundLength;fileCompareLfnIndex++) 
....................                                     { 
....................                                        // get the source character 
....................                                        character = (BYTE)fileFoundString[fileCompareLfnIndex]; 
....................                                        // get the destination character 
....................                                        test = tempDst[fileCompareLfnIndex]; 
....................                                        if((fileFoundString[fileCompareLfnIndex] > 0xFF) || (tolower(character) != tolower(test))) 
....................                                        { 
....................                                           statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                           break; 
....................                                        } 
....................                                     }// for loop 
....................                            } 
....................                              } 
....................                              else 
....................                              { 
....................                                  // search for one. if status = TRUE we found one 
....................                                  for(index = 0; index < DIR_NAMECOMP; index++) 
....................                                  { 
....................                                      // get the source character 
....................                                      character = dst[index]; 
....................                                      // get the destination character 
....................                                      test = foCompareTo->name[index]; 
....................                                      if(tolower(character) != tolower(test)) 
....................                                      { 
....................                                          statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                          break; 
....................                                      } 
....................                                  }// for loop 
....................                         } 
....................                      } 
....................                            break; 
....................  
....................                      case 1: 
....................                      if(fileNameLength) 
....................                             { 
....................                         fileFoundDotPosition = FALSE; 
....................                         if(foundLFN) 
....................                         { 
....................                            lfnCountIndex = fileFoundMaxLfnIndex; 
....................                            while(lfnCountIndex > 0) 
....................                            { 
....................                               if(fileFoundString[lfnCountIndex] == '.') 
....................                               { 
....................                                  fileFoundDotPosition = TRUE; 
....................                                  lfnCountIndex--; 
....................                                  break; 
....................                               } 
....................                               lfnCountIndex--; 
....................                            } 
....................  
....................                            if(fileFoundDotPosition == FALSE) 
....................                               lfnCountIndex = fileFoundMaxLfnIndex; 
....................                         } 
....................                         else 
....................                         { 
....................                            if(dst[DIR_NAMESIZE] != ' ') 
....................                               fileFoundDotPosition = TRUE; 
....................                            lfnCountIndex = DIR_NAMESIZE - 1; 
....................                         } 
....................  
....................                         fileFoundLfnIndex = fileNameLength - 1; 
....................                         fileCompareDotPosition = FALSE; 
....................                         while(fileFoundLfnIndex > 0) 
....................                         { 
....................                            if(templfnPtr[fileFoundLfnIndex] == '.') 
....................                            { 
....................                               fileCompareDotPosition = TRUE; 
....................                               fileFoundLfnIndex--; 
....................                               break; 
....................                            } 
....................                            fileFoundLfnIndex--; 
....................                         } 
....................                         if(fileCompareDotPosition == FALSE) 
....................                            fileFoundLfnIndex = fileNameLength - 1; 
....................  
....................                                // Check for attribute match 
....................                                for(fileCompareLfnIndex = 0;;) 
....................                                { 
....................                                   if (templfnPtr[fileCompareLfnIndex] == '*') 
....................                                      break; 
....................  
....................                            if(fileCompareLfnIndex > lfnCountIndex) 
....................                                    { 
....................                                       statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                                    } 
....................  
....................                                   if (templfnPtr[fileCompareLfnIndex] != '?') 
....................                                   { 
....................                                 if(foCompareTo -> AsciiEncodingType) 
....................                                 { 
....................                                          // get the source character 
....................                                          character = (BYTE)templfnPtr[fileCompareLfnIndex]; 
....................                                          // get the destination character 
....................                                          if(foundLFN) 
....................                                             test = (BYTE)fileFoundString[fileCompareLfnIndex]; 
....................                                  else 
....................                                             test = dst[fileCompareLfnIndex]; 
....................  
....................                                  if((foundLFN && (fileFoundString[fileCompareLfnIndex] > 0xFF)) || 
....................                                             (tolower(character) != tolower(test))) 
....................                                          { 
....................                                             statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                             break; 
....................                                          } 
....................                                 } 
....................                                 else 
....................                                 { 
....................                                    if((templfnPtr[fileCompareLfnIndex] != fileFoundString[fileCompareLfnIndex]) || foundSFN) 
....................                                    { 
....................                                             statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                                    } 
....................                                 } 
....................                                   } 
....................  
....................                                    fileCompareLfnIndex++; 
....................                                    if(fileCompareLfnIndex > fileFoundLfnIndex) 
....................                                     { 
....................                                         if(fileCompareLfnIndex <= lfnCountIndex) 
....................                                         { 
....................                                          statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                               } 
....................                                         break; 
....................                            } 
....................                                }// for loop 
....................  
....................                         if(fileCompareDotPosition == FALSE) 
....................                         { 
....................                            if(fileFoundDotPosition == TRUE) 
....................                                    { 
....................                                       statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                    } 
....................                            break; 
....................                         } 
....................                         else 
....................                         { 
....................                            if(fileFoundDotPosition == FALSE) 
....................                                    { 
....................                                       statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                                    } 
....................  
....................                            if(foundLFN) 
....................                               lfnCountIndex = lfnCountIndex + 2; 
....................                            else 
....................                               lfnCountIndex = DIR_NAMESIZE; 
....................                         } 
....................  
....................                                // Check for attribute match 
....................                                for(fileCompareLfnIndex = fileFoundLfnIndex + 2;;) 
....................                                { 
....................                                   if (templfnPtr[fileCompareLfnIndex] == '*') 
....................                                      break; 
....................  
....................                            if((foundLFN && (lfnCountIndex > fileFoundMaxLfnIndex)) || (foundSFN && (lfnCountIndex == 11))) 
....................                            { 
....................                                       statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                            } 
....................  
....................                                   if (templfnPtr[fileCompareLfnIndex] != '?') 
....................                                   { 
....................                                 if(foCompareTo -> AsciiEncodingType) 
....................                                 { 
....................                                           // get the source character 
....................                                           character = (BYTE)templfnPtr[fileCompareLfnIndex]; 
....................                                           // get the destination character 
....................                                          if(foundLFN) 
....................                                             test = (BYTE)fileFoundString[lfnCountIndex]; 
....................                                  else 
....................                                             test = dst[lfnCountIndex]; 
....................                                  if((foundLFN && (fileFoundString[lfnCountIndex] > 0xFF)) || 
....................                                             (tolower(character) != tolower(test))) 
....................                                          { 
....................                                             statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                             break; 
....................                                          } 
....................                                 } 
....................                                 else 
....................                                 { 
....................                                    if((templfnPtr[fileCompareLfnIndex] != fileFoundString[lfnCountIndex]) || foundSFN) 
....................                                    { 
....................                                             statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                                    } 
....................                                 } 
....................                                   } 
....................                                    lfnCountIndex++; 
....................                                    fileCompareLfnIndex++; 
....................                                    if(fileCompareLfnIndex == fileNameLength) 
....................                                     { 
....................                                         if((foundLFN && (lfnCountIndex <= fileFoundMaxLfnIndex)) || (foundSFN && (lfnCountIndex < 11) && (dst[lfnCountIndex] != ' '))) 
....................                                         { 
....................                                          statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                               } 
....................                                         break; 
....................                            } 
....................                                }// for loop 
....................                      } 
....................                      else 
....................                      { 
....................                              /* We got something */ 
....................                                if(foundLFN) 
....................                                { 
....................                            fileCompareLfnIndex = fileFoundMaxLfnIndex; 
....................                            fileFoundDotPosition = FALSE; 
....................                            while(fileCompareLfnIndex > 0) 
....................                            { 
....................                               if(fileFoundString[fileCompareLfnIndex] == '.') 
....................                               { 
....................                                  fileFoundDotPosition = TRUE; 
....................                                  fileCompareLfnIndex--; 
....................                                  break; 
....................                               } 
....................                               fileCompareLfnIndex--; 
....................                            } 
....................  
....................                            if(fileFoundDotPosition == FALSE) 
....................                               fileCompareLfnIndex = fileFoundMaxLfnIndex; 
....................                         } 
....................                         else 
....................                            fileCompareLfnIndex = DIR_NAMESIZE - 1;   // Short File name last char position 
....................  
....................                                 if (foCompareTo->name[0] != '*')   //If "*" is passed for comparion as 1st char then don't proceed. Go back, file alreay found. 
....................                                 { 
....................                                     for (index = 0;;) 
....................                                     { 
....................                                         if(foundLFN) 
....................                                         { 
....................                                            if((fileFoundString[index] > 0xFF) || (index > fileCompareLfnIndex)) 
....................                                            { 
....................                                                statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                                break; 
....................                                  } 
....................                               } 
....................  
....................                                         // Get the source character 
....................                                      if(foundLFN) 
....................                                         character = (BYTE)fileFoundString[index]; 
....................                               else 
....................                                         character = dst[index]; 
....................  
....................                                         // Get the destination character 
....................                                         test = foCompareTo->name[index]; 
....................                                         if (test == '*') 
....................                                             break; 
....................                                         if (test != '?') 
....................                                         { 
....................                                             if(tolower(character) != tolower(test)) 
....................                                             { 
....................                                                 statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                                 break; 
....................                                             } 
....................                                         } 
....................  
....................                                       index++; 
....................                                       if(index == DIR_NAMESIZE) 
....................                                        { 
....................                                            if(foundLFN && (index <= fileCompareLfnIndex)) 
....................                                            { 
....................                                                statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                  } 
....................                                             break; 
....................                               } 
....................                                     } 
....................                                 } 
....................  
....................                                 // Before calling this "FILEfind" fn, "formatfilename" must be called. Hence, extn always starts from position "8". 
....................                                 if ((foCompareTo->name[8] != '*') && (statusB == CE_GOOD)) 
....................                                 { 
....................                                     if(foundLFN) 
....................                                     { 
....................                               if(foCompareTo->name[8] == ' ') 
....................                               { 
....................                                  if(fileFoundDotPosition == TRUE) 
....................                                            { 
....................                                                statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                  } 
....................                                  break; 
....................                               } 
....................                               else 
....................                               { 
....................                                  if(fileFoundDotPosition == FALSE) 
....................                                  { 
....................                                                statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                     break; 
....................                                  } 
....................                               } 
....................                               fileCompareLfnIndex = fileCompareLfnIndex + 2; 
....................                            } 
....................                            else 
....................                               fileCompareLfnIndex = DIR_NAMESIZE; 
....................  
....................                                     for (index = 8;;) 
....................                                     { 
....................                                         if(foundLFN) 
....................                                         { 
....................                                            if((fileFoundString[fileCompareLfnIndex] > 0xFF) || (fileCompareLfnIndex > fileFoundMaxLfnIndex)) 
....................                                            { 
....................                                                statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                                break; 
....................                                  } 
....................                               } 
....................                                         // Get the destination character 
....................                                         test = foCompareTo->name[index]; 
....................                                         // Get the source character 
....................                                      if(foundLFN) 
....................                                         character = (BYTE)fileFoundString[fileCompareLfnIndex++]; 
....................                               else 
....................                                         character = dst[fileCompareLfnIndex++]; 
....................  
....................                                         if (test == '*') 
....................                                             break; 
....................                                         if (test != '?') 
....................                                         { 
....................                                             if(tolower(character) != tolower(test)) 
....................                                             { 
....................                                                 statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                                 break; 
....................                                             } 
....................                                         } 
....................  
....................                               index++; 
....................                               if(index == DIR_NAMECOMP) 
....................                               { 
....................                                  if(foundLFN && (fileCompareLfnIndex <= fileFoundMaxLfnIndex)) 
....................                                     statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                  break; 
....................                               } 
....................                                     } 
....................                                 } 
....................                      } 
....................                             break; 
....................               } 
....................  
....................             // If the comparision of each character in LFN is completed 
....................             if(statusB == CE_GOOD) 
....................             { 
....................                if(foundLFN) 
....................                   fHandle++; 
....................  
....................                    state = Fill_File_Object(foDest, &fHandle); 
....................  
....................                if(foundLFN) 
....................                   fHandle--; 
....................  
....................                      /* We got something get the attributes */ 
....................                      attrib = foDest->attributes; 
....................  
....................                      attrib &= ATTR_MASK; 
....................  
....................                      switch (mode) 
....................                      { 
....................                          case 0: 
....................                              // see if we are a volume id or hidden, ignore 
....................                              if(attrib == ATTR_VOLUME) 
....................                                  statusB = CE_FILE_NOT_FOUND; 
....................                              break; 
....................  
....................                          case 1: 
....................                              // Check for attribute match 
....................                              if ((attrib & compareAttrib) != 0) 
....................                                  statusB = CE_FILE_NOT_FOUND; // Indicate the already filled file data is correct and go back 
....................                              if(foundLFN) 
....................                                 foDest->utf16LFNlength = fileFoundLength; 
....................                              else 
....................                         foDest->utf16LFNlength = 0; 
....................                              break; 
....................                      } 
....................             } 
....................             #else 
....................             { 
....................                       /* We got something */ 
....................                       // get the attributes 
....................                       attrib = foDest->attributes; 
0376A:  MOV     #2C,W0
0376C:  ADD     1002,W0
0376E:  MOV     [W0],[W15++]
03770:  POP     1008
....................  
....................                       attrib &= ATTR_MASK; 
03772:  MOV     1008,W4
03774:  AND     #3F,W4
03776:  MOV     W4,1008
....................                       switch (mode) 
03778:  MOV.B   1007,W0L
0377A:  CLR.B   1
0377C:  XOR     #0,W0
0377E:  BRA     Z,3786
03780:  XOR     #1,W0
03782:  BRA     Z,380C
03784:  BRA     394C
....................                       { 
....................                           case 0: 
....................                               // see if we are a volume id or hidden, ignore 
....................                               if(attrib != ATTR_VOLUME) 
03786:  MOV     1008,W4
03788:  CP      W4,#8
0378A:  BRA     Z,3808
....................                               { 
....................                                   statusB = CE_GOOD; 
0378C:  CLR.B   100E
....................                                   character = (BYTE)'m'; // random value 
0378E:  MOV.B   #6D,W0L
03790:  MOV.B   W0L,100F
....................  
....................                                   // search for one. if status = TRUE we found one 
....................                                   for(index = 0; index < DIR_NAMECOMP; index++) 
03792:  CLR.B   1012
03794:  MOV     1012,W4
03796:  CP.B    W4L,#B
03798:  BRA     C,3808
....................                                   { 
....................                                       // get the source character 
....................                                       character = foDest->name[index]; 
0379A:  MOV     #1C,W0
0379C:  ADD.B   1012,W0L
0379E:  ZE      W0,W0
037A0:  CLR.B   1
037A2:  MOV     1002,W4
037A4:  ADD     W0,W4,W0
037A6:  MOV     W0,[W15++]
037A8:  MOV.B   [W0],W0L
037AA:  MOV.B   W0L,100F
037AC:  MOV     [--W15],W0
....................                                       // get the destination character 
....................                                       test = foCompareTo->name[index]; 
037AE:  MOV     #1C,W0
037B0:  ADD.B   1012,W0L
037B2:  ZE      W0,W0
037B4:  CLR.B   1
037B6:  MOV     1004,W4
037B8:  ADD     W0,W4,W0
037BA:  MOV     1010,W4
037BC:  MOV.B   [W0+#0],W4L
037BE:  MOV     W4,1010
....................                                       if(tolower(character) != tolower(test)) 
037C0:  MOV     100E,W4
037C2:  LSR     W4,#8,W4
037C4:  MOV     #41,W3
037C6:  CP.B    W3L,W4L
037C8:  BRA     GTU,37DA
037CA:  MOV     100E,W4
037CC:  LSR     W4,#8,W4
037CE:  MOV     #5A,W3
037D0:  CP.B    W3L,W4L
037D2:  BRA     NC,37DA
037D4:  MOV.B   100F,W0L
037D6:  IOR.B   #20,W0L
037D8:  BRA     37DC
037DA:  MOV.B   100F,W0L
037DC:  MOV.B   W0L,W5L
037DE:  MOV     1010,W4
037E0:  MOV     #41,W3
037E2:  CP.B    W3L,W4L
037E4:  BRA     GTU,37F4
037E6:  MOV     1010,W4
037E8:  MOV     #5A,W3
037EA:  CP.B    W3L,W4L
037EC:  BRA     NC,37F4
037EE:  MOV.B   1010,W0L
037F0:  IOR.B   #20,W0L
037F2:  BRA     37F6
037F4:  MOV.B   1010,W0L
037F6:  CP.B    W5L,W0L
037F8:  BRA     Z,3802
....................                                       { 
....................                                           statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
037FA:  MOV.B   #B,W0L
037FC:  MOV.B   W0L,100E
....................                                           break; 
037FE:  GOTO    3808
....................                                       } 
03802:  INC.B   1012
03804:  GOTO    3794
....................                                   }// for loop 
....................                               } // not dir nor vol 
....................                               break; 
03808:  GOTO    394C
....................  
....................                           case 1: 
....................                               // Check for attribute match 
....................                               if (((attrib & compareAttrib) == 0) && (attrib != ATTR_LONG_NAME)) 
0380C:  MOV     1008,W0
0380E:  AND     100A,W0
03810:  MOV     W0,W5
03812:  CP0     W5
03814:  BRA     NZ,3948
03816:  MOV     1008,W4
03818:  CP      W4,#F
0381A:  BRA     Z,3948
....................                               { 
....................                                               #ifdef __DEBUG_UART   
....................                                                 PrintROMASCIIStringUART(" CHK_foCompareTo="); 
....................                                                 PrintRAMBytesUART(((unsigned char*)foCompareTo->name), 13); 
....................                                                 PrintROMASCIIStringUART(" foGot="); 
....................                                                 PrintRAMBytesUART(((unsigned char*)foDest->name), 13); 
....................                                                #endif   
....................                                                 
....................                                   statusB = CE_GOOD;                 // Indicate the already filled file data is correct and go back 
0381C:  CLR.B   100E
....................                                   character = (BYTE)'m';             // random value 
0381E:  MOV.B   #6D,W0L
03820:  MOV.B   W0L,100F
....................                                   if (foCompareTo->name[0] != '*')   //If "*" is passed for comparion as 1st char then don't proceed. Go back, file alreay found. 
03822:  MOV     #1C,W0
03824:  ADD     1004,W0
03826:  MOV.B   [W0],W4L
03828:  XOR.B   #2A,W4L
0382A:  BRA     Z,38B2
....................                                   { 
....................                                       for (index = 0; index < DIR_NAMESIZE; index++) 
0382C:  CLR.B   1012
0382E:  MOV     1012,W4
03830:  CP.B    W4L,#8
03832:  BRA     C,38B2
....................                                       { 
....................                                           // Get the source character 
....................                                           character = foDest->name[index]; 
03834:  MOV     #1C,W0
03836:  ADD.B   1012,W0L
03838:  ZE      W0,W0
0383A:  CLR.B   1
0383C:  MOV     1002,W4
0383E:  ADD     W0,W4,W0
03840:  MOV     W0,[W15++]
03842:  MOV.B   [W0],W0L
03844:  MOV.B   W0L,100F
03846:  MOV     [--W15],W0
....................                                           // Get the destination character 
....................                                           test = foCompareTo->name[index]; 
03848:  MOV     #1C,W0
0384A:  ADD.B   1012,W0L
0384C:  ZE      W0,W0
0384E:  CLR.B   1
03850:  MOV     1004,W4
03852:  ADD     W0,W4,W0
03854:  MOV     1010,W4
03856:  MOV.B   [W0+#0],W4L
03858:  MOV     W4,1010
....................                                           if (test == '*') 
0385A:  MOV     1010,W4
0385C:  XOR.B   #2A,W4L
0385E:  BRA     NZ,3864
....................                                               break; 
03860:  GOTO    38B2
....................                                           if (test != '?') 
03864:  MOV     1010,W4
03866:  XOR.B   #3F,W4L
03868:  BRA     Z,38AC
....................                                           { 
....................                                               if(tolower(character) != tolower(test)) 
0386A:  MOV     100E,W4
0386C:  LSR     W4,#8,W4
0386E:  MOV     #41,W3
03870:  CP.B    W3L,W4L
03872:  BRA     GTU,3884
03874:  MOV     100E,W4
03876:  LSR     W4,#8,W4
03878:  MOV     #5A,W3
0387A:  CP.B    W3L,W4L
0387C:  BRA     NC,3884
0387E:  MOV.B   100F,W0L
03880:  IOR.B   #20,W0L
03882:  BRA     3886
03884:  MOV.B   100F,W0L
03886:  MOV.B   W0L,W5L
03888:  MOV     1010,W4
0388A:  MOV     #41,W3
0388C:  CP.B    W3L,W4L
0388E:  BRA     GTU,389E
03890:  MOV     1010,W4
03892:  MOV     #5A,W3
03894:  CP.B    W3L,W4L
03896:  BRA     NC,389E
03898:  MOV.B   1010,W0L
0389A:  IOR.B   #20,W0L
0389C:  BRA     38A0
0389E:  MOV.B   1010,W0L
038A0:  CP.B    W5L,W0L
038A2:  BRA     Z,38AC
....................                                               { 
....................                                               #ifdef __DEBUG_UART   
....................                                                 PrintROMASCIIStringUART(" !NAMEMATCH!"); 
....................                                                #endif 
....................                                                   statusB = CE_FILE_NOT_FOUND; // it's not a match 
038A4:  MOV.B   #B,W0L
038A6:  MOV.B   W0L,100E
....................                                                   break; 
038A8:  GOTO    38B2
....................                                               } 
....................                                           } 
038AC:  INC.B   1012
038AE:  GOTO    382E
....................                                       } 
....................                                   } 
....................  
....................                                   // Before calling this "FILEfind" fn, "formatfilename" must be called. Hence, extn always starts from position "8".                                  
....................                                   if ((foCompareTo->name[8] != '*') && (statusB == CE_GOOD)) 
038B2:  MOV     #24,W0
038B4:  ADD     1004,W0
038B6:  MOV.B   [W0],W4L
038B8:  XOR.B   #2A,W4L
038BA:  BRA     Z,3948
038BC:  CP0.B   100E
038BE:  BRA     NZ,3948
....................                                   { 
....................                                       for (index = 8; index < DIR_NAMECOMP; index++) 
038C0:  MOV.B   #8,W0L
038C2:  MOV.B   W0L,1012
038C4:  MOV     1012,W4
038C6:  CP.B    W4L,#B
038C8:  BRA     C,3948
....................                                       { 
....................                                           // Get the source character 
....................                                           character = foDest->name[index]; 
038CA:  MOV     #1C,W0
038CC:  ADD.B   1012,W0L
038CE:  ZE      W0,W0
038D0:  CLR.B   1
038D2:  MOV     1002,W4
038D4:  ADD     W0,W4,W0
038D6:  MOV     W0,[W15++]
038D8:  MOV.B   [W0],W0L
038DA:  MOV.B   W0L,100F
038DC:  MOV     [--W15],W0
....................                                           // Get the destination character 
....................                                           test = foCompareTo->name[index]; 
038DE:  MOV     #1C,W0
038E0:  ADD.B   1012,W0L
038E2:  ZE      W0,W0
038E4:  CLR.B   1
038E6:  MOV     1004,W4
038E8:  ADD     W0,W4,W0
038EA:  MOV     1010,W4
038EC:  MOV.B   [W0+#0],W4L
038EE:  MOV     W4,1010
....................                                           if (test == '*') 
038F0:  MOV     1010,W4
038F2:  XOR.B   #2A,W4L
038F4:  BRA     NZ,38FA
....................                                               break; 
038F6:  GOTO    3948
....................                                           if (test != '?') 
038FA:  MOV     1010,W4
038FC:  XOR.B   #3F,W4L
038FE:  BRA     Z,3942
....................                                           { 
....................                                               if(tolower(character) != tolower(test)) 
03900:  MOV     100E,W4
03902:  LSR     W4,#8,W4
03904:  MOV     #41,W3
03906:  CP.B    W3L,W4L
03908:  BRA     GTU,391A
0390A:  MOV     100E,W4
0390C:  LSR     W4,#8,W4
0390E:  MOV     #5A,W3
03910:  CP.B    W3L,W4L
03912:  BRA     NC,391A
03914:  MOV.B   100F,W0L
03916:  IOR.B   #20,W0L
03918:  BRA     391C
0391A:  MOV.B   100F,W0L
0391C:  MOV.B   W0L,W5L
0391E:  MOV     1010,W4
03920:  MOV     #41,W3
03922:  CP.B    W3L,W4L
03924:  BRA     GTU,3934
03926:  MOV     1010,W4
03928:  MOV     #5A,W3
0392A:  CP.B    W3L,W4L
0392C:  BRA     NC,3934
0392E:  MOV.B   1010,W0L
03930:  IOR.B   #20,W0L
03932:  BRA     3936
03934:  MOV.B   1010,W0L
03936:  CP.B    W5L,W0L
03938:  BRA     Z,3942
....................                                               { 
....................                                               #ifdef __DEBUG_UART   
....................                                                 PrintROMASCIIStringUART(" !EXTMATCH!"); 
....................                                                #endif                                               
....................                                                   statusB = CE_FILE_NOT_FOUND; // it's not a match 
0393A:  MOV.B   #B,W0L
0393C:  MOV.B   W0L,100E
....................                                                   break; 
0393E:  GOTO    3948
....................                                               } 
....................                                           } 
03942:  INC.B   1012
03944:  GOTO    38C4
....................                                       } 
....................                                   } 
....................  
....................                               } // Attribute match 
....................  
....................                               break; 
03948:  GOTO    394C
....................                       } 
....................                } 
....................               #endif 
....................             } // not found 
0394C:  GOTO    3956
....................             else 
....................             { 
....................             #if defined(SUPPORT_LFN) 
....................                lfnFirstCheck = FALSE; 
....................             #endif 
....................                 /*** looking for an empty/re-usable entry ***/ 
....................                 if ( cmd == LOOK_FOR_EMPTY_ENTRY) 
03950:  CP0.B   1006
03952:  BRA     NZ,3956
....................                     statusB = CE_GOOD; 
03954:  CLR.B   100E
....................             } // found or not 
....................  
....................          #if defined(SUPPORT_LFN) 
.................... //            if(foundLFN) 
.................... //            fHandle = fHandle + 2; 
.................... //             fHandle++; 
.................... //         else 
....................          #endif 
....................                // increment it no matter what happened 
....................                fHandle++; 
03956:  INC     100C
03958:  GOTO    3740
....................  
....................         }// while 
....................     } 
....................      
....................                                               #ifdef __DEBUG_UART   
....................                                                 PrintROMASCIIStringUART("FILEfind2 foCompareTo="); 
....................                                                 PrintRAMBytesUART(((unsigned char*)foCompareTo->name), 13); 
....................                                                #endif  
....................      
....................  
....................     return(statusB); 
0395C:  MOV.B   100E,W0L
0395E:  MOV.B   W0L,0
03960:  MOV     [--W15],W5
03962:  RETURN  
.................... } // FILEFind 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     CETYPE FILEopen (FILEOBJ fo, WORD *fHandle, char type) 
....................   Summary: 
....................     Loads file information from the device 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -       File to be opened 
....................     fHandle -  Location of file 
....................     type - 
....................          -     FS_WRITE -  Create a new file or replace an existing file 
....................          -     FS_READ -   Read data from an existing file 
....................          -     FS_APPEND - Append data to an existing file 
....................   Return Values: 
....................     CE_GOOD -            FILEopen successful 
....................     CE_NOT_INIT -        Device is not yet initialized 
....................     CE_FILE_NOT_FOUND -  Could not find the file on the device 
....................     CE_BAD_SECTOR_READ - A bad read of a sector occured 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache a directory entry in the directory specified 
....................     by the dirclus parameter of hte FSFILE object 'fo.'  The offset of the 
....................     entry in the directory is specified by fHandle.  Once the directory entry 
....................     has been loaded, the first sector of the file can be loaded using the 
....................     cluster value specified in the directory entry. The type argument will 
....................     specify the mode the files will be opened in.  This will allow this 
....................     function to set the correct read/write flags for the file. 
....................   Remarks: 
....................     If the mode the file is being opened in is a plus mode (e.g. FS_READ+) the 
....................     flags will be modified further in the FSfopen function. 
....................   **************************************************************************/ 
....................  
.................... CETYPE FILEopen (FILEOBJ fo, WORD *fHandle, char type) 
*
04454:  MOV     W5,[W15++]
04456:  MOV     W6,[W15++]
*
04460:  CLR.B   100C
.................... { 
....................     DISK   *dsk;      //Disk structure 
*
04458:  CLR     1006
....................     BYTE    r;               //Result of search for file 
0445A:  CLR.B   1005
....................     DWORD    l;               //lba of first sector of first cluster 
0445C:  CLR     1008
0445E:  CLR     100A
....................     CETYPE    error = CE_GOOD; 
....................  
....................     dsk = (DISK *)(fo->dsk); 
*
04462:  MOV     1000,W4
04464:  ADD     W4,#0,W4
04466:  MOV     W4,W0
04468:  MOV     [W0],[W15++]
0446A:  POP     1006
....................     if (dsk->mount == FALSE) 
0446C:  MOV     #23,W4
0446E:  MOV     1006,W3
04470:  ADD     W3,W4,W0
04472:  MOV     #A,W1
04474:  MOV     W0,W2
04476:  MOV.B   [W2++],[W1++]
04478:  CP0.B   W5L
0447A:  BRA     NZ,4484
....................     { 
....................         error = CE_NOT_INIT; 
0447C:  MOV.B   #7,W0L
0447E:  MOV.B   W0L,100C
....................     } 
04480:  GOTO    45EC
....................     else 
....................     { 
....................         // load the sector 
....................         fo->dirccls = fo->dirclus; 
04484:  MOV     #32,W0
04486:  ADD     1000,W0
04488:  MOV     W0,W5
0448A:  MOV     #2E,W0
0448C:  ADD     1000,W0
0448E:  MOV     [W0++],[W5++]
04490:  MOV     [W0++],[W5++]
....................         // Cache no matter what if it's the first entry 
....................         if (*fHandle == 0) 
04492:  MOV     1002,W0
04494:  MOV     [W0],W5
04496:  CP0     W5
04498:  BRA     NZ,44B8
....................         { 
....................             if (Cache_File_Entry(fo, fHandle, TRUE) == NULL) 
0449A:  MOV.B   #1,W0L
0449C:  MOV.B   W0L,102C
0449E:  PUSH    1000
044A0:  POP     1028
044A2:  PUSH    1002
044A4:  POP     102A
044A6:  CALL    31E4
044AA:  MOV     W0,W5
044AC:  CP0     W5
044AE:  BRA     NZ,44B4
....................             { 
....................                 error = CE_BADCACHEREAD; 
044B0:  MOV.B   #1B,W0L
044B2:  MOV.B   W0L,100C
....................             } 
....................         } 
044B4:  GOTO    44DC
....................         else 
....................         { 
....................             // If it's not the first, only cache it if it's 
....................             // not divisible by the number of entries per sector 
....................             // If it is, Fill_File_Object will cache it 
....................             if ((*fHandle & 0xf) != 0) 
044B8:  MOV     1002,W0
044BA:  MOV     [W0],W5
044BC:  AND     W5,#F,W5
044BE:  CP0     W5
044C0:  BRA     Z,44DC
....................             { 
....................                 if (Cache_File_Entry (fo, fHandle, TRUE) == NULL) 
044C2:  MOV.B   #1,W0L
044C4:  MOV.B   W0L,102C
044C6:  PUSH    1000
044C8:  POP     1028
044CA:  PUSH    1002
044CC:  POP     102A
044CE:  CALL    31E4
044D2:  MOV     W0,W5
044D4:  CP0     W5
044D6:  BRA     NZ,44DC
....................                 { 
....................                     error = CE_BADCACHEREAD; 
044D8:  MOV.B   #1B,W0L
044DA:  MOV.B   W0L,100C
....................                 } 
....................             } 
....................         } 
....................  
....................         // Fill up the File Object with the information pointed to by fHandle 
....................         r = Fill_File_Object(fo, fHandle); 
044DC:  PUSH    1000
044DE:  POP     1018
044E0:  PUSH    1002
044E2:  POP     101A
044E4:  CALL    34D8
044E8:  MOV.B   W0L,1005
....................         if (r != FOUND) 
044EA:  CP0.B   1005
044EC:  BRA     Z,44F6
....................             error = CE_FILE_NOT_FOUND; 
044EE:  MOV.B   #B,W0L
044F0:  MOV.B   W0L,100C
044F2:  GOTO    45EC
....................         else 
....................         { 
....................             fo->seek = 0;               // first byte in file 
044F6:  MOV     #E,W0
044F8:  ADD     1000,W0
044FA:  MOV     W0,W5
044FC:  CLR.B   [W5]
044FE:  MOV.B   #0,W0L
04500:  MOV.B   W0L,[W5+#1]
04502:  MOV.B   #0,W0L
04504:  MOV.B   W0L,[W5+#2]
04506:  MOV.B   #0,W0L
04508:  MOV.B   W0L,[W5+#3]
....................             fo->ccls = fo->cluster;     // first cluster 
0450A:  MOV     #6,W0
0450C:  ADD     1000,W0
0450E:  MOV     W0,W5
04510:  MOV     #2,W0
04512:  ADD     1000,W0
04514:  MOV     [W0++],[W5++]
04516:  MOV     [W0++],[W5++]
....................             fo->sec = 0;                // first sector in the cluster 
04518:  MOV     #A,W0
0451A:  ADD     1000,W0
0451C:  MOV     W0,W5
0451E:  CLR.B   [W5]
04520:  MOV.B   #0,W0L
04522:  MOV.B   W0L,[W5+#1]
....................             fo->pos = 0;                // first byte in sector/cluster 
04524:  MOV     #C,W0
04526:  ADD     1000,W0
04528:  MOV     W0,W5
0452A:  CLR.B   [W5]
0452C:  MOV.B   #0,W0L
0452E:  MOV.B   W0L,[W5+#1]
....................  
....................             if  ( r == NOT_FOUND) 
04530:  MOV     1004,W4
04532:  LSR     W4,#8,W4
04534:  CP.B    W4L,#1
04536:  BRA     NZ,4540
....................             { 
....................                 error = CE_FILE_NOT_FOUND; 
04538:  MOV.B   #B,W0L
0453A:  MOV.B   W0L,100C
....................             } 
0453C:  GOTO    45AA
....................             else 
....................             { 
....................                 // Determine the lba of the selected sector and load 
....................                 l = Cluster2Sector(dsk,fo->ccls); 
04540:  MOV     #6,W0
04542:  ADD     1000,W0
04544:  MOV     #A,W4
04546:  MOV     [W0++],[W4++]
04548:  MOV     [W0++],[W4++]
0454A:  PUSH    1006
0454C:  POP     1056
0454E:  MOV     W5,1058
04550:  MOV     W6,105A
04552:  CALL    308C
04556:  MOV     W0,1008
04558:  MOV     W1,100A
.................... #ifdef ALLOW_WRITES 
....................                 if (gNeedDataWrite) 
0455A:  CP0.B   854
0455C:  BRA     Z,456C
....................                     if (flushData()) 
0455E:  CALL    3170
04562:  CP0.B   W0L
04564:  BRA     Z,456C
....................                         return CE_WRITE_ERROR; 
04566:  MOV.B   #9,W0L
04568:  MOV.B   W0L,0
0456A:  BRA     45F0
.................... #endif 
....................                 gBufferOwner = fo; 
0456C:  PUSH    1000
0456E:  POP     84E
....................                 if (gLastDataSectorRead != l) 
04570:  MOV     850,W0
04572:  CP      1008
04574:  BRA     NZ,457C
04576:  MOV     852,W0
04578:  CP      100A
0457A:  BRA     Z,45AA
....................                 { 
....................                     gBufferZeroed = FALSE; 
0457C:  CLR.B   856
....................                     if ( !MDD_SectorRead( l, dsk->buffer)) 
0457E:  MOV     1006,W4
04580:  ADD     W4,#0,W4
04582:  MOV     W4,W0
04584:  MOV     #A,W1
04586:  MOV     W0,W2
04588:  REPEAT  #1
0458A:  MOV.B   [W2++],[W1++]
0458C:  PUSH    1008
0458E:  POP     1098
04590:  PUSH    100A
04592:  POP     109A
04594:  MOV     W5,109C
04596:  CALL    1722
0459A:  CP0.B   W0L
0459C:  BRA     NZ,45A2
....................                         error = CE_BAD_SECTOR_READ; 
0459E:  MOV.B   #8,W0L
045A0:  MOV.B   W0L,100C
....................                     gLastDataSectorRead = l; 
045A2:  PUSH    1008
045A4:  POP     850
045A6:  PUSH    100A
045A8:  POP     852
....................                 } 
....................             } // -- found 
....................  
....................             fo->flags.FileWriteEOF = FALSE; 
045AA:  MOV     #16,W0
045AC:  ADD     1000,W0
045AE:  MOV     W0,W5
045B0:  MOV     #FB,W4
045B2:  AND.B   W4L,[W5],[W5]
....................             // Set flag for operation type 
.................... #ifdef ALLOW_WRITES 
....................             if ((type == 'w') || (type == 'a')) 
045B4:  MOV     1004,W4
045B6:  XOR.B   #77,W4L
045B8:  BRA     Z,45C0
045BA:  MOV     1004,W4
045BC:  XOR.B   #61,W4L
045BE:  BRA     NZ,45D8
....................             { 
....................                 fo->flags.write = 1;   //write or append 
045C0:  MOV     #16,W0
045C2:  ADD     1000,W0
045C4:  MOV     W0,W5
045C6:  MOV     #1,W4
045C8:  IOR.B    W4L,  [W5],[W5]
....................                 fo->flags.read = 0; 
045CA:  MOV     #16,W0
045CC:  ADD     1000,W0
045CE:  MOV     W0,W5
045D0:  MOV     #FD,W4
045D2:  AND.B   W4L,[W5],[W5]
....................             } 
045D4:  GOTO    45EC
....................             else 
....................             { 
.................... #endif 
....................                 fo->flags.write = 0;   //read 
045D8:  MOV     #16,W0
045DA:  ADD     1000,W0
045DC:  MOV     W0,W5
045DE:  MOV     #FE,W4
045E0:  AND.B   W4L,[W5],[W5]
....................                 fo->flags.read = 1; 
045E2:  MOV     #16,W0
045E4:  ADD     1000,W0
045E6:  MOV     W0,W5
045E8:  MOV     #2,W4
045EA:  IOR.B    W4L,  [W5],[W5]
.................... #ifdef ALLOW_WRITES 
....................             } // -- flags 
.................... #endif 
....................         } // -- r = Found 
....................     } // -- Mounted 
....................     return (error); 
045EC:  MOV.B   100C,W0L
045EE:  MOV.B   W0L,0
045F0:  MOV     [--W15],W6
045F2:  MOV     [--W15],W5
045F4:  RETURN  
.................... } // -- FILEopen 
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE FILEget_next_cluster(FSFILE *fo, DWORD n) 
....................   Summary: 
....................     Step through a chain of clusters 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fo - The file to get the next cluster of 
....................     n -  Number of links in the FAT cluster chain to jump through 
....................   Return Values: 
....................     CE_GOOD - Operation successful 
....................     CE_BAD_SECTOR_READ - A bad read occured of a sector 
....................     CE_INVALID_CLUSTER - Invalid cluster value \> maxcls 
....................     CE_FAT_EOF - Fat attempt to read beyond EOF 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will load 'n' proximate clusters for a file from 
....................     the FAT on the device.  It will stop checking for clusters if the 
....................     ReadFAT function returns an error, if it reaches the last cluster in 
....................     a file, or if the device tries to read beyond the last cluster used 
....................     by the device. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... BYTE FILEget_next_cluster(FSFILE *fo, DWORD n) 
*
04674:  MOV     W5,[W15++]
04676:  MOV     W6,[W15++]
*
04688:  CLR.B   100C
.................... { 
....................     DWORD         c, c2, ClusterFailValue, LastClustervalue; 
*
04678:  CLR     FFC
0467A:  CLR     FFE
0467C:  CLR     1000
0467E:  CLR     1002
04680:  CLR     1004
04682:  CLR     1006
04684:  CLR     1008
04686:  CLR     100A
....................     BYTE          error = CE_GOOD; 
....................     DISK *      disk; 
*
0468A:  CLR     100E
....................  
....................     disk = fo->dsk; 
0468C:  MOV     FF6,W4
0468E:  ADD     W4,#0,W4
04690:  MOV     W4,W0
04692:  MOV     [W0],[W15++]
04694:  POP     100E
....................  
....................     /* Settings based on FAT type */ 
....................     switch (disk->type) 
04696:  MOV     #22,W4
04698:  MOV     100E,W3
0469A:  ADD     W3,W4,W0
0469C:  MOV     #A,W1
0469E:  MOV     W0,W2
046A0:  MOV.B   [W2++],[W1++]
046A2:  MOV.B   W5L,W0L
046A4:  CLR.B   1
046A6:  XOR     #3,W0
046A8:  BRA     Z,46B0
046AA:  XOR     #1,W0
046AC:  BRA     Z,46C2
046AE:  BRA     46C2
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             LastClustervalue = LAST_CLUSTER_FAT32; 
046B0:  MOV     #FFF8,W4
046B2:  MOV     W4,1008
046B4:  MOV     #FFF,W4
046B6:  MOV     W4,100A
....................             ClusterFailValue  = CLUSTER_FAIL_FAT32; 
046B8:  SETM    1004
046BA:  MOV     #FFF,W4
046BC:  MOV     W4,1006
....................             break; 
046BE:  GOTO    46D0
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
....................             LastClustervalue = LAST_CLUSTER_FAT12; 
....................             ClusterFailValue  = CLUSTER_FAIL_FAT16; 
....................             break; 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             LastClustervalue = LAST_CLUSTER_FAT16; 
046C2:  MOV     #FFF8,W4
046C4:  MOV     W4,1008
046C6:  CLR     100A
....................             ClusterFailValue  = CLUSTER_FAIL_FAT16; 
046C8:  SETM    1004
046CA:  CLR     1006
....................             break; 
046CC:  GOTO    46D0
....................     } 
....................  
....................     // loop n times 
....................     do 
....................     { 
....................         // get the next cluster link from FAT 
....................         c2 = fo->ccls; 
046D0:  MOV     #6,W0
046D2:  ADD     FF6,W0
046D4:  MOV     #1000,W4
046D6:  MOV     [W0++],[W4++]
046D8:  MOV     [W0++],[W4++]
....................         if ( (c = ReadFAT( disk, c2)) == ClusterFailValue) 
046DA:  PUSH    100E
046DC:  POP     1048
046DE:  PUSH    1000
046E0:  POP     104A
046E2:  PUSH    1002
046E4:  POP     104C
046E6:  CALL    2ECC
046EA:  MOV     W0,FFC
046EC:  MOV     W1,FFE
046EE:  MOV     FFC,W0
046F0:  CP      1004
046F2:  BRA     NZ,4702
046F4:  MOV     FFE,W0
046F6:  CP      1006
046F8:  BRA     NZ,4702
....................             error = CE_BAD_SECTOR_READ; 
046FA:  MOV.B   #8,W0L
046FC:  MOV.B   W0L,100C
046FE:  GOTO    4738
....................         else 
....................         { 
....................             // check if cluster value is valid 
....................             if ( c >= disk->maxcls) 
04702:  MOV     100E,W4
04704:  ADD     W4,#14,W4
04706:  MOV     W4,W0
04708:  MOV     #A,W1
0470A:  MOV     W0,W2
0470C:  REPEAT  #3
0470E:  MOV.B   [W2++],[W1++]
04710:  MOV     FFE,W4
04712:  CP      W4,W6
04714:  BRA     NC,4722
04716:  BRA     GTU,471E
04718:  MOV     FFC,W4
0471A:  CP      W4,W5
0471C:  BRA     NC,4722
....................             { 
....................                 error = CE_INVALID_CLUSTER; 
0471E:  MOV.B   #A,W0L
04720:  MOV.B   W0L,100C
....................             } 
....................  
....................             // compare against max value of a cluster in FAT 
....................             // return if eof 
....................             if ( c >= LastClustervalue)    // check against eof 
04722:  MOV     100A,W0
04724:  MOV     FFE,W4
04726:  CP      W4,W0
04728:  BRA     NC,4738
0472A:  BRA     GTU,4734
0472C:  MOV     1008,W0
0472E:  MOV     FFC,W4
04730:  CP      W4,W0
04732:  BRA     NC,4738
....................             { 
....................                 error = CE_FAT_EOF; 
04734:  MOV.B   #3C,W0L
04736:  MOV.B   W0L,100C
....................             } 
....................         } 
....................  
....................         // update the FSFILE structure 
....................         fo->ccls = c; 
04738:  MOV     #6,W0
0473A:  ADD     FF6,W0
0473C:  MOV     W0,W5
0473E:  MOV     #FFC,W4
04740:  MOV     [W4++],[W5++]
04742:  MOV     [W4++],[W5++]
....................  
....................     } while ((--n > 0) && (error == CE_GOOD));// loop end 
04744:  DEC     0FF8
04746:  BTSS.B  42.0
04748:  DEC     0FFA
0474A:  CP0     FF8
0474C:  BRA     NZ,4752
0474E:  CP0     FFA
04750:  BRA     Z,4756
04752:  CP0.B   100C
04754:  BRA     Z,46D0
....................  
....................     return(error); 
04756:  MOV.B   100C,W0L
04758:  MOV.B   W0L,0
0475A:  MOV     [--W15],W6
0475C:  MOV     [--W15],W5
0475E:  RETURN  
.................... } // get next cluster 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     BYTE DISKmount ( DISK *dsk) 
....................   Summary: 
....................     Initialies the device and loads MBR and boot sector information 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -  The disk structure to be initialized. 
....................   Return Values: 
....................     CE_GOOD -       Disk mounted 
....................     CE_INIT_ERROR - Initialization error has occured 
....................     CE_UNSUPPORTED_SECTOR_SIZE - Media sector size bigger than 
....................                 MEDIA_SECTOR_SIZE as defined in FSconfig.h. 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will use the function pointed to by the MDD_MediaInitialize 
....................     function pointer to initialize the device (if any initialization is 
....................     required).  It then attempts to load the master boot record with the 
....................     LoadMBR function and the boot sector with the LoadBootSector function. 
....................     These two functions will be used to initialize a global DISK structure 
....................     that will be used when accessing file information in the future. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... BYTE DISKmount( DISK *dsk) 
*
0211A:  MOV     W5,[W15++]
0211C:  MOV     W6,[W15++]
0211E:  MOV     W7,[W15++]
02120:  CLR.B   F7A
.................... { 
....................     BYTE                error = CE_GOOD; 
....................     MEDIA_INFORMATION   *mediaInformation; 
02122:  CLR     F7C
....................  
....................     dsk->mount = FALSE; // default invalid 
02124:  MOV     #23,W4
02126:  MOV     F78,W3
02128:  ADD     W3,W4,W0
0212A:  MOV     W0,W5
0212C:  CLR.B   W6
0212E:  MOV     W5,W1
02130:  MOV     #C,W2
02132:  MOV.B   [W2++],[W1++]
....................     dsk->buffer = gDataBuffer;    // assign buffer 
02134:  MOV     F78,W4
02136:  ADD     W4,#0,W4
02138:  MOV     W4,W0
0213A:  MOV     W0,W5
0213C:  MOV     #908,W6
0213E:  MOV     W5,W1
02140:  MOV     #C,W2
02142:  REPEAT  #1
02144:  MOV.B   [W2++],[W1++]
....................  
....................     // Initialize the device 
....................     mediaInformation = MDD_MediaInitialize(); 
02146:  CALL    10FE
0214A:  MOV     W0,F7C
....................     if (mediaInformation->errorCode != MEDIA_NO_ERROR) 
0214C:  MOV     #0,W0
0214E:  ADD     F7C,W0
02150:  CP0.B   [W0]
02152:  BRA     Z,2160
....................     { 
....................         error = CE_INIT_ERROR; 
02154:  MOV.B   #6,W0L
02156:  MOV.B   W0L,F7A
....................         FSerrno = CE_INIT_ERROR; 
02158:  MOV.B   #6,W0L
0215A:  MOV.B   W0L,857
....................     } 
0215C:  GOTO    21D0
....................     else 
....................     { 
....................         // If the media initialization routine determined the sector size, 
....................         // check it and make sure we can support it. 
....................         if (mediaInformation->validityFlags.bits.sectorSize) 
02160:  MOV     #1,W0
02162:  ADD     F7C,W0
02164:  MOV.B   [W0],W4L
02166:  BTSS    W4.0
02168:  BRA     21A4
....................         { 
....................          dsk->sectorSize = mediaInformation->sectorSize; 
0216A:  MOV     F78,W4
0216C:  ADD     W4,#18,W4
0216E:  MOV     W4,W0
02170:  MOV     W0,W5
02172:  MOV     #2,W0
02174:  ADD     F7C,W0
02176:  MOV     W0,W4
02178:  MOV     [W4],W0
0217A:  MOV     W0,W6
0217C:  MOV     #0,W7
0217E:  MOV     W5,W1
02180:  MOV     #C,W2
02182:  REPEAT  #1
02184:  MOV.B   [W2++],[W1++]
02186:  CLR.B   [W1++]
02188:  CLR.B   [W1++]
....................             if (mediaInformation->sectorSize > MEDIA_SECTOR_SIZE) 
0218A:  MOV     #2,W0
0218C:  ADD     F7C,W0
0218E:  MOV     [W0],W5
02190:  MOV     #200,W4
02192:  CP      W4,W5
02194:  BRA     C,21A4
....................             { 
....................                 error = CE_UNSUPPORTED_SECTOR_SIZE; 
02196:  MOV.B   #21,W0L
02198:  MOV.B   W0L,F7A
....................                 FSerrno = CE_UNSUPPORTED_SECTOR_SIZE; 
0219A:  MOV.B   #21,W0L
0219C:  MOV.B   W0L,857
....................                 return error; 
0219E:  MOV.B   F7A,W0L
021A0:  MOV.B   W0L,0
021A2:  BRA     21D4
....................             } 
....................         } 
....................  
....................         // Load the Master Boot Record (partition) 
....................         if((error = LoadMBR(dsk)) == CE_GOOD) 
021A4:  PUSH    F78
021A6:  POP     F80
021A8:  CALL    1786
021AC:  MOV.B   W0L,F7A
021AE:  CP0.B   F7A
021B0:  BRA     NZ,21D0
....................         { 
....................             // Now the boot sector 
....................             if((error = LoadBootSector(dsk)) == CE_GOOD) 
021B2:  PUSH    F78
021B4:  POP     F80
021B6:  CALL    1B3A
021BA:  MOV.B   W0L,F7A
021BC:  CP0.B   F7A
021BE:  BRA     NZ,21D0
....................                 dsk->mount = TRUE; // Mark that the DISK mounted successfully 
021C0:  MOV     #23,W4
021C2:  MOV     F78,W3
021C4:  ADD     W3,W4,W0
021C6:  MOV     W0,W5
021C8:  MOV.B   #1,W6L
021CA:  MOV     W5,W1
021CC:  MOV     #C,W2
021CE:  MOV.B   [W2++],[W1++]
....................         } 
....................     } // -- Load file parameters 
....................  
....................     return(error); 
021D0:  MOV.B   F7A,W0L
021D2:  MOV.B   W0L,0
021D4:  MOV     [--W15],W7
021D6:  MOV     [--W15],W6
021D8:  MOV     [--W15],W5
021DA:  RETURN  
.................... } // -- mount 
....................  
....................  
....................  
.................... /******************************************************************** 
....................   Function: 
....................     CETYPE LoadMBR ( DISK *dsk) 
....................   Summary: 
....................     Loads the MBR and extracts necessary information 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -  The disk containing the master boot record to be loaded 
....................   Return Values: 
....................     CE_GOOD -            MBR loaded successfully 
....................     CE_BAD_SECTOR_READ - A bad read occured of a sector 
....................     CE_BAD_PARTITION -   The boot record is bad 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The LoadMBR function will use the function pointed to by the 
....................     MDD_SectorRead function pointer to read the 0 sector from the 
....................     device.  If a valid boot signature is obtained, this function 
....................     will compare fields in that cached sector to the values that 
....................     would be present if that sector was a boot sector.  If all of 
....................     those values match, it will be assumed that the device does not 
....................     have a master boot record and the 0 sector is actually the boot 
....................     sector.  Otherwise, data about the partition and the actual 
....................     location of the boot sector will be loaded from the MBR into 
....................     the DISK structure pointed to by 'dsk.' 
....................   Remarks: 
....................     None 
....................   ********************************************************************/ 
....................  
.................... BYTE LoadMBR(DISK *dsk) 
*
01786:  MOV     W5,[W15++]
01788:  MOV     #C,W5
0178A:  REPEAT  #4
0178C:  MOV     [W5++],[W15++]
*
01790:  CLR.B   F84
.................... { 
....................     PT_MBR  Partition; 
*
0178E:  CLR     F82
....................     BYTE error = CE_GOOD; 
....................     BYTE type; 
*
01792:  CLR.B   F85
....................     BootSec BSec; 
01794:  CLR     F86
....................  
....................     // Get the partition table from the MBR 
....................     if ( MDD_SectorRead( FO_MBR, dsk->buffer) != TRUE) 
01796:  MOV     F80,W4
01798:  ADD     W4,#0,W4
0179A:  MOV     W4,W0
0179C:  MOV     #A,W1
0179E:  MOV     W0,W2
017A0:  REPEAT  #1
017A2:  MOV.B   [W2++],[W1++]
017A4:  CLR     1098
017A6:  CLR     109A
017A8:  MOV     W5,109C
017AA:  CALL    1722
017AE:  CP.B    W0L,#1
017B0:  BRA     Z,17BE
....................     { 
....................         #ifdef __DEBUG_UART 
....................         PrintROMASCIIStringUART("Error reading MBR block"); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................  
....................         error = CE_BAD_SECTOR_READ; 
017B2:  MOV.B   #8,W0L
017B4:  MOV.B   W0L,F84
....................         FSerrno = CE_BAD_SECTOR_READ; 
017B6:  MOV.B   #8,W0L
017B8:  MOV.B   W0L,857
....................     } 
017BA:  GOTO    1A58
....................     else 
....................     { 
....................         #ifdef __DEBUG_UART 
....................         PrintROMASCIIStringUART("MBR:"); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         PrintRAMBytesUART(((unsigned char*)dsk->buffer), 512); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................  
....................         // Check if the card has no MBR 
....................         BSec = (BootSec) dsk->buffer; 
017BE:  MOV     F80,W4
017C0:  ADD     W4,#0,W4
017C2:  MOV     W4,W0
017C4:  MOV     #A,W1
017C6:  MOV     W0,W2
017C8:  REPEAT  #1
017CA:  MOV.B   [W2++],[W1++]
017CC:  MOV     W5,F86
....................  
....................         #ifdef __DEBUG_UART 
....................         PrintROMASCIIStringUART("MBR Sig0="); 
....................         PrintRAMBytesUART(((unsigned char*)&BSec->Signature0), 1); 
....................         PrintROMASCIIStringUART(" Sig1="); 
....................         PrintRAMBytesUART(((unsigned char*)&BSec->Signature1), 1); 
....................         PrintROMASCIIStringUART(" FAT1* type="); 
....................         PrintRAMBytesUART(((unsigned char*)BSec->FAT.FAT_16.BootSec_FSType), 4); 
....................         PrintROMASCIIStringUART(" sig="); 
....................         PrintRAMBytesUART(((unsigned char*)&BSec->FAT.FAT_16.BootSec_BootSig), 1); 
....................         PrintROMASCIIStringUART(" FAT32 type="); 
....................         PrintRAMBytesUART(((unsigned char*)BSec->FAT.FAT_32.BootSec_FilSysType), 4); 
....................         PrintROMASCIIStringUART(" sig="); 
....................         PrintRAMBytesUART(((unsigned char*)&BSec->FAT.FAT_32.BootSec_BootSig), 1); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................  
....................         if((BSec->Signature0 == FAT_GOOD_SIGN_0) && (BSec->Signature1 == FAT_GOOD_SIGN_1)) 
017CE:  MOV     #1FE,W4
017D0:  MOV     F86,W3
017D2:  ADD     W3,W4,W0
017D4:  MOV     #A,W1
017D6:  MOV     W0,W2
017D8:  MOV.B   [W2++],[W1++]
017DA:  MOV     #55,W4
017DC:  CP.B    W4L,W5L
017DE:  BRA     NZ,197A
017E0:  MOV     #1FF,W4
017E2:  MOV     F86,W3
017E4:  ADD     W3,W4,W0
017E6:  MOV     #A,W1
017E8:  MOV     W0,W2
017EA:  MOV.B   [W2++],[W1++]
017EC:  MOV     #AA,W4
017EE:  CP.B    W4L,W5L
017F0:  BRA     NZ,197A
....................         { 
....................          // Technically, the OEM name is not for indication 
....................          // The alternative is to read the CIS from attribute 
....................          // memory.  See the PCMCIA metaformat for more details 
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................             if ((ReadByte( dsk->buffer, BSI_FSTYPE ) == 'F') && \ 
....................             (ReadByte( dsk->buffer, BSI_FSTYPE + 1 ) == 'A') && \ 
....................             (ReadByte( dsk->buffer, BSI_FSTYPE + 2 ) == 'T') && \ 
....................             (ReadByte( dsk->buffer, BSI_FSTYPE + 3 ) == '1') && \ 
....................             (ReadByte( dsk->buffer, BSI_BOOTSIG) == 0x29)) 
017F2:  MOV     F80,W4
017F4:  ADD     W4,#0,W4
017F6:  MOV     W4,W0
017F8:  MOV     #A,W1
017FA:  MOV     W0,W2
017FC:  REPEAT  #1
017FE:  MOV.B   [W2++],[W1++]
01800:  MOV     W5,F9C
01802:  MOV     #36,W4
01804:  MOV     W4,F9E
01806:  CALL    1776
0180A:  MOV     #46,W4
0180C:  CP.B    W4L,W0L
0180E:  BRA     NZ,18B8
01810:  MOV     F80,W4
01812:  ADD     W4,#0,W4
01814:  MOV     W4,W0
01816:  MOV     #C,W1
01818:  MOV     W0,W2
0181A:  REPEAT  #1
0181C:  MOV.B   [W2++],[W1++]
0181E:  MOV     W6,F9C
01820:  MOV     #37,W4
01822:  MOV     W4,F9E
01824:  CALL    1776
01828:  MOV     #41,W4
0182A:  CP.B    W4L,W0L
0182C:  BRA     NZ,18B8
0182E:  MOV     F80,W4
01830:  ADD     W4,#0,W4
01832:  MOV     W4,W0
01834:  MOV     #E,W1
01836:  MOV     W0,W2
01838:  REPEAT  #1
0183A:  MOV.B   [W2++],[W1++]
0183C:  MOV     W7,F9C
0183E:  MOV     #38,W4
01840:  MOV     W4,F9E
01842:  CALL    1776
01846:  MOV     #54,W4
01848:  CP.B    W4L,W0L
0184A:  BRA     NZ,18B8
0184C:  MOV     F80,W4
0184E:  ADD     W4,#0,W4
01850:  MOV     W4,W0
01852:  MOV     #10,W1
01854:  MOV     W0,W2
01856:  REPEAT  #1
01858:  MOV.B   [W2++],[W1++]
0185A:  MOV     W8,F9C
0185C:  MOV     #39,W4
0185E:  MOV     W4,F9E
01860:  CALL    1776
01864:  MOV     #31,W4
01866:  CP.B    W4L,W0L
01868:  BRA     NZ,18B8
0186A:  MOV     F80,W4
0186C:  ADD     W4,#0,W4
0186E:  MOV     W4,W0
01870:  MOV     #12,W1
01872:  MOV     W0,W2
01874:  REPEAT  #1
01876:  MOV.B   [W2++],[W1++]
01878:  MOV     W9,F9C
0187A:  MOV     #26,W4
0187C:  MOV     W4,F9E
0187E:  CALL    1776
01882:  MOV     #29,W4
01884:  CP.B    W4L,W0L
01886:  BRA     NZ,18B8
.................... #else 
....................             if ((BSec->FAT.FAT_16.BootSec_FSType[0] == 'F') && \ 
....................                 (BSec->FAT.FAT_16.BootSec_FSType[1] == 'A') && \ 
....................                 (BSec->FAT.FAT_16.BootSec_FSType[2] == 'T') && \ 
....................                 (BSec->FAT.FAT_16.BootSec_FSType[3] == '1') && \ 
....................                 (BSec->FAT.FAT_16.BootSec_BootSig == 0x29)) 
.................... #endif 
....................              { 
....................                 dsk->firsts = 0; 
01888:  MOV     F80,W4
0188A:  ADD     W4,#2,W4
0188C:  MOV     W4,W0
0188E:  MOV     W0,W5
01890:  MOV     #0,W6
01892:  MOV     #0,W7
01894:  MOV     W5,W1
01896:  MOV     #C,W2
01898:  REPEAT  #1
0189A:  MOV.B   [W2++],[W1++]
0189C:  CLR.B   [W1++]
0189E:  CLR.B   [W1++]
....................                 dsk->type = FAT16; 
018A0:  MOV     #22,W4
018A2:  MOV     F80,W3
018A4:  ADD     W3,W4,W0
018A6:  MOV     W0,W5
018A8:  MOV.B   #2,W6L
018AA:  MOV     W5,W1
018AC:  MOV     #C,W2
018AE:  MOV.B   [W2++],[W1++]
....................                 return CE_GOOD; 
018B0:  CLR.B   0
018B2:  BRA     1A5C
....................              } 
018B4:  GOTO    197A
....................              else 
....................              { 
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................                 if ((ReadByte( dsk->buffer, BSI_FAT32_FSTYPE ) == 'F') && \ 
....................                     (ReadByte( dsk->buffer, BSI_FAT32_FSTYPE + 1 ) == 'A') && \ 
....................                     (ReadByte( dsk->buffer, BSI_FAT32_FSTYPE + 2 ) == 'T') && \ 
....................                     (ReadByte( dsk->buffer, BSI_FAT32_FSTYPE + 3 ) == '3') && \ 
....................                     (ReadByte( dsk->buffer, BSI_FAT32_BOOTSIG) == 0x29)) 
018B8:  MOV     F80,W4
018BA:  ADD     W4,#0,W4
018BC:  MOV     W4,W0
018BE:  MOV     #A,W1
018C0:  MOV     W0,W2
018C2:  REPEAT  #1
018C4:  MOV.B   [W2++],[W1++]
018C6:  MOV     W5,F9C
018C8:  MOV     #52,W4
018CA:  MOV     W4,F9E
018CC:  CALL    1776
018D0:  MOV     #46,W4
018D2:  CP.B    W4L,W0L
018D4:  BRA     NZ,197A
018D6:  MOV     F80,W4
018D8:  ADD     W4,#0,W4
018DA:  MOV     W4,W0
018DC:  MOV     #C,W1
018DE:  MOV     W0,W2
018E0:  REPEAT  #1
018E2:  MOV.B   [W2++],[W1++]
018E4:  MOV     W6,F9C
018E6:  MOV     #53,W4
018E8:  MOV     W4,F9E
018EA:  CALL    1776
018EE:  MOV     #41,W4
018F0:  CP.B    W4L,W0L
018F2:  BRA     NZ,197A
018F4:  MOV     F80,W4
018F6:  ADD     W4,#0,W4
018F8:  MOV     W4,W0
018FA:  MOV     #E,W1
018FC:  MOV     W0,W2
018FE:  REPEAT  #1
01900:  MOV.B   [W2++],[W1++]
01902:  MOV     W7,F9C
01904:  MOV     #54,W4
01906:  MOV     W4,F9E
01908:  CALL    1776
0190C:  MOV     #54,W4
0190E:  CP.B    W4L,W0L
01910:  BRA     NZ,197A
01912:  MOV     F80,W4
01914:  ADD     W4,#0,W4
01916:  MOV     W4,W0
01918:  MOV     #10,W1
0191A:  MOV     W0,W2
0191C:  REPEAT  #1
0191E:  MOV.B   [W2++],[W1++]
01920:  MOV     W8,F9C
01922:  MOV     #55,W4
01924:  MOV     W4,F9E
01926:  CALL    1776
0192A:  MOV     #33,W4
0192C:  CP.B    W4L,W0L
0192E:  BRA     NZ,197A
01930:  MOV     F80,W4
01932:  ADD     W4,#0,W4
01934:  MOV     W4,W0
01936:  MOV     #12,W1
01938:  MOV     W0,W2
0193A:  REPEAT  #1
0193C:  MOV.B   [W2++],[W1++]
0193E:  MOV     W9,F9C
01940:  MOV     #42,W4
01942:  MOV     W4,F9E
01944:  CALL    1776
01948:  MOV     #29,W4
0194A:  CP.B    W4L,W0L
0194C:  BRA     NZ,197A
.................... #else 
....................                 if ((BSec->FAT.FAT_32.BootSec_FilSysType[0] == 'F') && \ 
....................                     (BSec->FAT.FAT_32.BootSec_FilSysType[1] == 'A') && \ 
....................                     (BSec->FAT.FAT_32.BootSec_FilSysType[2] == 'T') && \ 
....................                     (BSec->FAT.FAT_32.BootSec_FilSysType[3] == '3') && \ 
....................                     (BSec->FAT.FAT_32.BootSec_BootSig == 0x29)) 
.................... #endif 
....................                 { 
....................                     dsk->firsts = 0; 
0194E:  MOV     F80,W4
01950:  ADD     W4,#2,W4
01952:  MOV     W4,W0
01954:  MOV     W0,W5
01956:  MOV     #0,W6
01958:  MOV     #0,W7
0195A:  MOV     W5,W1
0195C:  MOV     #C,W2
0195E:  REPEAT  #1
01960:  MOV.B   [W2++],[W1++]
01962:  CLR.B   [W1++]
01964:  CLR.B   [W1++]
....................                     dsk->type = FAT32; 
01966:  MOV     #22,W4
01968:  MOV     F80,W3
0196A:  ADD     W3,W4,W0
0196C:  MOV     W0,W5
0196E:  MOV.B   #3,W6L
01970:  MOV     W5,W1
01972:  MOV     #C,W2
01974:  MOV.B   [W2++],[W1++]
....................                     return CE_GOOD; 
01976:  CLR.B   0
01978:  BRA     1A5C
....................                 } 
....................             } 
....................         } 
....................         // assign it the partition table strucutre 
....................         Partition = (PT_MBR)dsk->buffer; 
0197A:  MOV     F80,W4
0197C:  ADD     W4,#0,W4
0197E:  MOV     W4,W0
01980:  MOV     #A,W1
01982:  MOV     W0,W2
01984:  REPEAT  #1
01986:  MOV.B   [W2++],[W1++]
01988:  MOV     W5,F82
....................  
....................         #ifdef __DEBUG_UART 
....................         PrintROMASCIIStringUART("Partition Sig0="); 
....................         PrintRAMBytesUART(((unsigned char*)&Partition->Signature0), 1); 
....................         PrintROMASCIIStringUART(" Sig1="); 
....................         PrintRAMBytesUART(((unsigned char*)&Partition->Signature1), 1); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................  
....................         // Ensure its good 
....................         if((Partition->Signature0 != FAT_GOOD_SIGN_0) || (Partition->Signature1 != FAT_GOOD_SIGN_1)) 
0198A:  MOV     #1FE,W4
0198C:  MOV     F82,W3
0198E:  ADD     W3,W4,W0
01990:  MOV     #A,W1
01992:  MOV     W0,W2
01994:  MOV.B   [W2++],[W1++]
01996:  MOV     #55,W4
01998:  CP.B    W4L,W5L
0199A:  BRA     NZ,19AE
0199C:  MOV     #1FF,W4
0199E:  MOV     F82,W3
019A0:  ADD     W3,W4,W0
019A2:  MOV     #A,W1
019A4:  MOV     W0,W2
019A6:  MOV.B   [W2++],[W1++]
019A8:  MOV     #AA,W4
019AA:  CP.B    W4L,W5L
019AC:  BRA     Z,19BA
....................         { 
....................             FSerrno = CE_BAD_PARTITION; 
019AE:  MOV.B   #4,W0L
019B0:  MOV.B   W0L,857
....................             error = CE_BAD_PARTITION; 
019B2:  MOV.B   #4,W0L
019B4:  MOV.B   W0L,F84
....................         } 
019B6:  GOTO    1A58
....................         else 
....................         { 
....................             BYTE i; 
019BA:  CLR.B   F88
019BC:  MOV     #1BE,W4
019BE:  MOV     F82,W3
019C0:  ADD     W3,W4,W0
....................             PTE_MBR* partitionEntry = &Partition->Partition0; 
019C2:  MOV     W0,F8A
....................  
....................             for(i=0; i<4; i++) 
019C4:  CLR.B   F88
019C6:  MOV     F88,W4
019C8:  CP.B    W4L,#4
019CA:  BRA     C,1A50
....................             { 
....................                 /*    Valid Master Boot Record Loaded   */ 
....................  
....................                 // Get the 32 bit offset to the first partition 
....................                 dsk->firsts = partitionEntry->PTE_FrstSect; 
019CC:  MOV     F80,W4
019CE:  ADD     W4,#2,W4
019D0:  MOV     W4,W0
019D2:  MOV     W0,W5
019D4:  MOV     F8A,W4
019D6:  ADD     W4,#8,W4
019D8:  MOV     W4,W0
019DA:  MOV     #C,W1
019DC:  MOV     W0,W2
019DE:  REPEAT  #3
019E0:  MOV.B   [W2++],[W1++]
019E2:  MOV.D   W6,W8
019E4:  MOV     W5,W1
019E6:  MOV     #10,W2
019E8:  REPEAT  #3
019EA:  MOV.B   [W2++],[W1++]
....................  
....................                 // check if the partition type is acceptable 
....................                   type = partitionEntry->PTE_FSDesc; 
019EC:  MOV     F8A,W4
019EE:  ADD     W4,#4,W4
019F0:  MOV     W4,W0
019F2:  MOV     #A,W1
019F4:  MOV     W0,W2
019F6:  MOV.B   [W2++],[W1++]
019F8:  MOV.B   W5L,W0L
019FA:  MOV.B   W0L,F85
....................  
....................                 switch (type) 
019FC:  MOV.B   F85,W0L
019FE:  CLR.B   1
01A00:  XOR     #4,W0
01A02:  BRA     Z,1A16
01A04:  XOR     #2,W0
01A06:  BRA     Z,1A16
01A08:  XOR     #8,W0
01A0A:  BRA     Z,1A16
01A0C:  XOR     #5,W0
01A0E:  BRA     Z,1A2C
01A10:  XOR     #7,W0
01A12:  BRA     Z,1A2C
01A14:  BRA     1A42
....................                 { 
....................                 #ifdef SUPPORT_FAT12 
....................                     case 0x01: 
....................                         dsk->type = FAT12; 
....................                         break; 
....................                         #endif 
....................  
....................                 case 0x04: 
....................                     case 0x06: 
....................                     case 0x0E: 
....................                         dsk->type = FAT16; 
01A16:  MOV     #22,W4
01A18:  MOV     F80,W3
01A1A:  ADD     W3,W4,W0
01A1C:  MOV     W0,W5
01A1E:  MOV.B   #2,W6L
01A20:  MOV     W5,W1
01A22:  MOV     #C,W2
01A24:  MOV.B   [W2++],[W1++]
....................                         return(error); 
01A26:  MOV.B   F84,W0L
01A28:  MOV.B   W0L,0
01A2A:  BRA     1A5C
....................  
....................                     case 0x0B: 
....................                     case 0x0C: 
....................                         #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................                             dsk->type = FAT32;    // FAT32 is supported too 
01A2C:  MOV     #22,W4
01A2E:  MOV     F80,W3
01A30:  ADD     W3,W4,W0
01A32:  MOV     W0,W5
01A34:  MOV.B   #3,W6L
01A36:  MOV     W5,W1
01A38:  MOV     #C,W2
01A3A:  MOV.B   [W2++],[W1++]
....................                             return(error); 
01A3C:  MOV.B   F84,W0L
01A3E:  MOV.B   W0L,0
01A40:  BRA     1A5C
....................                         #endif 
....................                 } // switch 
....................  
....................                 /* If we are here, we didn't find a matching partition.  We 
....................                    should increment to the next partition table entry */ 
....................                 partitionEntry++; 
01A42:  PUSH    F8A
01A44:  MOV     #10,W0
01A46:  ADD     F8A
01A48:  MOV     [--W15],W0
01A4A:  INC.B   0F88
01A4C:  GOTO    19C6
....................             } 
....................  
....................             FSerrno = CE_UNSUPPORTED_FS; 
01A50:  MOV.B   #5,W0L
01A52:  MOV.B   W0L,857
....................             error = CE_UNSUPPORTED_FS; 
01A54:  MOV.B   #5,W0L
01A56:  MOV.B   W0L,F84
....................         } 
....................     } 
....................  
....................     return(error); 
01A58:  MOV.B   F84,W0L
01A5A:  MOV.B   W0L,0
01A5C:  MOV     #14,W5
01A5E:  REPEAT  #4
01A60:  MOV     [--W15],[W5--]
01A62:  MOV     [--W15],W5
01A64:  RETURN  
.................... }// -- LoadMBR 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     BYTE LoadBootSector (DISK *dsk) 
....................   Summary: 
....................     Load the boot sector and extract the necessary information 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -  The disk containing the boot sector 
....................   Return Values: 
....................     CE_GOOD -                    Boot sector loaded 
....................     CE_BAD_SECTOR_READ -         A bad read occured of a sector 
....................     CE_NOT_FORMATTED -           The disk is of an unsupported format 
....................     CE_CARDFAT32 -               FAT 32 device not supported 
....................     CE_UNSUPPORTED_SECTOR_SIZE - The sector size is not supported 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     LoadBootSector will use the function pointed to by the MDD_SectorWrite 
....................     function pointer to load the boot sector, whose location was obtained 
....................     by a previous call of LoadMBR.  If the boot sector is loaded successfully, 
....................     partition information will be calcualted from it and copied into the DISK 
....................     structure pointed to by 'dsk.' 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
....................  
.................... BYTE LoadBootSector(DISK *dsk) 
*
01B3A:  MOV     W5,[W15++]
01B3C:  MOV     #C,W5
01B3E:  REPEAT  #4
01B40:  MOV     [W5++],[W15++]
*
01B4E:  CLR.B   F8E
*
01B56:  BCLR.B  F8F.0
01B58:  BCLR.B  F8F.1
.................... { 
....................     DWORD       RootDirSectors; 
*
01B42:  CLR     F82
01B44:  CLR     F84
....................     DWORD       TotSec,DataSec; 
01B46:  CLR     F86
01B48:  CLR     F88
01B4A:  CLR     F8A
01B4C:  CLR     F8C
....................     BYTE        error = CE_GOOD; 
....................     BootSec     BSec; 
*
01B50:  CLR     F90
....................     WORD        BytesPerSec; 
01B52:  CLR     F92
....................     WORD        ReservedSectorCount; 
01B54:  CLR     F94
....................  
....................     #if defined(SUPPORT_FAT32) 
....................     BOOL        TriedSpecifiedBackupBootSec = FALSE; 
....................     BOOL        TriedBackupBootSecAtAddress6 = FALSE; 
....................     #endif 
....................     // Get the Boot sector 
....................     if ( MDD_SectorRead( dsk->firsts, dsk->buffer) != TRUE) 
*
01B5A:  MOV     F80,W4
01B5C:  ADD     W4,#2,W4
01B5E:  MOV     W4,W0
01B60:  MOV     #A,W1
01B62:  MOV     W0,W2
01B64:  REPEAT  #3
01B66:  MOV.B   [W2++],[W1++]
01B68:  MOV     F80,W4
01B6A:  ADD     W4,#0,W4
01B6C:  MOV     W4,W0
01B6E:  MOV     #E,W1
01B70:  MOV     W0,W2
01B72:  REPEAT  #1
01B74:  MOV.B   [W2++],[W1++]
01B76:  MOV     W5,1098
01B78:  MOV     W6,109A
01B7A:  MOV     W7,109C
01B7C:  CALL    1722
01B80:  CP.B    W0L,#1
01B82:  BRA     Z,1B8C
....................     { 
....................         error = CE_BAD_SECTOR_READ; 
01B84:  MOV.B   #8,W0L
01B86:  MOV.B   W0L,F8E
....................     } 
01B88:  GOTO    2104
....................     else 
....................     { 
....................         BSec = (BootSec)dsk->buffer; 
01B8C:  MOV     F80,W4
01B8E:  ADD     W4,#0,W4
01B90:  MOV     W4,W0
01B92:  MOV     #A,W1
01B94:  MOV     W0,W2
01B96:  REPEAT  #1
01B98:  MOV.B   [W2++],[W1++]
01B9A:  MOV     W5,F90
....................  
....................         do      //test each possible boot sector (FAT32 can have backup boot sectors) 
....................         { 
....................  
....................             //Verify the Boot Sector has a valid signature 
....................             if(    (BSec->Signature0 != FAT_GOOD_SIGN_0) 
....................                 || (BSec->Signature1 != FAT_GOOD_SIGN_1) 
01B9C:  MOV     #1FE,W4
01B9E:  MOV     F90,W3
01BA0:  ADD     W3,W4,W0
01BA2:  MOV     #A,W1
01BA4:  MOV     W0,W2
01BA6:  MOV.B   [W2++],[W1++]
01BA8:  MOV     #55,W4
01BAA:  CP.B    W4L,W5L
01BAC:  BRA     NZ,1BC0
01BAE:  MOV     #1FF,W4
01BB0:  MOV     F90,W3
01BB2:  ADD     W3,W4,W0
01BB4:  MOV     #A,W1
01BB6:  MOV     W0,W2
01BB8:  MOV.B   [W2++],[W1++]
01BBA:  MOV     #AA,W4
01BBC:  CP.B    W4L,W5L
01BBE:  BRA     Z,1BC8
....................               ) 
....................             { 
....................                 error = CE_NOT_FORMATTED; 
01BC0:  MOV.B   #3,W0L
01BC2:  MOV.B   W0L,F8E
....................             } 
01BC4:  GOTO    1F22
....................             else 
....................             { 
....................  
....................                 do      //loop just to allow a break to jump out of this section of code 
....................                 { 
....................                     #ifdef __18CXX 
....................                     // Load count of sectors per cluster 
....................                     dsk->SecPerClus = BSec->FAT.FAT_16.BootSec_SPC; 
....................                     // Load the sector number of the first FAT sector 
....................                     dsk->fat        = dsk->firsts + BSec->FAT.FAT_16.BootSec_ResrvSec; 
....................                     // Load the count of FAT tables 
....................                     dsk->fatcopy    = BSec->FAT.FAT_16.BootSec_FATCount; 
....................                     // Load the size of the FATs 
....................                     dsk->fatsize = BSec->FAT.FAT_16.BootSec_SPF; 
....................                     if(dsk->fatsize == 0) 
....................                         dsk->fatsize  = BSec->FAT.FAT_32.BootSec_FATSz32; 
....................                     // Calculate the location of the root sector (for FAT12/16) 
....................                     dsk->root = dsk->fat + (DWORD)(dsk->fatcopy * (DWORD)dsk->fatsize); 
....................                     // Determine the max size of the root (will be 0 for FAT32) 
....................                     dsk->maxroot    = BSec->FAT.FAT_16.BootSec_RootDirEnts; 
....................  
....................                     // Determine the total number of sectors in the partition 
....................                     if(BSec->FAT.FAT_16.BootSec_TotSec16 != 0) 
....................                     { 
....................                         TotSec = BSec->FAT.FAT_16.BootSec_TotSec16; 
....................                     } 
....................                     else 
....................                     { 
....................                         TotSec = BSec->FAT.FAT_16.BootSec_TotSec32; 
....................                     } 
....................  
....................                     // Calculate the number of bytes in each sector 
....................                     BytesPerSec = BSec->FAT.FAT_16.BootSec_BPS; 
....................                     if( (BytesPerSec == 0) || ((BytesPerSec & 1) == 1) ) 
....................                     { 
....................                         error = CE_UNSUPPORTED_SECTOR_SIZE; 
....................                         break;  //break out of the do while loop 
....................                     } 
....................  
....................                     // Calculate the number of sectors in the root (will be 0 for FAT32) 
....................                     RootDirSectors = ((BSec->FAT.FAT_16.BootSec_RootDirEnts * 32) + (BSec->FAT.FAT_16.BootSec_BPS - 1)) / BSec->FAT.FAT_16.BootSec_BPS; 
....................                     // Calculate the number of data sectors on the card 
....................                     DataSec = TotSec - (dsk->root + RootDirSectors); 
....................                     // Calculate the maximum number of clusters on the card 
....................                     dsk->maxcls = DataSec / dsk->SecPerClus; 
....................  
....................                     #else // PIC24/30/33 
....................  
....................                     // Read the count of reserved sectors 
....................                     ReservedSectorCount = ReadWord( dsk->buffer, BSI_RESRVSEC ); 
01BC8:  MOV     F80,W4
01BCA:  ADD     W4,#0,W4
01BCC:  MOV     W4,W0
01BCE:  MOV     #A,W1
01BD0:  MOV     W0,W2
01BD2:  REPEAT  #1
01BD4:  MOV.B   [W2++],[W1++]
01BD6:  MOV     W5,FB0
01BD8:  MOV     #E,W4
01BDA:  MOV     W4,FB2
01BDC:  CALL    1A66
01BE0:  MOV     W0,F94
....................                     // Load the count of sectors per cluster 
....................                     dsk->SecPerClus = ReadByte( dsk->buffer, BSI_SPC ); 
01BE2:  MOV     #21,W4
01BE4:  MOV     F80,W3
01BE6:  ADD     W3,W4,W0
01BE8:  MOV     W0,W5
01BEA:  MOV     F80,W4
01BEC:  ADD     W4,#0,W4
01BEE:  MOV     W4,W0
01BF0:  MOV     #C,W1
01BF2:  MOV     W0,W2
01BF4:  REPEAT  #1
01BF6:  MOV.B   [W2++],[W1++]
01BF8:  MOV     W6,F9C
01BFA:  MOV     #D,W4
01BFC:  MOV     W4,F9E
01BFE:  CALL    1776
01C02:  MOV.B   W0L,W7L
01C04:  MOV     W5,W1
01C06:  MOV     #E,W2
01C08:  MOV.B   [W2++],[W1++]
....................                     // Load the sector number of the first FAT sector 
....................                     dsk->fat = dsk->firsts + ReservedSectorCount; 
01C0A:  MOV     F80,W4
01C0C:  ADD     W4,#6,W4
01C0E:  MOV     W4,W0
01C10:  MOV     W0,W5
01C12:  MOV     F80,W4
01C14:  ADD     W4,#2,W4
01C16:  MOV     W4,W0
01C18:  MOV     #C,W1
01C1A:  MOV     W0,W2
01C1C:  REPEAT  #3
01C1E:  MOV.B   [W2++],[W1++]
01C20:  MOV     W6,W0
01C22:  ADD     F94,W0
01C24:  ADDC    W7,#0,W7
01C26:  MOV     W7,W1
01C28:  MOV.D   W0,W6
01C2A:  MOV     W5,W1
01C2C:  MOV     #C,W2
01C2E:  REPEAT  #3
01C30:  MOV.B   [W2++],[W1++]
....................                     // Load the count of FAT tables 
....................                     dsk->fatcopy    = ReadByte( dsk->buffer, BSI_FATCOUNT ); 
01C32:  MOV     #20,W4
01C34:  MOV     F80,W3
01C36:  ADD     W3,W4,W0
01C38:  MOV     W0,W5
01C3A:  MOV     F80,W4
01C3C:  ADD     W4,#0,W4
01C3E:  MOV     W4,W0
01C40:  MOV     #C,W1
01C42:  MOV     W0,W2
01C44:  REPEAT  #1
01C46:  MOV.B   [W2++],[W1++]
01C48:  MOV     W6,F9C
01C4A:  MOV     #10,W4
01C4C:  MOV     W4,F9E
01C4E:  CALL    1776
01C52:  MOV.B   W0L,W7L
01C54:  MOV     W5,W1
01C56:  MOV     #E,W2
01C58:  MOV.B   [W2++],[W1++]
....................                     // Load the size of the FATs 
....................                     dsk->fatsize = ReadWord( dsk->buffer, BSI_SPF ); 
01C5A:  MOV     F80,W4
01C5C:  ADD     W4,#1C,W4
01C5E:  MOV     W4,W0
01C60:  MOV     W0,W5
01C62:  MOV     F80,W4
01C64:  ADD     W4,#0,W4
01C66:  MOV     W4,W0
01C68:  MOV     #C,W1
01C6A:  MOV     W0,W2
01C6C:  REPEAT  #1
01C6E:  MOV.B   [W2++],[W1++]
01C70:  MOV     W6,FB0
01C72:  MOV     #16,W4
01C74:  MOV     W4,FB2
01C76:  CALL    1A66
01C7A:  MOV     W0,W7
01C7C:  MOV     #0,W8
01C7E:  MOV     W5,W1
01C80:  MOV     #E,W2
01C82:  REPEAT  #1
01C84:  MOV.B   [W2++],[W1++]
01C86:  CLR.B   [W1++]
01C88:  CLR.B   [W1++]
....................                     if(dsk->fatsize == 0) 
01C8A:  MOV     F80,W4
01C8C:  ADD     W4,#1C,W4
01C8E:  MOV     W4,W0
01C90:  MOV     #A,W1
01C92:  MOV     W0,W2
01C94:  REPEAT  #3
01C96:  MOV.B   [W2++],[W1++]
01C98:  CP0     W5
01C9A:  BRA     NZ,1CCC
01C9C:  CP0     W6
01C9E:  BRA     NZ,1CCC
....................                         dsk->fatsize  = ReadDWord( dsk->buffer, BSI_FATSZ32 ); 
01CA0:  MOV     F80,W4
01CA2:  ADD     W4,#1C,W4
01CA4:  MOV     W4,W0
01CA6:  MOV     W0,W5
01CA8:  MOV     F80,W4
01CAA:  ADD     W4,#0,W4
01CAC:  MOV     W4,W0
01CAE:  MOV     #C,W1
01CB0:  MOV     W0,W2
01CB2:  REPEAT  #1
01CB4:  MOV.B   [W2++],[W1++]
01CB6:  MOV     W6,F9C
01CB8:  MOV     #24,W4
01CBA:  MOV     W4,F9E
01CBC:  CALL    1AA4
01CC0:  MOV     W0,W7
01CC2:  MOV     W1,W8
01CC4:  MOV     W5,W1
01CC6:  MOV     #E,W2
01CC8:  REPEAT  #3
01CCA:  MOV.B   [W2++],[W1++]
....................                     // Calculate the location of the root sector (for FAT12/16) 
....................                     dsk->root = dsk->fat + (DWORD)(dsk->fatcopy * (DWORD)dsk->fatsize); 
01CCC:  MOV     F80,W4
01CCE:  ADD     W4,#A,W4
01CD0:  MOV     W4,W0
01CD2:  MOV     W0,W5
01CD4:  MOV     F80,W4
01CD6:  ADD     W4,#6,W4
01CD8:  MOV     W4,W0
01CDA:  MOV     #C,W1
01CDC:  MOV     W0,W2
01CDE:  REPEAT  #3
01CE0:  MOV.B   [W2++],[W1++]
01CE2:  MOV     #20,W4
01CE4:  MOV     F80,W3
01CE6:  ADD     W3,W4,W0
01CE8:  MOV     #10,W1
01CEA:  MOV     W0,W2
01CEC:  MOV.B   [W2++],[W1++]
01CEE:  MOV     F80,W4
01CF0:  ADD     W4,#1C,W4
01CF2:  MOV     W4,W0
01CF4:  MOV     #12,W1
01CF6:  MOV     W0,W2
01CF8:  REPEAT  #3
01CFA:  MOV.B   [W2++],[W1++]
01CFC:  MOV     #0,W1
01CFE:  MOV.B   W8L,W0L
01D00:  CLR.B   1
01D02:  MOV     W9,W2
01D04:  MOV     W10,W3
01D06:  CALL    10CE
01D0A:  ADD     W0,W6,W0
01D0C:  ADDC    W1,W7,W1
01D0E:  MOV.D   W0,W6
01D10:  MOV     W5,W1
01D12:  MOV     #C,W2
01D14:  REPEAT  #3
01D16:  MOV.B   [W2++],[W1++]
....................                     // Determine the max size of the root (will be 0 for FAT32) 
....................                     dsk->maxroot = ReadWord( dsk->buffer, BSI_ROOTDIRENTS ); 
01D18:  MOV     F80,W4
01D1A:  ADD     W4,#12,W4
01D1C:  MOV     W4,W0
01D1E:  MOV     W0,W5
01D20:  MOV     F80,W4
01D22:  ADD     W4,#0,W4
01D24:  MOV     W4,W0
01D26:  MOV     #C,W1
01D28:  MOV     W0,W2
01D2A:  REPEAT  #1
01D2C:  MOV.B   [W2++],[W1++]
01D2E:  MOV     W6,FB0
01D30:  MOV     #11,W4
01D32:  MOV     W4,FB2
01D34:  CALL    1A66
01D38:  MOV     W0,W7
01D3A:  MOV     W5,W1
01D3C:  MOV     #E,W2
01D3E:  REPEAT  #1
01D40:  MOV.B   [W2++],[W1++]
....................  
....................                     // Determine the total number of sectors in the partition 
....................                     TotSec = ReadWord( dsk->buffer, BSI_TOTSEC16 ); 
01D42:  MOV     F80,W4
01D44:  ADD     W4,#0,W4
01D46:  MOV     W4,W0
01D48:  MOV     #A,W1
01D4A:  MOV     W0,W2
01D4C:  REPEAT  #1
01D4E:  MOV.B   [W2++],[W1++]
01D50:  MOV     W5,FB0
01D52:  MOV     #13,W4
01D54:  MOV     W4,FB2
01D56:  CALL    1A66
01D5A:  MOV     W0,F86
01D5C:  CLR     F88
....................                     if( TotSec == 0 ) 
01D5E:  CP0     F86
01D60:  BRA     NZ,1D82
01D62:  CP0     F88
01D64:  BRA     NZ,1D82
....................                         TotSec = ReadDWord( dsk->buffer, BSI_TOTSEC32 ); 
01D66:  MOV     F80,W4
01D68:  ADD     W4,#0,W4
01D6A:  MOV     W4,W0
01D6C:  MOV     #A,W1
01D6E:  MOV     W0,W2
01D70:  REPEAT  #1
01D72:  MOV.B   [W2++],[W1++]
01D74:  MOV     W5,F9C
01D76:  MOV     #20,W4
01D78:  MOV     W4,F9E
01D7A:  CALL    1AA4
01D7E:  MOV     W0,F86
01D80:  MOV     W1,F88
....................  
....................                     // Calculate the number of bytes in each sector 
....................                     BytesPerSec = ReadWord( dsk->buffer, BSI_BPS ); 
01D82:  MOV     F80,W4
01D84:  ADD     W4,#0,W4
01D86:  MOV     W4,W0
01D88:  MOV     #A,W1
01D8A:  MOV     W0,W2
01D8C:  REPEAT  #1
01D8E:  MOV.B   [W2++],[W1++]
01D90:  MOV     W5,FB0
01D92:  MOV     #B,W4
01D94:  MOV     W4,FB2
01D96:  CALL    1A66
01D9A:  MOV     W0,F92
....................                     if( (BytesPerSec == 0) || ((BytesPerSec & 1) == 1) ) 
01D9C:  CP0     F92
01D9E:  BRA     Z,1DA8
01DA0:  MOV     F92,W0
01DA2:  AND     W0,#1,W5
01DA4:  CP      W5,#1
01DA6:  BRA     NZ,1DB0
....................                     { 
....................                         error = CE_UNSUPPORTED_SECTOR_SIZE; 
01DA8:  MOV.B   #21,W0L
01DAA:  MOV.B   W0L,F8E
....................                         break; 
01DAC:  GOTO    1F22
....................                     } 
....................  
....................                     // Calculate the number of sectors in the root (will be 0 for FAT32) 
....................                     RootDirSectors = ((dsk->maxroot * NUMBER_OF_BYTES_IN_DIR_ENTRY) + (BytesPerSec - 1)) / BytesPerSec; 
01DB0:  MOV     F80,W4
01DB2:  ADD     W4,#12,W4
01DB4:  MOV     W4,W0
01DB6:  MOV     #A,W1
01DB8:  MOV     W0,W2
01DBA:  REPEAT  #1
01DBC:  MOV.B   [W2++],[W1++]
01DBE:  SL      W5,#5,W5
01DC0:  MOV     F92,W4
01DC2:  SUB     W4,#1,W0
01DC4:  ADD     W0,W5,W5
01DC6:  MOV     W5,W4
01DC8:  MOV     F92,W3
01DCA:  REPEAT  #11
01DCC:  DIV.U   W4,W3
01DCE:  MOV     W0,F82
01DD0:  CLR     F84
....................                     // Calculate the number of data sectors on the card 
....................                     DataSec = TotSec - (ReservedSectorCount + (dsk->fatcopy * dsk->fatsize )  + RootDirSectors); 
01DD2:  MOV     #20,W4
01DD4:  MOV     F80,W3
01DD6:  ADD     W3,W4,W0
01DD8:  MOV     #A,W1
01DDA:  MOV     W0,W2
01DDC:  MOV.B   [W2++],[W1++]
01DDE:  MOV     F80,W4
01DE0:  ADD     W4,#1C,W4
01DE2:  MOV     W4,W0
01DE4:  MOV     #C,W1
01DE6:  MOV     W0,W2
01DE8:  REPEAT  #3
01DEA:  MOV.B   [W2++],[W1++]
01DEC:  MOV     #0,W1
01DEE:  MOV.B   W5L,W0L
01DF0:  CLR.B   1
01DF2:  MOV     W6,W2
01DF4:  MOV     W7,W3
01DF6:  CALL    10CE
01DFA:  MOV     F94,W4
01DFC:  ADD     W0,W4,W5
01DFE:  ADDC    W1,#0,W1
01E00:  MOV     W1,W6
01E02:  MOV     W5,W0
01E04:  ADD     F82,W0
01E06:  MOV     F84,W4
01E08:  ADDC    W6,W4,W1
01E0A:  MOV     F86,W4
01E0C:  SUB     W4,W0,W0
01E0E:  MOV     W0,F8A
01E10:  MOV     F88,W4
01E12:  SUBB    W4,W1,W0
01E14:  MOV     W0,F8C
....................                     // Calculate the maximum number of clusters on the card 
....................                     dsk->maxcls = DataSec / dsk->SecPerClus; 
01E16:  MOV     F80,W4
01E18:  ADD     W4,#14,W4
01E1A:  MOV     W4,W0
01E1C:  MOV     W0,W5
01E1E:  MOV     #21,W4
01E20:  MOV     F80,W3
01E22:  ADD     W3,W4,W0
01E24:  MOV     #C,W1
01E26:  MOV     W0,W2
01E28:  MOV.B   [W2++],[W1++]
01E2A:  BCLR.B  43.0
01E2C:  MOV.B   W6L,W2L
01E2E:  CLR.B   5
01E30:  MOV     #0,W3
01E32:  MOV     F8A,W0
01E34:  MOV     F8C,W1
01E36:  CALL    1AE6
01E3A:  MOV     W0,W7
01E3C:  MOV     W1,W8
01E3E:  MOV     W5,W1
01E40:  MOV     #E,W2
01E42:  REPEAT  #3
01E44:  MOV.B   [W2++],[W1++]
....................  
....................                     #endif 
....................  
....................                     // Determine the file system type based on the number of clusters used 
....................                     #ifdef SUPPORT_FAT12 
....................                     if(dsk->maxcls < 4085) 
....................                     { 
....................                         dsk->type = FAT12; 
....................                     } 
....................                     else 
....................                     #endif 
....................                     { 
....................                         if(dsk->maxcls < 65525) 
01E46:  MOV     F80,W4
01E48:  ADD     W4,#14,W4
01E4A:  MOV     W4,W0
01E4C:  MOV     #A,W1
01E4E:  MOV     W0,W2
01E50:  REPEAT  #3
01E52:  MOV.B   [W2++],[W1++]
01E54:  CP      W6,#0
01E56:  BRA     GTU,1E74
01E58:  BRA     NC,1E60
01E5A:  MOV     #FFF5,W4
01E5C:  CP      W4,W5
01E5E:  BRA     LEU,1E74
....................                         { 
....................                             dsk->type = FAT16; 
01E60:  MOV     #22,W4
01E62:  MOV     F80,W3
01E64:  ADD     W3,W4,W0
01E66:  MOV     W0,W5
01E68:  MOV.B   #2,W6L
01E6A:  MOV     W5,W1
01E6C:  MOV     #C,W2
01E6E:  MOV.B   [W2++],[W1++]
....................                         } 
01E70:  GOTO    1E84
....................                         else 
....................                         { 
....................                             #ifdef SUPPORT_FAT32 
....................                                 dsk->type = FAT32; 
01E74:  MOV     #22,W4
01E76:  MOV     F80,W3
01E78:  ADD     W3,W4,W0
01E7A:  MOV     W0,W5
01E7C:  MOV.B   #3,W6L
01E7E:  MOV     W5,W1
01E80:  MOV     #C,W2
01E82:  MOV.B   [W2++],[W1++]
....................                             #else 
....................                                 error = CE_CARDFAT32; 
....................                             #endif 
....................                         } 
....................                     } 
....................  
....................                     #ifdef SUPPORT_FAT32 
....................                         if (dsk->type == FAT32) 
01E84:  MOV     #22,W4
01E86:  MOV     F80,W3
01E88:  ADD     W3,W4,W0
01E8A:  MOV     #A,W1
01E8C:  MOV     W0,W2
01E8E:  MOV.B   [W2++],[W1++]
01E90:  CP.B    W5L,#3
01E92:  BRA     NZ,1EDC
....................                         { 
....................                             #ifdef __18CXX 
....................                                 FatRootDirClusterValue =  BSec->FAT.FAT_32.BootSec_RootClus; 
....................                             #else 
....................                                 FatRootDirClusterValue = ReadDWord( dsk->buffer, BSI_ROOTCLUS ); 
01E94:  MOV     F80,W4
01E96:  ADD     W4,#0,W4
01E98:  MOV     W4,W0
01E9A:  MOV     #A,W1
01E9C:  MOV     W0,W2
01E9E:  REPEAT  #1
01EA0:  MOV.B   [W2++],[W1++]
01EA2:  MOV     W5,F9C
01EA4:  MOV     #2C,W4
01EA6:  MOV     W4,F9E
01EA8:  CALL    1AA4
01EAC:  MOV     W0,858
01EAE:  MOV     W1,85A
....................                             #endif 
....................                             dsk->data = dsk->root + RootDirSectors; 
01EB0:  MOV     F80,W4
01EB2:  ADD     W4,#E,W4
01EB4:  MOV     W4,W0
01EB6:  MOV     W0,W5
01EB8:  MOV     F80,W4
01EBA:  ADD     W4,#A,W4
01EBC:  MOV     W4,W0
01EBE:  MOV     #C,W1
01EC0:  MOV     W0,W2
01EC2:  REPEAT  #3
01EC4:  MOV.B   [W2++],[W1++]
01EC6:  MOV     W6,W0
01EC8:  ADD     F82,W0
01ECA:  MOV     F84,W4
01ECC:  ADDC    W7,W4,W1
01ECE:  MOV.D   W0,W6
01ED0:  MOV     W5,W1
01ED2:  MOV     #C,W2
01ED4:  REPEAT  #3
01ED6:  MOV.B   [W2++],[W1++]
....................                         } 
01ED8:  GOTO    1F16
....................                         else 
....................                     #endif 
....................                     { 
....................                         FatRootDirClusterValue = 0; 
01EDC:  CLR     858
01EDE:  CLR     85A
....................                         dsk->data = dsk->root + ( dsk->maxroot >> 4); 
01EE0:  MOV     F80,W4
01EE2:  ADD     W4,#E,W4
01EE4:  MOV     W4,W0
01EE6:  MOV     W0,W5
01EE8:  MOV     F80,W4
01EEA:  ADD     W4,#A,W4
01EEC:  MOV     W4,W0
01EEE:  MOV     #C,W1
01EF0:  MOV     W0,W2
01EF2:  REPEAT  #3
01EF4:  MOV.B   [W2++],[W1++]
01EF6:  MOV     F80,W4
01EF8:  ADD     W4,#12,W4
01EFA:  MOV     W4,W0
01EFC:  MOV     #10,W1
01EFE:  MOV     W0,W2
01F00:  REPEAT  #1
01F02:  MOV.B   [W2++],[W1++]
01F04:  LSR     W8,#4,W0
01F06:  ADD     W0,W6,W0
01F08:  MOV     #0,W4
01F0A:  ADDC    W4,W7,W1
01F0C:  MOV.D   W0,W6
01F0E:  MOV     W5,W1
01F10:  MOV     #C,W2
01F12:  REPEAT  #3
01F14:  MOV.B   [W2++],[W1++]
....................                     } 
....................  
....................                 #ifdef __18CXX 
....................                     if(BSec->FAT.FAT_16.BootSec_BPS > MEDIA_SECTOR_SIZE) 
....................                 #else 
....................                     if(BytesPerSec > MEDIA_SECTOR_SIZE) 
01F16:  MOV     F92,W4
01F18:  MOV     #200,W3
01F1A:  CP      W3,W4
01F1C:  BRA     C,1F22
....................                 #endif 
....................                     { 
....................                         error = CE_UNSUPPORTED_SECTOR_SIZE; 
01F1E:  MOV.B   #21,W0L
01F20:  MOV.B   W0L,F8E
....................                     } 
....................  
....................                 }while(0);  // do/while loop designed to allow to break out if 
....................                             //   there is an error detected without returning 
....................                             //   from the function. 
....................  
....................             } 
....................  
....................             #if defined(SUPPORT_FAT32) 
....................             if ((dsk->type == FAT32) || ((error != CE_GOOD) && ((BSec->FAT.FAT_32.BootSec_BootSig == 0x29) || (BSec->FAT.FAT_32.BootSec_BootSig == 0x28)))) 
01F22:  MOV     #22,W4
01F24:  MOV     F80,W3
01F26:  ADD     W3,W4,W0
01F28:  MOV     #A,W1
01F2A:  MOV     W0,W2
01F2C:  MOV.B   [W2++],[W1++]
01F2E:  CP.B    W5L,#3
01F30:  BRA     Z,1F5A
01F32:  CP0.B   F8E
01F34:  BRA     Z,20FC
01F36:  MOV     #42,W4
01F38:  MOV     F90,W3
01F3A:  ADD     W3,W4,W0
01F3C:  MOV     #A,W1
01F3E:  MOV     W0,W2
01F40:  MOV.B   [W2++],[W1++]
01F42:  MOV     #29,W4
01F44:  CP.B    W4L,W5L
01F46:  BRA     Z,1F5A
01F48:  MOV     #42,W4
01F4A:  MOV     F90,W3
01F4C:  ADD     W3,W4,W0
01F4E:  MOV     #A,W1
01F50:  MOV     W0,W2
01F52:  MOV.B   [W2++],[W1++]
01F54:  MOV     #28,W4
01F56:  CP.B    W4L,W5L
01F58:  BRA     NZ,20FC
....................             { 
....................                 //Check for possible errors in the formatting 
....................                 if(    (BSec->FAT.FAT_32.BootSec_TotSec16 != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[0] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[1] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[2] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[3] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[4] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[5] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[6] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[7] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[8] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[9] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[10] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[11] != 0) 
....................                     || ((BSec->FAT.FAT_32.BootSec_BootSig != 0x29) && (BSec->FAT.FAT_32.BootSec_BootSig != 0x28)) 
01F5A:  MOV     F90,W4
01F5C:  ADD     W4,#13,W4
01F5E:  MOV     W4,W0
01F60:  MOV     #A,W1
01F62:  MOV     W0,W2
01F64:  REPEAT  #1
01F66:  MOV.B   [W2++],[W1++]
01F68:  CP0     W5
01F6A:  BRA     NZ,2050
01F6C:  MOV     #34,W4
01F6E:  MOV     F90,W3
01F70:  ADD     W3,W4,W0
01F72:  MOV     #A,W1
01F74:  MOV     W0,W2
01F76:  MOV.B   [W2++],[W1++]
01F78:  CP0.B   W5L
01F7A:  BRA     NZ,2050
01F7C:  MOV     #35,W4
01F7E:  MOV     F90,W3
01F80:  ADD     W3,W4,W0
01F82:  MOV     #A,W1
01F84:  MOV     W0,W2
01F86:  MOV.B   [W2++],[W1++]
01F88:  CP0.B   W5L
01F8A:  BRA     NZ,2050
01F8C:  MOV     #36,W4
01F8E:  MOV     F90,W3
01F90:  ADD     W3,W4,W0
01F92:  MOV     #A,W1
01F94:  MOV     W0,W2
01F96:  MOV.B   [W2++],[W1++]
01F98:  CP0.B   W5L
01F9A:  BRA     NZ,2050
01F9C:  MOV     #37,W4
01F9E:  MOV     F90,W3
01FA0:  ADD     W3,W4,W0
01FA2:  MOV     #A,W1
01FA4:  MOV     W0,W2
01FA6:  MOV.B   [W2++],[W1++]
01FA8:  CP0.B   W5L
01FAA:  BRA     NZ,2050
01FAC:  MOV     #38,W4
01FAE:  MOV     F90,W3
01FB0:  ADD     W3,W4,W0
01FB2:  MOV     #A,W1
01FB4:  MOV     W0,W2
01FB6:  MOV.B   [W2++],[W1++]
01FB8:  CP0.B   W5L
01FBA:  BRA     NZ,2050
01FBC:  MOV     #39,W4
01FBE:  MOV     F90,W3
01FC0:  ADD     W3,W4,W0
01FC2:  MOV     #A,W1
01FC4:  MOV     W0,W2
01FC6:  MOV.B   [W2++],[W1++]
01FC8:  CP0.B   W5L
01FCA:  BRA     NZ,2050
01FCC:  MOV     #3A,W4
01FCE:  MOV     F90,W3
01FD0:  ADD     W3,W4,W0
01FD2:  MOV     #A,W1
01FD4:  MOV     W0,W2
01FD6:  MOV.B   [W2++],[W1++]
01FD8:  CP0.B   W5L
01FDA:  BRA     NZ,2050
01FDC:  MOV     #3B,W4
01FDE:  MOV     F90,W3
01FE0:  ADD     W3,W4,W0
01FE2:  MOV     #A,W1
01FE4:  MOV     W0,W2
01FE6:  MOV.B   [W2++],[W1++]
01FE8:  CP0.B   W5L
01FEA:  BRA     NZ,2050
01FEC:  MOV     #3C,W4
01FEE:  MOV     F90,W3
01FF0:  ADD     W3,W4,W0
01FF2:  MOV     #A,W1
01FF4:  MOV     W0,W2
01FF6:  MOV.B   [W2++],[W1++]
01FF8:  CP0.B   W5L
01FFA:  BRA     NZ,2050
01FFC:  MOV     #3D,W4
01FFE:  MOV     F90,W3
02000:  ADD     W3,W4,W0
02002:  MOV     #A,W1
02004:  MOV     W0,W2
02006:  MOV.B   [W2++],[W1++]
02008:  CP0.B   W5L
0200A:  BRA     NZ,2050
0200C:  MOV     #3E,W4
0200E:  MOV     F90,W3
02010:  ADD     W3,W4,W0
02012:  MOV     #A,W1
02014:  MOV     W0,W2
02016:  MOV.B   [W2++],[W1++]
02018:  CP0.B   W5L
0201A:  BRA     NZ,2050
0201C:  MOV     #3F,W4
0201E:  MOV     F90,W3
02020:  ADD     W3,W4,W0
02022:  MOV     #A,W1
02024:  MOV     W0,W2
02026:  MOV.B   [W2++],[W1++]
02028:  CP0.B   W5L
0202A:  BRA     NZ,2050
0202C:  MOV     #42,W4
0202E:  MOV     F90,W3
02030:  ADD     W3,W4,W0
02032:  MOV     #A,W1
02034:  MOV     W0,W2
02036:  MOV.B   [W2++],[W1++]
02038:  MOV     #29,W4
0203A:  CP.B    W4L,W5L
0203C:  BRA     Z,2054
0203E:  MOV     #42,W4
02040:  MOV     F90,W3
02042:  ADD     W3,W4,W0
02044:  MOV     #A,W1
02046:  MOV     W0,W2
02048:  MOV.B   [W2++],[W1++]
0204A:  MOV     #28,W4
0204C:  CP.B    W4L,W5L
0204E:  BRA     Z,2054
....................                   ) 
....................                 { 
....................                     error = CE_NOT_FORMATTED; 
02050:  MOV.B   #3,W0L
02052:  MOV.B   W0L,F8E
....................                 } 
....................  
....................                 //If there were formatting errors then in FAT32 we can try to use 
....................                 //  the backup boot sector 
....................                 if((error != CE_GOOD) && (TriedSpecifiedBackupBootSec == FALSE)) 
02054:  CP0.B   F8E
02056:  BRA     Z,20B0
02058:  BTSC.B  F8F.0
0205A:  BRA     20B0
....................                 { 
....................                     TriedSpecifiedBackupBootSec = TRUE; 
0205C:  BSET.B  F8F.0
....................  
....................                     if ( MDD_SectorRead( dsk->firsts + BSec->FAT.FAT_32.BootSec_BkBootSec, dsk->buffer) != TRUE) 
0205E:  MOV     F80,W4
02060:  ADD     W4,#2,W4
02062:  MOV     W4,W0
02064:  MOV     #A,W1
02066:  MOV     W0,W2
02068:  REPEAT  #3
0206A:  MOV.B   [W2++],[W1++]
0206C:  MOV     #32,W4
0206E:  MOV     F90,W3
02070:  ADD     W3,W4,W0
02072:  MOV     #E,W1
02074:  MOV     W0,W2
02076:  REPEAT  #1
02078:  MOV.B   [W2++],[W1++]
0207A:  ADD     W7,W5,W5
0207C:  MOV     #0,W4
0207E:  ADDC    W4,W6,W6
02080:  MOV     F80,W4
02082:  ADD     W4,#0,W4
02084:  MOV     W4,W0
02086:  MOV     #10,W1
02088:  MOV     W0,W2
0208A:  REPEAT  #1
0208C:  MOV.B   [W2++],[W1++]
0208E:  MOV     W5,1098
02090:  MOV     W6,109A
02092:  MOV     W8,109C
02094:  CALL    1722
02098:  CP.B    W0L,#1
0209A:  BRA     Z,20AA
....................                     { 
....................                         FSerrno = CE_BAD_SECTOR_READ; 
0209C:  MOV.B   #8,W0L
0209E:  MOV.B   W0L,857
....................                         return CE_BAD_SECTOR_READ; 
020A0:  MOV.B   #8,W0L
020A2:  MOV.B   W0L,0
020A4:  BRA     2110
....................                     } 
020A6:  GOTO    20B0
....................                     else 
....................                     { 
....................                         error = CE_GOOD; 
020AA:  CLR.B   F8E
....................                         continue; 
020AC:  GOTO    2100
....................                     } 
....................                 } 
....................  
....................                 if((error != CE_GOOD) && (TriedBackupBootSecAtAddress6 == FALSE)) 
020B0:  CP0.B   F8E
020B2:  BRA     Z,20FC
020B4:  BTSC.B  F8F.1
020B6:  BRA     20FC
....................                 { 
....................                     TriedBackupBootSecAtAddress6 = TRUE; 
020B8:  BSET.B  F8F.1
....................  
....................                     //Here we are using the magic number 6 because the FAT32 specification 
....................                     //  recommends that "No value other than 6 is recommended."  We've 
....................                     //  already tried using the value specified in the BPB_BkBootSec 
....................                     //  field and it must have failed 
....................                     if ( MDD_SectorRead( dsk->firsts + 6, dsk->buffer) != TRUE) 
020BA:  MOV     F80,W4
020BC:  ADD     W4,#2,W4
020BE:  MOV     W4,W0
020C0:  MOV     #A,W1
020C2:  MOV     W0,W2
020C4:  REPEAT  #3
020C6:  MOV.B   [W2++],[W1++]
020C8:  ADD     W5,#6,W5
020CA:  ADDC    W6,#0,W6
020CC:  MOV     F80,W4
020CE:  ADD     W4,#0,W4
020D0:  MOV     W4,W0
020D2:  MOV     #E,W1
020D4:  MOV     W0,W2
020D6:  REPEAT  #1
020D8:  MOV.B   [W2++],[W1++]
020DA:  MOV     W5,1098
020DC:  MOV     W6,109A
020DE:  MOV     W7,109C
020E0:  CALL    1722
020E4:  CP.B    W0L,#1
020E6:  BRA     Z,20F6
....................                     { 
....................                         FSerrno = CE_BAD_SECTOR_READ; 
020E8:  MOV.B   #8,W0L
020EA:  MOV.B   W0L,857
....................                         return CE_BAD_SECTOR_READ; 
020EC:  MOV.B   #8,W0L
020EE:  MOV.B   W0L,0
020F0:  BRA     2110
....................                     } 
020F2:  GOTO    20FC
....................                     else 
....................                     { 
....................                         error = CE_GOOD; 
020F6:  CLR.B   F8E
....................                         continue; 
020F8:  GOTO    2100
....................                     } 
....................                 } 
....................  
....................             }   //type == FAT32 
....................             #endif  //SUPPORT_FAT32 
....................             break; 
020FC:  GOTO    2104
....................         } 
....................         while(1); 
02100:  GOTO    1B9C
....................     } 
....................  
....................     if(error != CE_GOOD) 
02104:  CP0.B   F8E
02106:  BRA     Z,210C
....................     { 
....................         FSerrno = error; 
02108:  MOV.B   F8E,W0L
0210A:  MOV.B   W0L,857
....................     } 
....................  
....................     return(error); 
0210C:  MOV.B   F8E,W0L
0210E:  MOV.B   W0L,0
02110:  MOV     #14,W5
02112:  REPEAT  #4
02114:  MOV     [--W15],[W5--]
02116:  MOV     [--W15],W5
02118:  RETURN  
.................... } 
....................  
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     DWORD GetFullClusterNumber (DIRENTRY entry) 
....................   Summary: 
....................     Gets the cluster number from a directory entry 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     entry - The cached directory entry to get the cluster number from 
....................   Returns: 
....................     The cluster value from the passed directory entry 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     This function will load both the high and low 16-bit first cluster 
....................     values of a file from a directory entry and copy them into a 32-bit 
....................     cluster number variable, which will be returned. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... DWORD GetFullClusterNumber(DIRENTRY entry) 
*
034B4:  CLR     102C
034B6:  CLR     102E
.................... { 
....................  
....................     DWORD TempFullClusterCalc = 0; 
....................  
.................... #ifndef SUPPORT_FAT32 // If FAT32 Not supported. 
....................     entry->DIR_FstClusHI = 0; // If FAT32 is not supported then Higher Word of the address is "0" 
.................... #endif 
....................  
....................     // Get the cluster 
....................     TempFullClusterCalc = (entry->DIR_FstClusHI); 
034B8:  MOV     #14,W0
034BA:  ADD     102A,W0
034BC:  MOV     [W0],[W15++]
034BE:  POP     102C
034C0:  CLR     102E
....................     TempFullClusterCalc = TempFullClusterCalc << 16; 
034C2:  PUSH    102C
034C4:  POP     102E
034C6:  CLR     102C
....................     TempFullClusterCalc |= entry->DIR_FstClusLO; 
034C8:  MOV     #1A,W0
034CA:  ADD     102A,W0
034CC:  MOV     W0,W4
034CE:  MOV     [W4],W0
034D0:  IOR     102C
....................  
....................     return TempFullClusterCalc; 
034D2:  MOV     102C,W0
034D4:  MOV     102E,W1
034D6:  RETURN  
.................... } 
....................  
....................  
.................... #ifdef ALLOW_FORMATS 
.................... #ifdef ALLOW_WRITES 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     int FSCreateMBR (unsigned long firstSector, unsigned long numSectors) 
....................   Summary: 
....................     Creates a master boot record 
....................   Conditions: 
....................     The I/O pins for the device have been initialized by the InitIO function. 
....................   Input: 
....................     firstSector -  The first sector of the partition on the device (cannot 
....................                    be 0; that's the MBR) 
....................     numSectors -   The number of sectors available in memory (including the 
....................                    MBR) 
....................   Return Values: 
....................     0 -   MBR was created successfully 
....................     EOF - MBR could not be created 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function can be used to create a master boot record for a device.  Note 
....................     that this function should not be used on a device that is already formatted 
....................     with a master boot record (i.e. most SD cards, CF cards, USB keys).  This 
....................     function will fill the global data buffer with appropriate partition information 
....................     for a FAT partition with a type determined by the number of sectors available 
....................     to the partition.  It will then write the MBR information to the first sector 
....................     on the device.  This function should be followed by a call to FSformat, which 
....................     will create a boot sector, root dir, and FAT appropriate the the information 
....................     contained in the new master boot record.  Note that FSformat only supports 
....................     FAT12 and FAT16 formatting at this time, and so cannot be used to format a 
....................     device with more than 0x3FFD5F sectors. 
....................   Remarks: 
....................     This function can damage the device being used, and should not be called 
....................     unless the user is sure about the size of the device and the first sector value. 
....................   *********************************************************************************/ 
....................  
.................... int FSCreateMBR (unsigned long firstSector, unsigned long numSectors) 
.................... { 
....................     PT_MBR  Partition; 
....................     DWORD CyHdSc = 0x00000000; 
....................     DWORD tempSector; 
....................  
....................     if ((firstSector == 0) || (numSectors <= 1)) 
....................         return EOF; 
....................  
....................     if (firstSector > (numSectors - 1)) 
....................         return EOF; 
....................  
....................     if (gNeedDataWrite) 
....................         if (flushData()) 
....................             return EOF; 
....................  
....................     memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE); 
....................  
....................     Partition = (PT_MBR) gDataBuffer; 
....................  
....................     // Set Cylinder-head-sector address of the first sector 
....................     tempSector = firstSector; 
....................     CyHdSc = (tempSector / (unsigned int)16065 ) << 14; 
....................     tempSector %= 16065; 
....................     CyHdSc |= (tempSector / 63) << 6; 
....................     tempSector %= 63; 
....................     CyHdSc |= tempSector + 1; 
....................     gDataBuffer[447] = (BYTE)((CyHdSc >> 16) & 0xFF); 
....................     gDataBuffer[448] = (BYTE)((CyHdSc >> 8) & 0xFF); 
....................     gDataBuffer[449] = (BYTE)((CyHdSc) & 0xFF); 
....................  
....................     // Set the count of sectors 
....................     Partition->Partition0.PTE_NumSect = numSectors - firstSector; 
....................  
....................     // Set the partition type 
....................     // We only support creating FAT12 and FAT16 MBRs at this time 
....................     if (Partition->Partition0.PTE_NumSect < 0x1039) 
....................     { 
....................         // FAT12 
....................         Partition->Partition0.PTE_FSDesc = 0x01; 
....................     } 
....................     else if (Partition->Partition0.PTE_NumSect <= 0x3FFD5F) 
....................     { 
....................         // FAT16 
....................         Partition->Partition0.PTE_FSDesc = 0x06; 
....................     } 
....................     else 
....................         return EOF; 
....................  
....................     // Set the LBA of the first sector 
....................     Partition->Partition0.PTE_FrstSect = firstSector; 
....................  
....................     // Set the Cylinder-head-sector address of the last sector 
....................     tempSector = firstSector + numSectors - 1; 
....................     CyHdSc = (tempSector / (unsigned int)16065 ) << 14; 
....................     tempSector %= 16065; 
....................     CyHdSc |= (tempSector / 63) << 6; 
....................     tempSector %= 63; 
....................     CyHdSc |= tempSector + 1; 
....................     gDataBuffer[451] = (BYTE)((CyHdSc >> 16) & 0xFF); 
....................     gDataBuffer[452] = (BYTE)((CyHdSc >> 8) & 0xFF); 
....................     gDataBuffer[453] = (BYTE)((CyHdSc) & 0xFF); 
....................  
....................     // Set the boot descriptor.  This will be 0, since we won't 
....................     // be booting anything from our device probably 
....................     Partition->Partition0.PTE_BootDes = 0x00; 
....................  
....................     // Set the signature codes 
....................     Partition->Signature0 = 0x55; 
....................     Partition->Signature1 = 0xAA; 
....................  
....................     if (MDD_SectorWrite (0x00, gDataBuffer, TRUE) != TRUE) 
....................         return EOF; 
....................     else 
....................         return 0; 
....................  
.................... } 
....................  
....................  
.................... /******************************************************************* 
....................   Function: 
....................     int FSformat (char mode, long int serialNumber, char * volumeID) 
....................   Summary: 
....................     Formats a device 
....................   Conditions: 
....................     The device must possess a valid master boot record. 
....................   Input: 
....................     mode -          - 0 - Just erase the FAT and root 
....................                     - 1 - Create a new boot sector 
....................     serialNumber -  Serial number to write to the card 
....................     volumeID -      Name of the card 
....................   Return Values: 
....................     0 -    Format was successful 
....................     EOF -  Format was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSformat function can be used to create a new boot sector 
....................     on a device, based on the information in the master boot record. 
....................     This function will first initialize the I/O pins and the device, 
....................     and then attempts to read the master boot record.  If the MBR 
....................     cannot be loaded successfully, the function will fail.  Next, if 
....................     the 'mode' argument is specified as '0' the existing boot sector 
....................     information will be loaded.  If the 'mode' argument is '1' an 
....................     entirely new boot sector will be constructed using the disk 
....................     values from the master boot record.  Once the boot sector has 
....................     been successfully loaded/created, the locations of the FAT and 
....................     root will be loaded from it, and they will be completely 
....................     erased.  If the user has specified a volumeID parameter, a 
....................     VOLUME attribute entry will be created in the root directory 
....................     to name the device. 
....................  
....................     FAT12, FAT16 and FAT32 formatting are supported. 
....................  
....................     Based on the number of sectors, the format function automatically 
....................     compute the smallest possible value for the cluster size in order to 
....................     accommodate the physical size of the media. In this case, if a media 
....................     with a big capacity is formatted, the format function may take a very 
....................     long time to write all the FAT tables. 
....................  
....................     Therefore, the FORMAT_SECTORS_PER_CLUSTER macro may be used to 
....................     specify the exact cluster size (in multiples of sector size). This 
....................     macro can be defined in FSconfig.h 
....................  
....................   Remarks: 
....................     Only devices with a sector size of 512 bytes are supported by the 
....................     format function 
....................   *******************************************************************/ 
....................  
.................... int FSformat (char mode, long int serialNumber, char * volumeID) 
.................... { 
....................     PT_MBR   masterBootRecord; 
....................     DWORD    secCount, DataClusters, RootDirSectors; 
....................     BootSec   BSec; 
....................     DISK   d; 
....................     DISK * disk = &d; 
....................     WORD    j; 
....................     DWORD   fatsize, test; 
....................     DWORD Index; 
....................     MEDIA_INFORMATION * mediaInfo; 
.................... #ifdef __18CXX 
....................     // This is here because of a C18 compiler feature 
....................     BYTE *  dataBufferPointer = gDataBuffer; 
.................... #endif 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................     gBufferZeroed = FALSE; 
....................     gNeedFATWrite = FALSE; 
....................     gLastFATSectorRead = 0xFFFFFFFF; 
....................     gLastDataSectorRead = 0xFFFFFFFF; 
....................  
....................     disk->buffer = gDataBuffer; 
....................  
....................     MDD_InitIO(); 
....................  
....................     mediaInfo = MDD_MediaInitialize(); 
....................     if (mediaInfo->errorCode != MEDIA_NO_ERROR) 
....................     { 
....................         FSerrno = CE_INIT_ERROR; 
....................         return EOF; 
....................     } 
....................  
....................     if (MDD_SectorRead (0x00, gDataBuffer) == FALSE) 
....................     { 
....................         FSerrno = CE_BADCACHEREAD; 
....................         return EOF; 
....................     } 
....................  
....................     // Check if the card has no MBR 
....................     BSec = (BootSec) disk->buffer; 
....................     if((BSec->Signature0 == FAT_GOOD_SIGN_0) && (BSec->Signature1 == FAT_GOOD_SIGN_1)) 
....................     { 
....................         // Technically, the OEM name is not for indication 
....................         // The alternative is to read the CIS from attribute 
....................         // memory.  See the PCMCIA metaformat for more details 
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................         if ((ReadByte( disk->buffer, BSI_FSTYPE ) == 'F') && \ 
....................             (ReadByte( disk->buffer, BSI_FSTYPE + 1 ) == 'A') && \ 
....................             (ReadByte( disk->buffer, BSI_FSTYPE + 2 ) == 'T') && \ 
....................             (ReadByte( disk->buffer, BSI_FSTYPE + 3 ) == '1') && \ 
....................             (ReadByte( disk->buffer, BSI_BOOTSIG) == 0x29)) 
.................... #else 
....................         if ((BSec->FAT.FAT_16.BootSec_FSType[0] == 'F') && \ 
....................             (BSec->FAT.FAT_16.BootSec_FSType[1] == 'A') && \ 
....................             (BSec->FAT.FAT_16.BootSec_FSType[2] == 'T') && \ 
....................             (BSec->FAT.FAT_16.BootSec_FSType[3] == '1') && \ 
....................             (BSec->FAT.FAT_16.BootSec_BootSig == 0x29)) 
.................... #endif 
....................         { 
....................             /* Mark that we do not have a MBR; 
....................                 this is not actualy used - is here only to remove a compilation warning */ 
....................             masterBootRecord = (PT_MBR) NULL; 
....................             switch (mode) 
....................             { 
....................                 case 1: 
....................                     // not enough info to construct our own boot sector 
....................                     FSerrno = CE_INVALID_ARGUMENT; 
....................                     return EOF; 
....................                 case 0: 
....................                     // We have to determine the operating system, and the 
....................                     // locations and sizes of the root dir and FAT, and the 
....................                     // count of FATs 
....................                     disk->firsts = 0; 
....................                     if (LoadBootSector (disk) != CE_GOOD) 
....................                     { 
....................                         FSerrno = CE_BADCACHEREAD; 
....................                         return EOF; 
....................                     } 
....................                 default: 
....................                     break; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             masterBootRecord = (PT_MBR) &gDataBuffer; 
....................             disk->firsts = masterBootRecord->Partition0.PTE_FrstSect; 
....................         } 
....................     } 
....................     else 
....................     { 
....................         /* If the signature is not correct, this is neither a MBR, nor a VBR */ 
....................         FSerrno = CE_BAD_PARTITION; 
....................         return EOF; 
....................     } 
....................  
....................     switch (mode) 
....................     { 
....................         // True: Rewrite the whole boot sector 
....................         case 1: 
....................             secCount = masterBootRecord->Partition0.PTE_NumSect; 
....................  
....................            #ifdef SUPPORT_FAT12 
....................             if (secCount < 0x1039) 
....................             { 
....................                 disk->type = FAT12; 
....................                 // Format to FAT12 only if there are too few sectors to format 
....................                 // as FAT16 
....................                 masterBootRecord->Partition0.PTE_FSDesc = 0x01; 
....................                 if (MDD_SectorWrite (0x00, gDataBuffer, TRUE) == FALSE) 
....................                 { 
....................                     FSerrno = CE_WRITE_ERROR; 
....................                     return EOF; 
....................                 } 
....................  
....................                 if (secCount >= 0x1028) 
....................                 { 
....................                     // More than 0x18 sectors for FATs, 0x20 for root dir, 
....................                     // 0x8 reserved, and 0xFED for data 
....................                     // So double the number of sectors in a cluster to reduce 
....................                     // the number of data clusters used 
....................                     disk->SecPerClus = 2; 
....................                 } 
....................                 else 
....................                 { 
....................                     // One sector per cluster 
....................                     disk->SecPerClus = 1; 
....................                 } 
....................  
....................                 // Prepare a boot sector 
....................                 memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE); 
....................  
....................                 // Last digit of file system name (FAT12   ) 
....................                 gDataBuffer[58] = '2'; 
....................  
....................                 // Calculate the size of the FAT 
....................                 fatsize = (secCount - 0x21  + (2*disk->SecPerClus)); 
....................                 test =   (341 * disk->SecPerClus) + 2; 
....................                 fatsize = (fatsize + (test-1)) / test; 
....................  
....................                 disk->fatcopy = 0x02; 
....................                 disk->maxroot = 0x200; 
....................  
....................                 disk->fatsize = fatsize; 
....................  
....................             } 
....................             else 
....................            #endif 
....................             if (secCount <= 0x3FFD5F) 
....................             { 
....................                 disk->type = FAT16; 
....................                 // Format to FAT16 
....................                 masterBootRecord->Partition0.PTE_FSDesc = 0x06; 
....................                 if (MDD_SectorWrite (0x00, gDataBuffer, TRUE) == FALSE) 
....................                 { 
....................                     FSerrno = CE_WRITE_ERROR; 
....................                     return EOF; 
....................                 } 
....................  
....................                 DataClusters = secCount - 0x218; 
....................                 // Figure out how many sectors per cluster we need 
....................                 disk->SecPerClus = 1; 
....................                 while (DataClusters > 0xFFED) 
....................                 { 
....................                     disk->SecPerClus *= 2; 
....................                     DataClusters /= 2; 
....................                 } 
....................                 // This shouldnt happen 
....................                 if (disk->SecPerClus > 128) 
....................                 { 
....................                     FSerrno = CE_BAD_PARTITION; 
....................                     return EOF; 
....................                 } 
....................  
....................                 // Prepare a boot sector 
....................                 memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE); 
....................  
....................                 // Last digit of file system name (FAT16   ) 
....................                 gDataBuffer[58] = '6'; 
....................  
....................                 // Calculate the size of the FAT 
....................                 fatsize = (secCount - 0x21  + (2*disk->SecPerClus)); 
....................                 test =    (256  * disk->SecPerClus) + 2; 
....................                 fatsize = (fatsize + (test-1)) / test; 
....................  
....................                 disk->fatcopy = 0x02; 
....................                 disk->maxroot = 0x200; 
....................  
....................                 disk->fatsize = fatsize; 
....................             } 
....................             else 
....................             { 
....................                 disk->type = FAT32; 
....................                 // Format to FAT32 
....................                 masterBootRecord->Partition0.PTE_FSDesc = 0x0B; 
....................                 if (MDD_SectorWrite (0x00, gDataBuffer, TRUE) == FALSE) 
....................                 { 
....................                     FSerrno = CE_WRITE_ERROR; 
....................                     return EOF; 
....................                 } 
....................  
....................                 #ifdef FORMAT_SECTORS_PER_CLUSTER 
....................                     disk->SecPerClus = FORMAT_SECTORS_PER_CLUSTER; 
....................                     DataClusters = secCount / disk->SecPerClus; 
....................  
....................                     /* FAT32: 65526 < Number of clusters < 4177918 */ 
....................                     if ((DataClusters <= 65526) || (DataClusters >= 4177918)) 
....................                     { 
....................                         FSerrno = CE_BAD_PARTITION; 
....................                         return EOF; 
....................                     } 
....................                 #else 
....................                     /*  FAT32: 65526 < Number of clusters < 4177918 */ 
....................                     DataClusters = secCount; 
....................                     // Figure out how many sectors per cluster we need 
....................                     disk->SecPerClus = 1; 
....................                     while (DataClusters > 0x3FBFFE) 
....................                     { 
....................                         disk->SecPerClus *= 2; 
....................                         DataClusters /= 2; 
....................                     } 
....................                 #endif 
....................                 // Check the cluster size: FAT32 supports 512, 1024, 2048, 4096, 8192, 16K, 32K, 64K 
....................                 if (disk->SecPerClus > 128) 
....................                 { 
....................                     FSerrno = CE_BAD_PARTITION; 
....................                     return EOF; 
....................                 } 
....................  
....................                 // Prepare a boot sector 
....................                 memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE); 
....................  
....................                // Calculate the size of the FAT 
....................                 fatsize = (secCount - 0x20); 
....................                 test =    (128  * disk->SecPerClus) + 1; 
....................                 fatsize = (fatsize + (test-1)) / test; 
....................  
....................                 disk->fatcopy = 0x02; 
....................                 disk->maxroot = 0x200; 
....................  
....................                 disk->fatsize = fatsize; 
....................             } 
....................  
....................             // Non-file system specific values 
....................             gDataBuffer[0] = 0xEB;         //Jump instruction 
....................             gDataBuffer[1] = 0x3C; 
....................             gDataBuffer[2] = 0x90; 
....................             gDataBuffer[3] =  'M';         //OEM Name "MCHP FAT" 
....................             gDataBuffer[4] =  'C'; 
....................             gDataBuffer[5] =  'H'; 
....................             gDataBuffer[6] =  'P'; 
....................             gDataBuffer[7] =  ' '; 
....................             gDataBuffer[8] =  'F'; 
....................             gDataBuffer[9] =  'A'; 
....................             gDataBuffer[10] = 'T'; 
....................  
....................             gDataBuffer[11] = 0x00;             //Sector size 
....................             gDataBuffer[12] = 0x02; 
....................  
....................             gDataBuffer[13] = disk->SecPerClus;   //Sectors per cluster 
....................  
....................             if ((disk->type == FAT12) || (disk->type == FAT16)) 
....................             { 
....................                 gDataBuffer[14] = 0x08;         //Reserved sector count 
....................                 gDataBuffer[15] = 0x00; 
....................                 disk->fat = 0x08 + disk->firsts; 
....................  
....................                 gDataBuffer[16] = 0x02;         //number of FATs 
....................  
....................                 gDataBuffer[17] = 0x00;          //Max number of root directory entries - 512 files allowed 
....................                 gDataBuffer[18] = 0x02; 
....................  
....................                 gDataBuffer[19] = 0x00;         //total sectors 
....................                 gDataBuffer[20] = 0x00; 
....................  
....................                 gDataBuffer[21] = 0xF8;         //Media Descriptor 
....................  
....................                 gDataBuffer[22] = fatsize & 0xFF;         //Sectors per FAT 
....................                 gDataBuffer[23] = (fatsize >> 8) & 0xFF; 
....................  
....................                 gDataBuffer[24] = 0x3F;           //Sectors per track 
....................                 gDataBuffer[25] = 0x00; 
....................  
....................                 gDataBuffer[26] = 0xFF;         //Number of heads 
....................                 gDataBuffer[27] = 0x00; 
....................  
....................                 // Hidden sectors = sectors between the MBR and the boot sector 
....................                 gDataBuffer[28] = (BYTE)(disk->firsts & 0xFF); 
....................                 gDataBuffer[29] = (BYTE)((disk->firsts / 0x100) & 0xFF); 
....................                 gDataBuffer[30] = (BYTE)((disk->firsts / 0x10000) & 0xFF); 
....................                 gDataBuffer[31] = (BYTE)((disk->firsts / 0x1000000) & 0xFF); 
....................  
....................                 // Total Sectors = same as sectors in the partition from MBR 
....................                 gDataBuffer[32] = (BYTE)(secCount & 0xFF); 
....................                 gDataBuffer[33] = (BYTE)((secCount / 0x100) & 0xFF); 
....................                 gDataBuffer[34] = (BYTE)((secCount / 0x10000) & 0xFF); 
....................                 gDataBuffer[35] = (BYTE)((secCount / 0x1000000) & 0xFF); 
....................  
....................                 gDataBuffer[36] = 0x00;         // Physical drive number 
....................  
....................                 gDataBuffer[37] = 0x00;         // Reserved (current head) 
....................  
....................                 gDataBuffer[38] = 0x29;         // Signature code 
....................  
....................                 gDataBuffer[39] = (BYTE)(serialNumber & 0xFF); 
....................                 gDataBuffer[40] = (BYTE)((serialNumber / 0x100) & 0xFF); 
....................                 gDataBuffer[41] = (BYTE)((serialNumber / 0x10000) & 0xFF); 
....................                 gDataBuffer[42] = (BYTE)((serialNumber / 0x1000000) & 0xFF); 
....................  
....................                 // Volume ID 
....................                 if (volumeID != NULL) 
....................                 { 
....................                     for (Index = 0; (*(volumeID + Index) != 0) && (Index < 11); Index++) 
....................                     { 
....................                         gDataBuffer[Index + 43] = *(volumeID + Index); 
....................                     } 
....................                     while (Index < 11) 
....................                     { 
....................                         gDataBuffer[43 + Index++] = 0x20; 
....................                     } 
....................                 } 
....................                 else 
....................                 { 
....................                     for (Index = 0; Index < 11; Index++) 
....................                     { 
....................                         gDataBuffer[Index+43] = 0; 
....................                     } 
....................                 } 
....................  
....................                 gDataBuffer[54] = 'F'; 
....................                 gDataBuffer[55] = 'A'; 
....................                 gDataBuffer[56] = 'T'; 
....................                 gDataBuffer[57] = '1'; 
....................                 gDataBuffer[59] = ' '; 
....................                 gDataBuffer[60] = ' '; 
....................                 gDataBuffer[61] = ' '; 
....................  
....................             } 
....................             else //FAT32 
....................             { 
....................                 gDataBuffer[14] = 0x20;         //Reserved sector count 
....................                 gDataBuffer[15] = 0x00; 
....................                 disk->fat = 0x20 + disk->firsts; 
....................  
....................                 gDataBuffer[16] = 0x02;         //number of FATs 
....................  
....................                 gDataBuffer[17] = 0x00;          //Max number of root directory entries - 512 files allowed 
....................                 gDataBuffer[18] = 0x00; 
....................  
....................                 gDataBuffer[19] = 0x00;         //total sectors 
....................                 gDataBuffer[20] = 0x00; 
....................  
....................                 gDataBuffer[21] = 0xF8;         //Media Descriptor 
....................  
....................                 gDataBuffer[22] = 0x00;         //Sectors per FAT 
....................                 gDataBuffer[23] = 0x00; 
....................  
....................                 gDataBuffer[24] = 0x3F;         //Sectors per track 
....................                 gDataBuffer[25] = 0x00; 
....................  
....................                 gDataBuffer[26] = 0xFF;         //Number of heads 
....................                 gDataBuffer[27] = 0x00; 
....................  
....................                 // Hidden sectors = sectors between the MBR and the boot sector 
....................                 gDataBuffer[28] = (BYTE)(disk->firsts & 0xFF); 
....................                 gDataBuffer[29] = (BYTE)((disk->firsts / 0x100) & 0xFF); 
....................                 gDataBuffer[30] = (BYTE)((disk->firsts / 0x10000) & 0xFF); 
....................                 gDataBuffer[31] = (BYTE)((disk->firsts / 0x1000000) & 0xFF); 
....................  
....................                 // Total Sectors = same as sectors in the partition from MBR 
....................                 gDataBuffer[32] = (BYTE)(secCount & 0xFF); 
....................                 gDataBuffer[33] = (BYTE)((secCount / 0x100) & 0xFF); 
....................                 gDataBuffer[34] = (BYTE)((secCount / 0x10000) & 0xFF); 
....................                 gDataBuffer[35] = (BYTE)((secCount / 0x1000000) & 0xFF); 
....................  
....................                 gDataBuffer[36] = fatsize & 0xFF;         //Sectors per FAT 
....................                 gDataBuffer[37] = (fatsize >>  8) & 0xFF; 
....................                 gDataBuffer[38] = (fatsize >> 16) & 0xFF; 
....................                 gDataBuffer[39] = (fatsize >> 24) & 0xFF; 
....................  
....................                 gDataBuffer[40] = 0x00;         //Active FAT 
....................                 gDataBuffer[41] = 0x00; 
....................  
....................                 gDataBuffer[42] = 0x00;         //File System version 
....................                 gDataBuffer[43] = 0x00; 
....................  
....................                 gDataBuffer[44] = 0x02;         //First cluster of the root directory 
....................                 gDataBuffer[45] = 0x00; 
....................                 gDataBuffer[46] = 0x00; 
....................                 gDataBuffer[47] = 0x00; 
....................  
....................                 gDataBuffer[48] = 0x01;         //FSInfo 
....................                 gDataBuffer[49] = 0x00; 
....................  
....................                 gDataBuffer[50] = 0x00;         //Backup Boot Sector 
....................                 gDataBuffer[51] = 0x00; 
....................  
....................                 gDataBuffer[52] = 0x00;         //Reserved for future expansion 
....................                 gDataBuffer[53] = 0x00; 
....................                 gDataBuffer[54] = 0x00; 
....................                 gDataBuffer[55] = 0x00; 
....................                 gDataBuffer[56] = 0x00; 
....................                 gDataBuffer[57] = 0x00; 
....................                 gDataBuffer[58] = 0x00; 
....................                 gDataBuffer[59] = 0x00; 
....................                 gDataBuffer[60] = 0x00; 
....................                 gDataBuffer[61] = 0x00; 
....................                 gDataBuffer[62] = 0x00; 
....................                 gDataBuffer[63] = 0x00; 
....................  
....................                 gDataBuffer[64] = 0x00;         // Physical drive number 
....................  
....................                 gDataBuffer[65] = 0x00;         // Reserved (current head) 
....................  
....................                 gDataBuffer[66] = 0x29;         // Signature code 
....................  
....................                 gDataBuffer[67] = (BYTE)(serialNumber & 0xFF); 
....................                 gDataBuffer[68] = (BYTE)((serialNumber / 0x100) & 0xFF); 
....................                 gDataBuffer[69] = (BYTE)((serialNumber / 0x10000) & 0xFF); 
....................                 gDataBuffer[70] = (BYTE)((serialNumber / 0x1000000) & 0xFF); 
....................  
....................                 // Volume ID 
....................                 if (volumeID != NULL) 
....................                 { 
....................                     for (Index = 0; (*(volumeID + Index) != 0) && (Index < 11); Index++) 
....................                     { 
....................                         gDataBuffer[Index + 71] = *(volumeID + Index); 
....................                     } 
....................                     while (Index < 11) 
....................                     { 
....................                         gDataBuffer[71 + Index++] = 0x20; 
....................                     } 
....................                 } 
....................                 else 
....................                 { 
....................                     for (Index = 0; Index < 11; Index++) 
....................                     { 
....................                         gDataBuffer[Index+71] = 0; 
....................                     } 
....................                 } 
....................  
....................                 gDataBuffer[82] = 'F'; 
....................                 gDataBuffer[83] = 'A'; 
....................                 gDataBuffer[84] = 'T'; 
....................                 gDataBuffer[85] = '3'; 
....................                 gDataBuffer[86] = '2'; 
....................                 gDataBuffer[87] = ' '; 
....................                 gDataBuffer[88] = ' '; 
....................                 gDataBuffer[89] = ' '; 
....................  
....................  
....................             } 
....................  
.................... #ifdef __18CXX 
....................             // C18 can't reference a value greater than 256 
....................             // using an array name pointer 
....................             *(dataBufferPointer + 510) = 0x55; 
....................             *(dataBufferPointer + 511) = 0xAA; 
.................... #else 
....................             gDataBuffer[510] = 0x55; 
....................             gDataBuffer[511] = 0xAA; 
.................... #endif 
....................  
....................             disk->root = disk->fat + (disk->fatcopy * disk->fatsize); 
....................  
....................             if (MDD_SectorWrite (disk->firsts, gDataBuffer, FALSE) == FALSE) 
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
....................                 return EOF; 
....................             } 
....................  
....................             break; 
....................         case 0: 
....................             if (LoadBootSector (disk) != CE_GOOD) 
....................             { 
....................                 FSerrno = CE_BADCACHEREAD; 
....................                 return EOF; 
....................             } 
....................             break; 
....................         default: 
....................             FSerrno = CE_INVALID_ARGUMENT; 
....................             return EOF; 
....................     } 
....................  
....................     // Erase the FAT 
....................     memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE); 
....................  
....................     if (disk->type == FAT32) 
....................     { 
....................         gDataBuffer[0] = 0xF8;          //BPB_Media byte value in its low 8 bits, and all other bits are set to 1 
....................         gDataBuffer[1] = 0xFF; 
....................         gDataBuffer[2] = 0xFF; 
....................         gDataBuffer[3] = 0xFF; 
....................  
....................         gDataBuffer[4] = 0x00;          //Disk is clean and no read/write errors were encountered 
....................         gDataBuffer[5] = 0x00; 
....................         gDataBuffer[6] = 0x00; 
....................         gDataBuffer[7] = 0x0C; 
....................  
....................         gDataBuffer[8]  = 0xFF;         //Root Directory EOF 
....................         gDataBuffer[9]  = 0xFF; 
....................         gDataBuffer[10] = 0xFF; 
....................         gDataBuffer[11] = 0xFF; 
....................  
....................         for (j = disk->fatcopy - 1; j != 0xFFFF; j--) 
....................         { 
....................             if (MDD_SectorWrite (disk->fat + (j * disk->fatsize), gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         memset (gDataBuffer, 0x00, 12); 
....................  
....................         for (Index = disk->fat + 1; Index < (disk->fat + disk->fatsize); Index++) 
....................         { 
....................             for (j = disk->fatcopy - 1; j != 0xFFFF; j--) 
....................             { 
....................                 if (MDD_SectorWrite (Index + (j * disk->fatsize), gDataBuffer, FALSE) == FALSE) 
....................                     return EOF; 
....................             } 
....................         } 
....................  
....................         // Erase the root directory 
....................         for (Index = 1; Index < disk->SecPerClus; Index++) 
....................         { 
....................             if (MDD_SectorWrite (disk->root + Index, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         if (volumeID != NULL) 
....................         { 
....................             // Create a drive name entry in the root dir 
....................             Index = 0; 
....................             while ((*(volumeID + Index) != 0) && (Index < 11)) 
....................             { 
....................                 gDataBuffer[Index] = *(volumeID + Index); 
....................                 Index++; 
....................             } 
....................             while (Index < 11) 
....................             { 
....................                 gDataBuffer[Index++] = ' '; 
....................             } 
....................             gDataBuffer[11] = 0x08; 
....................             gDataBuffer[17] = 0x11; 
....................             gDataBuffer[19] = 0x11; 
....................             gDataBuffer[23] = 0x11; 
....................  
....................             if (MDD_SectorWrite (disk->root, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................         else 
....................         { 
....................             if (MDD_SectorWrite (disk->root, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         return 0; 
....................     } 
....................     else 
....................     { 
....................         gDataBuffer[0] = 0xF8; 
....................         gDataBuffer[1] = 0xFF; 
....................         gDataBuffer[2] = 0xFF; 
....................         if (disk->type == FAT16) 
....................             gDataBuffer[3] = 0xFF; 
....................  
....................         for (j = disk->fatcopy - 1; j != 0xFFFF; j--) 
....................         { 
....................             if (MDD_SectorWrite (disk->fat + (j * disk->fatsize), gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         memset (gDataBuffer, 0x00, 4); 
....................  
....................         for (Index = disk->fat + 1; Index < (disk->fat + disk->fatsize); Index++) 
....................         { 
....................             for (j = disk->fatcopy - 1; j != 0xFFFF; j--) 
....................             { 
....................                 if (MDD_SectorWrite (Index + (j * disk->fatsize), gDataBuffer, FALSE) == FALSE) 
....................                     return EOF; 
....................             } 
....................         } 
....................  
....................       // Initialize the sector size 
....................         disk->sectorSize = MEDIA_SECTOR_SIZE; 
....................  
....................         // Erase the root directory 
....................         RootDirSectors = ((disk->maxroot * 32) + (disk->sectorSize - 1)) / disk->sectorSize; 
....................  
....................         for (Index = 1; Index < RootDirSectors; Index++) 
....................         { 
....................             if (MDD_SectorWrite (disk->root + Index, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         if (volumeID != NULL) 
....................         { 
....................             // Create a drive name entry in the root dir 
....................             Index = 0; 
....................             while ((*(volumeID + Index) != 0) && (Index < 11)) 
....................             { 
....................                 gDataBuffer[Index] = *(volumeID + Index); 
....................                 Index++; 
....................             } 
....................             while (Index < 11) 
....................             { 
....................                 gDataBuffer[Index++] = ' '; 
....................             } 
....................             gDataBuffer[11] = 0x08; 
....................             gDataBuffer[17] = 0x11; 
....................             gDataBuffer[19] = 0x11; 
....................             gDataBuffer[23] = 0x11; 
....................  
....................             if (MDD_SectorWrite (disk->root, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................         else 
....................         { 
....................             if (MDD_SectorWrite (disk->root, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         return 0; 
....................     } 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /******************************************************* 
....................   Function: 
....................     BYTE Write_File_Entry( FILEOBJ fo, WORD * curEntry) 
....................   Summary: 
....................     Write dir entry info into a specified entry 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -        \File structure 
....................     curEntry -  Write destination 
....................   Return Values: 
....................     TRUE - Operation successful 
....................     FALSE - Operation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will calculate the sector of the 
....................     directory (whose base sector is pointed to by the 
....................     dirccls value in the FSFILE object 'fo') that contains 
....................     a directory entry whose offset is indicated by the 
....................     curEntry parameter.  It will then write the data 
....................     in the global data buffer (which should already 
....................     contain the entries for that sector) to the device. 
....................   Remarks: 
....................     None 
....................   *******************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE Write_File_Entry( FILEOBJ fo, WORD * curEntry) 
*
03964:  MOV     W5,[W15++]
03966:  MOV     W6,[W15++]
03968:  MOV     W7,[W15++]
.................... { 
....................     DISK   *dsk; 
0396A:  CLR     100A
....................     BYTE   status; 
0396C:  CLR.B   100C
....................     BYTE   offset2; 
0396E:  CLR.B   100D
....................     DWORD   sector; 
03970:  CLR     100E
03972:  CLR     1010
....................     DWORD   ccls; 
03974:  CLR     1012
03976:  CLR     1014
....................  
....................     dsk = fo->dsk; 
03978:  MOV     1006,W4
0397A:  ADD     W4,#0,W4
0397C:  MOV     W4,W0
0397E:  MOV     [W0],[W15++]
03980:  POP     100A
....................  
....................     // get the cluster of this entry 
....................     ccls = fo->dirccls; 
03982:  MOV     #32,W0
03984:  ADD     1006,W0
03986:  MOV     #1012,W4
03988:  MOV     [W0++],[W4++]
0398A:  MOV     [W0++],[W4++]
....................  
....................      // figure out the offset from the base sector 
....................     offset2  = (*curEntry / (dsk->sectorSize/32)); 
0398C:  MOV     1008,W0
0398E:  MOV     [W0],W5
03990:  MOV     100A,W4
03992:  ADD     W4,#18,W4
03994:  MOV     W4,W0
03996:  MOV     #C,W1
03998:  MOV     W0,W2
0399A:  REPEAT  #3
0399C:  MOV.B   [W2++],[W1++]
0399E:  MOV     #5,W4
039A0:  CLR.B   9
039A2:  MOV.D   W6,W0
039A4:  INC     W4,W4
039A6:  DEC     W4,W4
039A8:  BRA     Z,39B0
039AA:  LSR     W1,W1
039AC:  RRC     W0,W0
039AE:  BRA     39A6
039B0:  BCLR.B  43.0
039B2:  MOV     W0,W2
039B4:  MOV     W1,W3
039B6:  MOV     W5,W0
039B8:  MOV     #0,W1
039BA:  CALL    1AE6
039BE:  MOV.B   W0L,100D
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
039C0:  MOV     #22,W4
039C2:  MOV     100A,W3
039C4:  ADD     W3,W4,W0
039C6:  MOV     #A,W1
039C8:  MOV     W0,W2
039CA:  MOV.B   [W2++],[W1++]
039CC:  MOV.B   W5L,W0L
039CE:  CLR.B   1
039D0:  XOR     #3,W0
039D2:  BRA     Z,39DA
039D4:  XOR     #1,W0
039D6:  BRA     Z,39FC
039D8:  BRA     3A2A
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             // Root is always cluster-based in FAT32 
....................             offset2 = offset2 % (dsk->SecPerClus); 
039DA:  MOV     #21,W4
039DC:  MOV     100A,W3
039DE:  ADD     W3,W4,W0
039E0:  MOV     #A,W1
039E2:  MOV     W0,W2
039E4:  MOV.B   [W2++],[W1++]
039E6:  MOV.B   100D,W0L
039E8:  CLR.B   1
039EA:  CLR.B   1
039EC:  CLR.B   B
039EE:  CLR.B   B
039F0:  REPEAT  #11
039F2:  DIV.U   W0,W5
039F4:  MOV.B   W1L,W0L
039F6:  MOV.B   W0L,100D
....................             break; 
039F8:  GOTO    3A2A
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
.................... #endif 
....................         case FAT16: 
....................             if(ccls != FatRootDirClusterValue) 
039FC:  MOV     1012,W0
039FE:  CP      858
03A00:  BRA     NZ,3A08
03A02:  MOV     1014,W0
03A04:  CP      85A
03A06:  BRA     Z,3A26
....................                 offset2 = offset2 % (dsk->SecPerClus); 
03A08:  MOV     #21,W4
03A0A:  MOV     100A,W3
03A0C:  ADD     W3,W4,W0
03A0E:  MOV     #A,W1
03A10:  MOV     W0,W2
03A12:  MOV.B   [W2++],[W1++]
03A14:  MOV.B   100D,W0L
03A16:  CLR.B   1
03A18:  CLR.B   1
03A1A:  CLR.B   B
03A1C:  CLR.B   B
03A1E:  REPEAT  #11
03A20:  DIV.U   W0,W5
03A22:  MOV.B   W1L,W0L
03A24:  MOV.B   W0L,100D
....................             break; 
03A26:  GOTO    3A2A
....................     } 
....................  
....................     sector = Cluster2Sector(dsk,ccls); 
03A2A:  PUSH    100A
03A2C:  POP     1056
03A2E:  PUSH    1012
03A30:  POP     1058
03A32:  PUSH    1014
03A34:  POP     105A
03A36:  CALL    308C
03A3A:  MOV     W0,100E
03A3C:  MOV     W1,1010
....................  
....................     // Now write it 
....................     // "Offset" ensures writing of data belonging to a file entry only. Hence it doesn't change other file entries. 
....................     if ( !MDD_SectorWrite( sector + offset2, dsk->buffer, FALSE)) 
03A3E:  MOV     100C,W4
03A40:  LSR     W4,#8,W4
03A42:  MOV     100E,W3
03A44:  ADD     W3,W4,W5
03A46:  MOV     1010,W3
03A48:  ADDC    W3,#0,W3
03A4A:  MOV     W3,W6
03A4C:  MOV     100A,W4
03A4E:  ADD     W4,#0,W4
03A50:  MOV     W4,W0
03A52:  MOV     #E,W1
03A54:  MOV     W0,W2
03A56:  REPEAT  #1
03A58:  MOV.B   [W2++],[W1++]
03A5A:  CLR.B   109E
03A5C:  MOV     W5,1098
03A5E:  MOV     W6,109A
03A60:  MOV     W7,109C
03A62:  CALL    2BBE
03A66:  CP0.B   W0L
03A68:  BRA     NZ,3A70
....................         status = FALSE; 
03A6A:  CLR.B   100C
03A6C:  GOTO    3A74
....................     else 
....................         status = TRUE; 
03A70:  MOV.B   #1,W0L
03A72:  MOV.B   W0L,100C
....................  
....................     return(status); 
03A74:  MOV.B   100C,W0L
03A76:  MOV.B   W0L,0
03A78:  MOV     [--W15],W7
03A7A:  MOV     [--W15],W6
03A7C:  MOV     [--W15],W5
03A7E:  RETURN  
.................... } // Write_File_Entry 
.................... #endif 
....................  
....................  
.................... /********************************************************** 
....................   Function: 
....................     BYTE FAT_erase_cluster_chain (WORD cluster, DISK * dsk) 
....................   Summary: 
....................     Erase a chain of clusters 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     cluster -  The cluster number 
....................     dsk -      The disk structure 
....................   Return Values: 
....................     TRUE -  Operation successful 
....................     FALSE - Operation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will parse through a cluster chain 
....................     starting with the cluster pointed to by 'cluster' and 
....................     mark all of the FAT entries as empty until the end of 
....................     the chain has been reached or an error occurs. 
....................   Remarks: 
....................     None 
....................   **********************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE FAT_erase_cluster_chain (DWORD cluster, DISK * dsk) 
03A80:  MOV     W5,[W15++]
03A82:  MOV     W6,[W15++]
.................... { 
....................     DWORD     c,c2,ClusterFailValue; 
03A84:  CLR     100C
03A86:  CLR     100E
03A88:  CLR     1010
03A8A:  CLR     1012
03A8C:  CLR     1014
03A8E:  CLR     1016
....................     enum    _status {Good, Fail, Exit}status; 
03A90:  CLR.B   1018
....................  
....................     status = Good; 
03A92:  CLR.B   1018
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
03A94:  MOV     #22,W4
03A96:  MOV     100A,W3
03A98:  ADD     W3,W4,W0
03A9A:  MOV     #A,W1
03A9C:  MOV     W0,W2
03A9E:  MOV.B   [W2++],[W1++]
03AA0:  MOV.B   W5L,W0L
03AA2:  CLR.B   1
03AA4:  XOR     #3,W0
03AA6:  BRA     Z,3AAE
03AA8:  XOR     #1,W0
03AAA:  BRA     Z,3AC0
03AAC:  BRA     3AC0
....................     { 
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             ClusterFailValue = CLUSTER_FAIL_FAT32; 
03AAE:  SETM    1014
03AB0:  MOV     #FFF,W4
03AB2:  MOV     W4,1016
....................             c2 =  LAST_CLUSTER_FAT32; 
03AB4:  MOV     #FFF8,W4
03AB6:  MOV     W4,1010
03AB8:  MOV     #FFF,W4
03ABA:  MOV     W4,1012
....................             break; 
03ABC:  GOTO    3ACE
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; // FAT16 value itself 
....................             c2 =  LAST_CLUSTER_FAT12; 
....................             break; 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
03AC0:  SETM    1014
03AC2:  CLR     1016
....................             c2 =  LAST_CLUSTER_FAT16; 
03AC4:  MOV     #FFF8,W4
03AC6:  MOV     W4,1010
03AC8:  CLR     1012
....................             break; 
03ACA:  GOTO    3ACE
....................     } 
....................  
....................     // Make sure there is actually a cluster assigned 
....................     if((cluster == 0) || (cluster == 1))  // Cluster assigned can't be "0" and "1" 
03ACE:  CP0     1006
03AD0:  BRA     NZ,3AD6
03AD2:  CP0     1008
03AD4:  BRA     Z,3AE0
03AD6:  MOV     1006,W4
03AD8:  CP      W4,#1
03ADA:  BRA     NZ,3AE8
03ADC:  CP0     1008
03ADE:  BRA     NZ,3AE8
....................     { 
....................         status = Exit; 
03AE0:  MOV.B   #2,W0L
03AE2:  MOV.B   W0L,1018
....................     } 
03AE4:  GOTO    3B7A
....................     else 
....................     { 
....................         while(status == Good) 
03AE8:  CP0.B   1018
03AEA:  BRA     NZ,3B7A
....................         { 
....................             // Get the FAT entry 
....................             if((c = ReadFAT( dsk, cluster)) == ClusterFailValue) 
03AEC:  PUSH    100A
03AEE:  POP     1048
03AF0:  PUSH    1006
03AF2:  POP     104A
03AF4:  PUSH    1008
03AF6:  POP     104C
03AF8:  CALL    2ECC
03AFC:  MOV     W0,100C
03AFE:  MOV     W1,100E
03B00:  MOV     100C,W0
03B02:  CP      1014
03B04:  BRA     NZ,3B14
03B06:  MOV     100E,W0
03B08:  CP      1016
03B0A:  BRA     NZ,3B14
....................                 status = Fail; 
03B0C:  MOV.B   #1,W0L
03B0E:  MOV.B   W0L,1018
03B10:  GOTO    3B76
....................             else 
....................             { 
....................                 if((c == 0) || (c == 1))  // Cluster assigned can't be "0" and "1" 
03B14:  CP0     100C
03B16:  BRA     NZ,3B1C
03B18:  CP0     100E
03B1A:  BRA     Z,3B26
03B1C:  MOV     100C,W4
03B1E:  CP      W4,#1
03B20:  BRA     NZ,3B2E
03B22:  CP0     100E
03B24:  BRA     NZ,3B2E
....................                 { 
....................                     status = Exit; 
03B26:  MOV.B   #2,W0L
03B28:  MOV.B   W0L,1018
....................                 } 
03B2A:  GOTO    3B76
....................                 else 
....................                 { 
....................                     // compare against max value of a cluster in FATxx 
....................                     // look for the last cluster in the chain 
....................                     if ( c >= c2) 
03B2E:  MOV     1012,W0
03B30:  MOV     100E,W4
03B32:  CP      W4,W0
03B34:  BRA     NC,3B44
03B36:  BRA     GTU,3B40
03B38:  MOV     1010,W0
03B3A:  MOV     100C,W4
03B3C:  CP      W4,W0
03B3E:  BRA     NC,3B44
....................                         status = Exit; 
03B40:  MOV.B   #2,W0L
03B42:  MOV.B   W0L,1018
....................  
....................                     // Now erase this FAT entry 
....................                     if(WriteFAT(dsk, cluster, CLUSTER_EMPTY, FALSE) == ClusterFailValue) 
03B44:  CLR.B   1078
03B46:  PUSH    100A
03B48:  POP     106E
03B4A:  PUSH    1006
03B4C:  POP     1070
03B4E:  PUSH    1008
03B50:  POP     1072
03B52:  CLR     1074
03B54:  CLR     1076
03B56:  CALL    2C18
03B5A:  MOV     W0,W5
03B5C:  MOV     W1,W6
03B5E:  MOV     1014,W4
03B60:  CP      W4,W5
03B62:  BRA     NZ,3B6E
03B64:  MOV     1016,W4
03B66:  CP      W4,W6
03B68:  BRA     NZ,3B6E
....................                         status = Fail; 
03B6A:  MOV.B   #1,W0L
03B6C:  MOV.B   W0L,1018
....................  
....................                     // now update what the current cluster is 
....................                     cluster = c; 
03B6E:  PUSH    100C
03B70:  POP     1006
03B72:  PUSH    100E
03B74:  POP     1008
....................                 } 
....................             } 
03B76:  GOTO    3AE8
....................         }// while status 
....................     }// cluster == 0 
....................  
....................     WriteFAT (dsk, 0, 0, TRUE); 
03B7A:  MOV.B   #1,W0L
03B7C:  MOV.B   W0L,1078
03B7E:  PUSH    100A
03B80:  POP     106E
03B82:  CLR     1070
03B84:  CLR     1072
03B86:  CLR     1074
03B88:  CLR     1076
03B8A:  CALL    2C18
....................  
....................     if(status == Exit) 
03B8E:  MOV     1018,W4
03B90:  CP.B    W4L,#2
03B92:  BRA     NZ,3B9E
....................         return(TRUE); 
03B94:  MOV.B   #1,W0L
03B96:  MOV.B   W0L,0
03B98:  BRA     3BA2
03B9A:  GOTO    3BA2
....................     else 
....................         return(FALSE); 
03B9E:  CLR.B   0
03BA0:  BRA     3BA2
03BA2:  MOV     [--W15],W6
03BA4:  MOV     [--W15],W5
03BA6:  RETURN  
.................... } // Erase cluster 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     DIRENTRY Cache_File_Entry( FILEOBJ fo, WORD * curEntry, BYTE ForceRead) 
....................   Summary: 
....................     Load a file entry 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -         File information 
....................     curEntry -   Offset of the directory entry to load. 
....................     ForceRead -  Forces loading of a new sector of the directory. 
....................   Return: 
....................     DIRENTRY - Pointer to the directory entry that was loaded. 
....................   Side Effects: 
....................     Any unwritten data in the data buffer will be written to the device. 
....................   Description: 
....................     Load the sector containing the file entry pointed to by 'curEntry' 
....................     from the directory pointed to by the variables in 'fo.' 
....................   Remarks: 
....................     Any modification of this function is extremely likely to 
....................     break something. 
....................   **************************************************************************/ 
....................  
.................... DIRENTRY Cache_File_Entry( FILEOBJ fo, WORD * curEntry, BYTE ForceRead) 
*
031E4:  MOV     W5,[W15++]
031E6:  MOV     W6,[W15++]
031E8:  MOV     W7,[W15++]
031EA:  MOV     W8,[W15++]
.................... { 
....................     DIRENTRY dir; 
031EC:  CLR     102E
....................     DISK *dsk; 
031EE:  CLR     1030
....................     DWORD sector; 
031F0:  CLR     1032
031F2:  CLR     1034
....................     DWORD cluster, LastClusterLimit; 
031F4:  CLR     1036
031F6:  CLR     1038
031F8:  CLR     103A
031FA:  CLR     103C
....................     DWORD ccls; 
031FC:  CLR     103E
031FE:  CLR     1040
....................     BYTE offset2; 
03200:  CLR.B   102D
....................     BYTE numofclus; 
03202:  CLR.B   1042
....................    BYTE dirEntriesPerSector; 
03204:  CLR.B   1043
....................  
....................     dsk = fo->dsk; 
03206:  MOV     1028,W4
03208:  ADD     W4,#0,W4
0320A:  MOV     W4,W0
0320C:  MOV     [W0],[W15++]
0320E:  POP     1030
....................  
....................     // get the base sector of this directory 
....................     cluster = fo->dirclus; 
03210:  MOV     #2E,W0
03212:  ADD     1028,W0
03214:  MOV     #1036,W4
03216:  MOV     [W0++],[W4++]
03218:  MOV     [W0++],[W4++]
....................     ccls = fo->dirccls; 
0321A:  MOV     #32,W0
0321C:  ADD     1028,W0
0321E:  MOV     #103E,W4
03220:  MOV     [W0++],[W4++]
03222:  MOV     [W0++],[W4++]
....................  
....................    dirEntriesPerSector = dsk->sectorSize/32; 
03224:  MOV     1030,W4
03226:  ADD     W4,#18,W4
03228:  MOV     W4,W0
0322A:  MOV     #A,W1
0322C:  MOV     W0,W2
0322E:  REPEAT  #3
03230:  MOV.B   [W2++],[W1++]
03232:  MOV     #5,W4
03234:  CLR.B   9
03236:  MOV     W5,W0
03238:  MOV     W6,W1
0323A:  INC     W4,W4
0323C:  DEC     W4,W4
0323E:  BRA     Z,3246
03240:  LSR     W1,W1
03242:  RRC     W0,W0
03244:  BRA     323C
03246:  MOV.B   W0L,1043
....................  
....................      // figure out the offset from the base sector 
....................     offset2  = (*curEntry / dirEntriesPerSector); 
03248:  MOV     102A,W0
0324A:  MOV     [W0],W5
0324C:  MOV     W5,W4
0324E:  MOV.B   1043,W0L
03250:  CLR.B   1
03252:  MOV.B   W0L,W3L
03254:  CLR.B   7
03256:  REPEAT  #11
03258:  DIV.U   W4,W3
0325A:  MOV.B   W0L,102D
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
0325C:  MOV     #22,W4
0325E:  MOV     1030,W3
03260:  ADD     W3,W4,W0
03262:  MOV     #A,W1
03264:  MOV     W0,W2
03266:  MOV.B   [W2++],[W1++]
03268:  MOV.B   W5L,W0L
0326A:  CLR.B   1
0326C:  XOR     #3,W0
0326E:  BRA     Z,3276
03270:  XOR     #1,W0
03272:  BRA     Z,32A0
03274:  BRA     32A0
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             // the ROOT is always cluster based in FAT32 
....................             /* In FAT32: There is no ROOT region. Root etries are made in DATA region only. 
....................             Every cluster of DATA which is accupied by ROOT is tracked by FAT table/entry so the ROOT can grow 
....................             to an amount which is restricted only by available free DATA region. */ 
....................             offset2  = offset2 % (dsk->SecPerClus);   // figure out the offset 
03276:  MOV     #21,W4
03278:  MOV     1030,W3
0327A:  ADD     W3,W4,W0
0327C:  MOV     #A,W1
0327E:  MOV     W0,W2
03280:  MOV.B   [W2++],[W1++]
03282:  MOV.B   102D,W0L
03284:  CLR.B   1
03286:  CLR.B   1
03288:  CLR.B   B
0328A:  CLR.B   B
0328C:  REPEAT  #11
0328E:  DIV.U   W0,W5
03290:  MOV.B   W1L,W0L
03292:  MOV.B   W0L,102D
....................             LastClusterLimit = LAST_CLUSTER_FAT32; 
03294:  MOV     #FFF8,W4
03296:  MOV     W4,103A
03298:  MOV     #FFF,W4
0329A:  MOV     W4,103C
....................             break; 
0329C:  GOTO    32D0
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             // if its the root its not cluster based 
....................             if(cluster != 0) 
032A0:  CP0     1036
032A2:  BRA     NZ,32A8
032A4:  CP0     1038
032A6:  BRA     Z,32C6
....................                 offset2  = offset2 % (dsk->SecPerClus);   // figure out the offset 
032A8:  MOV     #21,W4
032AA:  MOV     1030,W3
032AC:  ADD     W3,W4,W0
032AE:  MOV     #A,W1
032B0:  MOV     W0,W2
032B2:  MOV.B   [W2++],[W1++]
032B4:  MOV.B   102D,W0L
032B6:  CLR.B   1
032B8:  CLR.B   1
032BA:  CLR.B   B
032BC:  CLR.B   B
032BE:  REPEAT  #11
032C0:  DIV.U   W0,W5
032C2:  MOV.B   W1L,W0L
032C4:  MOV.B   W0L,102D
....................             LastClusterLimit = LAST_CLUSTER_FAT16; 
032C6:  MOV     #FFF8,W4
032C8:  MOV     W4,103A
032CA:  CLR     103C
....................             break; 
032CC:  GOTO    32D0
....................     } 
....................  
....................    //#ifdef __DEBUG_UART   
....................    #if 0 
....................    PrintROMASCIIStringUART("Cache_File_Entry"); 
....................     
....................    PrintROMASCIIStringUART(" cluster="); 
....................    PrintRAMBytesUART(((unsigned char*)&cluster), sizeof(cluster)); 
....................  
....................    PrintROMASCIIStringUART(" ccls="); 
....................    PrintRAMBytesUART(((unsigned char*)&ccls), sizeof(ccls)); 
....................  
....................    PrintROMASCIIStringUART(" dirEntriesPerSector="); 
....................    PrintRAMBytesUART(((unsigned char*)&dirEntriesPerSector), sizeof(dirEntriesPerSector)); 
....................  
....................    PrintROMASCIIStringUART(" LastClusterLimit="); 
....................    PrintRAMBytesUART(((unsigned char*)&LastClusterLimit), sizeof(LastClusterLimit)); 
....................  
....................    PrintROMASCIIStringUART(" offset2="); 
....................    PrintRAMBytesUART(((unsigned char*)&offset2), sizeof(offset2)); 
....................  
....................    PrintROMASCIIStringUART(" curEntry="); 
....................    PrintRAMBytesUART(((unsigned char*)curEntry), sizeof(WORD)); 
....................    #endif 
....................  
....................     // check if a new sector of the root must be loaded 
....................     if (ForceRead || ((*curEntry & MASK_MAX_FILE_ENTRY_LIMIT_BITS) == 0))     // only 16 entries per sector 
032D0:  CP0.B   102C
032D2:  BRA     NZ,32DE
032D4:  MOV     102A,W0
032D6:  MOV     [W0],W5
032D8:  AND     W5,#F,W5
032DA:  CP0     W5
032DC:  BRA     NZ,347E
....................     { 
....................         // see if we have to load a new cluster 
....................         if(((offset2 == 0) && (*curEntry >= dirEntriesPerSector)) || ForceRead) 
032DE:  CP0.B   102D
032E0:  BRA     NZ,32F0
032E2:  MOV     102A,W0
032E4:  MOV     [W0],W5
032E6:  MOV.B   1043,W0L
032E8:  CLR.B   1
032EA:  CP      W0,W5
032EC:  BRA     GTU,32F0
032EE:  BRA     32F4
032F0:  CP0.B   102C
032F2:  BRA     Z,336E
....................         { 
....................             if(cluster == 0) 
032F4:  CP0     1036
032F6:  BRA     NZ,3304
032F8:  CP0     1038
032FA:  BRA     NZ,3304
....................             { 
....................                 ccls = 0; 
032FC:  CLR     103E
032FE:  CLR     1040
....................             } 
03300:  GOTO    336E
....................             else 
....................             { 
....................                 // If ForceRead, read the number of sectors from 0 
....................                 if(ForceRead) 
03304:  CP0.B   102C
03306:  BRA     Z,3332
....................                     numofclus = ((WORD)(*curEntry) / (WORD)(((WORD)dirEntriesPerSector) * (WORD)dsk->SecPerClus)); 
03308:  MOV     102A,W0
0330A:  MOV     [W0],W5
0330C:  MOV.B   1043,W0L
0330E:  MOV.B   W0L,W6L
03310:  CLR.B   D
03312:  MOV     #21,W4
03314:  MOV     1030,W3
03316:  ADD     W3,W4,W0
03318:  MOV     #E,W1
0331A:  MOV     W0,W2
0331C:  MOV.B   [W2++],[W1++]
0331E:  MOV.B   W7L,W0L
03320:  CLR.B   1
03322:  MUL.UU  W6,W0,W0
03324:  MOV     W5,W4
03326:  MOV     W0,W3
03328:  REPEAT  #11
0332A:  DIV.U   W4,W3
0332C:  MOV.B   W0L,1042
0332E:  GOTO    3336
....................                 // Otherwise just read the next sector 
....................                 else 
....................                     numofclus = 1; 
03332:  MOV.B   #1,W0L
03334:  MOV.B   W0L,1042
....................  
....................                 // move to the correct cluster 
....................                 while(numofclus) 
03336:  CP0.B   1042
03338:  BRA     Z,336E
....................                 { 
....................                     ccls = ReadFAT(dsk, ccls); 
0333A:  PUSH    1030
0333C:  POP     1048
0333E:  PUSH    103E
03340:  POP     104A
03342:  PUSH    1040
03344:  POP     104C
03346:  CALL    2ECC
0334A:  MOV     W0,103E
0334C:  MOV     W1,1040
....................  
....................                     if(ccls >= LastClusterLimit) 
0334E:  MOV     103C,W0
03350:  MOV     1040,W4
03352:  CP      W4,W0
03354:  BRA     NC,3368
03356:  BRA     GTU,3360
03358:  MOV     103A,W0
0335A:  MOV     103E,W4
0335C:  CP      W4,W0
0335E:  BRA     NC,3368
....................                         break; 
03360:  GOTO    336E
03364:  GOTO    336A
....................                     else 
....................                         numofclus--; 
03368:  DEC.B   1042
0336A:  GOTO    3336
....................                 } 
....................             } 
....................         } 
....................  
....................    //#ifdef __DEBUG_UART   
....................    #if 0 
....................    PrintROMASCIIStringUART(" numofclus="); 
....................    PrintRAMBytesUART(((unsigned char*)&numofclus), sizeof(numofclus)); 
....................  
....................    PrintROMASCIIStringUART(" ccls="); 
....................    PrintRAMBytesUART(((unsigned char*)&ccls), sizeof(ccls)); 
....................    #endif 
....................  
....................         // see if that we have a valid cluster number 
....................         if(ccls < LastClusterLimit) 
0336E:  MOV     1040,W0
03370:  MOV     103C,W4
03372:  CP      W4,W0
03374:  BRA     NC,3474
03376:  BRA     GTU,3380
03378:  MOV     103E,W0
0337A:  MOV     103A,W4
0337C:  CP      W4,W0
0337E:  BRA     LEU,3474
....................         { 
....................             fo->dirccls = ccls; // write it back 
03380:  MOV     #32,W0
03382:  ADD     1028,W0
03384:  MOV     W0,W5
03386:  MOV     #103E,W4
03388:  MOV     [W4++],[W5++]
0338A:  MOV     [W4++],[W5++]
....................  
....................             sector = Cluster2Sector(dsk,ccls); 
0338C:  PUSH    1030
0338E:  POP     1056
03390:  PUSH    103E
03392:  POP     1058
03394:  PUSH    1040
03396:  POP     105A
03398:  CALL    308C
0339C:  MOV     W0,1032
0339E:  MOV     W1,1034
....................  
....................             //#ifdef __DEBUG_UART   
....................             #if 0 
....................             PrintROMASCIIStringUART(" sector="); 
....................             PrintRAMBytesUART(((unsigned char*)&sector), sizeof(sector)); 
....................             #endif 
....................  
....................  
....................             /* see if we are root and about to go pass our boundaries 
....................             FAT32 stores the root directory in the Data Region along with files and other directories, 
....................             allowing it to grow without such a restraint */ 
....................             if((ccls == FatRootDirClusterValue) && ((sector + offset2) >= dsk->data) && (FAT32 != dsk->type)) 
033A0:  MOV     103E,W0
033A2:  CP      858
033A4:  BRA     NZ,33E8
033A6:  MOV     1040,W0
033A8:  CP      85A
033AA:  BRA     NZ,33E8
033AC:  MOV     102C,W4
033AE:  LSR     W4,#8,W4
033B0:  MOV     1032,W3
033B2:  ADD     W3,W4,W5
033B4:  MOV     1034,W3
033B6:  ADDC    W3,#0,W3
033B8:  MOV     W3,W6
033BA:  MOV     1030,W4
033BC:  ADD     W4,#E,W4
033BE:  MOV     W4,W0
033C0:  MOV     #E,W1
033C2:  MOV     W0,W2
033C4:  REPEAT  #3
033C6:  MOV.B   [W2++],[W1++]
033C8:  CP      W8,W6
033CA:  BRA     GTU,33E8
033CC:  BRA     NC,33D2
033CE:  CP      W7,W5
033D0:  BRA     GTU,33E8
033D2:  MOV     #22,W4
033D4:  MOV     1030,W3
033D6:  ADD     W3,W4,W0
033D8:  MOV     #A,W1
033DA:  MOV     W0,W2
033DC:  MOV.B   [W2++],[W1++]
033DE:  CP.B    W5L,#3
033E0:  BRA     Z,33E8
....................             { 
....................                 dir = ((DIRENTRY)NULL);   // reached the end of the root 
033E2:  CLR     102E
....................             } 
033E4:  GOTO    3470
....................             else 
....................             { 
.................... #ifdef ALLOW_WRITES 
....................                 if (gNeedDataWrite) 
033E8:  CP0.B   854
033EA:  BRA     Z,33F8
....................                     if (flushData()) 
033EC:  CALL    3170
033F0:  CP0.B   W0L
033F2:  BRA     Z,33F8
....................                         return NULL; 
033F4:  CLR     0
033F6:  BRA     34AA
.................... #endif 
....................                 gBufferOwner = NULL; 
033F8:  CLR     84E
....................                 gBufferZeroed = FALSE; 
033FA:  CLR.B   856
....................  
....................                 if ( MDD_SectorRead( sector + offset2, dsk->buffer) != TRUE) // if FALSE: sector could not be read. 
033FC:  MOV     102C,W4
033FE:  LSR     W4,#8,W4
03400:  MOV     1032,W3
03402:  ADD     W3,W4,W5
03404:  MOV     1034,W3
03406:  ADDC    W3,#0,W3
03408:  MOV     W3,W6
0340A:  MOV     1030,W4
0340C:  ADD     W4,#0,W4
0340E:  MOV     W4,W0
03410:  MOV     #E,W1
03412:  MOV     W0,W2
03414:  REPEAT  #1
03416:  MOV.B   [W2++],[W1++]
03418:  MOV     W5,1098
0341A:  MOV     W6,109A
0341C:  MOV     W7,109C
0341E:  CALL    1722
03422:  CP.B    W0L,#1
03424:  BRA     Z,342C
....................                 { 
....................                     dir = ((DIRENTRY)NULL); 
03426:  CLR     102E
....................                 } 
03428:  GOTO    346C
....................                 else // Sector has been read properly, Copy the root entry info of the file searched. 
....................                 { 
....................                     if(ForceRead)    // Buffer holds all 16 root entry info. Point to the one required. 
0342C:  CP0.B   102C
0342E:  BRA     Z,345C
....................                         dir = (DIRENTRY)((DIRENTRY)dsk->buffer) + ((*curEntry)%dirEntriesPerSector); 
03430:  MOV     1030,W4
03432:  ADD     W4,#0,W4
03434:  MOV     W4,W0
03436:  MOV     #A,W1
03438:  MOV     W0,W2
0343A:  REPEAT  #1
0343C:  MOV.B   [W2++],[W1++]
0343E:  MOV     102A,W0
03440:  MOV     [W0],W6
03442:  MOV     W6,W4
03444:  MOV.B   1043,W0L
03446:  CLR.B   1
03448:  MOV.B   W0L,W3L
0344A:  CLR.B   7
0344C:  REPEAT  #11
0344E:  DIV.U   W4,W3
03450:  MOV     W1,W6
03452:  SL      W6,#5,W0
03454:  ADD     W0,W5,W0
03456:  MOV     W0,102E
03458:  GOTO    346C
....................                     else 
....................                         dir = (DIRENTRY)dsk->buffer; 
0345C:  MOV     1030,W4
0345E:  ADD     W4,#0,W4
03460:  MOV     W4,W0
03462:  MOV     #A,W1
03464:  MOV     W0,W2
03466:  REPEAT  #1
03468:  MOV.B   [W2++],[W1++]
0346A:  MOV     W5,102E
....................                 } 
....................                //#ifdef __DEBUG_UART   
....................                #if 0 
....................                PrintROMASCIIStringUART(" dirread="); 
....................                PrintRAMBytesUART(((unsigned char*)&dir), sizeof(dir)); 
....................                #endif                 
....................                 gLastDataSectorRead = 0xFFFFFFFF; 
0346C:  SETM    850
0346E:  SETM    852
....................             } 
....................         } 
03470:  GOTO    347A
....................         else 
....................         { 
....................             nextClusterIsLast = TRUE; 
03474:  MOV.B   #1,W0L
03476:  MOV.B   W0L,855
....................             dir = ((DIRENTRY)NULL); 
03478:  CLR     102E
....................         } 
....................     } 
0347A:  GOTO    34A6
....................     else 
....................     { 
....................         dir = (DIRENTRY)((DIRENTRY)dsk->buffer) + ((*curEntry)%dirEntriesPerSector); 
0347E:  MOV     1030,W4
03480:  ADD     W4,#0,W4
03482:  MOV     W4,W0
03484:  MOV     #A,W1
03486:  MOV     W0,W2
03488:  REPEAT  #1
0348A:  MOV.B   [W2++],[W1++]
0348C:  MOV     102A,W0
0348E:  MOV     [W0],W6
03490:  MOV     W6,W4
03492:  MOV.B   1043,W0L
03494:  CLR.B   1
03496:  MOV.B   W0L,W3L
03498:  CLR.B   7
0349A:  REPEAT  #11
0349C:  DIV.U   W4,W3
0349E:  MOV     W1,W6
034A0:  SL      W6,#5,W0
034A2:  ADD     W0,W5,W0
034A4:  MOV     W0,102E
....................                //#ifdef __DEBUG_UART   
....................                #if 0 
....................                PrintROMASCIIStringUART(" dirmath="); 
....................                PrintRAMBytesUART(((unsigned char*)&dir), sizeof(dir)); 
....................                #endif                 
....................     } 
....................  
....................     return(dir); 
034A6:  PUSH    102E
034A8:  POP     0
034AA:  MOV     [--W15],W8
034AC:  MOV     [--W15],W7
034AE:  MOV     [--W15],W6
034B0:  MOV     [--W15],W5
034B2:  RETURN  
.................... } // Cache_File_Entry 
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     CETYPE CreateFileEntry(FILEOBJ fo, WORD *fHandle, BYTE mode, BOOL createFirstCluster) 
....................   Summary: 
....................     Create a new file entry 
....................   Conditions: 
....................     Should not be called by the user. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................     fHandle -  Location to create file 
....................     mode - DIRECTORY mode or ARCHIVE mode 
....................     createFirstCluster - If set to TRUE, first cluster is created 
....................   Return Values: 
....................     CE_GOOD -        File Creation successful 
....................     CE_DIR_FULL -    All root directory entries are taken 
....................     CE_WRITE_ERROR - The head cluster of the file could not be created. 
....................   Side Effects: 
....................     Modifies the FSerrno variable. 
....................   Description: 
....................     With the data passed within fo, create a new file entry in the current 
....................     directory.  This function will first search for empty file entries. 
....................     Once an empty entry is found, the entry will be populated with data 
....................     for a file or directory entry.  Finally, the first cluster of the 
....................     new file will be located and allocated, and its value will be 
....................     written into the file entry. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... CETYPE CreateFileEntry(FILEOBJ fo, WORD *fHandle, BYTE mode, BOOL createFirstCluster) 
*
043FA:  MOV     W5,[W15++]
043FC:  CLR.B   FD8
.................... { 
....................     CETYPE  error = CE_GOOD; 
....................  
....................    #if defined(SUPPORT_LFN) 
....................    LFN_ENTRY *lfno; 
....................    unsigned short int   *templfnPtr = (unsigned short int *)fo -> utf16LFNptr,*dest; 
....................    unsigned short int   tempString[MAX_UTF16_CHARS_IN_LFN_ENTRY]; 
....................    UINT16_VAL tempShift; 
....................     BOOL    firstTime = TRUE; 
....................    BYTE   checksum,sequenceNumber,reminder,tempCalc1,numberOfFileEntries; 
....................     char    index; 
....................    char    *src; 
....................    #endif 
....................  
....................    FSerrno = CE_GOOD; 
043FE:  CLR.B   857
....................  
....................    *fHandle = 0; 
04400:  MOV     FD4,W5
04402:  CLR.B   [W5]
04404:  MOV.B   #0,W0L
04406:  MOV.B   W0L,[W5+#1]
....................  
....................     // figure out where to put this file in the directory stucture 
....................     if(FindEmptyEntries(fo, fHandle) == FOUND) 
04408:  PUSH    FD2
0440A:  POP     FDE
0440C:  PUSH    FD4
0440E:  POP     FE0
04410:  CALL    3F70
04414:  CP0.B   W0L
04416:  BRA     NZ,4444
....................     { 
....................       #if defined(SUPPORT_LFN) 
....................       // If LFN entry 
....................       if(fo->utf16LFNlength) 
....................       { 
....................          // Alias the LFN to short file name 
....................          if(!Alias_LFN_Object(fo)) 
....................          { 
....................             // If Aliasing of LFN is unsucessful 
....................             error = FSerrno = CE_FILENAME_EXISTS; 
....................             return(error); 
....................          } 
....................  
....................          src = fo -> name; 
....................  
....................            // Find the checksum for Short file name of LFN 
....................            checksum = 0; 
....................            for (index = 11; index != 0; index--) 
....................            { 
....................             checksum = ((checksum & 1) ? 0x80 : 0) + (checksum >> 1) + *src++; 
....................          } 
....................  
....................          // File Name + NULL character is file name length in LFN 
....................          fileNameLength = fo->utf16LFNlength; 
....................  
....................          // Determine the number of entries for LFN 
....................          reminder = tempCalc1 = fileNameLength % MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................          numberOfFileEntries = fileNameLength/MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................          if(tempCalc1 || (fileNameLength < MAX_UTF16_CHARS_IN_LFN_ENTRY)) 
....................          { 
....................             numberOfFileEntries++; 
....................          } 
....................  
....................          // Max sequence number for LFN root entry 
....................          sequenceNumber = numberOfFileEntries | 0x40; 
....................  
....................          // Store the max sequence number entries in tempString 
....................          if(tempCalc1) 
....................          { 
....................             index = 0; 
....................             while(tempCalc1) 
....................             { 
....................                tempString[(BYTE)index++] = templfnPtr[fileNameLength - tempCalc1]; 
....................                tempCalc1--; 
....................             } 
....................  
....................             tempString[(BYTE)index++] = 0x0000; 
....................  
....................             // Store the remaining bytes of max sequence number entries with 0xFF 
....................             for(;index < MAX_UTF16_CHARS_IN_LFN_ENTRY;index++) 
....................             { 
....................                tempString[(BYTE)index] = 0xFFFF; 
....................             } 
....................          } 
....................          else 
....................          { 
....................             // Store the remaining bytes of max sequence number entries with 0xFF 
....................             for(index = MAX_UTF16_CHARS_IN_LFN_ENTRY;index > 0;index--) 
....................             { 
....................                tempString[MAX_UTF16_CHARS_IN_LFN_ENTRY - (BYTE)index] = templfnPtr[fileNameLength - (BYTE)index]; 
....................             } 
....................          } 
....................  
....................          dest = &tempString[12]; 
....................  
....................          while(numberOfFileEntries) 
....................          { 
....................             fo->dirccls = fo->dirclus; 
....................              lfno = (LFN_ENTRY *)Cache_File_Entry( fo, fHandle, TRUE); 
....................  
....................              if (lfno == NULL) 
....................             { 
....................                  return CE_BADCACHEREAD; 
....................             } 
....................  
....................             // Write the 32 byte LFN Object as per FAT specification 
....................             lfno->LFN_SequenceNo = sequenceNumber--;   // Sequence number, 
....................  
....................             lfno->LFN_Part3[1] = *dest--; 
....................             lfno->LFN_Part3[0] = *dest--; 
....................  
....................             lfno->LFN_Part2[5] = *dest--; 
....................             lfno->LFN_Part2[4] = *dest--; 
....................             lfno->LFN_Part2[3] = *dest--; 
....................             lfno->LFN_Part2[2] = *dest--; 
....................             lfno->LFN_Part2[1] = *dest--; 
....................             lfno->LFN_Part2[0] = *dest--; 
....................  
....................             tempShift.Val = *dest--; 
....................             lfno->LFN_Part1[9] = tempShift.byte.HB; 
....................             lfno->LFN_Part1[8] = tempShift.byte.LB; 
....................             tempShift.Val = *dest--; 
....................             lfno->LFN_Part1[7] = tempShift.byte.HB; 
....................             lfno->LFN_Part1[6] = tempShift.byte.LB; 
....................             tempShift.Val = *dest--; 
....................             lfno->LFN_Part1[5] = tempShift.byte.HB; 
....................             lfno->LFN_Part1[4] = tempShift.byte.LB; 
....................             tempShift.Val = *dest--; 
....................             lfno->LFN_Part1[3] = tempShift.byte.HB; 
....................             lfno->LFN_Part1[2] = tempShift.byte.LB; 
....................             tempShift.Val = *dest--; 
....................             lfno->LFN_Part1[1] = tempShift.byte.HB; 
....................             lfno->LFN_Part1[0] = tempShift.byte.LB; 
....................  
....................             lfno->LFN_Attribute = ATTR_LONG_NAME; 
....................             lfno->LFN_Type = 0; 
....................             lfno->LFN_Checksum = checksum; 
....................             lfno->LFN_Reserved2 = 0; 
....................  
....................              // just write the last entry in 
....................              if (Write_File_Entry(fo,fHandle) != TRUE) 
....................                  error = CE_WRITE_ERROR; 
....................  
....................                // 0x40 should be ORed with only max sequence number & in 
....................             // all other cases it should not be present 
....................                sequenceNumber &= (~0x40); 
....................                *fHandle = *fHandle + 1; 
....................             numberOfFileEntries--; 
....................  
....................             // Load the destination address only once and during first time, 
....................             if(firstTime) 
....................             { 
....................                if(reminder) 
....................                   dest = (unsigned short int *)(fo -> utf16LFNptr + fileNameLength - reminder - 1); 
....................                else 
....................                   dest = (unsigned short int *)(fo -> utf16LFNptr + fileNameLength - MAX_UTF16_CHARS_IN_LFN_ENTRY - 1); 
....................                firstTime = FALSE; 
....................             } 
....................          } 
....................       } 
....................       #endif 
....................  
....................         // found the entry, now populate it 
....................         if((error = PopulateEntries(fo, fHandle, mode)) == CE_GOOD) 
04418:  MOV.B   FD6,W0L
0441A:  MOV.B   W0L,FE2
0441C:  PUSH    FD2
0441E:  POP     FDE
04420:  PUSH    FD4
04422:  POP     FE0
04424:  CALL    40EA
04428:  MOV.B   W0L,FD8
0442A:  CP0.B   FD8
0442C:  BRA     NZ,4440
....................         { 
....................          if(createFirstCluster) 
0442E:  CP0.B   FD7
04430:  BRA     Z,4440
....................                // if everything is ok, create a first cluster 
....................                error = CreateFirstCluster(fo); 
04432:  PUSH    FD2
04434:  POP     FDE
04436:  CALL    4380
0443A:  MOV.B   W0L,FD8
0443C:  GOTO    4440
....................          else 
....................          { 
....................  
....................          } 
....................         } 
....................     } 
04440:  GOTO    4448
....................     else 
....................     { 
....................         error = CE_DIR_FULL; 
04444:  MOV.B   #14,W0L
04446:  MOV.B   W0L,FD8
....................     } 
....................  
....................     FSerrno = error; 
04448:  MOV.B   FD8,W0L
0444A:  MOV.B   W0L,857
....................  
....................     return(error); 
0444C:  MOV.B   FD8,W0L
0444E:  MOV.B   W0L,0
04450:  MOV     [--W15],W5
04452:  RETURN  
.................... } 
.................... #endif 
....................  
.................... /****************************************************** 
....................   Function: 
....................     CETYPE CreateFirstCluster(FILEOBJ fo) 
....................   Summary: 
....................     Create the first cluster for a file 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -  The file that contains the first cluster 
....................   Return Values: 
....................     CE_GOOD -        First cluster created successfully 
....................     CE_WRITE_ERROR - Cluster creation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will find an unused cluster, link it to 
....................     a file's directory entry, and write the entry back 
....................     to the device. 
....................   Remarks: 
....................     None. 
....................   ******************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... CETYPE CreateFirstCluster(FILEOBJ fo) 
*
04380:  MOV     W5,[W15++]
.................... { 
....................     CETYPE       error; 
04382:  CLR.B   FE0
....................     DWORD      cluster,TempMsbCluster; 
04384:  CLR     FE2
04386:  CLR     FE4
04388:  CLR     FE6
0438A:  CLR     FE8
....................     WORD        fHandle; 
0438C:  CLR     FEA
....................     DIRENTRY   dir; 
0438E:  CLR     FEC
....................     fHandle = fo->entry; 
04390:  MOV     #28,W0
04392:  ADD     FDE,W0
04394:  MOV     [W0],[W15++]
04396:  POP     FEA
....................  
....................     // Now create the first cluster (head cluster) 
....................     if((error = FILECreateHeadCluster(fo,&cluster)) == CE_GOOD) 
04398:  PUSH    FDE
0439A:  POP     FF0
0439C:  MOV     #FE2,W4
0439E:  MOV     W4,FF2
043A0:  CALL    421E
043A4:  MOV.B   W0L,FE0
043A6:  CP0.B   FE0
043A8:  BRA     NZ,43F2
....................     { 
....................         // load the file entry so the new cluster can be linked to it 
....................         dir = LoadDirAttrib(fo, &fHandle); 
043AA:  PUSH    FDE
043AC:  POP     FF0
043AE:  MOV     #FEA,W4
043B0:  MOV     W4,FF2
043B2:  CALL    42F0
043B6:  MOV     W0,FEC
....................  
....................         // Now update the new cluster 
....................         dir->DIR_FstClusLO = (cluster & 0x0000FFFF); 
043B8:  MOV     #1A,W0
043BA:  ADD     FEC,W0
043BC:  MOV     W0,W5
043BE:  CLR     W1
043C0:  MOV     FE2,W0
043C2:  MOV     W0,[W5]
....................  
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         // Get the higher part of cluster and store it in directory entry. 
....................        TempMsbCluster = (cluster & 0x0FFF0000);    // Since only 28 bits usedin FAT32. Mask the higher MSB nibble. 
043C4:  CLR     FE6
043C6:  PUSH    FE4
043C8:  POP     FE8
043CA:  MOV     #FFF,W0
043CC:  AND     FE8
....................        TempMsbCluster = TempMsbCluster >> 16;      // Get the date into Lsb place. 
043CE:  PUSH    FE8
043D0:  POP     FE6
043D2:  CLR     FE8
....................        dir->DIR_FstClusHI = TempMsbCluster; 
043D4:  MOV     #14,W0
043D6:  ADD     FEC,W0
043D8:  MOV     W0,W5
043DA:  MOV     FE6,W4
043DC:  MOV     W4,[W5+#0]
.................... #else // If FAT32 support not enabled 
....................        TempMsbCluster = 0;                         // Just to avoid compiler warnigng. 
....................        dir->DIR_FstClusHI = 0; 
.................... #endif 
....................  
....................         // now write it 
....................         if(Write_File_Entry(fo, &fHandle) != TRUE) 
043DE:  PUSH    FDE
043E0:  POP     1006
043E2:  MOV     #FEA,W4
043E4:  MOV     W4,1008
043E6:  CALL    3964
043EA:  CP.B    W0L,#1
043EC:  BRA     Z,43F2
....................             error = CE_WRITE_ERROR; 
043EE:  MOV.B   #9,W0L
043F0:  MOV.B   W0L,FE0
....................     } // Create Cluster 
....................  
....................     return(error); 
043F2:  MOV.B   FE0,W0L
043F4:  MOV.B   W0L,0
043F6:  MOV     [--W15],W5
043F8:  RETURN  
.................... }// End of CreateFirstCluster 
.................... #endif 
....................  
.................... /********************************************************** 
....................   Function: 
....................     BYTE FindEmptyEntries(FILEOBJ fo, WORD *fHandle) 
....................   Summary: 
....................     Find an empty dir entry 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................     fHandle -  Start of entries 
....................   Return Values: 
....................     TRUE - One found 
....................     FALSE - None found 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache directory entries, starting 
....................     with the one pointed to by the fHandle argument.  It will 
....................     then search through the entries until an unused one 
....................     is found.  If the end of the cluster chain for the 
....................     directory is reached, a new cluster will be allocated 
....................     to the directory (unless it's a FAT12 or FAT16 root) 
....................     and the first entry of the new cluster will be used. 
....................   Remarks: 
....................     None. 
....................   **********************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE FindEmptyEntries(FILEOBJ fo, WORD *fHandle) 
*
03F70:  MOV     W5,[W15++]
03F72:  MOV     W6,[W15++]
03F74:  MOV     W7,[W15++]
03F76:  MOV.B   #1,W0L
03F78:  MOV.B   W0L,FE2
*
03F7E:  CLR.B   FE5
03F80:  MOV     FE0,W0
03F82:  MOV     [W0],[W15++]
03F84:  POP     FE6
.................... { 
....................     BYTE   status = NOT_FOUND; 
....................     BYTE   amountfound,numberOfFileEntries; 
*
03F7A:  CLR.B   FE3
03F7C:  CLR.B   FE4
....................     BYTE   a = 0; 
....................     WORD   bHandle = *fHandle; 
....................     DWORD b; 
*
03F86:  CLR     FE8
03F88:  CLR     FEA
....................     DIRENTRY    dir; 
03F8A:  CLR     FEC
....................  
....................     fo->dirccls = fo->dirclus; 
03F8C:  MOV     #32,W0
03F8E:  ADD     FDE,W0
03F90:  MOV     W0,W5
03F92:  MOV     #2E,W0
03F94:  ADD     FDE,W0
03F96:  MOV     [W0++],[W5++]
03F98:  MOV     [W0++],[W5++]
....................     if((dir = Cache_File_Entry( fo, fHandle, TRUE)) != NULL) 
03F9A:  MOV.B   #1,W0L
03F9C:  MOV.B   W0L,102C
03F9E:  PUSH    FDE
03FA0:  POP     1028
03FA2:  PUSH    FE0
03FA4:  POP     102A
03FA6:  CALL    31E4
03FAA:  MOV     W0,FEC
03FAC:  CP0     FEC
03FAE:  BRA     Z,409A
....................     { 
....................       #if defined(SUPPORT_LFN) 
....................       // If LFN entry 
....................       if(fo->utf16LFNlength) 
....................       { 
....................          // File Name + NULL character is file name length in LFN 
....................          fileNameLength = fo->utf16LFNlength; 
....................  
....................          // Determine the number of entries for LFN 
....................          a = fileNameLength % MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................          numberOfFileEntries = fileNameLength/MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................          if(a || (fileNameLength < MAX_UTF16_CHARS_IN_LFN_ENTRY)) 
....................          { 
....................             numberOfFileEntries++; 
....................          } 
....................  
....................             // Increment by 1 so that you have space to store for assosciated short file name 
....................             numberOfFileEntries = numberOfFileEntries + 1; 
....................       } 
....................       else 
....................       #endif 
....................             numberOfFileEntries = 1; 
03FB0:  MOV.B   #1,W0L
03FB2:  MOV.B   W0L,FE4
....................  
....................         // while its still not found 
....................         while(status == NOT_FOUND) 
03FB4:  MOV     FE2,W4
03FB6:  CP.B    W4L,#1
03FB8:  BRA     NZ,409A
....................         { 
....................             amountfound = 0; 
03FBA:  CLR.B   FE3
....................             bHandle = *fHandle; 
03FBC:  MOV     FE0,W0
03FBE:  MOV     [W0],[W15++]
03FC0:  POP     FE6
....................  
....................             // find (number) continuous entries 
....................             do 
....................             { 
....................                 // Get the entry 
....................                 dir = Cache_File_Entry( fo, fHandle, FALSE); 
03FC2:  CLR.B   102C
03FC4:  PUSH    FDE
03FC6:  POP     1028
03FC8:  PUSH    FE0
03FCA:  POP     102A
03FCC:  CALL    31E4
03FD0:  MOV     W0,FEC
....................  
....................                 // Read the first char of the file name 
....................                 if(dir != NULL) // Last entry of the cluster 
03FD2:  CP0     FEC
03FD4:  BRA     Z,3FE2
....................                 { 
....................                     a = dir->DIR_Name[0]; 
03FD6:  MOV     #0,W0
03FD8:  ADD     FEC,W0
03FDA:  MOV     W0,[W15++]
03FDC:  MOV.B   [W0],W0L
03FDE:  MOV.B   W0L,FE5
03FE0:  MOV     [--W15],W0
....................                 } 
....................                 // increase number 
....................                 (*fHandle)++; 
03FE2:  MOV     FE0,W5
03FE4:  INC     [W5],[W5]
....................             }while((dir != (DIRENTRY)NULL) && ((a == DIR_DEL) || (a == DIR_EMPTY)) && (++amountfound < numberOfFileEntries)); 
03FE6:  CP0     FEC
03FE8:  BRA     Z,4000
03FEA:  MOV     FE4,W4
03FEC:  LSR     W4,#8,W4
03FEE:  XOR.B   #E5,W4L
03FF0:  BRA     Z,3FF6
03FF2:  CP0.B   FE5
03FF4:  BRA     NZ,4000
03FF6:  INC.B   0FE3
03FF8:  MOV.B   FE3,W0L
03FFA:  MOV     FE4,W4
03FFC:  CP.B    W4L,W0L
03FFE:  BRA     GTU,3FC2
....................  
....................             // --- now why did we exit? 
....................             if(dir == NULL) // Last entry of the cluster 
04000:  CP0     FEC
04002:  BRA     NZ,408E
....................             { 
....................                 //setup the current cluster 
....................                 b = fo->dirccls; // write it back 
04004:  MOV     #32,W0
04006:  ADD     FDE,W0
04008:  MOV     #FE8,W4
0400A:  MOV     [W0++],[W4++]
0400C:  MOV     [W0++],[W4++]
....................  
....................                 // make sure we are not the root directory 
....................                 if(b == FatRootDirClusterValue) 
0400E:  MOV     FE8,W0
04010:  CP      858
04012:  BRA     NZ,4064
04014:  MOV     FEA,W0
04016:  CP      85A
04018:  BRA     NZ,4064
....................                 { 
....................                     if (fo->dsk->type != FAT32) 
0401A:  MOV     #0,W0
0401C:  ADD     FDE,W0
0401E:  MOV     W0,W5
04020:  MOV     W5,W0
04022:  MOV     [W0],W6
04024:  MOV     #22,W4
04026:  ADD     W6,W4,W0
04028:  MOV     #E,W1
0402A:  MOV     W0,W2
0402C:  MOV.B   [W2++],[W1++]
0402E:  CP.B    W7L,#3
04030:  BRA     Z,403A
....................                         status = NO_MORE; 
04032:  MOV.B   #2,W0L
04034:  MOV.B   W0L,FE2
04036:  GOTO    4060
....................                     else 
....................                     { 
....................                         fo->ccls = b; 
0403A:  MOV     #6,W0
0403C:  ADD     FDE,W0
0403E:  MOV     W0,W5
04040:  MOV     #FE8,W4
04042:  MOV     [W4++],[W5++]
04044:  MOV     [W4++],[W5++]
....................  
....................                         if(FILEallocate_new_cluster(fo, 1) == CE_DISK_FULL) 
04046:  MOV.B   #1,W0L
04048:  MOV.B   W0L,FF4
0404A:  PUSH    FDE
0404C:  POP     FF2
0404E:  CALL    3E9C
04052:  CP.B    W0L,#15
04054:  BRA     NZ,405E
....................                             status = NO_MORE; 
04056:  MOV.B   #2,W0L
04058:  MOV.B   W0L,FE2
0405A:  GOTO    4060
....................                         else 
....................                             status = FOUND;     // a new cluster will surely hold a new file name 
0405E:  CLR.B   FE2
....................                     } 
....................                 } 
04060:  GOTO    408A
....................                 else 
....................                 { 
....................                     fo->ccls = b; 
04064:  MOV     #6,W0
04066:  ADD     FDE,W0
04068:  MOV     W0,W5
0406A:  MOV     #FE8,W4
0406C:  MOV     [W4++],[W5++]
0406E:  MOV     [W4++],[W5++]
....................  
....................                     if(FILEallocate_new_cluster(fo, 1) == CE_DISK_FULL) 
04070:  MOV.B   #1,W0L
04072:  MOV.B   W0L,FF4
04074:  PUSH    FDE
04076:  POP     FF2
04078:  CALL    3E9C
0407C:  CP.B    W0L,#15
0407E:  BRA     NZ,4088
....................                         status = NO_MORE; 
04080:  MOV.B   #2,W0L
04082:  MOV.B   W0L,FE2
04084:  GOTO    408A
....................                     else 
....................                     { 
....................                         status = FOUND;     // a new cluster will surely hold a new file name 
04088:  CLR.B   FE2
....................                     } 
....................                 } 
....................             } 
0408A:  GOTO    4096
....................             else 
....................             { 
....................                 if(amountfound == numberOfFileEntries) 
0408E:  MOV.B   FE3,W0L
04090:  CP.B    FE4
04092:  BRA     NZ,4096
....................                     status = FOUND; 
04094:  CLR.B   FE2
....................             } 
04096:  GOTO    3FB4
....................         }// while 
....................     } 
....................  
....................     // copy the base handle over 
....................    *fHandle = bHandle; 
0409A:  MOV     FE0,W5
0409C:  MOV     FE6,W4
0409E:  MOV     W4,[W5+#0]
....................  
....................    return(status); 
040A0:  MOV.B   FE2,W0L
040A2:  MOV.B   W0L,0
040A4:  MOV     [--W15],W7
040A6:  MOV     [--W15],W6
040A8:  MOV     [--W15],W5
040AA:  RETURN  
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     BYTE PopulateEntries(FILEOBJ fo, WORD *fHandle, BYTE mode) 
....................   Summary: 
....................     Populate a dir entry with data 
....................   Conditions: 
....................     Should not be called by the user. 
....................   Input: 
....................     fo -      Pointer to file structure 
....................     fHandle - Location of the file 
....................     mode - DIRECTORY mode or ARCHIVE mode 
....................   Return Values: 
....................     CE_GOOD - Population successful 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will write data into a new file entry.  It will also 
....................     load timestamp data (based on the method selected by the user) and 
....................     update the timestamp variables. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE PopulateEntries(FILEOBJ fo, WORD *fHandle, BYTE mode) 
*
040EA:  MOV     W5,[W15++]
040EC:  MOV     W6,[W15++]
040EE:  CLR.B   FE3
.................... { 
....................     BYTE error = CE_GOOD; 
....................     DIRENTRY    dir; 
040F0:  CLR     FE4
....................  
....................     fo->dirccls = fo->dirclus; 
040F2:  MOV     #32,W0
040F4:  ADD     FDE,W0
040F6:  MOV     W0,W5
040F8:  MOV     #2E,W0
040FA:  ADD     FDE,W0
040FC:  MOV     [W0++],[W5++]
040FE:  MOV     [W0++],[W5++]
....................     dir = Cache_File_Entry( fo, fHandle, TRUE); 
04100:  MOV.B   #1,W0L
04102:  MOV.B   W0L,102C
04104:  PUSH    FDE
04106:  POP     1028
04108:  PUSH    FE0
0410A:  POP     102A
0410C:  CALL    31E4
04110:  MOV     W0,FE4
....................  
....................     if (dir == NULL) 
04112:  CP0     FE4
04114:  BRA     NZ,411C
....................         return CE_BADCACHEREAD; 
04116:  MOV.B   #1B,W0L
04118:  MOV.B   W0L,0
0411A:  BRA     4218
....................  
....................     // copy the contents over 
....................     strncpy(dir->DIR_Name,fo->name,DIR_NAMECOMP); 
0411C:  MOV     #0,W0
0411E:  ADD     FE4,W0
04120:  MOV     W0,W5
04122:  MOV     #1C,W0
04124:  ADD     FDE,W0
04126:  MOV     W0,W6
04128:  MOV     W5,FF0
0412A:  MOV     W6,FF2
0412C:  MOV     #B,W4
0412E:  MOV     W4,FF4
04130:  CALL    40AC
....................  
....................     // setup no attributes 
....................     if (mode == DIRECTORY) 
04134:  MOV     FE2,W4
04136:  CP.B    W4L,#12
04138:  BRA     NZ,4148
....................         dir->DIR_Attr = ATTR_DIRECTORY; 
0413A:  MOV     #B,W0
0413C:  ADD     FE4,W0
0413E:  MOV     W0,W5
04140:  MOV.B   #10,W0L
04142:  MOV.B   W0L,[W5]
04144:  GOTO    4152
....................     else 
....................         dir->DIR_Attr   = ATTR_ARCHIVE; 
04148:  MOV     #B,W0
0414A:  ADD     FE4,W0
0414C:  MOV     W0,W5
0414E:  MOV.B   #20,W0L
04150:  MOV.B   W0L,[W5]
....................  
....................     dir->DIR_NTRes  = 0x00;              // nt reserved 
04152:  MOV     #C,W0
04154:  ADD     FE4,W0
04156:  MOV     W0,W5
04158:  CLR.B   [W5]
....................     dir->DIR_FstClusHI =    0x0000;      // high word of this enty's first cluster number 
0415A:  MOV     #14,W0
0415C:  ADD     FE4,W0
0415E:  MOV     W0,W5
04160:  CLR.B   [W5]
04162:  MOV.B   #0,W0L
04164:  MOV.B   W0L,[W5+#1]
....................     dir->DIR_FstClusLO =    0x0000;      // low word of this entry's first cluster number 
04166:  MOV     #1A,W0
04168:  ADD     FE4,W0
0416A:  MOV     W0,W5
0416C:  CLR.B   [W5]
0416E:  MOV.B   #0,W0L
04170:  MOV.B   W0L,[W5+#1]
....................     dir->DIR_FileSize =     0x0;         // file size in DWORD 
04172:  MOV     #1C,W0
04174:  ADD     FE4,W0
04176:  MOV     W0,W5
04178:  CLR.B   [W5]
0417A:  MOV.B   #0,W0L
0417C:  MOV.B   W0L,[W5+#1]
0417E:  MOV.B   #0,W0L
04180:  MOV.B   W0L,[W5+#2]
04182:  MOV.B   #0,W0L
04184:  MOV.B   W0L,[W5+#3]
....................  
....................    // Timing information for uncontrolled clock mode 
.................... #ifdef INCREMENTTIMESTAMP 
....................     dir->DIR_CrtTimeTenth = 0xB2;        // millisecond stamp 
....................     dir->DIR_CrtTime =      0x7278;      // time created 
....................     dir->DIR_CrtDate =      0x32B0;      // date created 
....................     dir->DIR_LstAccDate =   0x32B0;      // Last Access date 
....................     dir->DIR_WrtTime =      0x7279;      // last update time 
....................     dir->DIR_WrtDate =      0x32B0;      // last update date 
.................... #endif 
....................  
.................... #ifdef USEREALTIMECLOCK 
....................     CacheTime(); 
....................     dir->DIR_CrtTimeTenth = gTimeCrtMS;        // millisecond stamp 
....................     dir->DIR_CrtTime =      gTimeCrtTime;      // time created // 
....................     dir->DIR_CrtDate =      gTimeCrtDate;      // date created (1/1/2004) 
....................     dir->DIR_LstAccDate =   gTimeAccDate;      // Last Access date 
....................     dir->DIR_WrtTime =      gTimeWrtTime;      // last update time 
....................     dir->DIR_WrtDate =      gTimeWrtDate;      // last update date 
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................     // The user will have set the time before this funciton is called 
....................     dir->DIR_CrtTimeTenth = gTimeCrtMS; 
04186:  MOV     #D,W0
04188:  ADD     FE4,W0
0418A:  MOV     W0,W5
0418C:  MOV     83E,W0
0418E:  MOV.B   W0L,[W5+#0]
....................     dir->DIR_CrtTime =      gTimeCrtTime; 
04190:  MOV     #E,W0
04192:  ADD     FE4,W0
04194:  MOV     W0,W5
04196:  MOV     840,W4
04198:  MOV     W4,[W5+#0]
....................     dir->DIR_CrtDate =       gTimeCrtDate; 
0419A:  MOV     #10,W0
0419C:  ADD     FE4,W0
0419E:  MOV     W0,W5
041A0:  MOV     842,W4
041A2:  MOV     W4,[W5+#0]
....................     dir->DIR_LstAccDate =   gTimeAccDate; 
041A4:  MOV     #12,W0
041A6:  ADD     FE4,W0
041A8:  MOV     W0,W5
041AA:  MOV     844,W4
041AC:  MOV     W4,[W5+#0]
....................     dir->DIR_WrtTime =       gTimeWrtTime; 
041AE:  MOV     #16,W0
041B0:  ADD     FE4,W0
041B2:  MOV     W0,W5
041B4:  MOV     846,W4
041B6:  MOV     W4,[W5+#0]
....................     dir->DIR_WrtDate =      gTimeWrtDate; 
041B8:  MOV     #18,W0
041BA:  ADD     FE4,W0
041BC:  MOV     W0,W5
041BE:  MOV     848,W4
041C0:  MOV     W4,[W5+#0]
.................... #endif 
....................  
....................     fo->size        = dir->DIR_FileSize; 
041C2:  MOV     #12,W0
041C4:  ADD     FDE,W0
041C6:  MOV     W0,W5
041C8:  MOV     #1C,W0
041CA:  ADD     FE4,W0
041CC:  MOV     [W0++],[W5++]
041CE:  MOV     [W0++],[W5++]
....................     fo->time        = dir->DIR_CrtTime; 
041D0:  MOV     #18,W0
041D2:  ADD     FDE,W0
041D4:  MOV     W0,W5
041D6:  MOV     #E,W0
041D8:  ADD     FE4,W0
041DA:  MOV     [W0],[W5]
....................     fo->date        = dir->DIR_CrtDate; 
041DC:  MOV     #1A,W0
041DE:  ADD     FDE,W0
041E0:  MOV     W0,W5
041E2:  MOV     #10,W0
041E4:  ADD     FE4,W0
041E6:  MOV     [W0],[W5]
....................     fo->attributes  = dir->DIR_Attr; 
041E8:  MOV     #2C,W0
041EA:  ADD     FDE,W0
041EC:  MOV     W0,W5
041EE:  MOV     #B,W0
041F0:  ADD     FE4,W0
041F2:  MOV.B   [W0],[W5]
041F4:  MOV.B   #0,W4L
041F6:  MOV.B   W4L,[W5+#1]
....................     fo->entry       = *fHandle; 
041F8:  MOV     #28,W0
041FA:  ADD     FDE,W0
041FC:  MOV     W0,W5
041FE:  MOV     FE0,W0
04200:  MOV     [W0],[W5]
....................  
....................     // just write the last entry in 
....................     if (Write_File_Entry(fo,fHandle) != TRUE) 
04202:  PUSH    FDE
04204:  POP     1006
04206:  PUSH    FE0
04208:  POP     1008
0420A:  CALL    3964
0420E:  CP.B    W0L,#1
04210:  BRA     Z,4216
....................         error = CE_WRITE_ERROR; 
04212:  MOV.B   #9,W0L
04214:  MOV.B   W0L,FE3
....................  
....................     return(error); 
04216:  MOV.B   FE3,W0L
04218:  MOV     [--W15],W6
0421A:  MOV     [--W15],W5
0421C:  RETURN  
.................... } 
....................  
.................... /***************************************************************** 
....................   Function: 
....................     BOOL Alias_LFN_Object(FILEOBJ fo) 
....................   Summary: 
....................     Find the Short file name of the LFN entry 
....................   Conditions: 
....................     Long file name should be present. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................   Return Values: 
....................     FOUND -     Operation successful 
....................     NOT_FOUND - Operation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will find the short file name 
....................     of the long file name as mentioned in the FAT 
....................     specs. 
....................   Remarks: 
....................     None. 
....................   *****************************************************************/ 
.................... #if defined(SUPPORT_LFN) 
.................... BOOL Alias_LFN_Object(FILEOBJ fo) 
.................... { 
....................    FSFILE      filePtr1; 
....................    FSFILE      filePtr2; 
....................    unsigned long int index4; 
....................    short int   lfnIndex,index1,index2; 
....................     BYTE  tempVariable,index; 
....................    char  tempString[8]; 
....................    char  *lfnAliasPtr; 
....................    unsigned short int  *templfnPtr; 
....................    BOOL result = FALSE; 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&filePtr1, fo); 
....................  
....................    lfnAliasPtr = (char *)&filePtr1.name[0]; 
....................  
....................    templfnPtr = (unsigned short int *)filePtr1.utf16LFNptr; 
....................  
....................    fileNameLength = fo->utf16LFNlength; 
....................  
....................    // Initially fill the alias name with space characters 
....................    for(index1 = 0;index1 < FILE_NAME_SIZE_8P3;index1++) 
....................    { 
....................       lfnAliasPtr[index1] = ' '; 
....................    } 
....................  
....................    // find the location where '.' is present 
....................    for(lfnIndex = fileNameLength - 1;lfnIndex > 0;lfnIndex--) 
....................    { 
....................       if (templfnPtr[lfnIndex] == '.') 
....................       { 
....................           break; 
....................       } 
....................    } 
....................  
....................    index1 = lfnIndex + 1; 
....................  
....................    tempVariable = 0; 
....................    if(lfnIndex) 
....................    { 
....................       index2 = 8; 
....................       // Complete the extension part as per the FAT specifications 
....................       for(;((index1 < fileNameLength) && (tempVariable < 3));index1++) 
....................       { 
....................          // Convert lower-case to upper-case 
....................          index = (BYTE)templfnPtr[index1]; 
....................          if ((index >= 0x61) && (index <= 0x7A)) 
....................          { 
....................              lfnAliasPtr[index2++] = index - 0x20; 
....................          } 
....................          else if(index == ' ') 
....................          { 
....................             continue; 
....................          } 
....................          else if ((index == 0x2B) || (index == 0x2C) || (index == 0x3B) || 
....................                (index == 0x3D) || (index == 0x5B) || (index == 0x5D) || 
....................                (templfnPtr[index1] > 0xFF)) 
....................          { 
....................              lfnAliasPtr[index2++] = '_'; 
....................          } 
....................          else 
....................          { 
....................              lfnAliasPtr[index2++] = index; 
....................          } 
....................  
....................          tempVariable++; 
....................       } 
....................  
....................       index2 = lfnIndex; 
....................       tempVariable = 0; 
....................    } 
....................    else 
....................    { 
....................       index2 = fileNameLength; 
....................    } 
....................  
....................    // Fill the base part as per the FAT specifications 
....................    for(index1 = 0;((index1 < index2) && (tempVariable < 6));index1++) 
....................    { 
....................       // Convert lower-case to upper-case 
....................       index = (BYTE)templfnPtr[index1]; 
....................       if ((index >= 0x61) && (index <= 0x7A)) 
....................       { 
....................           lfnAliasPtr[tempVariable] = index - 0x20; 
....................       } 
....................       else if(index == ' ') 
....................       { 
....................          continue; 
....................       } 
....................       else if ((index == 0x2B) || (index == 0x2C) || (index == 0x3B) || 
....................             (index == 0x3D) || (index == 0x5B) || (index == 0x5D) || 
....................             (templfnPtr[index1] > 0xFF)) 
....................       { 
....................           lfnAliasPtr[tempVariable] = '_'; 
....................       } 
....................       else 
....................       { 
....................           lfnAliasPtr[tempVariable] = index; 
....................       } 
....................       tempVariable++; 
....................    } 
....................  
....................    // Aliasing of the predicted name should append ~1 
....................    lfnAliasPtr[tempVariable] = '~'; 
....................    lfnAliasPtr[tempVariable + 1] = '1'; 
....................  
....................     filePtr1.attributes = ATTR_ARCHIVE; 
....................  
....................    filePtr1.utf16LFNlength = 0; 
....................  
....................    // Try for 9999999 combinations before telling error to the user 
....................    for(index4 = 1;index4 < (unsigned long int)10000000;index4++) 
....................    { 
....................        filePtr1.cluster = 0; 
....................        filePtr1.ccls    = 0; 
....................        filePtr1.entry = 0; 
....................  
....................           // start at the current directory 
....................       #ifdef ALLOW_DIRS 
....................           filePtr1.dirclus    = cwdptr->dirclus; 
....................           filePtr1.dirccls    = cwdptr->dirccls; 
....................       #else 
....................           filePtr1.dirclus = FatRootDirClusterValue; 
....................           filePtr1.dirccls = FatRootDirClusterValue; 
....................       #endif 
....................  
....................        // copy file object over 
....................        FileObjectCopy(&filePtr2, &filePtr1); 
....................  
....................        // See if the file is found 
....................        if(FILEfind (&filePtr2, &filePtr1, LOOK_FOR_MATCHING_ENTRY, 0) == CE_GOOD) 
....................       { 
....................          tempString[7] = index4 % (BYTE)10 + '0'; 
....................          tempString[6] = (index4 % (BYTE)100)/10 + '0'; 
....................          tempString[5] = (index4 % 1000)/100 + '0'; 
....................          tempString[4] = (index4 % 10000)/1000 + '0'; 
....................          tempString[3] = (index4 % 100000)/10000 + '0'; 
....................          tempString[2] = (index4 % 1000000)/100000 + '0'; 
....................          if((tempString[1] = ((index4 % 10000000)/1000000 + '0')) != '0') 
....................          { 
....................                tempString[index = 0] = '~'; 
....................          } 
....................          else 
....................          { 
....................             for(index = 6;index > 0;index--) 
....................             { 
....................                if((tempString[index] == '0') && (tempString[index - 1] == '0')) 
....................                { 
....................                   tempString[index] = '~'; 
....................                   if(!filePtr1.AsciiEncodingType) 
....................                   { 
....................                      if(index % 2) 
....................                      { 
....................                         for(index2 = index - 1;index2 < 7;index2++) 
....................                         { 
....................                            tempString[index2] = tempString[index2 + 1]; 
....................                         } 
....................                         tempString[7] = ' '; 
....................                         index--; 
....................                      } 
....................                   } 
....................                   break; 
....................                } 
....................             } 
....................          } 
....................  
....................          if(index >= tempVariable) 
....................          { 
....................             index1 = tempVariable; 
....................          } 
....................          else 
....................          { 
....................             index1 = index; 
....................          } 
....................  
....................          while(index < 8) 
....................          { 
....................             filePtr1.name[index1++] = tempString[index++]; 
....................          } 
....................  
....................          // Store the remaining bytes with leading spaces 
....................          while(index1 < 8) 
....................          { 
....................             filePtr1.name[index1++] = ' '; 
....................          } 
....................  
....................       } 
....................       else 
....................       { 
....................          // short file name is found.Store it & quit 
....................          lfnAliasPtr = &fo->name[0]; 
....................  
....................          for(index = 0;index < FILE_NAME_SIZE_8P3;index++) 
....................          { 
....................             lfnAliasPtr[index] = filePtr1.name[index]; 
....................          } 
....................  
....................          result = TRUE; 
....................          break; 
....................       } 
....................    } 
....................  
....................    return(result); 
....................  
.................... } // Alias_LFN_Object 
.................... #endif 
....................  
.................... #ifdef USEREALTIMECLOCK 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     void CacheTime (void) 
....................   Summary: 
....................     Automatically store timestamp information from the RTCC 
....................   Conditions: 
....................     RTCC module enabled.  Should not be called by the user. 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     Modifies global timing variables 
....................   Description: 
....................     This function will automatically load information from an RTCC 
....................     module and use it to update the global timing variables.  These can 
....................     then be used to update file timestamps. 
....................   Remarks: 
....................     None. 
....................   *************************************************************************/ 
....................  
.................... void CacheTime (void) 
.................... { 
....................     WORD    year, monthday, weekhour, minsec, c, result; 
....................  
.................... #if defined (__PIC32MX__)   // Added support for PIC32. -Bud (3/4/2008) 
....................  
....................    unsigned int   t0, t1; 
....................    unsigned int   d0, d1; 
....................  
....................    do  // Get the time 
....................    { 
....................       t0=RTCTIME; 
....................       t1=RTCTIME; 
....................    }while(t0!=t1); 
....................  
....................    do  // Get the date 
....................    { 
....................       d0=RTCDATE; 
....................       d1=RTCDATE; 
....................    }while(d0!=d1); 
....................  
....................     // Put them in place. 
....................     year        = (WORD)(d0 >> 24); 
....................     monthday    = (WORD)(d0 >> 8); 
....................     weekhour    = (WORD)((d0 & 0x0F) << 8); 
....................     weekhour   |= (WORD)(t0 >> 24); 
....................     minsec      = (WORD)(t0 >> 8); 
....................  
.................... #else 
....................     BYTE    ptr1, ptr0; 
....................     if(RCFGCALbits.RTCPTR0) 
....................         ptr0 = 1; 
....................     else 
....................         ptr0 = 0; 
....................     if (RCFGCALbits.RTCPTR1) 
....................         ptr1 = 1; 
....................     else 
....................         ptr1 = 0; 
....................  
....................     RCFGCALbits.RTCPTR0 = 1; 
....................     RCFGCALbits.RTCPTR1 = 1; 
....................     year = RTCVAL; 
....................     monthday = RTCVAL; 
....................     weekhour = RTCVAL; 
....................     minsec = RTCVAL; 
....................  
....................     if (ptr0 == 1) 
....................         RCFGCALbits.RTCPTR0 = 1; 
....................  
....................     if (ptr1 == 1) 
....................         RCFGCALbits.RTCPTR1 = 1; 
....................  
.................... #endif 
....................  
....................     c = 0; 
....................     c += (year & 0x0F); 
....................     c += ((year & 0xF0) >> 4) * 10; 
....................     // c equals the last 2 digits of the year from 2000 to 2099 
....................     // Add 20 to adjust it to FAT time (from 1980 to 2107) 
....................     c += 20; 
....................     // shift the result to bits 
....................     result = c << 9; 
....................  
....................     if ((monthday & 0x1000) == 0x1000) 
....................     { 
....................         c = 10; 
....................     } 
....................     else 
....................     { 
....................         c = 0; 
....................     } 
....................     c += ((monthday & 0x0F00) >> 8); 
....................     c <<= 5; 
....................     result |= c; 
....................  
....................     c = (monthday & 0x00F0) >> 4; 
....................     c *= 10; 
....................     c += (monthday & 0x000F); 
....................  
....................     result |= c; 
....................  
....................     gTimeCrtDate = result; 
....................     gTimeWrtDate = result; 
....................     gTimeAccDate = result; 
....................  
....................     c = ((weekhour & 0x00F0) >> 4) * 10; 
....................     c += (weekhour & 0x000F); 
....................     result = c << 11; 
....................     c = ((minsec & 0xF000) >> 12) * 10; 
....................     c += (minsec & 0x0F00) >> 8; 
....................     result |= (c << 5); 
....................     c = ((minsec & 0x00F0) >> 4) * 10; 
....................     c += (minsec & 0x000F); 
....................  
....................     // If seconds mod 2 is 1, add 1000 ms 
....................     if (c % 2) 
....................         gTimeCrtMS = 100; 
....................     else 
....................         gTimeCrtMS = 0; 
....................  
....................     c >>= 1; 
....................     result |= c; 
....................  
....................     gTimeCrtTime = result; 
....................     gTimeWrtTime = result; 
.................... } 
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................  
.................... /*********************************************************************************************************** 
....................   Function: 
....................     int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second) 
....................   Summary: 
....................     Manually set timestamp variables 
....................   Conditions: 
....................     USERDEFINEDCLOCK macro defined in FSconfig.h. 
....................   Input: 
....................     year -     The year (1980\-2107) 
....................     month -   The month (1\-12) 
....................     day -     The day of the month (1\-31) 
....................     hour -    The hour (0\-23) 
....................     minute -  The minute (0\-59) 
....................     second -  The second (0\-59) 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     Modifies global timing variables 
....................   Description: 
....................     Lets the user manually set the timing variables.  The values passed in will be converted to the format 
....................     used by the FAT timestamps. 
....................   Remarks: 
....................     Call this before creating a file or directory (set create time) and 
....................     before closing a file (set last access time, last modified time) 
....................   ***********************************************************************************************************/ 
....................  
.................... int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second) 
.................... { 
....................     unsigned int result; 
....................  
....................     if ((year < 1980) || (year > 2107) || (month < 1) || (month > 12) || 
....................         (day < 1) || (day > 31) || (hour > 23) || (minute > 59) || (second > 59)) 
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
....................         return -1; 
....................     } 
....................  
....................     result = (year - 1980) << 9; 
....................     result |= (unsigned int)((unsigned int)month << 5); 
....................     result |= (day); 
....................  
....................     gTimeAccDate = result; 
....................     gTimeCrtDate = result; 
....................     gTimeWrtDate = result; 
....................  
....................     result = ((unsigned int)hour << 11); 
....................     result |= (unsigned int)((unsigned int)minute << 5); 
....................     result |= (second/2); 
....................  
....................     gTimeCrtTime = result; 
....................     gTimeWrtTime = result; 
....................  
....................     if (second % 2) 
....................         gTimeCrtMS = 100; 
....................     else 
....................         gTimeCrtMS = 0; 
....................  
....................     FSerrno = CE_GOOD; 
....................     return 0; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /*********************************************************************** 
....................   Function: 
....................     BYTE FILEallocate_new_cluster( FILEOBJ fo, BYTE mode) 
....................   Summary; 
....................     Allocate a new cluster to a file 
....................   Conditions: 
....................     Should not be called by the user. 
....................   Input: 
....................     fo -    Pointer to file structure 
....................     mode - 
....................          - 0 - Allocate a cluster to a file 
....................          - 1 - Allocate a cluster to a directory 
....................   Return Values: 
....................     CE_GOOD -      Cluster allocated 
....................     CE_DISK_FULL - No clusters available 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will find an empty cluster on the device using the 
....................     FATfindEmptyCluster function.  It will then mark it as the last 
....................     cluster in the file in the FAT chain, and link the current last 
....................     cluster of the passed file to the new cluster.  If the new 
....................     cluster is a directory cluster, it will be erased (so there are no 
....................     extraneous directory entries).  If it's allocated to a non-directory 
....................     file, it doesn't need to be erased; extraneous data in the cluster 
....................     will be unviewable because of the file size parameter. 
....................   Remarks: 
....................     None. 
....................   ***********************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE FILEallocate_new_cluster( FILEOBJ fo, BYTE mode) 
*
03E9C:  MOV     W5,[W15++]
.................... { 
....................     DISK *      dsk; 
03E9E:  CLR     FF6
....................     DWORD c,curcls; 
03EA0:  CLR     FF8
03EA2:  CLR     FFA
03EA4:  CLR     FFC
03EA6:  CLR     FFE
....................  
....................     dsk = fo->dsk; 
03EA8:  MOV     FF2,W4
03EAA:  ADD     W4,#0,W4
03EAC:  MOV     W4,W0
03EAE:  MOV     [W0],[W15++]
03EB0:  POP     FF6
....................     c = fo->ccls; 
03EB2:  MOV     #6,W0
03EB4:  ADD     FF2,W0
03EB6:  MOV     #FF8,W4
03EB8:  MOV     [W0++],[W4++]
03EBA:  MOV     [W0++],[W4++]
....................  
....................     // find the next empty cluster 
....................     c = FATfindEmptyCluster(fo); 
03EBC:  PUSH    FF2
03EBE:  POP     1004
03EC0:  CALL    3CAE
03EC4:  MOV     W0,FF8
03EC6:  MOV     W1,FFA
....................     if (c == 0)      // "0" is just an indication as Disk full in the fn "FATfindEmptyCluster()" 
03EC8:  CP0     FF8
03ECA:  BRA     NZ,3ED6
03ECC:  CP0     FFA
03ECE:  BRA     NZ,3ED6
....................         return CE_DISK_FULL; 
03ED0:  MOV.B   #15,W0L
03ED2:  MOV.B   W0L,0
03ED4:  BRA     3F6C
....................  
....................  
....................     // mark the cluster as taken, and last in chain 
.................... #ifdef SUPPORT_FAT12 
....................     if(dsk->type == FAT12) 
....................         WriteFAT( dsk, c, LAST_CLUSTER_FAT12, FALSE); 
....................     else 
.................... #endif 
....................     if (dsk->type == FAT16) 
03ED6:  MOV     #22,W4
03ED8:  MOV     FF6,W3
03EDA:  ADD     W3,W4,W0
03EDC:  MOV     #A,W1
03EDE:  MOV     W0,W2
03EE0:  MOV.B   [W2++],[W1++]
03EE2:  CP.B    W5L,#2
03EE4:  BRA     NZ,3F02
....................         WriteFAT( dsk, c, LAST_CLUSTER_FAT16, FALSE); 
03EE6:  CLR.B   1078
03EE8:  PUSH    FF6
03EEA:  POP     106E
03EEC:  PUSH    FF8
03EEE:  POP     1070
03EF0:  PUSH    FFA
03EF2:  POP     1072
03EF4:  MOV     #FFF8,W4
03EF6:  MOV     W4,1074
03EF8:  CLR     1076
03EFA:  CALL    2C18
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
03EFE:  GOTO    3F1C
....................     else 
....................         WriteFAT( dsk, c, LAST_CLUSTER_FAT32, FALSE); 
03F02:  CLR.B   1078
03F04:  PUSH    FF6
03F06:  POP     106E
03F08:  PUSH    FF8
03F0A:  POP     1070
03F0C:  PUSH    FFA
03F0E:  POP     1072
03F10:  MOV     #FFF8,W4
03F12:  MOV     W4,1074
03F14:  MOV     #FFF,W4
03F16:  MOV     W4,1076
03F18:  CALL    2C18
.................... #endif 
....................  
....................     // link current cluster to the new one 
....................     curcls = fo->ccls; 
03F1C:  MOV     #6,W0
03F1E:  ADD     FF2,W0
03F20:  MOV     #FFC,W4
03F22:  MOV     [W0++],[W4++]
03F24:  MOV     [W0++],[W4++]
....................  
....................     WriteFAT( dsk, curcls, c, FALSE); 
03F26:  CLR.B   1078
03F28:  PUSH    FF6
03F2A:  POP     106E
03F2C:  PUSH    FFC
03F2E:  POP     1070
03F30:  PUSH    FFE
03F32:  POP     1072
03F34:  PUSH    FF8
03F36:  POP     1074
03F38:  PUSH    FFA
03F3A:  POP     1076
03F3C:  CALL    2C18
....................  
....................     // update the FILE structure 
....................     fo->ccls = c; 
03F40:  MOV     #6,W0
03F42:  ADD     FF2,W0
03F44:  MOV     W0,W5
03F46:  MOV     #FF8,W4
03F48:  MOV     [W4++],[W5++]
03F4A:  MOV     [W4++],[W5++]
....................  
....................     // IF this is a dir, we need to erase the cluster 
....................     // If it's a file, we can leave it- the file size 
....................     // will limit the data we see to the data that's been 
....................     // written 
....................     if (mode == 1) 
03F4C:  MOV     FF4,W4
03F4E:  CP.B    W4L,#1
03F50:  BRA     NZ,3F68
....................         return (EraseCluster(dsk, c)); 
03F52:  PUSH    FF6
03F54:  POP     1004
03F56:  PUSH    FF8
03F58:  POP     1006
03F5A:  PUSH    FFA
03F5C:  POP     1008
03F5E:  CALL    3DDC
03F62:  BRA     3F6C
03F64:  GOTO    3F6C
....................     else 
....................         return CE_GOOD; 
03F68:  CLR.B   0
03F6A:  BRA     3F6C
03F6C:  MOV     [--W15],W5
03F6E:  RETURN  
....................  
.................... } // allocate new cluster 
.................... #endif 
....................  
.................... /*********************************************** 
....................   Function: 
....................     DWORD FATfindEmptyCluster(FILEOBJ fo) 
....................   Summary: 
....................     Find the next available cluster on the device 
....................   Conditions: 
....................     This function should not be called by the 
....................     user. 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return Values: 
....................     DWORD - Address of empty cluster 
....................     0 -     Could not find empty cluster 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will search through the FAT to 
....................     find the next available cluster on the device. 
....................   Remarks: 
....................     Should not be called by user 
....................   ***********************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... DWORD FATfindEmptyCluster(FILEOBJ fo) 
*
03CAE:  MOV     W5,[W15++]
03CB0:  MOV     W6,[W15++]
*
03CB4:  CLR     1008
03CB6:  CLR     100A
.................... { 
....................     DISK *   disk; 
*
03CB2:  CLR     1006
....................     DWORD    value = 0x0; 
....................     DWORD    c,curcls, EndClusterLimit, ClusterFailValue; 
*
03CB8:  CLR     100C
03CBA:  CLR     100E
03CBC:  CLR     1010
03CBE:  CLR     1012
03CC0:  CLR     1014
03CC2:  CLR     1016
03CC4:  CLR     1018
03CC6:  CLR     101A
....................  
....................     disk = fo->dsk; 
03CC8:  MOV     1004,W4
03CCA:  ADD     W4,#0,W4
03CCC:  MOV     W4,W0
03CCE:  MOV     [W0],[W15++]
03CD0:  POP     1006
....................     c = fo->ccls; 
03CD2:  MOV     #6,W0
03CD4:  ADD     1004,W0
03CD6:  MOV     #100C,W4
03CD8:  MOV     [W0++],[W4++]
03CDA:  MOV     [W0++],[W4++]
....................  
....................     /* Settings based on FAT type */ 
....................     switch (disk->type) 
03CDC:  MOV     #22,W4
03CDE:  MOV     1006,W3
03CE0:  ADD     W3,W4,W0
03CE2:  MOV     #A,W1
03CE4:  MOV     W0,W2
03CE6:  MOV.B   [W2++],[W1++]
03CE8:  MOV.B   W5L,W0L
03CEA:  CLR.B   1
03CEC:  XOR     #3,W0
03CEE:  BRA     Z,3CF6
03CF0:  XOR     #1,W0
03CF2:  BRA     Z,3D08
03CF4:  BRA     3D08
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             EndClusterLimit = END_CLUSTER_FAT32; 
03CF6:  MOV     #FFF7,W4
03CF8:  MOV     W4,1014
03CFA:  MOV     #FFF,W4
03CFC:  MOV     W4,1016
....................             ClusterFailValue = CLUSTER_FAIL_FAT32; 
03CFE:  SETM    1018
03D00:  MOV     #FFF,W4
03D02:  MOV     W4,101A
....................             break; 
03D04:  GOTO    3D16
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
....................             EndClusterLimit = END_CLUSTER_FAT12; 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
....................             break; 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             EndClusterLimit = END_CLUSTER_FAT16; 
03D08:  MOV     #FFF7,W4
03D0A:  MOV     W4,1014
03D0C:  CLR     1016
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
03D0E:  SETM    1018
03D10:  CLR     101A
....................             break; 
03D12:  GOTO    3D16
....................     } 
....................  
....................     // just in case 
....................     if(c < 2) 
03D16:  MOV     100E,W4
03D18:  CP      W4,#0
03D1A:  BRA     GTU,3D2A
03D1C:  BRA     NC,3D24
03D1E:  MOV     100C,W4
03D20:  CP      W4,#2
03D22:  BRA     C,3D2A
....................         c = 2; 
03D24:  MOV     #2,W4
03D26:  MOV     W4,100C
03D28:  CLR     100E
....................  
....................     curcls = c; 
03D2A:  PUSH    100C
03D2C:  POP     1010
03D2E:  PUSH    100E
03D30:  POP     1012
....................     ReadFAT(disk, c); 
03D32:  PUSH    1006
03D34:  POP     1048
03D36:  PUSH    100C
03D38:  POP     104A
03D3A:  PUSH    100E
03D3C:  POP     104C
03D3E:  CALL    2ECC
....................  
....................     // sequentially scan through the FAT looking for an empty cluster 
....................     while(c) 
03D42:  CP0     100C
03D44:  BRA     NZ,3D4A
03D46:  CP0     100E
03D48:  BRA     Z,3DD2
....................     { 
....................         // look at its value 
....................         if ( (value = ReadFAT(disk, c)) == ClusterFailValue) 
03D4A:  PUSH    1006
03D4C:  POP     1048
03D4E:  PUSH    100C
03D50:  POP     104A
03D52:  PUSH    100E
03D54:  POP     104C
03D56:  CALL    2ECC
03D5A:  MOV     W0,1008
03D5C:  MOV     W1,100A
03D5E:  MOV     1008,W0
03D60:  CP      1018
03D62:  BRA     NZ,3D72
03D64:  MOV     100A,W0
03D66:  CP      101A
03D68:  BRA     NZ,3D72
....................         { 
....................             c = 0; 
03D6A:  CLR     100C
03D6C:  CLR     100E
....................             break; 
03D6E:  GOTO    3DD2
....................         } 
....................  
....................         // check if empty cluster found 
....................         if (value == CLUSTER_EMPTY) 
03D72:  CP0     1008
03D74:  BRA     NZ,3D7E
03D76:  CP0     100A
03D78:  BRA     NZ,3D7E
....................             break; 
03D7A:  GOTO    3DD2
....................  
....................         c++;    // check next cluster in FAT 
03D7E:  INC     100C
03D80:  BTSC.B  42.1
03D82:  INC     100E
....................         // check if reached last cluster in FAT, re-start from top 
....................         if ((value == EndClusterLimit) || (c >= (disk->maxcls+2))) 
03D84:  MOV     1008,W0
03D86:  CP      1014
03D88:  BRA     NZ,3D90
03D8A:  MOV     100A,W0
03D8C:  CP      1016
03D8E:  BRA     Z,3DB4
03D90:  MOV     1006,W4
03D92:  ADD     W4,#14,W4
03D94:  MOV     W4,W0
03D96:  MOV     #A,W1
03D98:  MOV     W0,W2
03D9A:  REPEAT  #3
03D9C:  MOV.B   [W2++],[W1++]
03D9E:  ADD     W5,#2,W5
03DA0:  MOV     W5,W0
03DA2:  ADDC    W6,#0,W6
03DA4:  MOV     W6,W1
03DA6:  MOV     100E,W4
03DA8:  CP      W4,W1
03DAA:  BRA     NC,3DBA
03DAC:  BRA     GTU,3DB4
03DAE:  MOV     100C,W4
03DB0:  CP      W4,W0
03DB2:  BRA     NC,3DBA
....................             c = 2; 
03DB4:  MOV     #2,W4
03DB6:  MOV     W4,100C
03DB8:  CLR     100E
....................  
....................         // check if full circle done, disk full 
....................         if ( c == curcls) 
03DBA:  MOV     100C,W0
03DBC:  CP      1010
03DBE:  BRA     NZ,3DCE
03DC0:  MOV     100E,W0
03DC2:  CP      1012
03DC4:  BRA     NZ,3DCE
....................         { 
....................             c = 0; 
03DC6:  CLR     100C
03DC8:  CLR     100E
....................             break; 
03DCA:  GOTO    3DD2
....................         } 
03DCE:  GOTO    3D42
....................     }  // scanning for an empty cluster 
....................  
....................     return(c); 
03DD2:  MOV     100C,W0
03DD4:  MOV     100E,W1
03DD6:  MOV     [--W15],W6
03DD8:  MOV     [--W15],W5
03DDA:  RETURN  
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     void FSGetDiskProperties(FS_DISK_PROPERTIES* properties) 
....................   Summary: 
....................     Allows user to get the disk properties (size of disk, free space, etc) 
....................   Conditions: 
....................     1) ALLOW_GET_DISK_PROPERTIES must be defined in FSconfig.h 
....................     2) a FS_DISK_PROPERTIES object must be created before the function is called 
....................     3) the new_request member of the FS_DISK_PROPERTIES object must be set before 
....................         calling the function for the first time.  This will start a new search. 
....................     4) this function should not be called while there is a file open.  Close all 
....................         files before calling this function. 
....................   Input: 
....................     properties - a pointer to a FS_DISK_PROPERTIES object where the results should 
....................       be stored. 
....................   Return Values: 
....................     This function returns void.  The properties_status of the previous call of this 
....................       function is located in the properties.status field.  This field has the 
....................       following possible values: 
....................  
....................     FS_GET_PROPERTIES_NO_ERRORS - operation completed without error.  Results 
....................       are in the properties object passed into the function. 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED - there is no mounted disk.  Results in 
....................       properties object is not valid 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE - there was a failure trying to read a 
....................       cluster from the drive.  The results in the properties object is a partial 
....................       result up until the point of the failure. 
....................     FS_GET_PROPERTIES_STILL_WORKING - the search for free sectors is still in 
....................       process.  Continue calling this function with the same properties pointer 
....................       until either the function completes or until the partial results meets the 
....................       application needs.  The properties object contains the partial results of 
....................       the search and can be used by the application. 
....................   Side Effects: 
....................     Can cause errors if called when files are open.  Close all files before 
....................     calling this function. 
....................  
....................     Calling this function without setting the new_request member on the first 
....................     call can result in undefined behavior and results. 
....................  
....................     Calling this function after a result is returned other than 
....................     FS_GET_PROPERTIES_STILL_WORKING can result in undefined behavior and results. 
....................   Description: 
....................     This function returns the information about the mounted drive.  The results 
....................     member of the properties object passed into the function is populated with 
....................     the information about the drive. 
....................  
....................     Before starting a new request, the new_request member of the properties 
....................     input parameter should be set to TRUE.  This will initiate a new search 
....................     request. 
....................  
....................     This function will return before the search is complete with partial results. 
....................     All of the results except the free_clusters will be correct after the first 
....................     call.  The free_clusters will contain the number of free clusters found up 
....................     until that point, thus the free_clusters result will continue to grow until 
....................     the entire drive is searched.  If an application only needs to know that a 
....................     certain number of bytes is available and doesn't need to know the total free 
....................     size, then this function can be called until the required free size is 
....................     verified.  To continue a search, pass a pointer to the same FS_DISK_PROPERTIES 
....................     object that was passed in to create the search. 
....................  
....................     A new search request sould be made once this function has returned a value 
....................     other than FS_GET_PROPERTIES_STILL_WORKING.  Continuing a completed search 
....................     can result in undefined behavior or results. 
....................  
....................     Typical Usage: 
....................     <code> 
....................     FS_DISK_PROPERTIES disk_properties; 
....................  
....................     disk_properties.new_request = TRUE; 
....................  
....................     do 
....................     { 
....................         FSGetDiskProperties(&disk_properties); 
....................     } while (disk_properties.properties_status == FS_GET_PROPERTIES_STILL_WORKING); 
....................     </code> 
....................  
....................     results.disk_format - contains the format of the drive.  Valid results are 
....................       FAT12(1), FAT16(2), or FAT32(3). 
....................  
....................     results.sector_size - the sector size of the mounted drive.  Valid values are 
....................       512, 1024, 2048, and 4096. 
....................  
....................     results.sectors_per_cluster - the number sectors per cluster. 
....................  
....................     results.total_clusters - the number of total clusters on the drive.  This 
....................       can be used to calculate the total disk size (total_clusters * 
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................     results.free_clusters - the number of free (unallocated) clusters on the drive. 
....................       This can be used to calculate the total free disk size (free_clusters * 
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................   Remarks: 
....................     PIC24F size estimates: 
....................       Flash - 400 bytes (-Os setting) 
....................  
....................     PIC24F speed estimates: 
....................       Search takes approximately 7 seconds per Gigabyte of drive space.  Speed 
....................         will vary based on the number of sectors per cluster and the sector size. 
....................   *********************************************************************************/ 
.................... #if defined(ALLOW_GET_DISK_PROPERTIES) 
.................... void FSGetDiskProperties(FS_DISK_PROPERTIES* properties) 
*
08162:  MOV     W5,[W15++]
08164:  MOV     #C,W5
08166:  REPEAT  #3
08168:  MOV     [W5++],[W15++]
*
0816C:  CLR     F98
0816E:  CLR     F9A
.................... { 
....................     BYTE    i; 
*
0816A:  CLR.B   F96
....................     DWORD   value = 0x0; 
....................  
....................     if(properties->new_request == TRUE) 
*
08170:  MOV     #2,W0
08172:  ADD     F94,W0
08174:  MOV     W0,W4
08176:  CLR     W0
08178:  MOV.B   [W4],W3L
0817A:  BTSC    W3.0
0817C:  INC     W0,W0
0817E:  CP.B    W0L,#1
08180:  BRA     NZ,8312
....................     { 
....................         properties->disk = &gDiskData; 
08182:  MOV     F94,W4
08184:  ADD     W4,#0,W4
08186:  MOV     W4,W0
08188:  MOV     W0,W5
0818A:  MOV.B   #8,W0L
0818C:  MOV.B   W0L,[W5]
0818E:  MOV.B   #D,W0L
08190:  MOV.B   W0L,[W5+#1]
....................         properties->results.free_clusters = 0; 
08192:  MOV     #E,W0
08194:  ADD     F94,W0
08196:  MOV     W0,W5
08198:  CLR.B   [W5]
0819A:  MOV.B   #0,W0L
0819C:  MOV.B   W0L,[W5+#1]
0819E:  MOV.B   #0,W0L
081A0:  MOV.B   W0L,[W5+#2]
081A2:  MOV.B   #0,W0L
081A4:  MOV.B   W0L,[W5+#3]
....................         properties->new_request = FALSE; 
081A6:  MOV     #2,W0
081A8:  ADD     F94,W0
081AA:  MOV     W0,W5
081AC:  MOV     #FE,W4
081AE:  AND.B   W4L,[W5],[W5]
....................  
....................         if(properties->disk->mount != TRUE) 
081B0:  MOV     #0,W0
081B2:  ADD     F94,W0
081B4:  MOV     W0,W5
081B6:  MOV     W5,W0
081B8:  MOV     [W0],W6
081BA:  MOV     #23,W4
081BC:  ADD     W6,W4,W0
081BE:  MOV     #E,W1
081C0:  MOV     W0,W2
081C2:  MOV.B   [W2++],[W1++]
081C4:  CP.B    W7L,#1
081C6:  BRA     Z,81D4
....................         { 
....................             properties->properties_status = FS_GET_PROPERTIES_DISK_NOT_MOUNTED; 
081C8:  MOV     #3,W0
081CA:  ADD     F94,W0
081CC:  MOV     W0,W5
081CE:  MOV.B   #1,W0L
081D0:  MOV.B   W0L,[W5]
....................             return; 
081D2:  BRA     8428
....................         } 
....................  
....................         properties->properties_status = FS_GET_PROPERTIES_STILL_WORKING; 
081D4:  MOV     #3,W0
081D6:  ADD     F94,W0
081D8:  MOV     W0,W5
081DA:  SETM.B  [W5]
....................  
....................         properties->results.disk_format = properties->disk->type; 
081DC:  MOV     #4,W0
081DE:  ADD     F94,W0
081E0:  MOV     W0,W5
081E2:  MOV     #0,W0
081E4:  ADD     F94,W0
081E6:  MOV     W0,W6
081E8:  MOV     W6,W0
081EA:  MOV     [W0],W7
081EC:  MOV     #22,W4
081EE:  ADD     W7,W4,W0
081F0:  MOV     #10,W1
081F2:  MOV     W0,W2
081F4:  MOV.B   [W2++],[W1++]
081F6:  MOV.B   W8L,[W5]
....................         properties->results.sector_size = properties->disk->sectorSize; 
081F8:  MOV     #6,W0
081FA:  ADD     F94,W0
081FC:  MOV     W0,W5
081FE:  MOV     #0,W0
08200:  ADD     F94,W0
08202:  MOV     W0,W6
08204:  MOV     W6,W0
08206:  MOV     [W0],W7
08208:  ADD     W7,#18,W7
0820A:  MOV     W7,W0
0820C:  MOV     #10,W1
0820E:  MOV     W0,W2
08210:  REPEAT  #3
08212:  MOV.B   [W2++],[W1++]
08214:  MOV     W8,[W5]
....................         properties->results.sectors_per_cluster = properties->disk->SecPerClus; 
08216:  MOV     #8,W0
08218:  ADD     F94,W0
0821A:  MOV     W0,W5
0821C:  MOV     #0,W0
0821E:  ADD     F94,W0
08220:  MOV     W0,W6
08222:  MOV     W6,W0
08224:  MOV     [W0],W7
08226:  MOV     #21,W4
08228:  ADD     W7,W4,W0
0822A:  MOV     #10,W1
0822C:  MOV     W0,W2
0822E:  MOV.B   [W2++],[W1++]
08230:  MOV.B   W8L,[W5]
....................         properties->results.total_clusters = properties->disk->maxcls; 
08232:  MOV     #A,W0
08234:  ADD     F94,W0
08236:  MOV     W0,W5
08238:  MOV     #0,W0
0823A:  ADD     F94,W0
0823C:  MOV     W0,W6
0823E:  MOV     W6,W0
08240:  MOV     [W0],W7
08242:  ADD     W7,#14,W7
08244:  MOV     W7,W0
08246:  MOV     #10,W1
08248:  MOV     W0,W2
0824A:  REPEAT  #3
0824C:  MOV.B   [W2++],[W1++]
0824E:  MOV     #10,W4
08250:  MOV     [W4++],[W5++]
08252:  MOV     [W4++],[W5++]
....................  
....................         /* Settings based on FAT type */ 
....................         switch (properties->disk->type) 
08254:  MOV     #0,W0
08256:  ADD     F94,W0
08258:  MOV     W0,W5
0825A:  MOV     W5,W0
0825C:  MOV     [W0],W6
0825E:  MOV     #22,W4
08260:  ADD     W6,W4,W0
08262:  MOV     #E,W1
08264:  MOV     W0,W2
08266:  MOV.B   [W2++],[W1++]
08268:  MOV.B   W7L,W0L
0826A:  CLR.B   1
0826C:  XOR     #3,W0
0826E:  BRA     Z,8276
08270:  XOR     #1,W0
08272:  BRA     Z,82A4
08274:  BRA     82D2
....................         { 
....................     #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................             case FAT32: 
....................                 properties->private.EndClusterLimit = END_CLUSTER_FAT32; 
08276:  MOV     #1A,W0
08278:  ADD     F94,W0
0827A:  MOV     W0,W5
0827C:  MOV.B   #F7,W0L
0827E:  MOV.B   W0L,[W5]
08280:  MOV.B   #FF,W0L
08282:  MOV.B   W0L,[W5+#1]
08284:  MOV.B   #FF,W0L
08286:  MOV.B   W0L,[W5+#2]
08288:  MOV.B   #F,W0L
0828A:  MOV.B   W0L,[W5+#3]
....................                 properties->private.ClusterFailValue = CLUSTER_FAIL_FAT32; 
0828C:  MOV     #1E,W0
0828E:  ADD     F94,W0
08290:  MOV     W0,W5
08292:  SETM.B  [W5]
08294:  MOV.B   #FF,W0L
08296:  MOV.B   W0L,[W5+#1]
08298:  MOV.B   #FF,W0L
0829A:  MOV.B   W0L,[W5+#2]
0829C:  MOV.B   #F,W0L
0829E:  MOV.B   W0L,[W5+#3]
....................                 break; 
082A0:  GOTO    82D2
....................     #endif 
....................             case FAT16: 
....................                 properties->private.EndClusterLimit = END_CLUSTER_FAT16; 
082A4:  MOV     #1A,W0
082A6:  ADD     F94,W0
082A8:  MOV     W0,W5
082AA:  MOV.B   #F7,W0L
082AC:  MOV.B   W0L,[W5]
082AE:  MOV.B   #FF,W0L
082B0:  MOV.B   W0L,[W5+#1]
082B2:  MOV.B   #0,W0L
082B4:  MOV.B   W0L,[W5+#2]
082B6:  MOV.B   #0,W0L
082B8:  MOV.B   W0L,[W5+#3]
....................                 properties->private.ClusterFailValue = CLUSTER_FAIL_FAT16; 
082BA:  MOV     #1E,W0
082BC:  ADD     F94,W0
082BE:  MOV     W0,W5
082C0:  SETM.B  [W5]
082C2:  MOV.B   #FF,W0L
082C4:  MOV.B   W0L,[W5+#1]
082C6:  MOV.B   #0,W0L
082C8:  MOV.B   W0L,[W5+#2]
082CA:  MOV.B   #0,W0L
082CC:  MOV.B   W0L,[W5+#3]
....................                 break; 
082CE:  GOTO    82D2
.................... #ifdef SUPPORT_FAT12 
....................             case FAT12: 
....................                 properties->private.EndClusterLimit = END_CLUSTER_FAT12; 
....................                 properties->private.ClusterFailValue = CLUSTER_FAIL_FAT16; 
....................                 break; 
.................... #endif 
....................         } 
....................  
....................         properties->private.c = 2; 
082D2:  MOV     #12,W0
082D4:  ADD     F94,W0
082D6:  MOV     W0,W5
082D8:  MOV.B   #2,W0L
082DA:  MOV.B   W0L,[W5]
082DC:  MOV.B   #0,W0L
082DE:  MOV.B   W0L,[W5+#1]
082E0:  MOV.B   #0,W0L
082E2:  MOV.B   W0L,[W5+#2]
082E4:  MOV.B   #0,W0L
082E6:  MOV.B   W0L,[W5+#3]
....................  
....................         properties->private.curcls = properties->private.c; 
082E8:  MOV     #16,W0
082EA:  ADD     F94,W0
082EC:  MOV     W0,W5
082EE:  MOV     #12,W0
082F0:  ADD     F94,W0
082F2:  MOV     [W0++],[W5++]
082F4:  MOV     [W0++],[W5++]
....................         ReadFAT(properties->disk, properties->private.c); 
082F6:  MOV     F94,W4
082F8:  ADD     W4,#0,W4
082FA:  MOV     W4,W0
082FC:  MOV     [W0],W5
082FE:  MOV     #12,W0
08300:  ADD     F94,W0
08302:  MOV     #C,W4
08304:  MOV     [W0++],[W4++]
08306:  MOV     [W0++],[W4++]
08308:  MOV     W5,1048
0830A:  MOV     W6,104A
0830C:  MOV     W7,104C
0830E:  CALL    2ECC
....................     } 
....................  
....................     if(properties->disk == NULL) 
08312:  MOV     F94,W4
08314:  ADD     W4,#0,W4
08316:  MOV     W4,W0
08318:  MOV     [W0],W5
0831A:  CP0     W5
0831C:  BRA     NZ,832A
....................     { 
....................         properties->properties_status = FS_GET_PROPERTIES_DISK_NOT_MOUNTED; 
0831E:  MOV     #3,W0
08320:  ADD     F94,W0
08322:  MOV     W0,W5
08324:  MOV.B   #1,W0L
08326:  MOV.B   W0L,[W5]
....................         return; 
08328:  BRA     8428
....................     } 
....................  
....................     if(properties->properties_status != FS_GET_PROPERTIES_STILL_WORKING) 
0832A:  MOV     #3,W0
0832C:  ADD     F94,W0
0832E:  MOV.B   [W0],W4L
08330:  XOR.B   #FF,W4L
08332:  BRA     Z,8336
....................     { 
....................         return; 
08334:  BRA     8428
....................     } 
....................  
....................     // sequentially scan through the FAT looking for an empty cluster 
....................     for(i=0;i<255;i++) 
08336:  CLR.B   F96
08338:  MOV     F96,W4
0833A:  XOR.B   #FF,W4L
0833C:  BRA     Z,8420
....................     { 
....................         // look at its value 
....................         if ( (value = ReadFAT(properties->disk, properties->private.c)) == properties->private.ClusterFailValue) 
0833E:  MOV     F94,W4
08340:  ADD     W4,#0,W4
08342:  MOV     W4,W0
08344:  MOV     [W0],W5
08346:  MOV     #12,W0
08348:  ADD     F94,W0
0834A:  MOV     #C,W4
0834C:  MOV     [W0++],[W4++]
0834E:  MOV     [W0++],[W4++]
08350:  MOV     W5,1048
08352:  MOV     W6,104A
08354:  MOV     W7,104C
08356:  CALL    2ECC
0835A:  MOV     W0,F98
0835C:  MOV     W1,F9A
0835E:  MOV     #1E,W0
08360:  ADD     F94,W0
08362:  MOV     W0,W4
08364:  MOV     #0,W3
08366:  MOV     [W4++],[W3++]
08368:  MOV     [W4++],[W3++]
0836A:  CP      F98
0836C:  BRA     NZ,8380
0836E:  MOV     F9A,W4
08370:  CP      W4,W1
08372:  BRA     NZ,8380
....................         { 
....................             properties->properties_status = FS_GET_PROPERTIES_CLUSTER_FAILURE; 
08374:  MOV     #3,W0
08376:  ADD     F94,W0
08378:  MOV     W0,W5
0837A:  MOV.B   #2,W0L
0837C:  MOV.B   W0L,[W5]
....................             return; 
0837E:  BRA     8428
....................         } 
....................  
....................         // check if empty cluster found 
....................         if (value == CLUSTER_EMPTY) 
08380:  CP0     F98
08382:  BRA     NZ,8394
08384:  CP0     F9A
08386:  BRA     NZ,8394
....................         { 
....................             properties->results.free_clusters++; 
08388:  MOV     #E,W0
0838A:  ADD     F94,W0
0838C:  MOV     W0,W5
0838E:  INC     [W5],[W5++]
08390:  BTSC.B  42.1
08392:  INC     [W5],[W5++]
....................         } 
....................  
....................         properties->private.c++;    // check next cluster in FAT 
08394:  MOV     #12,W0
08396:  ADD     F94,W0
08398:  MOV     W0,W5
0839A:  INC     [W5],[W5++]
0839C:  BTSC.B  42.1
0839E:  INC     [W5],[W5++]
....................         // check if reached last cluster in FAT, re-start from top 
....................         if ((value == properties->private.EndClusterLimit) || (properties->private.c >= (properties->results.total_clusters + 2))) 
083A0:  MOV     #1A,W0
083A2:  ADD     F94,W0
083A4:  MOV     W0,W4
083A6:  MOV     #0,W3
083A8:  MOV     [W4++],[W3++]
083AA:  MOV     [W4++],[W3++]
083AC:  CP      F98
083AE:  BRA     NZ,83B6
083B0:  MOV     F9A,W4
083B2:  CP      W4,W1
083B4:  BRA     Z,83DC
083B6:  MOV     #12,W0
083B8:  ADD     F94,W0
083BA:  MOV     #A,W4
083BC:  MOV     [W0++],[W4++]
083BE:  MOV     [W0++],[W4++]
083C0:  MOV     #A,W0
083C2:  ADD     F94,W0
083C4:  MOV     #E,W4
083C6:  MOV     [W0++],[W4++]
083C8:  MOV     [W0++],[W4++]
083CA:  ADD     W7,#2,W7
083CC:  MOV     W7,W0
083CE:  ADDC    W8,#0,W8
083D0:  MOV     W8,W1
083D2:  CP      W1,W6
083D4:  BRA     GTU,83F2
083D6:  BRA     NC,83DC
083D8:  CP      W0,W5
083DA:  BRA     GTU,83F2
....................             properties->private.c = 2; 
083DC:  MOV     #12,W0
083DE:  ADD     F94,W0
083E0:  MOV     W0,W5
083E2:  MOV.B   #2,W0L
083E4:  MOV.B   W0L,[W5]
083E6:  MOV.B   #0,W0L
083E8:  MOV.B   W0L,[W5+#1]
083EA:  MOV.B   #0,W0L
083EC:  MOV.B   W0L,[W5+#2]
083EE:  MOV.B   #0,W0L
083F0:  MOV.B   W0L,[W5+#3]
....................  
....................         // check if full circle done, disk full 
....................         if ( properties->private.c == properties->private.curcls) 
083F2:  MOV     #12,W0
083F4:  ADD     F94,W0
083F6:  MOV     #A,W4
083F8:  MOV     [W0++],[W4++]
083FA:  MOV     [W0++],[W4++]
083FC:  MOV     #16,W0
083FE:  ADD     F94,W0
08400:  MOV     W0,W4
08402:  MOV     #0,W3
08404:  MOV     [W4++],[W3++]
08406:  MOV     [W4++],[W3++]
08408:  CP      W5,W0
0840A:  BRA     NZ,841A
0840C:  CP      W6,W1
0840E:  BRA     NZ,841A
....................         { 
....................             properties->properties_status = FS_GET_PROPERTIES_NO_ERRORS; 
08410:  MOV     #3,W0
08412:  ADD     F94,W0
08414:  MOV     W0,W5
08416:  CLR.B   [W5]
....................             return; 
08418:  BRA     8428
....................         } 
0841A:  INC.B   0F96
0841C:  GOTO    8338
....................     }  // scanning for an empty cluster 
....................  
....................     properties->properties_status = FS_GET_PROPERTIES_STILL_WORKING; 
08420:  MOV     #3,W0
08422:  ADD     F94,W0
08424:  MOV     W0,W5
08426:  SETM.B  [W5]
....................     return; 
08428:  MOV     #12,W5
0842A:  REPEAT  #3
0842C:  MOV     [--W15],[W5--]
0842E:  MOV     [--W15],W5
08430:  RETURN  
.................... } 
.................... #endif 
....................  
.................... /************************************************************ 
....................   Function: 
....................     int FSfclose(FSFILE *fo) 
....................   Summary: 
....................     Update file information and free FSFILE objects 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to the file to close 
....................   Return Values: 
....................     0 -   File closed successfully 
....................     EOF - Error closing the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will update the directory entry for the 
....................     file pointed to by 'fo' with the information contained 
....................     in 'fo,' including the new file size and attributes. 
....................     Timestamp information will also be loaded based on the 
....................     method selected by the user and written to the entry 
....................     as the last modified time and date.  The file entry will 
....................     then be written to the device.  Finally, the memory 
....................     used for the specified file object will be freed from 
....................     the dynamic heap or the array of FSFILE objects. 
....................   Remarks: 
....................     A function to flush data to the device without closing the 
....................     file can be created by removing the portion of this 
....................     function that frees the memory and the line that clears 
....................     the write flag. 
....................   ************************************************************/ 
....................  
.................... int FSfclose(FSFILE   *fo) 
*
05142:  MOV     W5,[W15++]
05144:  MOV     W6,[W15++]
05146:  MOV     W7,[W15++]
*
0514C:  MOV     #48,W4
0514E:  MOV     W4,FC8
.................... { 
....................     WORD        fHandle; 
*
05148:  CLR     FC4
.................... #ifndef FS_DYNAMIC_MEM 
....................     WORD        fIndex; 
0514A:  CLR     FC6
.................... #endif 
....................     int        error = 72; 
.................... #ifdef ALLOW_WRITES 
....................     DIRENTRY    dir; 
*
05150:  CLR     FCA
.................... #endif 
....................  
....................     FSerrno = CE_GOOD; 
05152:  CLR.B   857
....................     fHandle = fo->entry; 
05154:  MOV     #28,W0
05156:  ADD     FC2,W0
05158:  MOV     [W0],[W15++]
0515A:  POP     FC4
....................  
.................... #ifdef ALLOW_WRITES 
....................     if(fo->flags.write) 
0515C:  MOV     #16,W0
0515E:  ADD     FC2,W0
05160:  MOV.B   [W0],W4L
05162:  BTSS    W4.0
05164:  BRA     5238
....................     { 
....................         if (gNeedDataWrite) 
05166:  CP0.B   854
05168:  BRA     Z,517A
....................         { 
....................             if (flushData()) 
0516A:  CALL    3170
0516E:  CP0.B   W0L
05170:  BRA     Z,517A
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
05172:  MOV.B   #9,W0L
05174:  MOV.B   W0L,857
....................                 return EOF; 
05176:  SETM    0
05178:  BRA     526C
....................             } 
....................         } 
....................  
....................         // Write the current FAT sector to the disk 
....................         WriteFAT (fo->dsk, 0, 0, TRUE); 
0517A:  MOV     FC2,W4
0517C:  ADD     W4,#0,W4
0517E:  MOV     W4,W0
05180:  MOV     [W0],W5
05182:  MOV     W0,[W15++]
05184:  MOV.B   #1,W0L
05186:  MOV.B   W0L,1078
05188:  MOV     [--W15],W0
0518A:  MOV     W5,106E
0518C:  CLR     1070
0518E:  CLR     1072
05190:  CLR     1074
05192:  CLR     1076
05194:  CALL    2C18
....................  
....................         // Invalidate the currently cached FAT entry so that the next read will 
....................         //   result in an acutal read from the physical media instead of a read 
....................         //   from the RAM cache. 
....................         gLastFATSectorRead = 0; 
05198:  CLR     84A
0519A:  CLR     84C
....................  
....................         // Read the FAT entry from the physical media.  This is required because 
....................         //   some physical media cache the entries in RAM and only write them 
....................         //   after a time expires for until the sector is accessed again. 
....................         ReadFAT (fo->dsk, fo->ccls); 
0519C:  MOV     FC2,W4
0519E:  ADD     W4,#0,W4
051A0:  MOV     W4,W0
051A2:  MOV     [W0],W5
051A4:  MOV     #6,W0
051A6:  ADD     FC2,W0
051A8:  MOV     #C,W4
051AA:  MOV     [W0++],[W4++]
051AC:  MOV     [W0++],[W4++]
051AE:  MOV     W5,1048
051B0:  MOV     W6,104A
051B2:  MOV     W7,104C
051B4:  CALL    2ECC
....................  
....................         // Get the file entry 
....................         dir = LoadDirAttrib(fo, &fHandle); 
051B8:  PUSH    FC2
051BA:  POP     FF0
051BC:  MOV     #FC4,W4
051BE:  MOV     W4,FF2
051C0:  CALL    42F0
051C4:  MOV     W0,FCA
....................  
....................         if (dir == NULL) 
051C6:  CP0     FCA
051C8:  BRA     NZ,51D6
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
051CA:  MOV.B   #1B,W0L
051CC:  MOV.B   W0L,857
....................             error = EOF; 
051CE:  SETM    FC8
....................             return error; 
051D0:  PUSH    FC8
051D2:  POP     0
051D4:  BRA     526C
....................         } 
....................  
....................       // update the time 
.................... #ifdef INCREMENTTIMESTAMP 
....................         IncrementTimeStamp(dir); 
.................... #elif defined USERDEFINEDCLOCK 
....................         dir->DIR_WrtTime = gTimeWrtTime; 
051D6:  MOV     #16,W0
051D8:  ADD     FCA,W0
051DA:  MOV     W0,W5
051DC:  MOV     846,W4
051DE:  MOV     W4,[W5+#0]
....................         dir->DIR_WrtDate = gTimeWrtDate; 
051E0:  MOV     #18,W0
051E2:  ADD     FCA,W0
051E4:  MOV     W0,W5
051E6:  MOV     848,W4
051E8:  MOV     W4,[W5+#0]
.................... #elif defined USEREALTIMECLOCK 
....................         CacheTime(); 
....................         dir->DIR_WrtTime = gTimeWrtTime; 
....................         dir->DIR_WrtDate = gTimeWrtDate; 
.................... #endif 
....................  
....................         dir->DIR_FileSize = fo->size; 
051EA:  MOV     #1C,W0
051EC:  ADD     FCA,W0
051EE:  MOV     W0,W5
051F0:  MOV     #12,W0
051F2:  ADD     FC2,W0
051F4:  MOV     [W0++],[W5++]
051F6:  MOV     [W0++],[W5++]
....................  
....................         dir->DIR_Attr = fo->attributes; 
051F8:  MOV     #B,W0
051FA:  ADD     FCA,W0
051FC:  MOV     W0,W5
051FE:  MOV     #2C,W0
05200:  ADD     FC2,W0
05202:  MOV.B   [W0],[W5]
....................  
....................         // just write the last entry in 
....................         if(Write_File_Entry(fo,&fHandle)) 
05204:  PUSH    FC2
05206:  POP     1006
05208:  MOV     #FC4,W4
0520A:  MOV     W4,1008
0520C:  CALL    3964
05210:  CP0.B   W0L
05212:  BRA     Z,5228
....................         { 
....................             // Read the folder entry from the physical media.  This is required because 
....................             //   some physical media cache the entries in RAM and only write them 
....................             //   after a time expires for until the sector is accessed again. 
....................             dir = LoadDirAttrib(fo, &fHandle); 
05214:  PUSH    FC2
05216:  POP     FF0
05218:  MOV     #FC4,W4
0521A:  MOV     W4,FF2
0521C:  CALL    42F0
05220:  MOV     W0,FCA
....................             error = 0; 
05222:  CLR     FC8
....................         } 
05224:  GOTO    522E
....................         else 
....................         { 
....................             FSerrno = CE_WRITE_ERROR; 
05228:  MOV.B   #9,W0L
0522A:  MOV.B   W0L,857
....................             error = EOF; 
0522C:  SETM    FC8
....................         } 
....................  
....................         // it's now closed 
....................         fo->flags.write = FALSE; 
0522E:  MOV     #16,W0
05230:  ADD     FC2,W0
05232:  MOV     W0,W5
05234:  MOV     #FE,W4
05236:  AND.B   W4L,[W5],[W5]
....................     } 
.................... #endif 
....................  
.................... #ifdef FS_DYNAMIC_MEM 
....................     #ifdef   SUPPORT_LFN 
....................       FS_free((unsigned char *)fo->utf16LFNptr); 
....................    #endif 
....................    FS_free((unsigned char *)fo); 
.................... #else 
....................  
....................     for( fIndex = 0; fIndex < FS_MAX_FILES_OPEN; fIndex++ ) 
05238:  CLR     FC6
0523A:  CP0     FC6
0523C:  BRA     NZ,5260
....................     { 
....................         if( fo == &gFileArray[fIndex] ) 
0523E:  MOV     FC6,W4
05240:  MOV     #36,W3
05242:  MUL.UU  W4,W3,W0
05244:  MOV     #808,W4
05246:  ADD     W0,W4,W0
05248:  CP      FC2
0524A:  BRA     NZ,525A
....................         { 
....................             gFileSlotOpen[fIndex] = TRUE; 
0524C:  MOV     #801,W4
0524E:  MOV     FC6,W3
05250:  ADD     W3,W4,W5
05252:  MOV.B   #1,W0L
05254:  MOV.B   W0L,[W5]
....................             break; 
05256:  GOTO    5260
....................         } 
0525A:  INC     0FC6
0525C:  GOTO    523A
....................     } 
.................... #endif 
....................  
....................     // File opened in read mode 
....................     if (error == 72) 
05260:  MOV     FC8,W4
05262:  XOR     #48,W4
05264:  BRA     NZ,5268
....................         error = 0; 
05266:  CLR     FC8
....................  
....................     return(error); 
05268:  PUSH    FC8
0526A:  POP     0
0526C:  MOV     [--W15],W7
0526E:  MOV     [--W15],W6
05270:  MOV     [--W15],W5
05272:  RETURN  
.................... } // FSfclose 
....................  
....................  
.................... /******************************************************* 
....................   Function: 
....................     void IncrementTimeStamp(DIRENTRY dir) 
....................   Summary: 
....................     Automatically set the timestamp to "don't care" data 
....................   Conditions: 
....................     Should not be called by the user. 
....................   Input: 
....................     dir -  Pointer to directory structure 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will increment the timestamp variable in 
....................     the 'dir' directory entry.  This is used for the 
....................     don't-care timing method. 
....................   Remarks: 
....................     None 
....................   *******************************************************/ 
.................... #ifdef INCREMENTTIMESTAMP 
.................... void IncrementTimeStamp(DIRENTRY dir) 
.................... { 
....................     BYTE          seconds; 
....................     BYTE          minutes; 
....................     BYTE          hours; 
....................  
....................     BYTE          day; 
....................     BYTE          month; 
....................     BYTE          year; 
....................  
....................     seconds = (dir->DIR_WrtTime & 0x1f); 
....................     minutes = ((dir->DIR_WrtTime & 0x07E0) >> 5); 
....................     hours   = ((dir->DIR_WrtTime & 0xF800) >> 11); 
....................  
....................     day     = (dir->DIR_WrtDate & 0x1f); 
....................     month   = ((dir->DIR_WrtDate & 0x01E0) >> 5); 
....................     year    = ((dir->DIR_WrtDate & 0xFE00) >> 9); 
....................  
....................     if(seconds < 29) 
....................     { 
....................         // Increment number of seconds by 2 
....................         // This clock method isn't intended to be accurate anyway 
....................         seconds++; 
....................     } 
....................     else 
....................     { 
....................         seconds = 0x00; 
....................  
....................         if(minutes < 59) 
....................         { 
....................             minutes++; 
....................         } 
....................         else 
....................         { 
....................             minutes = 0; 
....................  
....................             if(hours < 23) 
....................             { 
....................                 hours++; 
....................             } 
....................             else 
....................             { 
....................                 hours = 0; 
....................                 if(day < 30) 
....................                 { 
....................                     day++; 
....................                 } 
....................                 else 
....................                 { 
....................                     day = 1; 
....................  
....................                     if(month < 12) 
....................                     { 
....................                         month++; 
....................                     } 
....................                     else 
....................                     { 
....................                         month = 1; 
....................                         // new year 
....................                         year++; 
....................                         // This is only valid until 2107 
....................                     } 
....................                 } 
....................             } 
....................         } 
....................     } 
....................  
....................     dir->DIR_WrtTime = (WORD)(seconds); 
....................     dir->DIR_WrtTime |= ((WORD)(minutes) << 5); 
....................     dir->DIR_WrtTime |= ((WORD)(hours) << 11); 
....................  
....................     dir->DIR_WrtDate = (WORD)(day); 
....................     dir->DIR_WrtDate |= ((WORD)(month) << 5); 
....................     dir->DIR_WrtDate |= ((WORD)(year) << 9); 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************** 
....................   Function: 
....................     BYTE Fill_File_Object(FILEOBJ fo, WORD *fHandle) 
....................   Summary: 
....................     Fill a file object with specified dir entry data 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................     fHandle -  Passed member's location 
....................   Return Values: 
....................     FOUND -     Operation successful 
....................     NOT_FOUND - Operation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache the sector of directory entries 
....................     in the directory pointed to by the dirclus value in 
....................     the FSFILE object 'fo' that contains the entry that 
....................     corresponds to the fHandle offset.  It will then copy 
....................     the file information for that entry into the 'fo' FSFILE 
....................     object. 
....................   Remarks: 
....................     None. 
....................   *****************************************************************/ 
....................  
.................... BYTE Fill_File_Object(FILEOBJ fo, WORD *fHandle) 
*
034D8:  MOV     W5,[W15++]
*
034E4:  CLR.B   1022
.................... { 
....................     DIRENTRY    dir; 
*
034DA:  CLR     101C
....................     BYTE        index, a; 
034DC:  CLR.B   101E
034DE:  CLR.B   101F
....................     BYTE        character; 
034E0:  CLR.B   1020
....................     BYTE        status; 
034E2:  CLR.B   1021
....................     BYTE        test = 0; 
....................  
.................... #ifdef __DEBUG_UART   
.................... PrintROMASCIIStringUART("Fill_File_Object"); 
.................... #endif 
....................  
....................  
....................     // Get the entry 
....................     if (((*fHandle & MASK_MAX_FILE_ENTRY_LIMIT_BITS) == 0) && (*fHandle != 0)) // 4-bit mask because 16-root entries max per sector 
*
034E6:  MOV     101A,W0
034E8:  MOV     [W0],W5
034EA:  AND     W5,#F,W5
034EC:  CP0     W5
034EE:  BRA     NZ,351C
034F0:  MOV     101A,W0
034F2:  MOV     [W0],W5
034F4:  CP0     W5
034F6:  BRA     Z,351C
....................     { 
....................         fo->dirccls = fo->dirclus; 
034F8:  MOV     #32,W0
034FA:  ADD     1018,W0
034FC:  MOV     W0,W5
034FE:  MOV     #2E,W0
03500:  ADD     1018,W0
03502:  MOV     [W0++],[W5++]
03504:  MOV     [W0++],[W5++]
....................          
....................          #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" Cache_File_Entry FORCE dirccls="); 
....................          PrintRAMBytesUART(((unsigned char*)&fo->dirccls), 4); 
....................          #endif     
....................      
....................         dir = Cache_File_Entry(fo, fHandle, TRUE); 
03506:  MOV.B   #1,W0L
03508:  MOV.B   W0L,102C
0350A:  PUSH    1018
0350C:  POP     1028
0350E:  PUSH    101A
03510:  POP     102A
03512:  CALL    31E4
03516:  MOV     W0,101C
....................     } 
03518:  GOTO    352C
....................     else 
....................     { 
....................          #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" Cache_File_Entry dirccls="); 
....................          PrintRAMBytesUART(((unsigned char*)&fo->dirccls), 4); 
....................          PrintROMASCIIStringUART(" dirclus="); 
....................          PrintRAMBytesUART(((unsigned char*)&fo->dirclus), 4);                   
....................          #endif     
....................           
....................         dir = Cache_File_Entry (fo, fHandle, FALSE); 
0351C:  CLR.B   102C
0351E:  PUSH    1018
03520:  POP     1028
03522:  PUSH    101A
03524:  POP     102A
03526:  CALL    31E4
0352A:  MOV     W0,101C
....................     } 
....................  
....................    #ifdef __DEBUG_UART 
....................    PrintROMASCIIStringUART(" dir="); 
....................    PrintRAMBytesUART(((unsigned char*)&dir), sizeof(dir));          
....................    #endif 
....................  
....................  
....................     // Make sure there is a directory left 
....................     if(dir == (DIRENTRY)NULL) 
0352C:  CP0     101C
0352E:  BRA     NZ,3538
....................     { 
....................         status = NO_MORE; 
03530:  MOV.B   #2,W0L
03532:  MOV.B   W0L,1021
....................     } 
03534:  GOTO    36B8
....................     else 
....................     { 
....................         // Read the first char of the file name 
....................         a = dir->DIR_Name[0]; 
03538:  MOV     #0,W0
0353A:  ADD     101C,W0
0353C:  MOV     W0,[W15++]
0353E:  MOV.B   [W0],W0L
03540:  MOV.B   W0L,101F
03542:  MOV     [--W15],W0
....................  
....................    #ifdef __DEBUG_UART 
....................    PrintROMASCIIStringUART(" a="); 
....................    PrintRAMBytesUART(((unsigned char*)&a), sizeof(a));          
....................    #endif 
....................  
....................         // Check for empty or deleted directory 
....................         if ( a == DIR_DEL) 
03544:  MOV     101E,W4
03546:  LSR     W4,#8,W4
03548:  XOR.B   #E5,W4L
0354A:  BRA     NZ,3554
....................       { 
....................             status = NOT_FOUND; 
0354C:  MOV.B   #1,W0L
0354E:  MOV.B   W0L,1021
....................       } 
03550:  GOTO    36B8
....................       else if ( a == DIR_EMPTY) 
03554:  CP0.B   101F
03556:  BRA     NZ,3560
....................       { 
....................          status = NO_MORE; 
03558:  MOV.B   #2,W0L
0355A:  MOV.B   W0L,1021
....................       } 
0355C:  GOTO    36B8
....................         else 
....................         { 
....................             // Get the attributes 
....................             a = dir->DIR_Attr; 
03560:  MOV     #B,W0
03562:  ADD     101C,W0
03564:  MOV     W0,[W15++]
03566:  MOV.B   [W0],W0L
03568:  MOV.B   W0L,101F
0356A:  MOV     [--W15],W0
....................  
....................             // print the file name and extension 
....................             for (index=0; index < DIR_NAMESIZE; index++) 
0356C:  CLR.B   101E
0356E:  MOV     101E,W4
03570:  CP.B    W4L,#8
03572:  BRA     C,35B4
....................             { 
....................                 character = dir->DIR_Name[index]; 
03574:  MOV     101E,W4
03576:  CLR.B   9
03578:  MOV     W4,W0
0357A:  ADD     101C,W0
0357C:  MOV     1020,W4
0357E:  MOV.B   [W0+#0],W4L
03580:  MOV     W4,1020
....................                 character = (BYTE)toupper(character); 
03582:  MOV     1020,W4
03584:  MOV     #61,W3
03586:  CP.B    W3L,W4L
03588:  BRA     GTU,3598
0358A:  MOV     1020,W4
0358C:  MOV     #7A,W3
0358E:  CP.B    W3L,W4L
03590:  BRA     NC,3598
03592:  MOV.B   1020,W0L
03594:  AND.B   #DF,W0L
03596:  BRA     359A
03598:  MOV.B   1020,W0L
0359A:  MOV.B   W0L,1020
....................                 fo->name[test++] = character; 
0359C:  MOV.B   1022,W0L
0359E:  INC.B   1022
035A0:  ADD.B   W0L,#1C,W0L
035A2:  ZE      W0,W0
035A4:  CLR.B   1
035A6:  MOV     1018,W4
035A8:  ADD     W0,W4,W5
035AA:  MOV     1020,W0
035AC:  MOV.B   W0L,[W5+#0]
035AE:  INC.B   101E
035B0:  GOTO    356E
....................             } 
....................  
....................             // Get the attributes 
....................             a = dir->DIR_Attr; 
035B4:  MOV     #B,W0
035B6:  ADD     101C,W0
035B8:  MOV     W0,[W15++]
035BA:  MOV.B   [W0],W0L
035BC:  MOV.B   W0L,101F
035BE:  MOV     [--W15],W0
....................  
....................             // its possible to have an extension in a directory 
....................             character = dir->DIR_Extension[0]; 
035C0:  MOV     #8,W0
035C2:  ADD     101C,W0
035C4:  MOV     1020,W4
035C6:  MOV.B   [W0+#0],W4L
035C8:  MOV     W4,1020
....................  
....................             // Get the file extension if its there 
....................             for (index=0; index < DIR_EXTENSION; index++) 
035CA:  CLR.B   101E
035CC:  MOV     101E,W4
035CE:  CP.B    W4L,#3
035D0:  BRA     C,3616
....................             { 
....................                 character = dir->DIR_Extension[index]; 
035D2:  MOV     #8,W0
035D4:  ADD.B   101E,W0L
035D6:  ZE      W0,W0
035D8:  CLR.B   1
035DA:  MOV     101C,W4
035DC:  ADD     W0,W4,W0
035DE:  MOV     1020,W4
035E0:  MOV.B   [W0+#0],W4L
035E2:  MOV     W4,1020
....................                 character = (BYTE)toupper(character); 
035E4:  MOV     1020,W4
035E6:  MOV     #61,W3
035E8:  CP.B    W3L,W4L
035EA:  BRA     GTU,35FA
035EC:  MOV     1020,W4
035EE:  MOV     #7A,W3
035F0:  CP.B    W3L,W4L
035F2:  BRA     NC,35FA
035F4:  MOV.B   1020,W0L
035F6:  AND.B   #DF,W0L
035F8:  BRA     35FC
035FA:  MOV.B   1020,W0L
035FC:  MOV.B   W0L,1020
....................                 fo->name[test++] = character; 
035FE:  MOV.B   1022,W0L
03600:  INC.B   1022
03602:  ADD.B   W0L,#1C,W0L
03604:  ZE      W0,W0
03606:  CLR.B   1
03608:  MOV     1018,W4
0360A:  ADD     W0,W4,W5
0360C:  MOV     1020,W0
0360E:  MOV.B   W0L,[W5+#0]
03610:  INC.B   101E
03612:  GOTO    35CC
....................             } 
....................  
....................    #ifdef __DEBUG_UART 
....................    PrintROMASCIIStringUART(" name="); 
....................    PrintRAMBytesUART(((unsigned char*)fo->name), test);          
....................    #endif 
....................  
....................             // done and done with the name 
....................             //         fo->name[++test] = (BYTE)'\0'; 
....................  
....................             // Now store the identifier 
....................             fo->entry = *fHandle; 
03616:  MOV     #28,W0
03618:  ADD     1018,W0
0361A:  MOV     W0,W5
0361C:  MOV     101A,W0
0361E:  MOV     [W0],[W5]
....................  
....................             // see if we are still a good file 
....................             a = dir->DIR_Name[0]; 
03620:  MOV     #0,W0
03622:  ADD     101C,W0
03624:  MOV     W0,[W15++]
03626:  MOV.B   [W0],W0L
03628:  MOV.B   W0L,101F
0362A:  MOV     [--W15],W0
....................  
....................             if(a == DIR_DEL) 
0362C:  MOV     101E,W4
0362E:  LSR     W4,#8,W4
03630:  XOR.B   #E5,W4L
03632:  BRA     NZ,363C
....................                 status = NOT_FOUND; 
03634:  MOV.B   #1,W0L
03636:  MOV.B   W0L,1021
03638:  GOTO    363E
....................             else 
....................                 status = FOUND; 
0363C:  CLR.B   1021
....................  
....................             // Now store the size 
....................             fo->size = (dir->DIR_FileSize); 
0363E:  MOV     #12,W0
03640:  ADD     1018,W0
03642:  MOV     W0,W5
03644:  MOV     #1C,W0
03646:  ADD     101C,W0
03648:  MOV     [W0++],[W5++]
0364A:  MOV     [W0++],[W5++]
....................  
....................             fo->cluster = GetFullClusterNumber(dir); // Get Complete Cluster number. 
0364C:  MOV     #2,W0
0364E:  ADD     1018,W0
03650:  MOV     W0,W5
03652:  PUSH    101C
03654:  POP     102A
03656:  CALL    34B4
0365A:  MOV     #0,W4
0365C:  MOV     [W4++],[W5++]
0365E:  MOV     [W4++],[W5++]
....................  
....................    #ifdef __DEBUG_UART 
....................    PrintROMASCIIStringUART(" cluster="); 
....................    PrintRAMBytesUART(((unsigned char*)&fo->cluster), 4);          
....................    #endif 
....................  
....................             /// -Get and store the attributes 
....................             a = dir->DIR_Attr; 
03660:  MOV     #B,W0
03662:  ADD     101C,W0
03664:  MOV     W0,[W15++]
03666:  MOV.B   [W0],W0L
03668:  MOV.B   W0L,101F
0366A:  MOV     [--W15],W0
....................             fo->attributes = a; 
0366C:  MOV     #2C,W0
0366E:  ADD     1018,W0
03670:  MOV     W0,W5
03672:  MOV.B   101F,W0L
03674:  MOV.B   W0L,[W5]
03676:  MOV.B   #0,W0L
03678:  MOV.B   W0L,[W5+#1]
....................  
....................             // get the date and time 
....................             if ((a & ATTR_DIRECTORY) != 0) 
0367A:  MOV.B   101F,W0L
0367C:  CLR.B   1
0367E:  AND     W0,#10,W5
03680:  CP0     W5
03682:  BRA     Z,36A0
....................             { 
....................                 fo->time = dir->DIR_CrtTime; 
03684:  MOV     #18,W0
03686:  ADD     1018,W0
03688:  MOV     W0,W5
0368A:  MOV     #E,W0
0368C:  ADD     101C,W0
0368E:  MOV     [W0],[W5]
....................                 fo->date = dir->DIR_CrtDate; 
03690:  MOV     #1A,W0
03692:  ADD     1018,W0
03694:  MOV     W0,W5
03696:  MOV     #10,W0
03698:  ADD     101C,W0
0369A:  MOV     [W0],[W5]
....................             } 
0369C:  GOTO    36B8
....................             else 
....................             { 
....................                 fo->time = dir->DIR_WrtTime; 
036A0:  MOV     #18,W0
036A2:  ADD     1018,W0
036A4:  MOV     W0,W5
036A6:  MOV     #16,W0
036A8:  ADD     101C,W0
036AA:  MOV     [W0],[W5]
....................                 fo->date = dir->DIR_WrtDate; 
036AC:  MOV     #1A,W0
036AE:  ADD     1018,W0
036B0:  MOV     W0,W5
036B2:  MOV     #18,W0
036B4:  ADD     101C,W0
036B6:  MOV     [W0],[W5]
....................             } 
....................  
....................         }// deleted directory 
....................     }// Ensure we are still good 
....................  
.................... #ifdef __DEBUG_UART   
.................... UARTSendLineFeedCarriageReturn(); 
.................... #endif 
....................     return(status); 
036B8:  MOV.B   1021,W0L
036BA:  MOV     [--W15],W5
036BC:  RETURN  
.................... } // Fill_File_Object 
....................  
.................... /***************************************************************** 
....................   Function: 
....................     BYTE Fill_LFN_Object(FILEOBJ fo, LFN_ENTRY *lfno, WORD *fHandle) 
....................   Summary: 
....................     Fill a LFN object with specified entry data 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -   Pointer to file structure 
....................     lfno - Pointer to Long File Name Object 
....................     fHandle -  Passed member's location 
....................   Return Values: 
....................     FOUND -     Operation successful 
....................     NOT_FOUND - Operation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache the sector of LFN entries 
....................     in the directory pointed to by the dirclus value in 
....................     the FSFILE object 'fo' that contains the entry that 
....................     corresponds to the fHandle offset.  It will then copy 
....................     the file information for that entry into the 'fo' FSFILE 
....................     object. 
....................   Remarks: 
....................     None. 
....................   *****************************************************************/ 
.................... #if defined(SUPPORT_LFN) 
.................... BYTE Fill_LFN_Object(FILEOBJ fo, LFN_ENTRY *lfno, WORD *fHandle) 
.................... { 
....................     DIRENTRY    dir; 
....................     BYTE        tempVariable; 
....................     BYTE        *src,*dst; 
....................     BYTE        status; 
....................  
....................     // Get the entry 
....................     if (((*fHandle & MASK_MAX_FILE_ENTRY_LIMIT_BITS) == 0) && (*fHandle != 0)) // 4-bit mask because 16-root entries max per sector 
....................     { 
....................         fo->dirccls = fo->dirclus; 
....................         dir = Cache_File_Entry(fo, fHandle, TRUE); 
....................     } 
....................     else 
....................     { 
....................         dir = Cache_File_Entry (fo, fHandle, FALSE); 
....................     } 
....................  
....................  
....................     // Make sure there is a directory left 
....................     if(dir == (DIRENTRY)NULL) 
....................     { 
....................         status = NO_MORE; 
....................     } 
....................     else 
....................     { 
....................         // Read the first char of the file name 
....................         tempVariable = dir->DIR_Name[0]; 
....................  
....................         // Check for empty or deleted directory 
....................         if ( tempVariable == DIR_DEL) 
....................       { 
....................             status = NOT_FOUND; 
....................       } 
....................       else if ( tempVariable == DIR_EMPTY) 
....................       { 
....................          status = NO_MORE; 
....................       } 
....................         else 
....................         { 
....................             status = FOUND; 
....................  
....................          dst = (BYTE *)lfno; 
....................          src = (BYTE *)dir; 
....................  
....................          // Copy the entry in the lfno object 
....................          for(tempVariable = 0;tempVariable < 32;tempVariable++) 
....................          { 
....................             *dst++ = *src++; 
....................          } 
....................         }// deleted directory 
....................     }// Ensure we are still good 
....................     return(status); 
.................... } // Fill_File_Object 
.................... #endif 
.................... /************************************************************************ 
....................   Function: 
....................     DIRENTRY LoadDirAttrib(FILEOBJ fo, WORD *fHandle) 
....................   Summary: 
....................     Load file information from a directory entry and cache the entry 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................     fHandle -  Information location 
....................   Return Values: 
....................     DIRENTRY - Pointer to the directory entry 
....................     NULL -     Directory entry could not be loaded 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache the sector of directory entries 
....................     in the directory pointed to by the dirclus value in 
....................     the FSFILE object 'fo' that contains the entry that 
....................     corresponds to the fHandle offset.  It will then return a pointer 
....................     to the directory entry in the global data buffer. 
....................   Remarks: 
....................     None. 
....................   ************************************************************************/ 
....................  
.................... DIRENTRY LoadDirAttrib(FILEOBJ fo, WORD *fHandle) 
*
042F0:  MOV     W5,[W15++]
.................... { 
....................     DIRENTRY    dir; 
042F2:  CLR     FF4
....................     BYTE      a; 
042F4:  CLR.B   FF6
....................  
....................     fo->dirccls = fo->dirclus; 
042F6:  MOV     #32,W0
042F8:  ADD     FF0,W0
042FA:  MOV     W0,W5
042FC:  MOV     #2E,W0
042FE:  ADD     FF0,W0
04300:  MOV     [W0++],[W5++]
04302:  MOV     [W0++],[W5++]
....................     // Get the entry 
....................     dir = Cache_File_Entry( fo, fHandle, TRUE); 
04304:  MOV.B   #1,W0L
04306:  MOV.B   W0L,102C
04308:  PUSH    FF0
0430A:  POP     1028
0430C:  PUSH    FF2
0430E:  POP     102A
04310:  CALL    31E4
04314:  MOV     W0,FF4
....................     if (dir == NULL) 
04316:  CP0     FF4
04318:  BRA     NZ,431E
....................         return NULL; 
0431A:  CLR     0
0431C:  BRA     437C
....................  
....................     // Read the first char of the file name 
....................     a = dir->DIR_Name[0]; 
0431E:  MOV     #0,W0
04320:  ADD     FF4,W0
04322:  MOV     FF6,W4
04324:  MOV.B   [W0+#0],W4L
04326:  MOV     W4,FF6
....................  
....................     // Make sure there is a directory left 
....................     if(a == DIR_EMPTY) 
04328:  CP0.B   FF6
0432A:  BRA     NZ,432E
....................         dir = (DIRENTRY)NULL; 
0432C:  CLR     FF4
....................  
....................     if(dir != (DIRENTRY)NULL) 
0432E:  CP0     FF4
04330:  BRA     Z,4378
....................     { 
....................         // Check for empty or deleted directory 
....................         if ( a == DIR_DEL) 
04332:  MOV     FF6,W4
04334:  XOR.B   #E5,W4L
04336:  BRA     NZ,433E
....................             dir = (DIRENTRY)NULL; 
04338:  CLR     FF4
0433A:  GOTO    4378
....................         else 
....................         { 
....................             // Get the attributes 
....................             a = dir->DIR_Attr; 
0433E:  MOV     #B,W0
04340:  ADD     FF4,W0
04342:  MOV     FF6,W4
04344:  MOV.B   [W0+#0],W4L
04346:  MOV     W4,FF6
....................  
....................             // scan through all the long dir entries 
....................             while(a == ATTR_LONG_NAME) 
04348:  MOV     FF6,W4
0434A:  CP.B    W4L,#F
0434C:  BRA     NZ,4378
....................             { 
....................                 (*fHandle)++; 
0434E:  MOV     FF2,W5
04350:  INC     [W5],[W5]
....................                 dir = Cache_File_Entry( fo, fHandle, FALSE); 
04352:  CLR.B   102C
04354:  PUSH    FF0
04356:  POP     1028
04358:  PUSH    FF2
0435A:  POP     102A
0435C:  CALL    31E4
04360:  MOV     W0,FF4
....................                 if (dir == NULL) 
04362:  CP0     FF4
04364:  BRA     NZ,436A
....................                     return NULL; 
04366:  CLR     0
04368:  BRA     437C
....................                 a = dir->DIR_Attr; 
0436A:  MOV     #B,W0
0436C:  ADD     FF4,W0
0436E:  MOV     FF6,W4
04370:  MOV.B   [W0+#0],W4L
04372:  MOV     W4,FF6
04374:  GOTO    4348
....................             } // long file name while loop 
....................         } // deleted dir 
....................     }// Ensure we are still good 
....................  
....................     return(dir); 
04378:  PUSH    FF4
0437A:  POP     0
0437C:  MOV     [--W15],W5
0437E:  RETURN  
.................... } // LoadDirAttrib 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     CETYPE FILEerase( FILEOBJ fo, WORD *fHandle, BYTE EraseClusters) 
....................   Summary: 
....................     Erase a file 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -            Pointer to file structure 
....................     fHandle -       Location of file information 
....................     EraseClusters - If set to TRUE, delete the corresponding cluster of file 
....................   Return Values: 
....................     CE_GOOD - File erased successfully 
....................     CE_FILE_NOT_FOUND - Could not find the file on the card 
....................     CE_ERASE_FAIL - Internal Card erase failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache the sector of directory entries in the directory 
....................     pointed to by the dirclus value in the FSFILE object 'fo' that contains 
....................     the entry that corresponds to the fHandle offset.  It will then mark that 
....................     entry as deleted.  If the EraseClusters argument is TRUE, the chain of 
....................     clusters for that file will be marked as unused in the FAT by the 
....................     FAT_erase_cluster_chain function. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... CETYPE FILEerase( FILEOBJ fo, WORD *fHandle, BYTE EraseClusters) 
*
03BA8:  MOV     W5,[W15++]
03BAA:  MOV     W6,[W15++]
*
03BB0:  CLR.B   FF8
03BB2:  CLR     FFA
03BB4:  CLR     FFC
*
03BBA:  BSET.B  1000.0
.................... { 
....................     DIRENTRY    dir; 
*
03BAC:  CLR     FF6
....................     BYTE        a; 
03BAE:  CLR.B   FF5
....................     CETYPE      status = CE_GOOD; 
....................     DWORD       clus = 0; 
....................     DISK *      disk; 
*
03BB6:  CLR     FFE
....................  
....................     BYTE   numberOfFileEntries; 
03BB8:  CLR.B   FF9
....................    BOOL   forFirstTime = TRUE; 
....................    #if defined(SUPPORT_LFN) 
....................       BYTE   tempCalc1; 
....................    #endif 
....................  
....................     disk = fo->dsk; 
*
03BBC:  MOV     FF0,W4
03BBE:  ADD     W4,#0,W4
03BC0:  MOV     W4,W0
03BC2:  MOV     [W0],[W15++]
03BC4:  POP     FFE
....................  
....................    #if defined(SUPPORT_LFN) 
....................  
....................    fileNameLength = fo->utf16LFNlength; 
....................  
....................    // Find the number of entries of LFN in the root directory 
....................    if(fileNameLength) 
....................    { 
....................       tempCalc1 = fileNameLength % 13; 
....................  
....................       numberOfFileEntries = fileNameLength/13; 
....................  
....................       if(tempCalc1 || (fileNameLength < 13)) 
....................       { 
....................          numberOfFileEntries = numberOfFileEntries + 2; 
....................       } 
....................       else 
....................       { 
....................          numberOfFileEntries++; 
....................       } 
....................    } 
....................    else 
....................    #endif 
....................    { 
....................       numberOfFileEntries = 1; 
03BC6:  MOV.B   #1,W0L
03BC8:  MOV.B   W0L,FF9
....................    } 
....................  
....................    FSerrno = CE_ERASE_FAIL; 
03BCA:  MOV.B   #1,W0L
03BCC:  MOV.B   W0L,857
....................  
....................    // delete all the entries of LFN in root directory 
....................    while(numberOfFileEntries--) 
03BCE:  MOV.B   FF9,W0L
03BD0:  DEC.B   0FF9
03BD2:  CP0.B   W0L
03BD4:  BRA     Z,3C6A
....................    { 
....................        // reset the cluster 
....................        fo->dirccls = fo->dirclus; 
03BD6:  MOV     #32,W0
03BD8:  ADD     FF0,W0
03BDA:  MOV     W0,W5
03BDC:  MOV     #2E,W0
03BDE:  ADD     FF0,W0
03BE0:  MOV     [W0++],[W5++]
03BE2:  MOV     [W0++],[W5++]
....................  
....................        // load the sector 
....................        dir = Cache_File_Entry(fo, fHandle, TRUE); 
03BE4:  MOV.B   #1,W0L
03BE6:  MOV.B   W0L,102C
03BE8:  PUSH    FF0
03BEA:  POP     1028
03BEC:  PUSH    FF2
03BEE:  POP     102A
03BF0:  CALL    31E4
03BF4:  MOV     W0,FF6
....................  
....................        if (dir == NULL) 
03BF6:  CP0     FF6
03BF8:  BRA     NZ,3C00
....................        { 
....................            return CE_BADCACHEREAD; 
03BFA:  MOV.B   #1B,W0L
03BFC:  MOV.B   W0L,0
03BFE:  BRA     3CA8
....................        } 
....................  
....................        // Fill up the File Object with the information pointed to by fHandle 
....................        a = dir->DIR_Name[0]; 
03C00:  MOV     #0,W0
03C02:  ADD     FF6,W0
03C04:  MOV     W0,[W15++]
03C06:  MOV.B   [W0],W0L
03C08:  MOV.B   W0L,FF5
03C0A:  MOV     [--W15],W0
....................  
....................        // see if there is something in the dir 
....................        if((dir == (DIRENTRY)NULL) || (a == DIR_EMPTY) || (a == DIR_DEL)) 
03C0C:  CP0     FF6
03C0E:  BRA     Z,3C1C
03C10:  CP0.B   FF5
03C12:  BRA     Z,3C1C
03C14:  MOV     FF4,W4
03C16:  LSR     W4,#8,W4
03C18:  XOR.B   #E5,W4L
03C1A:  BRA     NZ,3C28
....................        { 
....................            status = CE_FILE_NOT_FOUND; 
03C1C:  MOV.B   #B,W0L
03C1E:  MOV.B   W0L,FF8
....................          break; 
03C20:  GOTO    3C6A
....................        } 
03C24:  GOTO    3C4A
....................       else 
....................       { 
....................             /* 8.3 File Name - entry*/ 
....................             dir->DIR_Name[0] = DIR_DEL; // mark as deleted 
03C28:  MOV     #0,W0
03C2A:  ADD     FF6,W0
03C2C:  MOV     W0,W5
03C2E:  MOV.B   #E5,W0L
03C30:  MOV.B   W0L,[W5]
....................  
....................          if(!(Write_File_Entry( fo, fHandle))) 
03C32:  PUSH    FF0
03C34:  POP     1006
03C36:  PUSH    FF2
03C38:  POP     1008
03C3A:  CALL    3964
03C3E:  CP0.B   W0L
03C40:  BRA     NZ,3C4A
....................            { 
....................                status = CE_ERASE_FAIL; 
03C42:  MOV.B   #1,W0L
03C44:  MOV.B   W0L,FF8
....................             break; 
03C46:  GOTO    3C6A
....................            } 
....................       } 
....................  
....................       if(forFirstTime) 
03C4A:  BTSS.B  1000.0
03C4C:  BRA     3C5C
....................       { 
....................          // Get the starting cluster 
....................          clus = GetFullClusterNumber(dir); // Get Complete Cluster number. 
03C4E:  PUSH    FF6
03C50:  POP     102A
03C52:  CALL    34B4
03C56:  MOV     W0,FFA
03C58:  MOV     W1,FFC
....................          forFirstTime = FALSE; 
03C5A:  BCLR.B  1000.0
....................       } 
....................  
....................       *fHandle = *fHandle - 1; 
03C5C:  MOV     FF2,W5
03C5E:  MOV     FF2,W0
03C60:  MOV     [W0],W6
03C62:  SUB     W6,#1,W0
03C64:  MOV     W0,[W5]
03C66:  GOTO    3BCE
....................    } 
....................  
....................    if(status == CE_GOOD) 
03C6A:  CP0.B   FF8
03C6C:  BRA     NZ,3CA4
....................    { 
....................       if (clus != FatRootDirClusterValue) // 
03C6E:  MOV     FFA,W0
03C70:  CP      858
03C72:  BRA     NZ,3C7A
03C74:  MOV     FFC,W0
03C76:  CP      85A
03C78:  BRA     Z,3CA0
....................       { 
....................          // If 'EraseClusters' is set to TRUE, erase the cluster chain corresponding to file 
....................           if(EraseClusters) 
03C7A:  CP0.B   FF4
03C7C:  BRA     Z,3CA0
....................           { 
....................               /* Now remove the cluster allocation from the FAT */ 
....................               status = ((FAT_erase_cluster_chain(clus, disk)) ? CE_GOOD : CE_ERASE_FAIL); 
03C7E:  PUSH    FFA
03C80:  POP     1006
03C82:  PUSH    FFC
03C84:  POP     1008
03C86:  PUSH    FFE
03C88:  POP     100A
03C8A:  CALL    3A80
03C8E:  CP0.B   W0L
03C90:  BRA     Z,3C9A
03C92:  MOV     #0,W0
03C94:  MOV     #0,W1
03C96:  GOTO    3C9E
03C9A:  MOV     #1,W0
03C9C:  MOV     #0,W1
03C9E:  MOV.B   W0L,FF8
....................           } 
....................       } 
....................  
....................       FSerrno = status; 
03CA0:  MOV.B   FF8,W0L
03CA2:  MOV.B   W0L,857
....................    } 
....................  
....................     return (status); 
03CA4:  MOV.B   FF8,W0L
03CA6:  MOV.B   W0L,0
03CA8:  MOV     [--W15],W6
03CAA:  MOV     [--W15],W5
03CAC:  RETURN  
.................... } 
.................... #endif 
....................  
.................... /*************************************************************** 
....................   Function: 
....................     int FSrename (const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices. 
....................     First, it will search through the current working directory to ensure the 
....................     specified new filename is not already in use. If it isn't, the new filename 
....................     will be written to the file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None 
....................   ***************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... int FSrename (const char * fileName, FSFILE * fo) 
.................... { 
....................     WORD fHandle; 
....................    FSFILE   tempFo1,tempFo2; 
....................     DIRENTRY dir; 
....................     #ifdef SUPPORT_LFN 
....................     DWORD  TempMsbCluster; 
....................     #else 
....................     BYTE j; 
....................     #endif 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................     if (MDD_WriteProtectState()) 
....................     { 
....................         FSerrno = CE_WRITE_PROTECTED; 
....................         return (-1); 
....................     } 
....................  
....................      // copy file object over 
....................     FileObjectCopy(&tempFo1, fo); 
....................  
....................     //Format the source string 
....................     if(!FormatFileName(fileName, &tempFo1, 0) ) 
....................     { 
....................         FSerrno = CE_INVALID_FILENAME; 
....................         return -1; 
....................     } 
....................  
....................    tempFo1.entry  = 0; 
....................  
....................    // start at the current directory 
....................    tempFo1.dirclus  = cwdptr->dirclus; 
....................    tempFo1.dirccls  = cwdptr->dirccls; 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&tempFo2, &tempFo1); 
....................  
....................     // See if the file is found 
....................     if(FILEfind (&tempFo2, &tempFo1, LOOK_FOR_MATCHING_ENTRY, 0) == CE_FILE_NOT_FOUND) 
....................    { 
....................       fHandle = fo->entry; 
....................  
....................       #ifdef SUPPORT_LFN 
....................  
....................       if(CE_GOOD != FILEerase(fo, &fHandle, FALSE)) 
....................       { 
....................          FSerrno = CE_ERASE_FAIL; 
....................          return -1; 
....................       } 
....................  
....................          // Create the new entry as per the user requested name 
....................          FSerrno = CreateFileEntry (&tempFo1, &fHandle, tempFo1.attributes, FALSE); 
....................  
....................          // load the file entry so the new cluster can be linked to it 
....................          dir = LoadDirAttrib(&tempFo1, &fHandle); 
....................  
....................          // Now update the new cluster 
....................          dir->DIR_FstClusLO = (fo->cluster & 0x0000FFFF); 
....................  
....................          #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................          // Get the higher part of cluster and store it in directory entry. 
....................          TempMsbCluster = (fo->cluster & 0x0FFF0000);    // Since only 28 bits usedin FAT32. Mask the higher MSB nibble. 
....................          TempMsbCluster = TempMsbCluster >> 16;      // Get the date into Lsb place. 
....................          dir->DIR_FstClusHI = TempMsbCluster; 
....................          #else // If FAT32 support not enabled 
....................          TempMsbCluster = 0;                         // Just to avoid compiler warnigng. 
....................          dir->DIR_FstClusHI = 0; 
....................          #endif 
....................  
....................       // Update the file size 
....................         dir->DIR_FileSize = fo->size; 
....................  
....................          // now write it 
....................          if(Write_File_Entry(&tempFo1, &fHandle) != TRUE) 
....................       { 
....................           FSerrno = CE_WRITE_ERROR; 
....................           return -1; 
....................       } 
....................  
....................          tempFo1.size = fo->size; 
....................  
....................       // copy file object over 
....................       FileObjectCopy(fo, &tempFo1); 
....................  
....................       #else 
....................  
....................         // Get the file entry 
....................         dir = LoadDirAttrib(fo, &fHandle); 
....................  
....................         for (j = 0; j < 11; j++) 
....................         { 
....................             fo->name[j] = tempFo1.name[j]; 
....................             dir->DIR_Name[j] = tempFo1.name[j]; 
....................         } 
....................  
....................         // just write the last entry in 
....................         if(!Write_File_Entry(fo,&fHandle)) 
....................         { 
....................             FSerrno = CE_WRITE_ERROR; 
....................             return -1; 
....................         } 
....................  
....................       #endif 
....................    } 
....................    else 
....................    { 
....................         FSerrno = CE_FILENAME_EXISTS; 
....................         return -1; 
....................    } 
....................  
....................     return 0; 
.................... } 
....................  
.................... /*************************************************************** 
....................   Function: 
....................     int wFSrename (const rom unsigned short int * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices. First, it will search through the current 
....................     working directory to ensure the specified new UTF16 filename is not 
....................     already in use.  If it isn't, the new filename will be written to the 
....................     file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None 
....................   ***************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSrename (const unsigned short int * fileName, FSFILE * fo) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................    result = FSrename ((const char *)fileName,fo); 
....................    utfModeFileName = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... #endif // Allow writes 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * wFSfopen (const unsigned short int * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... FSFILE * wFSfopen( const unsigned short int * fileName, const char *mode ) 
.................... { 
....................    FSFILE *result; 
....................    utfModeFileName = TRUE; 
....................    result = FSfopen((const char *)fileName,mode); 
....................    utfModeFileName = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * FSfopen (const char * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with ascii input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will open a ascii name file or directory on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * FSfopen( const char * fileName, const char *mode ) 
*
04A26:  MOV     W5,[W15++]
04A28:  MOV     W6,[W15++]
04A2A:  MOV     W7,[W15++]
.................... { 
....................     FILEOBJ    filePtr; 
04A2C:  CLR     FC6
.................... #ifndef FS_DYNAMIC_MEM 
....................     int      fIndex; 
04A2E:  CLR     FC8
.................... #endif 
....................     BYTE   ModeC; 
04A30:  CLR.B   FCA
....................     WORD    fHandle; 
04A32:  CLR     FCC
....................     CETYPE   final; 
04A34:  CLR.B   FCB
....................  
....................     //Read the mode character 
....................     ModeC = mode[0]; 
04A36:  MOV     #0,W0
04A38:  ADD     FC4,W0
04A3A:  MOV     FCA,W4
04A3C:  MOV.B   [W0+#0],W4L
04A3E:  MOV     W4,FCA
....................  
....................     if(MDD_WriteProtectState() && (ModeC != 'r') && (ModeC != 'R')) 
04A40:  CALL    25A0
04A44:  CP0.B   W0L
04A46:  BRA     Z,4A5C
04A48:  MOV     FCA,W4
04A4A:  XOR.B   #72,W4L
04A4C:  BRA     Z,4A5C
04A4E:  MOV     FCA,W4
04A50:  XOR.B   #52,W4L
04A52:  BRA     Z,4A5C
....................     { 
....................         FSerrno = CE_WRITE_PROTECTED; 
04A54:  MOV.B   #18,W0L
04A56:  MOV.B   W0L,857
....................         return NULL; 
04A58:  CLR     0
04A5A:  BRA     4E34
....................     } 
....................  
.................... #ifdef FS_DYNAMIC_MEM 
....................     filePtr = (FILEOBJ) FS_malloc(sizeof(FSFILE)); 
.................... #else 
....................  
....................     filePtr = NULL; 
04A5C:  CLR     FC6
....................  
....................     //Pick available file structure 
....................     for( fIndex = 0; fIndex < FS_MAX_FILES_OPEN; fIndex++ ) 
04A5E:  CLR     FC8
04A60:  MOV     FC8,W4
04A62:  CP      W4,#1
04A64:  BRA     GE,4A8E
....................     { 
....................         if( gFileSlotOpen[fIndex] )   //this slot is available 
04A66:  MOV     #801,W4
04A68:  MOV     FC8,W3
04A6A:  ADD     W3,W4,W0
04A6C:  CP0.B   [W0]
04A6E:  BRA     Z,4A88
....................         { 
....................             gFileSlotOpen[fIndex] = FALSE; 
04A70:  MOV     #801,W4
04A72:  MOV     FC8,W3
04A74:  ADD     W3,W4,W5
04A76:  CLR.B   [W5]
....................             filePtr = &gFileArray[fIndex]; 
04A78:  MOV     FC8,W4
04A7A:  MOV     #36,W3
04A7C:  MUL.SS  W4,W3,W0
04A7E:  MOV     #808,W4
04A80:  ADD     W0,W4,W0
04A82:  MOV     W0,FC6
....................          break; 
04A84:  GOTO    4A8E
....................         } 
04A88:  INC     0FC8
04A8A:  GOTO    4A60
....................     } 
....................  
....................     if( filePtr == NULL ) 
04A8E:  CP0     FC6
04A90:  BRA     NZ,4A9A
....................     { 
....................         FSerrno = CE_TOO_MANY_FILES_OPEN; 
04A92:  MOV.B   #20,W0L
04A94:  MOV.B   W0L,857
....................         return NULL;      //no file structure slot available 
04A96:  CLR     0
04A98:  BRA     4E34
....................     } 
.................... #endif 
....................  
....................    #if defined(SUPPORT_LFN) 
....................       #if defined(FS_DYNAMIC_MEM) 
....................          filePtr -> utf16LFNptr = (unsigned short int *)FS_malloc(514); 
....................       #else 
....................          filePtr->utf16LFNptr = &lfnData[fIndex][0]; 
....................       #endif 
....................     #endif 
....................  
....................     //Format the source string. 
....................     if( !FormatFileName(fileName, filePtr, 0) ) 
04A9A:  CLR.B   1004
04A9C:  PUSH    FC2
04A9E:  POP     1000
04AA0:  PUSH    FC6
04AA2:  POP     1002
04AA4:  CALL    26EC
04AA8:  CP0.B   W0L
04AAA:  BRA     NZ,4ABE
....................     { 
....................       #ifdef FS_DYNAMIC_MEM 
....................          #if defined(SUPPORT_LFN) 
....................             FS_free((unsigned char *)filePtr->utf16LFNptr); 
....................          #endif 
....................            FS_free( (unsigned char *)filePtr ); 
....................       #else 
....................            gFileSlotOpen[fIndex] = TRUE;   //put this slot back to the pool 
04AAC:  MOV     #801,W4
04AAE:  MOV     FC8,W3
04AB0:  ADD     W3,W4,W5
04AB2:  MOV.B   #1,W0L
04AB4:  MOV.B   W0L,[W5]
....................       #endif 
....................  
....................       FSerrno = CE_INVALID_FILENAME; 
04AB6:  MOV.B   #12,W0L
04AB8:  MOV.B   W0L,857
....................         return NULL;   //bad filename 
04ABA:  CLR     0
04ABC:  BRA     4E34
....................     } 
....................  
....................     filePtr->dsk = &gDiskData; 
04ABE:  MOV     FC6,W4
04AC0:  ADD     W4,#0,W4
04AC2:  MOV     W4,W0
04AC4:  MOV     W0,W5
04AC6:  MOV.B   #8,W0L
04AC8:  MOV.B   W0L,[W5]
04ACA:  MOV.B   #D,W0L
04ACC:  MOV.B   W0L,[W5+#1]
....................     filePtr->cluster = 0; 
04ACE:  MOV     #2,W0
04AD0:  ADD     FC6,W0
04AD2:  MOV     W0,W5
04AD4:  CLR.B   [W5]
04AD6:  MOV.B   #0,W0L
04AD8:  MOV.B   W0L,[W5+#1]
04ADA:  MOV.B   #0,W0L
04ADC:  MOV.B   W0L,[W5+#2]
04ADE:  MOV.B   #0,W0L
04AE0:  MOV.B   W0L,[W5+#3]
....................     filePtr->ccls    = 0; 
04AE2:  MOV     #6,W0
04AE4:  ADD     FC6,W0
04AE6:  MOV     W0,W5
04AE8:  CLR.B   [W5]
04AEA:  MOV.B   #0,W0L
04AEC:  MOV.B   W0L,[W5+#1]
04AEE:  MOV.B   #0,W0L
04AF0:  MOV.B   W0L,[W5+#2]
04AF2:  MOV.B   #0,W0L
04AF4:  MOV.B   W0L,[W5+#3]
....................     filePtr->entry = 0; 
04AF6:  MOV     #28,W0
04AF8:  ADD     FC6,W0
04AFA:  MOV     W0,W5
04AFC:  CLR.B   [W5]
04AFE:  MOV.B   #0,W0L
04B00:  MOV.B   W0L,[W5+#1]
....................     filePtr->attributes = ATTR_ARCHIVE; 
04B02:  MOV     #2C,W0
04B04:  ADD     FC6,W0
04B06:  MOV     W0,W5
04B08:  MOV.B   #20,W0L
04B0A:  MOV.B   W0L,[W5]
04B0C:  MOV.B   #0,W0L
04B0E:  MOV.B   W0L,[W5+#1]
....................  
....................     // start at the current directory 
.................... #ifdef ALLOW_DIRS 
....................     filePtr->dirclus    = cwdptr->dirclus; 
04B10:  MOV     #2E,W0
04B12:  ADD     FC6,W0
04B14:  MOV     W0,W5
04B16:  MOV     #2E,W0
04B18:  ADD     904,W0
04B1A:  MOV     [W0++],[W5++]
04B1C:  MOV     [W0++],[W5++]
....................     filePtr->dirccls    = cwdptr->dirccls; 
04B1E:  MOV     #32,W0
04B20:  ADD     FC6,W0
04B22:  MOV     W0,W5
04B24:  MOV     #32,W0
04B26:  ADD     904,W0
04B28:  MOV     [W0++],[W5++]
04B2A:  MOV     [W0++],[W5++]
.................... #else 
....................     filePtr->dirclus = FatRootDirClusterValue; 
....................     filePtr->dirccls = FatRootDirClusterValue; 
.................... #endif 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&gFileTemp, filePtr); 
04B2C:  MOV     #898,W4
04B2E:  MOV     W4,1002
04B30:  PUSH    FC6
04B32:  POP     1004
04B34:  CALL    28E2
....................  
....................     // See if the file is found 
....................     if(FILEfind (filePtr, &gFileTemp, LOOK_FOR_MATCHING_ENTRY, 0) == CE_GOOD) 
04B38:  MOV.B   #1,W0L
04B3A:  MOV.B   W0L,1006
04B3C:  CLR.B   1007
04B3E:  PUSH    FC6
04B40:  POP     1002
04B42:  MOV     #898,W4
04B44:  MOV     W4,1004
04B46:  CALL    36BE
04B4A:  CP0.B   W0L
04B4C:  BRA     NZ,4D66
....................     { 
....................         // File is Found 
....................         switch(ModeC) 
04B4E:  MOV.B   FCA,W0L
04B50:  CLR.B   1
04B52:  XOR     #77,W0
04B54:  BRA     Z,4B6C
04B56:  XOR     #20,W0
04B58:  BRA     Z,4B6C
04B5A:  XOR     #16,W0
04B5C:  BRA     Z,4BF6
04B5E:  XOR     #20,W0
04B60:  BRA     Z,4BF6
04B62:  XOR     #33,W0
04B64:  BRA     Z,4D18
04B66:  XOR     #20,W0
04B68:  BRA     Z,4D18
04B6A:  BRA     4D56
....................         { 
.................... #ifdef ALLOW_WRITES 
....................             case 'w': 
....................             case 'W': 
....................             { 
....................                 // File exists, we want to create a new one, remove it first 
....................                 fHandle = filePtr->entry; 
04B6C:  MOV     #28,W0
04B6E:  ADD     FC6,W0
04B70:  MOV     [W0],[W15++]
04B72:  POP     FCC
....................                 final = FILEerase(filePtr, &fHandle, TRUE); 
04B74:  MOV.B   #1,W0L
04B76:  MOV.B   W0L,FF4
04B78:  PUSH    FC6
04B7A:  POP     FF0
04B7C:  MOV     #FCC,W4
04B7E:  MOV     W4,FF2
04B80:  CALL    3BA8
04B84:  MOV.B   W0L,FCB
....................  
....................                 if (final == CE_GOOD) 
04B86:  CP0.B   FCB
04B88:  BRA     NZ,4BF2
....................                 { 
....................                     // now create a new one 
....................                     final = CreateFileEntry (filePtr, &fHandle, 0, TRUE); 
04B8A:  CLR.B   FD6
04B8C:  MOV.B   #1,W0L
04B8E:  MOV.B   W0L,FD7
04B90:  PUSH    FC6
04B92:  POP     FD2
04B94:  MOV     #FCC,W4
04B96:  MOV     W4,FD4
04B98:  CALL    43FA
04B9C:  MOV.B   W0L,FCB
....................  
....................                     if (final == CE_GOOD) 
04B9E:  CP0.B   FCB
04BA0:  BRA     NZ,4BF2
....................                     { 
....................                         final = FILEopen (filePtr, &fHandle, 'w'); 
04BA2:  MOV.B   #77,W0L
04BA4:  MOV.B   W0L,1004
04BA6:  PUSH    FC6
04BA8:  POP     1000
04BAA:  MOV     #FCC,W4
04BAC:  MOV     W4,1002
04BAE:  CALL    4454
04BB2:  MOV.B   W0L,FCB
....................  
....................                         if (filePtr->attributes & ATTR_DIRECTORY) 
04BB4:  MOV     #2C,W0
04BB6:  ADD     FC6,W0
04BB8:  MOV     [W0],W5
04BBA:  AND     W5,#10,W0
04BBC:  CP0     W0
04BBE:  BRA     Z,4BC8
....................                         { 
....................                             FSerrno = CE_INVALID_ARGUMENT; 
04BC0:  MOV.B   #1F,W0L
04BC2:  MOV.B   W0L,857
....................                             final = 0xFF; 
04BC4:  MOV.B   #FF,W0L
04BC6:  MOV.B   W0L,FCB
....................                         } 
....................  
....................                         if (final == CE_GOOD) 
04BC8:  CP0.B   FCB
04BCA:  BRA     NZ,4BF2
....................                         { 
....................                             final = FSfseek (filePtr, 0, SEEK_END); 
04BCC:  PUSH    FC6
04BCE:  POP     FD2
04BD0:  CLR     FD4
04BD2:  CLR     FD6
04BD4:  MOV     #2,W4
04BD6:  MOV     W4,FD8
04BD8:  CALL    4760
04BDC:  MOV.B   W0L,FCB
....................                             if (mode[1] == '+') 
04BDE:  MOV     #1,W0
04BE0:  ADD     FC4,W0
04BE2:  MOV.B   [W0],W4L
04BE4:  XOR.B   #2B,W4L
04BE6:  BRA     NZ,4BF2
....................                                 filePtr->flags.read = 1; 
04BE8:  MOV     #16,W0
04BEA:  ADD     FC6,W0
04BEC:  MOV     W0,W5
04BEE:  MOV     #2,W4
04BF0:  IOR.B    W4L,  [W5],[W5]
....................                         } 
....................                     } 
....................                 } 
....................                 break; 
04BF2:  GOTO    4D62
....................             } 
....................  
....................             case 'A': 
....................             case 'a': 
....................             { 
....................                 if(filePtr->size != 0) 
04BF6:  MOV     #12,W0
04BF8:  ADD     FC6,W0
04BFA:  MOV     #A,W4
04BFC:  MOV     [W0++],[W4++]
04BFE:  MOV     [W0++],[W4++]
04C00:  CP0     W5
04C02:  BRA     NZ,4C08
04C04:  CP0     W6
04C06:  BRA     Z,4C86
....................                 { 
....................                     fHandle = filePtr->entry; 
04C08:  MOV     #28,W0
04C0A:  ADD     FC6,W0
04C0C:  MOV     [W0],[W15++]
04C0E:  POP     FCC
....................  
....................                     final = FILEopen (filePtr, &fHandle, 'w'); 
04C10:  MOV.B   #77,W0L
04C12:  MOV.B   W0L,1004
04C14:  PUSH    FC6
04C16:  POP     1000
04C18:  MOV     #FCC,W4
04C1A:  MOV     W4,1002
04C1C:  CALL    4454
04C20:  MOV.B   W0L,FCB
....................  
....................                     if (filePtr->attributes & ATTR_DIRECTORY) 
04C22:  MOV     #2C,W0
04C24:  ADD     FC6,W0
04C26:  MOV     [W0],W5
04C28:  AND     W5,#10,W0
04C2A:  CP0     W0
04C2C:  BRA     Z,4C36
....................                     { 
....................                         FSerrno = CE_INVALID_ARGUMENT; 
04C2E:  MOV.B   #1F,W0L
04C30:  MOV.B   W0L,857
....................                         final = 0xFF; 
04C32:  MOV.B   #FF,W0L
04C34:  MOV.B   W0L,FCB
....................                     } 
....................  
....................                     if (final == CE_GOOD) 
04C36:  CP0.B   FCB
04C38:  BRA     NZ,4C82
....................                     { 
....................                         final = FSfseek (filePtr, 0, SEEK_END); 
04C3A:  PUSH    FC6
04C3C:  POP     FD2
04C3E:  CLR     FD4
04C40:  CLR     FD6
04C42:  MOV     #2,W4
04C44:  MOV     W4,FD8
04C46:  CALL    4760
04C4A:  MOV.B   W0L,FCB
....................                         if (final != CE_GOOD) 
04C4C:  CP0.B   FCB
04C4E:  BRA     Z,4C58
....................                             FSerrno = CE_SEEK_ERROR; 
04C50:  MOV.B   #1A,W0L
04C52:  MOV.B   W0L,857
04C54:  GOTO    4C6E
....................                         else 
....................                             ReadFAT (&gDiskData, filePtr->ccls); 
04C58:  MOV     #D08,W5
04C5A:  MOV     #6,W0
04C5C:  ADD     FC6,W0
04C5E:  MOV     #C,W4
04C60:  MOV     [W0++],[W4++]
04C62:  MOV     [W0++],[W4++]
04C64:  MOV     W5,1048
04C66:  MOV     W6,104A
04C68:  MOV     W7,104C
04C6A:  CALL    2ECC
....................                         if (mode[1] == '+') 
04C6E:  MOV     #1,W0
04C70:  ADD     FC4,W0
04C72:  MOV.B   [W0],W4L
04C74:  XOR.B   #2B,W4L
04C76:  BRA     NZ,4C82
....................                             filePtr->flags.read = 1; 
04C78:  MOV     #16,W0
04C7A:  ADD     FC6,W0
04C7C:  MOV     W0,W5
04C7E:  MOV     #2,W4
04C80:  IOR.B    W4L,  [W5],[W5]
....................                     } 
....................                 } 
04C82:  GOTO    4D14
....................                 else 
....................                 { 
....................                     fHandle = filePtr->entry; 
04C86:  MOV     #28,W0
04C88:  ADD     FC6,W0
04C8A:  MOV     [W0],[W15++]
04C8C:  POP     FCC
....................                     final = FILEerase(filePtr, &fHandle, TRUE); 
04C8E:  MOV.B   #1,W0L
04C90:  MOV.B   W0L,FF4
04C92:  PUSH    FC6
04C94:  POP     FF0
04C96:  MOV     #FCC,W4
04C98:  MOV     W4,FF2
04C9A:  CALL    3BA8
04C9E:  MOV.B   W0L,FCB
....................  
....................                     if (final == CE_GOOD) 
04CA0:  CP0.B   FCB
04CA2:  BRA     NZ,4D14
....................                     { 
....................                         // now create a new one 
....................                         final = CreateFileEntry (filePtr, &fHandle, 0, TRUE); 
04CA4:  CLR.B   FD6
04CA6:  MOV.B   #1,W0L
04CA8:  MOV.B   W0L,FD7
04CAA:  PUSH    FC6
04CAC:  POP     FD2
04CAE:  MOV     #FCC,W4
04CB0:  MOV     W4,FD4
04CB2:  CALL    43FA
04CB6:  MOV.B   W0L,FCB
....................  
....................                         if (final == CE_GOOD) 
04CB8:  CP0.B   FCB
04CBA:  BRA     NZ,4D14
....................                         { 
....................                             final = FILEopen (filePtr, &fHandle, 'w'); 
04CBC:  MOV.B   #77,W0L
04CBE:  MOV.B   W0L,1004
04CC0:  PUSH    FC6
04CC2:  POP     1000
04CC4:  MOV     #FCC,W4
04CC6:  MOV     W4,1002
04CC8:  CALL    4454
04CCC:  MOV.B   W0L,FCB
....................  
....................                             if (filePtr->attributes & ATTR_DIRECTORY) 
04CCE:  MOV     #2C,W0
04CD0:  ADD     FC6,W0
04CD2:  MOV     [W0],W5
04CD4:  AND     W5,#10,W0
04CD6:  CP0     W0
04CD8:  BRA     Z,4CE2
....................                             { 
....................                                 FSerrno = CE_INVALID_ARGUMENT; 
04CDA:  MOV.B   #1F,W0L
04CDC:  MOV.B   W0L,857
....................                                 final = 0xFF; 
04CDE:  MOV.B   #FF,W0L
04CE0:  MOV.B   W0L,FCB
....................                             } 
....................  
....................                             if (final == CE_GOOD) 
04CE2:  CP0.B   FCB
04CE4:  BRA     NZ,4D14
....................                             { 
....................                                 final = FSfseek (filePtr, 0, SEEK_END); 
04CE6:  PUSH    FC6
04CE8:  POP     FD2
04CEA:  CLR     FD4
04CEC:  CLR     FD6
04CEE:  MOV     #2,W4
04CF0:  MOV     W4,FD8
04CF2:  CALL    4760
04CF6:  MOV.B   W0L,FCB
....................                                 if (final != CE_GOOD) 
04CF8:  CP0.B   FCB
04CFA:  BRA     Z,4D00
....................                                     FSerrno = CE_SEEK_ERROR; 
04CFC:  MOV.B   #1A,W0L
04CFE:  MOV.B   W0L,857
....................                                 if (mode[1] == '+') 
04D00:  MOV     #1,W0
04D02:  ADD     FC4,W0
04D04:  MOV.B   [W0],W4L
04D06:  XOR.B   #2B,W4L
04D08:  BRA     NZ,4D14
....................                                     filePtr->flags.read = 1; 
04D0A:  MOV     #16,W0
04D0C:  ADD     FC6,W0
04D0E:  MOV     W0,W5
04D10:  MOV     #2,W4
04D12:  IOR.B    W4L,  [W5],[W5]
....................                             } 
....................                         } 
....................                     } 
....................                 } 
....................                 break; 
04D14:  GOTO    4D62
....................             } 
.................... #endif 
....................             case 'R': 
....................             case 'r': 
....................             { 
....................                 fHandle = filePtr->entry; 
04D18:  MOV     #28,W0
04D1A:  ADD     FC6,W0
04D1C:  MOV     [W0],[W15++]
04D1E:  POP     FCC
....................  
....................                 final = FILEopen (filePtr, &fHandle, 'r'); 
04D20:  MOV.B   #72,W0L
04D22:  MOV.B   W0L,1004
04D24:  PUSH    FC6
04D26:  POP     1000
04D28:  MOV     #FCC,W4
04D2A:  MOV     W4,1002
04D2C:  CALL    4454
04D30:  MOV.B   W0L,FCB
.................... #ifdef ALLOW_WRITES 
....................                 if ((mode[1] == '+') && !(filePtr->attributes & ATTR_DIRECTORY)) 
04D32:  MOV     #1,W0
04D34:  ADD     FC4,W0
04D36:  MOV.B   [W0],W4L
04D38:  XOR.B   #2B,W4L
04D3A:  BRA     NZ,4D52
04D3C:  MOV     #2C,W0
04D3E:  ADD     FC6,W0
04D40:  MOV     [W0],W5
04D42:  AND     W5,#10,W0
04D44:  CP0     W0
04D46:  BRA     NZ,4D52
....................                     filePtr->flags.write = 1; 
04D48:  MOV     #16,W0
04D4A:  ADD     FC6,W0
04D4C:  MOV     W0,W5
04D4E:  MOV     #1,W4
04D50:  IOR.B    W4L,  [W5],[W5]
.................... #endif 
....................                 break; 
04D52:  GOTO    4D62
....................             } 
....................  
....................             default: 
....................                 FSerrno = CE_INVALID_ARGUMENT; 
04D56:  MOV.B   #1F,W0L
04D58:  MOV.B   W0L,857
....................                 final = 0xFF;;  //indicate error condition 
04D5A:  MOV.B   #FF,W0L
04D5C:  MOV.B   W0L,FCB
....................                 break; 
04D5E:  GOTO    4D62
....................         } 
....................     } 
04D62:  GOTO    4E08
....................     else 
....................     { 
.................... #ifdef ALLOW_WRITES 
....................         // the file was not found, reset to the default asked 
....................         FileObjectCopy(filePtr, &gFileTemp); 
04D66:  PUSH    FC6
04D68:  POP     1002
04D6A:  MOV     #898,W4
04D6C:  MOV     W4,1004
04D6E:  CALL    28E2
....................  
....................         // File is not Found 
....................         if((ModeC == 'w') || (ModeC == 'W') || (ModeC == 'a') || (ModeC == 'A')) 
04D72:  MOV     FCA,W4
04D74:  XOR.B   #77,W4L
04D76:  BRA     Z,4D8A
04D78:  MOV     FCA,W4
04D7A:  XOR.B   #57,W4L
04D7C:  BRA     Z,4D8A
04D7E:  MOV     FCA,W4
04D80:  XOR.B   #61,W4L
04D82:  BRA     Z,4D8A
04D84:  MOV     FCA,W4
04D86:  XOR.B   #41,W4L
04D88:  BRA     NZ,4E00
....................         { 
....................             // use the user requested name 
....................             fHandle = 0; 
04D8A:  CLR     FCC
....................             final = CreateFileEntry (filePtr, &fHandle, 0, TRUE); 
04D8C:  CLR.B   FD6
04D8E:  MOV.B   #1,W0L
04D90:  MOV.B   W0L,FD7
04D92:  PUSH    FC6
04D94:  POP     FD2
04D96:  MOV     #FCC,W4
04D98:  MOV     W4,FD4
04D9A:  CALL    43FA
04D9E:  MOV.B   W0L,FCB
....................  
....................             if (final == CE_GOOD) 
04DA0:  CP0.B   FCB
04DA2:  BRA     NZ,4DFC
....................             { 
....................                 final = FILEopen (filePtr, &fHandle, 'w'); 
04DA4:  MOV.B   #77,W0L
04DA6:  MOV.B   W0L,1004
04DA8:  PUSH    FC6
04DAA:  POP     1000
04DAC:  MOV     #FCC,W4
04DAE:  MOV     W4,1002
04DB0:  CALL    4454
04DB4:  MOV.B   W0L,FCB
....................                 if (filePtr->attributes & ATTR_DIRECTORY) 
04DB6:  MOV     #2C,W0
04DB8:  ADD     FC6,W0
04DBA:  MOV     [W0],W5
04DBC:  AND     W5,#10,W0
04DBE:  CP0     W0
04DC0:  BRA     Z,4DCA
....................                 { 
....................                     FSerrno = CE_INVALID_ARGUMENT; 
04DC2:  MOV.B   #1F,W0L
04DC4:  MOV.B   W0L,857
....................                     final = 0xFF; 
04DC6:  MOV.B   #FF,W0L
04DC8:  MOV.B   W0L,FCB
....................                 } 
....................  
....................                 if (final == CE_GOOD) 
04DCA:  CP0.B   FCB
04DCC:  BRA     NZ,4DFC
....................                 { 
....................                     final = FSfseek (filePtr, 0, SEEK_END); 
04DCE:  PUSH    FC6
04DD0:  POP     FD2
04DD2:  CLR     FD4
04DD4:  CLR     FD6
04DD6:  MOV     #2,W4
04DD8:  MOV     W4,FD8
04DDA:  CALL    4760
04DDE:  MOV.B   W0L,FCB
....................                     if (final != CE_GOOD) 
04DE0:  CP0.B   FCB
04DE2:  BRA     Z,4DE8
....................                         FSerrno = CE_SEEK_ERROR; 
04DE4:  MOV.B   #1A,W0L
04DE6:  MOV.B   W0L,857
....................                     if (mode[1] == '+') 
04DE8:  MOV     #1,W0
04DEA:  ADD     FC4,W0
04DEC:  MOV.B   [W0],W4L
04DEE:  XOR.B   #2B,W4L
04DF0:  BRA     NZ,4DFC
....................                         filePtr->flags.read = 1; 
04DF2:  MOV     #16,W0
04DF4:  ADD     FC6,W0
04DF6:  MOV     W0,W5
04DF8:  MOV     #2,W4
04DFA:  IOR.B    W4L,  [W5],[W5]
....................                 } 
....................             } 
....................         } 
04DFC:  GOTO    4E08
....................         else 
.................... #endif 
....................       { 
....................             final = CE_FILE_NOT_FOUND; 
04E00:  MOV.B   #B,W0L
04E02:  MOV.B   W0L,FCB
....................            FSerrno = CE_FILE_NOT_FOUND; 
04E04:  MOV.B   #B,W0L
04E06:  MOV.B   W0L,857
....................        } 
....................     } 
....................  
....................     if (MDD_WriteProtectState()) 
04E08:  CALL    25A0
04E0C:  CP0.B   W0L
04E0E:  BRA     Z,4E1A
....................     { 
....................         filePtr->flags.write = 0;; 
04E10:  MOV     #16,W0
04E12:  ADD     FC6,W0
04E14:  MOV     W0,W5
04E16:  MOV     #FE,W4
04E18:  AND.B   W4L,[W5],[W5]
....................     } 
....................  
.................... #ifdef FS_DYNAMIC_MEM 
....................     if( final != CE_GOOD ) 
....................     { 
....................         #ifdef   SUPPORT_LFN 
....................          FS_free((unsigned char *)filePtr->utf16LFNptr); 
....................       #endif 
....................       FS_free( (unsigned char *)filePtr ); 
....................         filePtr = NULL; 
....................     } 
.................... #else 
....................     if( final != CE_GOOD ) 
04E1A:  CP0.B   FCB
04E1C:  BRA     Z,4E2E
....................     { 
....................         gFileSlotOpen[fIndex] = TRUE;   //put this slot back to the pool 
04E1E:  MOV     #801,W4
04E20:  MOV     FC8,W3
04E22:  ADD     W3,W4,W5
04E24:  MOV.B   #1,W0L
04E26:  MOV.B   W0L,[W5]
....................         filePtr = NULL; 
04E28:  CLR     FC6
....................     } 
.................... #endif 
04E2A:  GOTO    4E30
....................     else 
....................     { 
....................         FSerrno = CE_GOOD; 
04E2E:  CLR.B   857
....................     } 
....................  
....................     return filePtr; 
04E30:  PUSH    FC6
04E32:  POP     0
04E34:  MOV     [--W15],W7
04E36:  MOV     [--W15],W6
04E38:  MOV     [--W15],W5
04E3A:  RETURN  
.................... } 
....................  
.................... /******************************************************************* 
....................   Function: 
....................     long FSftell (FSFILE * fo) 
....................   Summary: 
....................     Determine the current location in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return: Current location in the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     The FSftell function will return the current position in the 
....................     file pointed to by 'fo' by returning the 'seek' variable in the 
....................     FSFILE object, which is used to keep track of the absolute 
....................     location of the current position in the file. 
....................   Remarks: 
....................     None 
....................   *******************************************************************/ 
....................  
.................... long FSftell (FSFILE * fo) 
.................... { 
....................     FSerrno = CE_GOOD; 
....................     return (fo->seek); 
.................... } 
....................  
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     int FSremove (const char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed 
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................     The FSremove function will attempt to find the specified file with the FILEfind 
....................     function.  If the file is found, it will be erased using the FILEerase function. 
....................     The user can also provide ascii alias name of the ascii long file name as the 
....................     input to this function to get it erased from the memory. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int FSremove (const char * fileName) 
*
05CE6:  MOV     W5,[W15++]
05CE8:  MOV     #862,W4
05CEA:  MOV     W4,F78
.................... { 
....................     FILEOBJ fo = &tempCWDobj; 
....................  
....................    #ifdef SUPPORT_LFN 
....................       FSFILE cwdTemp; 
....................       char tempArray[514]; 
....................       LFN_ENTRY *lfno; 
....................       WORD prevHandle; 
....................       unsigned short int i = 0; 
....................    #endif 
....................     FSerrno = CE_GOOD; 
05CEC:  CLR.B   857
....................  
....................     if (MDD_WriteProtectState()) 
05CEE:  CALL    25A0
05CF2:  CP0.B   W0L
05CF4:  BRA     Z,5CFE
....................     { 
....................         FSerrno = CE_WRITE_PROTECTED; 
05CF6:  MOV.B   #18,W0L
05CF8:  MOV.B   W0L,857
....................         return (-1); 
05CFA:  SETM    0
05CFC:  BRA     5DEC
....................     } 
....................  
....................     //Format the source string 
....................    #if defined(SUPPORT_LFN) 
....................       fo->utf16LFNptr = (unsigned short int *)&tempArray[0]; 
....................    #endif 
....................  
....................     if( !FormatFileName(fileName, fo, 0) ) 
05CFE:  CLR.B   1004
05D00:  PUSH    F76
05D02:  POP     1000
05D04:  PUSH    F78
05D06:  POP     1002
05D08:  CALL    26EC
05D0C:  CP0.B   W0L
05D0E:  BRA     NZ,5D18
....................     { 
....................         FSerrno = CE_INVALID_FILENAME; 
05D10:  MOV.B   #12,W0L
05D12:  MOV.B   W0L,857
....................         return -1; 
05D14:  SETM    0
05D16:  BRA     5DEC
....................     } 
....................  
....................     fo->dsk = &gDiskData; 
05D18:  MOV     F78,W4
05D1A:  ADD     W4,#0,W4
05D1C:  MOV     W4,W0
05D1E:  MOV     W0,W5
05D20:  MOV.B   #8,W0L
05D22:  MOV.B   W0L,[W5]
05D24:  MOV.B   #D,W0L
05D26:  MOV.B   W0L,[W5+#1]
....................     fo->cluster = 0; 
05D28:  MOV     #2,W0
05D2A:  ADD     F78,W0
05D2C:  MOV     W0,W5
05D2E:  CLR.B   [W5]
05D30:  MOV.B   #0,W0L
05D32:  MOV.B   W0L,[W5+#1]
05D34:  MOV.B   #0,W0L
05D36:  MOV.B   W0L,[W5+#2]
05D38:  MOV.B   #0,W0L
05D3A:  MOV.B   W0L,[W5+#3]
....................     fo->ccls    = 0; 
05D3C:  MOV     #6,W0
05D3E:  ADD     F78,W0
05D40:  MOV     W0,W5
05D42:  CLR.B   [W5]
05D44:  MOV.B   #0,W0L
05D46:  MOV.B   W0L,[W5+#1]
05D48:  MOV.B   #0,W0L
05D4A:  MOV.B   W0L,[W5+#2]
05D4C:  MOV.B   #0,W0L
05D4E:  MOV.B   W0L,[W5+#3]
....................     fo->entry = 0; 
05D50:  MOV     #28,W0
05D52:  ADD     F78,W0
05D54:  MOV     W0,W5
05D56:  CLR.B   [W5]
05D58:  MOV.B   #0,W0L
05D5A:  MOV.B   W0L,[W5+#1]
....................     fo->attributes = ATTR_ARCHIVE; 
05D5C:  MOV     #2C,W0
05D5E:  ADD     F78,W0
05D60:  MOV     W0,W5
05D62:  MOV.B   #20,W0L
05D64:  MOV.B   W0L,[W5]
05D66:  MOV.B   #0,W0L
05D68:  MOV.B   W0L,[W5+#1]
....................  
.................... #ifndef ALLOW_DIRS 
....................     // start at the root directory 
....................     fo->dirclus    = FatRootDirClusterValue; 
....................     fo->dirccls    = FatRootDirClusterValue; 
.................... #else 
....................     fo->dirclus = cwdptr->dirclus; 
05D6A:  MOV     #2E,W0
05D6C:  ADD     F78,W0
05D6E:  MOV     W0,W5
05D70:  MOV     #2E,W0
05D72:  ADD     904,W0
05D74:  MOV     [W0++],[W5++]
05D76:  MOV     [W0++],[W5++]
....................     fo->dirccls = cwdptr->dirccls; 
05D78:  MOV     #32,W0
05D7A:  ADD     F78,W0
05D7C:  MOV     W0,W5
05D7E:  MOV     #32,W0
05D80:  ADD     904,W0
05D82:  MOV     [W0++],[W5++]
05D84:  MOV     [W0++],[W5++]
.................... #endif 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&gFileTemp, fo); 
05D86:  MOV     #898,W4
05D88:  MOV     W4,1002
05D8A:  PUSH    F78
05D8C:  POP     1004
05D8E:  CALL    28E2
....................  
....................     // See if the file is found 
....................     if (FILEfind (fo, &gFileTemp, LOOK_FOR_MATCHING_ENTRY, 0) != CE_GOOD) 
05D92:  MOV.B   #1,W0L
05D94:  MOV.B   W0L,1006
05D96:  CLR.B   1007
05D98:  PUSH    F78
05D9A:  POP     1002
05D9C:  MOV     #898,W4
05D9E:  MOV     W4,1004
05DA0:  CALL    36BE
05DA4:  CP0.B   W0L
05DA6:  BRA     Z,5DB0
....................     { 
....................         FSerrno = CE_FILE_NOT_FOUND; 
05DA8:  MOV.B   #B,W0L
05DAA:  MOV.B   W0L,857
....................         return -1; 
05DAC:  SETM    0
05DAE:  BRA     5DEC
....................     } 
....................  
....................     if (fo->attributes & ATTR_DIRECTORY) 
05DB0:  MOV     #2C,W0
05DB2:  ADD     F78,W0
05DB4:  MOV     [W0],W5
05DB6:  AND     W5,#10,W0
05DB8:  CP0     W0
05DBA:  BRA     Z,5DC4
....................     { 
....................         FSerrno = CE_DELETE_DIR; 
05DBC:  MOV.B   #13,W0L
05DBE:  MOV.B   W0L,857
....................         return -1; 
05DC0:  SETM    0
05DC2:  BRA     5DEC
....................     } 
....................  
....................    // Find the long file name assosciated with the short file name if present 
....................    #ifdef SUPPORT_LFN 
....................    if(!fo->utf16LFNlength) 
....................    { 
....................       FileObjectCopy (&cwdTemp, fo); 
....................       prevHandle = fo->entry - 1; 
....................  
....................       lfno = (LFN_ENTRY *)Cache_File_Entry (fo, &prevHandle, FALSE); 
....................  
....................  
....................          while((lfno->LFN_Attribute == ATTR_LONG_NAME) && (lfno->LFN_SequenceNo != DIR_DEL) 
....................  
....................                && (lfno->LFN_SequenceNo != DIR_EMPTY)) 
....................  
....................          { 
....................  
....................  
....................          i = i + MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................             prevHandle = prevHandle - 1; 
....................  
....................             lfno = (LFN_ENTRY *)Cache_File_Entry (fo, &prevHandle, FALSE); 
....................  
....................          } 
....................  
....................  
....................  
....................          FileObjectCopy (fo, &cwdTemp); 
....................  
....................       // Find the length of LFN file 
....................       fo->utf16LFNlength = i; 
....................  
....................    } 
....................    #endif 
....................  
....................    // Erase the file 
....................     if( FILEerase(fo, &fo->entry, TRUE) == CE_GOOD ) 
05DC4:  MOV     #28,W0
05DC6:  ADD     F78,W0
05DC8:  MOV     W0,W5
05DCA:  MOV.B   #1,W0L
05DCC:  MOV.B   W0L,FF4
05DCE:  PUSH    F78
05DD0:  POP     FF0
05DD2:  MOV     W5,FF2
05DD4:  CALL    3BA8
05DD8:  CP0.B   W0L
05DDA:  BRA     NZ,5DE4
....................         return 0; 
05DDC:  CLR     0
05DDE:  BRA     5DEC
05DE0:  GOTO    5DEC
....................     else 
....................     { 
....................         FSerrno = CE_ERASE_FAIL; 
05DE4:  MOV.B   #1,W0L
05DE6:  MOV.B   W0L,857
....................         return -1; 
05DE8:  SETM    0
05DEA:  BRA     5DEC
....................     } 
05DEC:  MOV     [--W15],W5
05DEE:  RETURN  
.................... } 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     int wFSremove (const unsigned short int * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed 
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................     The wFSremove function will attempt to find the specified UTF16 file 
....................     name with the FILEfind function. If the file is found, it will be erased 
....................     using the FILEerase function. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSremove (const unsigned short int * fileName) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................    result = FSremove ((const char *)fileName); 
....................    utfModeFileName = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /********************************************************* 
....................   Function: 
....................     void FSrewind (FSFILE * fo) 
....................   Summary: 
....................     Set the current position in a file to the beginning 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The FSrewind funciton will reset the position of the 
....................     specified file to the beginning of the file.  This 
....................     functionality is faster than using FSfseek to reset 
....................     the position in the file. 
....................   Remarks: 
....................     None. 
....................   *********************************************************/ 
....................  
.................... void FSrewind (FSFILE * fo) 
.................... { 
.................... #ifdef ALLOW_WRITES 
....................     if (gNeedDataWrite) 
....................         flushData(); 
.................... #endif 
....................     fo->seek = 0; 
....................     fo->pos = 0; 
....................     fo->sec = 0; 
....................     fo->ccls = fo->cluster; 
....................     gBufferOwner = NULL; 
....................     return; 
.................... } 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSerror (void) 
....................   Summary: 
....................     Return an error code for the last function call 
....................   Conditions: 
....................     The return value depends on the last function called. 
....................   Input: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Return Values: 
....................     FSInit       - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INIT_ERROR             The physical media could not be initialized 
....................                  - CE_BAD_SECTOR_READ        The MBR or the boot sector could not be 
....................                                               read correctly 
....................                  - CE_BAD_PARITION           The MBR signature code was incorrect. 
....................                  - CE_NOT_FORMATTED          The boot sector signature code was incorrect or 
....................                                               indicates an invalid number of bytes per sector. 
....................                  - CE_UNSUPPORTED_SECTOR_SIZE - The number of bytes per sector is unsupported 
....................                  - CE_CARDFAT32              The physical media is FAT32 type (only an error 
....................                                               when FAT32 support is disabled). 
....................                  - CE_UNSUPPORTED_FS         The device is formatted with an unsupported file 
....................                                               system (not FAT12 or 16). 
....................     FSfopen      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_NOT_INIT               The device has not been initialized. 
....................                  - CE_TOO_MANY_FILES_OPEN    The function could not allocate any 
....................                                               additional file information to the array 
....................                                               of FSFILE structures or the heap. 
....................                  - CE_INVALID_FILENAME       The file name argument was invalid. 
....................                  - CE_INVALID_ARGUMENT       The user attempted to open a directory in a 
....................                                               write mode or specified an invalid mode argument. 
....................                  - CE_FILE_NOT_FOUND         The specified file (which was to be opened in read 
....................                                               mode) does not exist on the device. 
....................                  - CE_BADCACHEREAD           A read from the device failed. 
....................                  - CE_ERASE_FAIL             The existing file could not be erased (when opening 
....................                                               a file in FS_WRITE mode). 
....................                  - CE_DIR_FULL               The directory is full. 
....................                  - CE_DISK_FULL              The data memory section is full. 
....................                  - CE_WRITE_ERROR            A write to the device failed. 
....................                  - CE_SEEK_ERROR             The current position in the file could not be set to 
....................                                               the end (when the file was opened in FS_APPEND mode). 
....................     FSfclose     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer or the new file 
....................                                               entry information could not be written to the device. 
....................                  - CE_BADCACHEREAD           The file entry information could not be cached 
....................     FSfread      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITEONLY              The file was opened in a write-only mode. 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device. 
....................                  - CE_BAD_SECTOR_READ        The data sector could not be read. 
....................                  - CE_EOF                    The end of the file was reached. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be loaded. 
....................     FSfwrite     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_READONLY               The file was opened in a read-only mode. 
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated 
....................                                               that the device has been write-protected. 
....................                  - CE_WRITE_ERROR            There was an error writing data to the device. 
....................                  - CE_BADCACHEREAD           The data sector to be modified could not be read from 
....................                                               the device. 
....................                  - CE_DISK_FULL              All data clusters on the device are in use. 
....................     FSfseek      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device. 
....................                  - CE_INVALID_ARGUMENT       The specified offset exceeds the size of the file. 
....................                  - CE_BADCACHEREAD           The sector that contains the new current position 
....................                                               could not be loaded. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be 
....................                                               loaded/allocated. 
....................     FSftell      - 
....................                  - CE_GOOD                   No Error 
....................     FSattrib     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INVALID_ARGUMENT       The attribute argument was invalid. 
....................                  - CE_BADCACHEREAD           The existing file entry information could not be 
....................                                               loaded. 
....................                  - CE_WRITE_ERROR            The file entry information could not be written to 
....................                                               the device. 
....................     FSrename     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_FILENOTOPENED          A null file pointer was passed into the function. 
....................                  - CE_INVALID_FILENAME       The file name passed into the function was invalid. 
....................                  - CE_BADCACHEREAD           A read from the device failed. 
....................                  - CE_FILENAME_EXISTS        A file with the specified name already exists. 
....................                  - CE_WRITE_ERROR            The new file entry data could not be written to the 
....................                                               device. 
....................     FSfeof       - 
....................                  - CE_GOOD                   No Error 
....................     FSformat     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INIT_ERROR             The device could not be initialized. 
....................                  - CE_BADCACHEREAD           The master boot record or boot sector could not be 
....................                                               loaded successfully. 
....................                  - CE_INVALID_ARGUMENT       The user selected to create their own boot sector on 
....................                                               a device that has no master boot record, or the mode 
....................                                               argument was invalid. 
....................                  - CE_WRITE_ERROR            The updated MBR/Boot sector could not be written to 
....................                                               the device. 
....................                  - CE_BAD_PARTITION          The calculated number of sectors per clusters was 
....................                                               invalid. 
....................                  - CE_NONSUPPORTED_SIZE      The card has too many sectors to be formatted as 
....................                                               FAT12 or FAT16. 
....................     FSremove     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated 
....................                                               that the device has been write-protected. 
....................                  - CE_INVALID_FILENAME       The specified filename was invalid. 
....................                  - CE_FILE_NOT_FOUND         The specified file could not be found. 
....................                  - CE_ERASE_FAIL             The file could not be erased. 
....................     FSchdir      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed or the user tried to 
....................                                               change to a non-directory file. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_FOUND          Could not find a directory in the path. 
....................     FSgetcwd     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INVALID_ARGUMENT       The user passed a 0-length buffer into the function. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory 
....................                                               of the current working directory. 
....................     FSmkdir      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated 
....................                                               that the device has been write-protected. 
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed. 
....................                  - CE_BADCACHEREAD           Could not successfully change to a recently created 
....................                                               directory to store its dir entry information, or 
....................                                               could not cache directory entry information. 
....................                  - CE_INVALID_FILENAME       One or more of the directory names has an invalid 
....................                                               format. 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device or the dot/dotdot entries could 
....................                                               not be written to a newly created directory. 
....................                  - CE_DIR_FULL               There are no available dir entries in the CWD. 
....................                  - CE_DISK_FULL              There are no available clusters in the data region of 
....................                                               the device. 
....................     FSrmdir      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_DIR_NOT_FOUND          The directory specified could not be found or the 
....................                                               function could not change to a subdirectory within 
....................                                               the directory to be deleted (when recursive delete is 
....................                                               enabled). 
....................                  - CE_INVALID_ARGUMENT       The user tried to remove the CWD or root directory. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_EMPTY          The directory to be deleted was not empty and 
....................                                               recursive subdirectory removal was disabled. 
....................                  - CE_ERASE_FAIL             The directory or one of the directories or files 
....................                                               within it could not be deleted. 
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory 
....................                                               of the CWD. 
....................     SetClockVars - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INVALID_ARGUMENT       The time values passed into the function were 
....................                                               invalid. 
....................     FindFirst    - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INVALID_FILENAME       The specified filename was invalid. 
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found. 
....................                  - CE_BADCACHEREAD           The file information for the file that was found 
....................                                               could not be cached. 
....................     FindNext     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_NOT_INIT               The SearchRec object was not initialized by a call to 
....................                                               FindFirst. 
....................                  - CE_INVALID_ARGUMENT       The SearchRec object was initialized in a different 
....................                                               directory from the CWD. 
....................                  - CE_INVALID_FILENAME       The filename is invalid. 
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found. 
....................     FSfprintf    - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITE_ERROR            Characters could not be written to the file. 
....................   Description: 
....................     The FSerror function will return the FSerrno variable.  This global 
....................     variable will have been set to an error value during the last call of a 
....................     library function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... int FSerror (void) 
.................... { 
....................     return FSerrno; 
.................... } 
....................  
....................  
.................... /************************************************************** 
....................   Function: 
....................     void FileObjectCopy(FILEOBJ foDest,FILEOBJ foSource) 
....................   Summary: 
....................     Copy a file object 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     foDest -    The destination 
....................     foSource -  the source 
....................   Return: 
....................     None 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The FileObjectCopy function will make an exacy copy of 
....................     a specified FSFILE object. 
....................   Remarks: 
....................     None 
....................   **************************************************************/ 
....................  
.................... void FileObjectCopy(FILEOBJ foDest,FILEOBJ foSource) 
*
028E2:  MOV     W5,[W15++]
.................... { 
....................     int size; 
028E4:  CLR     1006
....................     BYTE *dest; 
028E6:  CLR     1008
....................     BYTE *source; 
028E8:  CLR     100A
....................     int Index; 
028EA:  CLR     100C
....................  
....................     dest = (BYTE *)foDest; 
028EC:  PUSH    1002
028EE:  POP     1008
....................     source = (BYTE *)foSource; 
028F0:  PUSH    1004
028F2:  POP     100A
....................  
....................     size = sizeof(FSFILE); 
028F4:  MOV     #36,W4
028F6:  MOV     W4,1006
....................  
....................     for(Index=0;Index< size; Index++) 
028F8:  CLR     100C
028FA:  MOV     100C,W0
028FC:  MOV     1006,W4
028FE:  CP      W4,W0
02900:  BRA     LE,2914
....................     { 
....................         dest[Index] = source[Index]; 
02902:  MOV     100C,W0
02904:  ADD     1008,W0
02906:  MOV     W0,W5
02908:  MOV     100C,W0
0290A:  ADD     100A,W0
0290C:  MOV.B   [W0],[W5]
0290E:  INC     100C
02910:  GOTO    28FA
....................     } 
02914:  MOV     [--W15],W5
02916:  RETURN  
.................... } 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     CETYPE FILECreateHeadCluster( FILEOBJ fo, DWORD *cluster) 
....................   Summary: 
....................     Create the first cluster of a file 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................     cluster -  Cluster location 
....................   Return Values: 
....................     CE_GOOD - File closed successfully 
....................     CE_WRITE_ERROR - Could not write to the sector 
....................     CE_DISK_FULL - All clusters in partition are taken 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The FILECreateHeadCluster function will create the first cluster 
....................     of a file.  First, it will find an empty cluster with the 
....................     FATfindEmptyCluster function and mark it as the last cluster in the 
....................     file.  It will then erase the cluster using the EraseCluster function. 
....................   Remarks: 
....................     None. 
....................   *************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... CETYPE FILECreateHeadCluster( FILEOBJ fo, DWORD *cluster) 
*
0421E:  MOV     W5,[W15++]
04220:  MOV     W6,[W15++]
*
04224:  CLR.B   FF6
.................... { 
....................     DISK *      disk; 
*
04222:  CLR     FF4
....................     CETYPE        error = CE_GOOD; 
....................  
....................     disk = fo->dsk; 
*
04226:  MOV     FF0,W4
04228:  ADD     W4,#0,W4
0422A:  MOV     W4,W0
0422C:  MOV     [W0],[W15++]
0422E:  POP     FF4
....................  
....................     // find the next empty cluster 
....................     *cluster = FATfindEmptyCluster(fo); 
04230:  MOV     FF2,W5
04232:  PUSH    FF0
04234:  POP     1004
04236:  CALL    3CAE
0423A:  MOV     #0,W4
0423C:  MOV     [W4++],[W5++]
0423E:  MOV     [W4++],[W5++]
....................  
....................     if(*cluster == 0)  // "0" is just an indication as Disk full in the fn "FATfindEmptyCluster()" 
04240:  MOV     FF2,W0
04242:  MOV     #A,W4
04244:  MOV     [W0++],[W4++]
04246:  MOV     [W0++],[W4++]
04248:  CP0     W5
0424A:  BRA     NZ,4258
0424C:  CP0     W6
0424E:  BRA     NZ,4258
....................     { 
....................         error = CE_DISK_FULL; 
04250:  MOV.B   #15,W0L
04252:  MOV.B   W0L,FF6
....................     } 
04254:  GOTO    42E6
....................     else 
....................     { 
....................         // mark the cluster as taken, and last in chain 
....................        #ifdef SUPPORT_FAT12 
....................         if(disk->type == FAT12) 
....................         { 
....................             if(WriteFAT( disk, *cluster, LAST_CLUSTER_FAT12, FALSE) == CLUSTER_FAIL_FAT16) 
....................             { 
....................                 error = CE_WRITE_ERROR; 
....................             } 
....................         } 
....................         else 
....................        #endif 
....................         if(disk->type == FAT16) 
04258:  MOV     #22,W4
0425A:  MOV     FF4,W3
0425C:  ADD     W3,W4,W0
0425E:  MOV     #A,W1
04260:  MOV     W0,W2
04262:  MOV.B   [W2++],[W1++]
04264:  CP.B    W5L,#2
04266:  BRA     NZ,429A
....................         { 
....................             if(WriteFAT( disk, *cluster, LAST_CLUSTER_FAT16, FALSE) == CLUSTER_FAIL_FAT16) 
04268:  MOV     FF2,W0
0426A:  MOV     #A,W4
0426C:  MOV     [W0++],[W4++]
0426E:  MOV     [W0++],[W4++]
04270:  CLR.B   1078
04272:  PUSH    FF4
04274:  POP     106E
04276:  MOV     W5,1070
04278:  MOV     W6,1072
0427A:  MOV     #FFF8,W4
0427C:  MOV     W4,1074
0427E:  CLR     1076
04280:  CALL    2C18
04284:  MOV     W0,W5
04286:  MOV     W1,W6
04288:  MOV     #FFFF,W4
0428A:  CP      W4,W5
0428C:  BRA     NZ,4296
0428E:  CP0     W6
04290:  BRA     NZ,4296
....................             { 
....................                 error = CE_WRITE_ERROR; 
04292:  MOV.B   #9,W0L
04294:  MOV.B   W0L,FF6
....................             } 
....................         } 
....................  
....................  #ifdef SUPPORT_FAT32 // If FAT32 supported. 
04296:  GOTO    42CC
....................         else 
....................         { 
....................             if(WriteFAT( disk, *cluster, LAST_CLUSTER_FAT32, FALSE) == CLUSTER_FAIL_FAT32) 
0429A:  MOV     FF2,W0
0429C:  MOV     #A,W4
0429E:  MOV     [W0++],[W4++]
042A0:  MOV     [W0++],[W4++]
042A2:  CLR.B   1078
042A4:  PUSH    FF4
042A6:  POP     106E
042A8:  MOV     W5,1070
042AA:  MOV     W6,1072
042AC:  MOV     #FFF8,W4
042AE:  MOV     W4,1074
042B0:  MOV     #FFF,W4
042B2:  MOV     W4,1076
042B4:  CALL    2C18
042B8:  MOV     W0,W5
042BA:  MOV     W1,W6
042BC:  MOV     #FFFF,W4
042BE:  CP      W4,W5
042C0:  BRA     NZ,42CC
042C2:  MOV     #FFF,W4
042C4:  CP      W4,W6
042C6:  BRA     NZ,42CC
....................             { 
....................                 error = CE_WRITE_ERROR; 
042C8:  MOV.B   #9,W0L
042CA:  MOV.B   W0L,FF6
....................             } 
....................         } 
.................... #endif 
....................  
....................         // lets erase this cluster 
....................         if(error == CE_GOOD) 
042CC:  CP0.B   FF6
042CE:  BRA     NZ,42E6
....................         { 
....................             error = EraseCluster(disk,*cluster); 
042D0:  MOV     FF2,W0
042D2:  MOV     #A,W4
042D4:  MOV     [W0++],[W4++]
042D6:  MOV     [W0++],[W4++]
042D8:  PUSH    FF4
042DA:  POP     1004
042DC:  MOV     W5,1006
042DE:  MOV     W6,1008
042E0:  CALL    3DDC
042E4:  MOV.B   W0L,FF6
....................         } 
....................     } 
....................  
....................     return(error); 
042E6:  MOV.B   FF6,W0L
042E8:  MOV.B   W0L,0
042EA:  MOV     [--W15],W6
042EC:  MOV     [--W15],W5
042EE:  RETURN  
.................... } // allocate head cluster 
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE EraseCluster(DISK *disk, DWORD cluster) 
....................   Summary: 
....................     Erase a cluster 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -      Disk structure 
....................     cluster -  Cluster to be erased 
....................   Return Values: 
....................     CE_GOOD - File closed successfully 
....................     CE_WRITE_ERROR - Could not write to the sector 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The EraseCluster function will write a 0 value into every byte of 
....................     the specified cluster. 
....................   Remarks: 
....................     None. 
....................   *************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE EraseCluster(DISK *disk, DWORD cluster) 
*
03DDC:  MOV     W5,[W15++]
03DDE:  MOV     W6,[W15++]
03DE0:  MOV     W7,[W15++]
*
03DE8:  CLR.B   100B
.................... { 
....................     BYTE index; 
*
03DE2:  CLR.B   100A
....................     DWORD SectorAddress; 
03DE4:  CLR     100C
03DE6:  CLR     100E
....................     BYTE error = CE_GOOD; 
....................  
....................     SectorAddress = Cluster2Sector(disk,cluster); 
*
03DEA:  PUSH    1004
03DEC:  POP     1056
03DEE:  PUSH    1006
03DF0:  POP     1058
03DF2:  PUSH    1008
03DF4:  POP     105A
03DF6:  CALL    308C
03DFA:  MOV     W0,100C
03DFC:  MOV     W1,100E
....................     if (gNeedDataWrite) 
03DFE:  CP0.B   854
03E00:  BRA     Z,3E10
....................         if (flushData()) 
03E02:  CALL    3170
03E06:  CP0.B   W0L
03E08:  BRA     Z,3E10
....................             return CE_WRITE_ERROR; 
03E0A:  MOV.B   #9,W0L
03E0C:  MOV.B   W0L,0
03E0E:  BRA     3E94
....................  
....................     gBufferOwner = NULL; 
03E10:  CLR     84E
....................  
....................     if (gBufferZeroed == FALSE) 
03E12:  CP0.B   856
03E14:  BRA     NZ,3E44
....................     { 
....................         // clear out the memory first 
....................         memset(disk->buffer, 0x00, disk->sectorSize); 
03E16:  MOV     1004,W4
03E18:  ADD     W4,#0,W4
03E1A:  MOV     W4,W0
03E1C:  MOV     #A,W1
03E1E:  MOV     W0,W2
03E20:  REPEAT  #1
03E22:  MOV.B   [W2++],[W1++]
03E24:  MOV     1004,W4
03E26:  ADD     W4,#18,W4
03E28:  MOV     W4,W0
03E2A:  MOV     #C,W1
03E2C:  MOV     W0,W2
03E2E:  REPEAT  #3
03E30:  MOV.B   [W2++],[W1++]
03E32:  MOV     W5,W1
03E34:  MOV     #0,W2
03E36:  MOV     W6,W0
03E38:  DEC     W0,W0
03E3A:  BRA     N,3E3E
03E3C:  REPEAT  W0
03E3E:  CLR.B   [W1++]
....................         gBufferZeroed = TRUE; 
03E40:  MOV.B   #1,W0L
03E42:  MOV.B   W0L,856
....................     } 
....................  
....................     // Now clear them out 
....................     for(index = 0; (index < disk->SecPerClus) && (error == CE_GOOD); index++) 
03E44:  CLR.B   100A
03E46:  MOV     #21,W4
03E48:  MOV     1004,W3
03E4A:  ADD     W3,W4,W0
03E4C:  MOV     #A,W1
03E4E:  MOV     W0,W2
03E50:  MOV.B   [W2++],[W1++]
03E52:  MOV     100A,W4
03E54:  CP.B    W4L,W5L
03E56:  BRA     C,3E92
03E58:  CP0.B   100B
03E5A:  BRA     NZ,3E92
....................     { 
....................         if (MDD_SectorWrite( SectorAddress++, disk->buffer, FALSE) != TRUE) 
03E5C:  MOV     100E,W1
03E5E:  MOV     100C,W0
03E60:  INC     100C
03E62:  BTSC.B  42.1
03E64:  INC     100E
03E66:  MOV     W0,W5
03E68:  MOV     W1,W6
03E6A:  MOV     1004,W4
03E6C:  ADD     W4,#0,W4
03E6E:  MOV     W4,W0
03E70:  MOV     #E,W1
03E72:  MOV     W0,W2
03E74:  REPEAT  #1
03E76:  MOV.B   [W2++],[W1++]
03E78:  CLR.B   109E
03E7A:  MOV     W5,1098
03E7C:  MOV     W6,109A
03E7E:  MOV     W7,109C
03E80:  CALL    2BBE
03E84:  CP.B    W0L,#1
03E86:  BRA     Z,3E8C
....................             error = CE_WRITE_ERROR; 
03E88:  MOV.B   #9,W0L
03E8A:  MOV.B   W0L,100B
03E8C:  INC.B   100A
03E8E:  GOTO    3E46
....................     } 
....................  
....................     return(error); 
03E92:  MOV.B   100B,W0L
03E94:  MOV     [--W15],W7
03E96:  MOV     [--W15],W6
03E98:  MOV     [--W15],W5
03E9A:  RETURN  
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................  
.................... /*************************************************** 
....................   Function: 
....................     BYTE ReadByte(BYTE * pBuffer, WORD index) 
....................   Summary: 
....................     Read a byte from a buffer 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     pBuffer -  pointer to a buffer to read from 
....................     index -    index in the buffer to read to 
....................   Return: 
....................     BYTE - the byte read 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     Reads a byte from a buffer 
....................   Remarks: 
....................     None. 
....................   ***************************************************/ 
....................  
.................... BYTE ReadByte( BYTE* pBuffer, WORD index ) 
*
01776:  MOV     W5,[W15++]
.................... { 
....................     return( pBuffer[index] ); 
01778:  MOV     F9E,W0
0177A:  ADD     F9C,W0
0177C:  MOV     W0,W5
0177E:  MOV.B   [W5+#0],W0L
01780:  MOV.B   W0L,0
01782:  MOV     [--W15],W5
01784:  RETURN  
.................... } 
....................  
....................  
.................... /*************************************************** 
....................   Function: 
....................     BYTE ReadWord(BYTE * pBuffer, WORD index) 
....................   Summary: 
....................     Read a 16-bit word from a buffer 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     pBuffer -  pointer to a buffer to read from 
....................     index -    index in the buffer to read to 
....................   Return: 
....................     WORD - the word read 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     Reads a 16-bit word from a buffer 
....................   Remarks: 
....................     None. 
....................   ***************************************************/ 
....................  
.................... WORD ReadWord( BYTE* pBuffer, WORD index ) 
*
01A66:  MOV     W5,[W15++]
.................... { 
....................     BYTE loByte, hiByte; 
01A68:  CLR.B   FB4
01A6A:  CLR.B   FB5
....................     WORD res; 
01A6C:  CLR     FB6
....................  
....................     loByte = pBuffer[index]; 
01A6E:  MOV     FB2,W0
01A70:  ADD     FB0,W0
01A72:  MOV     FB4,W4
01A74:  MOV.B   [W0+#0],W4L
01A76:  MOV     W4,FB4
....................     hiByte = pBuffer[index+1]; 
01A78:  MOV     FB2,W4
01A7A:  ADD     W4,#1,W4
01A7C:  MOV     W4,W5
01A7E:  MOV     W5,W0
01A80:  ADD     FB0,W0
01A82:  MOV     W0,[W15++]
01A84:  MOV.B   [W0],W0L
01A86:  MOV.B   W0L,FB5
01A88:  MOV     [--W15],W0
....................     res = hiByte; 
01A8A:  MOV.B   FB5,W0L
01A8C:  MOV.B   W0L,FB6
01A8E:  CLR.B   FB7
....................     res *= 0x100; 
01A90:  MOV.B   FB6,W0L
01A92:  MOV.B   W0L,FB7
01A94:  CLR.B   FB6
....................     res |= loByte; 
01A96:  MOV.B   FB4,W0L
01A98:  CLR.B   1
01A9A:  IOR     FB6
....................     return( res ); 
01A9C:  PUSH    FB6
01A9E:  POP     0
01AA0:  MOV     [--W15],W5
01AA2:  RETURN  
.................... } 
....................  
....................  
.................... /**************************************************** 
....................   Function: 
....................     BYTE ReadDWord(BYTE * pBuffer, WORD index) 
....................   Summary: 
....................     Read a 32-bit double word from a buffer 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     pBuffer -  pointer to a buffer to read from 
....................     index -    index in the buffer to read to 
....................   Return: 
....................     DWORD - the double word read 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     Reads a 32-bit double word from a buffer 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... DWORD ReadDWord( BYTE* pBuffer, WORD index ) 
01AA4:  MOV     W5,[W15++]
.................... { 
....................     WORD loWord, hiWord; 
01AA6:  CLR     FA0
01AA8:  CLR     FA2
....................     DWORD result; 
01AAA:  CLR     FA4
01AAC:  CLR     FA6
....................  
....................     loWord = ReadWord( pBuffer, index ); 
01AAE:  PUSH    F9C
01AB0:  POP     FB0
01AB2:  PUSH    F9E
01AB4:  POP     FB2
01AB6:  CALL    1A66
01ABA:  MOV     W0,FA0
....................     hiWord = ReadWord( pBuffer, index+2 ); 
01ABC:  MOV     F9E,W4
01ABE:  ADD     W4,#2,W4
01AC0:  MOV     W4,W5
01AC2:  PUSH    F9C
01AC4:  POP     FB0
01AC6:  MOV     W5,FB2
01AC8:  CALL    1A66
01ACC:  MOV     W0,FA2
....................  
....................     result = hiWord; 
01ACE:  PUSH    FA2
01AD0:  POP     FA4
01AD2:  CLR     FA6
....................     result *= 0x10000; 
01AD4:  PUSH    FA4
01AD6:  POP     FA6
01AD8:  CLR     FA4
....................     result |= loWord; 
01ADA:  MOV     FA0,W0
01ADC:  IOR     FA4
....................     return result; 
01ADE:  MOV     FA4,W0
01AE0:  MOV     FA6,W1
01AE2:  MOV     [--W15],W5
01AE4:  RETURN  
.................... } 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /**************************************************** 
....................   Function: 
....................     DWORD Cluster2Sector(DISK * dsk, DWORD cluster) 
....................   Summary: 
....................     Convert a cluster number to the corresponding sector 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     disk -     Disk structure 
....................     cluster -  Cluster to be converted 
....................   Return: 
....................     sector - Sector that corresponds to given cluster 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The Cluster2Sector function will calculate the 
....................     sector number that corresponds to the first sector 
....................     of the cluster whose value was passed into the 
....................     function. 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... DWORD Cluster2Sector(DISK * dsk, DWORD cluster) 
*
0308C:  MOV     W5,[W15++]
0308E:  MOV     #C,W5
03090:  REPEAT  #3
03092:  MOV     [W5++],[W15++]
.................... { 
....................     DWORD sector; 
03094:  CLR     105C
03096:  CLR     105E
....................  
....................     /* Rt: Settings based on FAT type */ 
....................     switch (dsk->type) 
03098:  MOV     #22,W4
0309A:  MOV     1056,W3
0309C:  ADD     W3,W4,W0
0309E:  MOV     #A,W1
030A0:  MOV     W0,W2
030A2:  MOV.B   [W2++],[W1++]
030A4:  MOV.B   W5L,W0L
030A6:  CLR.B   1
030A8:  XOR     #3,W0
030AA:  BRA     Z,30B2
030AC:  XOR     #1,W0
030AE:  BRA     Z,30F2
030B0:  BRA     30F2
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             /* In FAT32, there is no separate ROOT region. It is as well stored in DATA region */ 
....................             sector = (((DWORD)cluster-2) * dsk->SecPerClus) + dsk->data; 
030B2:  MOV     1058,W4
030B4:  SUB     W4,#2,W5
030B6:  MOV     105A,W4
030B8:  SUBB    W4,#0,W6
030BA:  MOV     #21,W4
030BC:  MOV     1056,W3
030BE:  ADD     W3,W4,W0
030C0:  MOV     #E,W1
030C2:  MOV     W0,W2
030C4:  MOV.B   [W2++],[W1++]
030C6:  MOV.B   W7L,W2L
030C8:  CLR.B   5
030CA:  MOV     #0,W3
030CC:  MOV     W5,W0
030CE:  MOV     W6,W1
030D0:  CALL    10CE
030D4:  MOV     W0,W5
030D6:  MOV     W1,W6
030D8:  MOV     1056,W4
030DA:  ADD     W4,#E,W4
030DC:  MOV     W4,W0
030DE:  MOV     #10,W1
030E0:  MOV     W0,W2
030E2:  REPEAT  #3
030E4:  MOV.B   [W2++],[W1++]
030E6:  ADD     W8,W5,W0
030E8:  MOV     W0,105C
030EA:  ADDC    W9,W6,W0
030EC:  MOV     W0,105E
....................             break; 
030EE:  GOTO    3162
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             // The root dir takes up cluster 0 and 1 
....................             if((cluster == 0) || (cluster == 1)) 
030F2:  CP0     1058
030F4:  BRA     NZ,30FA
030F6:  CP0     105A
030F8:  BRA     Z,3104
030FA:  MOV     1058,W4
030FC:  CP      W4,#1
030FE:  BRA     NZ,3122
03100:  CP0     105A
03102:  BRA     NZ,3122
....................                 sector = dsk->root + cluster; 
03104:  MOV     1056,W4
03106:  ADD     W4,#A,W4
03108:  MOV     W4,W0
0310A:  MOV     #A,W1
0310C:  MOV     W0,W2
0310E:  REPEAT  #3
03110:  MOV.B   [W2++],[W1++]
03112:  MOV     W5,W0
03114:  ADD     1058,W0
03116:  MOV     W0,105C
03118:  MOV     105A,W4
0311A:  ADDC    W6,W4,W0
0311C:  MOV     W0,105E
0311E:  GOTO    315E
....................             else 
....................                 sector = (((DWORD)cluster-2) * dsk->SecPerClus) + dsk->data; 
03122:  MOV     1058,W4
03124:  SUB     W4,#2,W5
03126:  MOV     105A,W4
03128:  SUBB    W4,#0,W6
0312A:  MOV     #21,W4
0312C:  MOV     1056,W3
0312E:  ADD     W3,W4,W0
03130:  MOV     #E,W1
03132:  MOV     W0,W2
03134:  MOV.B   [W2++],[W1++]
03136:  MOV.B   W7L,W2L
03138:  CLR.B   5
0313A:  MOV     #0,W3
0313C:  MOV     W5,W0
0313E:  MOV     W6,W1
03140:  CALL    10CE
03144:  MOV     W0,W5
03146:  MOV     W1,W6
03148:  MOV     1056,W4
0314A:  ADD     W4,#E,W4
0314C:  MOV     W4,W0
0314E:  MOV     #10,W1
03150:  MOV     W0,W2
03152:  REPEAT  #3
03154:  MOV.B   [W2++],[W1++]
03156:  ADD     W8,W5,W0
03158:  MOV     W0,105C
0315A:  ADDC    W9,W6,W0
0315C:  MOV     W0,105E
....................             break; 
0315E:  GOTO    3162
....................     } 
....................  
....................     return(sector); 
03162:  MOV     105C,W0
03164:  MOV     105E,W1
03166:  MOV     #12,W5
03168:  REPEAT  #3
0316A:  MOV     [--W15],[W5--]
0316C:  MOV     [--W15],W5
0316E:  RETURN  
....................  
.................... } 
....................  
....................  
.................... /*************************************************************************** 
....................   Function: 
....................     int FSattrib (FSFILE * file, unsigned char attributes) 
....................   Summary: 
....................     Change the attributes of a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     file -        Pointer to file structure 
....................     attributes -  The attributes to set for the file 
....................                -  Attribute -      Value - Indications 
....................                -  ATTR_READ_ONLY - 0x01  - The read-only attribute 
....................                -  ATTR_HIDDEN -    0x02  - The hidden attribute 
....................                -  ATTR_SYSTEM -    0x04  - The system attribute 
....................                -  ATTR_ARCHIVE -   0x20  - The archive attribute 
....................   Return Values: 
....................     0 -  Attribute change was successful 
....................     -1 - Attribute change was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSattrib funciton will set the attributes of the specified file 
....................     to the attributes passed in by the user.  This function will load the 
....................     file entry, replace the attributes with the ones specified, and write 
....................     the attributes back.  If the specified file is a directory, the 
....................     directory attribute will be preserved. 
....................   Remarks: 
....................     None 
....................   ***************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... int FSattrib (FSFILE * file, unsigned char attributes) 
.................... { 
....................     WORD fHandle; 
....................     DIRENTRY dir; 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................     // Check for valid attributes 
....................     if ((attributes & ~0x27) != 0) 
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
....................         return -1; 
....................     } 
....................  
....................     fHandle = file->entry; 
....................  
....................     file->dirccls = file->dirclus; 
....................  
....................     // Get the file entry 
....................     dir = LoadDirAttrib(file, &fHandle); 
....................  
....................     if (dir == NULL) 
....................     { 
....................         FSerrno = CE_BADCACHEREAD; 
....................         return -1; 
....................     } 
....................  
....................     // Ensure that we aren't trying to change the 
....................     // attributes of a volume entry 
....................     if (dir->DIR_Attr & ATTR_VOLUME) 
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
....................         return -1; 
....................     } 
....................  
....................     // Don't remove the directory attribute from DIR files 
....................     if (file->attributes & ATTR_DIRECTORY) 
....................         file->attributes = attributes | ATTR_DIRECTORY; 
....................     else 
....................         file->attributes = attributes; 
....................  
....................     // just write the last entry in 
....................     if(!Write_File_Entry(file,&fHandle)) 
....................     { 
....................         FSerrno = CE_WRITE_ERROR; 
....................         return -1; 
....................     } 
....................  
....................     return 0; 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Write data to a file 
....................   Conditions: 
....................     File opened in FS_WRITE, FS_APPEND, FS_WRITE+, FS_APPEND+, FS_READ+ mode 
....................   Input: 
....................     data_to_write -     Pointer to source buffer 
....................     size -              Size of units in bytes 
....................     n -                 Number of units to transfer 
....................     stream -  Pointer to file structure 
....................   Return: 
....................     size_t - number of units written 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfwrite function will write data to a file.  First, the sector that 
....................     corresponds to the current position in the file will be loaded (if it hasn't 
....................     already been cached in the global data buffer).  Data will then be written to 
....................     the device from the specified buffer until the specified amount has been written. 
....................     If the end of a cluster is reached, the next cluster will be loaded, unless 
....................     the end-of-file flag for the specified file has been set.  If it has, a new 
....................     cluster will be allocated to the file.  Finally, the new position and filesize 
....................     will be stored in the FSFILE object.  The parameters 'size' and 'n' indicate how 
....................     much data to write.  'Size' refers to the size of one object to write (in bytes), 
....................     and 'n' will refer to the number of these objects to write.  The value returned 
....................     will be equal  to 'n' unless an error occured. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream) 
*
04E70:  MOV     W5,[W15++]
04E72:  MOV     W6,[W15++]
04E74:  MOV     F8A,W4
04E76:  MOV     F8C,W3
04E78:  MUL.UU  W4,W3,W0
04E7A:  MOV     W0,F90
04E7C:  CLR     F92
04E7E:  PUSH    F88
04E80:  POP     F94
*
04E84:  CLR.B   F98
*
04E94:  CLR     FA8
.................... { 
....................     DWORD       count = size * n; 
....................     BYTE   *    src = (BYTE *) data_to_write; 
....................     DISK   *    dsk;                 // pointer to disk structure 
*
04E82:  CLR     F96
....................     CETYPE      error = CE_GOOD; 
....................     WORD        pos; 
*
04E86:  CLR     F9A
....................     DWORD       l;                     // absolute lba of sector to load 
04E88:  CLR     F9C
04E8A:  CLR     F9E
....................     DWORD       seek, filesize; 
04E8C:  CLR     FA0
04E8E:  CLR     FA2
04E90:  CLR     FA4
04E92:  CLR     FA6
....................     WORD        writeCount = 0; 
....................  
....................     // see if the file was opened in a write mode 
....................     if(!(stream->flags.write)) 
*
04E96:  MOV     #16,W0
04E98:  ADD     F8E,W0
04E9A:  MOV.B   [W0],W4L
04E9C:  BTSC    W4.0
04E9E:  BRA     4EAC
....................     { 
....................         FSerrno = CE_READONLY; 
04EA0:  MOV.B   #1D,W0L
04EA2:  MOV.B   W0L,857
....................         error = CE_WRITE_ERROR; 
04EA4:  MOV.B   #9,W0L
04EA6:  MOV.B   W0L,F98
....................         return 0; 
04EA8:  CLR     0
04EAA:  BRA     513C
....................     } 
....................  
....................     if (count == 0) 
04EAC:  CP0     F90
04EAE:  BRA     NZ,4EB8
04EB0:  CP0     F92
04EB2:  BRA     NZ,4EB8
....................         return 0; 
04EB4:  CLR     0
04EB6:  BRA     513C
....................  
....................     if (MDD_WriteProtectState()) 
04EB8:  CALL    25A0
04EBC:  CP0.B   W0L
04EBE:  BRA     Z,4ECC
....................     { 
....................         FSerrno = CE_WRITE_PROTECTED; 
04EC0:  MOV.B   #18,W0L
04EC2:  MOV.B   W0L,857
....................         error = CE_WRITE_PROTECTED; 
04EC4:  MOV.B   #18,W0L
04EC6:  MOV.B   W0L,F98
....................         return 0; 
04EC8:  CLR     0
04ECA:  BRA     513C
....................     } 
....................  
....................     gBufferZeroed = FALSE; 
04ECC:  CLR.B   856
....................     dsk = stream->dsk; 
04ECE:  MOV     F8E,W4
04ED0:  ADD     W4,#0,W4
04ED2:  MOV     W4,W0
04ED4:  MOV     [W0],[W15++]
04ED6:  POP     F96
....................     // get the stated position 
....................     pos = stream->pos; 
04ED8:  MOV     #C,W0
04EDA:  ADD     F8E,W0
04EDC:  MOV     [W0],[W15++]
04EDE:  POP     F9A
....................     seek = stream->seek; 
04EE0:  MOV     #E,W0
04EE2:  ADD     F8E,W0
04EE4:  MOV     #FA0,W4
04EE6:  MOV     [W0++],[W4++]
04EE8:  MOV     [W0++],[W4++]
....................     l = Cluster2Sector(dsk,stream->ccls); 
04EEA:  MOV     #6,W0
04EEC:  ADD     F8E,W0
04EEE:  MOV     #A,W4
04EF0:  MOV     [W0++],[W4++]
04EF2:  MOV     [W0++],[W4++]
04EF4:  PUSH    F96
04EF6:  POP     1056
04EF8:  MOV     W5,1058
04EFA:  MOV     W6,105A
04EFC:  CALL    308C
04F00:  MOV     W0,F9C
04F02:  MOV     W1,F9E
....................     l += (WORD)stream->sec;      // add the sector number to it 
04F04:  MOV     #A,W0
04F06:  ADD     F8E,W0
04F08:  MOV     W0,W4
04F0A:  MOV     [W4],W0
04F0C:  ADD     F9C
04F0E:  MOV     #0,W0
04F10:  ADDC    F9E,W0
04F12:  MOV     W0,F9E
....................  
....................     // Check if the current stream was the last one to use the 
....................     // buffer. If not, check if we need to write data from the 
....................     // old stream 
....................     if (gBufferOwner != stream) 
04F14:  MOV     84E,W0
04F16:  CP      F8E
04F18:  BRA     Z,4F32
....................     { 
....................         if (gNeedDataWrite) 
04F1A:  CP0.B   854
04F1C:  BRA     Z,4F2E
....................         { 
....................             if (flushData()) 
04F1E:  CALL    3170
04F22:  CP0.B   W0L
04F24:  BRA     Z,4F2E
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
04F26:  MOV.B   #9,W0L
04F28:  MOV.B   W0L,857
....................                 return 0; 
04F2A:  CLR     0
04F2C:  BRA     513C
....................             } 
....................         } 
....................         gBufferOwner = stream; 
04F2E:  PUSH    F8E
04F30:  POP     84E
....................     } 
....................     if (gLastDataSectorRead != l) 
04F32:  MOV     850,W0
04F34:  CP      F9C
04F36:  BRA     NZ,4F3E
04F38:  MOV     852,W0
04F3A:  CP      F9E
04F3C:  BRA     Z,4F84
....................     { 
....................         if (gNeedDataWrite) 
04F3E:  CP0.B   854
04F40:  BRA     Z,4F52
....................         { 
....................             if (flushData()) 
04F42:  CALL    3170
04F46:  CP0.B   W0L
04F48:  BRA     Z,4F52
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
04F4A:  MOV.B   #9,W0L
04F4C:  MOV.B   W0L,857
....................                 return 0; 
04F4E:  CLR     0
04F50:  BRA     513C
....................             } 
....................         } 
....................  
....................         gBufferZeroed = FALSE; 
04F52:  CLR.B   856
....................         if(!MDD_SectorRead( l, dsk->buffer) ) 
04F54:  MOV     F96,W4
04F56:  ADD     W4,#0,W4
04F58:  MOV     W4,W0
04F5A:  MOV     #A,W1
04F5C:  MOV     W0,W2
04F5E:  REPEAT  #1
04F60:  MOV.B   [W2++],[W1++]
04F62:  PUSH    F9C
04F64:  POP     1098
04F66:  PUSH    F9E
04F68:  POP     109A
04F6A:  MOV     W5,109C
04F6C:  CALL    1722
04F70:  CP0.B   W0L
04F72:  BRA     NZ,4F7C
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
04F74:  MOV.B   #1B,W0L
04F76:  MOV.B   W0L,857
....................             error = CE_BAD_SECTOR_READ; 
04F78:  MOV.B   #8,W0L
04F7A:  MOV.B   W0L,F98
....................         } 
....................         gLastDataSectorRead = l; 
04F7C:  PUSH    F9C
04F7E:  POP     850
04F80:  PUSH    F9E
04F82:  POP     852
....................     } 
....................     // exit loop if EOF reached 
....................     filesize = stream->size; 
04F84:  MOV     #12,W0
04F86:  ADD     F8E,W0
04F88:  MOV     #FA4,W4
04F8A:  MOV     [W0++],[W4++]
04F8C:  MOV     [W0++],[W4++]
....................  
....................     // Loop while writing bytes 
....................     while ((error == CE_GOOD) && (count > 0)) 
04F8E:  CP0.B   F98
04F90:  BRA     NZ,5110
04F92:  CP0     F90
04F94:  BRA     NZ,4F9A
04F96:  CP0     F92
04F98:  BRA     Z,5110
....................     { 
....................         if( seek == filesize ) 
04F9A:  MOV     FA0,W0
04F9C:  CP      FA4
04F9E:  BRA     NZ,4FB0
04FA0:  MOV     FA2,W0
04FA2:  CP      FA6
04FA4:  BRA     NZ,4FB0
....................             stream->flags.FileWriteEOF = TRUE; 
04FA6:  MOV     #16,W0
04FA8:  ADD     F8E,W0
04FAA:  MOV     W0,W5
04FAC:  MOV     #4,W4
04FAE:  IOR.B    W4L,  [W5],[W5]
....................  
....................         // load a new sector if necessary, multiples of sector 
....................         if (pos == dsk->sectorSize) 
04FB0:  MOV     F96,W4
04FB2:  ADD     W4,#18,W4
04FB4:  MOV     W4,W0
04FB6:  MOV     #A,W1
04FB8:  MOV     W0,W2
04FBA:  REPEAT  #3
04FBC:  MOV.B   [W2++],[W1++]
04FBE:  MOV     F9A,W4
04FC0:  CP      W4,W5
04FC2:  BRA     NZ,50C6
04FC4:  CP0     W6
04FC6:  BRA     NZ,50C6
....................         { 
....................             BYTE needRead = TRUE; 
04FC8:  MOV.B   #1,W0L
04FCA:  MOV.B   W0L,F99
....................  
....................             if (gNeedDataWrite) 
04FCC:  CP0.B   854
04FCE:  BRA     Z,4FE0
....................                 if (flushData()) 
04FD0:  CALL    3170
04FD4:  CP0.B   W0L
04FD6:  BRA     Z,4FE0
....................                 { 
....................                     FSerrno = CE_WRITE_ERROR; 
04FD8:  MOV.B   #9,W0L
04FDA:  MOV.B   W0L,857
....................                     return 0; 
04FDC:  CLR     0
04FDE:  BRA     513C
....................                 } 
....................  
....................             // reset position 
....................             pos = 0; 
04FE0:  CLR     F9A
....................  
....................             // point to the next sector 
....................             stream->sec++; 
04FE2:  MOV     #A,W0
04FE4:  ADD     F8E,W0
04FE6:  MOV     W0,W5
04FE8:  INC     [W5],[W5]
....................  
....................             // get a new cluster if necessary 
....................             if (stream->sec == dsk->SecPerClus) 
04FEA:  MOV     #A,W0
04FEC:  ADD     F8E,W0
04FEE:  MOV     [W0],W5
04FF0:  MOV     #21,W4
04FF2:  MOV     F96,W3
04FF4:  ADD     W3,W4,W0
04FF6:  MOV     #C,W1
04FF8:  MOV     W0,W2
04FFA:  MOV.B   [W2++],[W1++]
04FFC:  CLR.B   D
04FFE:  CP      W5,W6
05000:  BRA     NZ,503A
....................             { 
....................                 stream->sec = 0; 
05002:  MOV     #A,W0
05004:  ADD     F8E,W0
05006:  MOV     W0,W5
05008:  CLR.B   [W5]
0500A:  MOV.B   #0,W0L
0500C:  MOV.B   W0L,[W5+#1]
....................  
....................                 if(stream->flags.FileWriteEOF) 
0500E:  MOV     #16,W0
05010:  ADD     F8E,W0
05012:  MOV.B   [W0],W4L
05014:  BTSS    W4.2
05016:  BRA     502A
....................                 { 
....................                     error = FILEallocate_new_cluster(stream, 0);    // add new cluster to the file 
05018:  CLR.B   FF4
0501A:  PUSH    F8E
0501C:  POP     FF2
0501E:  CALL    3E9C
05022:  MOV.B   W0L,F98
....................                     needRead = FALSE; 
05024:  CLR.B   F99
....................                 } 
05026:  GOTO    503A
....................                 else 
....................                     error = FILEget_next_cluster( stream, 1); 
0502A:  PUSH    F8E
0502C:  POP     FF6
0502E:  MOV     #1,W4
05030:  MOV     W4,FF8
05032:  CLR     FFA
05034:  CALL    4674
05038:  MOV.B   W0L,F98
....................             } 
....................  
....................             if (error == CE_DISK_FULL) 
0503A:  MOV     F98,W4
0503C:  CP.B    W4L,#15
0503E:  BRA     NZ,5048
....................             { 
....................                 FSerrno = CE_DISK_FULL; 
05040:  MOV.B   #15,W0L
05042:  MOV.B   W0L,857
....................                 return 0; 
05044:  CLR     0
05046:  BRA     513C
....................             } 
....................  
....................             if(error == CE_GOOD) 
05048:  CP0.B   F98
0504A:  BRA     NZ,50C6
....................             { 
....................                 l = Cluster2Sector(dsk,stream->ccls); 
0504C:  MOV     #6,W0
0504E:  ADD     F8E,W0
05050:  MOV     #A,W4
05052:  MOV     [W0++],[W4++]
05054:  MOV     [W0++],[W4++]
05056:  PUSH    F96
05058:  POP     1056
0505A:  MOV     W5,1058
0505C:  MOV     W6,105A
0505E:  CALL    308C
05062:  MOV     W0,F9C
05064:  MOV     W1,F9E
....................                 l += (WORD)stream->sec;      // add the sector number to it 
05066:  MOV     #A,W0
05068:  ADD     F8E,W0
0506A:  MOV     W0,W4
0506C:  MOV     [W4],W0
0506E:  ADD     F9C
05070:  MOV     #0,W0
05072:  ADDC    F9E,W0
05074:  MOV     W0,F9E
....................                 gBufferOwner = stream; 
05076:  PUSH    F8E
05078:  POP     84E
....................                 // If we just allocated a new cluster, then the cluster will 
....................                 // contain garbage data, so it doesn't matter what we write to it 
....................                 // Whatever is in the buffer will work fine 
....................                 if (needRead) 
0507A:  CP0.B   F99
0507C:  BRA     Z,50BE
....................                 { 
....................                     if( !MDD_SectorRead( l, dsk->buffer) ) 
0507E:  MOV     F96,W4
05080:  ADD     W4,#0,W4
05082:  MOV     W4,W0
05084:  MOV     #A,W1
05086:  MOV     W0,W2
05088:  REPEAT  #1
0508A:  MOV.B   [W2++],[W1++]
0508C:  PUSH    F9C
0508E:  POP     1098
05090:  PUSH    F9E
05092:  POP     109A
05094:  MOV     W5,109C
05096:  CALL    1722
0509A:  CP0.B   W0L
0509C:  BRA     NZ,50B2
....................                     { 
....................                         FSerrno = CE_BADCACHEREAD; 
0509E:  MOV.B   #1B,W0L
050A0:  MOV.B   W0L,857
....................                         error = CE_BAD_SECTOR_READ; 
050A2:  MOV.B   #8,W0L
050A4:  MOV.B   W0L,F98
....................                         gLastDataSectorRead = 0xFFFFFFFF; 
050A6:  SETM    850
050A8:  SETM    852
....................                         return 0; 
050AA:  CLR     0
050AC:  BRA     513C
....................                     } 
050AE:  GOTO    50BA
....................                     else 
....................                     { 
....................                         gLastDataSectorRead = l; 
050B2:  PUSH    F9C
050B4:  POP     850
050B6:  PUSH    F9E
050B8:  POP     852
....................                     } 
....................                 } 
050BA:  GOTO    50C6
....................                 else 
....................                     gLastDataSectorRead = l; 
050BE:  PUSH    F9C
050C0:  POP     850
050C2:  PUSH    F9E
050C4:  POP     852
....................             } 
....................         } //  load new sector 
....................  
....................         if(error == CE_GOOD) 
050C6:  CP0.B   F98
050C8:  BRA     NZ,510C
....................         { 
....................             // Write one byte at a time 
....................             RAMwrite(dsk->buffer, pos++, *(char *)src); 
050CA:  MOV     F96,W4
050CC:  ADD     W4,#0,W4
050CE:  MOV     W4,W0
050D0:  MOV     #A,W1
050D2:  MOV     W0,W2
050D4:  REPEAT  #1
050D6:  MOV.B   [W2++],[W1++]
050D8:  MOV     F9A,W0
050DA:  INC     0F9A
050DC:  ADD     W0,W5,W0
050DE:  MOV     W0,W5
050E0:  MOV     F94,W0
050E2:  MOV.B   [W0],[W5]
....................             src = src + 1; // compiler bug 
050E4:  MOV     F94,W4
050E6:  ADD     W4,#1,W4
050E8:  MOV     W4,F94
....................             seek++; 
050EA:  INC     0FA0
050EC:  BTSC.B  42.1
050EE:  INC     0FA2
....................             count--; 
050F0:  DEC     0F90
050F2:  BTSS.B  42.0
050F4:  DEC     0F92
....................             writeCount++; 
050F6:  INC     0FA8
....................             // now increment the size of the part 
....................             if(stream->flags.FileWriteEOF) 
050F8:  MOV     #16,W0
050FA:  ADD     F8E,W0
050FC:  MOV.B   [W0],W4L
050FE:  BTSS    W4.2
05100:  BRA     5108
....................                 filesize++; 
05102:  INC     0FA4
05104:  BTSC.B  42.1
05106:  INC     0FA6
....................             gNeedDataWrite = TRUE; 
05108:  MOV.B   #1,W0L
0510A:  MOV.B   W0L,854
....................         } 
0510C:  GOTO    4F8E
....................     } // while count 
....................  
....................     // save off the positon 
....................     stream->pos = pos; 
05110:  MOV     #C,W0
05112:  ADD     F8E,W0
05114:  MOV     W0,W5
05116:  MOV     F9A,W4
05118:  MOV     W4,[W5+#0]
....................  
....................     // save off the seek 
....................     stream->seek = seek; 
0511A:  MOV     #E,W0
0511C:  ADD     F8E,W0
0511E:  MOV     W0,W5
05120:  MOV     #FA0,W4
05122:  MOV     [W4++],[W5++]
05124:  MOV     [W4++],[W5++]
....................  
....................     // now the new size 
....................     stream->size = filesize; 
05126:  MOV     #12,W0
05128:  ADD     F8E,W0
0512A:  MOV     W0,W5
0512C:  MOV     #FA4,W4
0512E:  MOV     [W4++],[W5++]
05130:  MOV     [W4++],[W5++]
....................  
....................     return(writeCount / size); 
05132:  MOV     FA8,W4
05134:  MOV     F8A,W3
05136:  REPEAT  #11
05138:  DIV.U   W4,W3
0513A:  MOV     W0,0
0513C:  MOV     [--W15],W6
0513E:  MOV     [--W15],W5
05140:  RETURN  
.................... } // fwrite 
.................... #endif 
....................  
....................  
.................... /********************************************************** 
....................   Function: 
....................     BYTE flushData (void) 
....................   Summary: 
....................     Flush unwritten data to a file 
....................   Conditions: 
....................     File opened in a write mode, data needs to be written 
....................   Return Values: 
....................     CE_GOOD -        Data was updated successfully 
....................     CE_WRITE_ERROR - Data could not be updated 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The flushData function is called when it is necessary to 
....................     read new data into the global data buffer and the 
....................     gNeedDataWrite variable indicates that there is data 
....................     in the buffer that hasn't been written to the device. 
....................     The flushData function will write the data from the 
....................     buffer into the current cluster of the FSFILE object 
....................     that is stored in the gBufferOwner global variable. 
....................   Remarks: 
....................     None 
....................   **********************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE flushData (void) 
*
03170:  MOV     W5,[W15++]
03172:  MOV     W6,[W15++]
*
0317A:  PUSH    84E
0317C:  POP     104E
.................... { 
....................     DWORD l; 
*
03174:  CLR     1048
03176:  CLR     104A
....................     DISK * dsk; 
03178:  CLR     104C
....................  
....................     // This will either be the pointer to the last file, or the handle 
....................     FILEOBJ stream = gBufferOwner; 
....................  
....................     dsk = stream->dsk; 
*
0317E:  MOV     104E,W4
03180:  ADD     W4,#0,W4
03182:  MOV     W4,W0
03184:  MOV     [W0],[W15++]
03186:  POP     104C
....................  
....................     // figure out the lba 
....................     l = Cluster2Sector(dsk,stream->ccls); 
03188:  MOV     #6,W0
0318A:  ADD     104E,W0
0318C:  MOV     #A,W4
0318E:  MOV     [W0++],[W4++]
03190:  MOV     [W0++],[W4++]
03192:  PUSH    104C
03194:  POP     1056
03196:  MOV     W5,1058
03198:  MOV     W6,105A
0319A:  CALL    308C
0319E:  MOV     W0,1048
031A0:  MOV     W1,104A
....................     l += (WORD)stream->sec;      // add the sector number to it 
031A2:  MOV     #A,W0
031A4:  ADD     104E,W0
031A6:  MOV     W0,W4
031A8:  MOV     [W4],W0
031AA:  ADD     1048
031AC:  MOV     #0,W0
031AE:  ADDC    104A,W0
031B0:  MOV     W0,104A
....................  
....................     if(!MDD_SectorWrite( l, dsk->buffer, FALSE)) 
031B2:  MOV     104C,W4
031B4:  ADD     W4,#0,W4
031B6:  MOV     W4,W0
031B8:  MOV     #A,W1
031BA:  MOV     W0,W2
031BC:  REPEAT  #1
031BE:  MOV.B   [W2++],[W1++]
031C0:  CLR.B   109E
031C2:  PUSH    1048
031C4:  POP     1098
031C6:  PUSH    104A
031C8:  POP     109A
031CA:  MOV     W5,109C
031CC:  CALL    2BBE
031D0:  CP0.B   W0L
031D2:  BRA     NZ,31DA
....................     { 
....................         return CE_WRITE_ERROR; 
031D4:  MOV.B   #9,W0L
031D6:  MOV.B   W0L,0
031D8:  BRA     31DE
....................     } 
....................  
....................     gNeedDataWrite = FALSE; 
031DA:  CLR.B   854
....................  
....................     return CE_GOOD; 
031DC:  CLR.B   0
031DE:  MOV     [--W15],W6
031E0:  MOV     [--W15],W5
031E2:  RETURN  
.................... } 
.................... #endif 
....................  
.................... /**************************************************** 
....................   Function: 
....................     int FSfeof( FSFILE * stream ) 
....................   Summary: 
....................     Indicate whether the current file position is at the end 
....................   Conditions: 
....................     File is open in a read mode 
....................   Input: 
....................     stream -  Pointer to the target file 
....................   Return Values: 
....................     Non-Zero - EOF reached 
....................     0 - Not at end of File 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfeof function will indicate that the end-of- 
....................     file has been reached for the specified file by 
....................     comparing the absolute location in the file to the 
....................     size of the file. 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... int FSfeof( FSFILE * stream ) 
.................... { 
....................     FSerrno = CE_GOOD; 
....................     return( stream->seek == stream->size ); 
.................... } 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Read data from a file 
....................   Conditions: 
....................     File is opened in a read mode 
....................   Input: 
....................     ptr -     Destination buffer for read bytes 
....................     size -    Size of units in bytes 
....................     n -       Number of units to be read 
....................     stream -  File to be read from 
....................   Return: 
....................     size_t - number of units read 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfread function will read data from the specified file.  First, 
....................     the appropriate sector of the file is loaded.  Then, data is read into 
....................     the specified buffer until the specified number of bytes have been read. 
....................     When a cluster boundary is reached, a new cluster will be loaded.  The 
....................     parameters 'size' and 'n' indicate how much data to read.  'Size' 
....................     refers to the size of one object to read (in bytes), and 'n' will refer 
....................     to the number of these objects to read.  The value returned will be equal 
....................     to 'n' unless an error occured or the user tried to read beyond the end 
....................     of the file. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... size_t FSfread (void *ptr, size_t size, size_t n, FSFILE *stream) 
*
06C80:  MOV     W5,[W15++]
06C82:  MOV     W6,[W15++]
06C84:  MOV     FC4,W4
06C86:  MOV     FC6,W3
06C88:  MUL.UU  W4,W3,W0
06C8A:  MOV     W0,FCA
06C8C:  CLR     FCC
06C8E:  PUSH    FC2
06C90:  POP     FCE
*
06C9E:  CLR.B   FDC
06CA0:  CLR     FDE
.................... { 
....................     DWORD   len = size * n; 
....................     BYTE    *pointer = (BYTE *) ptr; 
....................     DISK    *dsk;               // Disk structure 
*
06C92:  CLR     FD0
....................     DWORD    seek, sec_sel; 
06C94:  CLR     FD2
06C96:  CLR     FD4
06C98:  CLR     FD6
06C9A:  CLR     FD8
....................     WORD    pos;       //position within sector 
06C9C:  CLR     FDA
....................     CETYPE   error = CE_GOOD; 
....................     WORD    readCount = 0; 
....................  
....................     FSerrno = CE_GOOD; 
*
06CA2:  CLR.B   857
....................  
....................     dsk    = (DISK *)stream->dsk; 
06CA4:  MOV     FC8,W4
06CA6:  ADD     W4,#0,W4
06CA8:  MOV     W4,W0
06CAA:  MOV     [W0],[W15++]
06CAC:  POP     FD0
....................     pos    = stream->pos; 
06CAE:  MOV     #C,W0
06CB0:  ADD     FC8,W0
06CB2:  MOV     [W0],[W15++]
06CB4:  POP     FDA
....................     seek    = stream->seek; 
06CB6:  MOV     #E,W0
06CB8:  ADD     FC8,W0
06CBA:  MOV     #FD2,W4
06CBC:  MOV     [W0++],[W4++]
06CBE:  MOV     [W0++],[W4++]
....................  
....................     if( !stream->flags.read ) 
06CC0:  MOV     #16,W0
06CC2:  ADD     FC8,W0
06CC4:  MOV.B   [W0],W4L
06CC6:  BTSC    W4.1
06CC8:  BRA     6CD2
....................     { 
....................         FSerrno = CE_WRITEONLY; 
06CCA:  MOV.B   #1E,W0L
06CCC:  MOV.B   W0L,857
....................         return 0;   // CE_WRITEONLY 
06CCE:  CLR     0
06CD0:  BRA     6EA4
....................     } 
....................  
.................... #ifdef ALLOW_WRITES 
....................     if (gNeedDataWrite) 
06CD2:  CP0.B   854
06CD4:  BRA     Z,6CE6
....................         if (flushData() != CE_GOOD) 
06CD6:  CALL    3170
06CDA:  CP0.B   W0L
06CDC:  BRA     Z,6CE6
....................         { 
....................             FSerrno = CE_WRITE_ERROR; 
06CDE:  MOV.B   #9,W0L
06CE0:  MOV.B   W0L,857
....................             return 0; 
06CE2:  CLR     0
06CE4:  BRA     6EA4
....................         } 
.................... #endif 
....................  
....................     // if it not my buffer, then get it from the disk. 
....................     if( (gBufferOwner != stream) && (pos != dsk->sectorSize)) 
06CE6:  MOV     84E,W0
06CE8:  CP      FC8
06CEA:  BRA     Z,6D68
06CEC:  MOV     FD0,W4
06CEE:  ADD     W4,#18,W4
06CF0:  MOV     W4,W0
06CF2:  MOV     #A,W1
06CF4:  MOV     W0,W2
06CF6:  REPEAT  #3
06CF8:  MOV.B   [W2++],[W1++]
06CFA:  MOV     FDA,W4
06CFC:  CP      W4,W5
06CFE:  BRA     NZ,6D04
06D00:  CP0     W6
06D02:  BRA     Z,6D68
....................     { 
....................         gBufferOwner = stream; 
06D04:  PUSH    FC8
06D06:  POP     84E
....................         sec_sel = Cluster2Sector(dsk,stream->ccls); 
06D08:  MOV     #6,W0
06D0A:  ADD     FC8,W0
06D0C:  MOV     #A,W4
06D0E:  MOV     [W0++],[W4++]
06D10:  MOV     [W0++],[W4++]
06D12:  PUSH    FD0
06D14:  POP     1056
06D16:  MOV     W5,1058
06D18:  MOV     W6,105A
06D1A:  CALL    308C
06D1E:  MOV     W0,FD6
06D20:  MOV     W1,FD8
....................         sec_sel += (WORD)stream->sec;      // add the sector number to it 
06D22:  MOV     #A,W0
06D24:  ADD     FC8,W0
06D26:  MOV     W0,W4
06D28:  MOV     [W4],W0
06D2A:  ADD     FD6
06D2C:  MOV     #0,W0
06D2E:  ADDC    FD8,W0
06D30:  MOV     W0,FD8
....................  
....................         gBufferZeroed = FALSE; 
06D32:  CLR.B   856
....................         if( !MDD_SectorRead( sec_sel, dsk->buffer) ) 
06D34:  MOV     FD0,W4
06D36:  ADD     W4,#0,W4
06D38:  MOV     W4,W0
06D3A:  MOV     #A,W1
06D3C:  MOV     W0,W2
06D3E:  REPEAT  #1
06D40:  MOV.B   [W2++],[W1++]
06D42:  PUSH    FD6
06D44:  POP     1098
06D46:  PUSH    FD8
06D48:  POP     109A
06D4A:  MOV     W5,109C
06D4C:  CALL    1722
06D50:  CP0.B   W0L
06D52:  BRA     NZ,6D60
....................         { 
....................             FSerrno = CE_BAD_SECTOR_READ; 
06D54:  MOV.B   #8,W0L
06D56:  MOV.B   W0L,857
....................             error = CE_BAD_SECTOR_READ; 
06D58:  MOV.B   #8,W0L
06D5A:  MOV.B   W0L,FDC
....................             return 0; 
06D5C:  CLR     0
06D5E:  BRA     6EA4
....................         } 
....................         gLastDataSectorRead = sec_sel; 
06D60:  PUSH    FD6
06D62:  POP     850
06D64:  PUSH    FD8
06D66:  POP     852
....................     } 
....................  
....................     //loop reading (count) bytes 
....................     while( len ) 
06D68:  CP0     FCA
06D6A:  BRA     NZ,6D70
06D6C:  CP0     FCC
06D6E:  BRA     Z,6E84
....................     { 
....................         if( seek == stream->size ) 
06D70:  MOV     #12,W0
06D72:  ADD     FC8,W0
06D74:  MOV     W0,W4
06D76:  MOV     #0,W3
06D78:  MOV     [W4++],[W3++]
06D7A:  MOV     [W4++],[W3++]
06D7C:  CP      FD2
06D7E:  BRA     NZ,6D92
06D80:  MOV     FD4,W4
06D82:  CP      W4,W1
06D84:  BRA     NZ,6D92
....................         { 
....................             FSerrno = CE_EOF; 
06D86:  MOV.B   #3D,W0L
06D88:  MOV.B   W0L,857
....................             error = CE_EOF; 
06D8A:  MOV.B   #3D,W0L
06D8C:  MOV.B   W0L,FDC
....................             break; 
06D8E:  GOTO    6E84
....................         } 
....................  
....................         // In fopen, pos is init to 0 and the sect is loaded 
....................         if( pos == dsk->sectorSize ) 
06D92:  MOV     FD0,W4
06D94:  ADD     W4,#18,W4
06D96:  MOV     W4,W0
06D98:  MOV     #A,W1
06D9A:  MOV     W0,W2
06D9C:  REPEAT  #3
06D9E:  MOV.B   [W2++],[W1++]
06DA0:  MOV     FDA,W4
06DA2:  CP      W4,W5
06DA4:  BRA     NZ,6E58
06DA6:  CP0     W6
06DA8:  BRA     NZ,6E58
....................         { 
....................             // reset position 
....................             pos = 0; 
06DAA:  CLR     FDA
....................             // point to the next sector 
....................             stream->sec++; 
06DAC:  MOV     #A,W0
06DAE:  ADD     FC8,W0
06DB0:  MOV     W0,W5
06DB2:  INC     [W5],[W5]
....................  
....................             // get a new cluster if necessary 
....................             if( stream->sec == dsk->SecPerClus ) 
06DB4:  MOV     #A,W0
06DB6:  ADD     FC8,W0
06DB8:  MOV     [W0],W5
06DBA:  MOV     #21,W4
06DBC:  MOV     FD0,W3
06DBE:  ADD     W3,W4,W0
06DC0:  MOV     #C,W1
06DC2:  MOV     W0,W2
06DC4:  MOV.B   [W2++],[W1++]
06DC6:  CLR.B   D
06DC8:  CP      W5,W6
06DCA:  BRA     NZ,6DF4
....................             { 
....................                 stream->sec = 0; 
06DCC:  MOV     #A,W0
06DCE:  ADD     FC8,W0
06DD0:  MOV     W0,W5
06DD2:  CLR.B   [W5]
06DD4:  MOV.B   #0,W0L
06DD6:  MOV.B   W0L,[W5+#1]
....................                 if( (error = FILEget_next_cluster( stream, 1)) != CE_GOOD ) 
06DD8:  PUSH    FC8
06DDA:  POP     FF6
06DDC:  MOV     #1,W4
06DDE:  MOV     W4,FF8
06DE0:  CLR     FFA
06DE2:  CALL    4674
06DE6:  MOV.B   W0L,FDC
06DE8:  CP0.B   FDC
06DEA:  BRA     Z,6DF4
....................                 { 
....................                     FSerrno = CE_COULD_NOT_GET_CLUSTER; 
06DEC:  MOV.B   #F,W0L
06DEE:  MOV.B   W0L,857
....................                     break; 
06DF0:  GOTO    6E84
....................                 } 
....................             } 
....................  
....................             sec_sel = Cluster2Sector(dsk,stream->ccls); 
06DF4:  MOV     #6,W0
06DF6:  ADD     FC8,W0
06DF8:  MOV     #A,W4
06DFA:  MOV     [W0++],[W4++]
06DFC:  MOV     [W0++],[W4++]
06DFE:  PUSH    FD0
06E00:  POP     1056
06E02:  MOV     W5,1058
06E04:  MOV     W6,105A
06E06:  CALL    308C
06E0A:  MOV     W0,FD6
06E0C:  MOV     W1,FD8
....................             sec_sel += (WORD)stream->sec;      // add the sector number to it 
06E0E:  MOV     #A,W0
06E10:  ADD     FC8,W0
06E12:  MOV     W0,W4
06E14:  MOV     [W4],W0
06E16:  ADD     FD6
06E18:  MOV     #0,W0
06E1A:  ADDC    FD8,W0
06E1C:  MOV     W0,FD8
....................  
....................  
....................             gBufferOwner = stream; 
06E1E:  PUSH    FC8
06E20:  POP     84E
....................             gBufferZeroed = FALSE; 
06E22:  CLR.B   856
....................             if( !MDD_SectorRead( sec_sel, dsk->buffer) ) 
06E24:  MOV     FD0,W4
06E26:  ADD     W4,#0,W4
06E28:  MOV     W4,W0
06E2A:  MOV     #A,W1
06E2C:  MOV     W0,W2
06E2E:  REPEAT  #1
06E30:  MOV.B   [W2++],[W1++]
06E32:  PUSH    FD6
06E34:  POP     1098
06E36:  PUSH    FD8
06E38:  POP     109A
06E3A:  MOV     W5,109C
06E3C:  CALL    1722
06E40:  CP0.B   W0L
06E42:  BRA     NZ,6E50
....................             { 
....................                 FSerrno = CE_BAD_SECTOR_READ; 
06E44:  MOV.B   #8,W0L
06E46:  MOV.B   W0L,857
....................                 error = CE_BAD_SECTOR_READ; 
06E48:  MOV.B   #8,W0L
06E4A:  MOV.B   W0L,FDC
....................                 break; 
06E4C:  GOTO    6E84
....................             } 
....................             gLastDataSectorRead = sec_sel; 
06E50:  PUSH    FD6
06E52:  POP     850
06E54:  PUSH    FD8
06E56:  POP     852
....................         } 
....................  
....................         // copy one byte at a time 
....................         *pointer = RAMread( dsk->buffer, pos++ ); 
06E58:  MOV     FCE,W5
06E5A:  MOV     FD0,W4
06E5C:  ADD     W4,#0,W4
06E5E:  MOV     W4,W0
06E60:  MOV     #C,W1
06E62:  MOV     W0,W2
06E64:  REPEAT  #1
06E66:  MOV.B   [W2++],[W1++]
06E68:  MOV     FDA,W0
06E6A:  INC     0FDA
06E6C:  ADD     W0,W6,W0
06E6E:  MOV.B   [W0],[W5]
....................         pointer++; 
06E70:  INC     0FCE
....................         seek++; 
06E72:  INC     0FD2
06E74:  BTSC.B  42.1
06E76:  INC     0FD4
....................         readCount++; 
06E78:  INC     0FDE
....................         len--; 
06E7A:  DEC     0FCA
06E7C:  BTSS.B  42.0
06E7E:  DEC     0FCC
06E80:  GOTO    6D68
....................     } 
....................  
....................     // save off the positon 
....................     stream->pos = pos; 
06E84:  MOV     #C,W0
06E86:  ADD     FC8,W0
06E88:  MOV     W0,W5
06E8A:  MOV     FDA,W4
06E8C:  MOV     W4,[W5+#0]
....................     // save off the seek 
....................     stream->seek = seek; 
06E8E:  MOV     #E,W0
06E90:  ADD     FC8,W0
06E92:  MOV     W0,W5
06E94:  MOV     #FD2,W4
06E96:  MOV     [W4++],[W5++]
06E98:  MOV     [W4++],[W5++]
....................  
....................     return(readCount / size); 
06E9A:  MOV     FDE,W4
06E9C:  MOV     FC4,W3
06E9E:  REPEAT  #11
06EA0:  DIV.U   W4,W3
06EA2:  MOV     W0,0
06EA4:  MOV     [--W15],W6
06EA6:  MOV     [--W15],W5
06EA8:  RETURN  
.................... } // fread 
....................  
....................  
.................... /*************************************************************************** 
....................   Function: 
....................     BYTE FormatFileName( const char* fileName, FILEOBJ fptr, BYTE mode ) 
....................   Summary: 
....................     Format a file name into dir entry format 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fileName -  The name to be formatted 
....................     fN2 -       The location the formatted name will be stored 
....................     mode -      Non-zero if parital string search chars are allowed 
....................   Return Values: 
....................     TRUE - Name formatted successfully 
....................     FALSE - File name could not be formatted 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     Format an 8.3 filename into FSFILE structure format. If filename is less 
....................     than 8 chars, then it will be padded with spaces. If the extension name is 
....................     fewer than 3 chars, then it will also be oadded with spaces. The 
....................     ValidateChars function is used to ensure the characters in the specified 
....................     filename are valid in this filesystem. 
....................   Remarks: 
....................     None. 
....................   ***************************************************************************/ 
.................... BYTE FormatFileName( const char* fileName, FILEOBJ fptr, BYTE mode) 
*
026EC:  MOV     W5,[W15++]
026EE:  MOV     W6,[W15++]
026F0:  MOV     W7,[W15++]
*
02700:  BCLR.B  1012.0
02702:  CLR     1014
.................... { 
....................    char *fN2; 
*
026F2:  CLR     1006
....................    FILE_DIR_NAME_TYPE fileNameType; 
026F4:  CLR.B   1005
....................     int temp,count1,count2,count3,count4; 
026F6:  CLR     1008
026F8:  CLR     100A
026FA:  CLR     100C
026FC:  CLR     100E
026FE:  CLR     1010
....................     BOOL supportLFN = FALSE; 
....................    char *localFileName = NULL; 
....................  
....................    // go with static allocation 
....................    #if defined(SUPPORT_LFN) 
....................       unsigned short int tempString[256]; 
....................       BOOL   AscciIndication = TRUE; 
....................       count1 = 256; 
....................    #else 
....................       unsigned short int   tempString[13]; 
*
02704:  CLR     1016
02706:  CLR     1018
02708:  CLR     101A
0270A:  CLR     101C
0270C:  CLR     101E
0270E:  CLR     1020
02710:  CLR     1022
02712:  CLR     1024
02714:  CLR     1026
02716:  CLR     1028
02718:  CLR     102A
0271A:  CLR     102C
0271C:  CLR     102E
....................       count1 = 12; 
0271E:  MOV     #C,W4
02720:  MOV     W4,100A
....................    #endif 
....................  
....................    // Check whether the length of the file name is valid 
....................    // for LFN support as well as Non LFN support 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................    { 
....................       utf16Filename = (unsigned short int *)fileName; 
....................       fileNameLength = 0; 
....................       while(utf16Filename[fileNameLength]) 
....................       { 
....................          fileNameLength++; 
....................       } 
....................  
....................       if((fileNameLength > count1) || (*utf16Filename == '.') || 
....................          (*utf16Filename == 0)) 
....................       { 
....................          return FALSE; 
....................       } 
....................  
....................       for (count1 = 0;count1 < fileNameLength; count1++) 
....................       { 
....................          tempString[count1] = utf16Filename[count1]; 
....................       } 
....................  
....................       utf16Filename = tempString; 
....................    } 
....................    else 
....................    #endif 
....................    { 
....................       fileNameLength = strlen(fileName); 
02722:  PUSH    1000
02724:  POP     1036
02726:  CALL    25A8
0272A:  MOV     W0,D2C
....................  
....................       if((fileNameLength > count1) || (*fileName == '.') || (*fileName == 0)) 
0272C:  MOV     100A,W0
0272E:  MOV     D2C,W4
02730:  CP      W4,W0
02732:  BRA     GT,2746
02734:  MOV     1000,W0
02736:  MOV.B   [W0],W4L
02738:  XOR.B   #2E,W4L
0273A:  BRA     Z,2746
0273C:  MOV     1000,W0
0273E:  MOV.B   [W0],W5L
02740:  SE      W5,W5
02742:  CP0     W5
02744:  BRA     NZ,274A
....................       { 
....................          return FALSE; 
02746:  CLR.B   0
02748:  BRA     28DA
....................       } 
....................  
....................       asciiFilename = (char *)tempString; 
0274A:  MOV     #1016,W5
0274C:  MOV     W5,906
....................       for (count1 = 0;count1 < fileNameLength; count1++) 
0274E:  CLR     100A
02750:  MOV     100A,W0
02752:  MOV     D2C,W4
02754:  CP      W4,W0
02756:  BRA     LE,276A
....................       { 
....................          asciiFilename[count1] = fileName[count1]; 
02758:  MOV     100A,W0
0275A:  ADD     906,W0
0275C:  MOV     W0,W5
0275E:  MOV     100A,W0
02760:  ADD     1000,W0
02762:  MOV.B   [W0],[W5]
02764:  INC     100A
02766:  GOTO    2750
....................       } 
....................    } 
....................     
....................  
....................        #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" FormatFileName len="); 
....................          PrintRAMBytesUART(((unsigned char*)&fileNameLength), 1); 
....................          PrintROMASCIIStringUART(" FormatFileName asciiFilename="); 
....................          PrintRAMBytesUART(((unsigned char*)asciiFilename), 13);          
....................          PrintROMASCIIStringUART(" FormatFileName fileName="); 
....................          PrintRAMBytesUART(((unsigned char*)fileName), 13);          
....................         #endif 
....................  
....................     // Make sure the characters are valid 
....................       fileNameType = ValidateChars(mode); 
0276A:  MOV.B   1004,W0L
0276C:  MOV.B   W0L,1036
0276E:  CALL    25C8
02772:  MOV.B   W0L,1005
....................  
....................     // If the file name doesn't follow 8P3 or LFN format, then return FALSE 
....................     if(NAME_ERROR == fileNameType) 
02774:  MOV     1004,W4
02776:  LSR     W4,#8,W4
02778:  CP.B    W4L,#7
0277A:  BRA     NZ,2780
....................    { 
....................       return FALSE; 
0277C:  CLR.B   0
0277E:  BRA     28DA
....................    } 
....................  
....................    temp = fileNameLength; 
02780:  PUSH    D2C
02782:  POP     1008
....................  
....................    #if defined(SUPPORT_LFN) 
....................       fptr->AsciiEncodingType = TRUE; 
....................       fptr->utf16LFNlength = 0; 
....................    #endif 
....................  
....................    // If LFN is supported and the file name is UTF16 type or Ascii mixed type, 
....................    // go for LFN support rather than trying to adjust in 8P3 format 
....................    if(NAME_8P3_ASCII_MIXED_TYPE == fileNameType) 
02784:  MOV     1004,W4
02786:  LSR     W4,#8,W4
02788:  CP.B    W4L,#1
0278A:  BRA     NZ,278C
....................    { 
....................       #if defined(SUPPORT_LFN) 
....................          supportLFN = TRUE; 
....................       #endif 
....................    } 
....................  
....................    #if defined(SUPPORT_LFN) 
....................    if(NAME_8P3_UTF16_TYPE == fileNameType) 
....................    { 
....................       for (count3 = 0; count3 < temp; count3++) 
....................       { 
....................          if(utf16Filename[count3] > 0xFF) 
....................          { 
....................             fileNameType = NAME_8P3_UTF16_NONASCII_TYPE; 
....................             supportLFN = TRUE; 
....................             break; 
....................          } 
....................       } 
....................  
....................       if(count3 == temp) 
....................       { 
....................          fileNameType = NAME_8P3_UTF16_ASCII_CAPS_TYPE; 
....................  
....................          for (count3 = 0; count3 < temp; count3++) 
....................          { 
....................             if((utf16Filename[count3] >= 0x61) && (utf16Filename[count3] <= 0x7A)) 
....................             { 
....................                fileNameType = NAME_8P3_UTF16_ASCII_MIXED_TYPE; 
....................                supportLFN = TRUE; 
....................                break; 
....................             } 
....................          } 
....................       } 
....................    } 
....................    #endif 
....................  
....................    // If the file name follows 8P3 type 
....................    if((NAME_LFN_TYPE != fileNameType) && (FALSE == supportLFN)) 
0278C:  MOV     1004,W4
0278E:  LSR     W4,#8,W4
02790:  CP.B    W4L,#6
02792:  BRA     Z,28C6
02794:  BTSC.B  1012.0
02796:  BRA     28C6
....................    { 
....................       for (count3 = 0; count3 < temp; count3++) 
02798:  CLR     100E
0279A:  MOV     100E,W0
0279C:  MOV     1008,W4
0279E:  CP      W4,W0
027A0:  BRA     LE,27DE
....................       { 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................          { 
....................             if(((utf16Filename[count3] == '.') && ((temp - count3) > 4)) || 
....................                (count3 > 8)) 
....................             { 
....................                // UTF File name extension greater then 3 characters or 
....................                 // UTF File name greater then 8 charcters 
....................                supportLFN = TRUE; 
....................                break; 
....................             } 
....................             else if(utf16Filename[count3] == '.') 
....................             { 
....................                break; 
....................             } 
....................          } 
....................          else 
....................          #endif 
....................          { 
....................             if(((asciiFilename[count3] == '.') && ((temp - count3) > 4)) || 
....................                (count3 > 8)) 
027A2:  MOV     100E,W0
027A4:  ADD     906,W0
027A6:  MOV.B   [W0],W4L
027A8:  XOR.B   #2E,W4L
027AA:  BRA     NZ,27B6
027AC:  MOV     1008,W4
027AE:  MOV     100E,W3
027B0:  SUB     W4,W3,W5
027B2:  CP      W5,#4
027B4:  BRA     GT,27BC
027B6:  MOV     100E,W4
027B8:  CP      W4,#8
027BA:  BRA     LE,27CA
....................             { 
....................                // File extension greater then 3 characters or 
....................                // File name greater then 8 charcters 
....................                #if !defined(SUPPORT_LFN) 
....................                   return FALSE; 
027BC:  CLR.B   0
027BE:  BRA     28DA
....................                #endif 
....................                supportLFN = TRUE; 
027C0:  BSET.B  1012.0
....................                break; 
027C2:  GOTO    27DE
....................             } 
027C6:  GOTO    27D8
....................             else if(asciiFilename[count3] == '.') 
027CA:  MOV     100E,W0
027CC:  ADD     906,W0
027CE:  MOV.B   [W0],W4L
027D0:  XOR.B   #2E,W4L
027D2:  BRA     NZ,27D8
....................             { 
....................                break; 
027D4:  GOTO    27DE
....................             } 
....................          } 
027D8:  INC     100E
027DA:  GOTO    279A
....................       } 
....................  
....................       // If LFN not supported try to adjust in 8P3 format 
....................       if(FALSE == supportLFN) 
027DE:  BTSC.B  1012.0
027E0:  BRA     28C6
....................       { 
....................           // point fN2 to short file name 
....................           fN2 = fptr -> name; 
027E2:  MOV     #1C,W0
027E4:  ADD     1002,W0
027E6:  MOV     W0,1006
....................  
....................           // Load destination filename to be space intially. 
....................           for (count1 = 0; count1 < FILE_NAME_SIZE_8P3; count1++) 
027E8:  CLR     100A
027EA:  MOV     100A,W4
027EC:  CP      W4,#B
027EE:  BRA     GE,2800
....................           { 
....................               *(fN2 + count1) = ' '; 
027F0:  MOV     1006,W0
027F2:  ADD     100A,W0
027F4:  MOV     W0,W5
027F6:  MOV.B   #20,W0L
027F8:  MOV.B   W0L,[W5]
027FA:  INC     100A
027FC:  GOTO    27EA
....................           } 
....................  
....................          // multiply the length by 2 as each UTF word has 2 byte 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................          { 
....................             count4 = count3 * 2; 
....................             temp = temp * 2; 
....................             localFileName = (char *)utf16Filename; 
....................          } 
....................          else 
....................          #endif 
....................          { 
....................             count4 = count3; 
02800:  PUSH    100E
02802:  POP     1010
....................             localFileName = asciiFilename; 
02804:  PUSH    906
02806:  POP     1014
....................          } 
....................  
....................           //copy only file name ( not the extension part ) 
....................           for (count1 = 0,count2 = 0; (count2 < 8) && (count1 < count4);count1++ ) 
02808:  CLR     100A
0280A:  CLR     100C
0280C:  MOV     100C,W4
0280E:  CP      W4,#8
02810:  BRA     GE,2862
02812:  MOV     100A,W0
02814:  MOV     1010,W4
02816:  CP      W4,W0
02818:  BRA     LE,2862
....................           { 
....................             if(localFileName[count1]) 
0281A:  MOV     100A,W0
0281C:  ADD     1014,W0
0281E:  CP0.B   [W0]
02820:  BRA     Z,285C
....................             { 
....................                fN2[count2] = localFileName[count1]; // Destination filename initially filled with SPACE. Now copy only available chars. 
02822:  MOV     100C,W0
02824:  ADD     1006,W0
02826:  MOV     W0,W5
02828:  MOV     100A,W0
0282A:  ADD     1014,W0
0282C:  MOV.B   [W0],[W5]
....................  
....................                 // Convert lower-case to upper-case 
....................                 if ((fN2[count2] >= 0x61) && (fN2[count2] <= 0x7A)) 
0282E:  MOV     100C,W0
02830:  ADD     1006,W0
02832:  MOV.B   [W0],W5L
02834:  SE      W5,W5
02836:  MOV     #61,W4
02838:  CP      W4,W5
0283A:  BRA     GT,285A
0283C:  MOV     100C,W0
0283E:  ADD     1006,W0
02840:  MOV.B   [W0],W5L
02842:  SE      W5,W5
02844:  MOV     #7A,W4
02846:  CP      W4,W5
02848:  BRA     LT,285A
....................                 { 
....................                     fN2[count2] -= 0x20; 
0284A:  MOV     100C,W0
0284C:  ADD     1006,W0
0284E:  MOV     W0,W5
02850:  MOV.B   [W5],W4L
02852:  CLR.B   9
02854:  MOV     #20,W3
02856:  SUB     W4,W3,W0
02858:  MOV.B   W0L,[W5]
....................                } 
....................                count2++; 
0285A:  INC     100C
....................             } 
0285C:  INC     100A
0285E:  GOTO    280C
....................           } 
....................  
....................          if(count4 < temp) 
02862:  MOV     1010,W0
02864:  MOV     1008,W4
02866:  CP      W4,W0
02868:  BRA     LE,28C6
....................          { 
....................             // Discard the '.' part 
....................             count4++; 
0286A:  INC     1010
....................  
....................               // Copy the extn to 8th position onwards. Ex: "FILE    .Tx " 
....................               for (count3 = 8; (count3 < 11) && (count4 < temp);count4++ ) 
0286C:  MOV     #8,W4
0286E:  MOV     W4,100E
02870:  MOV     100E,W4
02872:  CP      W4,#B
02874:  BRA     GE,28C6
02876:  MOV     1010,W0
02878:  MOV     1008,W4
0287A:  CP      W4,W0
0287C:  BRA     LE,28C6
....................               { 
....................                if(localFileName[count4]) 
0287E:  MOV     1010,W0
02880:  ADD     1014,W0
02882:  CP0.B   [W0]
02884:  BRA     Z,28C0
....................                { 
....................                      fN2[count3] = localFileName[count4]; 
02886:  MOV     100E,W0
02888:  ADD     1006,W0
0288A:  MOV     W0,W5
0288C:  MOV     1010,W0
0288E:  ADD     1014,W0
02890:  MOV.B   [W0],[W5]
....................  
....................                       // Convert lower-case to upper-case 
....................                       if ((fN2[count3] >= 0x61) && (fN2[count3] <= 0x7A)) 
02892:  MOV     100E,W0
02894:  ADD     1006,W0
02896:  MOV.B   [W0],W5L
02898:  SE      W5,W5
0289A:  MOV     #61,W4
0289C:  CP      W4,W5
0289E:  BRA     GT,28BE
028A0:  MOV     100E,W0
028A2:  ADD     1006,W0
028A4:  MOV.B   [W0],W5L
028A6:  SE      W5,W5
028A8:  MOV     #7A,W4
028AA:  CP      W4,W5
028AC:  BRA     LT,28BE
....................                       { 
....................                           fN2[count3] -= 0x20; 
028AE:  MOV     100E,W0
028B0:  ADD     1006,W0
028B2:  MOV     W0,W5
028B4:  MOV.B   [W5],W4L
028B6:  CLR.B   9
028B8:  MOV     #20,W3
028BA:  SUB     W4,W3,W0
028BC:  MOV.B   W0L,[W5]
....................                   } 
....................                   count3++; 
028BE:  INC     100E
....................                } 
028C0:  INC     1010
028C2:  GOTO    2870
....................               } 
....................          } 
....................       } 
....................    } 
....................  
....................    // If the file name follows LFN format 
....................     if((NAME_LFN_TYPE == fileNameType) || (TRUE == supportLFN)) 
028C6:  MOV     1004,W4
028C8:  LSR     W4,#8,W4
028CA:  CP.B    W4L,#6
028CC:  BRA     Z,28D2
028CE:  BTSS.B  1012.0
028D0:  BRA     28D6
....................    { 
....................       #if defined(SUPPORT_LFN) 
....................  
....................          // point fN2 to long file name 
....................          fN2 = (char *)(fptr -> utf16LFNptr); 
....................  
....................          if(!utfModeFileName) 
....................          { 
....................             localFileName = asciiFilename; 
....................          } 
....................  
....................          // Copy the LFN name in the adress specified by FSFILE pointer 
....................          count2 = 0; 
....................          for(count1 = 0;count1 < temp;count1++) 
....................          { 
....................             if(utfModeFileName) 
....................             { 
....................                fptr -> utf16LFNptr[count1] = utf16Filename[count1]; 
....................                if(AscciIndication) 
....................                { 
....................                   if(utf16Filename[count1] > 0xFF) 
....................                   { 
....................                      fptr->AsciiEncodingType = FALSE; 
....................                      AscciIndication = FALSE; 
....................                   } 
....................                } 
....................             } 
....................             else 
....................             { 
....................                fN2[count2++] = localFileName[count1]; 
....................                fN2[count2++] = (BYTE)0x00; 
....................             } 
....................          } 
....................          fptr -> utf16LFNptr[count1] = 0x0000; 
....................  
....................          fptr->utf16LFNlength = fileNameLength; 
....................       #else 
....................          return FALSE; 
028D2:  CLR.B   0
028D4:  BRA     28DA
....................       #endif 
....................    } 
....................  
....................    // Free the temporary heap used for intermediate execution 
....................    return TRUE; 
028D6:  MOV.B   #1,W0L
028D8:  MOV.B   W0L,0
028DA:  MOV     [--W15],W7
028DC:  MOV     [--W15],W6
028DE:  MOV     [--W15],W5
028E0:  RETURN  
.................... } 
....................  
.................... #ifdef ALLOW_DIRS 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE FormatDirName (char * string,FILEOBJ fptr, BYTE mode) 
....................   Summary: 
....................     Format a dir name into dir entry format 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     string -  The name to be formatted 
....................     mode - 
....................          - TRUE -  Partial string search characters are allowed 
....................          - FALSE - Partial string search characters are forbidden 
....................   Return Values: 
....................     TRUE - The name was formatted correctly 
....................     FALSE - The name contained invalid characters 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     Format an 8.3 filename into directory structure format. If the name is less 
....................     than 8 chars, then it will be padded with spaces. If the extension name is 
....................     fewer than 3 chars, then it will also be oadded with spaces. The 
....................     ValidateChars function is used to ensure the characters in the specified 
....................     directory name are valid in this filesystem. 
....................   Remarks: 
....................     None. 
....................   *************************************************************************/ 
....................  
.................... BYTE FormatDirName (char * string,FILEOBJ fptr, BYTE mode) 
*
05F64:  MOV     W5,[W15++]
05F66:  MOV     W6,[W15++]
05F68:  MOV     W7,[W15++]
*
05F7E:  BCLR.B  101A.0
.................... { 
....................     char tempString [12]; 
*
05F6A:  CLR     1008
05F6C:  CLR     100A
05F6E:  CLR     100C
05F70:  CLR     100E
05F72:  CLR     1010
05F74:  CLR     1012
....................    FILE_DIR_NAME_TYPE fileNameType; 
05F76:  CLR.B   1007
....................     int temp,count1,count2; 
05F78:  CLR     1014
05F7A:  CLR     1016
05F7C:  CLR     1018
....................     BOOL supportLFN = FALSE; 
....................    char *localFileName; 
*
05F80:  CLR     101C
....................  
....................    // go with static allocation 
....................    #if defined(SUPPORT_LFN) 
....................        int count3,count4; 
....................       BOOL   AscciIndication = TRUE; 
....................       count1 = 256; 
....................    #else 
....................       count1 = 12; 
05F82:  MOV     #C,W4
05F84:  MOV     W4,1016
....................    #endif 
....................  
....................    // Calculate the String length 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................    { 
....................       utf16Filename = (unsigned short int *)string; 
....................       fileNameLength = 0; 
....................       while(utf16Filename[fileNameLength]) 
....................       { 
....................          fileNameLength++; 
....................       } 
....................    } 
....................    else 
....................    #endif 
....................    { 
....................       asciiFilename = string; 
05F86:  PUSH    1002
05F88:  POP     906
....................       fileNameLength = strlen(string); 
05F8A:  PUSH    1002
05F8C:  POP     1036
05F8E:  CALL    25A8
05F92:  MOV     W0,D2C
....................    } 
....................  
....................    if(fileNameLength > count1) 
05F94:  MOV     1016,W0
05F96:  MOV     D2C,W4
05F98:  CP      W4,W0
05F9A:  BRA     LE,5FA0
....................    { 
....................       return FALSE; 
05F9C:  CLR.B   0
05F9E:  BRA     60D4
....................    } 
....................  
....................     // Make sure the characters are valid 
....................     fileNameType = ValidateChars(mode); 
05FA0:  MOV.B   1006,W0L
05FA2:  MOV.B   W0L,1036
05FA4:  CALL    25C8
05FA8:  MOV.B   W0L,1007
....................  
....................     // If the file name doesn't follow 8P3 or LFN format, then return FALSE 
....................     if(NAME_ERROR == fileNameType) 
05FAA:  MOV     1006,W4
05FAC:  LSR     W4,#8,W4
05FAE:  CP.B    W4L,#7
05FB0:  BRA     NZ,5FB6
....................    { 
....................       return FALSE; 
05FB2:  CLR.B   0
05FB4:  BRA     60D4
....................    } 
....................  
....................    temp = fileNameLength; 
05FB6:  PUSH    D2C
05FB8:  POP     1014
....................  
....................    #if defined(SUPPORT_LFN) 
....................       fptr->AsciiEncodingType = TRUE; 
....................       fptr->utf16LFNlength = 0; 
....................    #endif 
....................  
....................    // If LFN is supported and the file name is UTF16 type or Ascii mixed type, 
....................    // go for LFN support rather than trying to adjust in 8P3 format 
....................    if(NAME_8P3_ASCII_MIXED_TYPE == fileNameType) 
05FBA:  MOV     1006,W4
05FBC:  LSR     W4,#8,W4
05FBE:  CP.B    W4L,#1
05FC0:  BRA     NZ,5FC2
....................    { 
....................       #if defined(SUPPORT_LFN) 
....................          supportLFN = TRUE; 
....................       #endif 
....................    } 
....................  
....................    #if defined(SUPPORT_LFN) 
....................    if(NAME_8P3_UTF16_TYPE == fileNameType) 
....................    { 
....................       for (count3 = 0; count3 < temp; count3++) 
....................       { 
....................          if(utf16Filename[count3] > 0xFF) 
....................          { 
....................             fileNameType = NAME_8P3_UTF16_NONASCII_TYPE; 
....................             supportLFN = TRUE; 
....................             break; 
....................          } 
....................       } 
....................  
....................       if(count3 == temp) 
....................       { 
....................          fileNameType = NAME_8P3_UTF16_ASCII_CAPS_TYPE; 
....................  
....................          for (count3 = 0; count3 < temp; count3++) 
....................          { 
....................             if((utf16Filename[count3] >= 0x61) && (utf16Filename[count3] <= 0x7A)) 
....................             { 
....................                fileNameType = NAME_8P3_UTF16_ASCII_MIXED_TYPE; 
....................                supportLFN = TRUE; 
....................                break; 
....................             } 
....................          } 
....................       } 
....................    } 
....................    #endif 
....................  
....................    // If the file name follows LFN format 
....................     if((NAME_LFN_TYPE == fileNameType) || (TRUE == supportLFN)) 
05FC2:  MOV     1006,W4
05FC4:  LSR     W4,#8,W4
05FC6:  CP.B    W4L,#6
05FC8:  BRA     Z,5FCE
05FCA:  BTSS.B  101A.0
05FCC:  BRA     5FD6
....................    { 
....................       #if !defined(SUPPORT_LFN) 
....................            return FALSE; 
05FCE:  CLR.B   0
05FD0:  BRA     60D4
....................       #else 
....................          fptr -> utf16LFNptr = (unsigned short int *)string; 
....................  
....................          if(utfModeFileName) 
....................          { 
....................             if(utf16Filename != (unsigned short int *)string) 
....................             { 
....................                // Copy the validated/Fomated name in the UTF16 string 
....................                for(count1 = 0; count1 < temp; count1++) 
....................                { 
....................                   fptr -> utf16LFNptr[count1] = utf16Filename[count1]; 
....................                   if(AscciIndication) 
....................                   { 
....................                      if(utf16Filename[count1] > 0xFF) 
....................                      { 
....................                         fptr->AsciiEncodingType = FALSE; 
....................                         AscciIndication = FALSE; 
....................                      } 
....................                   } 
....................                } 
....................                fptr -> utf16LFNptr[count1] = 0x0000; 
....................             } 
....................             else 
....................             { 
....................                for(count1 = 0; count1 < temp; count1++) 
....................                { 
....................                   if(AscciIndication) 
....................                   { 
....................                      if(utf16Filename[count1] > 0xFF) 
....................                      { 
....................                         fptr->AsciiEncodingType = FALSE; 
....................                         AscciIndication = FALSE; 
....................                         break; 
....................                      } 
....................                   } 
....................                } 
....................             } 
....................          } 
....................          else 
....................          { 
....................             #ifdef FS_DYNAMIC_MEM 
....................                 unsigned short int *tempAsciiLFN = (unsigned short int *)FS_malloc((temp + 1) * 2); 
....................             #else 
....................                unsigned short int   tempAsciiLFN[temp + 1]; 
....................             #endif 
....................  
....................             localFileName = (char *)tempAsciiLFN; 
....................  
....................             // Copy the validated/Fomated name in the Ascii string 
....................             count2 = 0; 
....................  
....................             for(count1 = 0; count1 < temp; count1++) 
....................             { 
....................                localFileName[count2++] = asciiFilename[count1]; 
....................  
....................                localFileName[count2++] = (BYTE)0x00; 
....................  
....................             } 
....................  
....................             // Copy the validated/Fomated name in the UTF16 string 
....................             for(count1 = 0; count1 < temp; count1++) 
....................             { 
....................                fptr -> utf16LFNptr[count1] = tempAsciiLFN[count1]; 
....................             } 
....................  
....................             #ifdef FS_DYNAMIC_MEM 
....................                 FS_free((unsigned char *)tempAsciiLFN); 
....................             #endif 
....................             fptr -> utf16LFNptr[count1] = 0x0000; 
....................          } 
....................  
....................          fptr->utf16LFNlength = fileNameLength; 
....................       #endif 
....................    } 
05FD2:  GOTO    60D0
....................    else 
....................    { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................       { 
....................          localFileName = (char *)utf16Filename; 
....................  
....................          // Copy the name part in the temporary string 
....................           count4 = 0; 
....................           for (count3 = 0; (count3 < temp) && (utf16Filename[count3] != '.') && (utf16Filename[count3] != 0); count3++) 
....................           { 
....................             count1 = count3 * 2; 
....................             if(localFileName[count1]) 
....................             { 
....................                  tempString[count4] = localFileName[count1]; 
....................                count4++; 
....................                if(count4 == 8) 
....................                   break; 
....................             } 
....................  
....................             if(localFileName[count1 + 1]) 
....................             { 
....................                  tempString[count4] = localFileName[count1 + 1]; 
....................                count4++; 
....................                if(count4 == 8) 
....................                   break; 
....................             } 
....................           } 
....................  
....................          // File the remaining name portion with spaces 
....................           while (count4 < 8) 
....................           { 
....................               tempString [count4++] = 0x20; 
....................           } 
....................  
....................          // Copy the extension part in the temporary string 
....................           if (utf16Filename[count3] == '.') 
....................           { 
....................             count1 = count3 * 2 + 2; 
....................               while (localFileName[count1] != 0) 
....................               { 
....................                if(localFileName[count3]) 
....................                { 
....................                     tempString[count4] = localFileName[count3]; 
....................                   count4++; 
....................                   if(count4 == 11) 
....................                      break; 
....................                } 
....................               } 
....................           } 
....................  
....................          count1 = count4; 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................          // Copy the name part in the temporary string 
....................           for (count1 = 0; (count1 < 8) && (*(asciiFilename + count1) != '.') && (*(asciiFilename + count1) != 0); count1++) 
05FD6:  CLR     1016
05FD8:  MOV     1016,W4
05FDA:  CP      W4,#8
05FDC:  BRA     GE,6006
05FDE:  MOV     906,W0
05FE0:  ADD     1016,W0
05FE2:  MOV.B   [W0],W4L
05FE4:  XOR.B   #2E,W4L
05FE6:  BRA     Z,6006
05FE8:  MOV     906,W0
05FEA:  ADD     1016,W0
05FEC:  MOV.B   [W0],W5L
05FEE:  SE      W5,W5
05FF0:  CP0     W5
05FF2:  BRA     Z,6006
....................           { 
....................               tempString[count1] = *(asciiFilename + count1); 
05FF4:  MOV     #1008,W4
05FF6:  MOV     1016,W3
05FF8:  ADD     W3,W4,W5
05FFA:  MOV     906,W0
05FFC:  ADD     1016,W0
05FFE:  MOV.B   [W0],[W5]
06000:  INC     1016
06002:  GOTO    5FD8
....................           } 
....................  
....................          count2 = count1; 
06006:  PUSH    1016
06008:  POP     1018
....................  
....................          // File the remaining name portion with spaces 
....................           while (count1 < 8) 
0600A:  MOV     1016,W4
0600C:  CP      W4,#8
0600E:  BRA     GE,6022
....................           { 
....................               tempString [count1++] = 0x20; 
06010:  MOV     1016,W0
06012:  INC     1016
06014:  MOV     W0,W5
06016:  MOV     #1008,W4
06018:  ADD     W5,W4,W6
0601A:  MOV.B   #20,W0L
0601C:  MOV.B   W0L,[W6]
0601E:  GOTO    600A
....................           } 
....................  
....................          // Copy the extension part in the temporary string 
....................           if (*(asciiFilename + count2) == '.') 
06022:  MOV     906,W0
06024:  ADD     1018,W0
06026:  MOV.B   [W0],W4L
06028:  XOR.B   #2E,W4L
0602A:  BRA     NZ,6058
....................           { 
....................               count2++; 
0602C:  INC     1018
....................               while ((*(asciiFilename + count2) != 0) && (count1 < FILE_NAME_SIZE_8P3)) 
0602E:  MOV     906,W0
06030:  ADD     1018,W0
06032:  MOV.B   [W0],W5L
06034:  SE      W5,W5
06036:  CP0     W5
06038:  BRA     Z,6058
0603A:  MOV     1016,W4
0603C:  CP      W4,#B
0603E:  BRA     GE,6058
....................               { 
....................                   tempString[count1++] = *(asciiFilename + count2++); 
06040:  MOV     1016,W0
06042:  INC     1016
06044:  MOV     W0,W5
06046:  MOV     #1008,W4
06048:  ADD     W5,W4,W6
0604A:  MOV     1018,W0
0604C:  INC     1018
0604E:  MOV     906,W4
06050:  ADD     W0,W4,W0
06052:  MOV.B   [W0],[W6]
06054:  GOTO    602E
....................               } 
....................           } 
....................       } 
....................  
....................       // File the remaining portion with spaces 
....................       while (count1 < FILE_NAME_SIZE_8P3) 
06058:  MOV     1016,W4
0605A:  CP      W4,#B
0605C:  BRA     GE,6070
....................       { 
....................           tempString[count1++] = 0x20; 
0605E:  MOV     1016,W0
06060:  INC     1016
06062:  MOV     W0,W5
06064:  MOV     #1008,W4
06066:  ADD     W5,W4,W6
06068:  MOV.B   #20,W0L
0606A:  MOV.B   W0L,[W6]
0606C:  GOTO    6058
....................       } 
....................  
....................       // Forbidden 
....................       if (tempString[0] == 0x20) 
06070:  MOV.B   1008,W0L
06072:  SE      W0,W0
06074:  MOV     #20,W4
06076:  CP      W4,W0
06078:  BRA     NZ,607E
....................       { 
....................           tempString[0] = '_'; 
0607A:  MOV.B   #5F,W0L
0607C:  MOV.B   W0L,1008
....................       } 
....................  
....................       // point fN2 to short file name 
....................       localFileName = fptr -> name; 
0607E:  MOV     #1C,W0
06080:  ADD     1004,W0
06082:  MOV     W0,101C
....................  
....................       // Copy the formated name in string 
....................       for (count1 = 0; count1 < FILE_NAME_SIZE_8P3; count1++) 
06084:  CLR     1016
06086:  MOV     1016,W4
06088:  CP      W4,#B
0608A:  BRA     GE,60D0
....................       { 
....................           localFileName[count1] = tempString[count1]; 
0608C:  MOV     1016,W0
0608E:  ADD     101C,W0
06090:  MOV     W0,W5
06092:  MOV     #1008,W4
06094:  MOV     1016,W3
06096:  ADD     W3,W4,W0
06098:  MOV.B   [W0],[W5]
....................  
....................          // Convert lower-case to upper-case 
....................          if ((tempString[count1] >= 0x61) && (tempString[count1] <= 0x7A)) 
0609A:  MOV     #1008,W4
0609C:  MOV     1016,W3
0609E:  ADD     W3,W4,W0
060A0:  MOV.B   [W0],W5L
060A2:  SE      W5,W5
060A4:  MOV     #61,W4
060A6:  CP      W4,W5
060A8:  BRA     GT,60CA
060AA:  MOV     #1008,W4
060AC:  MOV     1016,W3
060AE:  ADD     W3,W4,W0
060B0:  MOV.B   [W0],W5L
060B2:  SE      W5,W5
060B4:  MOV     #7A,W4
060B6:  CP      W4,W5
060B8:  BRA     LT,60CA
....................          { 
....................              localFileName[count1] -= 0x20; 
060BA:  MOV     1016,W0
060BC:  ADD     101C,W0
060BE:  MOV     W0,W5
060C0:  MOV.B   [W5],W4L
060C2:  CLR.B   9
060C4:  MOV     #20,W3
060C6:  SUB     W4,W3,W0
060C8:  MOV.B   W0L,[W5]
....................          } 
060CA:  INC     1016
060CC:  GOTO    6086
....................       } 
....................    } 
....................  
....................    return TRUE; 
060D0:  MOV.B   #1,W0L
060D2:  MOV.B   W0L,0
060D4:  MOV     [--W15],W7
060D6:  MOV     [--W15],W6
060D8:  MOV     [--W15],W5
060DA:  RETURN  
.................... } 
.................... #endif 
....................  
....................  
.................... /************************************************************* 
....................   Function: 
....................     FILE_DIR_NAME_TYPE ValidateChars(BYTE mode) 
....................   Summary: 
....................     Validate the characters in a given file name 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fileName -  The name to be validated 
....................     mode -      Determines if partial string search is allowed 
....................   Return Values: 
....................     TRUE - Name was validated 
....................     FALSE - File name was not valid 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The ValidateChars function will compare characters in a 
....................     specified filename to determine if they're permissable 
....................     in the FAT file system.  Lower-case characters will be 
....................     converted to upper-case.  If the mode argument is specifed 
....................     to be 'TRUE,' partial string search characters are allowed. 
....................   Remarks: 
....................     None. 
....................   *************************************************************/ 
.................... FILE_DIR_NAME_TYPE ValidateChars(BYTE mode) 
*
025CC:  CLR.B   103A
.................... { 
....................    FILE_DIR_NAME_TYPE fileNameType; 
*
025C8:  CLR.B   1037
....................     unsigned short int count1; 
025CA:  CLR     1038
....................    #if defined(SUPPORT_LFN) 
....................    unsigned short int utf16Value; 
....................     unsigned short int count2; 
....................    int      count3; 
....................    #endif 
....................     unsigned char radix = FALSE,asciiValue; 
*
025CE:  CLR.B   103B
....................  
....................    #if defined(SUPPORT_LFN) 
....................  
....................       // Remove the spaces if they are present before the file name 
....................       for (count1 = 0; count1 < fileNameLength; count1++) 
....................       { 
....................            if(utfModeFileName) 
....................          { 
....................             if((utf16Filename[count1] != ' ') && (utf16Filename[count1] != '.')) 
....................             { 
....................                utf16Filename = utf16Filename + count1; 
....................                break; 
....................             } 
....................          } 
....................          else if((asciiFilename[count1] != ' ') && (asciiFilename[count1] != '.')) 
....................          { 
....................             asciiFilename = asciiFilename + count1; 
....................             break; 
....................           } 
....................        } 
....................  
....................        count2 = 0; 
....................  
....................       // Remove the spaces  & dots if they are present after the file name 
....................        for (count3 = fileNameLength - count1 - 1; count3 > 0; count3--) 
....................        { 
....................            if(utfModeFileName) 
....................          { 
....................             if((utf16Filename[count3] != ' ') && (utf16Filename[count3] != '.')) 
....................             { 
....................                break; 
....................             } 
....................          } 
....................          else if((asciiFilename[count3] != ' ') && (asciiFilename[count3] != '.')) 
....................          { 
....................             break; 
....................           } 
....................  
....................           count2++; 
....................        } 
....................  
....................       fileNameLength = fileNameLength - count1 - count2; 
....................  
....................        if(( fileNameLength > MAX_FILE_NAME_LENGTH_LFN ) || (fileNameLength == 0))// 255 
....................            return NAME_ERROR; //long file name 
....................  
....................     #endif 
....................  
....................     // If the string length is greater then 8P3 length, then assume 
....................    // the file name as LFN type provided there are no errors in the 
....................    // below for loop. 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................    { 
....................       if((fileNameLength * 2) > (TOTAL_FILE_SIZE_8P3 * 2)) 
....................       { 
....................          fileNameType = NAME_LFN_TYPE; 
....................       } 
....................       else 
....................       { 
....................          fileNameType = NAME_8P3_UTF16_TYPE; 
....................       } 
....................    } 
....................    else 
....................    #endif 
....................    { 
....................       if(fileNameLength > TOTAL_FILE_SIZE_8P3) 
025D0:  MOV     D2C,W4
025D2:  CP      W4,#C
025D4:  BRA     LEU,25DE
....................       { 
....................          fileNameType = NAME_LFN_TYPE; 
025D6:  MOV.B   #6,W0L
025D8:  MOV.B   W0L,1037
....................       } 
025DA:  GOTO    25E0
....................       else 
....................       { 
....................          fileNameType = NAME_8P3_ASCII_CAPS_TYPE; 
025DE:  CLR.B   1037
....................       } 
....................    } 
....................  
....................    for( count1 = 0; count1 < fileNameLength; count1++ ) 
025E0:  CLR     1038
025E2:  MOV     1038,W0
025E4:  MOV     D2C,W4
025E6:  CP      W4,W0
025E8:  BRA     LEU,26E8
....................    { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................       { 
....................          utf16Value = utf16Filename[count1]; 
....................           // Characters not valid for either of 8P3 & LFN format 
....................           if (((utf16Value < 0x20) && (utf16Value != 0x05)) || (utf16Value == 0x22) || 
....................             (utf16Value == 0x2F) || (utf16Value == 0x3A) || (utf16Value == 0x3C) || 
....................               (utf16Value == 0x3E) || (utf16Value == 0x5C) || (utf16Value == 0x7C)) 
....................           { 
....................               return NAME_ERROR; 
....................           } 
....................  
....................            // Check for partial string search chars 
....................            if (mode == FALSE) 
....................            { 
....................                if ((utf16Value == '*') || (utf16Value == '?')) 
....................                { 
....................                  return NAME_ERROR; 
....................               } 
....................            } 
....................  
....................          if(fileNameType != NAME_LFN_TYPE) 
....................          { 
....................             // Characters valid for LFN format only 
....................              if ((utf16Value == 0x20) || (utf16Value == 0x2B) || (utf16Value == 0x2C) || 
....................                (utf16Value == 0x3B) || (utf16Value == 0x3D) || (utf16Value == 0x5B) || 
....................                (utf16Value == 0x5D) || ((utf16Value == 0x2E) && (radix == TRUE))) 
....................              { 
....................                fileNameType = NAME_LFN_TYPE; 
....................                continue; 
....................              } 
....................  
....................               // only one radix ('.') character is allowed in 8P3 format, where as 
....................             // multiple radices can be present in LFN format 
....................               if (utf16Filename[count1] == 0x2E) 
....................               { 
....................                   radix = TRUE; 
....................               } 
....................          } 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................          asciiValue = asciiFilename[count1]; 
025EA:  MOV     1038,W0
025EC:  ADD     906,W0
025EE:  MOV     W0,[W15++]
025F0:  MOV.B   [W0],W0L
025F2:  MOV.B   W0L,103B
025F4:  MOV     [--W15],W0
....................          if(((asciiValue < 0x20) && (asciiValue != 0x05)) || (asciiValue == 0x22) || 
....................             (asciiValue == 0x2F) || (asciiValue == 0x3A) || (asciiValue == 0x3C) || 
....................             (asciiValue == 0x3E) || (asciiValue == 0x5C) || (asciiValue == 0x7C)) 
025F6:  MOV     103A,W4
025F8:  LSR     W4,#8,W4
025FA:  MOV     #20,W3
025FC:  CP.B    W3L,W4L
025FE:  BRA     LEU,2608
02600:  MOV     103A,W4
02602:  LSR     W4,#8,W4
02604:  CP.B    W4L,#5
02606:  BRA     NZ,2640
02608:  MOV     103A,W4
0260A:  LSR     W4,#8,W4
0260C:  XOR.B   #22,W4L
0260E:  BRA     Z,2640
02610:  MOV     103A,W4
02612:  LSR     W4,#8,W4
02614:  XOR.B   #2F,W4L
02616:  BRA     Z,2640
02618:  MOV     103A,W4
0261A:  LSR     W4,#8,W4
0261C:  XOR.B   #3A,W4L
0261E:  BRA     Z,2640
02620:  MOV     103A,W4
02622:  LSR     W4,#8,W4
02624:  XOR.B   #3C,W4L
02626:  BRA     Z,2640
02628:  MOV     103A,W4
0262A:  LSR     W4,#8,W4
0262C:  XOR.B   #3E,W4L
0262E:  BRA     Z,2640
02630:  MOV     103A,W4
02632:  LSR     W4,#8,W4
02634:  XOR.B   #5C,W4L
02636:  BRA     Z,2640
02638:  MOV     103A,W4
0263A:  LSR     W4,#8,W4
0263C:  XOR.B   #7C,W4L
0263E:  BRA     NZ,2646
....................          { 
....................             return NAME_ERROR; 
02640:  MOV.B   #7,W0L
02642:  MOV.B   W0L,0
02644:  BRA     26EA
....................          } 
....................  
....................            // Check for partial string search chars 
....................            if (mode == FALSE) 
02646:  CP0.B   1036
02648:  BRA     NZ,2660
....................            { 
....................                if ((asciiValue == '*') || (asciiValue == '?')) 
0264A:  MOV     103A,W4
0264C:  LSR     W4,#8,W4
0264E:  XOR.B   #2A,W4L
02650:  BRA     Z,265A
02652:  MOV     103A,W4
02654:  LSR     W4,#8,W4
02656:  XOR.B   #3F,W4L
02658:  BRA     NZ,2660
....................                { 
....................                  return NAME_ERROR; 
0265A:  MOV.B   #7,W0L
0265C:  MOV.B   W0L,0
0265E:  BRA     26EA
....................               } 
....................            } 
....................  
....................          if(fileNameType != NAME_LFN_TYPE) 
02660:  MOV     1036,W4
02662:  LSR     W4,#8,W4
02664:  CP.B    W4L,#6
02666:  BRA     Z,26E2
....................          { 
....................             // Characters valid for LFN format only 
....................              if ((asciiValue == 0x20) || (asciiValue == 0x2B) || (asciiValue == 0x2C) || 
....................                 (asciiValue == 0x3B) || (asciiValue == 0x3D) || (asciiValue == 0x5B) || 
....................                  (asciiValue == 0x5D) || ((asciiValue == 0x2E) && (radix == TRUE))) 
02668:  MOV     103A,W4
0266A:  LSR     W4,#8,W4
0266C:  XOR.B   #20,W4L
0266E:  BRA     Z,26AE
02670:  MOV     103A,W4
02672:  LSR     W4,#8,W4
02674:  XOR.B   #2B,W4L
02676:  BRA     Z,26AE
02678:  MOV     103A,W4
0267A:  LSR     W4,#8,W4
0267C:  XOR.B   #2C,W4L
0267E:  BRA     Z,26AE
02680:  MOV     103A,W4
02682:  LSR     W4,#8,W4
02684:  XOR.B   #3B,W4L
02686:  BRA     Z,26AE
02688:  MOV     103A,W4
0268A:  LSR     W4,#8,W4
0268C:  XOR.B   #3D,W4L
0268E:  BRA     Z,26AE
02690:  MOV     103A,W4
02692:  LSR     W4,#8,W4
02694:  XOR.B   #5B,W4L
02696:  BRA     Z,26AE
02698:  MOV     103A,W4
0269A:  LSR     W4,#8,W4
0269C:  XOR.B   #5D,W4L
0269E:  BRA     Z,26AE
026A0:  MOV     103A,W4
026A2:  LSR     W4,#8,W4
026A4:  XOR.B   #2E,W4L
026A6:  BRA     NZ,26B6
026A8:  MOV     103A,W4
026AA:  CP.B    W4L,#1
026AC:  BRA     NZ,26B6
....................              { 
....................                fileNameType = NAME_LFN_TYPE; 
026AE:  MOV.B   #6,W0L
026B0:  MOV.B   W0L,1037
....................                continue; 
026B2:  GOTO    26E2
....................              } 
....................  
....................               // only one radix ('.') character is allowed in 8P3 format, where as 
....................             // multiple radices can be present in LFN format 
....................               if (asciiValue == 0x2E) 
026B6:  MOV     103A,W4
026B8:  LSR     W4,#8,W4
026BA:  XOR.B   #2E,W4L
026BC:  BRA     NZ,26C2
....................               { 
....................                   radix = TRUE; 
026BE:  MOV.B   #1,W0L
026C0:  MOV.B   W0L,103A
....................               } 
....................  
....................             // If the characters are mixed type & are within 8P3 length range 
....................             // then store file type as 8P3 mixed type format 
....................             if(fileNameType != NAME_8P3_ASCII_MIXED_TYPE) 
026C2:  MOV     1036,W4
026C4:  LSR     W4,#8,W4
026C6:  CP.B    W4L,#1
026C8:  BRA     Z,26E2
....................             { 
....................                if((asciiValue >= 0x61) && (asciiValue <= 0x7A)) 
026CA:  MOV     103A,W4
026CC:  LSR     W4,#8,W4
026CE:  MOV     #61,W3
026D0:  CP.B    W3L,W4L
026D2:  BRA     GTU,26E2
026D4:  MOV     103A,W4
026D6:  LSR     W4,#8,W4
026D8:  MOV     #7A,W3
026DA:  CP.B    W3L,W4L
026DC:  BRA     NC,26E2
....................                { 
....................                   fileNameType = NAME_8P3_ASCII_MIXED_TYPE; 
026DE:  MOV.B   #1,W0L
026E0:  MOV.B   W0L,1037
....................                } 
....................             } 
....................          } 
....................       } 
026E2:  INC     1038
026E4:  GOTO    25E2
....................    } 
....................  
....................    return fileNameType; 
026E8:  MOV.B   1037,W0L
026EA:  RETURN  
.................... } 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FSfseek(FSFILE *stream, long offset, int whence) 
....................   Summary: 
....................     Change the current position in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     stream -    Pointer to file structure 
....................     offset -    Offset from base location 
....................     whence - 
....................            - SEEK_SET -  Seek from start of file 
....................            - SEEK_CUR -  Seek from current location 
....................            - SEEK_END -  Seek from end of file (subtract offset) 
....................   Return Values: 
....................     0 -  Operation successful 
....................     -1 - Operation unsuccesful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfseek function will change the current position in the file to 
....................     one specified by the user.  First, an absolute offset is calculated 
....................     using the offset and base location passed in by the user.  Then, the 
....................     position variables are updated, and the sector number that corresponds 
....................     to the new location.  That sector is then loaded.  If the offset 
....................     falls exactly on a cluster boundary, a new cluster will be allocated 
....................     to the file and the position will be set to the first byte of that 
....................     cluster. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int FSfseek(FSFILE *stream, long offset, int whence) 
*
04760:  MOV     W5,[W15++]
04762:  MOV     W6,[W15++]
04764:  MOV     W7,[W15++]
*
04772:  PUSH    FD4
04774:  POP     FE6
04776:  PUSH    FD6
04778:  POP     FE8
.................... { 
....................     DWORD    numsector, temp;   // lba of first sector of first cluster 
*
04766:  CLR     FDA
04768:  CLR     FDC
0476A:  CLR     FDE
0476C:  CLR     FE0
....................     DISK*   dsk;            // pointer to disk structure 
0476E:  CLR     FE2
....................     BYTE   test; 
04770:  CLR.B   FE4
....................     long offset2 = offset; 
....................  
....................     dsk = stream->dsk; 
*
0477A:  MOV     FD2,W4
0477C:  ADD     W4,#0,W4
0477E:  MOV     W4,W0
04780:  MOV     [W0],[W15++]
04782:  POP     FE2
....................  
....................     switch(whence) 
04784:  MOV     FD8,W0
04786:  XOR     #1,W0
04788:  BRA     Z,4794
0478A:  XOR     #3,W0
0478C:  BRA     Z,47AC
0478E:  XOR     #2,W0
04790:  BRA     Z,47C6
04792:  BRA     47C6
....................     { 
....................         case SEEK_CUR: 
....................             // Apply the offset to the current position 
....................             offset2 += stream->seek; 
04794:  MOV     #E,W0
04796:  ADD     FD2,W0
04798:  MOV     W0,W4
0479A:  MOV     #0,W3
0479C:  MOV     [W4++],[W3++]
0479E:  MOV     [W4++],[W3++]
047A0:  ADD     FE6
047A2:  MOV     W1,W0
047A4:  ADDC    FE8,W0
047A6:  MOV     W0,FE8
....................             break; 
047A8:  GOTO    47CA
....................         case SEEK_END: 
....................             // Apply the offset to the end of the file 
....................             offset2 = stream->size - offset2; 
047AC:  MOV     #12,W0
047AE:  ADD     FD2,W0
047B0:  MOV     #A,W4
047B2:  MOV     [W0++],[W4++]
047B4:  MOV     [W0++],[W4++]
047B6:  MOV     FE6,W4
047B8:  SUB     W5,W4,W0
047BA:  MOV     W0,FE6
047BC:  MOV     FE8,W4
047BE:  SUBB    W6,W4,W0
047C0:  MOV     W0,FE8
....................             break; 
047C2:  GOTO    47CA
....................         case SEEK_SET: 
....................             // automatically there 
....................         default: 
....................             break; 
047C6:  GOTO    47CA
....................    } 
....................  
.................... #ifdef ALLOW_WRITES 
....................     if (gNeedDataWrite) 
047CA:  CP0.B   854
047CC:  BRA     Z,47DE
....................         if (flushData()) 
047CE:  CALL    3170
047D2:  CP0.B   W0L
047D4:  BRA     Z,47DE
....................         { 
....................             FSerrno = CE_WRITE_ERROR; 
047D6:  MOV.B   #9,W0L
047D8:  MOV.B   W0L,857
....................             return EOF; 
047DA:  SETM    0
047DC:  BRA     4A1E
....................         } 
.................... #endif 
....................  
....................     // start from the beginning 
....................     temp = stream->cluster; 
047DE:  MOV     #2,W0
047E0:  ADD     FD2,W0
047E2:  MOV     #FDE,W4
047E4:  MOV     [W0++],[W4++]
047E6:  MOV     [W0++],[W4++]
....................     stream->ccls = temp; 
047E8:  MOV     #6,W0
047EA:  ADD     FD2,W0
047EC:  MOV     W0,W5
047EE:  MOV     #FDE,W4
047F0:  MOV     [W4++],[W5++]
047F2:  MOV     [W4++],[W5++]
....................  
....................     temp = stream->size; 
047F4:  MOV     #12,W0
047F6:  ADD     FD2,W0
047F8:  MOV     #FDE,W4
047FA:  MOV     [W0++],[W4++]
047FC:  MOV     [W0++],[W4++]
....................  
....................     if (offset2 > temp) 
047FE:  MOV     FE0,W0
04800:  MOV     FE8,W4
04802:  CP      W4,W0
04804:  BRA     LT,481C
04806:  BRA     GT,4810
04808:  MOV     FDE,W0
0480A:  MOV     FE6,W4
0480C:  CP      W4,W0
0480E:  BRA     LEU,481C
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
04810:  MOV.B   #1F,W0L
04812:  MOV.B   W0L,857
....................         return (-1);      // past the limits 
04814:  SETM    0
04816:  BRA     4A1E
....................     } 
04818:  GOTO    4A1A
....................     else 
....................     { 
....................         // if we are writing we are no longer at the end 
....................         stream->flags.FileWriteEOF = FALSE; 
0481C:  MOV     #16,W0
0481E:  ADD     FD2,W0
04820:  MOV     W0,W5
04822:  MOV     #FB,W4
04824:  AND.B   W4L,[W5],[W5]
....................  
....................         // set the new postion 
....................         stream->seek = offset2; 
04826:  MOV     #E,W0
04828:  ADD     FD2,W0
0482A:  MOV     W0,W5
0482C:  MOV     #FE6,W4
0482E:  MOV     [W4++],[W5++]
04830:  MOV     [W4++],[W5++]
....................  
....................         // figure out how many sectors 
....................         numsector = offset2 / dsk->sectorSize; 
04832:  MOV     FE2,W4
04834:  ADD     W4,#18,W4
04836:  MOV     W4,W0
04838:  MOV     #A,W1
0483A:  MOV     W0,W2
0483C:  REPEAT  #3
0483E:  MOV.B   [W2++],[W1++]
04840:  BCLR.B  43.0
04842:  MOV     FE6,W0
04844:  MOV     FE8,W1
04846:  MOV     W5,W2
04848:  MOV     W6,W3
0484A:  CALL    45F6
0484E:  MOV     W0,FDA
04850:  MOV     W1,FDC
....................  
....................         // figure out how many bytes off of the offset 
....................         offset2 = offset2 - (numsector * dsk->sectorSize); 
04852:  MOV     FE2,W4
04854:  ADD     W4,#18,W4
04856:  MOV     W4,W0
04858:  MOV     #A,W1
0485A:  MOV     W0,W2
0485C:  REPEAT  #3
0485E:  MOV.B   [W2++],[W1++]
04860:  MOV     FDA,W0
04862:  MOV     FDC,W1
04864:  MOV     W5,W2
04866:  MOV     W6,W3
04868:  CALL    10CE
0486C:  MOV     FE6,W4
0486E:  SUB     W4,W0,W0
04870:  MOV     W0,FE6
04872:  MOV     FE8,W4
04874:  SUBB    W4,W1,W0
04876:  MOV     W0,FE8
....................         stream->pos = offset2; 
04878:  MOV     #C,W0
0487A:  ADD     FD2,W0
0487C:  MOV     W0,W5
0487E:  MOV     FE6,W4
04880:  MOV     W4,[W5+#0]
....................  
....................         // figure out how many clusters 
....................         temp = numsector / dsk->SecPerClus; 
04882:  MOV     #21,W4
04884:  MOV     FE2,W3
04886:  ADD     W3,W4,W0
04888:  MOV     #A,W1
0488A:  MOV     W0,W2
0488C:  MOV.B   [W2++],[W1++]
0488E:  BCLR.B  43.0
04890:  MOV.B   W5L,W2L
04892:  CLR.B   5
04894:  MOV     #0,W3
04896:  MOV     FDA,W0
04898:  MOV     FDC,W1
0489A:  CALL    1AE6
0489E:  MOV     W0,FDE
048A0:  MOV     W1,FE0
....................  
....................         // figure out the stranded sectors 
....................         numsector = numsector - (dsk->SecPerClus * temp); 
048A2:  MOV     #21,W4
048A4:  MOV     FE2,W3
048A6:  ADD     W3,W4,W0
048A8:  MOV     #A,W1
048AA:  MOV     W0,W2
048AC:  MOV.B   [W2++],[W1++]
048AE:  MOV     #0,W1
048B0:  MOV.B   W5L,W0L
048B2:  CLR.B   1
048B4:  MOV     FDE,W2
048B6:  MOV     FE0,W3
048B8:  CALL    10CE
048BC:  MOV     FDA,W4
048BE:  SUB     W4,W0,W0
048C0:  MOV     W0,FDA
048C2:  MOV     FDC,W4
048C4:  SUBB    W4,W1,W0
048C6:  MOV     W0,FDC
....................         stream->sec = numsector; 
048C8:  MOV     #A,W0
048CA:  ADD     FD2,W0
048CC:  MOV     W0,W5
048CE:  MOV     FDA,W4
048D0:  MOV     W4,[W5+#0]
....................  
....................         // if we are in the current cluster stay there 
....................         if (temp > 0) 
048D2:  CP0     FDE
048D4:  BRA     NZ,48DA
048D6:  CP0     FE0
048D8:  BRA     Z,49B4
....................         { 
....................             test = FILEget_next_cluster(stream, temp); 
048DA:  PUSH    FD2
048DC:  POP     FF6
048DE:  PUSH    FDE
048E0:  POP     FF8
048E2:  PUSH    FE0
048E4:  POP     FFA
048E6:  CALL    4674
048EA:  MOV.B   W0L,FE4
....................             if (test != CE_GOOD) 
048EC:  CP0.B   FE4
048EE:  BRA     Z,49B4
....................             { 
....................                 if (test == CE_FAT_EOF) 
048F0:  MOV     FE4,W4
048F2:  XOR.B   #3C,W4L
048F4:  BRA     NZ,49AC
....................                 { 
.................... #ifdef ALLOW_WRITES 
....................                     if (stream->flags.write) 
048F6:  MOV     #16,W0
048F8:  ADD     FD2,W0
048FA:  MOV.B   [W0],W4L
048FC:  BTSS    W4.0
048FE:  BRA     4948
....................                     { 
....................                         // load the previous cluster 
....................                         stream->ccls = stream->cluster; 
04900:  MOV     #6,W0
04902:  ADD     FD2,W0
04904:  MOV     W0,W5
04906:  MOV     #2,W0
04908:  ADD     FD2,W0
0490A:  MOV     [W0++],[W5++]
0490C:  MOV     [W0++],[W5++]
....................                         // Don't perform this operation if there's only one cluster 
....................                         if (temp != 1) 
0490E:  MOV     FDE,W4
04910:  CP      W4,#1
04912:  BRA     NZ,4918
04914:  CP0     FE0
04916:  BRA     Z,492E
....................                         test = FILEget_next_cluster(stream, temp - 1); 
04918:  MOV     FDE,W4
0491A:  SUB     W4,#1,W5
0491C:  MOV     FE0,W4
0491E:  SUBB    W4,#0,W6
04920:  PUSH    FD2
04922:  POP     FF6
04924:  MOV     W5,FF8
04926:  MOV     W6,FFA
04928:  CALL    4674
0492C:  MOV.B   W0L,FE4
....................                         if (FILEallocate_new_cluster(stream, 0) != CE_GOOD) 
0492E:  CLR.B   FF4
04930:  PUSH    FD2
04932:  POP     FF2
04934:  CALL    3E9C
04938:  CP0.B   W0L
0493A:  BRA     Z,4944
....................                         { 
....................                             FSerrno = CE_COULD_NOT_GET_CLUSTER; 
0493C:  MOV.B   #F,W0L
0493E:  MOV.B   W0L,857
....................                             return -1; 
04940:  SETM    0
04942:  BRA     4A1E
....................                         } 
....................                         // sec and pos should already be zero 
....................                     } 
04944:  GOTO    49A8
....................                     else 
....................                     { 
.................... #endif 
....................                         stream->ccls = stream->cluster; 
04948:  MOV     #6,W0
0494A:  ADD     FD2,W0
0494C:  MOV     W0,W5
0494E:  MOV     #2,W0
04950:  ADD     FD2,W0
04952:  MOV     [W0++],[W5++]
04954:  MOV     [W0++],[W5++]
....................                         test = FILEget_next_cluster(stream, temp - 1); 
04956:  MOV     FDE,W4
04958:  SUB     W4,#1,W5
0495A:  MOV     FE0,W4
0495C:  SUBB    W4,#0,W6
0495E:  PUSH    FD2
04960:  POP     FF6
04962:  MOV     W5,FF8
04964:  MOV     W6,FFA
04966:  CALL    4674
0496A:  MOV.B   W0L,FE4
....................                         if (test != CE_GOOD) 
0496C:  CP0.B   FE4
0496E:  BRA     Z,4978
....................                         { 
....................                             FSerrno = CE_COULD_NOT_GET_CLUSTER; 
04970:  MOV.B   #F,W0L
04972:  MOV.B   W0L,857
....................                             return (-1); 
04974:  SETM    0
04976:  BRA     4A1E
....................                         } 
....................                         stream->pos = dsk->sectorSize; 
04978:  MOV     #C,W0
0497A:  ADD     FD2,W0
0497C:  MOV     W0,W5
0497E:  MOV     FE2,W4
04980:  ADD     W4,#18,W4
04982:  MOV     W4,W0
04984:  MOV     #C,W1
04986:  MOV     W0,W2
04988:  REPEAT  #3
0498A:  MOV.B   [W2++],[W1++]
0498C:  MOV     W6,[W5]
....................                         stream->sec = dsk->SecPerClus - 1; 
0498E:  MOV     #A,W0
04990:  ADD     FD2,W0
04992:  MOV     W0,W5
04994:  MOV     #21,W4
04996:  MOV     FE2,W3
04998:  ADD     W3,W4,W0
0499A:  MOV     #C,W1
0499C:  MOV     W0,W2
0499E:  MOV.B   [W2++],[W1++]
049A0:  ZE      W6,W6
049A2:  CLR.B   D
049A4:  SUB     W6,#1,W0
049A6:  MOV     W0,[W5]
.................... #ifdef ALLOW_WRITES 
....................                     } 
.................... #endif 
....................                 } 
049A8:  GOTO    49B4
....................                 else 
....................                 { 
....................                     FSerrno = CE_COULD_NOT_GET_CLUSTER; 
049AC:  MOV.B   #F,W0L
049AE:  MOV.B   W0L,857
....................                     return (-1);   // past the limits 
049B0:  SETM    0
049B2:  BRA     4A1E
....................                 } 
....................             } 
....................         } 
....................  
....................         // Determine the lba of the selected sector and load 
....................         temp = Cluster2Sector(dsk,stream->ccls); 
049B4:  MOV     #6,W0
049B6:  ADD     FD2,W0
049B8:  MOV     #A,W4
049BA:  MOV     [W0++],[W4++]
049BC:  MOV     [W0++],[W4++]
049BE:  PUSH    FE2
049C0:  POP     1056
049C2:  MOV     W5,1058
049C4:  MOV     W6,105A
049C6:  CALL    308C
049CA:  MOV     W0,FDE
049CC:  MOV     W1,FE0
....................  
....................         // now the extra sectors 
....................         numsector = stream->sec; 
049CE:  MOV     #A,W0
049D0:  ADD     FD2,W0
049D2:  MOV     [W0],[W15++]
049D4:  POP     FDA
049D6:  CLR     FDC
....................         temp += numsector; 
049D8:  MOV     FDE,W0
049DA:  ADD     FDA,W0
049DC:  MOV     W0,FDE
049DE:  MOV     FDC,W4
049E0:  MOV     FE0,W3
049E2:  ADDC    W3,W4,W0
049E4:  MOV     W0,FE0
....................  
....................         gBufferOwner = NULL; 
049E6:  CLR     84E
....................         gBufferZeroed = FALSE; 
049E8:  CLR.B   856
....................         if( !MDD_SectorRead(temp, dsk->buffer) ) 
049EA:  MOV     FE2,W4
049EC:  ADD     W4,#0,W4
049EE:  MOV     W4,W0
049F0:  MOV     #A,W1
049F2:  MOV     W0,W2
049F4:  REPEAT  #1
049F6:  MOV.B   [W2++],[W1++]
049F8:  PUSH    FDE
049FA:  POP     1098
049FC:  PUSH    FE0
049FE:  POP     109A
04A00:  MOV     W5,109C
04A02:  CALL    1722
04A06:  CP0.B   W0L
04A08:  BRA     NZ,4A12
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
04A0A:  MOV.B   #1B,W0L
04A0C:  MOV.B   W0L,857
....................             return (-1);   // Bad read 
04A0E:  SETM    0
04A10:  BRA     4A1E
....................         } 
....................         gLastDataSectorRead = temp; 
04A12:  PUSH    FDE
04A14:  POP     850
04A16:  PUSH    FE0
04A18:  POP     852
....................     } 
....................  
....................     FSerrno = CE_GOOD; 
04A1A:  CLR.B   857
....................  
....................     return (0); 
04A1C:  CLR     0
04A1E:  MOV     [--W15],W7
04A20:  MOV     [--W15],W6
04A22:  MOV     [--W15],W5
04A24:  RETURN  
.................... } 
....................  
....................  
.................... // FSfopenpgm, FSremovepgm, and FSrenamepgm will only work on PIC18s 
.................... #ifdef __18CXX 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... /***************************************************************** 
....................   Function: 
....................     int FSrenamepgm(const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the file with the ascii ROM string(PIC18) 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file (in ROM) 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -  File renamed successfully 
....................     -1 - File could not be renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the file with the ascii ROM string(PIC18).The Fsrenamepgm 
....................     function will copy the rom fileName specified by the user into a 
....................     RAM array and pass that array into the FSrename function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   *****************************************************************/ 
....................  
.................... int FSrenamepgm (const rom char * fileName, FSFILE * fo) 
.................... { 
....................    #if defined(SUPPORT_LFN) 
....................  
....................       char tempArray[257]; 
....................       unsigned short int count; 
....................    #else 
....................  
....................       char   tempArray[13]; 
....................  
....................        BYTE count; 
....................    #endif 
....................  
....................  
....................     *fileName; 
....................     for(count = 0; count < sizeof(tempArray); count++) 
....................     { 
....................         _asm TBLRDPOSTINC _endasm 
....................         tempArray[count] = TABLAT; 
....................     }//end for(...) 
....................  
....................     return FSrename (tempArray, fo); 
.................... } 
.................... #endif 
....................  
.................... /****************************************************************************** 
....................   Function: 
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode) 
....................   Summary: 
....................     Opens a file on PIC18 Microcontrollers where 'fileName' ROM string is given 
....................     in Ascii format. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to be opened (ROM) 
....................     mode -      The mode the file will be opened in (ROM) 
....................   Return Values: 
....................     FSFILE * - A pointer to the file object 
....................     NULL -     File could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file on PIC18 Microcontrollers where 'fileName' ROM string 
....................     is given in Ascii format.The FSfopenpgm function will copy a PIC18 ROM fileName and 
....................     mode argument into RAM arrays, and then pass those arrays to the FSfopen function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   ******************************************************************************/ 
....................  
.................... FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode) 
.................... { 
....................    #if defined(SUPPORT_LFN) 
....................        char tempArray[257]; 
....................        unsigned short int count = 0; 
....................     #else 
....................        char tempArray[13]; 
....................        BYTE count = 0; 
....................    #endif 
....................     char M[2]; 
....................  
....................     for(;;) 
....................    { 
....................       tempArray[count] = fileName[count]; 
....................       if(tempArray[count]) 
....................          count++; 
....................       else 
....................          break; 
....................    } 
....................  
....................     for (count = 0; count < 2; count++) 
....................     { 
....................         M[count] = *(mode + count); 
....................     } 
....................  
....................     return FSfopen(tempArray, M); 
.................... } 
....................  
.................... /************************************************************* 
....................   Function: 
....................     int FSremovepgm (const rom char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC18 device 
....................   Conditions: 
....................     File not opened; file exists 
....................   Input: 
....................     fileName -  The name of the file to be deleted (ROM) 
....................   Return Values: 
....................     0 -  File was removed successfully 
....................     -1 - File could not be removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC18 device.The FSremovepgm function will copy a 
....................     PIC18 ROM fileName argument into a RAM array, and then pass that array 
....................     to the FSremove function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   *************************************************************/ 
.................... #ifdef ALLOW_WRITES 
.................... int FSremovepgm (const rom char * fileName) 
.................... { 
....................    #ifdef SUPPORT_LFN 
....................       char tempArray[257]; 
....................       unsigned short int count; 
....................    #else 
....................  
....................       char   tempArray[13]; 
....................  
....................        BYTE count; 
....................    #endif 
....................  
....................  
....................     *fileName; 
....................     for(count = 0; count < sizeof(tempArray); count++) 
....................     { 
....................         _asm TBLRDPOSTINC _endasm 
....................         tempArray[count] = TABLAT; 
....................     }//end for(...) 
....................  
....................     return FSremove (tempArray); 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************************** 
....................   Function: 
....................     int FindFirstpgm (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Find a file named with a ROM string on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName -  The name of the file to be found (ROM) 
....................     attr -      The attributes of the file to be found 
....................     rec -       Pointer to a search record to store the file info in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the given parameters was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirstpgm call on passed SearchRec object 
....................     will be lost.The FSerrno variable will be changed. 
....................   Description: 
....................     This function finds a file named with 'fileName' on PIC18. The FindFirstpgm 
....................     function will copy a PIC18 ROM fileName argument into a RAM array, and then 
....................     pass that array to the FindFirst function. 
....................   Remarks: 
....................     Call FindFirstpgm or FindFirst before calling FindNext. 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************************/ 
.................... #ifdef ALLOW_FILESEARCH 
.................... int FindFirstpgm (const rom char * fileName, unsigned int attr, SearchRec * rec) 
.................... { 
....................    #if defined(SUPPORT_LFN) 
....................  
....................       char tempArray[257]; 
....................       unsigned short int count; 
....................    #else 
....................  
....................       char   tempArray[13]; 
....................  
....................        BYTE count; 
....................    #endif 
....................  
....................  
....................     *fileName; 
....................     for(count = 0; count < sizeof(tempArray); count++) 
....................     { 
....................         _asm TBLRDPOSTINC _endasm 
....................         tempArray[count] = TABLAT; 
....................     }//end for 
....................  
....................     return FindFirst (tempArray,attr,rec); 
.................... } 
.................... #endif 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /*********************************************** 
....................   Function: 
....................     DWORD ReadFAT (DISK *dsk, DWORD ccls) 
....................   Summary: 
....................     Read the next entry from the FAT 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -   The disk structure 
....................     ccls -  The current cluster 
....................   Return: 
....................     DWORD - The next cluster in a file chain 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The ReadFAT function will read the FAT and 
....................     determine the next cluster value after the 
....................     cluster specified by 'ccls.' Note that the 
....................     FAT sector that is read is stored in the 
....................     global FAT cache buffer. 
....................   Remarks: 
....................     None. 
....................   ***********************************************/ 
....................  
.................... DWORD ReadFAT (DISK *dsk, DWORD ccls) 
*
02ECC:  MOV     W5,[W15++]
02ECE:  MOV     W6,[W15++]
02ED0:  MOV     W7,[W15++]
02ED2:  MOV     W8,[W15++]
*
02EDE:  CLR     1058
02EE0:  CLR     105A
.................... { 
....................     BYTE q; 
*
02ED4:  CLR.B   104E
....................     DWORD p, l;  // "l" is the sector Address 
02ED6:  CLR     1050
02ED8:  CLR     1052
02EDA:  CLR     1054
02EDC:  CLR     1056
....................     DWORD c = 0, d, ClusterFailValue,LastClusterLimit;   // ClusterEntries 
*
02EE2:  CLR     105C
02EE4:  CLR     105E
02EE6:  CLR     1060
02EE8:  CLR     1062
02EEA:  CLR     1064
02EEC:  CLR     1066
....................  
....................     gBufferZeroed = FALSE; 
02EEE:  CLR.B   856
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
02EF0:  MOV     #22,W4
02EF2:  MOV     1048,W3
02EF4:  ADD     W3,W4,W0
02EF6:  MOV     #A,W1
02EF8:  MOV     W0,W2
02EFA:  MOV.B   [W2++],[W1++]
02EFC:  MOV.B   W5L,W0L
02EFE:  CLR.B   1
02F00:  XOR     #3,W0
02F02:  BRA     Z,2F0A
02F04:  XOR     #1,W0
02F06:  BRA     Z,2F2E
02F08:  BRA     2F2E
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             p = (DWORD)ccls * 4; 
02F0A:  PUSH    104A
02F0C:  POP     1050
02F0E:  PUSH    104C
02F10:  POP     1052
02F12:  SL      1050
02F14:  RLC     1052
02F16:  SL      1050
02F18:  RLC     1052
....................             q = 0; // "q" not used for FAT32, only initialized to remove a warning 
02F1A:  CLR.B   104E
....................             ClusterFailValue = CLUSTER_FAIL_FAT32; 
02F1C:  SETM    1060
02F1E:  MOV     #FFF,W4
02F20:  MOV     W4,1062
....................             LastClusterLimit = LAST_CLUSTER_FAT32; 
02F22:  MOV     #FFF8,W4
02F24:  MOV     W4,1064
02F26:  MOV     #FFF,W4
02F28:  MOV     W4,1066
....................             break; 
02F2A:  GOTO    2F4A
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
....................             p = (DWORD) ccls *3;  // Mulby1.5 to find cluster pos in FAT 
....................             q = p&1; 
....................             p >>= 1; 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
....................             LastClusterLimit = LAST_CLUSTER_FAT12; 
....................             break; 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             p = (DWORD)ccls *2;     // Mulby 2 to find cluster pos in FAT 
02F2E:  PUSH    104A
02F30:  POP     1050
02F32:  PUSH    104C
02F34:  POP     1052
02F36:  SL      1050
02F38:  RLC     1052
....................             q = 0; // "q" not used for FAT16, only initialized to remove a warning 
02F3A:  CLR.B   104E
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
02F3C:  SETM    1060
02F3E:  CLR     1062
....................             LastClusterLimit = LAST_CLUSTER_FAT16; 
02F40:  MOV     #FFF8,W4
02F42:  MOV     W4,1064
02F44:  CLR     1066
....................             break; 
02F46:  GOTO    2F4A
....................     } 
....................  
....................     l = dsk->fat + (p / dsk->sectorSize);     // 
02F4A:  MOV     1048,W4
02F4C:  ADD     W4,#6,W4
02F4E:  MOV     W4,W0
02F50:  MOV     #A,W1
02F52:  MOV     W0,W2
02F54:  REPEAT  #3
02F56:  MOV.B   [W2++],[W1++]
02F58:  MOV     1048,W4
02F5A:  ADD     W4,#18,W4
02F5C:  MOV     W4,W0
02F5E:  MOV     #E,W1
02F60:  MOV     W0,W2
02F62:  REPEAT  #3
02F64:  MOV.B   [W2++],[W1++]
02F66:  BCLR.B  43.0
02F68:  MOV     1050,W0
02F6A:  MOV     1052,W1
02F6C:  MOV     W7,W2
02F6E:  MOV     W8,W3
02F70:  CALL    1AE6
02F74:  ADD     W0,W5,W0
02F76:  MOV     W0,1054
02F78:  ADDC    W1,W6,W0
02F7A:  MOV     W0,1056
....................     p &= dsk->sectorSize - 1;                 // Restrict 'p' within the FATbuffer size 
02F7C:  MOV     1048,W4
02F7E:  ADD     W4,#18,W4
02F80:  MOV     W4,W0
02F82:  MOV     #A,W1
02F84:  MOV     W0,W2
02F86:  REPEAT  #3
02F88:  MOV.B   [W2++],[W1++]
02F8A:  SUB     W5,#1,W0
02F8C:  SUBB    W6,#0,W1
02F8E:  AND     1050
02F90:  MOV     W1,W0
02F92:  AND     1052
....................  
....................     // Check if the appropriate FAT sector is already loaded 
....................     if (gLastFATSectorRead == l) 
02F94:  MOV     84A,W0
02F96:  CP      1054
02F98:  BRA     NZ,2FDC
02F9A:  MOV     84C,W0
02F9C:  CP      1056
02F9E:  BRA     NZ,2FDC
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         if (dsk->type == FAT32) 
02FA0:  MOV     #22,W4
02FA2:  MOV     1048,W3
02FA4:  ADD     W3,W4,W0
02FA6:  MOV     #A,W1
02FA8:  MOV     W0,W2
02FAA:  MOV.B   [W2++],[W1++]
02FAC:  CP.B    W5L,#3
02FAE:  BRA     NZ,2FBE
....................             c = RAMreadD (gFATBuffer, p); 
02FB0:  MOV     #B08,W0
02FB2:  ADD     1050,W0
02FB4:  MOV     #1058,W4
02FB6:  MOV     [W0++],[W4++]
02FB8:  MOV     [W0++],[W4++]
02FBA:  GOTO    2FD8
....................         else 
.................... #endif 
....................             if(dsk->type == FAT16) 
02FBE:  MOV     #22,W4
02FC0:  MOV     1048,W3
02FC2:  ADD     W3,W4,W0
02FC4:  MOV     #A,W1
02FC6:  MOV     W0,W2
02FC8:  MOV.B   [W2++],[W1++]
02FCA:  CP.B    W5L,#2
02FCC:  BRA     NZ,2FD8
....................                 c = RAMreadW (gFATBuffer, p); 
02FCE:  MOV     #B08,W0
02FD0:  ADD     1050,W0
02FD2:  MOV     [W0],[W15++]
02FD4:  POP     1058
02FD6:  CLR     105A
.................... #ifdef SUPPORT_FAT12 
....................             else if(dsk->type == FAT12) 
....................             { 
....................                 c = RAMread (gFATBuffer, p); 
....................                 if (q) 
....................                 { 
....................                     c >>= 4; 
....................                 } 
....................                 // Check if the MSB is across the sector boundry 
....................                 p = (p +1) & (dsk->sectorSize-1); 
....................                 if (p == 0) 
....................                 { 
....................                     // Start by writing the sector we just worked on to the card 
....................                     // if we need to 
.................... #ifdef ALLOW_WRITES 
....................                     if (gNeedFATWrite) 
....................                         if(WriteFAT (dsk, 0, 0, TRUE)) 
....................                             return ClusterFailValue; 
.................... #endif 
....................                     if (!MDD_SectorRead (l+1, gFATBuffer)) 
....................                     { 
....................                         gLastFATSectorRead = 0xFFFF; 
....................                         return ClusterFailValue; 
....................                     } 
....................                     else 
....................                     { 
....................                         gLastFATSectorRead = l +1; 
....................                     } 
....................                 } 
....................                 d = RAMread (gFATBuffer, p); 
....................                 if (q) 
....................                 { 
....................                     c += (d <<4); 
....................                 } 
....................                 else 
....................                 { 
....................                     c += ((d & 0x0F)<<8); 
....................                 } 
....................             } 
.................... #endif 
....................         } 
02FD8:  GOTO    3064
....................         else 
....................         { 
....................             // If there's a currently open FAT sector, 
....................             // write it back before reading into the buffer 
.................... #ifdef ALLOW_WRITES 
....................             if (gNeedFATWrite) 
02FDC:  CP0.B   83F
02FDE:  BRA     Z,3002
....................             { 
....................                 if(WriteFAT (dsk, 0, 0, TRUE)) 
02FE0:  MOV.B   #1,W0L
02FE2:  MOV.B   W0L,1078
02FE4:  PUSH    1048
02FE6:  POP     106E
02FE8:  CLR     1070
02FEA:  CLR     1072
02FEC:  CLR     1074
02FEE:  CLR     1076
02FF0:  CALL    2C18
02FF4:  CP0     W0
02FF6:  BRA     NZ,2FFC
02FF8:  CP0     W1
02FFA:  BRA     Z,3002
....................                     return ClusterFailValue; 
02FFC:  MOV     1060,W0
02FFE:  MOV     1062,W1
03000:  BRA     3082
....................             } 
.................... #endif 
....................             if (!MDD_SectorRead (l, gFATBuffer)) 
03002:  PUSH    1054
03004:  POP     1098
03006:  PUSH    1056
03008:  POP     109A
0300A:  MOV     #B08,W4
0300C:  MOV     W4,109C
0300E:  CALL    1722
03012:  CP0.B   W0L
03014:  BRA     NZ,3024
....................             { 
....................                 gLastFATSectorRead = 0xFFFF;  // Note: It is Sector not Cluster. 
03016:  SETM    84A
03018:  CLR     84C
....................                 return ClusterFailValue; 
0301A:  MOV     1060,W0
0301C:  MOV     1062,W1
0301E:  BRA     3082
....................             } 
03020:  GOTO    3064
....................             else 
....................             { 
....................                 gLastFATSectorRead = l; 
03024:  PUSH    1054
03026:  POP     84A
03028:  PUSH    1056
0302A:  POP     84C
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................                 if (dsk->type == FAT32) 
0302C:  MOV     #22,W4
0302E:  MOV     1048,W3
03030:  ADD     W3,W4,W0
03032:  MOV     #A,W1
03034:  MOV     W0,W2
03036:  MOV.B   [W2++],[W1++]
03038:  CP.B    W5L,#3
0303A:  BRA     NZ,304A
....................                     c = RAMreadD (gFATBuffer, p); 
0303C:  MOV     #B08,W0
0303E:  ADD     1050,W0
03040:  MOV     #1058,W4
03042:  MOV     [W0++],[W4++]
03044:  MOV     [W0++],[W4++]
03046:  GOTO    3064
....................                 else 
.................... #endif 
....................                     if(dsk->type == FAT16) 
0304A:  MOV     #22,W4
0304C:  MOV     1048,W3
0304E:  ADD     W3,W4,W0
03050:  MOV     #A,W1
03052:  MOV     W0,W2
03054:  MOV.B   [W2++],[W1++]
03056:  CP.B    W5L,#2
03058:  BRA     NZ,3064
....................                         c = RAMreadW (gFATBuffer, p); 
0305A:  MOV     #B08,W0
0305C:  ADD     1050,W0
0305E:  MOV     [W0],[W15++]
03060:  POP     1058
03062:  CLR     105A
.................... #ifdef SUPPORT_FAT12 
....................                     else if (dsk->type == FAT12) 
....................                     { 
....................                         c = RAMread (gFATBuffer, p); 
....................                         if (q) 
....................                         { 
....................                             c >>= 4; 
....................                         } 
....................                         p = (p +1) & (dsk->sectorSize-1); 
....................                         d = RAMread (gFATBuffer, p); 
....................                         if (q) 
....................                         { 
....................                             c += (d <<4); 
....................                         } 
....................                         else 
....................                         { 
....................                             c += ((d & 0x0F)<<8); 
....................                         } 
....................                     } 
.................... #endif 
....................             } 
....................     } 
....................  
....................     // Normalize it so 0xFFFF is an error 
....................     if (c >= LastClusterLimit) 
03064:  MOV     1066,W0
03066:  MOV     105A,W4
03068:  CP      W4,W0
0306A:  BRA     NC,307E
0306C:  BRA     GTU,3076
0306E:  MOV     1064,W0
03070:  MOV     1058,W4
03072:  CP      W4,W0
03074:  BRA     NC,307E
....................         c = LastClusterLimit; 
03076:  PUSH    1064
03078:  POP     1058
0307A:  PUSH    1066
0307C:  POP     105A
....................  
....................    return c; 
0307E:  MOV     1058,W0
03080:  MOV     105A,W1
03082:  MOV     [--W15],W8
03084:  MOV     [--W15],W7
03086:  MOV     [--W15],W6
03088:  MOV     [--W15],W5
0308A:  RETURN  
.................... }   // ReadFAT 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Function: 
....................     WORD WriteFAT (DISK *dsk, DWORD ccls, WORD value, BYTE forceWrite) 
....................   Summary: 
....................     Write an entry to the FAT 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -         The disk structure 
....................     ccls -        The current cluster 
....................     value -       The value to write in 
....................     forceWrite -  Force the function to write the current FAT sector 
....................   Return: 
....................     0 -    The FAT write was successful 
....................     FAIL - The FAT could not be written 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The WriteFAT function writes an entry to the FAT.  If the function 
....................     is called and the 'forceWrite' argument is TRUE, the function will 
....................     write the existing FAT data to the device.  Otherwise, the function 
....................     will replace a single entry in the FAT buffer (indicated by 'ccls') 
....................     with a new value (indicated by 'value.') 
....................   Remarks: 
....................     None. 
....................   ****************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... DWORD WriteFAT (DISK *dsk, DWORD ccls, DWORD value, BYTE forceWrite) 
*
02C18:  MOV     W5,[W15++]
02C1A:  MOV     W6,[W15++]
02C1C:  MOV     W7,[W15++]
02C1E:  MOV     W8,[W15++]
.................... { 
....................     BYTE i, q, c; 
02C20:  CLR.B   1079
02C22:  CLR.B   107A
02C24:  CLR.B   107B
....................     DWORD p, li, l, ClusterFailValue; 
02C26:  CLR     107C
02C28:  CLR     107E
02C2A:  CLR     1080
02C2C:  CLR     1082
02C2E:  CLR     1084
02C30:  CLR     1086
02C32:  CLR     1088
02C34:  CLR     108A
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................     if ((dsk->type != FAT32) && (dsk->type != FAT16) && (dsk->type != FAT12)) 
02C36:  MOV     #22,W4
02C38:  MOV     106E,W3
02C3A:  ADD     W3,W4,W0
02C3C:  MOV     #A,W1
02C3E:  MOV     W0,W2
02C40:  MOV.B   [W2++],[W1++]
02C42:  CP.B    W5L,#3
02C44:  BRA     Z,2C6C
02C46:  MOV     #22,W4
02C48:  MOV     106E,W3
02C4A:  ADD     W3,W4,W0
02C4C:  MOV     #A,W1
02C4E:  MOV     W0,W2
02C50:  MOV.B   [W2++],[W1++]
02C52:  CP.B    W5L,#2
02C54:  BRA     Z,2C6C
02C56:  MOV     #22,W4
02C58:  MOV     106E,W3
02C5A:  ADD     W3,W4,W0
02C5C:  MOV     #A,W1
02C5E:  MOV     W0,W2
02C60:  MOV.B   [W2++],[W1++]
02C62:  CP.B    W5L,#1
02C64:  BRA     Z,2C6C
....................         return CLUSTER_FAIL_FAT32; 
02C66:  MOV     #FFFF,W0
02C68:  MOV     #FFF,W1
02C6A:  BRA     2EC2
.................... #else // If FAT32 support not enabled 
....................     if ((dsk->type != FAT16) && (dsk->type != FAT12)) 
....................         return CLUSTER_FAIL_FAT16; 
.................... #endif 
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
02C6C:  MOV     #22,W4
02C6E:  MOV     106E,W3
02C70:  ADD     W3,W4,W0
02C72:  MOV     #A,W1
02C74:  MOV     W0,W2
02C76:  MOV.B   [W2++],[W1++]
02C78:  MOV.B   W5L,W0L
02C7A:  CLR.B   1
02C7C:  XOR     #3,W0
02C7E:  BRA     Z,2C86
02C80:  XOR     #1,W0
02C82:  BRA     Z,2C90
02C84:  BRA     2C90
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             ClusterFailValue = CLUSTER_FAIL_FAT32; 
02C86:  SETM    1088
02C88:  MOV     #FFF,W4
02C8A:  MOV     W4,108A
....................             break; 
02C8C:  GOTO    2C98
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
02C90:  SETM    1088
02C92:  CLR     108A
....................             break; 
02C94:  GOTO    2C98
....................     } 
....................  
....................     gBufferZeroed = FALSE; 
02C98:  CLR.B   856
....................  
....................     // The only purpose for calling this function with forceWrite 
....................     // is to write the current FAT sector to the card 
....................     if (forceWrite) 
02C9A:  CP0.B   1078
02C9C:  BRA     Z,2D00
....................     { 
....................         for (i = 0, li = gLastFATSectorRead; i < dsk->fatcopy; i++, li += dsk->fatsize) 
02C9E:  CLR.B   1079
02CA0:  PUSH    84A
02CA2:  POP     1080
02CA4:  PUSH    84C
02CA6:  POP     1082
02CA8:  MOV     #20,W4
02CAA:  MOV     106E,W3
02CAC:  ADD     W3,W4,W0
02CAE:  MOV     #A,W1
02CB0:  MOV     W0,W2
02CB2:  MOV.B   [W2++],[W1++]
02CB4:  MOV     1078,W4
02CB6:  LSR     W4,#8,W4
02CB8:  CP.B    W4L,W5L
02CBA:  BRA     C,2CF8
....................         { 
....................             if (!MDD_SectorWrite (li, gFATBuffer, FALSE)) 
02CBC:  CLR.B   109E
02CBE:  PUSH    1080
02CC0:  POP     1098
02CC2:  PUSH    1082
02CC4:  POP     109A
02CC6:  MOV     #B08,W4
02CC8:  MOV     W4,109C
02CCA:  CALL    2BBE
02CCE:  CP0.B   W0L
02CD0:  BRA     NZ,2CD8
....................             { 
....................                 return ClusterFailValue; 
02CD2:  MOV     1088,W0
02CD4:  MOV     108A,W1
02CD6:  BRA     2EC2
....................             } 
02CD8:  MOV.B   1079,W0L
02CDA:  INC.B   1079
02CDC:  MOV     106E,W4
02CDE:  ADD     W4,#1C,W4
02CE0:  MOV     W4,W0
02CE2:  MOV     #A,W1
02CE4:  MOV     W0,W2
02CE6:  REPEAT  #3
02CE8:  MOV.B   [W2++],[W1++]
02CEA:  MOV     W5,W0
02CEC:  ADD     1080
02CEE:  MOV     W6,W0
02CF0:  ADDC    1082,W0
02CF2:  MOV     W0,1082
02CF4:  GOTO    2CA8
....................         } 
....................  
....................         gNeedFATWrite = FALSE; 
02CF8:  CLR.B   83F
....................  
....................         return 0; 
02CFA:  MOV     #0,W0
02CFC:  MOV     #0,W1
02CFE:  BRA     2EC2
....................     } 
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
02D00:  MOV     #22,W4
02D02:  MOV     106E,W3
02D04:  ADD     W3,W4,W0
02D06:  MOV     #A,W1
02D08:  MOV     W0,W2
02D0A:  MOV.B   [W2++],[W1++]
02D0C:  MOV.B   W5L,W0L
02D0E:  CLR.B   1
02D10:  XOR     #3,W0
02D12:  BRA     Z,2D1A
02D14:  XOR     #1,W0
02D16:  BRA     Z,2D30
02D18:  BRA     2D30
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             p = (DWORD)ccls *4;   // "p" is the position in "gFATBuffer" for corresponding cluster. 
02D1A:  PUSH    1070
02D1C:  POP     107C
02D1E:  PUSH    1072
02D20:  POP     107E
02D22:  SL      107C
02D24:  RLC     107E
02D26:  SL      107C
02D28:  RLC     107E
....................             q = 0;      // "q" not used for FAT32, only initialized to remove a warning 
02D2A:  CLR.B   107A
....................             break; 
02D2C:  GOTO    2D42
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
....................             p = (DWORD) ccls * 3; // "p" is the position in "gFATBuffer" for corresponding cluster. 
....................             q = p & 1;   // Odd or even? 
....................             p >>= 1; 
....................             break; 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             p = (DWORD) ccls *2;   // "p" is the position in "gFATBuffer" for corresponding cluster. 
02D30:  PUSH    1070
02D32:  POP     107C
02D34:  PUSH    1072
02D36:  POP     107E
02D38:  SL      107C
02D3A:  RLC     107E
....................             q = 0;      // "q" not used for FAT16, only initialized to remove a warning 
02D3C:  CLR.B   107A
....................             break; 
02D3E:  GOTO    2D42
....................     } 
....................  
....................     l = dsk->fat + (p / dsk->sectorSize);     // 
02D42:  MOV     106E,W4
02D44:  ADD     W4,#6,W4
02D46:  MOV     W4,W0
02D48:  MOV     #A,W1
02D4A:  MOV     W0,W2
02D4C:  REPEAT  #3
02D4E:  MOV.B   [W2++],[W1++]
02D50:  MOV     106E,W4
02D52:  ADD     W4,#18,W4
02D54:  MOV     W4,W0
02D56:  MOV     #E,W1
02D58:  MOV     W0,W2
02D5A:  REPEAT  #3
02D5C:  MOV.B   [W2++],[W1++]
02D5E:  BCLR.B  43.0
02D60:  MOV     107C,W0
02D62:  MOV     107E,W1
02D64:  MOV     W7,W2
02D66:  MOV     W8,W3
02D68:  CALL    1AE6
02D6C:  ADD     W0,W5,W0
02D6E:  MOV     W0,1084
02D70:  ADDC    W1,W6,W0
02D72:  MOV     W0,1086
....................     p &= dsk->sectorSize - 1;                 // Restrict 'p' within the FATbuffer size 
02D74:  MOV     106E,W4
02D76:  ADD     W4,#18,W4
02D78:  MOV     W4,W0
02D7A:  MOV     #A,W1
02D7C:  MOV     W0,W2
02D7E:  REPEAT  #3
02D80:  MOV.B   [W2++],[W1++]
02D82:  SUB     W5,#1,W0
02D84:  SUBB    W6,#0,W1
02D86:  AND     107C
02D88:  MOV     W1,W0
02D8A:  AND     107E
....................  
....................     if (gLastFATSectorRead != l) 
02D8C:  MOV     84A,W0
02D8E:  CP      1084
02D90:  BRA     NZ,2D98
02D92:  MOV     84C,W0
02D94:  CP      1086
02D96:  BRA     Z,2E22
....................     { 
....................         // If we are loading a new sector then write 
....................         // the current one to the card if we need to 
....................         if (gNeedFATWrite) 
02D98:  CP0.B   83F
02D9A:  BRA     Z,2DF8
....................         { 
....................             for (i = 0, li = gLastFATSectorRead; i < dsk->fatcopy; i++, li += dsk->fatsize) 
02D9C:  CLR.B   1079
02D9E:  PUSH    84A
02DA0:  POP     1080
02DA2:  PUSH    84C
02DA4:  POP     1082
02DA6:  MOV     #20,W4
02DA8:  MOV     106E,W3
02DAA:  ADD     W3,W4,W0
02DAC:  MOV     #A,W1
02DAE:  MOV     W0,W2
02DB0:  MOV.B   [W2++],[W1++]
02DB2:  MOV     1078,W4
02DB4:  LSR     W4,#8,W4
02DB6:  CP.B    W4L,W5L
02DB8:  BRA     C,2DF6
....................             { 
....................                 if (!MDD_SectorWrite (li, gFATBuffer, FALSE)) 
02DBA:  CLR.B   109E
02DBC:  PUSH    1080
02DBE:  POP     1098
02DC0:  PUSH    1082
02DC2:  POP     109A
02DC4:  MOV     #B08,W4
02DC6:  MOV     W4,109C
02DC8:  CALL    2BBE
02DCC:  CP0.B   W0L
02DCE:  BRA     NZ,2DD6
....................                 { 
....................                     return ClusterFailValue; 
02DD0:  MOV     1088,W0
02DD2:  MOV     108A,W1
02DD4:  BRA     2EC2
....................                 } 
02DD6:  MOV.B   1079,W0L
02DD8:  INC.B   1079
02DDA:  MOV     106E,W4
02DDC:  ADD     W4,#1C,W4
02DDE:  MOV     W4,W0
02DE0:  MOV     #A,W1
02DE2:  MOV     W0,W2
02DE4:  REPEAT  #3
02DE6:  MOV.B   [W2++],[W1++]
02DE8:  MOV     W5,W0
02DEA:  ADD     1080
02DEC:  MOV     W6,W0
02DEE:  ADDC    1082,W0
02DF0:  MOV     W0,1082
02DF2:  GOTO    2DA6
....................             } 
....................  
....................             gNeedFATWrite = FALSE; 
02DF6:  CLR.B   83F
....................         } 
....................  
....................         // Load the new sector 
....................         if (!MDD_SectorRead (l, gFATBuffer)) 
02DF8:  PUSH    1084
02DFA:  POP     1098
02DFC:  PUSH    1086
02DFE:  POP     109A
02E00:  MOV     #B08,W4
02E02:  MOV     W4,109C
02E04:  CALL    1722
02E08:  CP0.B   W0L
02E0A:  BRA     NZ,2E1A
....................         { 
....................             gLastFATSectorRead = 0xFFFF; 
02E0C:  SETM    84A
02E0E:  CLR     84C
....................             return ClusterFailValue; 
02E10:  MOV     1088,W0
02E12:  MOV     108A,W1
02E14:  BRA     2EC2
....................         } 
02E16:  GOTO    2E22
....................         else 
....................         { 
....................             gLastFATSectorRead = l; 
02E1A:  PUSH    1084
02E1C:  POP     84A
02E1E:  PUSH    1086
02E20:  POP     84C
....................         } 
....................     } 
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................     if (dsk->type == FAT32)  // Refer page 16 of FAT requirement. 
02E22:  MOV     #22,W4
02E24:  MOV     106E,W3
02E26:  ADD     W3,W4,W0
02E28:  MOV     #A,W1
02E2A:  MOV     W0,W2
02E2C:  MOV.B   [W2++],[W1++]
02E2E:  CP.B    W5L,#3
02E30:  BRA     NZ,2E88
....................     { 
....................         RAMwrite (gFATBuffer, p,   ((value & 0x000000ff)));         // lsb,1st byte of cluster value 
02E32:  MOV     #B08,W0
02E34:  ADD     107C,W0
02E36:  MOV     W0,W5
02E38:  CLR     W1
02E3A:  MOV     1074,W0
02E3C:  AND     #FF,W0
02E3E:  MOV.B   W0L,[W5]
....................         RAMwrite (gFATBuffer, p+1, ((value & 0x0000ff00) >> 8)); 
02E40:  MOV     #B08,W0
02E42:  ADD     107C,W0
02E44:  MOV     W0,W5
02E46:  ADD     W5,#1,W5
02E48:  MOV     W5,W0
02E4A:  MOV     W0,W5
02E4C:  MOV     #FF00,W0
02E4E:  AND     1074,W0
02E50:  MOV     W0,W6
02E52:  CLR     W7
02E54:  MOV.B   D,W0L
02E56:  MOV.B   W0L,[W5]
....................         RAMwrite (gFATBuffer, p+2, ((value & 0x00ff0000) >> 16)); 
02E58:  MOV     #B08,W0
02E5A:  ADD     107C,W0
02E5C:  MOV     W0,W5
02E5E:  ADD     W5,#2,W5
02E60:  MOV     W5,W0
02E62:  MOV     W0,W5
02E64:  CLR     W6
02E66:  MOV     1076,W7
02E68:  AND     #FF,W7
02E6A:  MOV.B   W7L,[W5]
....................         RAMwrite (gFATBuffer, p+3, ((value & 0x0f000000) >> 24));   // the MSB nibble is supposed to be "0" in FAT32. So mask it. 
02E6C:  MOV     #B08,W0
02E6E:  ADD     107C,W0
02E70:  MOV     W0,W5
02E72:  ADD     W5,#3,W5
02E74:  MOV     W5,W0
02E76:  MOV     W0,W5
02E78:  CLR     W6
02E7A:  MOV     #F00,W0
02E7C:  AND     1076,W0
02E7E:  MOV     W0,W7
02E80:  MOV.B   F,W0L
02E82:  MOV.B   W0L,[W5]
....................     } 
02E84:  GOTO    2EBA
....................     else 
....................  
.................... #endif 
....................     { 
....................         if (dsk->type == FAT16) 
02E88:  MOV     #22,W4
02E8A:  MOV     106E,W3
02E8C:  ADD     W3,W4,W0
02E8E:  MOV     #A,W1
02E90:  MOV     W0,W2
02E92:  MOV.B   [W2++],[W1++]
02E94:  CP.B    W5L,#2
02E96:  BRA     NZ,2EBA
....................         { 
....................             RAMwrite (gFATBuffer, p, value);            //lsB 
02E98:  MOV     #B08,W0
02E9A:  ADD     107C,W0
02E9C:  MOV     W0,W5
02E9E:  MOV     1074,W0
02EA0:  MOV.B   W0L,[W5+#0]
....................             RAMwrite (gFATBuffer, p+1, ((value&0x0000ff00) >> 8));    // msB 
02EA2:  MOV     #B08,W0
02EA4:  ADD     107C,W0
02EA6:  MOV     W0,W5
02EA8:  ADD     W5,#1,W5
02EAA:  MOV     W5,W0
02EAC:  MOV     W0,W5
02EAE:  MOV     #FF00,W0
02EB0:  AND     1074,W0
02EB2:  MOV     W0,W6
02EB4:  CLR     W7
02EB6:  MOV.B   D,W0L
02EB8:  MOV.B   W0L,[W5]
....................         } 
....................        #ifdef SUPPORT_FAT12 
....................         else if (dsk->type == FAT12) 
....................         { 
....................             // Get the current byte from the FAT 
....................             c = RAMread (gFATBuffer, p); 
....................             if (q) 
....................             { 
....................                 c = ((value & 0x0F) << 4) | ( c & 0x0F); 
....................             } 
....................             else 
....................             { 
....................                 c = (value & 0xFF); 
....................             } 
....................             // Write in those bits 
....................             RAMwrite (gFATBuffer, p, c); 
....................  
....................             // FAT12 entries can cross sector boundaries 
....................             // Check if we need to load a new sector 
....................             p = (p +1) & (dsk->sectorSize-1); 
....................             if (p == 0) 
....................             { 
....................                 // call this function to update the FAT on the card 
....................                 if (WriteFAT (dsk, 0,0,TRUE)) 
....................                     return ClusterFailValue; 
....................  
....................                 // Load the next sector 
....................                 if (!MDD_SectorRead (l +1, gFATBuffer)) 
....................                 { 
....................                     gLastFATSectorRead = 0xFFFF; 
....................                     return ClusterFailValue; 
....................                 } 
....................                 else 
....................                 { 
....................                     gLastFATSectorRead = l + 1; 
....................                 } 
....................             } 
....................  
....................             // Get the second byte of the table entry 
....................             c = RAMread (gFATBuffer, p); 
....................             if (q) 
....................             { 
....................                 c = (value >> 4); 
....................             } 
....................             else 
....................             { 
....................                 c = ((value >> 8) & 0x0F) | (c & 0xF0); 
....................             } 
....................             RAMwrite (gFATBuffer, p, c); 
....................         } 
....................        #endif 
....................     } 
....................     gNeedFATWrite = TRUE; 
02EBA:  MOV.B   #1,W0L
02EBC:  MOV.B   W0L,83F
....................  
....................     return 0; 
02EBE:  MOV     #0,W0
02EC0:  MOV     #0,W1
02EC2:  MOV     [--W15],W8
02EC4:  MOV     [--W15],W7
02EC6:  MOV     [--W15],W6
02EC8:  MOV     [--W15],W5
02ECA:  RETURN  
.................... } 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_DIRS 
....................  
.................... // This string is used by dir functions to hold dir names temporarily 
.................... #if defined(SUPPORT_LFN) 
....................    char tempDirectoryString [522]; 
.................... #else 
....................    char tempDirectoryString [14]; 
.................... #endif 
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdir (char * path) 
....................   Summary: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC). 
....................     The FSchdir function passes a RAM pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... int FSchdir (char * path) 
.................... { 
....................     return chdirhelper (0, path, NULL); 
*
0651A:  CLR.B   FB2
0651C:  PUSH    FAE
0651E:  POP     FB4
06520:  CLR     FB6
06522:  CALL    60DC
06526:  MOV     W0,0
06528:  RETURN  
.................... } 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int wFSchdir (unsigned short int * path) 
....................   Summary: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC).The FSchdir function passes a RAM 
....................     pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSchdir (unsigned short int * path) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................     result = chdirhelper (0, (char *)path, NULL); 
....................    utfModeFileName = FALSE; 
....................     return result; 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdirpgm (const rom char * path) 
....................   Summary: 
....................     Changes the CWD to the input path on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to (ROM) 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the CWD to the input path on PIC18.The FSchdirpgm function 
....................     passes a PIC18 ROM path pointer to the chdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int FSchdirpgm (const rom char * path) 
.................... { 
....................     return chdirhelper (1, NULL, path); 
.................... } 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int wFSchdirpgm (const rom unsigned short int * path) 
....................   Summary: 
....................     Changed the CWD with a path in ROM on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to (ROM) 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     The FSchdirpgm function passes a PIC18 ROM path pointer to the 
....................     chdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM 
....................   **************************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSchdirpgm (const rom unsigned short int * path) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................     result = chdirhelper (1, NULL, (const char *)path); 
....................    utfModeFileName = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int chdirhelper (BYTE mode, char * ramptr, char * romptr); 
....................     // PIC18 
....................     int chdirhelper (BYTE mode, char * ramptr, const rom char * romptr); 
....................   Summary: 
....................     Helper function for FSchdir 
....................   Conditions: 
....................     None 
....................   Input: 
....................     mode -    Indicates which path pointer to use 
....................     ramptr -  Pointer to the path specified in RAM 
....................     romptr -  Pointer to the path specified in ROM 
....................   Return Values: 
....................     0 -   Directory was changed successfully. 
....................     EOF - Directory could not be changed. 
....................   Side Effects: 
....................     The current working directory will be changed. The FSerrno variable 
....................     will be changed. Any unwritten data in the data buffer will be written 
....................     to the device. 
....................   Description: 
....................     This helper function is used by the FSchdir function. If the path 
....................     argument is specified in ROM for PIC18 this function will be able to 
....................     parse it correctly.  The function will loop through a switch statement 
....................     to process the tokens in the path string.  Dot or dotdot entries are 
....................     handled in the first case statement.  A backslash character is handled 
....................     in the second case statement (note that this case statement will only 
....................     be used if backslash is the first character in the path; backslash 
....................     token delimiters will automatically be skipped after each token in the 
....................     path is processed).  The third case statement will handle actual 
....................     directory name strings. 
....................   Remarks: 
....................     None. 
....................   *************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int chdirhelper (BYTE mode, char * ramptr, const rom char * romptr) 
.................... #else 
.................... int chdirhelper (BYTE mode, char * ramptr, char * romptr) 
.................... #endif 
*
060DC:  MOV     W5,[W15++]
060DE:  MOV     W6,[W15++]
*
060E4:  CLR     FBC
060E6:  MOV     #1,W4
060E8:  MOV     W4,FBE
*
060EC:  PUSH    FB4
060EE:  POP     FC2
*
06126:  MOV     #FC4,W4
06128:  MOV     W4,FFA
.................... { 
....................     unsigned short int i,j,k = 0; 
*
060E0:  CLR     FB8
060E2:  CLR     FBA
....................     WORD curent = 1; 
....................     DIRENTRY entry; 
*
060EA:  CLR     FC0
....................     char * temppath = ramptr; 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     rom char * temppath2 = romptr; 
....................     rom unsigned short int * utf16path2 = (rom unsigned short int *)romptr; 
.................... #endif 
....................    #ifdef SUPPORT_LFN 
....................       unsigned short int *utf16path = (unsigned short int *)ramptr; 
....................    #endif 
....................  
....................     FSFILE tempCWDobj2; 
*
060F0:  CLR     FC4
060F2:  CLR     FC6
060F4:  CLR     FC8
060F6:  CLR     FCA
060F8:  CLR     FCC
060FA:  CLR     FCE
060FC:  CLR     FD0
060FE:  CLR     FD2
06100:  CLR     FD4
06102:  CLR     FD6
06104:  CLR     FD8
06106:  CLR     FDA
06108:  CLR     FDC
0610A:  CLR     FDE
0610C:  CLR     FE0
0610E:  CLR     FE2
06110:  CLR     FE4
06112:  CLR     FE6
06114:  CLR     FE8
06116:  CLR     FEA
06118:  CLR     FEC
0611A:  CLR     FEE
0611C:  CLR     FF0
0611E:  CLR     FF2
06120:  CLR     FF4
06122:  CLR     FF6
06124:  CLR     FF8
....................     FILEOBJ tempCWD = &tempCWDobj2; 
....................  
....................     FileObjectCopy (tempCWD, cwdptr); 
*
0612A:  PUSH    FFA
0612C:  POP     1002
0612E:  PUSH    904
06130:  POP     1004
06132:  CALL    28E2
....................  
....................     FSerrno = CE_GOOD; 
06136:  CLR.B   857
....................  
....................    // Check the first char of the path 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     if (mode) 
....................    { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................  
....................       { 
....................  
....................          i = *utf16path2; 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................          i = *temppath2; 
....................       } 
....................     } 
....................     else 
.................... #endif 
....................    { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................  
....................       { 
....................  
....................          i = *utf16path; 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................          i = *temppath; 
06138:  MOV     FC2,W0
0613A:  MOV     W0,W4
0613C:  MOV.B   [W4],W0L
0613E:  SE      W0,W0
06140:  MOV     W0,FB8
....................       } 
....................     } 
....................  
....................    // if NULL character return error 
....................     if (i == 0) 
06142:  CP0     FB8
06144:  BRA     NZ,614E
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
06146:  MOV.B   #1F,W0L
06148:  MOV.B   W0L,857
....................         return -1; 
0614A:  SETM    0
0614C:  BRA     6514
....................     } 
....................  
....................     while(1) 
....................     { 
....................         switch (i) 
0614E:  MOV     FB8,W0
06150:  XOR     #2E,W0
06152:  BRA     Z,615A
06154:  XOR     #72,W0
06156:  BRA     Z,632A
06158:  BRA     63DC
....................         { 
....................             // First case: dot or dotdot entry 
....................             case '.': 
....................                 // Move past the dot 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 if (mode) 
....................                 { 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................  
....................                { 
....................  
....................                        utf16path2++; 
....................                        i = *utf16path2; 
....................                } 
....................                else 
....................                #endif 
....................                { 
....................                        temppath2++; 
....................                        i = *temppath2; 
....................                } 
....................                 } 
....................                 else 
....................                 { 
.................... #endif 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................  
....................                { 
....................  
....................                        utf16path++; 
....................                        i = *utf16path; 
....................                } 
....................                else 
....................                #endif 
....................                { 
....................                        temppath++; 
0615A:  INC     0FC2
....................                        i = *temppath; 
0615C:  MOV     FC2,W0
0615E:  MOV     W0,W4
06160:  MOV.B   [W4],W0L
06162:  SE      W0,W0
06164:  MOV     W0,FB8
....................                } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 } 
.................... #endif 
....................                 // Check if it's a dotdot entry 
....................                 if (i == '.') 
06166:  MOV     FB8,W4
06168:  XOR     #2E,W4
0616A:  BRA     NZ,62D2
....................                 { 
....................                     // Increment the path variable 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     if (mode) 
....................                     { 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                           utf16path2++; 
....................                           i = *utf16path2; 
....................                   } 
....................                   else 
....................                   #endif 
....................                   { 
....................                           temppath2++; 
....................                           i = *temppath2; 
....................                   } 
....................                     } 
....................                     else 
....................                     { 
.................... #endif 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                           utf16path++; 
....................                           i = *utf16path; 
....................                   } 
....................                   else 
....................                   #endif 
....................                   { 
....................                           temppath++; 
0616C:  INC     0FC2
....................                           i = *temppath; 
0616E:  MOV     FC2,W0
06170:  MOV     W0,W4
06172:  MOV.B   [W4],W0L
06174:  SE      W0,W0
06176:  MOV     W0,FB8
....................                   } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     } 
.................... #endif 
....................                     // Check if we're in the root 
....................                     if (tempCWD->dirclus == FatRootDirClusterValue) 
06178:  MOV     #2E,W0
0617A:  ADD     FFA,W0
0617C:  MOV     #A,W4
0617E:  MOV     [W0++],[W4++]
06180:  MOV     [W0++],[W4++]
06182:  MOV     858,W4
06184:  CP      W4,W5
06186:  BRA     NZ,619A
06188:  MOV     85A,W4
0618A:  CP      W4,W6
0618C:  BRA     NZ,619A
....................                     { 
....................                         // Fails if there's a dotdot chdir from the root 
....................                         FSerrno = CE_INVALID_ARGUMENT; 
0618E:  MOV.B   #1F,W0L
06190:  MOV.B   W0L,857
....................                         return -1; 
06192:  SETM    0
06194:  BRA     6514
....................                     } 
06196:  GOTO    62CE
....................                     else 
....................                     { 
....................                         // Cache the dotdot entry 
....................                         tempCWD->dirccls = tempCWD->dirclus; 
0619A:  MOV     #32,W0
0619C:  ADD     FFA,W0
0619E:  MOV     W0,W5
061A0:  MOV     #2E,W0
061A2:  ADD     FFA,W0
061A4:  MOV     [W0++],[W5++]
061A6:  MOV     [W0++],[W5++]
....................                         curent = 1; 
061A8:  MOV     #1,W4
061AA:  MOV     W4,FBE
....................                         entry = Cache_File_Entry (tempCWD, &curent, TRUE); 
061AC:  MOV.B   #1,W0L
061AE:  MOV.B   W0L,102C
061B0:  PUSH    FFA
061B2:  POP     1028
061B4:  MOV     #FBE,W4
061B6:  MOV     W4,102A
061B8:  CALL    31E4
061BC:  MOV     W0,FC0
....................                         if (entry == NULL) 
061BE:  CP0     FC0
061C0:  BRA     NZ,61CA
....................                         { 
....................                             FSerrno = CE_BADCACHEREAD; 
061C2:  MOV.B   #1B,W0L
061C4:  MOV.B   W0L,857
....................                             return -1; 
061C6:  SETM    0
061C8:  BRA     6514
....................                         } 
....................  
....................                         // Get the cluster 
....................                         tempCWD->dirclus = GetFullClusterNumber(entry); // Get Complete Cluster number. 
061CA:  MOV     #2E,W0
061CC:  ADD     FFA,W0
061CE:  MOV     W0,W5
061D0:  PUSH    FC0
061D2:  POP     102A
061D4:  CALL    34B4
061D8:  MOV     #0,W4
061DA:  MOV     [W4++],[W5++]
061DC:  MOV     [W4++],[W5++]
....................                         tempCWD->dirccls = tempCWD->dirclus; 
061DE:  MOV     #32,W0
061E0:  ADD     FFA,W0
061E2:  MOV     W0,W5
061E4:  MOV     #2E,W0
061E6:  ADD     FFA,W0
061E8:  MOV     [W0++],[W5++]
061EA:  MOV     [W0++],[W5++]
....................  
....................                         // If we changed to root, record the name 
....................                         if (tempCWD->dirclus == VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT) // "0" is the value of Dotdot entry for Root in both FAT types. 
061EC:  MOV     #2E,W0
061EE:  ADD     FFA,W0
061F0:  MOV     #A,W4
061F2:  MOV     [W0++],[W4++]
061F4:  MOV     [W0++],[W4++]
061F6:  CP0     W5
061F8:  BRA     NZ,6246
061FA:  CP0     W6
061FC:  BRA     NZ,6246
....................                         { 
....................                             j = 0; 
061FE:  CLR     FBA
....................                             tempCWD->name[j++] = '\\'; 
06200:  MOV     FBA,W0
06202:  INC     0FBA
06204:  MOV     W0,W5
06206:  ADD     W5,#1C,W5
06208:  MOV     W5,W0
0620A:  MOV     FFA,W4
0620C:  ADD     W0,W4,W6
0620E:  MOV.B   #5C,W0L
06210:  MOV.B   W0L,[W6]
.................... //                            if(utfModeFileName) 
.................... //                     { 
.................... //                               tempCWD->name[j++] = 0x00; 
.................... //                     } 
....................                             for (;j < 11;) 
06212:  MOV     FBA,W4
06214:  CP      W4,#B
06216:  BRA     C,622A
....................                             { 
....................                                 tempCWD->name[j] = 0x20; 
06218:  MOV     #1C,W0
0621A:  ADD     FBA,W0
0621C:  MOV     FFA,W4
0621E:  ADD     W0,W4,W5
06220:  MOV.B   #20,W0L
06222:  MOV.B   W0L,[W5]
....................                                ++j; 
06224:  INC     0FBA
06226:  GOTO    6212
....................                             } 
....................  
....................                             /* While moving to Root, get the Root cluster value */ 
....................                             tempCWD->dirccls = FatRootDirClusterValue; 
0622A:  MOV     #32,W0
0622C:  ADD     FFA,W0
0622E:  MOV     W0,W5
06230:  MOV     #858,W4
06232:  MOV     [W4++],[W5++]
06234:  MOV     [W4++],[W5++]
....................                             tempCWD->dirclus = FatRootDirClusterValue; 
06236:  MOV     #2E,W0
06238:  ADD     FFA,W0
0623A:  MOV     W0,W5
0623C:  MOV     #858,W4
0623E:  MOV     [W4++],[W5++]
06240:  MOV     [W4++],[W5++]
....................                         } 
06242:  GOTO    6284
....................                         else 
....................                         { 
....................                             // Otherwise set the name to .. 
....................                             j = 0; 
06246:  CLR     FBA
....................                             tempCWD->name[j++] = '.'; 
06248:  MOV     FBA,W0
0624A:  INC     0FBA
0624C:  MOV     W0,W5
0624E:  ADD     W5,#1C,W5
06250:  MOV     W5,W0
06252:  MOV     FFA,W4
06254:  ADD     W0,W4,W6
06256:  MOV.B   #2E,W0L
06258:  MOV.B   W0L,[W6]
.................... //                            if(utfModeFileName) 
.................... //                     { 
.................... //                               tempCWD->name[j++] = 0x00; 
.................... //                               tempCWD->name[j++] = '.'; 
.................... //                               tempCWD->name[j++] = 0x00; 
.................... //                     } 
.................... //                     else 
....................                      { 
....................                                tempCWD->name[j++] = '.'; 
0625A:  MOV     FBA,W0
0625C:  INC     0FBA
0625E:  MOV     W0,W5
06260:  ADD     W5,#1C,W5
06262:  MOV     W5,W0
06264:  MOV     FFA,W4
06266:  ADD     W0,W4,W6
06268:  MOV.B   #2E,W0L
0626A:  MOV.B   W0L,[W6]
....................                             } 
....................                             for (; j < 11;) 
0626C:  MOV     FBA,W4
0626E:  CP      W4,#B
06270:  BRA     C,6284
....................                             { 
....................                                 tempCWD->name[j] = 0x20; 
06272:  MOV     #1C,W0
06274:  ADD     FBA,W0
06276:  MOV     FFA,W4
06278:  ADD     W0,W4,W5
0627A:  MOV.B   #20,W0L
0627C:  MOV.B   W0L,[W5]
....................                                ++j; 
0627E:  INC     0FBA
06280:  GOTO    626C
....................                             } 
....................                         } 
....................                         // Cache the dot entry 
....................                         curent = 0; 
06284:  CLR     FBE
....................                         if (Cache_File_Entry(tempCWD, &curent, TRUE) == NULL) 
06286:  MOV.B   #1,W0L
06288:  MOV.B   W0L,102C
0628A:  PUSH    FFA
0628C:  POP     1028
0628E:  MOV     #FBE,W4
06290:  MOV     W4,102A
06292:  CALL    31E4
06296:  MOV     W0,W5
06298:  CP0     W5
0629A:  BRA     NZ,62A4
....................                         { 
....................                             FSerrno = CE_BADCACHEREAD; 
0629C:  MOV.B   #1B,W0L
0629E:  MOV.B   W0L,857
....................                             return -1; 
062A0:  SETM    0
062A2:  BRA     6514
....................                         } 
....................                         // Move past the next backslash, if necessary 
....................                         while (i == '\\') 
062A4:  MOV     FB8,W4
062A6:  XOR     #5C,W4
062A8:  BRA     NZ,62BA
....................                         { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                             if (mode) 
....................                             { 
....................                         #ifdef SUPPORT_LFN 
....................                         if(utfModeFileName) 
....................  
....................                         { 
....................  
....................                                 utf16path2++; 
....................                                 i = *utf16path2; 
....................                         } 
....................                         else 
....................                         #endif 
....................                         { 
....................                                 temppath2++; 
....................                                 i = *temppath2; 
....................                         } 
....................                             } 
....................                             else 
....................                             { 
.................... #endif 
....................                         #ifdef SUPPORT_LFN 
....................                         if(utfModeFileName) 
....................  
....................                         { 
....................  
....................                                 utf16path++; 
....................                                 i = *utf16path; 
....................                         } 
....................                         else 
....................                         #endif 
....................                         { 
....................                                 temppath++; 
062AA:  INC     0FC2
....................                                 i = *temppath; 
062AC:  MOV     FC2,W0
062AE:  MOV     W0,W4
062B0:  MOV.B   [W4],W0L
062B2:  SE      W0,W0
062B4:  MOV     W0,FB8
....................                         } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
062B6:  GOTO    62A4
....................                             } 
.................... #endif 
....................                         } 
....................                         // Copy and return, if we're at the end 
....................                         if (i == 0) 
062BA:  CP0     FB8
062BC:  BRA     NZ,62CE
....................                         { 
....................                             FileObjectCopy (cwdptr, tempCWD); 
062BE:  PUSH    904
062C0:  POP     1002
062C2:  PUSH    FFA
062C4:  POP     1004
062C6:  CALL    28E2
....................                             return 0; 
062CA:  CLR     0
062CC:  BRA     6514
....................                         } 
....................                     } 
....................                 } 
062CE:  GOTO    6326
....................                 else 
....................                 { 
....................                     // If we ended with a . entry, 
....................                     // just return what we have 
....................                     if (i == 0) 
062D2:  CP0     FB8
062D4:  BRA     NZ,62EA
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
062D6:  PUSH    904
062D8:  POP     1002
062DA:  PUSH    FFA
062DC:  POP     1004
062DE:  CALL    28E2
....................                         return 0; 
062E2:  CLR     0
062E4:  BRA     6514
....................                     } 
062E6:  GOTO    6326
....................                     else 
....................                     { 
....................                         if (i == '\\') 
062EA:  MOV     FB8,W4
062EC:  XOR     #5C,W4
062EE:  BRA     NZ,631E
....................                         { 
....................                             while (i == '\\') 
062F0:  MOV     FB8,W4
062F2:  XOR     #5C,W4
062F4:  BRA     NZ,6306
....................                             { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                                 if (mode) 
....................                                 { 
....................                            #ifdef SUPPORT_LFN 
....................                            if(utfModeFileName) 
....................  
....................                            { 
....................  
....................                                    utf16path2++; 
....................                                    i = *utf16path2; 
....................                            } 
....................                            else 
....................                            #endif 
....................                            { 
....................                                    temppath2++; 
....................                                    i = *temppath2; 
....................                            } 
....................                                 } 
....................                                 else 
....................                                 { 
.................... #endif 
....................                            #ifdef SUPPORT_LFN 
....................                            if(utfModeFileName) 
....................  
....................                            { 
....................  
....................                                    utf16path++; 
....................                                    i = *utf16path; 
....................                            } 
....................                            else 
....................                            #endif 
....................                            { 
....................                                    temppath++; 
062F6:  INC     0FC2
....................                                    i = *temppath; 
062F8:  MOV     FC2,W0
062FA:  MOV     W0,W4
062FC:  MOV.B   [W4],W0L
062FE:  SE      W0,W0
06300:  MOV     W0,FB8
....................                            } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
06302:  GOTO    62F0
....................                                 } 
.................... #endif 
....................                             } 
....................                             if (i == 0) 
06306:  CP0     FB8
06308:  BRA     NZ,631A
....................                             { 
....................                                 FileObjectCopy (cwdptr, tempCWD); 
0630A:  PUSH    904
0630C:  POP     1002
0630E:  PUSH    FFA
06310:  POP     1004
06312:  CALL    28E2
....................                                 return 0; 
06316:  CLR     0
06318:  BRA     6514
....................                             } 
....................                         } 
0631A:  GOTO    6326
....................                         else 
....................                         { 
....................                             // Anything else after a dot doesn't make sense 
....................                             FSerrno = CE_INVALID_ARGUMENT; 
0631E:  MOV.B   #1F,W0L
06320:  MOV.B   W0L,857
....................                             return -1; 
06322:  SETM    0
06324:  BRA     6514
....................                         } 
....................                     } 
....................                 } 
....................  
....................                 break; 
06326:  GOTO    6510
....................  
....................             // Second case: the first char is the root backslash 
....................             // We will ONLY switch to this case if the first char 
....................             // of the path is a backslash 
....................             case '\\': 
....................             // Increment pointer to second char 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             if (mode) 
....................             { 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................  
....................             { 
....................  
....................                     utf16path2++; 
....................                     i = *utf16path2; 
....................             } 
....................             else 
....................             #endif 
....................             { 
....................                     temppath2++; 
....................                     i = *temppath2; 
....................             } 
....................             } 
....................             else 
....................             { 
.................... #endif 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................  
....................             { 
....................  
....................                     utf16path++; 
....................                     i = *utf16path; 
....................             } 
....................             else 
....................             #endif 
....................             { 
....................                     temppath++; 
0632A:  INC     0FC2
....................                     i = *temppath; 
0632C:  MOV     FC2,W0
0632E:  MOV     W0,W4
06330:  MOV.B   [W4],W0L
06332:  SE      W0,W0
06334:  MOV     W0,FB8
....................             } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             } 
.................... #endif 
....................             // Can't start the path with multiple backslashes 
....................             if (i == '\\') 
06336:  MOV     FB8,W4
06338:  XOR     #5C,W4
0633A:  BRA     NZ,6344
....................             { 
....................                 FSerrno = CE_INVALID_ARGUMENT; 
0633C:  MOV.B   #1F,W0L
0633E:  MOV.B   W0L,857
....................                 return -1; 
06340:  SETM    0
06342:  BRA     6514
....................             } 
....................  
....................             if (i == 0) 
06344:  CP0     FB8
06346:  BRA     NZ,6394
....................             { 
....................                 // The user is changing directory to 
....................                 // the root 
....................                 cwdptr->dirclus = FatRootDirClusterValue; 
06348:  MOV     #2E,W0
0634A:  ADD     904,W0
0634C:  MOV     W0,W5
0634E:  MOV     #858,W4
06350:  MOV     [W4++],[W5++]
06352:  MOV     [W4++],[W5++]
....................                 cwdptr->dirccls = FatRootDirClusterValue; 
06354:  MOV     #32,W0
06356:  ADD     904,W0
06358:  MOV     W0,W5
0635A:  MOV     #858,W4
0635C:  MOV     [W4++],[W5++]
0635E:  MOV     [W4++],[W5++]
....................                 j = 0; 
06360:  CLR     FBA
....................                 cwdptr->name[j++] = '\\'; 
06362:  MOV     FBA,W0
06364:  INC     0FBA
06366:  MOV     W0,W5
06368:  ADD     W5,#1C,W5
0636A:  MOV     W5,W0
0636C:  MOV     904,W4
0636E:  ADD     W0,W4,W6
06370:  MOV.B   #5C,W0L
06372:  MOV.B   W0L,[W6]
.................... //                if(utfModeFileName) 
.................... //            { 
.................... //                   cwdptr->name[j++] = 0x00; 
.................... //            } 
....................                 for (; j < 11;) 
06374:  MOV     FBA,W4
06376:  CP      W4,#B
06378:  BRA     C,638C
....................                 { 
....................                     cwdptr->name[j] = 0x20; 
0637A:  MOV     #1C,W0
0637C:  ADD     FBA,W0
0637E:  MOV     904,W4
06380:  ADD     W0,W4,W5
06382:  MOV.B   #20,W0L
06384:  MOV.B   W0L,[W5]
....................                    ++j; 
06386:  INC     0FBA
06388:  GOTO    6374
....................                 } 
....................                 return 0; 
0638C:  CLR     0
0638E:  BRA     6514
....................             } 
06390:  GOTO    63D8
....................             else 
....................             { 
....................                 // Our first char is the root dir switch 
....................                 tempCWD->dirclus = FatRootDirClusterValue; 
06394:  MOV     #2E,W0
06396:  ADD     FFA,W0
06398:  MOV     W0,W5
0639A:  MOV     #858,W4
0639C:  MOV     [W4++],[W5++]
0639E:  MOV     [W4++],[W5++]
....................                 tempCWD->dirccls = FatRootDirClusterValue; 
063A0:  MOV     #32,W0
063A2:  ADD     FFA,W0
063A4:  MOV     W0,W5
063A6:  MOV     #858,W4
063A8:  MOV     [W4++],[W5++]
063AA:  MOV     [W4++],[W5++]
....................                 j = 0; 
063AC:  CLR     FBA
....................                 tempCWD->name[j++] = '\\'; 
063AE:  MOV     FBA,W0
063B0:  INC     0FBA
063B2:  MOV     W0,W5
063B4:  ADD     W5,#1C,W5
063B6:  MOV     W5,W0
063B8:  MOV     FFA,W4
063BA:  ADD     W0,W4,W6
063BC:  MOV.B   #5C,W0L
063BE:  MOV.B   W0L,[W6]
.................... //                if(utfModeFileName) 
.................... //            { 
.................... //                   tempCWD->name[j++] = 0x00; 
.................... //            } 
....................                 for (; j < 11;) 
063C0:  MOV     FBA,W4
063C2:  CP      W4,#B
063C4:  BRA     C,63D8
....................                 { 
....................                     tempCWD->name[j] = 0x20; 
063C6:  MOV     #1C,W0
063C8:  ADD     FBA,W0
063CA:  MOV     FFA,W4
063CC:  ADD     W0,W4,W5
063CE:  MOV.B   #20,W0L
063D0:  MOV.B   W0L,[W5]
....................                    ++j; 
063D2:  INC     0FBA
063D4:  GOTO    63C0
....................                 } 
....................             } 
....................             break; 
063D8:  GOTO    6510
....................  
....................         default: 
....................             // We should be at the beginning of a string of letters/numbers 
....................             j = 0; 
063DC:  CLR     FBA
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             if (mode) 
....................             { 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................  
....................             { 
....................  
....................                    // Change directories as specified 
....................                k = 512; 
....................  
....................  
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempDirectoryString[j++] = i; 
....................                        tempDirectoryString[j++] = i >> 8; 
....................                        i = *(++utf16path2); 
....................                    } 
....................  
....................                tempDirectoryString[j++] = 0; 
....................             } 
....................  
....................             else 
....................  
....................             #endif 
....................               { 
....................  
....................                #if defined(SUPPORT_LFN) 
....................  
....................                   k = 256; 
....................  
....................                #else 
....................  
....................                   k = 12; 
....................  
....................                #endif 
....................  
....................  
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempDirectoryString[j++] = i; 
....................                        i = *(++temppath2); 
....................                    } 
....................             } 
....................  
....................             } 
....................             else 
....................             { 
.................... #endif 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................  
....................             { 
....................  
....................                    // Change directories as specified 
....................                k = 512; 
....................  
....................  
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempDirectoryString[j++] = i; 
....................                        tempDirectoryString[j++] = i >> 8; 
....................                        i = *(++utf16path); 
....................                    } 
....................  
....................                tempDirectoryString[j++] = 0; 
....................             } 
....................  
....................             else 
....................  
....................             #endif 
....................               { 
....................  
....................                #if defined(SUPPORT_LFN) 
....................  
....................                   k = 256; 
....................  
....................                #else 
....................  
....................                   k = 12; 
063DE:  MOV     #C,W4
063E0:  MOV     W4,FBC
....................  
....................                #endif 
....................  
....................  
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
063E2:  CP0     FB8
063E4:  BRA     Z,6412
063E6:  MOV     FB8,W4
063E8:  XOR     #5C,W4
063EA:  BRA     Z,6412
063EC:  MOV     FBA,W0
063EE:  MOV     FBC,W4
063F0:  CP      W4,W0
063F2:  BRA     LEU,6412
....................                    { 
....................                        tempDirectoryString[j++] = i; 
063F4:  MOV     FBA,W0
063F6:  INC     0FBA
063F8:  MOV     W0,W5
063FA:  MOV     #D2E,W4
063FC:  ADD     W5,W4,W6
063FE:  MOV     FB8,W0
06400:  MOV.B   W0L,[W6+#0]
....................                        i = *(++temppath); 
06402:  INC     0FC2
06404:  MOV     FC2,W0
06406:  MOV     W0,W4
06408:  MOV.B   [W4],W0L
0640A:  SE      W0,W0
0640C:  MOV     W0,FB8
0640E:  GOTO    63E2
....................                    } 
....................             } 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             } 
.................... #endif 
....................  
....................             tempDirectoryString[j++] = 0; 
06412:  MOV     FBA,W0
06414:  INC     0FBA
06416:  MOV     W0,W5
06418:  MOV     #D2E,W4
0641A:  ADD     W5,W4,W6
0641C:  CLR.B   [W6]
....................  
....................             // We got a whole 12 chars 
....................             // There could be more- truncate it 
....................             if (j > k) 
0641E:  MOV     FBC,W0
06420:  MOV     FBA,W4
06422:  CP      W4,W0
06424:  BRA     LEU,6440
....................             { 
....................                 while ((i != 0) && (i != '\\')) 
06426:  CP0     FB8
06428:  BRA     Z,6440
0642A:  MOV     FB8,W4
0642C:  XOR     #5C,W4
0642E:  BRA     Z,6440
....................                 { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     if (mode) 
....................                     { 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                            i = *(++utf16path2); 
....................                        } 
....................                   else 
....................                   #endif 
....................                   { 
....................  
....................                            i = *(++temppath2); 
....................                        } 
....................                     } 
....................                     else 
....................                     { 
.................... #endif 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                            i = *(++utf16path); 
....................                        } 
....................                   else 
....................                   #endif 
....................                   { 
....................  
....................                            i = *(++temppath); 
06430:  INC     0FC2
06432:  MOV     FC2,W0
06434:  MOV     W0,W4
06436:  MOV.B   [W4],W0L
06438:  SE      W0,W0
0643A:  MOV     W0,FB8
....................                        } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
0643C:  GOTO    6426
....................                     } 
.................... #endif 
....................                 } 
....................             } 
....................  
....................             if (FormatDirName (tempDirectoryString, tempCWD,0) == FALSE) 
06440:  CLR.B   1006
06442:  MOV     #D2E,W4
06444:  MOV     W4,1002
06446:  PUSH    FFA
06448:  POP     1004
0644A:  CALL    5F64
0644E:  CP0.B   W0L
06450:  BRA     NZ,6456
....................                 return -1; 
06452:  SETM    0
06454:  BRA     6514
....................  
....................             // copy file object over 
....................             FileObjectCopy(&gFileTemp, tempCWD); 
06456:  MOV     #898,W4
06458:  MOV     W4,1002
0645A:  PUSH    FFA
0645C:  POP     1004
0645E:  CALL    28E2
....................  
....................             // See if the directory is there 
....................             if(FILEfind (&gFileTemp, tempCWD, LOOK_FOR_MATCHING_ENTRY, 0) != CE_GOOD) 
06462:  MOV.B   #1,W0L
06464:  MOV.B   W0L,1006
06466:  CLR.B   1007
06468:  MOV     #898,W4
0646A:  MOV     W4,1002
0646C:  PUSH    FFA
0646E:  POP     1004
06470:  CALL    36BE
06474:  CP0.B   W0L
06476:  BRA     Z,6484
....................             { 
....................                 // Couldn't find the DIR 
....................                 FSerrno = CE_DIR_NOT_FOUND; 
06478:  MOV.B   #C,W0L
0647A:  MOV.B   W0L,857
....................                 return -1; 
0647C:  SETM    0
0647E:  BRA     6514
....................             } 
06480:  GOTO    64CA
....................             else 
....................             { 
....................                 // Found the file 
....................                 // Check to make sure it's actually a directory 
....................                 if ((gFileTemp.attributes & ATTR_DIRECTORY) == 0 ) 
06484:  MOV     8C4,W0
06486:  AND     W0,#10,W5
06488:  CP0     W5
0648A:  BRA     NZ,6494
....................                 { 
....................                     FSerrno = CE_INVALID_ARGUMENT; 
0648C:  MOV.B   #1F,W0L
0648E:  MOV.B   W0L,857
....................                     return -1; 
06490:  SETM    0
06492:  BRA     6514
....................                 } 
....................  
....................                 // Get the new name 
....................             #if defined(SUPPORT_LFN) 
....................                if(!tempCWD->utf16LFNlength) 
....................             #endif 
....................                       for (j = 0; j < 11; j++) 
06494:  CLR     FBA
06496:  MOV     FBA,W4
06498:  CP      W4,#B
0649A:  BRA     C,64B0
....................                       { 
....................                           tempCWD->name[j] = gFileTemp.name[j]; 
0649C:  MOV     #1C,W0
0649E:  ADD     FBA,W0
064A0:  MOV     FFA,W4
064A2:  ADD     W0,W4,W5
064A4:  MOV     #8B4,W0
064A6:  ADD     FBA,W0
064A8:  MOV.B   [W0],[W5]
064AA:  INC     0FBA
064AC:  GOTO    6496
....................                       } 
....................  
....................                 tempCWD->dirclus = gFileTemp.cluster; 
064B0:  MOV     #2E,W0
064B2:  ADD     FFA,W0
064B4:  MOV     W0,W5
064B6:  MOV     #89A,W4
064B8:  MOV     [W4++],[W5++]
064BA:  MOV     [W4++],[W5++]
....................                 tempCWD->dirccls = tempCWD->dirclus; 
064BC:  MOV     #32,W0
064BE:  ADD     FFA,W0
064C0:  MOV     W0,W5
064C2:  MOV     #2E,W0
064C4:  ADD     FFA,W0
064C6:  MOV     [W0++],[W5++]
064C8:  MOV     [W0++],[W5++]
....................             } 
....................  
....................             if (i == 0) 
064CA:  CP0     FB8
064CC:  BRA     NZ,64E2
....................             { 
....................                 // If we're at the end of the string, we're done 
....................                 FileObjectCopy (cwdptr, tempCWD); 
064CE:  PUSH    904
064D0:  POP     1002
064D2:  PUSH    FFA
064D4:  POP     1004
064D6:  CALL    28E2
....................                 return 0; 
064DA:  CLR     0
064DC:  BRA     6514
....................             } 
064DE:  GOTO    650C
....................             else 
....................             { 
....................                 while (i == '\\') 
064E2:  MOV     FB8,W4
064E4:  XOR     #5C,W4
064E6:  BRA     NZ,650C
....................                 { 
....................                     // If we get to another backslash, increment past it 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     if (mode) 
....................                     { 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                           utf16path2++; 
....................                           i = *utf16path2; 
....................                   } 
....................                   else 
....................                   #endif 
....................                   { 
....................                           temppath2++; 
....................                           i = *temppath2; 
....................                   } 
....................                     } 
....................                     else 
....................                     { 
.................... #endif 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                           utf16path++; 
....................                           i = *utf16path; 
....................                   } 
....................                   else 
....................                   #endif 
....................                   { 
....................                           temppath++; 
064E8:  INC     0FC2
....................                           i = *temppath; 
064EA:  MOV     FC2,W0
064EC:  MOV     W0,W4
064EE:  MOV.B   [W4],W0L
064F0:  SE      W0,W0
064F2:  MOV     W0,FB8
....................                   } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     } 
.................... #endif 
....................                     if (i == 0) 
064F4:  CP0     FB8
064F6:  BRA     NZ,6508
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
064F8:  PUSH    904
064FA:  POP     1002
064FC:  PUSH    FFA
064FE:  POP     1004
06500:  CALL    28E2
....................                         return 0; 
06504:  CLR     0
06506:  BRA     6514
....................                     } 
06508:  GOTO    64E2
....................                 } 
....................             } 
....................             break; 
0650C:  GOTO    6510
....................         } 
06510:  GOTO    614E
....................     } // loop 
06514:  MOV     [--W15],W6
06516:  MOV     [--W15],W5
06518:  RETURN  
.................... } 
....................  
....................  
....................  
.................... // This string is used by FSgetcwd to return the cwd name if the path 
.................... // passed into the function is NULL 
.................... char defaultArray [10]; 
....................  
....................  
.................... /************************************************************** 
....................   Function: 
....................     char * FSgetcwd (char * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in Ascii format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in Ascii format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name 
....................     into the buffer backwards, and insert a backslash character. 
....................     Next, the function will continuously switch to the previous 
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the 
....................     root. 
....................   Remarks: 
....................     None 
....................   **************************************************************/ 
.................... char * FSgetcwd (char * path, int numchars) 
*
055BA:  MOV     W5,[W15++]
055BC:  MOV     W6,[W15++]
055BE:  MOV     W7,[W15++]
055C0:  CP0     FB6
055C2:  BRA     NZ,55CA
055C4:  MOV     #A,W0
055C6:  GOTO    55CC
055CA:  MOV     FB8,W0
055CC:  MOV     W0,FBA
*
055D2:  MOV     #898,W4
055D4:  MOV     W4,FC0
055D6:  CLR.B   FC2
*
055E2:  CLR     FCC
055E4:  CLR     FCE
.................... { 
....................     // If path is passed in as null, set up a default 
....................     // array with 10 characters 
....................     unsigned short int totalchars = (path == NULL) ? 10 : numchars; 
....................     char * returnPointer; 
*
055CE:  CLR     FBC
....................     char * bufferEnd; 
055D0:  CLR     FBE
....................     FILEOBJ tempCWD = &gFileTemp; 
....................     BYTE bufferOverflow = FALSE; 
....................     signed char j; 
*
055D8:  CLR.B   FC3
....................     DWORD curclus; 
055DA:  CLR     FC4
055DC:  CLR     FC6
....................     WORD fHandle, tempindex; 
055DE:  CLR     FC8
055E0:  CLR     FCA
....................     short int i = 0, index = 0; 
....................     char aChar; 
*
055E6:  CLR.B   FD0
....................     DIRENTRY entry; 
055E8:  CLR     FD2
....................  
....................    #if defined(SUPPORT_LFN) 
....................    WORD prevHandle; 
....................    UINT16_VAL tempShift; 
....................    FSFILE cwdTemp; 
....................    LFN_ENTRY *lfno; 
....................    unsigned short int *tempLFN = (unsigned short int *)&tempDirectoryString[0]; 
....................    #endif 
....................  
....................     FSerrno = CE_GOOD; 
055EA:  CLR.B   857
....................  
....................     // Set up the return value 
....................     if (path == NULL) 
055EC:  CP0     FB6
055EE:  BRA     NZ,55F8
....................         returnPointer = defaultArray; 
055F0:  MOV     #D3C,W4
055F2:  MOV     W4,FBC
055F4:  GOTO    5608
....................     else 
....................     { 
....................         returnPointer = path; 
055F8:  PUSH    FB6
055FA:  POP     FBC
....................         if (numchars == 0) 
055FC:  CP0     FB8
055FE:  BRA     NZ,5608
....................         { 
....................             FSerrno = CE_INVALID_ARGUMENT; 
05600:  MOV.B   #1F,W0L
05602:  MOV.B   W0L,857
....................             return NULL; 
05604:  CLR     0
05606:  BRA     599C
....................         } 
....................     } 
....................  
....................     bufferEnd = returnPointer + totalchars - 1; 
05608:  MOV     FBC,W0
0560A:  ADD     FBA,W0
0560C:  MOV     W0,W5
0560E:  SUB     W5,#1,W0
05610:  MOV     W0,FBE
....................  
....................     FileObjectCopy (tempCWD, cwdptr); 
05612:  PUSH    FC0
05614:  POP     1002
05616:  PUSH    904
05618:  POP     1004
0561A:  CALL    28E2
....................  
....................     if (((tempCWD->name[0] == '.') && (tempCWD->name[1] == '.')) 
....................       #if defined(SUPPORT_LFN) 
0561E:  MOV     #1C,W0
05620:  ADD     FC0,W0
05622:  MOV.B   [W0],W4L
05624:  XOR.B   #2E,W4L
05626:  BRA     NZ,578E
05628:  MOV     #1D,W0
0562A:  ADD     FC0,W0
0562C:  MOV.B   [W0],W4L
0562E:  XOR.B   #2E,W4L
05630:  BRA     NZ,578E
....................        || tempCWD->utf16LFNlength 
....................       #endif 
....................       ) 
....................     { 
....................         // We last changed directory into a dotdot entry 
....................         // Save the value of the current directory 
....................         curclus = tempCWD->dirclus; 
05632:  MOV     #2E,W0
05634:  ADD     FC0,W0
05636:  MOV     #FC4,W4
05638:  MOV     [W0++],[W4++]
0563A:  MOV     [W0++],[W4++]
....................         // Put this dir's dotdot entry into the dirclus 
....................         // Our cwd absolutely is not the root 
....................         fHandle = 1; 
0563C:  MOV     #1,W4
0563E:  MOV     W4,FC8
....................         tempCWD->dirccls = tempCWD->dirclus; 
05640:  MOV     #32,W0
05642:  ADD     FC0,W0
05644:  MOV     W0,W5
05646:  MOV     #2E,W0
05648:  ADD     FC0,W0
0564A:  MOV     [W0++],[W5++]
0564C:  MOV     [W0++],[W5++]
....................         entry = Cache_File_Entry (tempCWD,&fHandle, TRUE); 
0564E:  MOV.B   #1,W0L
05650:  MOV.B   W0L,102C
05652:  PUSH    FC0
05654:  POP     1028
05656:  MOV     #FC8,W4
05658:  MOV     W4,102A
0565A:  CALL    31E4
0565E:  MOV     W0,FD2
....................         if (entry == NULL) 
05660:  CP0     FD2
05662:  BRA     NZ,566C
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
05664:  MOV.B   #1B,W0L
05666:  MOV.B   W0L,857
....................             return NULL; 
05668:  CLR     0
0566A:  BRA     599C
....................         } 
....................  
....................        // Get the cluster 
....................        TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number. 
0566C:  PUSH    FD2
0566E:  POP     102A
05670:  CALL    34B4
05674:  MOV     W0,85C
05676:  MOV     W1,85E
....................  
....................         // For FAT32, if the .. entry is 0, the cluster won't be 0 
.................... #ifdef SUPPORT_FAT32 
....................         if (TempClusterCalc == VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT) 
05678:  CP0     85C
0567A:  BRA     NZ,5690
0567C:  CP0     85E
0567E:  BRA     NZ,5690
....................         { 
....................             tempCWD->dirclus = FatRootDirClusterValue; 
05680:  MOV     #2E,W0
05682:  ADD     FC0,W0
05684:  MOV     W0,W5
05686:  MOV     #858,W4
05688:  MOV     [W4++],[W5++]
0568A:  MOV     [W4++],[W5++]
....................         } 
0568C:  GOTO    569C
....................         else 
.................... #endif 
....................             tempCWD->dirclus = TempClusterCalc; 
05690:  MOV     #2E,W0
05692:  ADD     FC0,W0
05694:  MOV     W0,W5
05696:  MOV     #85C,W4
05698:  MOV     [W4++],[W5++]
0569A:  MOV     [W4++],[W5++]
....................  
....................         tempCWD->dirccls = tempCWD->dirclus; 
0569C:  MOV     #32,W0
0569E:  ADD     FC0,W0
056A0:  MOV     W0,W5
056A2:  MOV     #2E,W0
056A4:  ADD     FC0,W0
056A6:  MOV     [W0++],[W5++]
056A8:  MOV     [W0++],[W5++]
....................  
....................         // Find the direntry for the entry we were just in 
....................         fHandle = 0; 
056AA:  CLR     FC8
....................         entry = Cache_File_Entry (tempCWD, &fHandle, TRUE); 
056AC:  MOV.B   #1,W0L
056AE:  MOV.B   W0L,102C
056B0:  PUSH    FC0
056B2:  POP     1028
056B4:  MOV     #FC8,W4
056B6:  MOV     W4,102A
056B8:  CALL    31E4
056BC:  MOV     W0,FD2
....................         if (entry == NULL) 
056BE:  CP0     FD2
056C0:  BRA     NZ,56CA
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
056C2:  MOV.B   #1B,W0L
056C4:  MOV.B   W0L,857
....................             return NULL; 
056C6:  CLR     0
056C8:  BRA     599C
....................         } 
....................  
....................         // Get the cluster 
....................         TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number. 
056CA:  PUSH    FD2
056CC:  POP     102A
056CE:  CALL    34B4
056D2:  MOV     W0,85C
056D4:  MOV     W1,85E
....................  
....................         while ((TempClusterCalc != curclus) || 
....................             ((TempClusterCalc == curclus) && 
....................             (((unsigned char)entry->DIR_Name[0] == 0xE5) || (entry->DIR_Attr == ATTR_VOLUME) || (entry->DIR_Attr == ATTR_LONG_NAME)))) 
056D6:  MOV     85C,W0
056D8:  CP      FC4
056DA:  BRA     NZ,570C
056DC:  MOV     85E,W0
056DE:  CP      FC6
056E0:  BRA     NZ,570C
056E2:  MOV     85C,W0
056E4:  CP      FC4
056E6:  BRA     NZ,573A
056E8:  MOV     85E,W0
056EA:  CP      FC6
056EC:  BRA     NZ,573A
056EE:  MOV     #0,W0
056F0:  ADD     FD2,W0
056F2:  MOV.B   [W0],W4L
056F4:  XOR.B   #E5,W4L
056F6:  BRA     Z,570C
056F8:  MOV     #B,W0
056FA:  ADD     FD2,W0
056FC:  MOV.B   [W0],W4L
056FE:  CP.B    W4L,#8
05700:  BRA     Z,570C
05702:  MOV     #B,W0
05704:  ADD     FD2,W0
05706:  MOV.B   [W0],W4L
05708:  CP.B    W4L,#F
0570A:  BRA     NZ,573A
....................         { 
....................             fHandle++; 
0570C:  INC     0FC8
....................             entry = Cache_File_Entry (tempCWD, &fHandle, FALSE); 
0570E:  CLR.B   102C
05710:  PUSH    FC0
05712:  POP     1028
05714:  MOV     #FC8,W4
05716:  MOV     W4,102A
05718:  CALL    31E4
0571C:  MOV     W0,FD2
....................             if (entry == NULL) 
0571E:  CP0     FD2
05720:  BRA     NZ,572A
....................             { 
....................                 FSerrno = CE_BADCACHEREAD; 
05722:  MOV.B   #1B,W0L
05724:  MOV.B   W0L,857
....................                 return NULL; 
05726:  CLR     0
05728:  BRA     599C
....................             } 
....................  
....................             // Get the cluster 
....................             TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number in a loop. 
0572A:  PUSH    FD2
0572C:  POP     102A
0572E:  CALL    34B4
05732:  MOV     W0,85C
05734:  MOV     W1,85E
....................         } 
....................  
....................       #if defined(SUPPORT_LFN) 
05736:  GOTO    56D6
....................           FileObjectCopy (&cwdTemp, tempCWD); 
....................          prevHandle = fHandle - 1; 
....................  
....................          lfno = (LFN_ENTRY *)Cache_File_Entry (tempCWD, &prevHandle, FALSE); 
....................  
....................  
....................          while((lfno->LFN_Attribute == ATTR_LONG_NAME) && (lfno->LFN_SequenceNo != DIR_DEL) 
....................  
....................                && (lfno->LFN_SequenceNo != DIR_EMPTY)) 
....................  
....................          { 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[0]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[1]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[2]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[3]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[4]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[5]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[6]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[7]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[8]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[9]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................  
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[0]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[1]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[2]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[3]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[4]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[5]; 
....................  
....................  
....................  
....................             tempLFN[i++] = lfno->LFN_Part3[0]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part3[1]; 
....................  
....................  
....................  
....................             prevHandle = prevHandle - 1; 
....................  
....................             lfno = (LFN_ENTRY *)Cache_File_Entry (tempCWD, &prevHandle, FALSE); 
....................  
....................          } 
....................  
....................          FileObjectCopy (tempCWD, &cwdTemp); 
....................       #endif 
....................  
....................          if(i == 0) 
0573A:  CP0     FCC
0573C:  BRA     NZ,5776
....................          { 
....................              for (j = 0; j < 11; j++) 
0573E:  CLR.B   FC3
05740:  MOV.B   FC3,W0L
05742:  SE      W0,W0
05744:  CP      W0,#B
05746:  BRA     GE,5776
....................               { 
....................                tempCWD->name[j] = entry->DIR_Name[j]; 
05748:  MOV.B   FC3,W0L
0574A:  SE      W0,W0
0574C:  ADD     W0,#1C,W0
0574E:  MOV     FC0,W4
05750:  ADD     W0,W4,W5
05752:  MOV.B   FC3,W0L
05754:  SE      W0,W0
05756:  MOV     FD2,W4
05758:  ADD     W0,W4,W0
0575A:  MOV.B   [W0],[W5]
....................                cwdptr->name[j] = entry->DIR_Name[j]; 
0575C:  MOV.B   FC3,W0L
0575E:  SE      W0,W0
05760:  ADD     W0,#1C,W0
05762:  MOV     904,W4
05764:  ADD     W0,W4,W5
05766:  MOV.B   FC3,W0L
05768:  SE      W0,W0
0576A:  MOV     FD2,W4
0576C:  ADD     W0,W4,W0
0576E:  MOV.B   [W0],[W5]
....................               } 
....................          #if defined(SUPPORT_LFN) 
05770:  INC.B   0FC3
05772:  GOTO    5740
....................             cwdptr->utf16LFNlength = 0; 
....................  
....................             tempCWD->utf16LFNlength = 0; 
....................  
....................          #endif 
....................          } 
....................  
....................       #if defined(SUPPORT_LFN) 
....................          else 
....................          { 
....................  
....................             tempCWD->utf16LFNlength = i; 
....................  
....................          for(j = 12;j >= 0;j--) 
....................          { 
....................             if((tempLFN[i - j - 1]) == 0x0000) 
....................             { 
....................                tempCWD->utf16LFNlength = i - j - 1; 
....................                break; 
....................             } 
....................          } 
....................          cwdptr->utf16LFNlength = tempCWD->utf16LFNlength; 
....................  
....................             tempCWD->utf16LFNptr = (unsigned short int *)&tempDirectoryString[0]; 
....................  
....................             cwdptr->utf16LFNptr = (unsigned short int *)&tempDirectoryString[0]; 
....................  
....................          } 
....................  
....................       #endif 
....................         // Reset our temp dir back to that cluster 
....................         tempCWD->dirclus = curclus; 
05776:  MOV     #2E,W0
05778:  ADD     FC0,W0
0577A:  MOV     W0,W5
0577C:  MOV     #FC4,W4
0577E:  MOV     [W4++],[W5++]
05780:  MOV     [W4++],[W5++]
....................         tempCWD->dirccls = curclus; 
05782:  MOV     #32,W0
05784:  ADD     FC0,W0
05786:  MOV     W0,W5
05788:  MOV     #FC4,W4
0578A:  MOV     [W4++],[W5++]
0578C:  MOV     [W4++],[W5++]
....................         // This will set us at the cwd, but it will actually 
....................         // have the name in the name field this time 
....................     } 
....................  
....................     // There's actually some kind of name value in the cwd 
....................    #if defined(SUPPORT_LFN) 
....................     if (((tempCWD->name[0] == '\\') && (tempCWD->utf16LFNlength == 0x0000)) || 
....................       ((tempCWD->utf16LFNlength != 0x0000) && (tempCWD->utf16LFNptr[0] == (unsigned short int)'\\')) || (numchars == 0x02)) 
....................    #else 
....................     if ((tempCWD->name[0] == '\\') || (numchars == 0x02)) 
0578E:  MOV     #1C,W0
05790:  ADD     FC0,W0
05792:  MOV.B   [W0],W4L
05794:  XOR.B   #5C,W4L
05796:  BRA     Z,579E
05798:  MOV     FB8,W4
0579A:  CP      W4,#2
0579C:  BRA     NZ,57B8
....................    #endif 
....................     { 
....................         // Easy, our CWD is the root 
....................         *returnPointer = '\\'; 
0579E:  MOV     FBC,W5
057A0:  MOV.B   #5C,W0L
057A2:  MOV.B   W0L,[W5]
....................         *(returnPointer + 1) = 0; 
057A4:  MOV     FBC,W4
057A6:  ADD     W4,#1,W4
057A8:  MOV     W4,W0
057AA:  MOV     W0,W5
057AC:  CLR.B   [W5]
....................         return returnPointer; 
057AE:  PUSH    FBC
057B0:  POP     0
057B2:  BRA     599C
....................     } 
057B4:  GOTO    58CE
....................     else 
....................     { 
....................         index = 0; 
057B8:  CLR     FCE
....................         // Loop until we get back to the root 
....................         while (tempCWD->dirclus != FatRootDirClusterValue) 
057BA:  MOV     #2E,W0
057BC:  ADD     FC0,W0
057BE:  MOV     #A,W4
057C0:  MOV     [W0++],[W4++]
057C2:  MOV     [W0++],[W4++]
057C4:  MOV     858,W4
057C6:  CP      W4,W5
057C8:  BRA     NZ,57D0
057CA:  MOV     85A,W4
057CC:  CP      W4,W6
057CE:  BRA     Z,58CE
....................         { 
....................          #if defined(SUPPORT_LFN) 
....................             if(tempCWD->utf16LFNlength) 
....................             { 
....................              i = tempCWD->utf16LFNlength * 2 - 1; 
....................              while(i >= 0) 
....................             { 
....................                #ifdef SUPPORT_LFN 
....................                if(twoByteMode) 
....................                { 
....................                   returnPointer[index++] = tempDirectoryString[i--]; 
....................                       if (index == totalchars) 
....................                       { 
....................                           index = 0; 
....................                           bufferOverflow = TRUE; 
....................                       } 
....................                } 
....................                else 
....................                #endif 
....................                { 
....................                   if(tempDirectoryString[i]) 
....................                   { 
....................                      returnPointer[index++] = tempDirectoryString[i]; 
....................                               if (index == totalchars) 
....................                               { 
....................                                   index = 0; 
....................                                   bufferOverflow = TRUE; 
....................                               } 
....................  
....................                   } 
....................                   i--; 
....................                } 
....................             } 
....................          } 
....................          else 
....................          #endif 
....................          { 
....................                j = 10; 
057D0:  MOV.B   #A,W0L
057D2:  MOV.B   W0L,FC3
....................                while (tempCWD->name[j] == 0x20) 
057D4:  MOV.B   FC3,W0L
057D6:  SE      W0,W0
057D8:  ADD     W0,#1C,W0
057DA:  MOV     FC0,W4
057DC:  ADD     W0,W4,W0
057DE:  MOV.B   [W0],W5L
057E0:  SE      W5,W5
057E2:  MOV     #20,W4
057E4:  CP      W4,W5
057E6:  BRA     NZ,57EE
....................                    j--; 
057E8:  DEC.B   0FC3
057EA:  GOTO    57D4
....................                if (j >= 8) 
057EE:  MOV.B   FC3,W0L
057F0:  SE      W0,W0
057F2:  CP      W0,#8
057F4:  BRA     LT,5842
....................                { 
....................                    while (j >= 8) 
057F6:  MOV.B   FC3,W0L
057F8:  SE      W0,W0
057FA:  CP      W0,#8
057FC:  BRA     LT,5828
....................                    { 
....................                        *(returnPointer + index++) = tempCWD->name[j--]; 
057FE:  MOV     FCE,W0
05800:  INC     0FCE
05802:  MOV     FBC,W4
05804:  ADD     W0,W4,W0
05806:  MOV     W0,W5
05808:  MOV.B   FC3,W0L
0580A:  DEC.B   0FC3
0580C:  SE      W0,W6
0580E:  ADD     W6,#1C,W6
05810:  MOV     W6,W0
05812:  MOV     FC0,W4
05814:  ADD     W0,W4,W0
05816:  MOV.B   [W0],[W5]
....................                        // This is a circular buffer 
....................                        // Any unnecessary values will be overwritten 
....................                        if (index == totalchars) 
05818:  MOV     FCE,W0
0581A:  CP      FBA
0581C:  BRA     NZ,5824
....................                        { 
....................                            index = 0; 
0581E:  CLR     FCE
....................                            bufferOverflow = TRUE; 
05820:  MOV.B   #1,W0L
05822:  MOV.B   W0L,FC2
....................                        } 
....................  
....................                   #ifdef SUPPORT_LFN 
05824:  GOTO    57F6
....................                   if(twoByteMode) 
....................                   { 
....................                      returnPointer[index++] = 0x00; 
....................                            if (index == totalchars) 
....................                            { 
....................                                index = 0; 
....................                                bufferOverflow = TRUE; 
....................                            } 
....................                   } 
....................                   #endif 
....................                    } 
....................  
....................                    *(returnPointer + index++) = '.'; 
05828:  MOV     FCE,W0
0582A:  INC     0FCE
0582C:  MOV     FBC,W4
0582E:  ADD     W0,W4,W0
05830:  MOV     W0,W5
05832:  MOV.B   #2E,W0L
05834:  MOV.B   W0L,[W5]
....................                    if (index == totalchars) 
05836:  MOV     FCE,W0
05838:  CP      FBA
0583A:  BRA     NZ,5842
....................                    { 
....................                        index = 0; 
0583C:  CLR     FCE
....................                        bufferOverflow = TRUE; 
0583E:  MOV.B   #1,W0L
05840:  MOV.B   W0L,FC2
....................                    } 
....................  
....................                #ifdef SUPPORT_LFN 
....................                if(twoByteMode) 
....................                { 
....................                   returnPointer[index++] = 0x00; 
....................                        if (index == totalchars) 
....................                        { 
....................                            index = 0; 
....................                            bufferOverflow = TRUE; 
....................                        } 
....................                } 
....................                #endif 
....................                } 
....................  
....................                while (tempCWD->name[j] == 0x20) 
05842:  MOV.B   FC3,W0L
05844:  SE      W0,W0
05846:  ADD     W0,#1C,W0
05848:  MOV     FC0,W4
0584A:  ADD     W0,W4,W0
0584C:  MOV.B   [W0],W5L
0584E:  SE      W5,W5
05850:  MOV     #20,W4
05852:  CP      W4,W5
05854:  BRA     NZ,585C
....................                    j--; 
05856:  DEC.B   0FC3
05858:  GOTO    5842
....................  
....................                while (j >= 0) 
0585C:  MOV.B   FC3,W0L
0585E:  SE      W0,W0
05860:  CP      W0,#0
05862:  BRA     LT,588E
....................                { 
....................                    *(returnPointer + index++) = tempCWD->name[j--]; 
05864:  MOV     FCE,W0
05866:  INC     0FCE
05868:  MOV     FBC,W4
0586A:  ADD     W0,W4,W0
0586C:  MOV     W0,W5
0586E:  MOV.B   FC3,W0L
05870:  DEC.B   0FC3
05872:  SE      W0,W6
05874:  ADD     W6,#1C,W6
05876:  MOV     W6,W0
05878:  MOV     FC0,W4
0587A:  ADD     W0,W4,W0
0587C:  MOV.B   [W0],[W5]
....................                    // This is a circular buffer 
....................                    // Any unnecessary values will be overwritten 
....................                    if (index == totalchars) 
0587E:  MOV     FCE,W0
05880:  CP      FBA
05882:  BRA     NZ,588A
....................                    { 
....................                        index = 0; 
05884:  CLR     FCE
....................                        bufferOverflow = TRUE; 
05886:  MOV.B   #1,W0L
05888:  MOV.B   W0L,FC2
....................                    } 
....................  
....................                #ifdef SUPPORT_LFN 
0588A:  GOTO    585C
....................                if(twoByteMode) 
....................                { 
....................                   returnPointer[index++] = 0x00; 
....................                        if (index == totalchars) 
....................                        { 
....................                            index = 0; 
....................                            bufferOverflow = TRUE; 
....................                        } 
....................                } 
....................                #endif 
....................                } 
....................          } 
....................  
....................          #ifdef SUPPORT_LFN 
....................          if(twoByteMode) 
....................          { 
....................             returnPointer[index++] = 0x00; 
....................                if (index == totalchars) 
....................                { 
....................                    index = 0; 
....................                    bufferOverflow = TRUE; 
....................                } 
....................          } 
....................          #endif 
....................  
....................             // Put a backslash delimiter in front of the dir name 
....................             *(returnPointer + index++) = '\\'; 
0588E:  MOV     FCE,W0
05890:  INC     0FCE
05892:  MOV     FBC,W4
05894:  ADD     W0,W4,W0
05896:  MOV     W0,W5
05898:  MOV.B   #5C,W0L
0589A:  MOV.B   W0L,[W5]
....................             if (index == totalchars) 
0589C:  MOV     FCE,W0
0589E:  CP      FBA
058A0:  BRA     NZ,58A8
....................             { 
....................                 index = 0; 
058A2:  CLR     FCE
....................                 bufferOverflow = TRUE; 
058A4:  MOV.B   #1,W0L
058A6:  MOV.B   W0L,FC2
....................             } 
....................  
....................             // Load the previous entry 
....................             tempCWD->dirccls = tempCWD->dirclus; 
058A8:  MOV     #32,W0
058AA:  ADD     FC0,W0
058AC:  MOV     W0,W5
058AE:  MOV     #2E,W0
058B0:  ADD     FC0,W0
058B2:  MOV     [W0++],[W5++]
058B4:  MOV     [W0++],[W5++]
....................             if (GetPreviousEntry (tempCWD)) 
058B6:  PUSH    FC0
058B8:  POP     FD8
058BA:  CALL    53FC
058BE:  CP0.B   W0L
058C0:  BRA     Z,58CA
....................             { 
....................                 FSerrno = CE_BAD_SECTOR_READ; 
058C2:  MOV.B   #8,W0L
058C4:  MOV.B   W0L,857
....................                 return NULL; 
058C6:  CLR     0
058C8:  BRA     599C
....................             } 
058CA:  GOTO    57BA
....................         } 
....................     } 
....................  
....................     // Point the index back at the last char in the string 
....................     index--; 
058CE:  DEC     0FCE
....................  
....................     i = 0; 
058D0:  CLR     FCC
....................     // Swap the chars in the buffer so they are in the right places 
....................     if (bufferOverflow) 
058D2:  CP0.B   FC2
058D4:  BRA     Z,5954
....................     { 
....................         tempindex = index; 
058D6:  PUSH    FCE
058D8:  POP     FCA
....................         // Swap the overflowed values in the buffer 
....................         while ((index - i) > 0) 
058DA:  MOV     FCE,W4
058DC:  MOV     FCC,W3
058DE:  SUB     W4,W3,W5
058E0:  CP      W5,#0
058E2:  BRA     LE,590C
....................         { 
....................              aChar = *(returnPointer + i); 
058E4:  MOV     FBC,W0
058E6:  ADD     FCC,W0
058E8:  MOV     FD0,W4
058EA:  MOV.B   [W0+#0],W4L
058EC:  MOV     W4,FD0
....................              *(returnPointer + i) = * (returnPointer + index); 
058EE:  MOV     FBC,W0
058F0:  ADD     FCC,W0
058F2:  MOV     W0,W5
058F4:  MOV     FBC,W0
058F6:  ADD     FCE,W0
058F8:  MOV.B   [W0],[W5]
....................              *(returnPointer + index) = aChar; 
058FA:  MOV     FBC,W0
058FC:  ADD     FCE,W0
058FE:  MOV     W0,W5
05900:  MOV     FD0,W0
05902:  MOV.B   W0L,[W5+#0]
....................              index--; 
05904:  DEC     0FCE
....................              i++; 
05906:  INC     0FCC
05908:  GOTO    58DA
....................         } 
....................  
....................         // Point at the non-overflowed values 
....................         i = tempindex + 1; 
0590C:  MOV     FCA,W4
0590E:  ADD     W4,#1,W4
05910:  MOV     W4,FCC
....................         index = bufferEnd - returnPointer; 
05912:  MOV     FBE,W4
05914:  MOV     FBC,W3
05916:  SUB     W4,W3,W0
05918:  MOV     W0,FCE
....................  
....................         // Swap the non-overflowed values into the right places 
....................         while ((index - i) > 0) 
0591A:  MOV     FCE,W4
0591C:  MOV     FCC,W3
0591E:  SUB     W4,W3,W5
05920:  CP      W5,#0
05922:  BRA     LE,594C
....................         { 
....................              aChar = *(returnPointer + i); 
05924:  MOV     FBC,W0
05926:  ADD     FCC,W0
05928:  MOV     FD0,W4
0592A:  MOV.B   [W0+#0],W4L
0592C:  MOV     W4,FD0
....................              *(returnPointer + i) = * (returnPointer + index); 
0592E:  MOV     FBC,W0
05930:  ADD     FCC,W0
05932:  MOV     W0,W5
05934:  MOV     FBC,W0
05936:  ADD     FCE,W0
05938:  MOV.B   [W0],[W5]
....................              *(returnPointer + index) = aChar; 
0593A:  MOV     FBC,W0
0593C:  ADD     FCE,W0
0593E:  MOV     W0,W5
05940:  MOV     FD0,W0
05942:  MOV.B   W0L,[W5+#0]
....................              index--; 
05944:  DEC     0FCE
....................              i++; 
05946:  INC     0FCC
05948:  GOTO    591A
....................         } 
....................         // All the values should be in the right place now 
....................         // Null-terminate the string 
....................         *(bufferEnd) = 0; 
0594C:  MOV     FBE,W5
0594E:  CLR.B   [W5]
....................     } 
05950:  GOTO    5998
....................     else 
....................     { 
....................         // There was no overflow, just do one set of swaps 
....................         tempindex = index; 
05954:  PUSH    FCE
05956:  POP     FCA
....................         while ((index - i) > 0) 
05958:  MOV     FCE,W4
0595A:  MOV     FCC,W3
0595C:  SUB     W4,W3,W5
0595E:  CP      W5,#0
05960:  BRA     LE,598A
....................         { 
....................             aChar = *(returnPointer + i); 
05962:  MOV     FBC,W0
05964:  ADD     FCC,W0
05966:  MOV     FD0,W4
05968:  MOV.B   [W0+#0],W4L
0596A:  MOV     W4,FD0
....................             *(returnPointer + i) = * (returnPointer + index); 
0596C:  MOV     FBC,W0
0596E:  ADD     FCC,W0
05970:  MOV     W0,W5
05972:  MOV     FBC,W0
05974:  ADD     FCE,W0
05976:  MOV.B   [W0],[W5]
....................             *(returnPointer + index) = aChar; 
05978:  MOV     FBC,W0
0597A:  ADD     FCE,W0
0597C:  MOV     W0,W5
0597E:  MOV     FD0,W0
05980:  MOV.B   W0L,[W5+#0]
....................             index--; 
05982:  DEC     0FCE
....................             i++; 
05984:  INC     0FCC
05986:  GOTO    5958
....................         } 
....................         *(returnPointer + tempindex + 1) = 0; 
0598A:  MOV     FBC,W0
0598C:  ADD     FCA,W0
0598E:  MOV     W0,W5
05990:  ADD     W5,#1,W5
05992:  MOV     W5,W0
05994:  MOV     W0,W5
05996:  CLR.B   [W5]
....................     } 
....................  
....................     return returnPointer; 
05998:  PUSH    FBC
0599A:  POP     0
0599C:  MOV     [--W15],W7
0599E:  MOV     [--W15],W6
059A0:  MOV     [--W15],W5
059A2:  RETURN  
.................... } 
....................  
.................... #ifdef SUPPORT_LFN 
....................  
.................... /************************************************************** 
....................   Function: 
....................     char * wFSgetcwd (unsigned short int * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in UTF16 format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in UTF16 format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name 
....................     into the buffer backwards, and insert a backslash character. 
....................     Next, the function will continuously switch to the previous 
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the 
....................     root. 
....................   Remarks: 
....................     None 
....................   **************************************************************/ 
.................... char * wFSgetcwd (unsigned short int * path, int numchars) 
.................... { 
....................    char *result; 
....................    twoByteMode = TRUE; 
....................     result = FSgetcwd ((char *)path,numchars); 
....................    twoByteMode = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     void GetPreviousEntry (FSFILE * fo) 
....................   Summary: 
....................     Get the file entry info for the parent dir of the specified dir 
....................   Conditions: 
....................     Should not be called by the user. 
....................   Input: 
....................     fo -  The file to get the previous entry of 
....................   Return Values: 
....................     0 -  The previous entry was successfully retrieved 
....................     -1 - The previous entry could not be retrieved 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The GetPreviousEntry function is used by the FSgetcwd function to 
....................     load the previous (parent) directory.  This function will load the 
....................     parent directory and then search through the file entries in that 
....................     directory for one that matches the cluster number of the original 
....................     directory.  When the matching entry is found, the name of the 
....................     original directory is copied into the 'fo' FSFILE object. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... BYTE GetPreviousEntry (FSFILE * fo) 
*
053FC:  MOV     W5,[W15++]
*
05402:  MOV     #1,W4
05404:  MOV     W4,FDE
.................... { 
....................     int i,j; 
*
053FE:  CLR     FDA
05400:  CLR     FDC
....................     WORD fHandle = 1; 
....................     DWORD dirclus; 
*
05406:  CLR     FE0
05408:  CLR     FE2
....................     DIRENTRY dirptr; 
0540A:  CLR     FE4
....................  
....................    #ifdef SUPPORT_LFN 
....................       unsigned short int *tempLFN = (unsigned short int *)&tempDirectoryString[0]; 
....................       FSFILE cwdTemp; 
....................       LFN_ENTRY *lfno; 
....................  
....................       WORD prevHandle; 
....................       UINT16_VAL tempShift; 
....................  
....................    #endif 
....................  
....................     // Load the previous entry 
....................     dirptr = Cache_File_Entry (fo, &fHandle, TRUE); 
0540C:  MOV.B   #1,W0L
0540E:  MOV.B   W0L,102C
05410:  PUSH    FD8
05412:  POP     1028
05414:  MOV     #FDE,W4
05416:  MOV     W4,102A
05418:  CALL    31E4
0541C:  MOV     W0,FE4
....................     if (dirptr == NULL) 
0541E:  CP0     FE4
05420:  BRA     NZ,5426
....................         return -1; 
05422:  SETM.B  0
05424:  BRA     55B6
....................  
....................     // Get the cluster 
....................     TempClusterCalc = GetFullClusterNumber(dirptr); // Get complete cluster number. 
05426:  PUSH    FE4
05428:  POP     102A
0542A:  CALL    34B4
0542E:  MOV     W0,85C
05430:  MOV     W1,85E
....................  
....................     if (TempClusterCalc == VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT) 
05432:  CP0     85C
05434:  BRA     NZ,547A
05436:  CP0     85E
05438:  BRA     NZ,547A
....................     { 
....................         // The previous directory is the root 
....................         fo->name[0] = '\\'; 
0543A:  MOV     #1C,W0
0543C:  ADD     FD8,W0
0543E:  MOV     W0,W5
05440:  MOV.B   #5C,W0L
05442:  MOV.B   W0L,[W5]
....................         for (i = 0; i < 11; i++) 
05444:  CLR     FDA
05446:  MOV     FDA,W4
05448:  CP      W4,#B
0544A:  BRA     GE,545E
....................         { 
....................             fo->name[i] = 0x20; 
0544C:  MOV     #1C,W0
0544E:  ADD     FDA,W0
05450:  MOV     FD8,W4
05452:  ADD     W0,W4,W5
05454:  MOV.B   #20,W0L
05456:  MOV.B   W0L,[W5]
05458:  INC     0FDA
0545A:  GOTO    5446
....................         } 
....................         fo->dirclus = FatRootDirClusterValue; 
0545E:  MOV     #2E,W0
05460:  ADD     FD8,W0
05462:  MOV     W0,W5
05464:  MOV     #858,W4
05466:  MOV     [W4++],[W5++]
05468:  MOV     [W4++],[W5++]
....................         fo->dirccls = FatRootDirClusterValue; 
0546A:  MOV     #32,W0
0546C:  ADD     FD8,W0
0546E:  MOV     W0,W5
05470:  MOV     #858,W4
05472:  MOV     [W4++],[W5++]
05474:  MOV     [W4++],[W5++]
....................     } 
05476:  GOTO    5592
....................     else 
....................     { 
....................         // Get the directory name 
....................         // Save the previous cluster value 
....................        // Get the cluster 
....................  
....................         dirclus = TempClusterCalc; 
0547A:  PUSH    85C
0547C:  POP     FE0
0547E:  PUSH    85E
05480:  POP     FE2
....................         fo->dirclus = TempClusterCalc; 
05482:  MOV     #2E,W0
05484:  ADD     FD8,W0
05486:  MOV     W0,W5
05488:  MOV     #85C,W4
0548A:  MOV     [W4++],[W5++]
0548C:  MOV     [W4++],[W5++]
....................         fo->dirccls = TempClusterCalc; 
0548E:  MOV     #32,W0
05490:  ADD     FD8,W0
05492:  MOV     W0,W5
05494:  MOV     #85C,W4
05496:  MOV     [W4++],[W5++]
05498:  MOV     [W4++],[W5++]
....................  
....................  
....................         // Load the previous previous cluster 
....................         dirptr = Cache_File_Entry (fo, &fHandle, TRUE); 
0549A:  MOV.B   #1,W0L
0549C:  MOV.B   W0L,102C
0549E:  PUSH    FD8
054A0:  POP     1028
054A2:  MOV     #FDE,W4
054A4:  MOV     W4,102A
054A6:  CALL    31E4
054AA:  MOV     W0,FE4
....................         if (dirptr == NULL) 
054AC:  CP0     FE4
054AE:  BRA     NZ,54B4
....................             return -1; 
054B0:  SETM.B  0
054B2:  BRA     55B6
....................  
....................        // Get the cluster 
....................         TempClusterCalc = GetFullClusterNumber(dirptr); // Get complete cluster number. 
054B4:  PUSH    FE4
054B6:  POP     102A
054B8:  CALL    34B4
054BC:  MOV     W0,85C
054BE:  MOV     W1,85E
.................... #ifdef SUPPORT_FAT32 
....................         // If we're using FAT32 and the previous previous cluster is the root, the 
....................         // value in the dotdot entry will be 0, but the actual cluster won't 
....................         if (TempClusterCalc == VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT) 
054C0:  CP0     85C
054C2:  BRA     NZ,54D8
054C4:  CP0     85E
054C6:  BRA     NZ,54D8
....................         { 
....................             fo->dirclus = FatRootDirClusterValue; 
054C8:  MOV     #2E,W0
054CA:  ADD     FD8,W0
054CC:  MOV     W0,W5
054CE:  MOV     #858,W4
054D0:  MOV     [W4++],[W5++]
054D2:  MOV     [W4++],[W5++]
....................         } 
054D4:  GOTO    54E4
....................         else 
.................... #endif 
....................             fo->dirclus = TempClusterCalc; 
054D8:  MOV     #2E,W0
054DA:  ADD     FD8,W0
054DC:  MOV     W0,W5
054DE:  MOV     #85C,W4
054E0:  MOV     [W4++],[W5++]
054E2:  MOV     [W4++],[W5++]
....................  
....................         fo->dirccls = fo->dirclus; 
054E4:  MOV     #32,W0
054E6:  ADD     FD8,W0
054E8:  MOV     W0,W5
054EA:  MOV     #2E,W0
054EC:  ADD     FD8,W0
054EE:  MOV     [W0++],[W5++]
054F0:  MOV     [W0++],[W5++]
....................  
....................         fHandle = 0; 
054F2:  CLR     FDE
....................         dirptr = Cache_File_Entry (fo, &fHandle, TRUE); 
054F4:  MOV.B   #1,W0L
054F6:  MOV.B   W0L,102C
054F8:  PUSH    FD8
054FA:  POP     1028
054FC:  MOV     #FDE,W4
054FE:  MOV     W4,102A
05500:  CALL    31E4
05504:  MOV     W0,FE4
....................         if (dirptr == NULL) 
05506:  CP0     FE4
05508:  BRA     NZ,550E
....................             return -1; 
0550A:  SETM.B  0
0550C:  BRA     55B6
....................         // Look through it until we get the name 
....................         // of the previous cluster 
....................         // Get the cluster 
....................         TempClusterCalc = GetFullClusterNumber(dirptr); // Get complete cluster number. 
0550E:  PUSH    FE4
05510:  POP     102A
05512:  CALL    34B4
05516:  MOV     W0,85C
05518:  MOV     W1,85E
....................         while ((TempClusterCalc != dirclus) || 
....................             ((TempClusterCalc == dirclus) && 
....................             (((unsigned char)dirptr->DIR_Name[0] == 0xE5) || (dirptr->DIR_Attr == ATTR_VOLUME) || (dirptr->DIR_Attr == ATTR_LONG_NAME)))) 
0551A:  MOV     85C,W0
0551C:  CP      FE0
0551E:  BRA     NZ,5550
05520:  MOV     85E,W0
05522:  CP      FE2
05524:  BRA     NZ,5550
05526:  MOV     85C,W0
05528:  CP      FE0
0552A:  BRA     NZ,557A
0552C:  MOV     85E,W0
0552E:  CP      FE2
05530:  BRA     NZ,557A
05532:  MOV     #0,W0
05534:  ADD     FE4,W0
05536:  MOV.B   [W0],W4L
05538:  XOR.B   #E5,W4L
0553A:  BRA     Z,5550
0553C:  MOV     #B,W0
0553E:  ADD     FE4,W0
05540:  MOV.B   [W0],W4L
05542:  CP.B    W4L,#8
05544:  BRA     Z,5550
05546:  MOV     #B,W0
05548:  ADD     FE4,W0
0554A:  MOV.B   [W0],W4L
0554C:  CP.B    W4L,#F
0554E:  BRA     NZ,557A
....................         { 
....................             // Look through the entries until we get the 
....................             // right one 
....................             dirptr = Cache_File_Entry (fo, &fHandle, FALSE); 
05550:  CLR.B   102C
05552:  PUSH    FD8
05554:  POP     1028
05556:  MOV     #FDE,W4
05558:  MOV     W4,102A
0555A:  CALL    31E4
0555E:  MOV     W0,FE4
....................             if (dirptr == NULL) 
05560:  CP0     FE4
05562:  BRA     NZ,5568
....................                 return -1; 
05564:  SETM.B  0
05566:  BRA     55B6
....................             fHandle++; 
05568:  INC     0FDE
....................  
....................            TempClusterCalc = GetFullClusterNumber(dirptr); // Get complete cluster number in a loop. 
0556A:  PUSH    FE4
0556C:  POP     102A
0556E:  CALL    34B4
05572:  MOV     W0,85C
05574:  MOV     W1,85E
05576:  GOTO    551A
....................         } 
....................  
....................         // The name should be in the entry now 
....................         // Copy the actual directory location back 
....................         fo->dirclus = dirclus; 
0557A:  MOV     #2E,W0
0557C:  ADD     FD8,W0
0557E:  MOV     W0,W5
05580:  MOV     #FE0,W4
05582:  MOV     [W4++],[W5++]
05584:  MOV     [W4++],[W5++]
....................         fo->dirccls = dirclus; 
05586:  MOV     #32,W0
05588:  ADD     FD8,W0
0558A:  MOV     W0,W5
0558C:  MOV     #FE0,W4
0558E:  MOV     [W4++],[W5++]
05590:  MOV     [W4++],[W5++]
....................    } 
....................  
....................       i = 0; 
05592:  CLR     FDA
....................    #ifdef SUPPORT_LFN 
....................           FileObjectCopy (&cwdTemp, fo); 
....................          prevHandle = fHandle - 2; 
....................  
....................          lfno = (LFN_ENTRY *)Cache_File_Entry (fo, &prevHandle, FALSE); 
....................  
....................       // Get the long file name of the short file name(if present) 
....................          while((lfno->LFN_Attribute == ATTR_LONG_NAME) && (lfno->LFN_SequenceNo != DIR_DEL) 
....................  
....................                && (lfno->LFN_SequenceNo != DIR_EMPTY)) 
....................  
....................          { 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[0]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[1]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[2]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[3]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[4]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[5]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[6]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[7]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[8]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[9]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[0]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[1]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[2]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[3]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[4]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[5]; 
....................  
....................  
....................             tempLFN[i++] = lfno->LFN_Part3[0]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part3[1]; 
....................  
....................  
....................  
....................             prevHandle = prevHandle - 1; 
....................  
....................             lfno = (LFN_ENTRY *)Cache_File_Entry (fo, &prevHandle, FALSE); 
....................  
....................          } 
....................  
....................  
....................          FileObjectCopy (fo, &cwdTemp); 
....................    #endif 
....................  
....................       if(i == 0) 
05594:  CP0     FDA
05596:  BRA     NZ,55B4
....................  
....................    { 
....................           for (j = 0; j < 11; j++) 
05598:  CLR     FDC
0559A:  MOV     FDC,W4
0559C:  CP      W4,#B
0559E:  BRA     GE,55B4
....................            fo->name[j] = dirptr->DIR_Name[j]; 
055A0:  MOV     #1C,W0
055A2:  ADD     FDC,W0
055A4:  MOV     FD8,W4
055A6:  ADD     W0,W4,W5
055A8:  MOV     FDC,W0
055AA:  ADD     FE4,W0
055AC:  MOV.B   [W0],[W5]
055AE:  INC     0FDC
055B0:  GOTO    559A
....................       #ifdef SUPPORT_LFN 
....................             fo->utf16LFNlength = 0; 
....................  
....................          #endif 
....................       } 
....................    #ifdef SUPPORT_LFN 
....................       else 
....................  
....................       { 
....................  
....................       fo->utf16LFNlength = i; 
....................  
....................  
....................  
....................       for(j = 12;j >= 0;j--) 
....................  
....................       { 
....................  
....................          if((tempLFN[i - j - 1]) == 0x0000) 
....................  
....................          { 
....................  
....................             fo->utf16LFNlength = i - j - 1; 
....................  
....................             break; 
....................  
....................          } 
....................  
....................       } 
....................  
....................  
....................          fo->utf16LFNptr = (unsigned short int *)&tempDirectoryString[0]; 
....................  
....................       } 
....................  
....................    #endif 
....................  
....................     return 0; 
055B4:  CLR.B   0
055B6:  MOV     [--W15],W5
055B8:  RETURN  
.................... } 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdir (char * path) 
....................   Summary: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno 
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... int FSmkdir (char * path) 
.................... { 
....................     return mkdirhelper (0, path, NULL); 
*
07688:  CLR.B   F7A
0768A:  PUSH    F76
0768C:  POP     F7C
0768E:  CLR     F7E
07690:  CALL    7302
07694:  MOV     W0,0
07696:  RETURN  
.................... } 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int wFSmkdir (unsigned short int * path) 
....................   Summary: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno 
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSmkdir (unsigned short int * path) 
.................... { 
....................    int   result; 
....................    utfModeFileName = TRUE; 
....................     result = mkdirhelper (0, (char *)path, NULL); 
....................    utfModeFileName = FALSE; 
....................     return result; 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdirpgm (const rom char * path) 
....................   Summary: 
....................     Creates a directory as per the path mentioned in the input string on 
....................     PIC18 devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create (ROM) 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno 
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the path mentioned in the input string on 
....................     PIC18 devices.'FSmkdirpgm' creates the directories as per the input 
....................     string path.This function doesn't move the current working 
....................     directory setting. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arugments in ROM 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int FSmkdirpgm (const rom char * path) 
.................... { 
....................     return mkdirhelper (1, NULL, path); 
.................... } 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int wFSmkdirpgm (const rom unsigned short int * path) 
....................   Summary: 
....................     Create a directory with a path in ROM on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create (ROM) 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno 
....................     variable will be changed. 
....................   Description: 
....................     The FSmkdirpgm function passes a PIC18 ROM path pointer to the 
....................     mkdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arugments in ROM 
....................   **************************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSmkdirpgm (const rom unsigned short int * path) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................     result = mkdirhelper (1, NULL, (const char *)path); 
....................    utfModeFileName = FALSE; 
....................     return result; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int mkdirhelper (BYTE mode, char * ramptr, char * romptr) 
....................     // PIC18 
....................     int mkdirhelper (BYTE mode, char * ramptr, const rom char * romptr) 
....................   Summary: 
....................     Helper function for FSmkdir 
....................   Conditions: 
....................     None 
....................   Input: 
....................     mode -   Indicates which path pointer to use 
....................     ramptr - Pointer to the path specified in RAM 
....................     romptr - Pointer to the path specified in ROM 
....................   Return Values: 
....................     0 -  Directory was created 
....................     -1 - Directory could not be created 
....................   Side Effects: 
....................     Will create all non-existant directories in the path. 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This helper function is used by the FSchdir function. If the path 
....................     argument is specified in ROM for PIC18 this function will be able 
....................     to parse it correctly.  This function will first scan through the path 
....................     to ensure that any DIR names don't exceed 11 characters.  It will then 
....................     backup the current working directory and begin changing directories 
....................     through the path until it reaches a directory than can't be changed to. 
....................     It will then create the specified directory and change directories to 
....................     the new directory. The function will continue creating and changing to 
....................     directories until the end of the path is reached.  The function will 
....................     then restore the original current working directory. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int mkdirhelper (BYTE mode, char * ramptr, const rom char * romptr) 
.................... #else 
.................... int mkdirhelper (BYTE mode, char * ramptr, char * romptr) 
.................... #endif 
*
07302:  MOV     W5,[W15++]
07304:  MOV     W6,[W15++]
*
07308:  CLR     F82
0730A:  CLR     F84
0730C:  PUSH    F7C
0730E:  POP     F86
07310:  PUSH    F7C
07312:  POP     F88
07314:  MOV     #862,W4
07316:  MOV     W4,F8A
.................... { 
....................     unsigned short int i,j = 0,k = 0; 
*
07306:  CLR     F80
....................     char * temppath = ramptr; 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     rom char * temppath2 = romptr; 
....................     rom unsigned short int * utf16path2 = (rom unsigned short int *)romptr; 
.................... #endif 
....................    unsigned short int *utf16path = (unsigned short int *)ramptr; 
....................     FILEOBJ tempCWD = &tempCWDobj; 
....................  
.................... #ifdef __18CXX 
....................     char dotdotPath[] = ".."; 
....................     char dotdotPath1[5] = {'.','\0','.','\0','\0'}; 
.................... #endif 
....................  
.................... // Do Dynamic allocation if the macro is defined or 
.................... // go with static allocation 
.................... #if defined(SUPPORT_LFN) 
....................    char tempArray[514]; 
.................... #else 
....................    char tempArray[14]; 
*
07318:  CLR     F8C
0731A:  CLR     F8E
0731C:  CLR     F90
0731E:  CLR     F92
07320:  CLR     F94
07322:  CLR     F96
07324:  CLR     F98
.................... #endif 
....................  
....................     FSerrno = CE_GOOD; 
07326:  CLR.B   857
....................  
....................     if (MDD_WriteProtectState()) 
07328:  CALL    25A0
0732C:  CP0.B   W0L
0732E:  BRA     Z,7338
....................     { 
....................         FSerrno = CE_WRITE_PROTECTED; 
07330:  MOV.B   #18,W0L
07332:  MOV.B   W0L,857
....................         return (-1); 
07334:  SETM    0
07336:  BRA     7682
....................     } 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     if (mode == 1) 
....................     { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................       { 
....................            // Scan for too-long file names 
....................            while (1) 
....................            { 
....................                i = 0; 
....................                while((*utf16path2 != 0) && (*utf16path2 != '.')&& (*utf16path2 != '\\')) 
....................                { 
....................                    utf16path2++; 
....................                    i++; 
....................                } 
....................  
....................               if (i > 256) 
....................               { 
....................                   FSerrno = CE_INVALID_ARGUMENT; 
....................                   return -1; 
....................               } 
....................  
....................                j = 0; 
....................                if (*utf16path2 == '.') 
....................                { 
....................                    utf16path2++; 
....................                    while ((*utf16path2 != 0) && (*utf16path2 != '\\')) 
....................                    { 
....................                        utf16path2++; 
....................                        j++; 
....................                    } 
....................                  if ((i + j) > 256) 
....................                  { 
....................                      FSerrno = CE_INVALID_ARGUMENT; 
....................                      return -1; 
....................                  } 
....................                } 
....................  
....................             if((i + j) > k) 
....................             { 
....................                k = (i + j); 
....................             } 
....................  
....................                while (*utf16path2 == '\\') 
....................                    utf16path2++; 
....................                if (*utf16path2 == 0) 
....................                    break; 
....................            } 
....................        } 
....................       else 
....................       #endif 
....................       { 
....................            // Scan for too-long file names 
....................            while (1) 
....................            { 
....................                i = 0; 
....................                while((*temppath2 != 0) && (*temppath2 != '.')&& (*temppath2 != '\\')) 
....................                { 
....................                    temppath2++; 
....................                    i++; 
....................                } 
....................  
....................             #if defined(SUPPORT_LFN) 
....................                   if (i > 256) 
....................                   { 
....................                       FSerrno = CE_INVALID_ARGUMENT; 
....................                       return -1; 
....................                   } 
....................             #else 
....................                   if (i > 8) 
....................                   { 
....................                       FSerrno = CE_INVALID_ARGUMENT; 
....................                       return -1; 
....................                   } 
....................             #endif 
....................  
....................                j = 0; 
....................                if (*temppath2 == '.') 
....................                { 
....................                    temppath2++; 
....................                    while ((*temppath2 != 0) && (*temppath2 != '\\')) 
....................                    { 
....................                        temppath2++; 
....................                        j++; 
....................                    } 
....................                #if defined(SUPPORT_LFN) 
....................                      if ((i + j) > 256) 
....................                      { 
....................                          FSerrno = CE_INVALID_ARGUMENT; 
....................                          return -1; 
....................                      } 
....................                #else 
....................                      if (j > 3) 
....................                      { 
....................                          FSerrno = CE_INVALID_ARGUMENT; 
....................                          return -1; 
....................                      } 
....................                #endif 
....................                } 
....................  
....................             if((i + j) > k) 
....................             { 
....................                k = (i + j); 
....................             } 
....................  
....................                while (*temppath2 == '\\') 
....................                    temppath2++; 
....................                if (*temppath2 == 0) 
....................                    break; 
....................            } 
....................        } 
....................     } 
....................     else 
.................... #endif 
....................    { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................       { 
....................          utf16path = (unsigned short int *)ramptr; 
....................            // Scan for too-long file names 
....................            while (1) 
....................            { 
....................                i = 0; 
....................                while((*utf16path != 0) && (*utf16path != '.')&& (*utf16path != '\\')) 
....................                { 
....................                    utf16path++; 
....................                    i++; 
....................                } 
....................               if (i > 256) 
....................               { 
....................                   FSerrno = CE_INVALID_ARGUMENT; 
....................                   return -1; 
....................               } 
....................  
....................                j = 0; 
....................                if (*utf16path == '.') 
....................                { 
....................                    utf16path++; 
....................                    while ((*utf16path != 0) && (*utf16path != '\\')) 
....................                    { 
....................                        utf16path++; 
....................                        j++; 
....................                    } 
....................                  if ((i + j) > 256) 
....................                  { 
....................                      FSerrno = CE_INVALID_ARGUMENT; 
....................                      return -1; 
....................                  } 
....................                } 
....................  
....................             if((i + j) > k) 
....................             { 
....................                k = (i + j); 
....................             } 
....................  
....................                while (*utf16path == '\\') 
....................                    utf16path++; 
....................                if (*utf16path == 0) 
....................                    break; 
....................            } 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................            // Scan for too-long file names 
....................            while (1) 
....................            { 
....................                i = 0; 
07338:  CLR     F80
....................                while((*temppath != 0) && (*temppath != '.')&& (*temppath != '\\')) 
0733A:  MOV     F86,W0
0733C:  MOV.B   [W0],W5L
0733E:  SE      W5,W5
07340:  CP0     W5
07342:  BRA     Z,735C
07344:  MOV     F86,W0
07346:  MOV.B   [W0],W4L
07348:  XOR.B   #2E,W4L
0734A:  BRA     Z,735C
0734C:  MOV     F86,W0
0734E:  MOV.B   [W0],W4L
07350:  XOR.B   #5C,W4L
07352:  BRA     Z,735C
....................                { 
....................                    temppath++; 
07354:  INC     0F86
....................                    i++; 
07356:  INC     0F80
....................                } 
....................             #if defined(SUPPORT_LFN) 
07358:  GOTO    733A
....................                   if (i > 256) 
....................                   { 
....................                       FSerrno = CE_INVALID_ARGUMENT; 
....................                       return -1; 
....................                   } 
....................             #else 
....................                   if (i > 8) 
0735C:  MOV     F80,W4
0735E:  CP      W4,#8
07360:  BRA     LEU,736A
....................                   { 
....................                       FSerrno = CE_INVALID_ARGUMENT; 
07362:  MOV.B   #1F,W0L
07364:  MOV.B   W0L,857
....................                       return -1; 
07366:  SETM    0
07368:  BRA     7682
....................                   } 
....................             #endif 
....................  
....................                j = 0; 
0736A:  CLR     F82
....................                if (*temppath == '.') 
0736C:  MOV     F86,W0
0736E:  MOV.B   [W0],W4L
07370:  XOR.B   #2E,W4L
07372:  BRA     NZ,739E
....................                { 
....................                    temppath++; 
07374:  INC     0F86
....................                    while ((*temppath != 0) && (*temppath != '\\')) 
07376:  MOV     F86,W0
07378:  MOV.B   [W0],W5L
0737A:  SE      W5,W5
0737C:  CP0     W5
0737E:  BRA     Z,7390
07380:  MOV     F86,W0
07382:  MOV.B   [W0],W4L
07384:  XOR.B   #5C,W4L
07386:  BRA     Z,7390
....................                    { 
....................                        temppath++; 
07388:  INC     0F86
....................                        j++; 
0738A:  INC     0F82
....................                    } 
....................                #if defined(SUPPORT_LFN) 
0738C:  GOTO    7376
....................                      if ((i + j) > 256) 
....................                      { 
....................                          FSerrno = CE_INVALID_ARGUMENT; 
....................                          return -1; 
....................                      } 
....................                #else 
....................                      if (j > 3) 
07390:  MOV     F82,W4
07392:  CP      W4,#3
07394:  BRA     LEU,739E
....................                      { 
....................                          FSerrno = CE_INVALID_ARGUMENT; 
07396:  MOV.B   #1F,W0L
07398:  MOV.B   W0L,857
....................                          return -1; 
0739A:  SETM    0
0739C:  BRA     7682
....................                      } 
....................                #endif 
....................                } 
....................  
....................             if((i + j) > k) 
0739E:  MOV     F80,W0
073A0:  ADD     F82,W0
073A2:  MOV     W0,W5
073A4:  MOV     F84,W4
073A6:  CP      W4,W5
073A8:  BRA     C,73B0
....................             { 
....................                k = (i + j); 
073AA:  MOV     F80,W0
073AC:  ADD     F82,W0
073AE:  MOV     W0,F84
....................             } 
....................  
....................                while (*temppath == '\\') 
073B0:  MOV     F86,W0
073B2:  MOV.B   [W0],W4L
073B4:  XOR.B   #5C,W4L
073B6:  BRA     NZ,73BE
....................                    temppath++; 
073B8:  INC     0F86
073BA:  GOTO    73B0
....................                if (*temppath == 0) 
073BE:  MOV     F86,W0
073C0:  MOV.B   [W0],W5L
073C2:  SE      W5,W5
073C4:  CP0     W5
073C6:  BRA     NZ,73CC
....................                    break; 
073C8:  GOTO    73D0
073CC:  GOTO    7338
....................            } 
....................       } 
....................    } 
....................  
....................    utf16path = (unsigned short int *)ramptr; 
073D0:  PUSH    F7C
073D2:  POP     F88
....................     temppath = ramptr; 
073D4:  PUSH    F7C
073D6:  POP     F86
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    utf16path2 = (rom unsigned short int *)romptr; 
....................     temppath2 = romptr; 
.................... #endif 
....................  
....................     // We're going to be moving the CWD 
....................     // Back up the CWD 
....................     FileObjectCopy (tempCWD, cwdptr); 
073D8:  PUSH    F8A
073DA:  POP     1002
073DC:  PUSH    904
073DE:  POP     1004
073E0:  CALL    28E2
....................  
....................     // get to the target directory 
....................     while (1) 
....................     { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................         if (mode == 1) 
....................         { 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................                i = *utf16path2; 
....................          else 
....................          #endif 
....................                i = *temppath2; 
....................       } 
....................         else 
.................... #endif 
....................       { 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................                i = *utf16path; 
....................          else 
....................          #endif 
....................                i = *temppath; 
073E4:  MOV     F86,W0
073E6:  MOV     W0,W4
073E8:  MOV.B   [W4],W0L
073EA:  SE      W0,W0
073EC:  MOV     W0,F80
....................       } 
....................  
....................         if (i == '.') 
073EE:  MOV     F80,W4
073F0:  XOR     #2E,W4
073F2:  BRA     NZ,74B2
....................         { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             if (mode == 1) 
....................             { 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................             { 
....................                    utf16path2++; 
....................                    i = *utf16path2; 
....................             } 
....................             else 
....................             #endif 
....................                { 
....................                    temppath2++; 
....................                    i = *temppath2; 
....................             } 
....................             } 
....................             else 
....................             { 
.................... #endif 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................             { 
....................                    utf16path++; 
....................                    i = *utf16path; 
....................             } 
....................             else 
....................             #endif 
....................                { 
....................                    temppath++; 
073F4:  INC     0F86
....................                    i = *temppath; 
073F6:  MOV     F86,W0
073F8:  MOV     W0,W4
073FA:  MOV.B   [W4],W0L
073FC:  SE      W0,W0
073FE:  MOV     W0,F80
....................             } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             } 
.................... #endif 
....................  
....................             if ((i != '.') && (i != 0) && (i != '\\')) 
07400:  MOV     F80,W4
07402:  XOR     #2E,W4
07404:  BRA     Z,7418
07406:  CP0     F80
07408:  BRA     Z,7418
0740A:  MOV     F80,W4
0740C:  XOR     #5C,W4
0740E:  BRA     Z,7418
....................             { 
....................                 FSerrno = CE_INVALID_ARGUMENT; 
07410:  MOV.B   #1F,W0L
07412:  MOV.B   W0L,857
....................                 return -1; 
07414:  SETM    0
07416:  BRA     7682
....................             } 
....................  
....................             if (i == '.') 
07418:  MOV     F80,W4
0741A:  XOR     #2E,W4
0741C:  BRA     NZ,7480
....................             { 
....................                 if (cwdptr->dirclus ==  FatRootDirClusterValue) 
0741E:  MOV     #2E,W0
07420:  ADD     904,W0
07422:  MOV     #A,W4
07424:  MOV     [W0++],[W4++]
07426:  MOV     [W0++],[W4++]
07428:  MOV     858,W4
0742A:  CP      W4,W5
0742C:  BRA     NZ,743C
0742E:  MOV     85A,W4
07430:  CP      W4,W6
07432:  BRA     NZ,743C
....................                 { 
....................                     // If we try to change to the .. from the 
....................                     // root, operation fails 
....................                     FSerrno = CE_INVALID_ARGUMENT; 
07434:  MOV.B   #1F,W0L
07436:  MOV.B   W0L,857
....................                     return -1; 
07438:  SETM    0
0743A:  BRA     7682
....................                 } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 if (mode == 1) 
....................                 { 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path2++; 
....................                       i = *utf16path2; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath2++; 
....................                       i = *temppath2; 
....................                } 
....................                 } 
....................                 else 
.................... #endif 
....................                 { 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path++; 
....................                       i = *utf16path; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath++; 
0743C:  INC     0F86
....................                       i = *temppath; 
0743E:  MOV     F86,W0
07440:  MOV     W0,W4
07442:  MOV.B   [W4],W0L
07444:  SE      W0,W0
07446:  MOV     W0,F80
....................                } 
....................             } 
....................  
....................                 if ((i != '\\') && (i != 0)) 
07448:  MOV     F80,W4
0744A:  XOR     #5C,W4
0744C:  BRA     Z,745E
0744E:  CP0     F80
07450:  BRA     Z,745E
....................                 { 
....................                     FSerrno = CE_INVALID_ARGUMENT; 
07452:  MOV.B   #1F,W0L
07454:  MOV.B   W0L,857
....................                     return -1; 
07456:  SETM    0
07458:  BRA     7682
....................                 } 
.................... // dotdot entry 
.................... #ifndef __18CXX 
....................          #ifdef SUPPORT_LFN 
0745A:  GOTO    7480
....................          if(utfModeFileName) 
....................                 FSchdir (".\0.\0\0"); 
....................          #endif 
....................          else 
....................                 FSchdir (".."); 
0745E:  MOV     #3,W3
07460:  MOV     #0,W2
07462:  MOV     #F9A,W1
07464:  MOV     W3,[W15++]
07466:  MOV     W2,W0
07468:  CALL    200
0746C:  MOV     [--W15],W3
0746E:  MOV.B   W0L,[W1++]
07470:  INC     W2,W2
07472:  DEC     W3,W3
07474:  BTSS.B  42.1
07476:  BRA     7464
07478:  MOV     #F9A,W4
0747A:  MOV     W4,FAE
0747C:  CALL    651A
.................... #else 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................                 FSchdir (dotdotPath1); 
....................          else 
....................          #endif 
....................                 FSchdir (dotdotPath); 
.................... #endif 
....................             } 
....................             // Skip past any backslashes 
....................             while (i == '\\') 
07480:  MOV     F80,W4
07482:  XOR     #5C,W4
07484:  BRA     NZ,7496
....................             { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 if (mode == 1) 
....................                 { 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path2++; 
....................                       i = *utf16path2; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath2++; 
....................                       i = *temppath2; 
....................                } 
....................                 } 
....................                 else 
....................                 { 
.................... #endif 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path++; 
....................                       i = *utf16path; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath++; 
07486:  INC     0F86
....................                       i = *temppath; 
07488:  MOV     F86,W0
0748A:  MOV     W0,W4
0748C:  MOV.B   [W4],W0L
0748E:  SE      W0,W0
07490:  MOV     W0,F80
....................                } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
07492:  GOTO    7480
....................                 } 
.................... #endif 
....................             } 
....................             if (i == 0) 
07496:  CP0     F80
07498:  BRA     NZ,74AE
....................             { 
....................                 // No point in creating a dot or dotdot entry directly 
....................                 FileObjectCopy (cwdptr, tempCWD); 
0749A:  PUSH    904
0749C:  POP     1002
0749E:  PUSH    F8A
074A0:  POP     1004
074A2:  CALL    28E2
....................                 FSerrno = CE_INVALID_ARGUMENT; 
074A6:  MOV.B   #1F,W0L
074A8:  MOV.B   W0L,857
....................                 return -1; 
074AA:  SETM    0
074AC:  BRA     7682
....................             } 
....................         } 
074AE:  GOTO    752E
....................         else 
....................         { 
....................             if (i == '\\') 
074B2:  MOV     F80,W4
074B4:  XOR     #5C,W4
074B6:  BRA     NZ,752A
....................             { 
....................                 // Start at the root 
....................                 cwdptr->dirclus = FatRootDirClusterValue; 
074B8:  MOV     #2E,W0
074BA:  ADD     904,W0
074BC:  MOV     W0,W5
074BE:  MOV     #858,W4
074C0:  MOV     [W4++],[W5++]
074C2:  MOV     [W4++],[W5++]
....................                 cwdptr->dirccls = FatRootDirClusterValue; 
074C4:  MOV     #32,W0
074C6:  ADD     904,W0
074C8:  MOV     W0,W5
074CA:  MOV     #858,W4
074CC:  MOV     [W4++],[W5++]
074CE:  MOV     [W4++],[W5++]
....................                 i = 0; 
074D0:  CLR     F80
....................                 cwdptr->name[i++] = '\\'; 
074D2:  MOV     F80,W0
074D4:  INC     0F80
074D6:  MOV     W0,W5
074D8:  ADD     W5,#1C,W5
074DA:  MOV     W5,W0
074DC:  MOV     904,W4
074DE:  ADD     W0,W4,W6
074E0:  MOV.B   #5C,W0L
074E2:  MOV.B   W0L,[W6]
.................... //                if(utfModeFileName) 
.................... //            { 
.................... //                   cwdptr->name[i++] = 0x00; 
.................... //            } 
....................                 for (; i < 11; i++) 
074E4:  MOV     F80,W4
074E6:  CP      W4,#B
074E8:  BRA     C,74FC
....................                 { 
....................                     cwdptr->name[i] = 0x20; 
074EA:  MOV     #1C,W0
074EC:  ADD     F80,W0
074EE:  MOV     904,W4
074F0:  ADD     W0,W4,W5
074F2:  MOV.B   #20,W0L
074F4:  MOV.B   W0L,[W5]
074F6:  INC     0F80
074F8:  GOTO    74E4
....................                 } 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 if (mode == 1) 
....................                 { 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path2++; 
....................                       i = *utf16path2; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath2++; 
....................                       i = *temppath2; 
....................                } 
....................                 } 
....................                 else 
....................                 { 
.................... #endif 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path++; 
....................                       i = *utf16path; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath++; 
074FC:  INC     0F86
....................                       i = *temppath; 
074FE:  MOV     F86,W0
07500:  MOV     W0,W4
07502:  MOV.B   [W4],W0L
07504:  SE      W0,W0
07506:  MOV     W0,F80
....................                } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 } 
.................... #endif 
....................                 // If we just got two backslashes in a row at the 
....................                 // beginning of the path, the function fails 
....................                 if ((i == '\\') || (i == 0)) 
07508:  MOV     F80,W4
0750A:  XOR     #5C,W4
0750C:  BRA     Z,7512
0750E:  CP0     F80
07510:  BRA     NZ,7526
....................                 { 
....................                     FileObjectCopy (cwdptr, tempCWD); 
07512:  PUSH    904
07514:  POP     1002
07516:  PUSH    F8A
07518:  POP     1004
0751A:  CALL    28E2
....................                     FSerrno = CE_INVALID_ARGUMENT; 
0751E:  MOV.B   #1F,W0L
07520:  MOV.B   W0L,857
....................                     return -1; 
07522:  SETM    0
07524:  BRA     7682
....................                 } 
....................             } 
07526:  GOTO    752E
....................             else 
....................             { 
....................                 break; 
0752A:  GOTO    7532
....................             } 
....................         } 
0752E:  GOTO    73E4
....................     } 
....................  
....................     while (1) 
....................     { 
....................         while(1) 
....................         { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             if (mode == 1) 
....................             { 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................             { 
....................                    // Change directories as specified 
....................                    i = *utf16path2; 
....................                    j = 0; 
....................  
....................                k = 512; 
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempArray[j++] = i; 
....................                        tempArray[j++] = i >> 8; 
....................                        utf16path2++; 
....................                        i = *utf16path2; 
....................                    } 
....................             } 
....................             else 
....................             #endif 
....................               { 
....................                    // Change directories as specified 
....................                    i = *temppath2; 
....................                    j = 0; 
....................  
....................                #if defined(SUPPORT_LFN) 
....................                   k = 256; 
....................                #else 
....................                   k = 12; 
....................                #endif 
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempArray[j++] = i; 
....................                        temppath2++; 
....................                        i = *temppath2; 
....................                    } 
....................             } 
....................             } 
....................             else 
....................             { 
.................... #endif 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................             { 
....................                    // Change directories as specified 
....................                    i = *utf16path; 
....................                    j = 0; 
....................  
....................                k = 512; 
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempArray[j++] = i; 
....................                        tempArray[j++] = i >> 8; 
....................                        utf16path++; 
....................                        i = *utf16path; 
....................                    } 
....................             } 
....................             else 
....................             #endif 
....................               { 
....................                    // Change directories as specified 
....................                    i = *temppath; 
07532:  MOV     F86,W0
07534:  MOV     W0,W4
07536:  MOV.B   [W4],W0L
07538:  SE      W0,W0
0753A:  MOV     W0,F80
....................                    j = 0; 
0753C:  CLR     F82
....................  
....................                #if defined(SUPPORT_LFN) 
....................                   k = 256; 
....................                #else 
....................                   k = 12; 
0753E:  MOV     #C,W4
07540:  MOV     W4,F84
....................                #endif 
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
07542:  CP0     F80
07544:  BRA     Z,7572
07546:  MOV     F80,W4
07548:  XOR     #5C,W4
0754A:  BRA     Z,7572
0754C:  MOV     F82,W0
0754E:  MOV     F84,W4
07550:  CP      W4,W0
07552:  BRA     LEU,7572
....................                    { 
....................                        tempArray[j++] = i; 
07554:  MOV     F82,W0
07556:  INC     0F82
07558:  MOV     W0,W5
0755A:  MOV     #F8C,W4
0755C:  ADD     W5,W4,W6
0755E:  MOV     F80,W0
07560:  MOV.B   W0L,[W6+#0]
....................                        temppath++; 
07562:  INC     0F86
....................                        i = *temppath; 
07564:  MOV     F86,W0
07566:  MOV     W0,W4
07568:  MOV.B   [W4],W0L
0756A:  SE      W0,W0
0756C:  MOV     W0,F80
0756E:  GOTO    7542
....................                    } 
....................             } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             } 
.................... #endif 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................          { 
....................                tempArray[j++] = 0; 
....................                tempArray[j] = 0; 
....................  
....................                if ((tempArray[0] == '.') && (tempArray[1] == 0)) 
....................                { 
....................                    if (((tempArray[2] != 0) || (tempArray[3] != 0)) && ((tempArray[2] != '.') || (tempArray[3] != 0))) 
....................                    { 
....................                        FileObjectCopy (cwdptr, tempCWD); 
....................                        FSerrno = CE_INVALID_ARGUMENT; 
....................                        return -1; 
....................                    } 
....................                    if (((tempArray[2] == '.') && (tempArray[3] == 0)) && ((tempArray[4] != 0) || (tempArray[5] != 0))) 
....................                    { 
....................                        FileObjectCopy (cwdptr, tempCWD); 
....................                        FSerrno = CE_INVALID_ARGUMENT; 
....................                        return -1; 
....................                    } 
....................                } 
....................          } 
....................          else 
....................          #endif 
....................          { 
....................                tempArray[j] = 0; 
07572:  MOV     #F8C,W4
07574:  MOV     F82,W3
07576:  ADD     W3,W4,W5
07578:  CLR.B   [W5]
....................  
....................                if (tempArray[0] == '.') 
0757A:  MOV     F8C,W4
0757C:  XOR.B   #2E,W4L
0757E:  BRA     NZ,75C8
....................                { 
....................                    if ((tempArray[1] != 0) && (tempArray[1] != '.')) 
07580:  MOV.B   F8D,W0L
07582:  SE      W0,W0
07584:  CP0     W0
07586:  BRA     Z,75A4
07588:  MOV     F8C,W4
0758A:  LSR     W4,#8,W4
0758C:  XOR.B   #2E,W4L
0758E:  BRA     Z,75A4
....................                    { 
....................                        FileObjectCopy (cwdptr, tempCWD); 
07590:  PUSH    904
07592:  POP     1002
07594:  PUSH    F8A
07596:  POP     1004
07598:  CALL    28E2
....................                        FSerrno = CE_INVALID_ARGUMENT; 
0759C:  MOV.B   #1F,W0L
0759E:  MOV.B   W0L,857
....................                        return -1; 
075A0:  SETM    0
075A2:  BRA     7682
....................                    } 
....................                    if ((tempArray[1] == '.') && (tempArray[2] != 0)) 
075A4:  MOV     F8C,W4
075A6:  LSR     W4,#8,W4
075A8:  XOR.B   #2E,W4L
075AA:  BRA     NZ,75C8
075AC:  MOV.B   F8E,W0L
075AE:  SE      W0,W0
075B0:  CP0     W0
075B2:  BRA     Z,75C8
....................                    { 
....................                        FileObjectCopy (cwdptr, tempCWD); 
075B4:  PUSH    904
075B6:  POP     1002
075B8:  PUSH    F8A
075BA:  POP     1004
075BC:  CALL    28E2
....................                        FSerrno = CE_INVALID_ARGUMENT; 
075C0:  MOV.B   #1F,W0L
075C2:  MOV.B   W0L,857
....................                        return -1; 
075C4:  SETM    0
075C6:  BRA     7682
....................                    } 
....................                } 
....................          } 
....................  
....................             // Try to change to it 
....................             // If you can't we need to create it 
....................             if (FSchdir (tempArray)) 
075C8:  MOV     #F8C,W4
075CA:  MOV     W4,FAE
075CC:  CALL    651A
075D0:  CP0     W0
075D2:  BRA     Z,75DC
....................             break; 
075D4:  GOTO    760A
075D8:  GOTO    7606
....................             else 
....................             { 
....................                 // We changed into the directory 
....................                 while (i == '\\') 
075DC:  MOV     F80,W4
075DE:  XOR     #5C,W4
075E0:  BRA     NZ,75F2
....................                 { 
....................                     // Next char is a backslash 
....................                     // Move past it 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     if (mode == 1) 
....................                     { 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................                   { 
....................                          utf16path2++; 
....................                          i = *utf16path2; 
....................                   } 
....................                   else 
....................                   #endif 
....................                      { 
....................                          temppath2++; 
....................                          i = *temppath2; 
....................                   } 
....................                     } 
....................                     else 
....................                     { 
.................... #endif 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................                   { 
....................                          utf16path++; 
....................                          i = *utf16path; 
....................                   } 
....................                   else 
....................                   #endif 
....................                      { 
....................                          temppath++; 
075E2:  INC     0F86
....................                          i = *temppath; 
075E4:  MOV     F86,W0
075E6:  MOV     W0,W4
075E8:  MOV.B   [W4],W0L
075EA:  SE      W0,W0
075EC:  MOV     W0,F80
....................                   } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
075EE:  GOTO    75DC
....................                     } 
.................... #endif 
....................                 } 
....................                 // If it's the last one, return success 
....................                 if (i == 0) 
075F2:  CP0     F80
075F4:  BRA     NZ,7606
....................                 { 
....................                     FileObjectCopy (cwdptr, tempCWD); 
075F6:  PUSH    904
075F8:  POP     1002
075FA:  PUSH    F8A
075FC:  POP     1004
075FE:  CALL    28E2
....................                     return 0; 
07602:  CLR     0
07604:  BRA     7682
....................                 } 
....................             } 
07606:  GOTO    7532
....................         } 
....................  
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................       { 
....................          unsigned short int *tempPtr1; 
....................          unsigned short int *tempPtr2; 
....................          k = 0; 
....................          tempPtr1 = (unsigned short int *)&tempArray[0]; 
....................          tempPtr2 = (unsigned short int *)&tempDirectoryString[0]; 
....................  
....................          for(;;) 
....................          { 
....................             tempPtr2[k] = tempPtr1[k]; 
....................             if(tempPtr2[k]) 
....................                k++; 
....................             else 
....................                break; 
....................          } 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................          strcpy(&tempDirectoryString[0],&tempArray[0]); 
0760A:  MOV     #D2E,W1
0760C:  MOV     #F8C,W2
0760E:  MOV.B   [W2++],[W1]
07610:  CP0.B   [W1++]
07612:  BTSS.B  42.1
07614:  BRA     760E
....................       } 
....................  
....................         // Create a dir here 
....................         if (!CreateDIR (tempDirectoryString)) 
07616:  MOV     #D2E,W4
07618:  MOV     W4,FA4
0761A:  CALL    7198
0761E:  CP0     W0
07620:  BRA     NZ,7632
....................         { 
....................             FileObjectCopy (cwdptr, tempCWD); 
07622:  PUSH    904
07624:  POP     1002
07626:  PUSH    F8A
07628:  POP     1004
0762A:  CALL    28E2
....................            return -1; 
0762E:  SETM    0
07630:  BRA     7682
....................         } 
....................  
....................         // Try to change to that directory 
....................         if (FSchdir (tempArray)) 
07632:  MOV     #F8C,W4
07634:  MOV     W4,FAE
07636:  CALL    651A
0763A:  CP0     W0
0763C:  BRA     Z,7652
....................         { 
....................             FileObjectCopy (cwdptr, tempCWD); 
0763E:  PUSH    904
07640:  POP     1002
07642:  PUSH    F8A
07644:  POP     1004
07646:  CALL    28E2
....................             FSerrno = CE_BADCACHEREAD; 
0764A:  MOV.B   #1B,W0L
0764C:  MOV.B   W0L,857
....................            return -1; 
0764E:  SETM    0
07650:  BRA     7682
....................         } 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................         if (mode == 1) 
....................         { 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................          { 
....................                while (*utf16path2 == '\\') 
....................                { 
....................                    utf16path2++; 
....................                    i = *utf16path2; 
....................                } 
....................          } 
....................          else 
....................          #endif 
....................            { 
....................                // Check for another backslash 
....................                while (*temppath2 == '\\') 
....................                { 
....................                    temppath2++; 
....................                    i = *temppath2; 
....................                } 
....................          } 
....................         } 
....................         else 
....................         { 
.................... #endif 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................          { 
....................                while (*utf16path == '\\') 
....................                { 
....................                    utf16path++; 
....................                    i = *utf16path; 
....................                } 
....................          } 
....................          else 
....................          #endif 
....................            { 
....................                while (*temppath == '\\') 
07652:  MOV     F86,W0
07654:  MOV.B   [W0],W4L
07656:  XOR.B   #5C,W4L
07658:  BRA     NZ,766A
....................                { 
....................                    temppath++; 
0765A:  INC     0F86
....................                    i = *temppath; 
0765C:  MOV     F86,W0
0765E:  MOV     W0,W4
07660:  MOV.B   [W4],W0L
07662:  SE      W0,W0
07664:  MOV     W0,F80
07666:  GOTO    7652
....................                } 
....................          } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................         } 
.................... #endif 
....................  
....................         // Check to see if we're at the end of the path string 
....................         if (i == 0) 
0766A:  CP0     F80
0766C:  BRA     NZ,767E
....................         { 
....................             // We already have one 
....................             FileObjectCopy (cwdptr, tempCWD); 
0766E:  PUSH    904
07670:  POP     1002
07672:  PUSH    F8A
07674:  POP     1004
07676:  CALL    28E2
....................            return 0; 
0767A:  CLR     0
0767C:  BRA     7682
....................         } 
0767E:  GOTO    7532
....................     } 
07682:  MOV     [--W15],W6
07684:  MOV     [--W15],W5
07686:  RETURN  
.................... } 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int CreateDIR (char * path) 
....................   Summary: 
....................     FSmkdir helper function to create a directory 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     path -  The name of the dir to create 
....................   Return Values: 
....................     TRUE -  Directory was created successfully 
....................     FALSE - Directory could not be created. 
....................   Side Effects: 
....................     Any unwritten data in the data buffer or the FAT buffer will be written 
....................     to the device. 
....................   Description: 
....................     The CreateDIR function is a helper function for the mkdirhelper 
....................     function.  The CreateDIR function will create a new file entry for 
....................     a directory and assign a cluster to it.  It will erase the cluster 
....................     and write a dot and dotdot entry to it. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int CreateDIR (char * path) 
*
07198:  MOV     W5,[W15++]
0719A:  MOV     W6,[W15++]
0719C:  MOV     #898,W4
0719E:  MOV     W4,FA6
*
071A2:  CLR     FAA
.................... { 
....................     FSFILE * dirEntryPtr = &gFileTemp; 
....................     DIRENTRY dir; 
*
071A0:  CLR     FA8
....................     WORD handle = 0; 
....................     DWORD dot, dotdot; 
*
071A4:  CLR     FAC
071A6:  CLR     FAE
071A8:  CLR     FB0
071AA:  CLR     FB2
....................  
....................     if (FormatDirName(path, dirEntryPtr,0) == FALSE) 
071AC:  CLR.B   1006
071AE:  PUSH    FA4
071B0:  POP     1002
071B2:  PUSH    FA6
071B4:  POP     1004
071B6:  CALL    5F64
071BA:  CP0.B   W0L
071BC:  BRA     NZ,71C6
....................     { 
....................         FSerrno = CE_INVALID_FILENAME; 
071BE:  MOV.B   #12,W0L
071C0:  MOV.B   W0L,857
....................         return FALSE; 
071C2:  CLR     0
071C4:  BRA     72FC
....................     } 
....................  
....................     dirEntryPtr->dirclus = cwdptr->dirclus; 
071C6:  MOV     #2E,W0
071C8:  ADD     FA6,W0
071CA:  MOV     W0,W5
071CC:  MOV     #2E,W0
071CE:  ADD     904,W0
071D0:  MOV     [W0++],[W5++]
071D2:  MOV     [W0++],[W5++]
....................     dirEntryPtr->dirccls = cwdptr->dirccls; 
071D4:  MOV     #32,W0
071D6:  ADD     FA6,W0
071D8:  MOV     W0,W5
071DA:  MOV     #32,W0
071DC:  ADD     904,W0
071DE:  MOV     [W0++],[W5++]
071E0:  MOV     [W0++],[W5++]
....................     dirEntryPtr->cluster = 0; 
071E2:  MOV     #2,W0
071E4:  ADD     FA6,W0
071E6:  MOV     W0,W5
071E8:  CLR.B   [W5]
071EA:  MOV.B   #0,W0L
071EC:  MOV.B   W0L,[W5+#1]
071EE:  MOV.B   #0,W0L
071F0:  MOV.B   W0L,[W5+#2]
071F2:  MOV.B   #0,W0L
071F4:  MOV.B   W0L,[W5+#3]
....................     dirEntryPtr->ccls = 0; 
071F6:  MOV     #6,W0
071F8:  ADD     FA6,W0
071FA:  MOV     W0,W5
071FC:  CLR.B   [W5]
071FE:  MOV.B   #0,W0L
07200:  MOV.B   W0L,[W5+#1]
07202:  MOV.B   #0,W0L
07204:  MOV.B   W0L,[W5+#2]
07206:  MOV.B   #0,W0L
07208:  MOV.B   W0L,[W5+#3]
....................     dirEntryPtr->dsk = cwdptr->dsk; 
0720A:  MOV     FA6,W4
0720C:  ADD     W4,#0,W4
0720E:  MOV     W4,W0
07210:  MOV     W0,W5
07212:  MOV     904,W4
07214:  ADD     W4,#0,W4
07216:  MOV     W4,W0
07218:  MOV     [W0],[W5]
....................  
....................     // Create a directory entry 
....................     if(CreateFileEntry(dirEntryPtr, &handle, DIRECTORY, TRUE) != CE_GOOD) 
0721A:  MOV.B   #12,W0L
0721C:  MOV.B   W0L,FD6
0721E:  MOV.B   #1,W0L
07220:  MOV.B   W0L,FD7
07222:  PUSH    FA6
07224:  POP     FD2
07226:  MOV     #FAA,W4
07228:  MOV     W4,FD4
0722A:  CALL    43FA
0722E:  CP0.B   W0L
07230:  BRA     Z,723A
....................     { 
....................         return FALSE; 
07232:  CLR     0
07234:  BRA     72FC
....................     } 
07236:  GOTO    72FC
....................     else 
....................     { 
....................         if (gNeedFATWrite) 
0723A:  CP0.B   83F
0723C:  BRA     Z,726C
....................             if(WriteFAT (dirEntryPtr->dsk, 0, 0, TRUE)) 
0723E:  MOV     FA6,W4
07240:  ADD     W4,#0,W4
07242:  MOV     W4,W0
07244:  MOV     [W0],W5
07246:  MOV     W0,[W15++]
07248:  MOV.B   #1,W0L
0724A:  MOV.B   W0L,1078
0724C:  MOV     [--W15],W0
0724E:  MOV     W5,106E
07250:  CLR     1070
07252:  CLR     1072
07254:  CLR     1074
07256:  CLR     1076
07258:  CALL    2C18
0725C:  CP0     W0
0725E:  BRA     NZ,7264
07260:  CP0     W1
07262:  BRA     Z,726C
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
07264:  MOV.B   #9,W0L
07266:  MOV.B   W0L,857
....................                 return FALSE; 
07268:  CLR     0
0726A:  BRA     72FC
....................             } 
....................         // Zero that cluster 
....................         if (dirEntryPtr->dirclus == FatRootDirClusterValue) 
0726C:  MOV     #2E,W0
0726E:  ADD     FA6,W0
07270:  MOV     #A,W4
07272:  MOV     [W0++],[W4++]
07274:  MOV     [W0++],[W4++]
07276:  MOV     858,W4
07278:  CP      W4,W5
0727A:  BRA     NZ,728A
0727C:  MOV     85A,W4
0727E:  CP      W4,W6
07280:  BRA     NZ,728A
....................             dotdot = 0; 
07282:  CLR     FB0
07284:  CLR     FB2
07286:  GOTO    7294
....................         else 
....................             dotdot = dirEntryPtr->dirclus; 
0728A:  MOV     #2E,W0
0728C:  ADD     FA6,W0
0728E:  MOV     #FB0,W4
07290:  MOV     [W0++],[W4++]
07292:  MOV     [W0++],[W4++]
....................         dirEntryPtr->dirccls = dirEntryPtr->dirclus; 
07294:  MOV     #32,W0
07296:  ADD     FA6,W0
07298:  MOV     W0,W5
0729A:  MOV     #2E,W0
0729C:  ADD     FA6,W0
0729E:  MOV     [W0++],[W5++]
072A0:  MOV     [W0++],[W5++]
....................         dir = Cache_File_Entry(dirEntryPtr, &handle, TRUE); 
072A2:  MOV.B   #1,W0L
072A4:  MOV.B   W0L,102C
072A6:  PUSH    FA6
072A8:  POP     1028
072AA:  MOV     #FAA,W4
072AC:  MOV     W4,102A
072AE:  CALL    31E4
072B2:  MOV     W0,FA8
....................         if (dir == NULL) 
072B4:  CP0     FA8
072B6:  BRA     NZ,72C0
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
072B8:  MOV.B   #1B,W0L
072BA:  MOV.B   W0L,857
....................             return FALSE; 
072BC:  CLR     0
072BE:  BRA     72FC
....................         } 
....................  
....................         // Get the cluster 
....................         dot = GetFullClusterNumber(dir); // Get complete cluster number. 
072C0:  PUSH    FA8
072C2:  POP     102A
072C4:  CALL    34B4
072C8:  MOV     W0,FAC
072CA:  MOV     W1,FAE
....................  
....................         if (writeDotEntries (dirEntryPtr->dsk, dot, dotdot)) 
072CC:  MOV     FA6,W4
072CE:  ADD     W4,#0,W4
072D0:  MOV     W4,W0
072D2:  MOV     [W0],W5
072D4:  MOV     W5,FB8
072D6:  PUSH    FAC
072D8:  POP     FBA
072DA:  PUSH    FAE
072DC:  POP     FBC
072DE:  PUSH    FB0
072E0:  POP     FBE
072E2:  PUSH    FB2
072E4:  POP     FC0
072E6:  CALL    7014
072EA:  CP0.B   W0L
072EC:  BRA     Z,72F8
....................             return TRUE; 
072EE:  MOV     #1,W4
072F0:  MOV     W4,0
072F2:  BRA     72FC
072F4:  GOTO    72FC
....................         else 
....................             return FALSE; 
072F8:  CLR     0
072FA:  BRA     72FC
....................  
....................     } 
072FC:  MOV     [--W15],W6
072FE:  MOV     [--W15],W5
07300:  RETURN  
.................... } 
....................  
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     BYTE writeDotEntries (DISK * disk, DWORD dotAddress, DWORD dotdotAddress) 
....................   Summary: 
....................     Create dot and dotdot entries in a non-root directory 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     disk -           The global disk structure 
....................     dotAddress -     The cluster the current dir is in 
....................     dotdotAddress -  The cluster the previous directory was in 
....................   Return Values: 
....................     TRUE -  The dot and dotdot entries were created 
....................     FALSE - The dot and dotdot entries could not be created in the new directory 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The writeDotEntries function will create and write dot and dotdot entries 
....................     to a newly created directory. 
....................   Remarks: 
....................     None. 
....................   ***********************************************************************************/ 
....................  
.................... BYTE writeDotEntries (DISK * disk, DWORD dotAddress, DWORD dotdotAddress) 
*
07014:  MOV     W5,[W15++]
07016:  MOV     W6,[W15++]
07018:  MOV     W7,[W15++]
*
0703E:  MOV     #FC6,W4
07040:  MOV     W4,FE6
.................... { 
....................     WORD i; 
*
0701A:  CLR     FC2
....................     WORD size; 
0701C:  CLR     FC4
....................     volatile _DIRENTRY entry; 
0701E:  CLR     FC6
07020:  CLR     FC8
07022:  CLR     FCA
07024:  CLR     FCC
07026:  CLR     FCE
07028:  CLR     FD0
0702A:  CLR     FD2
0702C:  CLR     FD4
0702E:  CLR     FD6
07030:  CLR     FD8
07032:  CLR     FDA
07034:  CLR     FDC
07036:  CLR     FDE
07038:  CLR     FE0
0703A:  CLR     FE2
0703C:  CLR     FE4
....................     DIRENTRY entryptr = (DIRENTRY)&entry; 
....................     DWORD sector; 
*
07042:  CLR     FE8
07044:  CLR     FEA
....................  
....................     gBufferOwner = NULL; 
07046:  CLR     84E
....................  
....................     size = sizeof (_DIRENTRY); 
07048:  MOV     #20,W4
0704A:  MOV     W4,FC4
....................  
....................    memset(disk->buffer, 0x00, disk->sectorSize); 
0704C:  MOV     FB8,W4
0704E:  ADD     W4,#0,W4
07050:  MOV     W4,W0
07052:  MOV     #A,W1
07054:  MOV     W0,W2
07056:  REPEAT  #1
07058:  MOV.B   [W2++],[W1++]
0705A:  MOV     FB8,W4
0705C:  ADD     W4,#18,W4
0705E:  MOV     W4,W0
07060:  MOV     #C,W1
07062:  MOV     W0,W2
07064:  REPEAT  #3
07066:  MOV.B   [W2++],[W1++]
07068:  MOV     W5,W1
0706A:  MOV     #0,W2
0706C:  MOV     W6,W0
0706E:  DEC     W0,W0
07070:  BRA     N,7074
07072:  REPEAT  W0
07074:  CLR.B   [W1++]
....................  
....................     entry.DIR_Name[0] = '.'; 
07076:  MOV.B   #2E,W0L
07078:  MOV.B   W0L,FC6
....................  
....................     for (i = 1; i < 8; i++) 
0707A:  MOV     #1,W4
0707C:  MOV     W4,FC2
0707E:  MOV     FC2,W4
07080:  CP      W4,#8
07082:  BRA     C,7094
....................     { 
....................         entry.DIR_Name[i] = 0x20; 
07084:  MOV     #FC6,W4
07086:  MOV     FC2,W3
07088:  ADD     W3,W4,W5
0708A:  MOV.B   #20,W0L
0708C:  MOV.B   W0L,[W5]
0708E:  INC     0FC2
07090:  GOTO    707E
....................     } 
....................     for (i = 0; i < 3; i++) 
07094:  CLR     FC2
07096:  MOV     FC2,W4
07098:  CP      W4,#3
0709A:  BRA     C,70AC
....................     { 
....................         entry.DIR_Extension[i] = 0x20; 
0709C:  MOV     #FCE,W0
0709E:  ADD     FC2,W0
070A0:  MOV     W0,W5
070A2:  MOV.B   #20,W0L
070A4:  MOV.B   W0L,[W5]
070A6:  INC     0FC2
070A8:  GOTO    7096
....................     } 
....................  
....................     entry.DIR_Attr = ATTR_DIRECTORY; 
070AC:  MOV.B   #10,W0L
070AE:  MOV.B   W0L,FD1
....................     entry.DIR_NTRes = 0x00; 
070B0:  CLR.B   FD2
....................  
....................     entry.DIR_FstClusLO = (WORD)(dotAddress & 0x0000FFFF); // Lower 16 bit address 
070B2:  CLR     W1
070B4:  MOV     FBA,W0
070B6:  MOV     W0,FE0
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................     entry.DIR_FstClusHI = (WORD)((dotAddress & 0x0FFF0000)>> 16); // Higher 16 bit address. FAT32 uses only 28 bits. Mask even higher nibble also. 
070B8:  CLR     W5
070BA:  MOV     #FFF,W0
070BC:  AND     FBC,W0
070BE:  MOV     W0,W6
070C0:  MOV     W6,W0
070C2:  MOV     #0,W1
070C4:  MOV     W0,FDA
.................... #else // If FAT32 support not enabled 
....................     entry.DIR_FstClusHI = 0; 
.................... #endif 
....................  
....................     entry.DIR_FileSize = 0x00; 
070C6:  CLR     FE2
070C8:  CLR     FE4
....................  
.................... // Times need to be the same as the times in the directory entry 
....................  
.................... // Set dir date for uncontrolled clock source 
.................... #ifdef INCREMENTTIMESTAMP 
....................     entry.DIR_CrtTimeTenth = 0xB2; 
....................     entry.DIR_CrtTime = 0x7278; 
....................     entry.DIR_CrtDate = 0x32B0; 
....................     entry.DIR_LstAccDate = 0x0000; 
....................     entry.DIR_WrtTime = 0x0000; 
....................     entry.DIR_WrtDate = 0x0000; 
.................... #endif 
....................  
.................... #ifdef USEREALTIMECLOCK 
....................     entry.DIR_CrtTimeTenth = gTimeCrtMS;         // millisecond stamp 
....................     entry.DIR_CrtTime =      gTimeCrtTime;      // time created // 
....................     entry.DIR_CrtDate =      gTimeCrtDate;      // date created (1/1/2004) 
....................     entry.DIR_LstAccDate =   0x0000;         // Last Access date 
....................     entry.DIR_WrtTime =      0x0000;         // last update time 
....................     entry.DIR_WrtDate =      0x0000;         // last update date 
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................     entry.DIR_CrtTimeTenth  =   gTimeCrtMS;         // millisecond stamp 
070CA:  MOV.B   83E,W0L
070CC:  MOV.B   W0L,FD3
....................     entry.DIR_CrtTime       =   gTimeCrtTime;       // time created // 
070CE:  PUSH    840
070D0:  POP     FD4
....................     entry.DIR_CrtDate       =   gTimeCrtDate;       // date created (1/1/2004) 
070D2:  PUSH    842
070D4:  POP     FD6
....................     entry.DIR_LstAccDate    =   0x0000;             // Last Access date 
070D6:  CLR     FD8
....................     entry.DIR_WrtTime       =   0x0000;             // last update time 
070D8:  CLR     FDC
....................     entry.DIR_WrtDate       =   0x0000;             // last update date 
070DA:  CLR     FDE
.................... #endif 
....................  
....................     for (i = 0; i < size; i++) 
070DC:  CLR     FC2
070DE:  MOV     FC2,W0
070E0:  MOV     FC4,W4
070E2:  CP      W4,W0
070E4:  BRA     LEU,7106
....................     { 
....................         *(disk->buffer + i) = *((char *)entryptr + i); 
070E6:  MOV     FB8,W4
070E8:  ADD     W4,#0,W4
070EA:  MOV     W4,W0
070EC:  MOV     #A,W1
070EE:  MOV     W0,W2
070F0:  REPEAT  #1
070F2:  MOV.B   [W2++],[W1++]
070F4:  MOV     W5,W0
070F6:  ADD     FC2,W0
070F8:  MOV     W0,W5
070FA:  MOV     FE6,W0
070FC:  ADD     FC2,W0
070FE:  MOV.B   [W0],[W5]
07100:  INC     0FC2
07102:  GOTO    70DE
....................     } 
....................     entry.DIR_Name[1] = '.'; 
07106:  MOV.B   #2E,W0L
07108:  MOV.B   W0L,FC7
....................  
....................     entry.DIR_FstClusLO = (WORD)(dotdotAddress & 0x0000FFFF); // Lower 16 bit address 
0710A:  CLR     W1
0710C:  MOV     FBE,W0
0710E:  MOV     W0,FE0
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................     entry.DIR_FstClusHI = (WORD)((dotdotAddress & 0x0FFF0000)>> 16); // Higher 16 bit address. FAT32 uses only 28 bits. Mask even higher nibble also. 
07110:  CLR     W5
07112:  MOV     #FFF,W0
07114:  AND     FC0,W0
07116:  MOV     W0,W6
07118:  MOV     W6,W0
0711A:  MOV     #0,W1
0711C:  MOV     W0,FDA
.................... #else // If FAT32 support not enabled 
....................     entry.DIR_FstClusHI = 0; 
.................... #endif 
....................  
....................  
....................     for (i = 0; i < size; i++) 
0711E:  CLR     FC2
07120:  MOV     FC2,W0
07122:  MOV     FC4,W4
07124:  CP      W4,W0
07126:  BRA     LEU,714E
....................     { 
....................         *(disk->buffer + i + size) = *((char *)entryptr + i); 
07128:  MOV     FB8,W4
0712A:  ADD     W4,#0,W4
0712C:  MOV     W4,W0
0712E:  MOV     #A,W1
07130:  MOV     W0,W2
07132:  REPEAT  #1
07134:  MOV.B   [W2++],[W1++]
07136:  MOV     W5,W0
07138:  ADD     FC2,W0
0713A:  MOV     W0,W5
0713C:  MOV     W5,W0
0713E:  ADD     FC4,W0
07140:  MOV     W0,W5
07142:  MOV     FE6,W0
07144:  ADD     FC2,W0
07146:  MOV.B   [W0],[W5]
07148:  INC     0FC2
0714A:  GOTO    7120
....................     } 
....................  
....................     sector = Cluster2Sector (disk, dotAddress); 
0714E:  PUSH    FB8
07150:  POP     1056
07152:  PUSH    FBA
07154:  POP     1058
07156:  PUSH    FBC
07158:  POP     105A
0715A:  CALL    308C
0715E:  MOV     W0,FE8
07160:  MOV     W1,FEA
....................  
....................     if (MDD_SectorWrite(sector, disk->buffer, FALSE) == FALSE) 
07162:  MOV     FB8,W4
07164:  ADD     W4,#0,W4
07166:  MOV     W4,W0
07168:  MOV     #A,W1
0716A:  MOV     W0,W2
0716C:  REPEAT  #1
0716E:  MOV.B   [W2++],[W1++]
07170:  CLR.B   109E
07172:  PUSH    FE8
07174:  POP     1098
07176:  PUSH    FEA
07178:  POP     109A
0717A:  MOV     W5,109C
0717C:  CALL    2BBE
07180:  CP0.B   W0L
07182:  BRA     NZ,718C
....................     { 
....................         FSerrno = CE_WRITE_ERROR; 
07184:  MOV.B   #9,W0L
07186:  MOV.B   W0L,857
....................         return FALSE; 
07188:  CLR.B   0
0718A:  BRA     7190
....................     } 
....................  
....................     return TRUE; 
0718C:  MOV.B   #1,W0L
0718E:  MOV.B   W0L,0
07190:  MOV     [--W15],W7
07192:  MOV     [--W15],W6
07194:  MOV     [--W15],W5
07196:  RETURN  
.................... } 
....................  
.................... // This array is used to prevent a stack frame error 
.................... #ifdef __18CXX 
....................     char tempArray[13] = "           "; 
.................... #endif 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdir (char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs - 
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int FSrmdir (char * path, unsigned char rmsubdirs) 
.................... { 
....................     return rmdirhelper (0, path, NULL, rmsubdirs); 
*
07EB6:  CLR.B   F7C
07EB8:  MOV.B   F78,W0L
07EBA:  MOV.B   W0L,F7D
07EBC:  PUSH    F76
07EBE:  POP     F7E
07EC0:  CLR     F80
07EC2:  CALL    7818
07EC6:  MOV     W0,0
07EC8:  RETURN  
.................... } 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs) 
....................   Summary: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs - 
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................     result = rmdirhelper (0, (char *)path, NULL, rmsubdirs); 
....................    utfModeFileName = FALSE; 
....................     return result; 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdirpgm (const rom char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     path -      The path of the directory to remove (ROM) 
....................     rmsubdirs - 
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................     This function deletes the directory as specified in the path. 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int FSrmdirpgm (const rom char * path, unsigned char rmsubdirs) 
.................... { 
....................     return rmdirhelper (1, NULL, path, rmsubdirs); 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................         int wFSrmdirpgm (const rom unsigned short int * path, unsigned char rmsubdirs) 
....................   Summary: 
....................     Delete a directory with a path in ROM on PIC18 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     path -      The path of the directory to remove (ROM) 
....................     rmsubdirs - 
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSrmdirpgm function passes a PIC18 ROM path pointer to the 
....................     rmdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................  
.................... #ifdef SUPPORT_LFN 
.................... int wFSrmdirpgm (const rom unsigned short int * path, unsigned char rmsubdirs) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................     result = rmdirhelper (1, NULL, (const char *)path, rmsubdirs); 
....................    utfModeFileName = FALSE; 
....................     return result; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /************************************************************************************************ 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int rmdirhelper (BYTE mode, char * ramptr, char * romptr, unsigned char rmsubdirs) 
....................     // PIC18 
....................     int rmdirhelper (BYTE mode, char * ramptr, const rom char * romptr, unsigned char rmsubdirs) 
....................   Summary: 
....................     Helper function for FSrmdir 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     path -      The path of the dir to delete 
....................     rmsubdirs - 
....................               - TRUE -  Remove all sub-directories and files in the directory 
....................               - FALSE - Non-empty directories can not be removed 
....................   Return Values: 
....................     0 -   The specified directory was successfully removed. 
....................     EOF - The specified directory could not be removed. 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This helper function is used by the FSmkdir function.  If the path 
....................     argument is specified in ROM for PIC18 this function will be able 
....................     to parse it correctly.  This function will first change to the 
....................     specified directory.  If the rmsubdirs argument is FALSE the function 
....................     will search through the directory to ensure that it is empty and then 
....................     remove it.  If the rmsubdirs argument is TRUE the function will also 
....................     search through the directory for subdirectories or files.  When the 
....................     function finds a file, the file will be erased.  When the function 
....................     finds a subdirectory, it will switch to the subdirectory and begin 
....................     removing all of the files in that subdirectory.  Once the subdirectory 
....................     is empty, the function will switch back to the original directory. 
....................     return to the original position in that directory, and continue removing 
....................     files.  Once the specified directory is empty, the function will 
....................     change to the parent directory, search through it for the directory 
....................     to remove, and then erase that directory. 
....................   Remarks: 
....................     None. 
....................   ************************************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int rmdirhelper (BYTE mode, char * ramptr, const rom char * romptr, unsigned char rmsubdirs) 
.................... #else 
.................... int rmdirhelper (BYTE mode, char * ramptr, char * romptr, unsigned char rmsubdirs) 
.................... #endif 
*
07818:  MOV     W5,[W15++]
0781A:  MOV     W6,[W15++]
0781C:  MOV     #862,W4
0781E:  MOV     W4,F82
07820:  MOV     #898,W4
07822:  MOV     W4,F84
*
07826:  CLR     F88
*
0782C:  CLR     F8E
.................... { 
....................     FILEOBJ tempCWD = &tempCWDobj; 
....................     FILEOBJ fo = &gFileTemp; 
....................     DIRENTRY entry; 
*
07824:  CLR     F86
....................     WORD handle = 0; 
....................     WORD handle2; 
*
07828:  CLR     F8A
....................     WORD subDirDepth; 
0782A:  CLR     F8C
....................     short int Index3 = 0; 
....................     char Index, Index2; 
*
0782E:  CLR.B   F90
07830:  CLR.B   F91
....................  
....................    #if defined(SUPPORT_LFN) 
....................  
....................       BOOL prevUtfModeFileName = utfModeFileName; 
....................       char tempArray[514]; 
....................        WORD prevHandle; 
....................        LFN_ENTRY *lfno; 
....................        FSFILE cwdTemp; 
....................       UINT16_VAL tempShift; 
....................       unsigned short int *tempLFN = (unsigned short int *)&tempArray[0]; 
....................       BOOL   forFirstTime; 
....................    #else 
....................  
....................       char   tempArray[13]; 
07832:  CLR     F92
07834:  CLR     F94
07836:  CLR     F96
07838:  CLR     F98
0783A:  CLR     F9A
0783C:  CLR     F9C
0783E:  CLR.B   F9E
....................  
....................    #endif 
....................  
.................... #ifndef __18CXX 
....................  
.................... #else 
....................     char dotdotname[] = ".."; 
....................     char dotdotname1[5] = {'.','\0','.','\0','\0'}; 
.................... #endif 
....................  
....................     FSerrno = CE_GOOD; 
07840:  CLR.B   857
....................  
....................     // Back up the current working directory 
....................     FileObjectCopy (tempCWD, cwdptr); 
07842:  PUSH    F82
07844:  POP     1002
07846:  PUSH    904
07848:  POP     1004
0784A:  CALL    28E2
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     if (mode) 
....................     { 
....................         if (chdirhelper (1, NULL, romptr)) 
....................         { 
....................             FSerrno = CE_DIR_NOT_FOUND; 
....................             return -1; 
....................         } 
....................     } 
....................     else 
....................     { 
.................... #endif 
....................         if (FSchdir (ramptr)) 
0784E:  PUSH    F7E
07850:  POP     FAE
07852:  CALL    651A
07856:  CP0     W0
07858:  BRA     Z,7862
....................         { 
....................             FSerrno = CE_DIR_NOT_FOUND; 
0785A:  MOV.B   #C,W0L
0785C:  MOV.B   W0L,857
....................             return -1; 
0785E:  SETM    0
07860:  BRA     7EB0
....................         } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     } 
.................... #endif 
....................  
....................     // Make sure we aren't trying to remove the root dir or the CWD 
....................     if ((cwdptr->dirclus == FatRootDirClusterValue) || (cwdptr->dirclus == tempCWD->dirclus)) 
07862:  MOV     #2E,W0
07864:  ADD     904,W0
07866:  MOV     #A,W4
07868:  MOV     [W0++],[W4++]
0786A:  MOV     [W0++],[W4++]
0786C:  MOV     858,W4
0786E:  CP      W4,W5
07870:  BRA     NZ,7878
07872:  MOV     85A,W4
07874:  CP      W4,W6
07876:  BRA     Z,7896
07878:  MOV     #2E,W0
0787A:  ADD     904,W0
0787C:  MOV     #A,W4
0787E:  MOV     [W0++],[W4++]
07880:  MOV     [W0++],[W4++]
07882:  MOV     #2E,W0
07884:  ADD     F82,W0
07886:  MOV     W0,W4
07888:  MOV     #0,W3
0788A:  MOV     [W4++],[W3++]
0788C:  MOV     [W4++],[W3++]
0788E:  CP      W5,W0
07890:  BRA     NZ,78AA
07892:  CP      W6,W1
07894:  BRA     NZ,78AA
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
07896:  PUSH    904
07898:  POP     1002
0789A:  PUSH    F82
0789C:  POP     1004
0789E:  CALL    28E2
....................         FSerrno = CE_INVALID_ARGUMENT; 
078A2:  MOV.B   #1F,W0L
078A4:  MOV.B   W0L,857
....................         return -1; 
078A6:  SETM    0
078A8:  BRA     7EB0
....................     } 
....................  
....................     handle++; 
078AA:  INC     0F88
....................     entry = Cache_File_Entry (cwdptr, &handle, TRUE); 
078AC:  MOV.B   #1,W0L
078AE:  MOV.B   W0L,102C
078B0:  PUSH    904
078B2:  POP     1028
078B4:  MOV     #F88,W4
078B6:  MOV     W4,102A
078B8:  CALL    31E4
078BC:  MOV     W0,F86
....................  
....................     if (entry == NULL) 
078BE:  CP0     F86
078C0:  BRA     NZ,78D6
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
078C2:  PUSH    904
078C4:  POP     1002
078C6:  PUSH    F82
078C8:  POP     1004
078CA:  CALL    28E2
....................         FSerrno = CE_BADCACHEREAD; 
078CE:  MOV.B   #1B,W0L
078D0:  MOV.B   W0L,857
....................         return -1; 
078D2:  SETM    0
078D4:  BRA     7EB0
....................     } 
....................  
....................     handle++; 
078D6:  INC     0F88
....................     entry = Cache_File_Entry (cwdptr, &handle, FALSE); 
078D8:  CLR.B   102C
078DA:  PUSH    904
078DC:  POP     1028
078DE:  MOV     #F88,W4
078E0:  MOV     W4,102A
078E2:  CALL    31E4
078E6:  MOV     W0,F86
....................     if (entry == NULL) 
078E8:  CP0     F86
078EA:  BRA     NZ,7900
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
078EC:  PUSH    904
078EE:  POP     1002
078F0:  PUSH    F82
078F2:  POP     1004
078F4:  CALL    28E2
....................         FSerrno = CE_BADCACHEREAD; 
078F8:  MOV.B   #1B,W0L
078FA:  MOV.B   W0L,857
....................         return -1; 
078FC:  SETM    0
078FE:  BRA     7EB0
....................     } 
....................     // Don't remove subdirectories and sub-files 
....................     if (!rmsubdirs) 
07900:  CP0.B   F7D
07902:  BRA     NZ,7960
....................     { 
....................         while (entry->DIR_Name[0] != 0) 
07904:  MOV     #0,W0
07906:  ADD     F86,W0
07908:  MOV.B   [W0],W5L
0790A:  SE      W5,W5
0790C:  CP0     W5
0790E:  BRA     Z,795C
....................         { 
....................             if ((unsigned char)entry->DIR_Name[0] != 0xE5) 
07910:  MOV     #0,W0
07912:  ADD     F86,W0
07914:  MOV.B   [W0],W4L
07916:  XOR.B   #E5,W4L
07918:  BRA     Z,792E
....................             { 
....................                 FileObjectCopy (cwdptr, tempCWD); 
0791A:  PUSH    904
0791C:  POP     1002
0791E:  PUSH    F82
07920:  POP     1004
07922:  CALL    28E2
....................                 FSerrno = CE_DIR_NOT_EMPTY; 
07926:  MOV.B   #16,W0L
07928:  MOV.B   W0L,857
....................                 return -1; 
0792A:  SETM    0
0792C:  BRA     7EB0
....................             } 
....................             handle++; 
0792E:  INC     0F88
....................             entry = Cache_File_Entry (cwdptr, &handle, FALSE); 
07930:  CLR.B   102C
07932:  PUSH    904
07934:  POP     1028
07936:  MOV     #F88,W4
07938:  MOV     W4,102A
0793A:  CALL    31E4
0793E:  MOV     W0,F86
....................             if ((entry == NULL)) 
07940:  CP0     F86
07942:  BRA     NZ,7958
....................             { 
....................                 FileObjectCopy (cwdptr, tempCWD); 
07944:  PUSH    904
07946:  POP     1002
07948:  PUSH    F82
0794A:  POP     1004
0794C:  CALL    28E2
....................                 FSerrno = CE_BADCACHEREAD; 
07950:  MOV.B   #1B,W0L
07952:  MOV.B   W0L,857
....................                 return -1; 
07954:  SETM    0
07956:  BRA     7EB0
....................             } 
07958:  GOTO    7904
....................         } 
....................     } 
0795C:  GOTO    7DEA
....................     else 
....................     { 
....................         // Do remove subdirectories and sub-files 
....................         dirCleared = FALSE; 
07960:  CLR.B   860
....................         subDirDepth = 0; 
07962:  CLR     F8C
....................       #if defined(SUPPORT_LFN) 
....................       tempCWD-> utf16LFNptr = (unsigned short int *)&tempArray[0]; 
....................       fo-> utf16LFNptr = (unsigned short int *)&tempArray[0]; 
....................       #endif 
....................  
....................         while (!dirCleared) 
07964:  CP0.B   860
07966:  BRA     NZ,7DEA
....................         { 
....................             if (entry->DIR_Name[0] != 0) 
07968:  MOV     #0,W0
0796A:  ADD     F86,W0
0796C:  MOV.B   [W0],W5L
0796E:  SE      W5,W5
07970:  CP0     W5
07972:  BRA     Z,7BF6
....................             { 
....................                 if (((unsigned char)entry->DIR_Name[0] != 0xE5) && (entry->DIR_Attr == ATTR_LONG_NAME)) 
07974:  MOV     #0,W0
07976:  ADD     F86,W0
07978:  MOV.B   [W0],W4L
0797A:  XOR.B   #E5,W4L
0797C:  BRA     Z,798C
0797E:  MOV     #B,W0
07980:  ADD     F86,W0
07982:  MOV.B   [W0],W4L
07984:  CP.B    W4L,#F
07986:  BRA     NZ,798C
....................             { 
....................                #if defined(SUPPORT_LFN) 
....................                lfno = (LFN_ENTRY *)entry; 
....................  
....................                if(lfno->LFN_SequenceNo & 0x40) 
....................                { 
....................                   Index3 = (lfno->LFN_SequenceNo - 0x41) * 13; 
....................                   tempLFN[Index3 + 13] = 0x0000; 
....................                   forFirstTime = TRUE; 
....................                } 
....................                else 
....................                { 
....................                   Index3 = (lfno->LFN_SequenceNo - 1) * 13; 
....................                   forFirstTime = FALSE; 
....................                } 
....................  
....................                tempShift.byte.LB = lfno->LFN_Part1[0]; 
....................                tempShift.byte.HB = lfno->LFN_Part1[1]; 
....................                tempLFN[Index3++] = tempShift.Val; 
....................                tempShift.byte.LB = lfno->LFN_Part1[2]; 
....................                tempShift.byte.HB = lfno->LFN_Part1[3]; 
....................                tempLFN[Index3++] = tempShift.Val; 
....................                tempShift.byte.LB = lfno->LFN_Part1[4]; 
....................                tempShift.byte.HB = lfno->LFN_Part1[5]; 
....................                tempLFN[Index3++] = tempShift.Val; 
....................                tempShift.byte.LB = lfno->LFN_Part1[6]; 
....................                tempShift.byte.HB = lfno->LFN_Part1[7]; 
....................                tempLFN[Index3++] = tempShift.Val; 
....................                tempShift.byte.LB = lfno->LFN_Part1[8]; 
....................                tempShift.byte.HB = lfno->LFN_Part1[9]; 
....................                tempLFN[Index3++] = tempShift.Val; 
....................  
....................                tempLFN[Index3++] = lfno->LFN_Part2[0]; 
....................                tempLFN[Index3++] = lfno->LFN_Part2[1]; 
....................                tempLFN[Index3++] = lfno->LFN_Part2[2]; 
....................                tempLFN[Index3++] = lfno->LFN_Part2[3]; 
....................                tempLFN[Index3++] = lfno->LFN_Part2[4]; 
....................                tempLFN[Index3++] = lfno->LFN_Part2[5]; 
....................  
....................                tempLFN[Index3++] = lfno->LFN_Part3[0]; 
....................                tempLFN[Index3] = lfno->LFN_Part3[1]; 
....................  
....................                if(forFirstTime) 
....................                { 
....................                   tempCWD->utf16LFNlength = Index3; 
....................  
....................                   for(Index = 12;Index >= 0;Index--) 
....................                   { 
....................                      if((tempLFN[Index3 - Index - 1]) == 0x0000) 
....................                      { 
....................                         tempCWD->utf16LFNlength = Index3 - Index - 1; 
....................                         break; 
....................                      } 
....................                   } 
....................  
....................                   fo->utf16LFNlength = tempCWD->utf16LFNlength; 
....................                } 
....................                    handle++; 
....................                #endif 
....................             } 
07988:  GOTO    7BA0
....................                 else if (((unsigned char)entry->DIR_Name[0] != 0xE5) && (entry->DIR_Attr != ATTR_VOLUME) && (entry->DIR_Attr != ATTR_LONG_NAME)) 
0798C:  MOV     #0,W0
0798E:  ADD     F86,W0
07990:  MOV.B   [W0],W4L
07992:  XOR.B   #E5,W4L
07994:  BRA     Z,7B9E
07996:  MOV     #B,W0
07998:  ADD     F86,W0
0799A:  MOV.B   [W0],W4L
0799C:  CP.B    W4L,#8
0799E:  BRA     Z,7B9E
079A0:  MOV     #B,W0
079A2:  ADD     F86,W0
079A4:  MOV.B   [W0],W4L
079A6:  CP.B    W4L,#F
079A8:  BRA     Z,7B9E
....................                 { 
....................                     if ((entry->DIR_Attr & ATTR_DIRECTORY) == ATTR_DIRECTORY) 
079AA:  MOV     #B,W0
079AC:  ADD     F86,W0
079AE:  MOV.B   [W0],W0L
079B0:  CLR.B   1
079B2:  AND     W0,#10,W5
079B4:  CP      W5,#10
079B6:  BRA     NZ,7ABA
....................                     { 
....................                         // We have a directory 
....................                         subDirDepth++; 
079B8:  INC     0F8C
....................                   #if defined(SUPPORT_LFN) 
....................                   if(tempCWD-> utf16LFNlength) 
....................                   { 
....................                      utfModeFileName = 1; 
....................                      Index = FSchdir(&tempArray[0]); 
....................                      utfModeFileName = prevUtfModeFileName; 
....................                      tempCWD-> utf16LFNlength = 0; 
....................                      fo-> utf16LFNlength = 0; 
....................                   } 
....................                   else 
....................                   #endif 
....................                   { 
....................                            for (Index = 0; (Index < DIR_NAMESIZE) && (entry->DIR_Name[(BYTE)Index] != 0x20); Index++) 
079BA:  CLR.B   F90
079BC:  MOV.B   F90,W0L
079BE:  SE      W0,W0
079C0:  CP      W0,#8
079C2:  BRA     GE,79EE
079C4:  MOV     F90,W4
079C6:  CLR.B   9
079C8:  MOV     W4,W0
079CA:  ADD     F86,W0
079CC:  MOV.B   [W0],W5L
079CE:  SE      W5,W5
079D0:  MOV     #20,W4
079D2:  CP      W4,W5
079D4:  BRA     Z,79EE
....................                            { 
....................                                tempArray[(BYTE)Index] = entry->DIR_Name[(BYTE)Index]; 
079D6:  MOV     F90,W4
079D8:  CLR.B   9
079DA:  MOV     #F92,W3
079DC:  ADD     W4,W3,W5
079DE:  MOV     F90,W4
079E0:  CLR.B   9
079E2:  MOV     W4,W0
079E4:  ADD     F86,W0
079E6:  MOV.B   [W0],[W5]
079E8:  INC.B   0F90
079EA:  GOTO    79BC
....................                            } 
....................                            if (entry->DIR_Extension[0] != 0x20) 
079EE:  MOV     #8,W0
079F0:  ADD     F86,W0
079F2:  MOV.B   [W0],W5L
079F4:  SE      W5,W5
079F6:  MOV     #20,W4
079F8:  CP      W4,W5
079FA:  BRA     Z,7A4C
....................                            { 
....................                                tempArray[(BYTE)Index++] = '.'; 
079FC:  MOV.B   F90,W0L
079FE:  INC.B   0F90
07A00:  ZE      W0,W0
07A02:  CLR.B   1
07A04:  MOV     #F92,W4
07A06:  ADD     W0,W4,W5
07A08:  MOV.B   #2E,W0L
07A0A:  MOV.B   W0L,[W5]
....................                                for (Index2 = 0; (Index2 < DIR_EXTENSION) && (entry->DIR_Extension[(BYTE)Index2] != 0x20); Index2++) 
07A0C:  CLR.B   F91
07A0E:  MOV.B   F91,W0L
07A10:  SE      W0,W0
07A12:  CP      W0,#3
07A14:  BRA     GE,7A4C
07A16:  MOV     #8,W0
07A18:  ADD.B   F91,W0L
07A1A:  ZE      W0,W0
07A1C:  CLR.B   1
07A1E:  MOV     F86,W4
07A20:  ADD     W0,W4,W0
07A22:  MOV.B   [W0],W5L
07A24:  SE      W5,W5
07A26:  MOV     #20,W4
07A28:  CP      W4,W5
07A2A:  BRA     Z,7A4C
....................                                { 
....................                                    tempArray[(BYTE)Index++] = entry->DIR_Extension[(BYTE)Index2]; 
07A2C:  MOV.B   F90,W0L
07A2E:  INC.B   0F90
07A30:  ZE      W0,W0
07A32:  CLR.B   1
07A34:  MOV     #F92,W4
07A36:  ADD     W0,W4,W5
07A38:  MOV     #8,W0
07A3A:  ADD.B   F91,W0L
07A3C:  ZE      W0,W0
07A3E:  CLR.B   1
07A40:  MOV     F86,W4
07A42:  ADD     W0,W4,W0
07A44:  MOV.B   [W0],[W5]
07A46:  INC.B   0F91
07A48:  GOTO    7A0E
....................                                } 
....................                            } 
....................                            tempArray[(BYTE)Index] = 0; 
07A4C:  MOV     F90,W4
07A4E:  CLR.B   9
07A50:  MOV     #F92,W3
07A52:  ADD     W4,W3,W5
07A54:  CLR.B   [W5]
....................                      #ifdef SUPPORT_LFN 
....................                      utfModeFileName = 0; 
....................                      #endif 
....................                      Index = FSchdir(&tempArray[0]); 
07A56:  MOV     #F92,W4
07A58:  MOV     W4,FAE
07A5A:  CALL    651A
07A5E:  MOV.B   W0L,F90
....................                      #ifdef SUPPORT_LFN 
....................                      utfModeFileName = prevUtfModeFileName; 
....................                      #endif 
....................                   } 
....................  
....................                         // Change to the subdirectory 
....................                         if (Index) 
07A60:  CP0.B   F90
07A62:  BRA     Z,7A7C
....................                         { 
....................                             FileObjectCopy (cwdptr, tempCWD); 
07A64:  PUSH    904
07A66:  POP     1002
07A68:  PUSH    F82
07A6A:  POP     1004
07A6C:  CALL    28E2
....................                             FSerrno = CE_DIR_NOT_FOUND; 
07A70:  MOV.B   #C,W0L
07A72:  MOV.B   W0L,857
....................                             return -1; 
07A74:  SETM    0
07A76:  BRA     7EB0
....................                         } 
07A78:  GOTO    7AAE
....................                         else 
....................                         { 
....................                             // Make sure we're not trying to delete the CWD 
....................                             if (cwdptr->dirclus == tempCWD->dirclus) 
07A7C:  MOV     #2E,W0
07A7E:  ADD     904,W0
07A80:  MOV     #A,W4
07A82:  MOV     [W0++],[W4++]
07A84:  MOV     [W0++],[W4++]
07A86:  MOV     #2E,W0
07A88:  ADD     F82,W0
07A8A:  MOV     W0,W4
07A8C:  MOV     #0,W3
07A8E:  MOV     [W4++],[W3++]
07A90:  MOV     [W4++],[W3++]
07A92:  CP      W5,W0
07A94:  BRA     NZ,7AAE
07A96:  CP      W6,W1
07A98:  BRA     NZ,7AAE
....................                             { 
....................                                 FileObjectCopy (cwdptr, tempCWD); 
07A9A:  PUSH    904
07A9C:  POP     1002
07A9E:  PUSH    F82
07AA0:  POP     1004
07AA2:  CALL    28E2
....................                                 FSerrno = CE_INVALID_ARGUMENT; 
07AA6:  MOV.B   #1F,W0L
07AA8:  MOV.B   W0L,857
....................                                 return -1; 
07AAA:  SETM    0
07AAC:  BRA     7EB0
....................                             } 
....................                         } 
....................                         handle = 2; 
07AAE:  MOV     #2,W4
07AB0:  MOV     W4,F88
....................                         recache = TRUE; 
07AB2:  MOV.B   #1,W0L
07AB4:  MOV.B   W0L,861
....................                     } 
07AB6:  GOTO    7B9A
....................                     else 
....................                     { 
....................                   #if defined(SUPPORT_LFN) 
....................                   if(!tempCWD-> utf16LFNlength) 
....................                   #endif 
....................                   { 
....................                            for (Index = 0; Index < 8; Index++) 
07ABA:  CLR.B   F90
07ABC:  MOV.B   F90,W0L
07ABE:  SE      W0,W0
07AC0:  CP      W0,#8
07AC2:  BRA     GE,7AE0
....................                            { 
....................                                fo->name[(BYTE)Index] = entry->DIR_Name[(BYTE)Index]; 
07AC4:  MOV     #1C,W0
07AC6:  ADD.B   F90,W0L
07AC8:  ZE      W0,W0
07ACA:  CLR.B   1
07ACC:  MOV     F84,W4
07ACE:  ADD     W0,W4,W5
07AD0:  MOV     F90,W4
07AD2:  CLR.B   9
07AD4:  MOV     W4,W0
07AD6:  ADD     F86,W0
07AD8:  MOV.B   [W0],[W5]
07ADA:  INC.B   0F90
07ADC:  GOTO    7ABC
....................                            } 
....................  
....................                            for (Index = 0; Index < 3; Index++) 
07AE0:  CLR.B   F90
07AE2:  MOV.B   F90,W0L
07AE4:  SE      W0,W0
07AE6:  CP      W0,#3
07AE8:  BRA     GE,7B0E
....................                            { 
....................                                fo->name[(BYTE)Index + 8] = entry->DIR_Extension[(BYTE)Index]; 
07AEA:  MOV     F90,W4
07AEC:  CLR.B   9
07AEE:  ADD     W4,#8,W4
07AF0:  MOV     W4,W5
07AF2:  ADD     W5,#1C,W5
07AF4:  MOV     W5,W0
07AF6:  MOV     F84,W4
07AF8:  ADD     W0,W4,W6
07AFA:  MOV     #8,W0
07AFC:  ADD.B   F90,W0L
07AFE:  ZE      W0,W0
07B00:  CLR.B   1
07B02:  MOV     F86,W4
07B04:  ADD     W0,W4,W0
07B06:  MOV.B   [W0],[W6]
07B08:  INC.B   0F90
07B0A:  GOTO    7AE2
....................                            } 
....................                   } 
....................  
....................                         fo->dsk = &gDiskData; 
07B0E:  MOV     F84,W4
07B10:  ADD     W4,#0,W4
07B12:  MOV     W4,W0
07B14:  MOV     W0,W5
07B16:  MOV.B   #8,W0L
07B18:  MOV.B   W0L,[W5]
07B1A:  MOV.B   #D,W0L
07B1C:  MOV.B   W0L,[W5+#1]
....................  
....................                         fo->entry = handle; 
07B1E:  MOV     #28,W0
07B20:  ADD     F84,W0
07B22:  MOV     W0,W5
07B24:  MOV     F88,W4
07B26:  MOV     W4,[W5+#0]
....................                         fo->dirclus = cwdptr->dirclus; 
07B28:  MOV     #2E,W0
07B2A:  ADD     F84,W0
07B2C:  MOV     W0,W5
07B2E:  MOV     #2E,W0
07B30:  ADD     904,W0
07B32:  MOV     [W0++],[W5++]
07B34:  MOV     [W0++],[W5++]
....................                         fo->dirccls = cwdptr->dirccls; 
07B36:  MOV     #32,W0
07B38:  ADD     F84,W0
07B3A:  MOV     W0,W5
07B3C:  MOV     #32,W0
07B3E:  ADD     904,W0
07B40:  MOV     [W0++],[W5++]
07B42:  MOV     [W0++],[W5++]
....................                         fo->cluster = 0; 
07B44:  MOV     #2,W0
07B46:  ADD     F84,W0
07B48:  MOV     W0,W5
07B4A:  CLR.B   [W5]
07B4C:  MOV.B   #0,W0L
07B4E:  MOV.B   W0L,[W5+#1]
07B50:  MOV.B   #0,W0L
07B52:  MOV.B   W0L,[W5+#2]
07B54:  MOV.B   #0,W0L
07B56:  MOV.B   W0L,[W5+#3]
....................                         fo->ccls    = 0; 
07B58:  MOV     #6,W0
07B5A:  ADD     F84,W0
07B5C:  MOV     W0,W5
07B5E:  CLR.B   [W5]
07B60:  MOV.B   #0,W0L
07B62:  MOV.B   W0L,[W5+#1]
07B64:  MOV.B   #0,W0L
07B66:  MOV.B   W0L,[W5+#2]
07B68:  MOV.B   #0,W0L
07B6A:  MOV.B   W0L,[W5+#3]
....................  
....................                         if (FILEerase(fo, &handle, TRUE)) 
07B6C:  MOV.B   #1,W0L
07B6E:  MOV.B   W0L,FF4
07B70:  PUSH    F84
07B72:  POP     FF0
07B74:  MOV     #F88,W4
07B76:  MOV     W4,FF2
07B78:  CALL    3BA8
07B7C:  CP0.B   W0L
07B7E:  BRA     Z,7B98
....................                         { 
....................                      #if defined(SUPPORT_LFN) 
....................                      tempCWD-> utf16LFNlength = 0; 
....................                      fo-> utf16LFNlength = 0; 
....................                      #endif 
....................                             FileObjectCopy (cwdptr, tempCWD); 
07B80:  PUSH    904
07B82:  POP     1002
07B84:  PUSH    F82
07B86:  POP     1004
07B88:  CALL    28E2
....................                             FSerrno = CE_ERASE_FAIL; 
07B8C:  MOV.B   #1,W0L
07B8E:  MOV.B   W0L,857
....................                             return -1; 
07B90:  SETM    0
07B92:  BRA     7EB0
....................                         } 
07B94:  GOTO    7B9A
....................                         else 
....................                         { 
....................                             handle++; 
07B98:  INC     0F88
....................                         } 
....................                   #if defined(SUPPORT_LFN) 
....................                   tempCWD-> utf16LFNlength = 0; 
....................                   fo-> utf16LFNlength = 0; 
....................                   #endif 
....................                     } // Check to see if it's a DIR entry 
....................                 }// Check non-dir entry to see if its a valid file 
07B9A:  GOTO    7BA0
....................                 else 
....................                 { 
....................                     handle++; 
07B9E:  INC     0F88
....................                 } 
....................  
....................                 if (recache) 
07BA0:  CP0.B   861
07BA2:  BRA     Z,7BCA
....................                 { 
....................                     recache = FALSE; 
07BA4:  CLR.B   861
....................                     cwdptr->dirccls = cwdptr->dirclus; 
07BA6:  MOV     #32,W0
07BA8:  ADD     904,W0
07BAA:  MOV     W0,W5
07BAC:  MOV     #2E,W0
07BAE:  ADD     904,W0
07BB0:  MOV     [W0++],[W5++]
07BB2:  MOV     [W0++],[W5++]
....................                     entry = Cache_File_Entry (cwdptr, &handle, TRUE); 
07BB4:  MOV.B   #1,W0L
07BB6:  MOV.B   W0L,102C
07BB8:  PUSH    904
07BBA:  POP     1028
07BBC:  MOV     #F88,W4
07BBE:  MOV     W4,102A
07BC0:  CALL    31E4
07BC4:  MOV     W0,F86
....................                 } 
07BC6:  GOTO    7BDA
....................                 else 
....................                 { 
....................                     entry = Cache_File_Entry (cwdptr, &handle, FALSE); 
07BCA:  CLR.B   102C
07BCC:  PUSH    904
07BCE:  POP     1028
07BD0:  MOV     #F88,W4
07BD2:  MOV     W4,102A
07BD4:  CALL    31E4
07BD8:  MOV     W0,F86
....................                 } 
....................  
....................             if (entry == NULL) 
07BDA:  CP0     F86
07BDC:  BRA     NZ,7BF2
....................                 { 
....................                #if defined(SUPPORT_LFN) 
....................                tempCWD-> utf16LFNlength = 0; 
....................                fo-> utf16LFNlength = 0; 
....................                #endif 
....................                     FileObjectCopy (cwdptr, tempCWD); 
07BDE:  PUSH    904
07BE0:  POP     1002
07BE2:  PUSH    F82
07BE4:  POP     1004
07BE6:  CALL    28E2
....................                     FSerrno = CE_BADCACHEREAD; 
07BEA:  MOV.B   #1B,W0L
07BEC:  MOV.B   W0L,857
....................                     return -1; 
07BEE:  SETM    0
07BF0:  BRA     7EB0
....................                 } 
....................             } 
07BF2:  GOTO    7DE6
....................             else 
....................             { 
....................             #if defined(SUPPORT_LFN) 
....................             tempCWD-> utf16LFNlength = 0; 
....................             fo-> utf16LFNlength = 0; 
....................             #endif 
....................  
....................                 // We have reached the end of the directory 
....................                 if (subDirDepth != 0) 
07BF6:  CP0     F8C
07BF8:  BRA     Z,7DE2
....................                 { 
....................                     handle2 = 0; 
07BFA:  CLR     F8A
....................  
....................                     cwdptr->dirccls = cwdptr->dirclus; 
07BFC:  MOV     #32,W0
07BFE:  ADD     904,W0
07C00:  MOV     W0,W5
07C02:  MOV     #2E,W0
07C04:  ADD     904,W0
07C06:  MOV     [W0++],[W5++]
07C08:  MOV     [W0++],[W5++]
....................                     entry = Cache_File_Entry (cwdptr, &handle2, TRUE); 
07C0A:  MOV.B   #1,W0L
07C0C:  MOV.B   W0L,102C
07C0E:  PUSH    904
07C10:  POP     1028
07C12:  MOV     #F8A,W4
07C14:  MOV     W4,102A
07C16:  CALL    31E4
07C1A:  MOV     W0,F86
....................                     if (entry == NULL) 
07C1C:  CP0     F86
07C1E:  BRA     NZ,7C34
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
07C20:  PUSH    904
07C22:  POP     1002
07C24:  PUSH    F82
07C26:  POP     1004
07C28:  CALL    28E2
....................                         FSerrno = CE_BADCACHEREAD; 
07C2C:  MOV.B   #1B,W0L
07C2E:  MOV.B   W0L,857
....................                         return -1; 
07C30:  SETM    0
07C32:  BRA     7EB0
....................                     } 
....................  
....................                     // Get the cluster 
....................                     handle2 = GetFullClusterNumber(entry); // Get complete cluster number. 
07C34:  PUSH    F86
07C36:  POP     102A
07C38:  CALL    34B4
07C3C:  MOV     W0,F8A
....................  
.................... #ifndef __18CXX 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................  
....................         Index3 = FSchdir (".\0.\0\0"); 
....................  
....................    else 
....................  
....................    #endif 
....................         Index3 = FSchdir (".."); 
07C3E:  MOV     #3,W3
07C40:  MOV     #0,W2
07C42:  MOV     #FA0,W1
07C44:  MOV     W3,[W15++]
07C46:  MOV     W2,W0
07C48:  CALL    200
07C4C:  MOV     [--W15],W3
07C4E:  MOV.B   W0L,[W1++]
07C50:  INC     W2,W2
07C52:  DEC     W3,W3
07C54:  BTSS.B  42.1
07C56:  BRA     7C44
07C58:  MOV     #FA0,W4
07C5A:  MOV     W4,FAE
07C5C:  CALL    651A
07C60:  MOV     W0,F8E
....................  
.................... #else 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................  
....................         Index3 = FSchdir (dotdotname1); 
....................  
....................    else 
....................  
....................    #endif 
....................         Index3 = FSchdir (dotdotname); 
....................  
.................... #endif 
....................                     if(Index3) 
07C62:  CP0     F8E
07C64:  BRA     Z,7C7A
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
07C66:  PUSH    904
07C68:  POP     1002
07C6A:  PUSH    F82
07C6C:  POP     1004
07C6E:  CALL    28E2
....................                         FSerrno = CE_DIR_NOT_FOUND; 
07C72:  MOV.B   #C,W0L
07C74:  MOV.B   W0L,857
....................                         return -1; 
07C76:  SETM    0
07C78:  BRA     7EB0
....................                     } 
....................                     // Return to our previous position in this directory 
....................                     handle = 2; 
07C7A:  MOV     #2,W4
07C7C:  MOV     W4,F88
....................                     cwdptr->dirccls = cwdptr->dirclus; 
07C7E:  MOV     #32,W0
07C80:  ADD     904,W0
07C82:  MOV     W0,W5
07C84:  MOV     #2E,W0
07C86:  ADD     904,W0
07C88:  MOV     [W0++],[W5++]
07C8A:  MOV     [W0++],[W5++]
....................                     entry = Cache_File_Entry (cwdptr, &handle, TRUE); 
07C8C:  MOV.B   #1,W0L
07C8E:  MOV.B   W0L,102C
07C90:  PUSH    904
07C92:  POP     1028
07C94:  MOV     #F88,W4
07C96:  MOV     W4,102A
07C98:  CALL    31E4
07C9C:  MOV     W0,F86
....................                     if (entry == NULL) 
07C9E:  CP0     F86
07CA0:  BRA     NZ,7CB6
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
07CA2:  PUSH    904
07CA4:  POP     1002
07CA6:  PUSH    F82
07CA8:  POP     1004
07CAA:  CALL    28E2
....................                         FSerrno = CE_BADCACHEREAD; 
07CAE:  MOV.B   #1B,W0L
07CB0:  MOV.B   W0L,857
....................                         return -1; 
07CB2:  SETM    0
07CB4:  BRA     7EB0
....................                     } 
....................  
....................                     // Get the cluster 
....................                     TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number. 
07CB6:  PUSH    F86
07CB8:  POP     102A
07CBA:  CALL    34B4
07CBE:  MOV     W0,85C
07CC0:  MOV     W1,85E
....................  
....................                     while ((TempClusterCalc != handle2) || 
....................                     ((TempClusterCalc == handle2) && 
....................                     (((unsigned char)entry->DIR_Name[0] == 0xE5) || (entry->DIR_Attr == ATTR_VOLUME)))) 
07CC2:  MOV     85C,W0
07CC4:  CP      F8A
07CC6:  BRA     NZ,7CEA
07CC8:  CP0     85E
07CCA:  BRA     NZ,7CEA
07CCC:  MOV     85C,W0
07CCE:  CP      F8A
07CD0:  BRA     NZ,7D24
07CD2:  CP0     85E
07CD4:  BRA     NZ,7D24
07CD6:  MOV     #0,W0
07CD8:  ADD     F86,W0
07CDA:  MOV.B   [W0],W4L
07CDC:  XOR.B   #E5,W4L
07CDE:  BRA     Z,7CEA
07CE0:  MOV     #B,W0
07CE2:  ADD     F86,W0
07CE4:  MOV.B   [W0],W4L
07CE6:  CP.B    W4L,#8
07CE8:  BRA     NZ,7D24
....................                     { 
....................                         handle++; 
07CEA:  INC     0F88
....................                         entry = Cache_File_Entry (cwdptr, &handle, FALSE); 
07CEC:  CLR.B   102C
07CEE:  PUSH    904
07CF0:  POP     1028
07CF2:  MOV     #F88,W4
07CF4:  MOV     W4,102A
07CF6:  CALL    31E4
07CFA:  MOV     W0,F86
....................                         if (entry == NULL) 
07CFC:  CP0     F86
07CFE:  BRA     NZ,7D14
....................                         { 
....................                             FileObjectCopy (cwdptr, tempCWD); 
07D00:  PUSH    904
07D02:  POP     1002
07D04:  PUSH    F82
07D06:  POP     1004
07D08:  CALL    28E2
....................                             FSerrno = CE_BADCACHEREAD; 
07D0C:  MOV.B   #1B,W0L
07D0E:  MOV.B   W0L,857
....................                             return -1; 
07D10:  SETM    0
07D12:  BRA     7EB0
....................                         } 
....................                         // Get the cluster 
....................                         TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number in a loop. 
07D14:  PUSH    F86
07D16:  POP     102A
07D18:  CALL    34B4
07D1C:  MOV     W0,85C
07D1E:  MOV     W1,85E
07D20:  GOTO    7CC2
....................                     } 
....................  
....................                Index3 = 0; 
07D24:  CLR     F8E
....................                #if defined(SUPPORT_LFN) 
....................                  FileObjectCopy (&cwdTemp, cwdptr); 
....................                prevHandle = handle - 1; 
....................                lfno = (LFN_ENTRY *)Cache_File_Entry (cwdptr, &prevHandle, FALSE); 
....................  
....................  
....................                while((lfno->LFN_Attribute == ATTR_LONG_NAME) && (lfno->LFN_SequenceNo != DIR_DEL) 
....................                      && (lfno->LFN_SequenceNo != DIR_EMPTY)) 
....................                { 
....................                   tempShift.byte.LB = lfno->LFN_Part1[0]; 
....................                   tempShift.byte.HB = lfno->LFN_Part1[1]; 
....................                   tempLFN[Index3++] = tempShift.Val; 
....................                   tempShift.byte.LB = lfno->LFN_Part1[2]; 
....................                   tempShift.byte.HB = lfno->LFN_Part1[3]; 
....................                   tempLFN[Index3++] = tempShift.Val; 
....................                   tempShift.byte.LB = lfno->LFN_Part1[4]; 
....................                   tempShift.byte.HB = lfno->LFN_Part1[5]; 
....................                   tempLFN[Index3++] = tempShift.Val; 
....................                   tempShift.byte.LB = lfno->LFN_Part1[6]; 
....................                   tempShift.byte.HB = lfno->LFN_Part1[7]; 
....................                   tempLFN[Index3++] = tempShift.Val; 
....................                   tempShift.byte.LB = lfno->LFN_Part1[8]; 
....................                   tempShift.byte.HB = lfno->LFN_Part1[9]; 
....................                   tempLFN[Index3++] = tempShift.Val; 
....................  
....................                   tempLFN[Index3++] = lfno->LFN_Part2[0]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part2[1]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part2[2]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part2[3]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part2[4]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part2[5]; 
....................  
....................                   tempLFN[Index3++] = lfno->LFN_Part3[0]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part3[1]; 
....................  
....................                   prevHandle = prevHandle - 1; 
....................                   lfno = (LFN_ENTRY *)Cache_File_Entry (cwdptr, &prevHandle, FALSE); 
....................                } 
....................  
....................                FileObjectCopy (cwdptr, &cwdTemp); 
....................  
....................                #endif 
....................  
....................                if(Index3 == 0) 
07D26:  CP0     F8E
07D28:  BRA     NZ,7D7E
....................                { 
....................                        memset (tempArray, 0x00, 12); 
07D2A:  MOV     #F92,W1
07D2C:  MOV     #0,W2
07D2E:  REPEAT  #B
07D30:  CLR.B   [W1++]
....................                        for (Index = 0; Index < 8; Index++) 
07D32:  CLR.B   F90
07D34:  MOV.B   F90,W0L
07D36:  SE      W0,W0
07D38:  CP      W0,#8
07D3A:  BRA     GE,7D54
....................                        { 
....................                            tempArray[(BYTE)Index] = entry->DIR_Name[(BYTE)Index]; 
07D3C:  MOV     F90,W4
07D3E:  CLR.B   9
07D40:  MOV     #F92,W3
07D42:  ADD     W4,W3,W5
07D44:  MOV     F90,W4
07D46:  CLR.B   9
07D48:  MOV     W4,W0
07D4A:  ADD     F86,W0
07D4C:  MOV.B   [W0],[W5]
07D4E:  INC.B   0F90
07D50:  GOTO    7D34
....................                        } 
....................                        for (Index = 0; Index < 3; Index++) 
07D54:  CLR.B   F90
07D56:  MOV.B   F90,W0L
07D58:  SE      W0,W0
07D5A:  CP      W0,#3
07D5C:  BRA     GE,7D7E
....................                        { 
....................                            tempArray[(BYTE)Index + 8] = entry->DIR_Extension[(BYTE)Index]; 
07D5E:  MOV     F90,W4
07D60:  CLR.B   9
07D62:  ADD     W4,#8,W4
07D64:  MOV     W4,W5
07D66:  MOV     #F92,W4
07D68:  ADD     W5,W4,W6
07D6A:  MOV     #8,W0
07D6C:  ADD.B   F90,W0L
07D6E:  ZE      W0,W0
07D70:  CLR.B   1
07D72:  MOV     F86,W4
07D74:  ADD     W0,W4,W0
07D76:  MOV.B   [W0],[W6]
....................                        } 
....................                   #if defined(SUPPORT_LFN) 
07D78:  INC.B   0F90
07D7A:  GOTO    7D56
....................                   cwdptr->utf16LFNlength = 0; 
....................                   #endif 
....................                } 
....................                #if defined(SUPPORT_LFN) 
....................                else 
....................                { 
....................                   cwdptr->utf16LFNlength = Index3; 
....................  
....................                   for(Index = 12;Index >= 0;Index--) 
....................                   { 
....................                      if((tempLFN[Index3 - Index - 1]) == 0x0000) 
....................                      { 
....................                         cwdptr->utf16LFNlength = Index3 - Index - 1; 
....................                         break; 
....................                      } 
....................                   } 
....................  
....................                   cwdptr->utf16LFNptr = (unsigned short int *)&tempArray[0]; 
....................                } 
....................                #endif 
....................                     // Erase the directory that we just cleared the subdirectories out of 
....................  
....................                     if (eraseDir (&tempArray[0])) 
07D7E:  MOV     #F92,W4
07D80:  MOV     W4,FAE
07D82:  CALL    7744
07D86:  CP0     W0
07D88:  BRA     Z,7DA2
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
07D8A:  PUSH    904
07D8C:  POP     1002
07D8E:  PUSH    F82
07D90:  POP     1004
07D92:  CALL    28E2
....................                         FSerrno = CE_ERASE_FAIL; 
07D96:  MOV.B   #1,W0L
07D98:  MOV.B   W0L,857
....................                         return -1; 
07D9A:  SETM    0
07D9C:  BRA     7EB0
....................                     } 
07D9E:  GOTO    7DDC
....................                     else 
....................                     { 
....................                         handle++; 
07DA2:  INC     0F88
....................                         cwdptr->dirccls = cwdptr->dirclus; 
07DA4:  MOV     #32,W0
07DA6:  ADD     904,W0
07DA8:  MOV     W0,W5
07DAA:  MOV     #2E,W0
07DAC:  ADD     904,W0
07DAE:  MOV     [W0++],[W5++]
07DB0:  MOV     [W0++],[W5++]
....................                         entry = Cache_File_Entry (cwdptr, &handle, TRUE); 
07DB2:  MOV.B   #1,W0L
07DB4:  MOV.B   W0L,102C
07DB6:  PUSH    904
07DB8:  POP     1028
07DBA:  MOV     #F88,W4
07DBC:  MOV     W4,102A
07DBE:  CALL    31E4
07DC2:  MOV     W0,F86
....................                         if (entry == NULL) 
07DC4:  CP0     F86
07DC6:  BRA     NZ,7DDC
....................                         { 
....................                             FileObjectCopy (cwdptr, tempCWD); 
07DC8:  PUSH    904
07DCA:  POP     1002
07DCC:  PUSH    F82
07DCE:  POP     1004
07DD0:  CALL    28E2
....................                             FSerrno = CE_BADCACHEREAD; 
07DD4:  MOV.B   #1B,W0L
07DD6:  MOV.B   W0L,857
....................                             return -1; 
07DD8:  SETM    0
07DDA:  BRA     7EB0
....................                         } 
....................                     } 
....................  
....................                     // Decrease the subdirectory depth 
....................                     subDirDepth--; 
07DDC:  DEC     0F8C
....................                 } 
07DDE:  GOTO    7DE6
....................                 else 
....................                 { 
....................                     dirCleared = TRUE; 
07DE2:  MOV.B   #1,W0L
07DE4:  MOV.B   W0L,860
....................                 } // Check subdirectory depth 
....................             } // Check until we get an empty entry 
07DE6:  GOTO    7964
....................         } // Loop until the whole dir is cleared 
....................     } 
....................  
....................     // Cache the current directory name 
....................     // tempArray is used so we don't disturb the 
....................     // global getcwd buffer 
....................     if (FSgetcwd (&tempArray[0], 2) == NULL) 
07DEA:  MOV     #F92,W4
07DEC:  MOV     W4,FB6
07DEE:  MOV     #2,W4
07DF0:  MOV     W4,FB8
07DF2:  CALL    55BA
07DF6:  MOV     W0,W5
07DF8:  CP0     W5
07DFA:  BRA     NZ,7E10
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
07DFC:  PUSH    904
07DFE:  POP     1002
07E00:  PUSH    F82
07E02:  POP     1004
07E04:  CALL    28E2
....................         return -1; 
07E08:  SETM    0
07E0A:  BRA     7EB0
....................     } 
07E0C:  GOTO    7E3E
....................    else 
....................    { 
....................       #if defined(SUPPORT_LFN) 
....................          if(!cwdptr->utf16LFNlength) 
....................       #endif 
....................          { 
....................               memset (tempArray, 0x00, 12); 
07E10:  MOV     #F92,W1
07E12:  MOV     #0,W2
07E14:  REPEAT  #B
07E16:  CLR.B   [W1++]
....................               for (Index = 0; Index < 11; Index++) 
07E18:  CLR.B   F90
07E1A:  MOV.B   F90,W0L
07E1C:  SE      W0,W0
07E1E:  CP      W0,#B
07E20:  BRA     GE,7E3E
....................               { 
....................                   tempArray[(BYTE)Index] = cwdptr->name[(BYTE)Index]; 
07E22:  MOV     F90,W4
07E24:  CLR.B   9
07E26:  MOV     #F92,W3
07E28:  ADD     W4,W3,W5
07E2A:  MOV     #1C,W0
07E2C:  ADD.B   F90,W0L
07E2E:  ZE      W0,W0
07E30:  CLR.B   1
07E32:  MOV     904,W4
07E34:  ADD     W0,W4,W0
07E36:  MOV.B   [W0],[W5]
07E38:  INC.B   0F90
07E3A:  GOTO    7E1A
....................               } 
....................          } 
....................    } 
....................  
....................     // If we're here, this directory is empty 
.................... #ifndef __18CXX 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................  
....................         Index3 = FSchdir (".\0.\0\0"); 
....................  
....................    else 
....................  
....................    #endif 
....................         Index3 = FSchdir (".."); 
07E3E:  MOV     #3,W3
07E40:  MOV     #0,W2
07E42:  MOV     #FA4,W1
07E44:  MOV     W3,[W15++]
07E46:  MOV     W2,W0
07E48:  CALL    200
07E4C:  MOV     [--W15],W3
07E4E:  MOV.B   W0L,[W1++]
07E50:  INC     W2,W2
07E52:  DEC     W3,W3
07E54:  BTSS.B  42.1
07E56:  BRA     7E44
07E58:  MOV     #FA4,W4
07E5A:  MOV     W4,FAE
07E5C:  CALL    651A
07E60:  MOV     W0,F8E
....................  
.................... #else 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................  
....................         Index3 = FSchdir (dotdotname1); 
....................  
....................    else 
....................  
....................    #endif 
....................         Index3 = FSchdir (dotdotname); 
....................  
.................... #endif 
....................     if(Index3) 
07E62:  CP0     F8E
07E64:  BRA     Z,7E7A
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
07E66:  PUSH    904
07E68:  POP     1002
07E6A:  PUSH    F82
07E6C:  POP     1004
07E6E:  CALL    28E2
....................         FSerrno = CE_DIR_NOT_FOUND; 
07E72:  MOV.B   #C,W0L
07E74:  MOV.B   W0L,857
....................         return -1; 
07E76:  SETM    0
07E78:  BRA     7EB0
....................     } 
....................  
....................    #if defined(SUPPORT_LFN) 
....................    if(cwdptr->utf16LFNlength) 
....................    { 
....................       Index3 = eraseDir((char *)cwdptr->utf16LFNptr); 
....................    } 
....................    else 
....................    #endif 
....................    { 
....................       Index3 = eraseDir(tempArray); 
07E7A:  MOV     #F92,W4
07E7C:  MOV     W4,FAE
07E7E:  CALL    7744
07E82:  MOV     W0,F8E
....................    } 
....................  
....................     if (Index3) 
07E84:  CP0     F8E
07E86:  BRA     Z,7EA0
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
07E88:  PUSH    904
07E8A:  POP     1002
07E8C:  PUSH    F82
07E8E:  POP     1004
07E90:  CALL    28E2
....................         FSerrno = CE_ERASE_FAIL; 
07E94:  MOV.B   #1,W0L
07E96:  MOV.B   W0L,857
....................         return -1; 
07E98:  SETM    0
07E9A:  BRA     7EB0
....................     } 
07E9C:  GOTO    7EB0
....................     else 
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
07EA0:  PUSH    904
07EA2:  POP     1002
07EA4:  PUSH    F82
07EA6:  POP     1004
07EA8:  CALL    28E2
....................         return 0; 
07EAC:  CLR     0
07EAE:  BRA     7EB0
....................     } 
07EB0:  MOV     [--W15],W6
07EB2:  MOV     [--W15],W5
07EB4:  RETURN  
.................... } 
....................  
....................  
.................... /**************************************************************** 
....................   Function: 
....................     int eraseDir (char * path) 
....................   Summary: 
....................     FSrmdir helper function to erase dirs 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     path -  The name of the directory to delete 
....................   Return Values: 
....................     0 -  Dir was deleted successfully 
....................     -1 - Dir could not be deleted. 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The eraseDir function is a helper function for the rmdirhelper 
....................     function.  The eraseDir function will search for the 
....................     directory that matches the specified path name and then erase 
....................     it with the FILEerase function. 
....................   Remarks: 
....................     None. 
....................   *****************************************************************/ 
....................  
.................... int eraseDir (char * path) 
*
07744:  MOV     W5,[W15++]
.................... { 
....................     int result; 
07746:  CLR     FB0
....................     BYTE Index; 
07748:  CLR.B   FB2
....................     FSFILE tempCWDobj2; 
0774A:  CLR     FB4
0774C:  CLR     FB6
0774E:  CLR     FB8
07750:  CLR     FBA
07752:  CLR     FBC
07754:  CLR     FBE
07756:  CLR     FC0
07758:  CLR     FC2
0775A:  CLR     FC4
0775C:  CLR     FC6
0775E:  CLR     FC8
07760:  CLR     FCA
07762:  CLR     FCC
07764:  CLR     FCE
07766:  CLR     FD0
07768:  CLR     FD2
0776A:  CLR     FD4
0776C:  CLR     FD6
0776E:  CLR     FD8
07770:  CLR     FDA
07772:  CLR     FDC
07774:  CLR     FDE
07776:  CLR     FE0
07778:  CLR     FE2
0777A:  CLR     FE4
0777C:  CLR     FE6
0777E:  CLR     FE8
....................  
....................     if (MDD_WriteProtectState()) 
07780:  CALL    25A0
07784:  CP0.B   W0L
07786:  BRA     Z,778C
....................     { 
....................         return (-1); 
07788:  SETM    0
0778A:  BRA     7814
....................     } 
....................  
....................     // preserve CWD 
....................     FileObjectCopy(&tempCWDobj2, cwdptr); 
0778C:  MOV     #FB4,W4
0778E:  MOV     W4,1002
07790:  PUSH    904
07792:  POP     1004
07794:  CALL    28E2
....................  
....................    // If long file name not present, copy the 8.3 name in cwdptr 
....................    #if defined(SUPPORT_LFN) 
....................     if(!cwdptr->utf16LFNlength) 
....................    #endif 
....................     { 
....................        for (Index = 0; Index <11; Index++) 
07798:  CLR.B   FB2
0779A:  MOV     FB2,W4
0779C:  CP.B    W4L,#B
0779E:  BRA     C,77BC
....................        { 
....................            cwdptr->name[Index] = *(path + Index); 
077A0:  MOV     #1C,W0
077A2:  ADD.B   FB2,W0L
077A4:  ZE      W0,W0
077A6:  CLR.B   1
077A8:  MOV     904,W4
077AA:  ADD     W0,W4,W5
077AC:  MOV     FB2,W4
077AE:  CLR.B   9
077B0:  MOV     FAE,W3
077B2:  ADD     W3,W4,W0
077B4:  MOV.B   [W0],[W5]
077B6:  INC.B   0FB2
077B8:  GOTO    779A
....................        } 
....................    } 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&gFileTemp, cwdptr); 
077BC:  MOV     #898,W4
077BE:  MOV     W4,1002
077C0:  PUSH    904
077C2:  POP     1004
077C4:  CALL    28E2
....................  
....................     // See if the file is found 
....................    if(FILEfind (cwdptr, &gFileTemp, LOOK_FOR_MATCHING_ENTRY, 0) == CE_GOOD) 
077C8:  MOV.B   #1,W0L
077CA:  MOV.B   W0L,1006
077CC:  CLR.B   1007
077CE:  PUSH    904
077D0:  POP     1002
077D2:  MOV     #898,W4
077D4:  MOV     W4,1004
077D6:  CALL    36BE
077DA:  CP0.B   W0L
077DC:  BRA     NZ,7802
....................    { 
....................       if(FILEerase(cwdptr, &cwdptr->entry, TRUE) == CE_GOOD) 
077DE:  MOV     #28,W0
077E0:  ADD     904,W0
077E2:  MOV     W0,W5
077E4:  MOV.B   #1,W0L
077E6:  MOV.B   W0L,FF4
077E8:  PUSH    904
077EA:  POP     FF0
077EC:  MOV     W5,FF2
077EE:  CALL    3BA8
077F2:  CP0.B   W0L
077F4:  BRA     NZ,77FC
....................          result = 0; 
077F6:  CLR     FB0
077F8:  GOTO    77FE
....................       else 
....................          result = -1; 
077FC:  SETM    FB0
....................    } 
077FE:  GOTO    7804
....................    else 
....................       result = -1; 
07802:  SETM    FB0
....................  
....................    FileObjectCopy(cwdptr, &tempCWDobj2); 
07804:  PUSH    904
07806:  POP     1002
07808:  MOV     #FB4,W4
0780A:  MOV     W4,1004
0780C:  CALL    28E2
....................    return(result); 
07810:  PUSH    FB0
07812:  POP     0
07814:  MOV     [--W15],W5
07816:  RETURN  
.................... } 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_FILESEARCH 
....................  
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................     The FindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the 
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was 
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec) 
*
0656E:  MOV     W5,[W15++]
06570:  MOV     W6,[W15++]
06572:  MOV     W7,[W15++]
*
065AA:  MOV     #FBE,W4
065AC:  MOV     W4,FF4
.................... { 
....................     FSFILE f; 
*
06574:  CLR     FBE
06576:  CLR     FC0
06578:  CLR     FC2
0657A:  CLR     FC4
0657C:  CLR     FC6
0657E:  CLR     FC8
06580:  CLR     FCA
06582:  CLR     FCC
06584:  CLR     FCE
06586:  CLR     FD0
06588:  CLR     FD2
0658A:  CLR     FD4
0658C:  CLR     FD6
0658E:  CLR     FD8
06590:  CLR     FDA
06592:  CLR     FDC
06594:  CLR     FDE
06596:  CLR     FE0
06598:  CLR     FE2
0659A:  CLR     FE4
0659C:  CLR     FE6
0659E:  CLR     FE8
065A0:  CLR     FEA
065A2:  CLR     FEC
065A4:  CLR     FEE
065A6:  CLR     FF0
065A8:  CLR     FF2
....................     FILEOBJ fo = &f; 
....................     WORD fHandle; 
*
065AE:  CLR     FF6
....................     BYTE j; 
065B0:  CLR.B   FF8
....................     BYTE Index; 
065B2:  CLR.B   FF9
....................    #ifdef SUPPORT_LFN 
....................       short int indexLFN; 
....................    #endif 
....................  
....................     FSerrno = CE_GOOD; 
065B4:  CLR.B   857
....................  
....................    #ifdef SUPPORT_LFN 
....................       fo->utf16LFNptr = &recordSearchName[0]; 
....................       rec->utf16LFNfound = &recordFoundName[0]; 
....................    #endif 
....................  
....................    // Format the file name as per 8.3 format or LFN format 
....................     if( !FormatFileName(fileName, fo, 1) ) 
065B6:  MOV.B   #1,W0L
065B8:  MOV.B   W0L,1004
065BA:  PUSH    FB8
065BC:  POP     1000
065BE:  PUSH    FF4
065C0:  POP     1002
065C2:  CALL    26EC
065C6:  CP0.B   W0L
065C8:  BRA     NZ,65D2
....................     { 
....................         FSerrno = CE_INVALID_FILENAME; 
065CA:  MOV.B   #12,W0L
065CC:  MOV.B   W0L,857
....................         return -1; 
065CE:  SETM    0
065D0:  BRA     6848
....................     } 
....................  
....................     rec->initialized = FALSE; 
065D2:  MOV     #2A,W0
065D4:  ADD     FBC,W0
065D6:  MOV     W0,W5
065D8:  CLR.B   [W5]
....................  
....................    #if defined(SUPPORT_LFN) 
....................    rec->AsciiEncodingType = fo->AsciiEncodingType; 
....................    recordSearchLength = fo->utf16LFNlength; 
....................  
....................    // If file name is 8.3 format copy it in 'searchname' string 
....................     if(!recordSearchLength) 
....................    #endif 
....................     { 
....................        for (Index = 0; (Index < 12) && (fileName[Index] != 0); Index++) 
065DA:  CLR.B   FF9
065DC:  MOV     FF8,W4
065DE:  LSR     W4,#8,W4
065E0:  CP.B    W4L,#C
065E2:  BRA     C,6610
065E4:  MOV     FF8,W4
065E6:  LSR     W4,#8,W4
065E8:  MOV     W4,W0
065EA:  ADD     FB8,W0
065EC:  MOV.B   [W0],W5L
065EE:  SE      W5,W5
065F0:  CP0     W5
065F2:  BRA     Z,6610
....................        { 
....................            rec->searchname[Index] = fileName[Index]; 
065F4:  MOV     #18,W0
065F6:  ADD.B   FF9,W0L
065F8:  ZE      W0,W0
065FA:  CLR.B   1
065FC:  MOV     FBC,W4
065FE:  ADD     W0,W4,W5
06600:  MOV     FF8,W4
06602:  LSR     W4,#8,W4
06604:  MOV     W4,W0
06606:  ADD     FB8,W0
06608:  MOV.B   [W0],[W5]
0660A:  INC.B   0FF9
0660C:  GOTO    65DC
....................        } 
....................  
....................        for (;Index < FILE_NAME_SIZE_8P3 + 2; Index++) 
06610:  MOV     FF8,W4
06612:  LSR     W4,#8,W4
06614:  CP.B    W4L,#D
06616:  BRA     C,662C
....................        { 
....................            rec->searchname[Index] = 0; 
06618:  MOV     #18,W0
0661A:  ADD.B   FF9,W0L
0661C:  ZE      W0,W0
0661E:  CLR.B   1
06620:  MOV     FBC,W4
06622:  ADD     W0,W4,W5
06624:  CLR.B   [W5]
06626:  INC.B   0FF9
06628:  GOTO    6610
....................        } 
....................    } 
....................  
....................     rec->searchattr = attr; 
0662C:  MOV     #25,W0
0662E:  ADD     FBC,W0
06630:  MOV     W0,W5
06632:  MOV     FBA,W0
06634:  MOV.B   W0L,[W5+#0]
.................... #ifdef ALLOW_DIRS 
....................     rec->cwdclus = cwdptr->dirclus; 
06636:  MOV     #26,W0
06638:  ADD     FBC,W0
0663A:  MOV     W0,W5
0663C:  MOV     #2E,W0
0663E:  ADD     904,W0
06640:  MOV     [W0++],[W5++]
06642:  MOV     [W0++],[W5++]
.................... #else 
....................     rec->cwdclus = FatRootDirClusterValue; 
.................... #endif 
....................  
....................     fo->dsk = &gDiskData; 
06644:  MOV     FF4,W4
06646:  ADD     W4,#0,W4
06648:  MOV     W4,W0
0664A:  MOV     W0,W5
0664C:  MOV.B   #8,W0L
0664E:  MOV.B   W0L,[W5]
06650:  MOV.B   #D,W0L
06652:  MOV.B   W0L,[W5+#1]
....................     fo->cluster = 0; 
06654:  MOV     #2,W0
06656:  ADD     FF4,W0
06658:  MOV     W0,W5
0665A:  CLR.B   [W5]
0665C:  MOV.B   #0,W0L
0665E:  MOV.B   W0L,[W5+#1]
06660:  MOV.B   #0,W0L
06662:  MOV.B   W0L,[W5+#2]
06664:  MOV.B   #0,W0L
06666:  MOV.B   W0L,[W5+#3]
....................     fo->ccls    = 0; 
06668:  MOV     #6,W0
0666A:  ADD     FF4,W0
0666C:  MOV     W0,W5
0666E:  CLR.B   [W5]
06670:  MOV.B   #0,W0L
06672:  MOV.B   W0L,[W5+#1]
06674:  MOV.B   #0,W0L
06676:  MOV.B   W0L,[W5+#2]
06678:  MOV.B   #0,W0L
0667A:  MOV.B   W0L,[W5+#3]
....................     fo->entry = 0; 
0667C:  MOV     #28,W0
0667E:  ADD     FF4,W0
06680:  MOV     W0,W5
06682:  CLR.B   [W5]
06684:  MOV.B   #0,W0L
06686:  MOV.B   W0L,[W5+#1]
....................     fo->attributes = attr; 
06688:  MOV     #2C,W0
0668A:  ADD     FF4,W0
0668C:  MOV     W0,W5
0668E:  MOV     FBA,W4
06690:  MOV     W4,[W5+#0]
....................  
.................... #ifndef ALLOW_DIRS 
....................     // start at the root directory 
....................     fo->dirclus    = FatRootDirClusterValue; 
....................     fo->dirccls    = FatRootDirClusterValue; 
.................... #else 
....................     fo->dirclus = cwdptr->dirclus; 
06692:  MOV     #2E,W0
06694:  ADD     FF4,W0
06696:  MOV     W0,W5
06698:  MOV     #2E,W0
0669A:  ADD     904,W0
0669C:  MOV     [W0++],[W5++]
0669E:  MOV     [W0++],[W5++]
....................     fo->dirccls = cwdptr->dirccls; 
066A0:  MOV     #32,W0
066A2:  ADD     FF4,W0
066A4:  MOV     W0,W5
066A6:  MOV     #32,W0
066A8:  ADD     904,W0
066AA:  MOV     [W0++],[W5++]
066AC:  MOV     [W0++],[W5++]
.................... #endif 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&gFileTemp, fo); 
066AE:  MOV     #898,W4
066B0:  MOV     W4,1002
066B2:  PUSH    FF4
066B4:  POP     1004
066B6:  CALL    28E2
....................  
....................     // See if the file is found 
....................     if (FILEfind (fo, &gFileTemp,LOOK_FOR_MATCHING_ENTRY, 1) != CE_GOOD) 
066BA:  MOV.B   #1,W0L
066BC:  MOV.B   W0L,1006
066BE:  MOV.B   #1,W0L
066C0:  MOV.B   W0L,1007
066C2:  PUSH    FF4
066C4:  POP     1002
066C6:  MOV     #898,W4
066C8:  MOV     W4,1004
066CA:  CALL    36BE
066CE:  CP0.B   W0L
066D0:  BRA     Z,66DA
....................     { 
....................         FSerrno = CE_FILE_NOT_FOUND; 
066D2:  MOV.B   #B,W0L
066D4:  MOV.B   W0L,857
....................         return -1; 
066D6:  SETM    0
066D8:  BRA     6848
....................     } 
....................  
....................     fHandle = fo->entry; 
066DA:  MOV     #28,W0
066DC:  ADD     FF4,W0
066DE:  MOV     [W0],[W15++]
066E0:  POP     FF6
....................  
....................     if (FILEopen (fo, &fHandle, 'r') == CE_GOOD) 
066E2:  MOV.B   #72,W0L
066E4:  MOV.B   W0L,1004
066E6:  PUSH    FF4
066E8:  POP     1000
066EA:  MOV     #FF6,W4
066EC:  MOV     W4,1002
066EE:  CALL    4454
066F2:  CP0.B   W0L
066F4:  BRA     NZ,6840
....................     { 
....................       #if defined(SUPPORT_LFN) 
....................       rec->utf16LFNfoundLength = fo->utf16LFNlength; 
....................       if(fo->utf16LFNlength) 
....................       { 
....................          indexLFN = fo->utf16LFNlength; 
....................          recordFoundName[indexLFN] = 0x0000; 
....................          while(indexLFN--) 
....................             recordFoundName[indexLFN] = fileFoundString[indexLFN]; 
....................       } 
....................       #endif 
....................  
....................       for(j = 0; j < FILE_NAME_SIZE_8P3 + 2 ; j++) 
066F6:  CLR.B   FF8
066F8:  MOV     FF8,W4
066FA:  CP.B    W4L,#D
066FC:  BRA     C,6710
....................       { 
....................             rec->filename[j] = 0; 
066FE:  MOV     FF8,W4
06700:  CLR.B   9
06702:  MOV     W4,W0
06704:  ADD     FBC,W0
06706:  MOV     W0,W5
06708:  CLR.B   [W5]
0670A:  INC.B   0FF8
0670C:  GOTO    66F8
....................       } 
....................  
....................         // Copy as much name as there is 
....................         if (fo->attributes != ATTR_VOLUME) 
06710:  MOV     #2C,W0
06712:  ADD     FF4,W0
06714:  MOV     [W0],W5
06716:  CP      W5,#8
06718:  BRA     Z,67C0
....................         { 
....................             for (Index = 0, j = 0; (j < 8) && (fo->name[j] != 0x20); Index++, j++) 
0671A:  CLR.B   FF9
0671C:  CLR.B   FF8
0671E:  MOV     FF8,W4
06720:  CP.B    W4L,#8
06722:  BRA     C,675C
06724:  MOV     #1C,W0
06726:  ADD.B   FF8,W0L
06728:  ZE      W0,W0
0672A:  CLR.B   1
0672C:  MOV     FF4,W4
0672E:  ADD     W0,W4,W0
06730:  MOV.B   [W0],W5L
06732:  SE      W5,W5
06734:  MOV     #20,W4
06736:  CP      W4,W5
06738:  BRA     Z,675C
....................             { 
....................                rec->filename[Index] = fo->name[j]; 
0673A:  MOV     FF8,W4
0673C:  LSR     W4,#8,W4
0673E:  MOV     W4,W0
06740:  ADD     FBC,W0
06742:  MOV     W0,W5
06744:  MOV     #1C,W0
06746:  ADD.B   FF8,W0L
06748:  ZE      W0,W0
0674A:  CLR.B   1
0674C:  MOV     FF4,W4
0674E:  ADD     W0,W4,W0
06750:  MOV.B   [W0],[W5]
06752:  MOV.B   FF9,W0L
06754:  INC.B   0FF9
06756:  INC.B   0FF8
06758:  GOTO    671E
....................             } 
....................  
....................          if(fo->name[8] != 0x20) 
0675C:  MOV     #24,W0
0675E:  ADD     FF4,W0
06760:  MOV.B   [W0],W5L
06762:  SE      W5,W5
06764:  MOV     #20,W4
06766:  CP      W4,W5
06768:  BRA     Z,67BC
....................          { 
....................                rec->filename[Index++] = '.'; 
0676A:  MOV.B   FF9,W0L
0676C:  INC.B   0FF9
0676E:  ZE      W0,W0
06770:  CLR.B   1
06772:  MOV     FBC,W4
06774:  ADD     W0,W4,W5
06776:  MOV.B   #2E,W0L
06778:  MOV.B   W0L,[W5]
....................  
....................                // Move to the extension, even if there are more space chars 
....................                for (j = 8; (j < 11) && (fo->name[j] != 0x20); Index++, j++) 
0677A:  MOV.B   #8,W0L
0677C:  MOV.B   W0L,FF8
0677E:  MOV     FF8,W4
06780:  CP.B    W4L,#B
06782:  BRA     C,67BC
06784:  MOV     #1C,W0
06786:  ADD.B   FF8,W0L
06788:  ZE      W0,W0
0678A:  CLR.B   1
0678C:  MOV     FF4,W4
0678E:  ADD     W0,W4,W0
06790:  MOV.B   [W0],W5L
06792:  SE      W5,W5
06794:  MOV     #20,W4
06796:  CP      W4,W5
06798:  BRA     Z,67BC
....................                { 
....................                   rec->filename[Index] = fo->name[j]; 
0679A:  MOV     FF8,W4
0679C:  LSR     W4,#8,W4
0679E:  MOV     W4,W0
067A0:  ADD     FBC,W0
067A2:  MOV     W0,W5
067A4:  MOV     #1C,W0
067A6:  ADD.B   FF8,W0L
067A8:  ZE      W0,W0
067AA:  CLR.B   1
067AC:  MOV     FF4,W4
067AE:  ADD     W0,W4,W0
067B0:  MOV.B   [W0],[W5]
067B2:  MOV.B   FF9,W0L
067B4:  INC.B   0FF9
067B6:  INC.B   0FF8
067B8:  GOTO    677E
....................                } 
....................          } 
....................         } 
067BC:  GOTO    67E8
....................         else 
....................         { 
....................             for (Index = 0; Index < DIR_NAMECOMP; Index++) 
067C0:  CLR.B   FF9
067C2:  MOV     FF8,W4
067C4:  LSR     W4,#8,W4
067C6:  CP.B    W4L,#B
067C8:  BRA     C,67E8
....................             { 
....................                 rec->filename[Index] = fo->name[Index]; 
067CA:  MOV     FF8,W4
067CC:  LSR     W4,#8,W4
067CE:  MOV     W4,W0
067D0:  ADD     FBC,W0
067D2:  MOV     W0,W5
067D4:  MOV     #1C,W0
067D6:  ADD.B   FF9,W0L
067D8:  ZE      W0,W0
067DA:  CLR.B   1
067DC:  MOV     FF4,W4
067DE:  ADD     W0,W4,W0
067E0:  MOV.B   [W0],[W5]
067E2:  INC.B   0FF9
067E4:  GOTO    67C2
....................             } 
....................         } 
....................  
....................         rec->attributes = fo->attributes; 
067E8:  MOV     #D,W0
067EA:  ADD     FBC,W0
067EC:  MOV     W0,W5
067EE:  MOV     #2C,W0
067F0:  ADD     FF4,W0
067F2:  MOV.B   [W0],[W5]
....................         rec->filesize = fo->size; 
067F4:  MOV     #E,W0
067F6:  ADD     FBC,W0
067F8:  MOV     W0,W5
067FA:  MOV     #12,W0
067FC:  ADD     FF4,W0
067FE:  MOV     [W0++],[W5++]
06800:  MOV     [W0++],[W5++]
....................         rec->timestamp = (DWORD)((DWORD)fo->date << 16) + fo->time; 
06802:  MOV     #12,W0
06804:  ADD     FBC,W0
06806:  MOV     W0,W5
06808:  MOV     #1A,W0
0680A:  ADD     FF4,W0
0680C:  MOV     [W0],W6
0680E:  MOV     #0,W7
06810:  MOV     W6,W7
06812:  MOV     #0,W6
06814:  MOV     #18,W0
06816:  ADD     FF4,W0
06818:  MOV     W0,W4
0681A:  MOV     [W4],W0
0681C:  ADD     W0,W6,[W5]
0681E:  MOV     #0,W4
06820:  ADDC    W4,W7,[++W5]
....................         rec->entry = fo->entry; 
06822:  MOV     #16,W0
06824:  ADD     FBC,W0
06826:  MOV     W0,W5
06828:  MOV     #28,W0
0682A:  ADD     FF4,W0
0682C:  MOV     [W0],[W5]
....................         rec->initialized = TRUE; 
0682E:  MOV     #2A,W0
06830:  ADD     FBC,W0
06832:  MOV     W0,W5
06834:  MOV.B   #1,W0L
06836:  MOV.B   W0L,[W5]
....................  
....................  
....................        #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" FINDFirst foCompareTo="); 
....................          PrintRAMBytesUART(((unsigned char*)fo->name), 13); 
....................          PrintROMASCIIStringUART(" FINDFirst recSearchname="); 
....................          PrintRAMBytesUART(((unsigned char*)rec->searchname), 13);          
....................          PrintROMASCIIStringUART(" FINDFirst gTempCompareTo="); 
....................          PrintRAMBytesUART(((unsigned char*)gFileTemp.name), 13); 
....................         #endif 
....................  
....................         return 0; 
06838:  CLR     0
0683A:  BRA     6848
....................     } 
0683C:  GOTO    6848
....................     else 
....................     { 
....................         FSerrno = CE_BADCACHEREAD; 
06840:  MOV.B   #1B,W0L
06842:  MOV.B   W0L,857
....................         return -1; 
06844:  SETM    0
06846:  BRA     6848
....................     } 
06848:  MOV     [--W15],W7
0684A:  MOV     [--W15],W6
0684C:  MOV     [--W15],W5
0684E:  RETURN  
.................... } 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FindNext (SearchRec * rec) 
....................   Summary: 
....................     Sequential search function 
....................   Conditions: 
....................     None 
....................   Input: 
....................     rec -  The structure to store the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No additional files matching the specified criteria were found 
....................   Side Effects: 
....................     Search criteria from previous FindNext call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     The FindNext function performs the same function as the FindFirst 
....................     funciton, except it does not copy any search parameters into the 
....................     SearchRec structure (only info about found files) and it begins 
....................     searching at the last directory entry offset at which a file was 
....................     found, rather than at the beginning of the current working 
....................     directory.If the return value of the function is 0 then "utf16LFNfoundLength" 
....................     indicates whether the file found was long file name or short file 
....................     name(8P3 format). The "utf16LFNfoundLength" is non-zero for long file name 
....................     and is zero for 8P3 format."utf16LFNfound" points to the address of long 
....................     file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling this function 
....................   **********************************************************************/ 
....................  
.................... int FindNext (SearchRec * rec) 
06850:  MOV     W5,[W15++]
06852:  MOV     W6,[W15++]
06854:  MOV     W7,[W15++]
*
0688C:  MOV     #FBA,W4
0688E:  MOV     W4,FF0
.................... { 
....................     FSFILE f; 
*
06856:  CLR     FBA
06858:  CLR     FBC
0685A:  CLR     FBE
0685C:  CLR     FC0
0685E:  CLR     FC2
06860:  CLR     FC4
06862:  CLR     FC6
06864:  CLR     FC8
06866:  CLR     FCA
06868:  CLR     FCC
0686A:  CLR     FCE
0686C:  CLR     FD0
0686E:  CLR     FD2
06870:  CLR     FD4
06872:  CLR     FD6
06874:  CLR     FD8
06876:  CLR     FDA
06878:  CLR     FDC
0687A:  CLR     FDE
0687C:  CLR     FE0
0687E:  CLR     FE2
06880:  CLR     FE4
06882:  CLR     FE6
06884:  CLR     FE8
06886:  CLR     FEA
06888:  CLR     FEC
0688A:  CLR     FEE
....................     FILEOBJ fo = &f; 
....................     BYTE i, j; 
*
06890:  CLR.B   FF2
06892:  CLR.B   FF3
....................    #ifdef SUPPORT_LFN 
....................       short int indexLFN; 
....................    #endif 
....................  
....................     FSerrno = CE_GOOD; 
06894:  CLR.B   857
....................  
....................     // Make sure we called FindFirst on this object 
....................     if (rec->initialized == FALSE) 
06896:  MOV     #2A,W0
06898:  ADD     FB8,W0
0689A:  CP0.B   [W0]
0689C:  BRA     NZ,68A6
....................     { 
....................         FSerrno = CE_NOT_INIT; 
0689E:  MOV.B   #7,W0L
068A0:  MOV.B   W0L,857
....................         return -1; 
068A2:  SETM    0
068A4:  BRA     6AD0
....................     } 
....................  
....................     // Make sure we called FindFirst in the cwd 
.................... #ifdef ALLOW_DIRS 
....................     if (rec->cwdclus != cwdptr->dirclus) 
068A6:  MOV     #26,W0
068A8:  ADD     FB8,W0
068AA:  MOV     #A,W4
068AC:  MOV     [W0++],[W4++]
068AE:  MOV     [W0++],[W4++]
068B0:  MOV     #2E,W0
068B2:  ADD     904,W0
068B4:  MOV     W0,W4
068B6:  MOV     #0,W3
068B8:  MOV     [W4++],[W3++]
068BA:  MOV     [W4++],[W3++]
068BC:  CP      W5,W0
068BE:  BRA     NZ,68C4
068C0:  CP      W6,W1
068C2:  BRA     Z,68CC
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
068C4:  MOV.B   #1F,W0L
068C6:  MOV.B   W0L,857
....................         return -1; 
068C8:  SETM    0
068CA:  BRA     6AD0
....................     } 
.................... #endif 
....................  
....................    #if defined(SUPPORT_LFN) 
....................     fo->AsciiEncodingType = rec->AsciiEncodingType; 
....................     fo->utf16LFNlength = recordSearchLength; 
....................    if(fo->utf16LFNlength) 
....................    { 
....................        fo->utf16LFNptr = &recordSearchName[0]; 
....................     } 
....................    else 
....................    #endif 
....................    { 
....................       // Format the file name 
....................        if( !FormatFileName(rec->searchname, fo, 1) ) 
068CC:  MOV     #18,W0
068CE:  ADD     FB8,W0
068D0:  MOV     W0,W5
068D2:  MOV.B   #1,W0L
068D4:  MOV.B   W0L,1004
068D6:  MOV     W5,1000
068D8:  PUSH    FF0
068DA:  POP     1002
068DC:  CALL    26EC
068E0:  CP0.B   W0L
068E2:  BRA     NZ,68EC
....................        { 
....................            FSerrno = CE_INVALID_FILENAME; 
068E4:  MOV.B   #12,W0L
068E6:  MOV.B   W0L,857
....................            return -1; 
068E8:  SETM    0
068EA:  BRA     6AD0
....................        } 
....................     } 
....................  
....................        #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" FindNext foCompareTo="); 
....................          PrintRAMBytesUART(((unsigned char*)fo->name), 13); 
....................          PrintROMASCIIStringUART(" FindNext recSearchname="); 
....................          PrintRAMBytesUART(((unsigned char*)rec->searchname), 13);          
....................         #endif 
....................  
....................     /* Brn: Copy the formatted name to "fo" which is necesary before calling "FILEfind" function */ 
....................     //strcpy(fo->name,rec->searchname); 
....................  
....................     fo->dsk = &gDiskData; 
068EC:  MOV     FF0,W4
068EE:  ADD     W4,#0,W4
068F0:  MOV     W4,W0
068F2:  MOV     W0,W5
068F4:  MOV.B   #8,W0L
068F6:  MOV.B   W0L,[W5]
068F8:  MOV.B   #D,W0L
068FA:  MOV.B   W0L,[W5+#1]
....................     fo->cluster = 0; 
068FC:  MOV     #2,W0
068FE:  ADD     FF0,W0
06900:  MOV     W0,W5
06902:  CLR.B   [W5]
06904:  MOV.B   #0,W0L
06906:  MOV.B   W0L,[W5+#1]
06908:  MOV.B   #0,W0L
0690A:  MOV.B   W0L,[W5+#2]
0690C:  MOV.B   #0,W0L
0690E:  MOV.B   W0L,[W5+#3]
....................     fo->ccls    = 0; 
06910:  MOV     #6,W0
06912:  ADD     FF0,W0
06914:  MOV     W0,W5
06916:  CLR.B   [W5]
06918:  MOV.B   #0,W0L
0691A:  MOV.B   W0L,[W5+#1]
0691C:  MOV.B   #0,W0L
0691E:  MOV.B   W0L,[W5+#2]
06920:  MOV.B   #0,W0L
06922:  MOV.B   W0L,[W5+#3]
....................     fo->entry = rec->entry + 1; 
06924:  MOV     #28,W0
06926:  ADD     FF0,W0
06928:  MOV     W0,W5
0692A:  MOV     #16,W0
0692C:  ADD     FB8,W0
0692E:  MOV     [W0],W6
06930:  ADD     W6,#1,W6
06932:  MOV     W6,[W5]
....................     fo->attributes = rec->searchattr; 
06934:  MOV     #2C,W0
06936:  ADD     FF0,W0
06938:  MOV     W0,W5
0693A:  MOV     #25,W0
0693C:  ADD     FB8,W0
0693E:  MOV.B   [W0],[W5]
06940:  MOV.B   #0,W4L
06942:  MOV.B   W4L,[W5+#1]
....................  
.................... #ifndef ALLOW_DIRS 
....................     // start at the root directory 
....................     fo->dirclus    = FatRootDirClusterValue; 
....................     fo->dirccls    = FatRootDirClusterValue; 
.................... #else 
....................     fo->dirclus = cwdptr->dirclus; 
06944:  MOV     #2E,W0
06946:  ADD     FF0,W0
06948:  MOV     W0,W5
0694A:  MOV     #2E,W0
0694C:  ADD     904,W0
0694E:  MOV     [W0++],[W5++]
06950:  MOV     [W0++],[W5++]
....................     fo->dirccls = cwdptr->dirccls; 
06952:  MOV     #32,W0
06954:  ADD     FF0,W0
06956:  MOV     W0,W5
06958:  MOV     #32,W0
0695A:  ADD     904,W0
0695C:  MOV     [W0++],[W5++]
0695E:  MOV     [W0++],[W5++]
.................... #endif 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&gFileTemp, fo); 
06960:  MOV     #898,W4
06962:  MOV     W4,1002
06964:  PUSH    FF0
06966:  POP     1004
06968:  CALL    28E2
....................  
....................        #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" FindNext2 foCompareTo="); 
....................          PrintRAMBytesUART(((unsigned char*)fo->name), 13); 
....................          PrintROMASCIIStringUART(" FindNext2 recSearchname="); 
....................          PrintRAMBytesUART(((unsigned char*)gFileTemp.name), 13);          
....................         #endif 
....................  
....................     // See if the file is found 
....................     if (CE_GOOD != FILEfind (fo, &gFileTemp,LOOK_FOR_MATCHING_ENTRY, 1)) 
0696C:  MOV.B   #1,W0L
0696E:  MOV.B   W0L,1006
06970:  MOV.B   #1,W0L
06972:  MOV.B   W0L,1007
06974:  PUSH    FF0
06976:  POP     1002
06978:  MOV     #898,W4
0697A:  MOV     W4,1004
0697C:  CALL    36BE
06980:  CP0.B   W0L
06982:  BRA     Z,6990
....................     { 
....................         FSerrno = CE_FILE_NOT_FOUND; 
06984:  MOV.B   #B,W0L
06986:  MOV.B   W0L,857
....................         return -1; 
06988:  SETM    0
0698A:  BRA     6AD0
....................     } 
0698C:  GOTO    6AD0
....................     else 
....................     { 
....................       #if defined(SUPPORT_LFN) 
....................       rec->utf16LFNfoundLength = fo->utf16LFNlength; 
....................       if(fo->utf16LFNlength) 
....................       { 
....................          indexLFN = fo->utf16LFNlength; 
....................          recordFoundName[indexLFN] = 0x0000; 
....................          while(indexLFN--) 
....................             recordFoundName[indexLFN] = fileFoundString[indexLFN]; 
....................       } 
....................       #endif 
....................  
....................       for(j = 0; j < FILE_NAME_SIZE_8P3 + 2 ; j++) 
06990:  CLR.B   FF3
06992:  MOV     FF2,W4
06994:  LSR     W4,#8,W4
06996:  CP.B    W4L,#D
06998:  BRA     C,69AC
....................       { 
....................             rec->filename[j] = 0; 
0699A:  MOV     FF2,W4
0699C:  LSR     W4,#8,W4
0699E:  MOV     W4,W0
069A0:  ADD     FB8,W0
069A2:  MOV     W0,W5
069A4:  CLR.B   [W5]
069A6:  INC.B   0FF3
069A8:  GOTO    6992
....................       } 
....................  
....................         if (fo->attributes != ATTR_VOLUME) 
069AC:  MOV     #2C,W0
069AE:  ADD     FF0,W0
069B0:  MOV     [W0],W5
069B2:  CP      W5,#8
069B4:  BRA     Z,6A60
....................         { 
....................             for (i = 0, j = 0; (j < 8) && (fo->name[j] != 0x20); i++, j++) 
069B6:  CLR.B   FF2
069B8:  CLR.B   FF3
069BA:  MOV     FF2,W4
069BC:  LSR     W4,#8,W4
069BE:  CP.B    W4L,#8
069C0:  BRA     C,69FA
069C2:  MOV     #1C,W0
069C4:  ADD.B   FF3,W0L
069C6:  ZE      W0,W0
069C8:  CLR.B   1
069CA:  MOV     FF0,W4
069CC:  ADD     W0,W4,W0
069CE:  MOV.B   [W0],W5L
069D0:  SE      W5,W5
069D2:  MOV     #20,W4
069D4:  CP      W4,W5
069D6:  BRA     Z,69FA
....................             { 
....................                rec->filename[i] = fo->name[j]; 
069D8:  MOV     FF2,W4
069DA:  CLR.B   9
069DC:  MOV     W4,W0
069DE:  ADD     FB8,W0
069E0:  MOV     W0,W5
069E2:  MOV     #1C,W0
069E4:  ADD.B   FF3,W0L
069E6:  ZE      W0,W0
069E8:  CLR.B   1
069EA:  MOV     FF0,W4
069EC:  ADD     W0,W4,W0
069EE:  MOV.B   [W0],[W5]
069F0:  MOV.B   FF2,W0L
069F2:  INC.B   0FF2
069F4:  INC.B   0FF3
069F6:  GOTO    69BA
....................             } 
....................  
....................          if(fo->name[8] != 0x20) 
069FA:  MOV     #24,W0
069FC:  ADD     FF0,W0
069FE:  MOV.B   [W0],W5L
06A00:  SE      W5,W5
06A02:  MOV     #20,W4
06A04:  CP      W4,W5
06A06:  BRA     Z,6A5C
....................          { 
....................                rec->filename[i++] = '.'; 
06A08:  MOV.B   FF2,W0L
06A0A:  INC.B   0FF2
06A0C:  ZE      W0,W0
06A0E:  CLR.B   1
06A10:  MOV     FB8,W4
06A12:  ADD     W0,W4,W5
06A14:  MOV.B   #2E,W0L
06A16:  MOV.B   W0L,[W5]
....................  
....................                // Move to the extension, even if there are more space chars 
....................                for (j = 8; (j < 11) && (fo->name[j] != 0x20); i++, j++) 
06A18:  MOV.B   #8,W0L
06A1A:  MOV.B   W0L,FF3
06A1C:  MOV     FF2,W4
06A1E:  LSR     W4,#8,W4
06A20:  CP.B    W4L,#B
06A22:  BRA     C,6A5C
06A24:  MOV     #1C,W0
06A26:  ADD.B   FF3,W0L
06A28:  ZE      W0,W0
06A2A:  CLR.B   1
06A2C:  MOV     FF0,W4
06A2E:  ADD     W0,W4,W0
06A30:  MOV.B   [W0],W5L
06A32:  SE      W5,W5
06A34:  MOV     #20,W4
06A36:  CP      W4,W5
06A38:  BRA     Z,6A5C
....................                { 
....................                   rec->filename[i] = fo->name[j]; 
06A3A:  MOV     FF2,W4
06A3C:  CLR.B   9
06A3E:  MOV     W4,W0
06A40:  ADD     FB8,W0
06A42:  MOV     W0,W5
06A44:  MOV     #1C,W0
06A46:  ADD.B   FF3,W0L
06A48:  ZE      W0,W0
06A4A:  CLR.B   1
06A4C:  MOV     FF0,W4
06A4E:  ADD     W0,W4,W0
06A50:  MOV.B   [W0],[W5]
06A52:  MOV.B   FF2,W0L
06A54:  INC.B   0FF2
06A56:  INC.B   0FF3
06A58:  GOTO    6A1C
....................                } 
....................          } 
....................         } 
06A5C:  GOTO    6A86
....................         else 
....................         { 
....................             for (i = 0; i < DIR_NAMECOMP; i++) 
06A60:  CLR.B   FF2
06A62:  MOV     FF2,W4
06A64:  CP.B    W4L,#B
06A66:  BRA     C,6A86
....................             { 
....................                 rec->filename[i] = fo->name[i]; 
06A68:  MOV     FF2,W4
06A6A:  CLR.B   9
06A6C:  MOV     W4,W0
06A6E:  ADD     FB8,W0
06A70:  MOV     W0,W5
06A72:  MOV     #1C,W0
06A74:  ADD.B   FF2,W0L
06A76:  ZE      W0,W0
06A78:  CLR.B   1
06A7A:  MOV     FF0,W4
06A7C:  ADD     W0,W4,W0
06A7E:  MOV.B   [W0],[W5]
06A80:  INC.B   0FF2
06A82:  GOTO    6A62
....................             } 
....................         } 
....................  
....................         rec->attributes = fo->attributes; 
06A86:  MOV     #D,W0
06A88:  ADD     FB8,W0
06A8A:  MOV     W0,W5
06A8C:  MOV     #2C,W0
06A8E:  ADD     FF0,W0
06A90:  MOV.B   [W0],[W5]
....................         rec->filesize = fo->size; 
06A92:  MOV     #E,W0
06A94:  ADD     FB8,W0
06A96:  MOV     W0,W5
06A98:  MOV     #12,W0
06A9A:  ADD     FF0,W0
06A9C:  MOV     [W0++],[W5++]
06A9E:  MOV     [W0++],[W5++]
....................         rec->timestamp = (DWORD)((DWORD)fo->date << 16) + fo->time; 
06AA0:  MOV     #12,W0
06AA2:  ADD     FB8,W0
06AA4:  MOV     W0,W5
06AA6:  MOV     #1A,W0
06AA8:  ADD     FF0,W0
06AAA:  MOV     [W0],W6
06AAC:  MOV     #0,W7
06AAE:  MOV     W6,W7
06AB0:  MOV     #0,W6
06AB2:  MOV     #18,W0
06AB4:  ADD     FF0,W0
06AB6:  MOV     W0,W4
06AB8:  MOV     [W4],W0
06ABA:  ADD     W0,W6,[W5]
06ABC:  MOV     #0,W4
06ABE:  ADDC    W4,W7,[++W5]
....................         rec->entry = fo->entry; 
06AC0:  MOV     #16,W0
06AC2:  ADD     FB8,W0
06AC4:  MOV     W0,W5
06AC6:  MOV     #28,W0
06AC8:  ADD     FF0,W0
06ACA:  MOV     [W0],[W5]
....................         return 0; 
06ACC:  CLR     0
06ACE:  BRA     6AD0
....................     } 
06AD0:  MOV     [--W15],W7
06AD2:  MOV     [--W15],W6
06AD4:  MOV     [--W15],W5
06AD6:  RETURN  
.................... } 
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous wFindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent wFindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................     The wFindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the 
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was 
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... #ifdef SUPPORT_LFN 
.................... int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................    result = FindFirst ((const char *)fileName,attr,rec); 
....................    utfModeFileName = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FSputc (char c, FSFILE * file) 
....................   Summary: 
....................     FSfprintf helper function to write a char 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     c - The character to write to the file. 
....................     file - The file to write to. 
....................   Return Values: 
....................     0 -   The character was written successfully 
....................     EOF - The character was not written to the file. 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This is a helper function for FSfprintf.  It will write one 
....................     character to a file. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int FSputc (char c, FSFILE * file) 
.................... { 
....................     if (FSfwrite ((void *)&c, 1, 1, file) != 1) 
....................         return EOF; 
....................     else 
....................         return 0; 
.................... } 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int str_put_n_chars (FSFILE * handle, unsigned char n, char c) 
....................   Summary: 
....................     FSfprintf helper function to write a char multiple times 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     handle - The file to write to. 
....................     n -      The number of times to write that character to a file. 
....................     c - The character to write to the file. 
....................   Return Values: 
....................     0 -   The characters were written successfully 
....................     EOF - The characters were not written to the file. 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This funciton is used by the FSfprintf function to write multiple 
....................     instances of a single character to a file (for example, when 
....................     padding a format specifier with leading spacez or zeros). 
....................   Remarks: 
....................     None. 
....................   **********************************************************************/ 
....................  
....................  
.................... unsigned char str_put_n_chars (FSFILE * handle, unsigned char n, char c) 
.................... { 
....................     while (n--) 
....................     if (FSputc (c, handle) == EOF) 
....................         return 1; 
....................     return 0; 
.................... } 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int FSfprintf (FSFILE * fptr, const char * fmt, ...) 
....................     // PIC18 
....................     int FSfpritnf (FSFILE * fptr, const rom char * fmt, ...) 
....................   Summary: 
....................     Function to write formatted strings to a file 
....................   Conditions: 
....................     For PIC18, integer promotion must be enabled in the project build 
....................     options menu.  File opened in a write mode. 
....................   Input: 
....................     fptr - A pointer to the file to write to. 
....................     fmt -  A string of characters and format specifiers to write to 
....................            the file 
....................     ... -  Additional arguments inserted in the string by format 
....................            specifiers 
....................   Returns: 
....................     The number of characters written to the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Writes a specially formatted string to a file. 
....................   Remarks: 
....................     Consult AN1045 for a full description of how to use format 
....................     specifiers. 
....................   **********************************************************************/ 
....................  
.................... #ifdef __18CXX 
.................... int FSfprintf (FSFILE *fptr, const rom char *fmt, ...) 
.................... #else 
.................... int FSfprintf (FSFILE *fptr, const char * fmt, ...) 
.................... #endif 
.................... { 
....................     va_list ap; 
....................     int n; 
....................  
....................     va_start (ap, fmt); 
....................     n = FSvfprintf (fptr, fmt, ap); 
....................     va_end (ap); 
....................     return n; 
.................... } 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int FSvfprintf (FSFILE * handle, const char * formatString, va_list ap) 
....................     // PIC18 
....................     int FSvfpritnf (auto FSFILE * handle, auto const rom char * formatString, auto va_list ap) 
....................   Summary: 
....................     Helper function for FSfprintf 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     handle -        A pointer to the file to write to. 
....................     formatString -  A string of characters and format specifiers to write to 
....................                     the file 
....................     ap -            A structure pointing to the arguments on the stack 
....................   Returns: 
....................     The number of characters written to the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This helper function will access the elements passed to FSfprintf 
....................   Remarks: 
....................     Consult AN1045 for a full description of how to use format 
....................     specifiers. 
....................   **********************************************************************/ 
....................  
.................... #ifdef __18CXX 
.................... int FSvfprintf (auto FSFILE *handle, auto const rom char * formatString, auto va_list ap) 
.................... #else 
.................... int FSvfprintf (FSFILE *handle, const char * formatString, va_list ap) 
.................... #endif 
.................... { 
....................     unsigned char c; 
....................     int count = 0; 
....................  
....................     for (c = *formatString; c; c = *++formatString) 
....................     { 
....................         if (c == '%') 
....................         { 
....................             unsigned char    flags = 0; 
....................             unsigned char    width = 0; 
....................             unsigned char    precision = 0; 
....................             unsigned char    have_precision = 0; 
....................             unsigned char    size = 0; 
.................... #ifndef __18CXX 
....................             unsigned char   size2 = 0; 
.................... #endif 
....................             unsigned char    space_cnt; 
....................             unsigned char    cval; 
.................... #ifdef __18CXX 
....................             unsigned long    larg; 
....................             far rom char *   romstring; 
.................... #else 
....................             unsigned long long larg; 
.................... #endif 
....................             char *         ramstring; 
....................             int n; 
....................  
....................             FSerrno = CE_GOOD; 
....................  
....................             c = *++formatString; 
....................  
....................             while ((c == '-') || (c == '+') || (c == ' ') || (c == '#') || (c == '0')) 
....................             { 
....................                 switch (c) 
....................                 { 
....................                     case '-': 
....................                         flags |= _FLAG_MINUS; 
....................                         break; 
....................                     case '+': 
....................                         flags |= _FLAG_PLUS; 
....................                         break; 
....................                     case ' ': 
....................                         flags |= _FLAG_SPACE; 
....................                         break; 
....................                     case '#': 
....................                         flags |= _FLAG_OCTO; 
....................                         break; 
....................                     case '0': 
....................                         flags |= _FLAG_ZERO; 
....................                         break; 
....................                 } 
....................                 c = *++formatString; 
....................             } 
....................             /* the optional width field is next */ 
....................             if (c == '*') 
....................             { 
....................                 n = va_arg (ap, int); 
....................                 if (n < 0) 
....................                 { 
....................                     flags |= _FLAG_MINUS; 
....................                     width = -n; 
....................                 } 
....................                 else 
....................                     width = n; 
....................                 c = *++formatString; 
....................             } 
....................             else 
....................             { 
....................                 cval = 0; 
....................                 while ((unsigned char) isdigit (c)) 
....................                 { 
....................                     cval = cval * 10 + c - '0'; 
....................                     c = *++formatString; 
....................                 } 
....................                 width = cval; 
....................             } 
....................  
....................             /* if '-' is specified, '0' is ignored */ 
....................             if (flags & _FLAG_MINUS) 
....................                 flags &= ~_FLAG_ZERO; 
....................  
....................             /* the optional precision field is next */ 
....................             if (c == '.') 
....................             { 
....................                 c = *++formatString; 
....................                 if (c == '*') 
....................                 { 
....................                     n = va_arg (ap, int); 
....................                     if (n >= 0) 
....................                     { 
....................                         precision = n; 
....................                         have_precision = 1; 
....................                     } 
....................                     c = *++formatString; 
....................                 } 
....................                 else 
....................                 { 
....................                     cval = 0; 
....................                     while ((unsigned char) isdigit (c)) 
....................                     { 
....................                         cval = cval * 10 + c - '0'; 
....................                         c = *++formatString; 
....................                     } 
....................                     precision = cval; 
....................                     have_precision = 1; 
....................                 } 
....................             } 
....................  
....................             /* the optional 'h' specifier. since int and short int are 
....................                 the same size for MPLAB C18, this is a NOP for us. */ 
....................             if (c == 'h') 
....................             { 
....................                 c = *++formatString; 
....................                 /* if 'c' is another 'h' character, this is an 'hh' 
....................                     specifier and the size is 8 bits */ 
....................                 if (c == 'h') 
....................                 { 
....................                     size = _FMT_BYTE; 
....................                     c = *++formatString; 
....................                 } 
....................             } 
....................             else if ((c == 't') || (c == 'z')) 
....................                 c = *++formatString; 
.................... #ifdef __18CXX 
....................             else if ((c == 'H') || (c == 'T') || (c == 'Z')) 
....................             { 
....................                 size = _FMT_SHRTLONG; 
....................                 c = *++formatString; 
....................             } 
....................             else if ((c == 'l') || (c == 'j')) 
.................... #else 
....................             else if ((c == 'q') || (c == 'j')) 
....................             { 
....................                 size = _FMT_LONGLONG; 
....................                 c = *++formatString; 
....................             } 
....................             else if (c == 'l') 
.................... #endif 
....................             { 
....................                 size = _FMT_LONG; 
....................                 c = *++formatString; 
....................             } 
....................  
....................             switch (c) 
....................             { 
....................                 case '\0': 
....................                 /* this is undefined behaviour. we have a trailing '%' character 
....................                     in the string, perhaps with some flags, width, precision 
....................                     stuff as well, but no format specifier. We'll, arbitrarily, 
....................                     back up a character so that the loop will terminate 
....................                     properly when it loops back and we'll output a '%' 
....................                     character. */ 
....................                     --formatString; 
....................                 /* fallthrough */ 
....................                 case '%': 
....................                     if (FSputc ('%', handle) == EOF) 
....................                     { 
....................                         FSerrno = CE_WRITE_ERROR; 
....................                         return EOF; 
....................                     } 
....................                     ++count; 
....................                     break; 
....................                 case 'c': 
....................                     space_cnt = 0; 
....................                     if (width > 1) 
....................                     { 
....................                         space_cnt = width - 1; 
....................                         count += space_cnt; 
....................                     } 
....................                     if (space_cnt && !(flags & _FLAG_MINUS)) 
....................                     { 
....................                         if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                         { 
....................                             FSerrno = CE_WRITE_ERROR; 
....................                             return EOF; 
....................                         } 
....................                         space_cnt = 0; 
....................                     } 
....................                     c = va_arg (ap, int); 
....................                     if (FSputc (c, handle) == EOF) 
....................                     { 
....................                         FSerrno = CE_WRITE_ERROR; 
....................                         return EOF; 
....................                     } 
....................                     ++count; 
....................                     if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                     { 
....................                         FSerrno = CE_WRITE_ERROR; 
....................                         return EOF; 
....................                     } 
....................                     break; 
....................                 case 'S': 
.................... #ifdef __18CXX 
....................                     if (size == _FMT_SHRTLONG) 
....................                         romstring = va_arg (ap, rom far char *); 
....................                     else 
....................                         romstring = (far rom char*)va_arg (ap, rom near char *); 
....................                     n = strlenpgm (romstring); 
....................                     /* Normalize the width based on the length of the actual 
....................                         string and the precision. */ 
....................                     if (have_precision && precision < (unsigned char) n) 
....................                         n = precision; 
....................                     if (width < (unsigned char) n) 
....................                         width = n; 
....................                     space_cnt = width - (unsigned char) n; 
....................                     count += space_cnt; 
....................                     /* we've already calculated the space count that the width 
....................                         will require. now we want the width field to have the 
....................                         number of character to display from the string itself, 
....................                         limited by the length of the actual string and the 
....................                         specified precision. */ 
....................                     if (have_precision && precision < width) 
....................                         width = precision; 
....................                     /* if right justified, we print the spaces before the 
....................                         string */ 
....................                     if (!(flags & _FLAG_MINUS)) 
....................                     { 
....................                         if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                         { 
....................                             FSerrno = CE_WRITE_ERROR; 
....................                             return EOF; 
....................                         } 
....................                         space_cnt = 0; 
....................                     } 
....................                     cval = 0; 
....................                     for (c = *romstring; c && cval < width; c = *++romstring) 
....................                     { 
....................                         if (FSputc (c, handle) == EOF) 
....................                         { 
....................                             FSerrno = CE_WRITE_ERROR; 
....................                             return EOF; 
....................                         } 
....................                         ++count; 
....................                         ++cval; 
....................                     } 
....................                     /* If there are spaces left, it's left justified. 
....................                         Either way, calling the function unconditionally 
....................                         is smaller code. */ 
....................                     if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                     { 
....................                         FSerrno = CE_WRITE_ERROR; 
....................                         return EOF; 
....................                     } 
....................                     break; 
.................... #endif 
....................                 case 's': 
....................                     ramstring = va_arg (ap, char *); 
....................                     n = strlen (ramstring); 
....................                     /* Normalize the width based on the length of the actual 
....................                         string and the precision. */ 
....................                     if (have_precision && precision < (unsigned char) n) 
....................                         n = precision; 
....................                     if (width < (unsigned char) n) 
....................                         width = n; 
....................                     space_cnt = width - (unsigned char) n; 
....................                     count += space_cnt; 
....................                     /* we've already calculated the space count that the width 
....................                         will require. now we want the width field to have the 
....................                         number of character to display from the string itself, 
....................                         limited by the length of the actual string and the 
....................                         specified precision. */ 
....................                     if (have_precision && precision < width) 
....................                         width = precision; 
....................                     /* if right justified, we print the spaces before the string */ 
....................                     if (!(flags & _FLAG_MINUS)) 
....................                     { 
....................                         if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                         { 
....................                             FSerrno = CE_WRITE_ERROR; 
....................                             return EOF; 
....................                         } 
....................                         space_cnt = 0; 
....................                     } 
....................                     cval = 0; 
....................                     for (c = *ramstring; c && cval < width; c = *++ramstring) 
....................                     { 
....................                         if (FSputc (c, handle) == EOF) 
....................                         { 
....................                             FSerrno = CE_WRITE_ERROR; 
....................                             return EOF; 
....................                         } 
....................                         ++count; 
....................                         ++cval; 
....................                     } 
....................                     /* If there are spaces left, it's left justified. 
....................                         Either way, calling the function unconditionally 
....................                         is smaller code. */ 
....................                     if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                     { 
....................                         FSerrno = CE_WRITE_ERROR; 
....................                         return EOF; 
....................                     } 
....................                     break; 
....................                 case 'd': 
....................                 case 'i': 
....................                     flags |= _FLAG_SIGNED; 
....................                 /* fall through */ 
....................                 case 'o': 
....................                 case 'u': 
....................                 case 'x': 
....................                 case 'X': 
....................                 case 'b': 
....................                 case 'B': 
....................                     /* This is a bit of a trick. The 'l' and 'hh' size 
....................                         specifiers are valid only for the integer conversions, 
....................                         not the 'p' or 'P' conversions, and are ignored for the 
....................                         latter. By jumping over the additional size specifier 
....................                         checks here we get the best code size since we can 
....................                         limit the size checks in the remaining code. */ 
....................                     if (size == _FMT_LONG) 
....................                     { 
....................                         if (flags & _FLAG_SIGNED) 
....................                             larg = va_arg (ap, long int); 
....................                         else 
....................                             larg = va_arg (ap, unsigned long int); 
....................                         goto _do_integer_conversion; 
....................                     } 
....................                     else if (size == _FMT_BYTE) 
....................                     { 
....................                         if (flags & _FLAG_SIGNED) 
....................                             larg = (signed char) va_arg (ap, int); 
....................                         else 
....................                             larg = (unsigned char) va_arg (ap, unsigned int); 
....................                         goto _do_integer_conversion; 
....................                     } 
.................... #ifndef __18CXX 
....................                     else if (size == _FMT_LONGLONG) 
....................                     { 
....................                         if (flags & _FLAG_SIGNED) 
....................                             larg = (signed long long)va_arg (ap, long long); 
....................                         else 
....................                             larg = (unsigned long long) va_arg (ap, unsigned long long); 
....................                         goto _do_integer_conversion; 
....................                     } 
.................... #endif 
....................                     /* fall trough */ 
....................                 case 'p': 
....................                 case 'P': 
.................... #ifdef __18CXX 
....................                     if (size == _FMT_SHRTLONG) 
....................                     { 
....................                         if (flags & _FLAG_SIGNED) 
....................                             larg = va_arg (ap, short long int); 
....................                         else 
....................                             larg = va_arg (ap, unsigned short long int); 
....................                     } 
....................                     else 
.................... #endif 
....................                         if (flags & _FLAG_SIGNED) 
....................                             larg = va_arg (ap, int); 
....................                         else 
....................                             larg = va_arg (ap, unsigned int); 
....................                     _do_integer_conversion: 
....................                         /* default precision is 1 */ 
....................                         if (!have_precision) 
....................                             precision = 1; 
....................                         { 
....................                             unsigned char digit_cnt = 0; 
....................                             unsigned char prefix_cnt = 0; 
....................                             unsigned char sign_char; 
....................                             /* A 32 bit number will require at most 32 digits in the 
....................                                 string representation (binary format). */ 
.................... #ifdef __18CXX 
....................                             char buf[33]; 
....................                             /* Start storing digits least-significant first */ 
....................                             char *q = &buf[31]; 
....................                             /* null terminate the string */ 
....................                             buf[32] = '\0'; 
.................... #else 
....................                             char buf[65]; 
....................                             char *q = &buf[63]; 
....................                             buf[64] = '\0'; 
.................... #endif 
....................                             space_cnt = 0; 
....................                             size = 10; 
....................  
....................                             switch (c) 
....................                             { 
....................                                 case 'b': 
....................                                 case 'B': 
....................                                     size = 2; 
.................... #ifndef __18CXX 
....................                                     size2 = 1; 
.................... #endif 
....................                                     break; 
....................                                 case 'o': 
....................                                     size = 8; 
.................... #ifndef __18CXX 
....................                                     size2 = 3; 
.................... #endif 
....................                                     break; 
....................                                 case 'p': 
....................                                 case 'P': 
....................                                     /* from here on out, treat 'p' conversions just 
....................                                         like 'x' conversions. */ 
....................                                     c += 'x' - 'p'; 
....................                                 /* fall through */ 
....................                                 case 'x': 
....................                                 case 'X': 
....................                                     size = 16; 
.................... #ifndef __18CXX 
....................                                     size2 = 4; 
.................... #endif 
....................                                     break; 
....................                             }// switch (c) 
....................  
....................                             /* if it's an unsigned conversion, we should ignore the 
....................                                 ' ' and '+' flags */ 
....................                             if (!(flags & _FLAG_SIGNED)) 
....................                                 flags &= ~(_FLAG_PLUS | _FLAG_SPACE); 
....................  
....................                             /* if it's a negative value, we need to negate the 
....................                                 unsigned version before we convert to text. Using 
....................                                 unsigned for this allows us to (ab)use the 2's 
....................                                 complement system to avoid overflow and be able to 
....................                                 adequately handle LONG_MIN. 
....................  
....................                                 We'll figure out what sign character to print, if 
....................                                 any, here as well. */ 
.................... #ifdef __18CXX 
....................                             if (flags & _FLAG_SIGNED && ((long) larg < 0)) 
....................                             { 
....................                                 larg = -(long) larg; 
.................... #else 
....................                             if (flags & _FLAG_SIGNED && ((long long) larg < 0)) 
....................                             { 
....................                                 larg = -(long long) larg; 
.................... #endif 
....................                                 sign_char = '-'; 
....................                                 ++digit_cnt; 
....................                             } 
....................                             else if (flags & _FLAG_PLUS) 
....................                             { 
....................                         sign_char = '+'; 
....................                         ++digit_cnt; 
....................                      } 
....................                       else if (flags & _FLAG_SPACE) 
....................                       { 
....................                                 sign_char = ' '; 
....................                                 ++digit_cnt; 
....................                             } 
....................                             else 
....................                                 sign_char = '\0'; 
....................                             /* get the digits for the actual number. If the 
....................                                 precision is zero and the value is zero, the result 
....................                                 is no characters. */ 
....................                             if (precision || larg) 
....................                             { 
....................                                 do 
....................                                 { 
.................... #ifdef __18CXX 
....................                                     cval = s_digits[larg % size]; 
....................                                     if ((c == 'X') && (cval >= 'a')) 
....................                                         cval -= 'a' - 'A'; 
....................                                     larg /= size; 
.................... #else 
....................                                     // larg is congruent mod size2 to its lower 16 bits 
....................                                     // for size2 = 2^n, 0 <= n <= 4 
....................                                     if (size2 != 0) 
....................                                         cval = s_digits[(unsigned int) larg % size]; 
....................                                     else 
....................                                         cval = s_digits[larg % size]; 
....................                                     if ((c == 'X') && (cval >= 'a')) 
....................                                         cval -= 'a' - 'A'; 
....................                                     if (size2 != 0) 
....................                                         larg = larg >> size2; 
....................                                     else 
....................                                         larg /= size; 
.................... #endif 
....................                                     *q-- = cval; 
....................                                     ++digit_cnt; 
....................                                 } while (larg); 
....................                                 /* if the '#' flag was specified and we're dealing 
....................                                     with an 'o', 'b', 'B', 'x', or 'X' conversion, 
....................                                     we need a bit more. */ 
....................                                 if (flags & _FLAG_OCTO) 
....................                                 { 
....................                                     if (c == 'o') 
....................                                     { 
....................                                         /* per the standard, for octal, the '#' flag 
....................                                             makes the precision be at least one more 
....................                                             than the number of digits in the number */ 
....................                                         if (precision <= digit_cnt) 
....................                                             precision = digit_cnt + 1; 
....................                                     } 
....................                                     else if ((c == 'x') || (c == 'X') || (c == 'b') || (c == 'B')) 
....................                                         prefix_cnt = 2; 
....................                                 } 
....................                             } 
....................                             else 
....................                                 digit_cnt = 0; 
....................  
....................                             /* The leading zero count depends on whether the '0' 
....................                                 flag was specified or not. If it was not, then the 
....................                                 count is the difference between the specified 
....................                                 precision and the number of digits (including the 
....................                                 sign character, if any) to be printed; otherwise, 
....................                                 it's as if the precision were equal to the max of 
....................                                 the specified precision and the field width. If a 
....................                                 precision was specified, the '0' flag is ignored, 
....................                                 however. */ 
....................                             if ((flags & _FLAG_ZERO) && (width > precision) 
....................                                 && !have_precision) 
....................                                 precision = width; 
....................                             /* for the rest of the processing, precision contains 
....................                                 the leading zero count for the conversion. */ 
....................                             if (precision > digit_cnt) 
....................                                 precision -= digit_cnt; 
....................                             else 
....................                                 precision = 0; 
....................                             /* the space count is the difference between the field 
....................                                 width and the digit count plus the leading zero 
....................                                 count. If the width is less than the digit count 
....................                                 plus the leading zero count, the space count is 
....................                                 zero. */ 
....................                             if (width > precision + digit_cnt + prefix_cnt) 
....................                                 space_cnt =   width - precision - digit_cnt - prefix_cnt; 
....................  
....................                             /* for output, we check the justification, if it's 
....................                                 right justified and the space count is positive, we 
....................                                 emit the space characters first. */ 
....................                             if (!(flags & _FLAG_MINUS) && space_cnt) 
....................                             { 
....................                                 if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                                 { 
....................                                     FSerrno = CE_WRITE_ERROR; 
....................                                     return EOF; 
....................                                 } 
....................                                 count += space_cnt; 
....................                                 space_cnt = 0; 
....................                             } 
....................                             /* if we have a sign character to print, that comes 
....................                                 next */ 
....................                             if (sign_char) 
....................                                 if (FSputc (sign_char, handle) == EOF) 
....................                                 { 
....................                                     FSerrno = CE_WRITE_ERROR; 
....................                                     return EOF; 
....................                                 } 
....................                             /* if we have a prefix (0b, 0B, 0x or 0X), that's next */ 
....................                             if (prefix_cnt) 
....................                             { 
....................                                 if (FSputc ('0', handle) == EOF) 
....................                                 { 
....................                                     FSerrno = CE_WRITE_ERROR; 
....................                                     return EOF; 
....................                                 } 
....................                                 if (FSputc (c, handle) == EOF) 
....................                                 { 
....................                                     FSerrno = CE_WRITE_ERROR; 
....................                                     return EOF; 
....................                                 } 
....................                             } 
....................                             /* if we have leading zeros, they follow. the prefix, if any 
....................                                 is included in the number of digits when determining how 
....................                                 many leading zeroes are needed. */ 
.................... //                            if (precision > prefix_cnt) 
....................   //                              precision -= prefix_cnt; 
....................                             if (str_put_n_chars (handle, precision, '0')) 
....................                             { 
....................                                 FSerrno = CE_WRITE_ERROR; 
....................                                 return EOF; 
....................                             } 
....................                             /* print the actual number */ 
....................                             for (cval = *++q; cval; cval = *++q) 
....................                                 if (FSputc (cval, handle) == EOF) 
....................                                 { 
....................                                     FSerrno = CE_WRITE_ERROR; 
....................                                     return EOF; 
....................                                 } 
....................                             /* if there are any spaces left, they go to right-pad 
....................                                 the field */ 
....................                             if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                             { 
....................                                 FSerrno = CE_WRITE_ERROR; 
....................                                 return EOF; 
....................                             } 
....................  
....................                             count += precision + digit_cnt + space_cnt + prefix_cnt; 
....................                         } 
....................                         break; 
....................                 case 'n': 
....................                     switch (size) 
....................                     { 
....................                         case _FMT_LONG: 
....................                             *(long *) va_arg (ap, long *) = count; 
....................                             break; 
.................... #ifdef __18CXX 
....................                         case _FMT_SHRTLONG: 
....................                             *(short long *) va_arg (ap, short long *) = count; 
....................                             break; 
.................... #else 
....................                         case _FMT_LONGLONG: 
....................                             *(long long *) va_arg (ap, long long *) = count; 
....................                             break; 
.................... #endif 
....................                         case _FMT_BYTE: 
....................                             *(signed char *) va_arg (ap, signed char *) = count; 
....................                             break; 
....................                         default: 
....................                             *(int *) va_arg (ap, int *) = count; 
....................                             break; 
....................                     } 
....................                     break; 
....................                 default: 
....................                     /* undefined behaviour. we do nothing */ 
....................                     break; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if (FSputc (c, handle) == EOF) 
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
....................                 return EOF; 
....................             } 
....................             ++count; 
....................         } 
....................     } 
....................     return count; 
.................... } 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #if defined(USE_SD_INTERFACE_WITH_SPI) 
.................... #include "sd-spi.c" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        SD-SPI.c 
....................  * Dependencies:    SD-SPI.h 
....................  *                  string.h 
....................  *                  FSIO.h 
....................  *                  FSDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the "Company") for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... ***************************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev     Description 
....................   -----   ----------- 
....................   1.2.5   Fixed bug in the calculation of the capacity for v1.0 devices 
....................   1.3.0   Improved media initialization sequence, for better card compatibility 
....................           (especially with SDHC cards). 
....................           Implemented SPI optimizations for data transfer rate improvement. 
....................           Added new MDD_SDSPI_AsyncReadTasks() and MDD_SDSPI_AsyncWriteTasks()  
....................           API functions.  These are non-blocking, state machine based read/write 
....................           handlers capable of considerably improved data throughput, particularly 
....................           for multi-block reads and multi-block writes. 
....................   1.3.2   Modified MDD_SDSPI_AsyncWriteTasks() so pre-erase command only gets 
....................           used for multi-block write scenarios.    
....................   1.3.4   1) Added support for dsPIC33E & PIC24E controllers. 
....................           2) #include "HardwareProfile.h" is moved up in the order. 
....................           3) "SPI_INTERRUPT_FLAG_ASM" macro has to be defined in "HardwareProfile.h" file 
....................              for PIC18 microcontrollers.Or else an error is generated while building 
....................              the code. 
....................                        "#define SPI_INTERRUPT_FLAG_ASM  PIR1, 3" is removed from SD-SPI.c 
....................           4) Replaced "__C30" usage with "__C30__" . 
....................   1.3.6   1) Modified "FSConfig.h" to "FSconfig.h" in '#include' directive. 
....................           2) Moved 'spiconvalue' variable definition to only C30 usage, as C32 
....................              is not using it. 
....................           3) Modified 'MDD_SDSPI_MediaDetect' function to ensure that CMD0 is sent freshly 
....................              after CS is asserted low. This minimizes the risk of SPI clock pulse master/slave 
....................              syncronization problems. 
....................  
.................... ********************************************************************/ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *					dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *					Microchip C30 v3.01 or higher 
....................  *					Microchip C18 v3.13 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006	Original, copied from old Compiler.h 
....................  * 11/07/2007	Reorganized and simplified 
....................  * 03/31/2010	Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__PCH__) 
....................    #include <p18cxxx.h> 
.................... #elif defined(__PCD__) 
....................    #include <CCSIncludes\PCDxxxx.h> 
.................... #elif defined(__18CXX) && !defined(HI_TECH_C)	 
.................... 	// PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)	 
.................... 	// PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
.................... 	#if !defined(__18CXX) 
.................... 		#define __18CXX 
.................... 	#endif 
....................     #define COMPILER_HITECH_PICC18 
.................... 	#include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p30fxxxx.h> 
.................... #elif defined(__C30__)		// Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p30sim.h> 
.................... 	// Define some useful inline assembly functions which are normally in the  
.................... 	// processor header files, but absent from the generic p30sim.h file. 
.................... 	#if !defined(Nop) 
.................... 		#define Nop()    __builtin_nop() 
.................... 		#define ClrWdt() {__asm__ volatile ("clrwdt");} 
.................... 		#define Sleep()  {__asm__ volatile ("pwrsav #0");} 
.................... 		#define Idle()   {__asm__ volatile ("pwrsav #1");} 
.................... 	#endif 
.................... #elif defined(__PIC32MX__)	// Microchip C32 compiler 
.................... 	#if !defined(__C32__) 
.................... 		#define __C32__ 
.................... 	#endif 
....................     #define COMPILER_MPLAB_C32 
.................... 	#include <p32xxxx.h> 
.................... 	#include <plib.h> 
.................... #else 
.................... 	#error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
.................... #include <string.h> 
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PIC32MX__) 
.................... 	#define PTR_BASE		unsigned long 
.................... 	#define ROM_PTR_BASE	unsigned long 
.................... #elif defined(__C30__) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
.................... 	#define memcmppgm2ram(a,b,c)	memcmp(a,b,c) 
.................... 	#define strcmppgm2ram(a,b)		strcmp(a,b) 
.................... 	#define memcpypgm2ram(a,b,c)	memcpy(a,b,c) 
.................... 	#define strcpypgm2ram(a,b)		strcpy(a,b) 
.................... 	#define strncpypgm2ram(a,b,c)	strncpy(a,b,c) 
.................... 	#define strstrrampgm(a,b)		strstr(a,b) 
.................... 	#define	strlenpgm(a)			strlen(a) 
.................... 	#define strchrpgm(a,b)			strchr(a,b) 
.................... 	#define strcatpgm2ram(a,b)		strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
.................... 	#define	__attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
.................... 	// Microchip C18 specific defines 
.................... 	#if defined(COMPILER_MPLAB_C18) 
.................... 	    #define ROM                 	rom 
.................... 	#endif 
.................... 	 
.................... 	// HI TECH PICC-18 specific defines 
.................... 	#if defined(COMPILER_HITECH_PICC18) 
.................... 	    #define ROM                 	const 
.................... 		#define rom 
.................... 	    #define Nop()               	asm("NOP"); 
.................... 		#define ClrWdt()				asm("CLRWDT"); 
.................... 	    #define Reset()					asm("RESET"); 
.................... 	#endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
.................... 	#define	ROM						const 
....................  
.................... 	// 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
.................... 	#if defined(__C30__) 
.................... 		#define Reset()				asm("reset") 
....................         #define FAR                 __attribute__((far)) 
.................... 	#endif 
....................  
.................... 	// 32-bit specific defines (PIC32) 
.................... 	#if defined(__PIC32MX__) 
.................... 		#define persistent 
.................... 		#define far 
....................         #define FAR 
.................... 		#define Reset()				SoftReset() 
.................... 		#define ClrWdt()			(WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
.................... 		// MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
.................... 		// Nop() function. However, version 1.05 has Nop() declared as _nop(). 
.................... 		#if !defined(Nop) && (__C32_VERSION__ <= 104) 
.................... 			#define Nop()				asm("nop") 
.................... 		#endif 
.................... 	#endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "HardwareProfile.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        HardwareProfile.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _MDD_HARDWAREPROFILE_H_ 
.................... #define _MDD_HARDWAREPROFILE_H_ 
....................  
.................... /*********************************************************************/ 
.................... /******************* Pin and Register Definitions ********************/ 
.................... /*********************************************************************/ 
....................  
.................... /* SD Card definitions: Change these to fit your application when using 
....................    an SD-card-based physical layer                                   */ 
.................... /* 
.................... #if (defined(HW_CCS_3V_ETHERNET)||defined(HW_CCS_46K20)) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)) 
.................... //CCS 18F67J60 3.3V Ethernet development kit with SD card 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................          
....................         // Chip Select Signal 
....................         #define SD_CS               PORTCbits.RC2 
....................         #define SD_CS_TRIS          TRISCbits.TRISC2 
....................          
....................         // Card detect signal 
....................         #define SD_CD               PORTEbits.RE5 
....................         #define SD_CD_TRIS          TRISEbits.TRISE5 
....................          
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................          
....................         // Defines for the HPC Explorer board 
....................         #define SPICLOCK            TRISCbits.TRISC3 
....................         #define SPIIN               TRISCbits.TRISC4 
....................         #define SPIOUT              TRISCbits.TRISC5 
....................      
....................         // Latch pins for SCK/SDI/SDO lines 
....................         #define SPICLOCKLAT         LATCbits.LATC3 
....................         #define SPIINLAT            LATCbits.LATC4 
....................         #define SPIOUTLAT           LATCbits.LATC5 
....................      
....................         // Port pins for SCK/SDI/SDO lines 
....................         #define SPICLOCKPORT        PORTCbits.RC3 
....................         #define SPIINPORT           PORTCbits.RC4 
....................         #define SPIOUTPORT          PORTCbits.RC5 
....................  
....................         // Registers for the SPI module you want to use 
....................         #define SPICON1             SSP1CON1 
....................         #define SPISTAT             SSP1STAT 
....................         #define SPIBUF              SSP1BUF 
....................         #define SPICON1bits         SSP1CON1bits 
....................         #define SPISTATbits         SSP1STATbits 
....................          
....................         #define PIR1_LOC   getenv("SFR:PIR1") 
....................         //#define SPI_INTERRUPT_FLAG_ASM PIR1_LOC,3 
....................         #define SPI_INTERRUPT_FLAG_ASM PIR1,3 
....................  
....................        //set SPI_INTERRUPT_FLAG to SPI1 interrupt flag. 
....................        //some PICs this bit is defined as SSP1IF and some PICs this is defined 
....................        //as SSPIF. 
....................         #if getenv("BIT_VALID:SSP1IF") 
....................          #bit SPI_INTERRUPT_FLAG=getenv("BIT:SSP1IF") 
....................         #else 
....................          #bit SPI_INTERRUPT_FLAG=getenv("BIT:SSPIF") 
....................         #endif 
....................      
....................         #define SPIENABLE           SPICON1bits.SSPEN 
.................... #endif   //HW_CCS_3V_ETHERNET 
....................  
.................... // ccs dsp analog board with (33hj) sd connector 
.................... #if defined(HW_CCS_DSP_AUDIO) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATDbits.LATD8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISDbits.TRISD8 
....................                  
....................          //NO SD_CD or SD_CD_TRIS 
....................          #define MEDIA_SOFT_DETECT 
....................  
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI2CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI2STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI2BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI2STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI2STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI2CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI2STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISFbits.TRISF4 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISFbits.TRISF5 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISBbits.TRISB15 
.................... #endif 
....................  
.................... // ccs dsp analog board (33ep) with sd connector 
.................... #if defined(HW_CCS_DSP_AUDIO2) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATDbits.LATD8 //PIN_D8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISDbits.TRISD8 
....................         #define SD_CS_ANSEL         ANSELEbits.ANSE8 
....................          
....................          //NO SD_CD or SD_CD_TRIS   //PIN_E1 
....................          #define SD_CD              PORTEbits.RE1 
....................          #define SD_CD_TRIS              TRISEbits.TRISE1 
....................  
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................  
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI1CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI1STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI1BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI1STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI1STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI1CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI1STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISGbits.TRISG6 
....................         #define SD_SCK_ANSEL        ANSELGbits.ANSG6 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISGbits.TRISG7 
....................         #define SD_SDI_ANSEL        ANSELGbits.ANSG7 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISGbits.TRISG8 
....................         #define SD_SDO_ANSEL        ANSELGbits.ANSG8 
.................... #endif 
....................  
.................... #if defined(HW_CCS_DSP_AUDIO) && defined(USE_SST25_INTERFACE) 
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................          
....................         //chip select pin of SST25 
....................         #define FLASH_SELECT_PIN PIN_F1 
....................          
....................         //configure sst25 library spi stream 
....................         #use spi(SPI2, MODE=0, BITS=8, baud=1000000, STREAM=SPI_SST25, FORCE_HW) 
....................         #define FLASH_STREAM SPI_SST25 
.................... #endif 
....................  
.................... */ 
.................... #if defined(HW_CCS_PIC24USB) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
.................... // ccs dsp analog board with sd connector 
....................  
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATGbits.LATG8      //pin_G8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISGbits.TRISG8 
....................  
.................... //This is the old setup  December 30, 2014 
....................         // Description: SD-SPI Chip Select Output bit 
....................         //#define SD_CS            LATBbits.LATB14      //pin_b14 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         //#define SD_CS_TRIS          TRISBbits.TRISB14 
....................  
....................         #define SD_CD            PORTBbits.RB12      //pin_b12 
....................         #define SD_CD_TRIS          TRISBbits.TRISB12 
....................  
....................          //NO SD_WE_TRIS         
....................          int1 SD_WE_TRIS; 
....................          int1 SD_WE=0; 
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI1CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI1STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI1BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI1STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI1STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI1CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI1STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The main SPI control register 
....................         //#define SPICON1             SPI2CON1 
....................         // Description: The SPI status register 
....................         //#define SPISTAT             SPI2STAT 
....................         // Description: The SPI Buffer 
....................         //#define SPIBUF              SPI2BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         //#define SPISTAT_RBF         SPI2STATbits.SPIRBF 
....................         //#define SPISTAT_TBF         SPI2STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         //#define SPICON1bits         SPI2CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         //#define SPISTATbits         SPI2STATbits 
....................         // Description: The enable bit for the SPI module 
....................         //#define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................  
....................        // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISFbits.TRISF3 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISFbits.TRISF6 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISFbits.TRISF2 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         //#define SPICLOCK            TRISGbits.TRISG6 
....................         // Description: The TRIS bit for the SDI pin 
....................         //#define SPIIN               TRISGbits.TRISG7 
....................         // Description: The TRIS bit for the SDO pin 
....................         //#define SPIOUT              TRISGbits.TRISG8 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "MDD File System/FSIO.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSIO.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  *                  FSconfig.h 
....................  *                  FSDefs.h 
....................  *                  stddef.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.4.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  FS_DOT_H 
.................... #define  FS_DOT_H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... #include "../FSconfig.h" 
.................... #include "FSDefs.h"  
.................... #include "stddef.h" 
....................  
.................... #ifdef USE_SD_INTERFACE_WITH_SPI 
....................     #include    "SD-SPI.h" 
.................... #endif 
.................... #ifdef USE_CF_INTERFACE_WITH_PMP 
....................     #include    "CF-PMP.h" 
.................... #endif 
.................... #ifdef USE_MANUAL_CF_INTERFACE 
....................     #include    "CF- Bit transaction.h" 
.................... #endif 
.................... #ifdef USE_USB_INTERFACE 
....................     #include    "usb_host_msd_scsi.h" 
.................... #endif 
.................... #ifdef USE_INTERNAL_FLASH 
....................     #include    "Internal Flash.h" 
.................... #endif 
....................  
....................  
.................... /*******************************************************************/ 
.................... /*                     Strunctures and defines                     */ 
.................... /*******************************************************************/ 
....................  
.................... #ifndef FALSE 
....................     // Summary: False value 
....................     // Description:  This macro will indicate that a condition is false. 
....................     #define FALSE   0 
.................... #endif 
.................... #ifndef TRUE 
....................     // Summary: True value 
....................     // Description: This macro will indicate that a condition is true. 
....................     #define TRUE    !FALSE  // True value 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #ifndef SEEK_SET 
....................     // Summary: Macro for the FSfseek SEEK_SET base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed  
....................     //              relative to the beginning of the file. 
....................     #define SEEK_SET 0 
....................  
.................... #endif 
.................... #ifndef SEEK_CUR 
....................  
....................     // Summary: Macro for the FSfseek SEEK_CUR base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the current location of the file 
....................     #define SEEK_CUR 1 
....................  
.................... #endif 
.................... #ifndef SEEK_END 
....................  
....................     // Summary: Macro for the FSfseek SEEK_END base location 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the end of the file.  For this macro, the offset value will be subtracted from 
....................     //              the end location of the file by default. 
....................     #define SEEK_END 2 
....................  
.................... #endif 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file. 
.................... #define FS_APPEND   "a" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file. 
.................... #define FS_WRITE    "w" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file. 
.................... #define FS_READ "r" 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file 
.................... //              or read from the file. 
.................... #define FS_APPENDPLUS   "a+" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file or read from the file. 
.................... #define FS_WRITEPLUS    "w+" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file or write to the file. 
.................... #define FS_READPLUS     "r+" 
....................  
.................... #ifndef intmax_t 
....................     #ifdef __PIC24F__ 
....................         // Summary: A data type indicating the maximum integer size in an architecture 
....................         // Description: The intmax_t data type refers to the maximum-sized data type on any given architecture.  This 
....................         //              data type can be specified as a format specifier size specification for the FSfprintf function. 
....................         #define intmax_t long long 
....................     #elif defined __PIC24H__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC30F__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC33F__ 
....................         #define intmax_t long long 
....................     #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary:  Indicates flag conditions for a file object 
.................... // Description: The FILEFLAGS structure is used to indicate conditions in a file.  It contains three flags: 'write' indicates 
.................... //              that the file was opened in a mode that allows writes, 'read' indicates that the file was opened in a mode 
.................... //              that allows reads, and 'FileWriteEOF' indicates that additional data that is written to the file will increase 
.................... //              the file size. 
.................... typedef struct 
.................... { 
....................     unsigned    write :1;           // Indicates a file was opened in a mode that allows writes 
....................     unsigned    read :1;            // Indicates a file was opened in a mode that allows reads 
....................     unsigned    FileWriteEOF :1;    // Indicates the current position in a file is at the end of the file 
.................... }FILEFLAGS; 
....................  
....................  
....................  
.................... // Summary: Indicates how to search for file entries in the FILEfind function 
.................... // Description: The values in the SEARCH_TYPE enumeration are used internally by the library to indicate how the FILEfind function 
.................... //              how to perform a search.  The 'LOOK_FOR_EMPTY_ENTRY' value indicates that FILEfind should search for an empty file entry. 
.................... //              The 'LOOK_FOR_MATCHING_ENTRY' value indicates that FILEfind should search for an entry that matches the FSFILE object 
.................... //              that was passed into the FILEfind function. 
.................... typedef enum{ 
....................     LOOK_FOR_EMPTY_ENTRY = 0, 
....................     LOOK_FOR_MATCHING_ENTRY 
.................... } SEARCH_TYPE; 
....................  
....................  
....................  
.................... // Summary: Macro indicating the length of a 8.3 file name 
.................... // Description: The TOTAL_FILE_SIZE_8P3 macro indicates the maximum number of characters in an 8.3 file name.  This value includes 
.................... //              8 characters for the name, three for the extentsion, and 1 for the radix ('.') 
.................... #define TOTAL_FILE_SIZE_8P3             (8+3+1) 
.................... #define TOTAL_FILE_SIZE                 TOTAL_FILE_SIZE_8P3 
....................  
.................... // Summary: Macro indicating the max length of a LFN file name 
.................... // Description: The MAX_FILE_NAME_LENGTH_LFN macro indicates the maximum number of characters in an LFN file name. 
.................... #define MAX_FILE_NAME_LENGTH_LFN             256 
....................  
.................... // Summary: A mask that indicates the limit of directory entries in a sector 
.................... // Description: The MASK_MAX_FILE_ENTRY_LIMIT_BITS is used to indicate to the Cache_File_Entry function that a new sector needs to 
.................... //              be loaded. 
.................... #define MASK_MAX_FILE_ENTRY_LIMIT_BITS          0x0f 
....................  
.................... // Summary: Value used for shift operations to calculate the sector offset in a directory 
.................... // Description: The VALUE_BASED_ON_ENTRIES_PER_CLUSTER macro is used to calculate sector offsets for directories.  The position of the 
.................... //              entry is shifted by 4 bits (divided by 16, since there are 16 entries in a sector) to calculate how many sectors a 
.................... //              specified entry is offset from the beginning of the directory. 
.................... #define VALUE_BASED_ON_ENTRIES_PER_CLUSTER      4 
....................  
.................... // Summary: A value that will indicate that a dotdot directory entry points to the root. 
.................... // Description: The VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT macro is used as an absolute address when writing information to a dotdot entry 
.................... //              in a newly created directory.  If a dotdot entry points to the root directory, it's cluster value must be set to 0, 
.................... //              regardless of the actual cluster number of the root directory. 
.................... #define VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT     0 
....................  
.................... // Summary: MAcro indicating the length of an 8.3 file name in a directory entry 
.................... // Description: The FILE_NAME_SIZE_8P3 macro indicates the number of characters that an 8.3 file name will take up when packed in 
.................... //              a directory entry.  This value includes 8 characters for the name and 3 for the extension.  Note that the radix is not 
.................... //              stored in the directory entry. 
.................... #define FILE_NAME_SIZE_8P3           11 
.................... #define FILE_NAME_SIZE               FILE_NAME_SIZE_8P3 
....................  
....................  
.................... // Summary: Contains file information and is used to indicate which file to access. 
.................... // Description: The FSFILE structure is used to hold file information for an open file as it's being modified or accessed.  A pointer to  
.................... //              an open file's FSFILE structure will be passeed to any library function that will modify that file. 
.................... typedef struct 
.................... { 
....................     DISK    *       dsk;            // Pointer to a DISK structure 
....................     DWORD           cluster;        // The first cluster of the file 
....................     DWORD           ccls;           // The current cluster of the file 
....................     WORD            sec;            // The current sector in the current cluster of the file 
....................     WORD            pos;            // The position in the current sector 
....................     DWORD           seek;           // The absolute position in the file 
....................     DWORD           size;           // The size of the file 
....................     FILEFLAGS       flags;          // A structure containing file flags 
....................     WORD            time;           // The file's last update time 
....................     WORD            date;           // The file's last update date 
....................     char            name[FILE_NAME_SIZE_8P3];       // The short name of the file 
....................    #ifdef SUPPORT_LFN 
....................        BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNptr;           // Pointer to long file name in UTF16 format 
....................       unsigned short int utf16LFNlength;          // LFN length in terms of words excluding the NULL word at the last. 
....................    #endif 
....................     WORD            entry;          // The position of the file's directory entry in it's directory 
....................     WORD            chk;            // File structure checksum 
....................     WORD            attributes;     // The file attributes 
....................     DWORD           dirclus;        // The base cluster of the file's directory 
....................     DWORD           dirccls;        // The current cluster of the file's directory 
.................... } FSFILE; 
....................  
.................... /* Summary: Possible results of the FSGetDiskProperties() function. 
.................... ** Description: See the FSGetDiskProperties() function for more information. 
.................... */ 
.................... typedef enum 
.................... { 
....................     FS_GET_PROPERTIES_NO_ERRORS = 0, 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED, 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE, 
....................     FS_GET_PROPERTIES_STILL_WORKING = 0xFF 
.................... } FS_DISK_ERRORS; 
....................  
....................  
.................... /* Summary: Contains the disk search information, intermediate values, and results 
.................... ** Description: This structure is used in conjunction with the FSGetDiskProperties() 
.................... **              function.  See that function for more information about the usage. 
.................... */ 
.................... typedef struct 
.................... { 
....................     DISK *  disk;           /* pointer to the disk we are searching */ 
....................     BOOL    new_request;    /* is this a new request or a continued request */ 
....................     FS_DISK_ERRORS properties_status;  /* status of the last call of the function */ 
....................  
....................     struct 
....................     { 
....................         BYTE disk_format;           /* disk format: FAT12, FAT16, FAT32 */ 
....................         WORD sector_size;           /* sector size of the drive */ 
....................         BYTE sectors_per_cluster;   /* number of sectors per cluster */ 
....................         DWORD total_clusters;       /* the number of total clusters on the drive */ 
....................         DWORD free_clusters;        /* the number of free (unused) clusters on drive */ 
....................     } results;                      /* the results of the current search */ 
....................  
....................     struct 
....................     { 
....................         DWORD   c;      
....................         DWORD   curcls; 
....................         DWORD   EndClusterLimit; 
....................         DWORD   ClusterFailValue; 
....................     } private;      /* intermediate values used to continue searches.  This 
....................                          member should be used only by the FSGetDiskProperties() 
....................                          function */ 
....................  
.................... } FS_DISK_PROPERTIES; 
....................  
.................... // Summary: A structure used for searching for files on a device. 
.................... // Description: The SearchRec structure is used when searching for file on a device.  It contains parameters that will be loaded with 
.................... //              file information when a file is found.  It also contains the parameters that the user searched for, allowing further 
.................... //              searches to be perfomed in the same directory for additional files that meet the specified criteria. 
.................... typedef struct 
.................... { 
....................     char            filename[FILE_NAME_SIZE_8P3 + 2];   // The name of the file that has been found 
....................     unsigned char   attributes;                     // The attributes of the file that has been found 
....................     unsigned long   filesize;                       // The size of the file that has been found 
....................     unsigned long   timestamp;                      // The last modified time of the file that has been found (create time for directories) 
....................    #ifdef SUPPORT_LFN 
....................       BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNfound;          // Pointer to long file name found in UTF16 format 
....................       unsigned short int utf16LFNfoundLength;     // LFN Found length in terms of words including the NULL word at the last. 
....................    #endif 
....................     unsigned int    entry;                          // The directory entry of the last file found that matches the specified attributes. (Internal use only) 
....................     char            searchname[FILE_NAME_SIZE_8P3 + 2]; // The 8.3 format name specified when the user began the search. (Internal use only) 
....................     unsigned char   searchattr;                     // The attributes specified when the user began the search. (Internal use only) 
....................     unsigned long   cwdclus;                        // The directory that this search was performed in. (Internal use only) 
....................     unsigned char   initialized;                    // Check to determine if the structure was initialized by FindFirst (Internal use only) 
.................... } SearchRec; 
....................  
....................  
.................... /*************************************************************************** 
.................... * Prototypes                                                               * 
.................... ***************************************************************************/ 
....................  
....................  
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     int FSInit(void) 
....................   Summary: 
....................     Function to initialize the device. 
....................   Conditions: 
....................     The physical device should be connected to the microcontroller. 
....................   Input: 
....................     None 
....................   Return Values: 
....................     TRUE -  Initialization successful 
....................     FALSE - Initialization unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function initializes the file system stack & the interfacing device. 
....................     Initializes the static or dynamic memory slots for holding file 
....................     structures. Initializes the device with the DISKmount function. Loads  
....................     MBR and boot sector information. Initializes the current working 
....................     directory to the root directory for the device if directory support 
....................     is enabled. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... int FSInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * FSfopen (const char * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with ascii input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will open a ascii name file or directory on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * FSfopen(const char * fileName, const char *mode); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * wFSfopen (const unsigned short int * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * wFSfopen(const unsigned short int * fileName, const char *mode); 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................  
.................... /****************************************************************************** 
....................   Function: 
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode) 
....................   Summary: 
....................     Opens a file on PIC18 Microcontrollers where 'fileName' ROM string is given 
....................     in Ascii format. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to be opened (ROM) 
....................     mode -      The mode the file will be opened in (ROM) 
....................   Return Values: 
....................     FSFILE * - A pointer to the file object 
....................     NULL -     File could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file on PIC18 Microcontrollers where 'fileName' ROM string 
....................     is given in Ascii format.The FSfopenpgm function will copy a PIC18 ROM fileName and 
....................     mode argument into RAM arrays, and then pass those arrays to the FSfopen function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   ******************************************************************************/ 
....................  
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode); 
....................  
....................  
.................... /************************************************************************************** 
....................   Function: 
....................     int FindFirstpgm (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Find a file named with a ROM string on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName -  The name of the file to be found (ROM) 
....................     attr -      The attributes of the file to be found 
....................     rec -       Pointer to a search record to store the file info in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the given parameters was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirstpgm call on passed SearchRec object 
....................     will be lost.The FSerrno variable will be changed. 
....................   Description: 
....................     This function finds a file named with 'fileName' on PIC18. The FindFirstpgm 
....................     function will copy a PIC18 ROM fileName argument into a RAM array, and then 
....................     pass that array to the FindFirst function. 
....................   Remarks: 
....................     Call FindFirstpgm or FindFirst before calling FindNext. 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************************/ 
....................  
....................     int FindFirstpgm (const rom char * fileName, unsigned int attr, SearchRec * rec); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdirpgm (const rom char * path) 
....................   Summary: 
....................     Changes the CWD to the input path on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to (ROM) 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the CWD to the input path on PIC18.The FSchdirpgm function 
....................     passes a PIC18 ROM path pointer to the chdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM 
....................   **************************************************************************/ 
....................  
....................     int FSchdirpgm (const rom char * path); 
....................  
....................     #ifdef ALLOW_WRITES 
....................  
....................  
.................... /************************************************************* 
....................   Function: 
....................     int FSremovepgm (const rom char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC18 device 
....................   Conditions: 
....................     File not opened; file exists 
....................   Input: 
....................     fileName -  The name of the file to be deleted (ROM) 
....................   Return Values: 
....................     0 -  File was removed successfully 
....................     -1 - File could not be removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC18 device.The FSremovepgm function will copy a 
....................     PIC18 ROM fileName argument into a RAM array, and then pass that array 
....................     to the FSremove function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   *************************************************************/ 
....................  
....................         int FSremovepgm (const rom char * fileName); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdirpgm (const rom char * path) 
....................   Summary: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create (ROM) 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices.'FSmkdirpgm' creates the directories as per the input 
....................     string path.This function doesn't move the current working 
....................     directory setting. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arugments in ROM 
....................   **************************************************************************/ 
....................  
....................         int FSmkdirpgm (const rom char * path); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdirpgm (const rom char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     path -      The path of the directory to remove (ROM) 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................     This function deletes the directory as specified in the path. 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************/ 
....................  
....................         int FSrmdirpgm (const rom char * path, unsigned char rmsubdirs); 
....................  
....................  
.................... /***************************************************************** 
....................   Function: 
....................     int FSrenamepgm(const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the file with the ascii ROM string(PIC18) 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file (in ROM) 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -  File renamed successfully 
....................     -1 - File could not be renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the file with the ascii ROM string(PIC18).The Fsrenamepgm 
....................     function will copy the rom fileName specified by the user into a  
....................     RAM array and pass that array into the FSrename function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM.                        
....................   *****************************************************************/ 
....................  
....................         int FSrenamepgm (const rom char * fileName, FSFILE * fo); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************ 
....................   Function: 
....................     int FSfclose(FSFILE *fo) 
....................   Summary: 
....................     Update file information and free FSFILE objects 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to the file to close 
....................   Return Values: 
....................     0 -   File closed successfully  
....................     EOF - Error closing the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will update the directory entry for the  
....................     file pointed to by 'fo' with the information contained 
....................     in 'fo,' including the new file size and attributes. 
....................     Timestamp information will also be loaded based on the 
....................     method selected by the user and written to the entry 
....................     as the last modified time and date.  The file entry will 
....................     then be written to the device.  Finally, the memory 
....................     used for the specified file object will be freed from 
....................     the dynamic heap or the array of FSFILE objects. 
....................   Remarks: 
....................     A function to flush data to the device without closing the 
....................     file can be created by removing the portion of this 
....................     function that frees the memory and the line that clears 
....................     the write flag. 
....................   ************************************************************/ 
....................  
.................... int FSfclose(FSFILE *fo); 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     void FSrewind (FSFILE * fo) 
....................   Summary: 
....................     Set the current position in a file to the beginning 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The FSrewind funciton will reset the position of the 
....................     specified file to the beginning of the file.  This 
....................     functionality is faster than using FSfseek to reset 
....................     the position in the file. 
....................   Remarks: 
....................     None. 
....................   *********************************************************/ 
....................  
.................... void FSrewind (FSFILE *fo); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Read data from a file 
....................   Conditions: 
....................     File is opened in a read mode 
....................   Input: 
....................     ptr -     Destination buffer for read bytes 
....................     size -    Size of units in bytes 
....................     n -       Number of units to be read 
....................     stream -  File to be read from 
....................   Return: 
....................     size_t - number of units read 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfread function will read data from the specified file.  First, 
....................     the appropriate sector of the file is loaded.  Then, data is read into 
....................     the specified buffer until the specified number of bytes have been read. 
....................     When a cluster boundary is reached, a new cluster will be loaded.  The 
....................     parameters 'size' and 'n' indicate how much data to read.  'Size' 
....................     refers to the size of one object to read (in bytes), and 'n' will refer  
....................     to the number of these objects to read.  The value returned will be equal  
....................     to 'n' unless an error occured or the user tried to read beyond the end 
....................     of the file. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream); 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FSfseek(FSFILE *stream, long offset, int whence) 
....................   Summary: 
....................     Change the current position in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     stream -    Pointer to file structure 
....................     offset -    Offset from base location 
....................     whence -     
....................            - SEEK_SET -  Seek from start of file 
....................            - SEEK_CUR -  Seek from current location 
....................            - SEEK_END -  Seek from end of file (subtract offset) 
....................   Return Values: 
....................     0 -  Operation successful  
....................     -1 - Operation unsuccesful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfseek function will change the current position in the file to 
....................     one specified by the user.  First, an absolute offset is calculated 
....................     using the offset and base location passed in by the user.  Then, the 
....................     position variables are updated, and the sector number that corresponds 
....................     to the new location.  That sector is then loaded.  If the offset 
....................     falls exactly on a cluster boundary, a new cluster will be allocated 
....................     to the file and the position will be set to the first byte of that 
....................     cluster. 
....................   Remarks: 
....................     None                                                                
....................   **********************************************************************/ 
....................  
.................... int FSfseek(FSFILE *stream, long offset, int whence); 
....................  
....................  
.................... /******************************************************************* 
....................   Function: 
....................     long FSftell (FSFILE * fo) 
....................   Summary: 
....................     Determine the current location in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return: Current location in the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     The FSftell function will return the current position in the 
....................     file pointed to by 'fo' by returning the 'seek' variable in the 
....................     FSFILE object, which is used to keep track of the absolute 
....................     location of the current position in the file. 
....................   Remarks: 
....................     None                                                             
....................   *******************************************************************/ 
....................  
.................... long FSftell(FSFILE *fo); 
....................  
....................  
.................... /**************************************************** 
....................   Function: 
....................     int FSfeof( FSFILE * stream ) 
....................   Summary: 
....................     Indicate whether the current file position is at the end 
....................   Conditions: 
....................     File is open in a read mode 
....................   Input: 
....................     stream -  Pointer to the target file 
....................   Return Values: 
....................     Non-Zero - EOF reached  
....................     0 - Not at end of File 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfeof function will indicate that the end-of- 
....................     file has been reached for the specified file by 
....................     comparing the absolute location in the file to the 
....................     size of the file. 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... int FSfeof( FSFILE * stream ); 
....................  
....................  
.................... #ifdef ALLOW_FORMATS 
.................... /******************************************************************* 
....................   Function: 
....................     int FSformat (char mode, long int serialNumber, char * volumeID) 
....................   Summary: 
....................     Formats a device 
....................   Conditions: 
....................     The device must possess a valid master boot record. 
....................   Input: 
....................     mode -          - 0 - Just erase the FAT and root 
....................                     - 1 - Create a new boot sector 
....................     serialNumber -  Serial number to write to the card 
....................     volumeID -      Name of the card 
....................   Return Values: 
....................     0 -    Format was successful 
....................     EOF -  Format was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSformat function can be used to create a new boot sector 
....................     on a device, based on the information in the master boot record. 
....................     This function will first initialize the I/O pins and the device, 
....................     and then attempts to read the master boot record.  If the MBR 
....................     cannot be loaded successfully, the function will fail.  Next, if 
....................     the 'mode' argument is specified as '0' the existing boot sector 
....................     information will be loaded.  If the 'mode' argument is '1' an 
....................     entirely new boot sector will be constructed using the disk 
....................     values from the master boot record.  Once the boot sector has 
....................     been successfully loaded/created, the locations of the FAT and 
....................     root will be loaded from it, and they will be completely 
....................     erased.  If the user has specified a volumeID parameter, a  
....................     VOLUME attribute entry will be created in the root directory 
....................     to name the device. 
....................  
....................     FAT12, FAT16 and FAT32 formatting are supported. 
....................  
....................     Based on the number of sectors, the format function automatically 
....................     compute the smallest possible value for the cluster size in order to 
....................     accommodate the physical size of the media. In this case, if a media  
....................     with a big capacity is formatted, the format function may take a very 
....................     long time to write all the FAT tables.  
....................  
....................     Therefore, the FORMAT_SECTORS_PER_CLUSTER macro may be used to  
....................     specify the exact cluster size (in multiples of sector size). This  
....................     macro can be defined in FSconfig.h 
....................  
....................   Remarks: 
....................     Only devices with a sector size of 512 bytes are supported by the  
....................     format function                       
....................   *******************************************************************/ 
....................  
.................... int FSformat (char mode, long int serialNumber, char * volumeID); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_WRITES 
.................... /*************************************************************************** 
....................   Function: 
....................     int FSattrib (FSFILE * file, unsigned char attributes) 
....................   Summary: 
....................     Change the attributes of a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     file -        Pointer to file structure 
....................     attributes -  The attributes to set for the file 
....................                -  Attribute -      Value - Indications  
....................                -  ATTR_READ_ONLY - 0x01  - The read-only attribute 
....................                -  ATTR_HIDDEN -    0x02  - The hidden attribute  
....................                -  ATTR_SYSTEM -    0x04  - The system attribute  
....................                -  ATTR_ARCHIVE -   0x20  - The archive attribute 
....................   Return Values: 
....................     0 -  Attribute change was successful  
....................     -1 - Attribute change was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSattrib funciton will set the attributes of the specified file 
....................     to the attributes passed in by the user.  This function will load the 
....................     file entry, replace the attributes with the ones specified, and write 
....................     the attributes back.  If the specified file is a directory, the 
....................     directory attribute will be preserved. 
....................   Remarks: 
....................     None                                                                 
....................   ***************************************************************************/ 
....................  
.................... int FSattrib (FSFILE * file, unsigned char attributes); 
....................  
....................  
.................... /*************************************************************** 
....................   Function: 
....................     int FSrename (const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices. 
....................     First, it will search through the current working directory to ensure the 
....................     specified new filename is not already in use. If it isn't, the new filename 
....................     will be written to the file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None                                                         
....................   ***************************************************************/ 
....................  
.................... int FSrename (const char * fileName, FSFILE * fo); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*************************************************************** 
....................   Function: 
....................     int wFSrename (const rom unsigned short int * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices. First, it will search through the current 
....................     working directory to ensure the specified new UTF16 filename is not 
....................     already in use.  If it isn't, the new filename will be written to the 
....................     file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None 
....................   ***************************************************************/ 
....................  
.................... int wFSrename (const unsigned short int * fileName, FSFILE * fo); 
.................... #endif 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     int FSremove (const char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed  
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................     The FSremove function will attempt to find the specified file with the FILEfind 
....................     function.  If the file is found, it will be erased using the FILEerase function. 
....................     The user can also provide ascii alias name of the ascii long file name as the 
....................     input to this function to get it erased from the memory. 
....................   Remarks: 
....................     None                                        
....................   **********************************************************************/ 
....................  
.................... int FSremove (const char * fileName); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     int wFSremove (const unsigned short int * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed 
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................     The wFSremove function will attempt to find the specified UTF16 file 
....................     name with the FILEfind function. If the file is found, it will be erased 
....................     using the FILEerase function. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int wFSremove (const unsigned short int * fileName); 
.................... #endif 
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Write data to a file 
....................   Conditions: 
....................     File opened in FS_WRITE, FS_APPEND, FS_WRITE+, FS_APPEND+, FS_READ+ mode 
....................   Input: 
....................     data_to_write -     Pointer to source buffer 
....................     size -              Size of units in bytes 
....................     n -                 Number of units to transfer 
....................     stream -            Pointer to file structure 
....................   Return: 
....................     size_t - number of units written 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfwrite function will write data to a file.  First, the sector that 
....................     corresponds to the current position in the file will be loaded (if it hasn't 
....................     already been cached in the global data buffer).  Data will then be written to 
....................     the device from the specified buffer until the specified amount has been written. 
....................     If the end of a cluster is reached, the next cluster will be loaded, unless 
....................     the end-of-file flag for the specified file has been set.  If it has, a new 
....................     cluster will be allocated to the file.  Finally, the new position and filesize 
....................     will be stored in the FSFILE object.  The parameters 'size' and 'n' indicate how  
....................     much data to write.  'Size' refers to the size of one object to write (in bytes),  
....................     and 'n' will refer to the number of these objects to write.  The value returned  
....................     will be equal  to 'n' unless an error occured. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************************/ 
....................  
.................... size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream); 
....................  
.................... #endif 
....................  
.................... #ifdef ALLOW_DIRS 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdir (char * path) 
....................   Summary: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC). 
....................     The FSchdir function passes a RAM pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSchdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSchdir (unsigned short int * path) 
....................   Summary: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC).The FSchdir function passes a RAM 
....................     pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSchdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************** 
....................   Function: 
....................     char * FSgetcwd (char * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in Ascii format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in Ascii format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * FSgetcwd (char * path, int numbchars); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************** 
....................   Function: 
....................     char * wFSgetcwd (unsigned short int * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in UTF16 format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in UTF16 format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * wFSgetcwd (unsigned short int * path, int numbchars); 
.................... #endif 
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdir (char * path) 
....................   Summary: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSmkdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSmkdir (unsigned short int * path) 
....................   Summary: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSmkdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdir (char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int FSrmdir (char * path, unsigned char rmsubdirs); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs) 
....................   Summary: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs); 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................  
....................  
.................... /*********************************************************************************************************** 
....................   Function: 
....................     int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second) 
....................   Summary: 
....................     Manually set timestamp variables 
....................   Conditions: 
....................     USERDEFINEDCLOCK macro defined in FSconfig.h. 
....................   Input: 
....................     year -     The year (1980\-2107) 
....................     month -   The month (1\-12) 
....................     day -     The day of the month (1\-31) 
....................     hour -    The hour (0\-23) 
....................     minute -  The minute (0\-59) 
....................     second -  The second (0\-59) 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     Modifies global timing variables 
....................   Description: 
....................     Lets the user manually set the timing variables.  The values passed in will be converted to the format 
....................     used by the FAT timestamps. 
....................   Remarks: 
....................     Call this before creating a file or directory (set create time) and 
....................     before closing a file (set last access time, last modified time)                                         
....................   ***********************************************************************************************************/ 
....................  
.................... int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_FILESEARCH 
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................     The FindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*********************************************************************************** 
....................   Function: 
....................     int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous wFindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent wFindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................     The wFindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec); 
.................... #endif 
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FindNext (SearchRec * rec) 
....................   Summary: 
....................     Sequential search function 
....................   Conditions: 
....................     None 
....................   Input: 
....................     rec -  The structure to store the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No additional files matching the specified criteria were found 
....................   Side Effects: 
....................     Search criteria from previous FindNext call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     The FindNext function performs the same function as the FindFirst 
....................     funciton, except it does not copy any search parameters into the 
....................     SearchRec structure (only info about found files) and it begins 
....................     searching at the last directory entry offset at which a file was 
....................     found, rather than at the beginning of the current working 
....................     directory.If the return value of the function is 0 then "utf16LFNfoundLength" 
....................     indicates whether the file found was long file name or short file 
....................     name(8P3 format). The "utf16LFNfoundLength" is non-zero for long file name 
....................     and is zero for 8P3 format."utf16LFNfound" points to the address of long  
....................     file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling this function 
....................   **********************************************************************/ 
....................  
.................... int FindNext (SearchRec * rec);  
.................... #endif 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int FSfprintf (FSFILE * fptr, const char * fmt, ...) 
....................     // PIC18 
....................     int FSfpritnf (FSFILE * fptr, const rom char * fmt, ...) 
....................   Summary: 
....................     Function to write formatted strings to a file 
....................   Conditions: 
....................     For PIC18, integer promotion must be enabled in the project build 
....................     options menu.  File opened in a write mode. 
....................   Input: 
....................     fptr - A pointer to the file to write to. 
....................     fmt -  A string of characters and format specifiers to write to 
....................            the file 
....................     ... -  Additional arguments inserted in the string by format 
....................            specifiers 
....................   Returns: 
....................     The number of characters written to the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Writes a specially formatted string to a file. 
....................   Remarks: 
....................     Consult AN1045 for a full description of how to use format 
....................     specifiers.         
....................   **********************************************************************/ 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................     #ifdef __18CXX 
....................         int FSfprintf (FSFILE *fptr, const rom char *fmt, ...); 
....................     #else 
....................         int FSfprintf (FSFILE *fptr, const char * fmt, ...); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSerror (void) 
....................   Summary: 
....................     Return an error code for the last function call 
....................   Conditions: 
....................     The return value depends on the last function called. 
....................   Input: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Return Values: 
....................     FSInit       -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The physical media could not be initialized 
....................                  - CE_BAD_SECTOR_READ        The MBR or the boot sector could not be 
....................                                               read correctly 
....................                  - CE_BAD_PARITION           The MBR signature code was incorrect. 
....................                  - CE_NOT_FORMATTED          The boot sector signature code was incorrect or 
....................                                               indicates an invalid number of bytes per sector.  
....................                  - CE_CARDFAT32              The physical media is FAT32 type (only an error  
....................                                               when FAT32 support is disabled).  
....................                  - CE_UNSUPPORTED_FS         The device is formatted with an unsupported file  
....................                                               system (not FAT12 or 16). 
....................     FSfopen      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The device has not been initialized.  
....................                  - CE_TOO_MANY_FILES_OPEN    The function could not allocate any  
....................                                               additional file information to the array  
....................                                               of FSFILE structures or the heap.  
....................                  - CE_INVALID_FILENAME       The file name argument was invalid. 
....................                  - CE_INVALID_ARGUMENT       The user attempted to open a directory in a  
....................                                               write mode or specified an invalid mode argument.  
....................                  - CE_FILE_NOT_FOUND         The specified file (which was to be opened in read  
....................                                               mode) does not exist on the device.  
....................                  - CE_BADCACHEREAD           A read from the device failed. 
....................                  - CE_ERASE_FAIL             The existing file could not be erased (when opening  
....................                                               a file in FS_WRITE mode).  
....................                  - CE_DIR_FULL               The directory is full.  
....................                  - CE_DISK_FULL              The data memory section is full.  
....................                  - CE_WRITE_ERROR            A write to the device failed.  
....................                  - CE_SEEK_ERROR             The current position in the file could not be set to  
....................                                               the end (when the file was opened in FS_APPEND mode). 
....................     FSfclose     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer or the new file 
....................                                               entry information could not be written to the device. 
....................                  - CE_BADCACHEREAD           The file entry information could not be cached 
....................     FSfread      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITEONLY              The file was opened in a write-only mode. 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device.  
....................                  - CE_BAD_SECTOR_READ        The data sector could not be read.  
....................                  - CE_EOF                    The end of the file was reached. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be loaded. 
....................     FSfwrite     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_READONLY               The file was opened in a read-only mode.  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected. 
....................                  - CE_WRITE_ERROR            There was an error writing data to the device. 
....................                  - CE_BADCACHEREAD           The data sector to be modified could not be read from 
....................                                               the device.  
....................                  - CE_DISK_FULL              All data clusters on the device are in use. 
....................     FSfseek      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device.  
....................                  - CE_INVALID_ARGUMENT       The specified offset exceeds the size of the file.  
....................                  - CE_BADCACHEREAD           The sector that contains the new current position  
....................                                               could not be loaded. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be  
....................                                               loaded/allocated. 
....................     FSftell      -  
....................                  - CE_GOOD                   No Error 
....................     FSattrib     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The attribute argument was invalid.  
....................                  - CE_BADCACHEREAD           The existing file entry information could not be  
....................                                               loaded.  
....................                  - CE_WRITE_ERROR            The file entry information could not be written to  
....................                                               the device. 
....................     FSrename     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_FILENOTOPENED          A null file pointer was passed into the function.  
....................                  - CE_INVALID_FILENAME       The file name passed into the function was invalid.  
....................                  - CE_BADCACHEREAD           A read from the device failed.  
....................                  - CE_FILENAME_EXISTS        A file with the specified name already exists.  
....................                  - CE_WRITE_ERROR            The new file entry data could not be written to the  
....................                                               device. 
....................     FSfeof       - 
....................                  - CE_GOOD                   No Error 
....................     FSformat     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The device could not be initialized.  
....................                  - CE_BADCACHEREAD           The master boot record or boot sector could not be  
....................                                               loaded successfully.  
....................                  - CE_INVALID_ARGUMENT       The user selected to create their own boot sector on  
....................                                               a device that has no master boot record, or the mode  
....................                                               argument was invalid.  
....................                  - CE_WRITE_ERROR            The updated MBR/Boot sector could not be written to  
....................                                               the device. 
....................                  - CE_BAD_PARTITION          The calculated number of sectors per clusters was  
....................                                               invalid.  
....................                  - CE_NONSUPPORTED_SIZE      The card has too many sectors to be formatted as  
....................                                               FAT12 or FAT16. 
....................     FSremove     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         The specified file could not be found. 
....................                  - CE_ERASE_FAIL             The file could not be erased. 
....................     FSchdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed or the user tried to  
....................                                               change to a non-directory file. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_FOUND          Could not find a directory in the path. 
....................     FSgetcwd     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The user passed a 0-length buffer into the function. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the current working directory. 
....................     FSmkdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed. 
....................                  - CE_BADCACHEREAD           Could not successfully change to a recently created  
....................                                               directory to store its dir entry information, or  
....................                                               could not cache directory entry information.  
....................                  - CE_INVALID_FILENAME       One or more of the directory names has an invalid  
....................                                               format.  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device or the dot/dotdot entries could  
....................                                               not be written to a newly created directory. 
....................                  - CE_DIR_FULL               There are no available dir entries in the CWD. 
....................                  - CE_DISK_FULL              There are no available clusters in the data region of  
....................                                               the device.     
....................     FSrmdir      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_DIR_NOT_FOUND          The directory specified could not be found or the  
....................                                               function could not change to a subdirectory within  
....................                                               the directory to be deleted (when recursive delete is  
....................                                               enabled). 
....................                  - CE_INVALID_ARGUMENT       The user tried to remove the CWD or root directory.  
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_EMPTY          The directory to be deleted was not empty and  
....................                                               recursive subdirectory removal was disabled.  
....................                  - CE_ERASE_FAIL             The directory or one of the directories or files  
....................                                               within it could not be deleted.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the CWD. 
....................     SetClockVars - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The time values passed into the function were  
....................                                               invalid.     
....................     FindFirst    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found.  
....................                  - CE_BADCACHEREAD           The file information for the file that was found  
....................                                               could not be cached. 
....................     FindNext     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The SearchRec object was not initialized by a call to  
....................                                               FindFirst.  
....................                  - CE_INVALID_ARGUMENT       The SearchRec object was initialized in a different  
....................                                               directory from the CWD. 
....................                  - CE_INVALID_FILENAME       The filename is invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found. 
....................     FSfprintf    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            Characters could not be written to the file.                                                    
....................   Description: 
....................     The FSerror function will return the FSerrno variable.  This global 
....................     variable will have been set to an error value during the last call of a 
....................     library function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... int FSerror (void); 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     int FSCreateMBR (unsigned long firstSector, unsigned long numSectors) 
....................   Summary: 
....................     Creates a master boot record 
....................   Conditions: 
....................     The I/O pins for the device have been initialized by the InitIO function. 
....................   Input: 
....................     firstSector -  The first sector of the partition on the device (cannot 
....................                    be 0; that's the MBR) 
....................     numSectors -   The number of sectors available in memory (including the 
....................                    MBR) 
....................   Return Values: 
....................     0 -   MBR was created successfully 
....................     EOF - MBR could not be created 
....................   Side Effects: 
....................     None 
....................   Description:   
....................     This function can be used to create a master boot record for a device.  Note 
....................     that this function should not be used on a device that is already formatted 
....................     with a master boot record (i.e. most SD cards, CF cards, USB keys).  This 
....................     function will fill the global data buffer with appropriate partition information 
....................     for a FAT partition with a type determined by the number of sectors available 
....................     to the partition.  It will then write the MBR information to the first sector 
....................     on the device.  This function should be followed by a call to FSformat, which 
....................     will create a boot sector, root dir, and FAT appropriate the the information 
....................     contained in the new master boot record.  Note that FSformat only supports 
....................     FAT12 and FAT16 formatting at this time, and so cannot be used to format a 
....................     device with more than 0x3FFD5F sectors. 
....................   Remarks: 
....................     This function can damage the device being used, and should not be called 
....................     unless the user is sure about the size of the device and the first sector value. 
....................   *********************************************************************************/ 
....................  
.................... int FSCreateMBR (unsigned long firstSector, unsigned long numSectors); 
....................  
....................  
.................... #ifdef ALLOW_GET_DISK_PROPERTIES 
.................... /********************************************************************************* 
....................   Function: 
....................     void FSGetDiskProperties(FS_DISK_PROPERTIES* properties) 
....................   Summary: 
....................     Allows user to get the disk properties (size of disk, free space, etc) 
....................   Conditions: 
....................     1) ALLOW_GET_DISK_PROPERTIES must be defined in FSconfig.h 
....................     2) a FS_DISK_PROPERTIES object must be created before the function is called 
....................     3) the new_request member of the FS_DISK_PROPERTIES object must be set before 
....................         calling the function for the first time.  This will start a new search. 
....................     4) this function should not be called while there is a file open.  Close all 
....................         files before calling this function. 
....................   Input: 
....................     properties - a pointer to a FS_DISK_PROPERTIES object where the results should 
....................       be stored. 
....................   Return Values: 
....................     This function returns void.  The properties_status of the previous call of  
....................       this function is located in the properties.status field.  This field has  
....................       the following possible values: 
....................  
....................     FS_GET_PROPERTIES_NO_ERRORS - operation completed without error.  Results 
....................       are in the properties object passed into the function. 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED - there is no mounted disk.  Results in 
....................       properties object is not valid 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE - there was a failure trying to read a  
....................       cluster from the drive.  The results in the properties object is a partial 
....................       result up until the point of the failure. 
....................     FS_GET_PROPERTIES_STILL_WORKING - the search for free sectors is still in 
....................       process.  Continue calling this function with the same properties pointer  
....................       until either the function completes or until the partial results meets the 
....................       application needs.  The properties object contains the partial results of 
....................       the search and can be used by the application.   
....................   Side Effects: 
....................     Can cause errors if called when files are open.  Close all files before 
....................     calling this function. 
....................  
....................     Calling this function without setting the new_request member on the first 
....................     call can result in undefined behavior and results. 
....................  
....................     Calling this function after a result is returned other than 
....................     FS_GET_PROPERTIES_STILL_WORKING can result in undefined behavior and results. 
....................   Description:   
....................     This function returns the information about the mounted drive.  The results  
....................     member of the properties object passed into the function is populated with  
....................     the information about the drive.     
....................  
....................     Before starting a new request, the new_request member of the properties 
....................     input parameter should be set to TRUE.  This will initiate a new search 
....................     request. 
....................  
....................     This function will return before the search is complete with partial results. 
....................     All of the results except the free_clusters will be correct after the first 
....................     call.  The free_clusters will contain the number of free clusters found up 
....................     until that point, thus the free_clusters result will continue to grow until 
....................     the entire drive is searched.  If an application only needs to know that a  
....................     certain number of bytes is available and doesn't need to know the total free  
....................     size, then this function can be called until the required free size is 
....................     verified.  To continue a search, pass a pointer to the same FS_DISK_PROPERTIES 
....................     object that was passed in to create the search. 
....................  
....................     A new search request sould be made once this function has returned a value  
....................     other than FS_GET_PROPERTIES_STILL_WORKING.  Continuing a completed search 
....................     can result in undefined behavior or results. 
....................  
....................     Typical Usage: 
....................     <code> 
....................     FS_DISK_PROPERTIES disk_properties; 
....................  
....................     disk_properties.new_request = TRUE; 
....................  
....................     do 
....................     { 
....................         FSGetDiskProperties(&disk_properties); 
....................     } while (disk_properties.properties_status == FS_GET_PROPERTIES_STILL_WORKING); 
....................     </code> 
....................  
....................     results.disk_format - contains the format of the drive.  Valid results are  
....................       FAT12(1), FAT16(2), or FAT32(3). 
....................  
....................     results.sector_size - the sector size of the mounted drive.  Valid values are 
....................       512, 1024, 2048, and 4096. 
....................  
....................     results.sectors_per_cluster - the number sectors per cluster. 
....................  
....................     results.total_clusters - the number of total clusters on the drive.  This  
....................       can be used to calculate the total disk size (total_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................     results.free_clusters - the number of free (unallocated) clusters on the drive. 
....................       This can be used to calculate the total free disk size (free_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................   Remarks: 
....................     PIC24F size estimates: 
....................       Flash - 400 bytes (-Os setting) 
....................  
....................     PIC24F speed estimates: 
....................       Search takes approximately 7 seconds per Gigabyte of drive space.  Speed 
....................         will vary based on the number of sectors per cluster and the sector size. 
....................   *********************************************************************************/ 
.................... void FSGetDiskProperties(FS_DISK_PROPERTIES* properties); 
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE FILEget_next_cluster(FSFILE *fo, DWORD n) 
....................   Summary: 
....................     Step through a chain of clusters 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fo - The file to get the next cluster of 
....................     n -  Number of links in the FAT cluster chain to jump through 
....................   Return Values: 
....................     CE_GOOD - Operation successful 
....................     CE_BAD_SECTOR_READ - A bad read occured of a sector 
....................     CE_INVALID_CLUSTER - Invalid cluster value \> maxcls 
....................     CE_FAT_EOF - Fat attempt to read beyond EOF 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will load 'n' proximate clusters for a file from 
....................     the FAT on the device.  It will stop checking for clusters if the 
....................     ReadFAT function returns an error, if it reaches the last cluster in 
....................     a file, or if the device tries to read beyond the last cluster used 
....................     by the device. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... BYTE FILEget_next_cluster(FSFILE *fo, DWORD n); 
....................  
.................... #endif 
....................  
.................... #include "MDD File System/FSDefs.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSDefs.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.2.4 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  _FSDEF__H 
.................... #define  _FSDEF__H 
....................  
.................... #include "../GenericTypeDefs.h" 
....................  
.................... // Summary: An enumeration used for various error codes. 
.................... // Description: The CETYPE enumeration is used to indicate different error conditions during device operation. 
.................... typedef enum _CETYPE 
.................... { 
....................     CE_GOOD = 0,                    // No error 
....................     CE_ERASE_FAIL,                  // An erase failed 
....................     CE_NOT_PRESENT,                 // No device was present 
....................     CE_NOT_FORMATTED,               // The disk is of an unsupported format 
....................     CE_BAD_PARTITION,               // The boot record is bad 
....................     CE_UNSUPPORTED_FS,              // The file system type is unsupported 
....................     CE_INIT_ERROR,                  // An initialization error has occured 
....................     CE_NOT_INIT,                    // An operation was performed on an uninitialized device 
....................     CE_BAD_SECTOR_READ,             // A bad read of a sector occured 
....................     CE_WRITE_ERROR,                 // Could not write to a sector 
....................     CE_INVALID_CLUSTER,             // Invalid cluster value > maxcls 
....................     CE_FILE_NOT_FOUND,              // Could not find the file on the device 
....................     CE_DIR_NOT_FOUND,               // Could not find the directory 
....................     CE_BAD_FILE,                    // File is corrupted 
....................     CE_DONE,                        // No more files in this directory 
....................     CE_COULD_NOT_GET_CLUSTER,       // Could not load/allocate next cluster in file 
....................     CE_FILENAME_2_LONG,             // A specified file name is too long to use 
....................     CE_FILENAME_EXISTS,             // A specified filename already exists on the device 
....................     CE_INVALID_FILENAME,            // Invalid file name 
....................     CE_DELETE_DIR,                  // The user tried to delete a directory with FSremove 
....................     CE_DIR_FULL,                    // All root dir entry are taken 
....................     CE_DISK_FULL,                   // All clusters in partition are taken 
....................     CE_DIR_NOT_EMPTY,               // This directory is not empty yet, remove files before deleting 
....................     CE_NONSUPPORTED_SIZE,           // The disk is too big to format as FAT16 
....................     CE_WRITE_PROTECTED,             // Card is write protected 
....................     CE_FILENOTOPENED,               // File not opened for the write 
....................     CE_SEEK_ERROR,                  // File location could not be changed successfully 
....................     CE_BADCACHEREAD,                // Bad cache read 
....................     CE_CARDFAT32,                   // FAT 32 - card not supported 
....................     CE_READONLY,                    // The file is read-only 
....................     CE_WRITEONLY,                   // The file is write-only 
....................     CE_INVALID_ARGUMENT,            // Invalid argument 
....................     CE_TOO_MANY_FILES_OPEN,         // Too many files are already open 
....................     CE_UNSUPPORTED_SECTOR_SIZE,     // Unsupported sector size 
....................     CE_EOF = 61 
.................... } CETYPE; 
....................  
....................  
.................... // Summary: A macro indicating a dir entry was found 
.................... // Description: The FOUND macro indicates that a directory entry was found in the specified position 
.................... #define FOUND       0 
....................  
.................... // Summary: A macro indicating no dir entry was found 
.................... // Description: The NOT_FOUND macro indicates that the specified directory entry to load was deleted 
.................... #define NOT_FOUND   1 
....................  
.................... // Summary: A macro indicating that no more files were found 
.................... // Description: The NO_MORE macro indicates that there are no more directory entries to search for 
.................... #define NO_MORE     2 
....................  
....................  
....................  
.................... // Summary: A macro indicating the device is formatted with FAT12 
.................... // Description: The FAT12 macro is used to indicate that the file system on the device being accessed is a FAT12 file system. 
.................... #define FAT12       1 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT16 
.................... // Description: The FAT16 macro is used to indicate that the file system on the device being accessed is a FAT16 file system. 
.................... #define FAT16       2 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT32 
.................... // Description: The FAT32 macro is used to indicate that the file system on the device being accessed is a FAT32 file system. 
.................... #define FAT32       3 
....................  
....................  
....................  
.................... // Summary: A read-only attribute macro 
.................... // Description: A macro for the read-only attribute.  A file with this attribute should not be written to.  Note that this 
.................... //              attribute will not actually prevent a write to the file; that functionality is operating-system dependant.  The 
.................... //              user should take care not to write to a read-only file. 
.................... #define ATTR_READ_ONLY      0x01 
....................  
.................... // Summary: A hidden attribute macro 
.................... // Description: A macro for the hidden attribute.  A file with this attribute may be hidden from the user, depending on the 
.................... //              implementation of the operating system. 
.................... #define ATTR_HIDDEN         0x02 
....................  
.................... // Summary: A system attribute macro 
.................... // Description: A macro for the system attribute.  A file with this attribute is used by the operating system, and should not be 
.................... //              modified.  Note that this attribute will not actually prevent a write to the file. 
.................... #define ATTR_SYSTEM         0x04 
....................  
.................... // Summary: A volume attribute macro 
.................... // Description: A macro for the volume attribute.  If the first directory entry in the root directory has the volume attribute set, 
.................... //              the device will use the name in that directory entry as the volume name. 
.................... #define ATTR_VOLUME         0x08 
....................  
.................... // Summary: A macro for the attributes for a long-file name entry 
.................... // Description: A macro for the long-name attributes.  If a directory entry is used in a long-file name implementation, it will have 
.................... //              all four lower bits set.  This indicates that any software that does not support long file names should ignore that 
.................... //              entry. 
.................... #define ATTR_LONG_NAME      0x0f 
....................  
.................... // Summary: A directory attribute macro 
.................... // Description: A macro for the directory attribute.  If a directory entry has this attribute set, the file it points to is a directory- 
.................... //              type file, and will contain directory entries that point to additional directories or files. 
.................... #define ATTR_DIRECTORY      0x10 
....................  
.................... // Summary: An archive attribute macro 
.................... // Description: A macro for the archive attribute.  This attribute will indicate to some archiving programs that the file with this 
.................... //              attribute needs to be backed up.  Most operating systems create files with the archive attribute set. 
.................... #define ATTR_ARCHIVE        0x20 
....................  
.................... // Summary: A macro for all attributes 
.................... // Description: A macro for all attributes.  The search functions in this library require an argument that determines which attributes 
.................... //              a file is allowed to have in order to be found.  If ATTR_MASK is specified as this argument, any file may be found, regardless 
.................... //              of its attributes. 
.................... #define ATTR_MASK           0x3f 
....................  
....................  
....................  
.................... // Summary: A macro to indicate an empty FAT entry 
.................... // Description: The CLUSTER_EMPTY value is used to indicate that a FAT entry and it's corresponding cluster are available. 
.................... #define CLUSTER_EMPTY               0x0000  
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT12 
.................... // Description: The LAST_CLUSTER_FAT12 macro is used when reading the FAT to indicate that the next FAT12 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT12          0xff8 
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT16 
.................... // Description: The LAST_CLUSTER_FAT16 macro is used when reading the FAT to indicate that the next FAT16 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT16          0xfff8 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT12 
.................... // Description: The END_CLUSTER_FAT12 value is used as a comparison in FAT12 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT12           0xFF7 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT16 
.................... // Description: The END_CLUSTER_FAT16 value is used as a comparison in FAT16 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT16           0xFFF7 
....................  
.................... // Summary: A macro to indicate the failure of the ReadFAT function 
.................... // Description: The CLUSTER_FAIL_FAT16 macro is used by the ReadFAT function to indicate that an error occured reading a FAT12 or FAT16 
.................... //              file allocation table.  Note that since '0xFFF8' is used for the last cluster return value in the FAT16 implementation 
.................... //              the end-of-file value '0xFFFF' can be used to indicate an error condition. 
.................... #define CLUSTER_FAIL_FAT16          0xFFFF 
....................  
....................  
....................  
.................... #ifdef SUPPORT_FAT32 
....................     // Summary: A macro to indicate the last cluster value for FAT32 
....................     // Description: The LAST_CLUSTER_FAT32 macro is used when reading the FAT to indicate that the next FAT32 entry for a file contains 
....................     //              the end-of-file value. 
....................     #define LAST_CLUSTER_FAT32      0x0FFFFFF8 
....................  
....................     // Summary: A macro to indicate the last allocatable cluster for FAT32 
....................     // Description: The END_CLUSTER_FAT32 value is used as a comparison in FAT32 to determine that the firmware has reached the end of 
....................     //              the range of allowed allocatable clusters. 
....................     #define END_CLUSTER_FAT32       0x0FFFFFF7 
....................  
....................     // Summary: A macro to indicate the failure of the ReadFAT function 
....................     // Description: The CLUSTER_FAIL_FAT32 macro is used by the ReadFAT function to indicate that an error occured reading a FAT32 
....................     //              file allocation able. 
....................     #define CLUSTER_FAIL_FAT32      0x0FFFFFFF 
....................  
.................... #endif 
....................  
.................... // Summary: A macro indicating the number of bytes in a directory entry. 
.................... // Description: The NUMBER_OF_BYTES_IN_DIR_ENTRY macro represents the number of bytes in one directory entry.  It is used to calculate 
.................... //              the number of sectors in the root directory based on information in the boot sector. 
.................... #define NUMBER_OF_BYTES_IN_DIR_ENTRY    32 
....................  
....................  
....................  
.................... // Summary: A macro for a deleted dir entry marker. 
.................... // Description: The DIR_DEL macro is used to mark a directory entry as deleted.  When a file is deleted, this value will replace the 
.................... //              first character in the file name, and will indicate that the file the entry points to was deleted. 
.................... #define DIR_DEL             0xE5 
....................  
.................... // Summary: A macro for the last dir entry marker. 
.................... // Description: The DIR_EMPTY macro is used to indicate the last entry in a directory.  Since entries in use cannot start with a 0 and 
.................... //              deleted entries start with the DIR_DEL character, a 0 will mark the end of the in-use or previously used group of 
.................... //              entries in a directory 
.................... #define DIR_EMPTY           0 
....................  
....................  
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name 
.................... // Description: The DIR_NAMESIZE macro is used when validing the name portion of 8.3 filenames 
.................... #define DIR_NAMESIZE        8 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file extension 
.................... // Description: The DIR_EXTENSION macro is used when validating the extension portion of 8.3 filenames 
.................... #define DIR_EXTENSION       3 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name and extension 
.................... // Description: The DIR_NAMECOMP macro is used when validating 8.3 filenames 
.................... #define DIR_NAMECOMP        (DIR_NAMESIZE+DIR_EXTENSION) 
....................  
....................  
....................  
.................... // Summary: A macro to write a byte to RAM 
.................... // Description: The RAMwrite macro is used to write a byte of data to a RAM array 
.................... #define RAMwrite( a, f, d) *(a+f) = d 
....................  
.................... // Summary: A macro to read a byte from RAM 
.................... // Description: The RAMread macro is used to read a byte of data from a RAM array 
.................... #define RAMread( a, f)  *(a+f) 
....................  
.................... // Summary: A macro to read a 16-bit word from RAM 
.................... // Description: The RAMreadW macro is used to read two bytes of data from a RAM array 
.................... #define RAMreadW( a, f) *(WORD *)(a+f) 
....................  
.................... // Summary: A macro to read a 32-bit word from RAM 
.................... // Description: The RAMreadD macro is used to read four bytes of data from a RAM array 
.................... #define RAMreadD( a, f) *(DWORD *)(a+f) 
....................  
....................  
....................  
.................... #ifndef EOF 
....................     // Summary: Indicates error conditions or end-of-file conditions 
....................     // Description: The EOF macro is used to indicate error conditions in some function calls.  It is also used to indicate 
....................     //              that the end-of-file has been reached. 
....................     #define EOF             ((int)-1) 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing information about the device. 
.................... // Description: The DISK structure contains information about the device being accessed. 
.................... typedef struct 
.................... {  
....................     BYTE    *   buffer;         // Address of the global data buffer used to read and write file information 
....................     DWORD       firsts;         // Logical block address of the first sector of the FAT partition on the device 
....................     DWORD       fat;            // Logical block address of the FAT 
....................     DWORD       root;           // Logical block address of the root directory 
....................     DWORD       data;           // Logical block address of the data section of the device. 
....................     WORD        maxroot;        // The maximum number of entries in the root directory. 
....................     DWORD       maxcls;         // The maximum number of clusters in the partition. 
....................     DWORD       sectorSize;     // The size of a sector in bytes 
....................     DWORD       fatsize;        // The number of sectors in the FAT 
....................     BYTE        fatcopy;        // The number of copies of the FAT in the partition 
....................     BYTE        SecPerClus;     // The number of sectors per cluster in the data region 
....................     BYTE        type;           // The file system type of the partition (FAT12, FAT16 or FAT32) 
....................     BYTE        mount;          // Device mount flag (TRUE if disk was mounted successfully, FALSE otherwise) 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... } __attribute__ ((packed)) DISK; 
.................... #else 
.................... } DISK; 
.................... #endif 
....................  
....................  
.................... #if defined(__18CXX) && !defined(__CCS__) 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef unsigned short long SWORD; 
.................... #else 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef struct 
....................     { 
....................         unsigned char array[3]; 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) SWORD; 
.................... #else 
....................     } SWORD; 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT12 file system (in the boot sector) 
.................... // Description: The _BPB_FAT12 structure provides a layout of the "bios parameter block" in the boot sector of a FAT12 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BPS;               // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD BootSec_ResrvSec;          // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD BootSec_RootDirEnts;       // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD BootSec_SPF;               // Number of sectors per FAT 
....................     WORD BootSec_SPT;               // Number of sectors per track 
....................     WORD BootSec_HeadCnt;           // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD  BootSec_Reserved;        // Reserved space 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved2;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination    
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT12; 
.................... #else 
....................     } _BPB_FAT12; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT16 file system (in the boot sector) 
.................... // Description: The _BPB_FAT16 structure provides a layout of the "bios parameter block" in the boot sector of a FAT16 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD  BootSec_BPS;              // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD  BootSec_ResrvSec;         // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD  BootSec_RootDirEnts;      // Number of root directory entries 
....................     WORD  BootSec_TotSec16;         // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD  BootSec_SPF;              // Number of sectors per FAT 
....................     WORD  BootSec_SPT;              // Number of sectors per track 
....................     WORD  BootSec_HeadCnt;          // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved;         // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination      
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT16; 
.................... #else 
....................     } _BPB_FAT16; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT32 file system (in the boot sector) 
.................... // Description: The _BPB_FAT32 structure provides a layout of the "bios parameter block" in the boot sector of a FAT32 partition. 
.................... typedef struct { 
....................     SWORD BootSec_jmpBoot;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BytsPerSec;        // Number of bytes per sector 
....................     BYTE  BootSec_SecPerClus;       // Number of sectors per cluster 
....................     WORD BootSec_RsvdSecCnt;        // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_NumFATs;          // Number of FATs on the partition 
....................     WORD BootSec_RootEntCnt;        // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_Media;            // Media descriptor 
....................     WORD BootSec_FATSz16;           // Number of sectors per FAT 
....................     WORD BootSec_SecPerTrk;         // Number of sectors per track 
....................     WORD BootSec_NumHeads;          // Number of heads 
....................     DWORD BootSec_HiddSec;          // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     DWORD BootSec_FATSz32;          // Sectors per FAT (32 bits) 
....................     WORD BootSec_ExtFlags;          // Presently active FAT. Defined by bits 0-3 if bit 7 is 1. 
....................     WORD BootSec_FSVers;            // FAT32 filesystem version.  Should be 0:0 
....................     DWORD BootSec_RootClus;         // Start cluster of the root directory (should be 2) 
....................     WORD BootSec_FSInfo;            // File system information 
....................     WORD BootSec_BkBootSec;         // Backup boot sector address. 
....................     BYTE  BootSec_Reserved[12];     // Reserved space 
....................     BYTE  BootSec_DrvNum;           // Drive number 
....................     BYTE  BootSec_Reserved1;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLab[11];       // Volume Label 
....................     BYTE  BootSec_FilSysType[8];    // File system type in ASCII.  Not used for determination   
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT32; 
.................... #else 
....................     } _BPB_FAT32; 
.................... #endif 
....................  
....................  
.................... // Description: A macro for the boot sector bytes per sector value offset 
.................... #define BSI_BPS            11 
....................  
.................... // Description: A macro for the boot sector sector per cluster value offset 
.................... #define BSI_SPC            13 
....................  
.................... // Description: A macro for the boot sector reserved sector count value offset 
.................... #define BSI_RESRVSEC       14 
....................  
.................... // Description: A macro for the boot sector FAT count value offset 
.................... #define BSI_FATCOUNT       16 
....................  
.................... // Description: A macro for the boot sector root directory entry count value offset 
.................... #define BSI_ROOTDIRENTS    17 
....................  
.................... // Description: A macro for the boot sector 16-bit total sector count value offset 
.................... #define BSI_TOTSEC16       19 
....................  
.................... // Description: A macro for the boot sector sectors per FAT value offset 
.................... #define BSI_SPF            22 
....................  
.................... // Description: A macro for the boot sector 32-bit total sector count value offset 
.................... #define BSI_TOTSEC32       32 
....................  
.................... // Description: A macro for the boot sector boot signature offset 
.................... #define BSI_BOOTSIG        38 
....................  
.................... // Description: A macro for the boot sector file system type string offset 
.................... #define BSI_FSTYPE         54 
....................  
.................... // Description: A macro for the boot sector 32-bit sector per FAT value offset 
.................... #define  BSI_FATSZ32       36 
....................  
.................... // Description: A macro for the boot sector start cluster of root directory value offset 
.................... #define  BSI_ROOTCLUS      44 
....................  
.................... // Description: A macro for the FAT32 boot sector boot signature offset 
.................... #define  BSI_FAT32_BOOTSIG 66 
....................  
.................... // Description: A macro for the FAT32 boot sector file system type string offset 
.................... #define  BSI_FAT32_FSTYPE  82 
....................  
....................  
....................  
.................... // Summary: A partition table entry structure. 
.................... // Description: The PTE_MBR structure contains values found in a partition table entry in the MBR of a device. 
.................... typedef struct 
.................... { 
....................     BYTE      PTE_BootDes;            // The boot descriptor (should be 0x00 in a non-bootable device) 
....................     SWORD     PTE_FrstPartSect;       // The cylinder-head-sector address of the first sector of the partition 
....................     BYTE      PTE_FSDesc;             // The file system descriptor 
....................     SWORD     PTE_LstPartSect;        // The cylinder-head-sector address of the last sector of the partition 
....................     DWORD     PTE_FrstSect;           // The logical block address of the first sector of the partition 
....................     DWORD     PTE_NumSect;            // The number of sectors in a partition 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) PTE_MBR; 
.................... #else 
....................     } PTE_MBR; 
.................... #endif 
....................  
....................  
.................... // Summary: A structure of the organization of a master boot record. 
.................... // Description: The _PT_MBR structure has the same form as a master boot record.  When the MBR is loaded from the device, it will 
.................... //              be cast as a _PT_MBR structure so the MBR elements can be accessed. 
.................... typedef struct 
.................... { 
....................     BYTE        ConsChkRtn[446];        // Boot code 
....................     PTE_MBR     Partition0;             // The first partition table entry 
....................     PTE_MBR     Partition1;             // The second partition table entry 
....................     PTE_MBR     Partition2;             // The third partition table entry 
....................     PTE_MBR     Partition3;             // The fourth partition table entry 
....................     BYTE        Signature0;             // MBR signature code - equal to 0x55 
....................     BYTE        Signature1;             // MBR signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... }__attribute__((packed)) _PT_MBR; 
.................... #else 
.................... }_PT_MBR; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _PT_MBR structure 
.................... // Description: The PT_MBR pointer points to a _PT_MBR structure. 
.................... typedef _PT_MBR *  PT_MBR; 
....................  
....................  
....................  
.................... // Summary: A structure of the organization of a boot sector. 
.................... // Description: The _BootSec structure has the same form as a boot sector.  When the boot sector is loaded from the device, it will 
.................... //              be cast as a _BootSec structure so the boot sector elements can be accessed. 
.................... typedef struct 
.................... { 
....................     // A union of different bios parameter blocks 
....................     union 
....................     { 
....................         _BPB_FAT32  FAT_32; 
....................         _BPB_FAT16  FAT_16; 
....................         _BPB_FAT12  FAT_12; 
....................     }FAT; 
....................     BYTE    Reserved[512-sizeof(_BPB_FAT32)-2]; // Reserved space 
....................     BYTE    Signature0;         // Boot sector signature code - equal to 0x55 
....................     BYTE    Signature1;         // Boot sector signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BootSec; 
.................... #else 
....................     } _BootSec; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _BootSec structure 
.................... // Description: The BootSec pointer points to a _BootSec structure. 
.................... typedef _BootSec * BootSec; 
....................  
....................  
....................  
.................... // Summary: A macro indicating the offset for the master boot record 
.................... // Description: FO_MBR is a macro that indicates the addresss of the master boot record on the device.  When the device is initialized 
.................... //              this sector will be read 
.................... #define FO_MBR          0L 
....................  
....................  
....................  
.................... // Summary: A macro for the first boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_0 macro is used to determine that the first byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_0     0x55 
....................  
.................... // Summary: A macro for the second boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_1 macro is used to determine that the second byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_1     0xAA 
....................  
....................  
.................... typedef struct  
.................... { 
....................     BYTE    errorCode; 
....................     union  
....................     { 
....................         BYTE    value; 
....................         struct  
....................         { 
....................             BYTE    sectorSize  : 1; 
....................             BYTE    maxLUN      : 1; 
....................         }   bits; 
....................     } validityFlags; 
....................      
....................     WORD    sectorSize; 
....................     BYTE    maxLUN; 
.................... } MEDIA_INFORMATION; 
....................  
.................... typedef enum 
.................... { 
....................     MEDIA_NO_ERROR,                     // No errors 
....................     MEDIA_DEVICE_NOT_PRESENT,           // The requested device is not present 
....................     MEDIA_CANNOT_INITIALIZE             // Cannot initialize media 
.................... } MEDIA_ERRORS;                 
....................  
....................  
.................... #endif 
....................  
.................... #include "MDD File System/SD-SPI.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        SD-SPI.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  *                  FSconfig.h 
....................  *                  FSDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the "Company") for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef SDMMC_H 
.................... #define SDMMC_H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... #include "../FSconfig.h" 
.................... #include "FSDefs.h" 
....................  
....................  
.................... #ifdef __18CXX 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 4x prescale divider 
....................     #define   SYNC_MODE_FAST    0x00 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 16x prescale divider 
....................     #define   SYNC_MODE_MED     0x01 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 64x prescale divider 
....................     #define   SYNC_MODE_SLOW    0x02 
.................... #elif defined __PIC32MX__ 
....................     // Description: This macro is used to initialize a PIC32 SPI module 
....................     #define   SYNC_MODE_FAST    0x3E 
....................     // Description: This macro is used to initialize a PIC32 SPI module 
....................     #define   SYNC_MODE_SLOW    0x3C 
.................... #else 
....................     // Description: This macro indicates the SPI enable bit for 16-bit PICs 
....................     #ifndef MASTER_ENABLE_ON 
....................         #define  MASTER_ENABLE_ON       0x0020 
....................     #endif 
....................  
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module 
....................     #ifndef SYNC_MODE_FAST 
....................         #define   SYNC_MODE_FAST    0x3E 
....................     #endif 
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module 
....................     #ifndef SYNC_MODE_SLOW 
....................         #define   SYNC_MODE_SLOW    0x3C 
....................     #endif 
....................  
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module secondary prescaler 
....................     #ifndef SEC_PRESCAL_1_1 
....................         #define  SEC_PRESCAL_1_1        0x001c 
....................     #endif 
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module primary prescaler 
....................     #ifndef PRI_PRESCAL_1_1 
....................         #define  PRI_PRESCAL_1_1        0x0003 
....................     #endif 
.................... #endif 
....................  
....................  
....................  
.................... /*****************************************************************/ 
.................... /*                  Strcutures and defines                       */ 
.................... /*****************************************************************/ 
....................  
....................  
.................... // Description: This macro represents an SD card start single data block token (used for single block writes) 
.................... #define DATA_START_TOKEN            0xFE 
....................  
.................... // Description: This macro represents an SD card start multi-block data token (used for multi-block writes) 
.................... #define DATA_START_MULTI_BLOCK_TOKEN    0xFC 
....................  
.................... // Description: This macro represents an SD card stop transmission token.  This is used when finishing a multi block write sequence. 
.................... #define DATA_STOP_TRAN_TOKEN        0xFD 
....................  
.................... // Description: This macro represents an SD card data accepted token 
.................... #define DATA_ACCEPTED               0x05 
....................  
.................... // Description: This macro indicates that the SD card expects to transmit or receive more data 
.................... #define MOREDATA    !0 
....................  
.................... // Description: This macro indicates that the SD card does not expect to transmit or receive more data 
.................... #define NODATA      0 
....................  
.................... // Description: This macro represents a floating SPI bus condition 
.................... #define MMC_FLOATING_BUS    0xFF 
....................  
.................... // Description: This macro represents a bad SD card response byte 
.................... #define MMC_BAD_RESPONSE    MMC_FLOATING_BUS 
....................  
.................... // The SDMMC Commands 
....................  
.................... // Description: This macro defines the command code to reset the SD card 
.................... #define     cmdGO_IDLE_STATE        0 
.................... // Description: This macro defines the command code to initialize the SD card 
.................... #define     cmdSEND_OP_COND         1         
.................... // Description: This macro defined the command code to check for sector addressing 
.................... #define     cmdSEND_IF_COND         8 
.................... // Description: This macro defines the command code to get the Card Specific Data 
.................... #define     cmdSEND_CSD             9 
.................... // Description: This macro defines the command code to get the Card Information 
.................... #define     cmdSEND_CID             10 
.................... // Description: This macro defines the command code to stop transmission during a multi-block read 
.................... #define     cmdSTOP_TRANSMISSION    12 
.................... // Description: This macro defines the command code to get the card status information 
.................... #define     cmdSEND_STATUS          13 
.................... // Description: This macro defines the command code to set the block length of the card 
.................... #define     cmdSET_BLOCKLEN         16 
.................... // Description: This macro defines the command code to read one block from the card 
.................... #define     cmdREAD_SINGLE_BLOCK    17 
.................... // Description: This macro defines the command code to read multiple blocks from the card 
.................... #define     cmdREAD_MULTI_BLOCK     18 
.................... // Description: This macro defines the command code to tell the media how many blocks to pre-erase (for faster multi-block writes to follow) 
.................... //Note: This is an "application specific" command.  This tells the media how many blocks to pre-erase for the subsequent WRITE_MULTI_BLOCK 
.................... #define     cmdSET_WR_BLK_ERASE_COUNT   23 
.................... // Description: This macro defines the command code to write one block to the card 
.................... #define     cmdWRITE_SINGLE_BLOCK   24     
.................... // Description: This macro defines the command code to write multiple blocks to the card 
.................... #define     cmdWRITE_MULTI_BLOCK    25 
.................... // Description: This macro defines the command code to set the address of the start of an erase operation 
.................... #define     cmdTAG_SECTOR_START     32 
.................... // Description: This macro defines the command code to set the address of the end of an erase operation 
.................... #define     cmdTAG_SECTOR_END       33 
.................... // Description: This macro defines the command code to erase all previously selected blocks 
.................... #define     cmdERASE                38 
.................... //Description: This macro defines the command code to intitialize an SD card and provide the CSD register value. 
.................... //Note: this is an "application specific" command (specific to SD cards) and must be preceded by cmdAPP_CMD. 
.................... #define     cmdSD_SEND_OP_COND      41 
.................... // Description: This macro defines the command code to begin application specific command inputs 
.................... #define     cmdAPP_CMD              55 
.................... // Description: This macro defines the command code to get the OCR register information from the card 
.................... #define     cmdREAD_OCR             58 
.................... // Description: This macro defines the command code to disable CRC checking 
.................... #define     cmdCRC_ON_OFF           59 
....................  
....................  
.................... // Description: Enumeration of different SD response types 
.................... typedef enum 
.................... { 
....................     R1,     // R1 type response 
....................     R1b,    // R1b type response 
....................     R2,     // R2 type response 
....................     R3,     // R3 type response  
....................     R7      // R7 type response  
.................... }RESP; 
....................  
.................... // Summary: SD card command data structure 
.................... // Description: The typMMC_CMD structure is used to create a command table of information needed for each relevant SD command 
.................... typedef struct 
.................... { 
....................     BYTE      CmdCode;          // The command code 
....................     BYTE      CRC;              // The CRC value for that command 
....................     RESP    responsetype;       // The response type 
....................     BYTE    moredataexpected;   // Set to MOREDATA or NODATA, depending on whether more data is expected or not 
.................... } typMMC_CMD; 
....................  
....................  
.................... // Summary: An SD command packet 
.................... // Description: This union represents different ways to access an SD card command packet 
.................... typedef union 
.................... { 
....................     // This structure allows array-style access of command bytes 
....................     struct 
....................     { 
....................         #ifdef __18CXX 
....................             BYTE field[6];      // BYTE array 
....................         #else 
....................             BYTE field[7]; 
....................         #endif 
....................     }; 
....................     // This structure allows byte-wise access of packet command bytes 
....................     struct 
....................     { 
....................         BYTE crc;               // The CRC byte 
....................         #if defined __C30__ 
....................             BYTE c30filler;     // Filler space (since bitwise declarations can't cross a WORD boundary) 
....................         #elif defined __C32__ 
....................             BYTE c32filler[3];  // Filler space (since bitwise declarations can't cross a DWORD boundary) 
....................         #endif 
....................          
....................         BYTE addr0;             // Address byte 0 
....................         BYTE addr1;             // Address byte 1 
....................         BYTE addr2;             // Address byte 2 
....................         BYTE addr3;             // Address byte 3 
....................         BYTE cmd;               // Command code byte 
....................     }; 
....................     // This structure allows bitwise access to elements of the command bytes 
....................     struct 
....................     { 
....................         BYTE  END_BIT:1;        // Packet end bit 
....................         BYTE  CRC7:7;           // CRC value 
....................         DWORD     address;      // Address 
....................         BYTE  CMD_INDEX:6;      // Command code 
....................         BYTE  TRANSMIT_BIT:1;   // Transmit bit 
....................         BYTE  START_BIT:1;      // Packet start bit 
....................     }; 
.................... } CMD_PACKET; 
....................  
....................  
.................... // Summary: The format of an R1 type response 
.................... // Description: This union represents different ways to access an SD card R1 type response packet. 
.................... typedef union 
.................... { 
....................     BYTE _byte;                         // Byte-wise access 
....................     // This structure allows bitwise access of the response 
....................     struct 
....................     { 
....................         unsigned IN_IDLE_STATE:1;       // Card is in idle state 
....................         unsigned ERASE_RESET:1;         // Erase reset flag 
....................         unsigned ILLEGAL_CMD:1;         // Illegal command flag 
....................         unsigned CRC_ERR:1;             // CRC error flag 
....................         unsigned ERASE_SEQ_ERR:1;       // Erase sequence error flag 
....................         unsigned ADDRESS_ERR:1;         // Address error flag 
....................         unsigned PARAM_ERR:1;           // Parameter flag    
....................         unsigned B7:1;                  // Unused bit 7 
....................     }; 
.................... } RESPONSE_1; 
....................  
.................... // Summary: The format of an R2 type response 
.................... // Description: This union represents different ways to access an SD card R2 type response packet 
.................... typedef union 
.................... { 
....................     WORD _word; 
....................     struct 
....................     { 
....................         BYTE      _byte0; 
....................         BYTE      _byte1; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned IN_IDLE_STATE:1; 
....................         unsigned ERASE_RESET:1; 
....................         unsigned ILLEGAL_CMD:1; 
....................         unsigned CRC_ERR:1; 
....................         unsigned ERASE_SEQ_ERR:1; 
....................         unsigned ADDRESS_ERR:1; 
....................         unsigned PARAM_ERR:1; 
....................         unsigned B7:1; 
....................         unsigned CARD_IS_LOCKED:1; 
....................         unsigned WP_ERASE_SKIP_LK_FAIL:1; 
....................         unsigned ERROR:1; 
....................         unsigned CC_ERROR:1; 
....................         unsigned CARD_ECC_FAIL:1; 
....................         unsigned WP_VIOLATION:1; 
....................         unsigned ERASE_PARAM:1; 
....................         unsigned OUTRANGE_CSD_OVERWRITE:1; 
....................     }; 
.................... } RESPONSE_2; 
....................  
.................... // Summary: The format of an R7 or R3 type response 
.................... // Description: This union represents different ways to access an SD card R7 type response packet. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         BYTE _byte;                         // Byte-wise access 
....................         union 
....................         { 
....................             //Note: The SD card argument response field is 32-bit, big endian format. 
....................             //However, the C compiler stores 32-bit values in little endian in RAM. 
....................             //When writing to the _returnVal/argument bytes, make sure to byte 
....................             //swap the order from which it arrived over the SPI from the SD card. 
....................             DWORD _returnVal; 
....................             struct 
....................             { 
....................                 BYTE _byte0; 
....................                 BYTE _byte1; 
....................                 BYTE _byte2; 
....................                 BYTE _byte3; 
....................             };     
....................         }argument;     
....................     } bytewise; 
....................     // This structure allows bitwise access of the response 
....................     struct 
....................     { 
....................         struct 
....................         { 
....................             unsigned IN_IDLE_STATE:1;       // Card is in idle state 
....................             unsigned ERASE_RESET:1;         // Erase reset flag 
....................             unsigned ILLEGAL_CMD:1;         // Illegal command flag 
....................             unsigned CRC_ERR:1;             // CRC error flag 
....................             unsigned ERASE_SEQ_ERR:1;       // Erase sequence error flag 
....................             unsigned ADDRESS_ERR:1;         // Address error flag 
....................             unsigned PARAM_ERR:1;           // Parameter flag    
....................             unsigned B7:1;                  // Unused bit 7 
....................         }bits; 
....................         DWORD _returnVal; 
....................     } bitwise; 
.................... } RESPONSE_7; 
....................  
.................... // Summary: A union of responses from an SD card 
.................... // Description: The MMC_RESPONSE union represents any of the possible responses that an SD card can return after 
.................... //              being issued a command. 
.................... typedef union 
.................... { 
....................     RESPONSE_1  r1;   
....................     RESPONSE_2  r2; 
....................     RESPONSE_7  r7; 
.................... }MMC_RESPONSE; 
....................  
....................  
.................... // Summary: A description of the card specific data register 
.................... // Description: This union represents different ways to access information in a packet with SD card CSD informaiton.  For more 
.................... //              information on the CSD register, consult an SD card user's manual. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         DWORD _u320; 
....................         DWORD _u321; 
....................         DWORD _u322; 
....................         DWORD _u323; 
....................     }; 
....................     struct 
....................     { 
....................         BYTE _byte[16]; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned NOT_USED           :1; 
....................         unsigned CRC                :7; 
....................         unsigned ECC                :2; 
....................         unsigned FILE_FORMAT        :2; 
....................         unsigned TMP_WRITE_PROTECT  :1; 
....................         unsigned PERM_WRITE_PROTECT :1; 
....................         unsigned COPY               :1; 
....................         unsigned FILE_FORMAT_GRP    :1; 
....................         unsigned RESERVED_1         :5; 
....................         unsigned WRITE_BL_PARTIAL   :1; 
....................         unsigned WRITE_BL_LEN_L     :2; 
....................         unsigned WRITE_BL_LEN_H     :2; 
....................         unsigned R2W_FACTOR         :3; 
....................         unsigned DEFAULT_ECC        :2; 
....................         unsigned WP_GRP_ENABLE      :1; 
....................         unsigned WP_GRP_SIZE        :5; 
....................         unsigned ERASE_GRP_SIZE_L   :3; 
....................         unsigned ERASE_GRP_SIZE_H   :2; 
....................         unsigned SECTOR_SIZE        :5; 
....................         unsigned C_SIZE_MULT_L      :1; 
....................         unsigned C_SIZE_MULT_H      :2; 
....................         unsigned VDD_W_CURR_MAX     :3; 
....................         unsigned VDD_W_CUR_MIN      :3; 
....................         unsigned VDD_R_CURR_MAX     :3; 
....................         unsigned VDD_R_CURR_MIN     :3; 
....................         unsigned C_SIZE_L           :2; 
....................         unsigned C_SIZE_H           :8; 
....................         unsigned C_SIZE_U           :2; 
....................         unsigned RESERVED_2         :2; 
....................         unsigned DSR_IMP            :1; 
....................         unsigned READ_BLK_MISALIGN  :1; 
....................         unsigned WRITE_BLK_MISALIGN :1; 
....................         unsigned READ_BL_PARTIAL    :1; 
....................         unsigned READ_BL_LEN        :4; 
....................         unsigned CCC_L              :4; 
....................         unsigned CCC_H              :8; 
....................         unsigned TRAN_SPEED         :8; 
....................         unsigned NSAC               :8; 
....................         unsigned TAAC               :8; 
....................         unsigned RESERVED_3         :2; 
....................         unsigned SPEC_VERS          :4; 
....................         unsigned CSD_STRUCTURE      :2; 
....................     }; 
.................... } CSD; 
....................  
....................  
.................... // Summary: A description of the card information register 
.................... // Description: This union represents different ways to access information in a packet with SD card CID register informaiton.  For more 
.................... //              information on the CID register, consult an SD card user's manual. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         DWORD _u320; 
....................         DWORD _u321; 
....................         DWORD _u322; 
....................         DWORD _u323; 
....................     }; 
....................     struct 
....................     { 
....................         BYTE _byte[16]; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned    NOT_USED            :1; 
....................         unsigned    CRC                 :7; 
....................         unsigned    MDT                 :8; 
....................         DWORD       PSN; 
....................         unsigned    PRV                 :8; 
....................         char        PNM[6]; 
....................         WORD        OID; 
....................         unsigned    MID                 :8; 
....................     }; 
.................... } CID; 
....................  
.................... #ifndef FALSE 
....................     #define FALSE   0 
.................... #endif 
.................... #ifndef TRUE 
....................     #define TRUE    !FALSE 
.................... #endif 
....................  
.................... #define INPUT   1 
.................... #define OUTPUT  0 
....................  
....................  
.................... // Description: A delay prescaler 
.................... #define DELAY_PRESCALER   (BYTE)      8 
....................  
.................... // Description: An approximation of the number of cycles per delay loop of overhead 
.................... #define DELAY_OVERHEAD    (BYTE)      5 
....................  
.................... // Description: An approximate calculation of how many times to loop to delay 1 ms in the Delayms function 
.................... #define MILLISECDELAY   (WORD)      ((GetInstructionClock()/DELAY_PRESCALER/(WORD)1000) - DELAY_OVERHEAD) 
....................  
....................  
.................... // Desription: Media Response Delay Timeouts  
.................... #define NCR_TIMEOUT     (WORD)20        //Byte times before command response is expected (must be at least 8) 
.................... #define NAC_TIMEOUT     (DWORD)0x40000  //SPI byte times we should wait when performing read operations (should be at least 100ms for SD cards) 
.................... #define WRITE_TIMEOUT   (DWORD)0xA0000  //SPI byte times to wait before timing out when the media is performing a write operation (should be at least 250ms for SD cards). 
....................  
.................... // Summary: An enumeration of SD commands 
.................... // Description: This enumeration corresponds to the position of each command in the sdmmc_cmdtable array 
.................... //              These macros indicate to the SendMMCCmd function which element of the sdmmc_cmdtable array 
.................... //              to retrieve command code information from. 
.................... typedef enum 
.................... { 
....................     GO_IDLE_STATE, 
....................     SEND_OP_COND, 
....................     SEND_IF_COND, 
....................     SEND_CSD, 
....................     SEND_CID, 
....................     STOP_TRANSMISSION, 
....................     SEND_STATUS, 
....................     SET_BLOCKLEN, 
....................     READ_SINGLE_BLOCK, 
....................     READ_MULTI_BLOCK, 
....................     WRITE_SINGLE_BLOCK, 
....................     WRITE_MULTI_BLOCK, 
....................     TAG_SECTOR_START, 
....................     TAG_SECTOR_END, 
....................     ERASE, 
....................     APP_CMD, 
....................     READ_OCR, 
....................     CRC_ON_OFF, 
....................     SD_SEND_OP_COND, 
....................     SET_WR_BLK_ERASE_COUNT 
.................... }sdmmc_cmd; 
....................  
....................  
.................... #define SD_MODE_NORMAL  0 
.................... #define SD_MODE_HC      1 
....................  
....................  
.................... //Definition for a structure used when calling either MDD_SDSPI_AsyncReadTasks()  
.................... //function, or the MDD_SDSPI_AsyncWriteTasks() function. 
.................... typedef struct 
.................... { 
....................     WORD wNumBytes;         //Number of bytes to attempt to read or write in the next call to MDD_SDSPI_AsyncReadTasks() or MDD_SDSPI_AsyncWriteTasks.  May be updated between calls to the handler. 
....................     DWORD dwBytesRemaining; //Should be initialized to the total number of bytes that you wish to read or write.  This value is allowed to be greater than a single block size of the media. 
....................     BYTE* pBuffer;          //Pointer to where the read/written bytes should be copied to/from.  May be updated between calls to the handler function. 
....................     DWORD dwAddress;        //Starting block address to read or to write to on the media.  Should only get initialized, do not modify after that. 
....................     BYTE bStateVariable;    //State machine variable.  Should get initialized to ASYNC_READ_QUEUED or ASYNC_WRITE_QUEUED to start an operation.  After that, do not modify until the read or write is complete. 
.................... }ASYNC_IO;    
....................  
....................  
.................... //Response codes for the MDD_SDSPI_AsyncReadTasks() function. 
.................... #define ASYNC_READ_COMPLETE             0x00 
.................... #define ASYNC_READ_BUSY                 0x01 
.................... #define ASYNC_READ_NEW_PACKET_READY     0x02 
.................... #define ASYNC_READ_ERROR                0xFF 
....................  
.................... //MDD_SDSPI_AsyncReadTasks() state machine variable values.  These are used internally to SD-SPI.c. 
.................... #define ASYNC_READ_COMPLETE             0x00 
.................... #define ASYNC_READ_QUEUED               0x01    //Initialize to this to start a read sequence 
.................... #define ASYNC_READ_WAIT_START_TOKEN     0x03 
.................... #define ASYNC_READ_NEW_PACKET_READY     0x02 
.................... #define ASYNC_READ_ABORT                0xFE 
.................... #define ASYNC_READ_ERROR                0xFF 
....................  
.................... //Possible return values when calling MDD_SDSPI_AsyncWriteTasks() 
.................... #define ASYNC_WRITE_COMPLETE        0x00 
.................... #define ASYNC_WRITE_SEND_PACKET     0x02 
.................... #define ASYNC_WRITE_BUSY            0x03 
.................... #define ASYNC_WRITE_ERROR           0xFF 
....................  
.................... //MDD_SDSPI_AsyncWriteTasks() state machine variable values.  These are used internally to SD-SPI.c. 
.................... #define ASYNC_WRITE_COMPLETE            0x00 
.................... #define ASYNC_WRITE_QUEUED              0x01    //Initialize to this to start a write sequence 
.................... #define ASYNC_WRITE_TRANSMIT_PACKET     0x02 
.................... #define ASYNC_WRITE_MEDIA_BUSY          0x03 
.................... #define ASYNC_STOP_TOKEN_SENT_WAIT_BUSY 0x04 
.................... #define ASYNC_WRITE_ABORT               0xFE 
.................... #define ASYNC_WRITE_ERROR               0xFF 
....................  
....................  
.................... //Constants 
.................... #define MEDIA_BLOCK_SIZE            512u  //Should always be 512 for v1 and v2 devices. 
.................... #define WRITE_RESPONSE_TOKEN_MASK   0x1F  //Bit mask to AND with the write token response byte from the media, to clear the don't care bits. 
....................  
....................  
....................  
.................... /***************************************************************************/ 
.................... /*                               Macros                                    */ 
.................... /***************************************************************************/ 
....................  
.................... // Description: A macro to send clock cycles to dummy-read the CRC 
.................... #define mReadCRC()              WriteSPIM(0xFF);WriteSPIM(0xFF); 
....................  
.................... // Description: A macro to send clock cycles to dummy-write the CRC 
.................... #define mSendCRC()              WriteSPIM(0xFF);WriteSPIM(0xFF); 
....................  
.................... // Description: A macro to send 8 clock cycles for SD timing requirements 
.................... #define mSend8ClkCycles()       WriteSPIM(0xFF); 
....................  
.................... /*****************************************************************************/ 
.................... /*                                 Public Prototypes                         */ 
.................... /*****************************************************************************/ 
....................  
.................... //These are the public API functions provided by SD-SPI.c 
.................... BYTE MDD_SDSPI_MediaDetect(void); 
.................... MEDIA_INFORMATION * MDD_SDSPI_MediaInitialize(void); 
.................... DWORD MDD_SDSPI_ReadCapacity(void); 
.................... WORD MDD_SDSPI_ReadSectorSize(void); 
.................... void MDD_SDSPI_InitIO(void); 
.................... BYTE MDD_SDSPI_SectorRead(DWORD sector_addr, BYTE* buffer); 
.................... BYTE MDD_SDSPI_SectorWrite(DWORD sector_addr, BYTE* buffer, BYTE allowWriteToZero); 
.................... BYTE MDD_SDSPI_AsyncReadTasks(ASYNC_IO*); 
.................... BYTE MDD_SDSPI_AsyncWriteTasks(ASYNC_IO*); 
.................... BYTE MDD_SDSPI_WriteProtectState(void); 
.................... BYTE MDD_SDSPI_ShutdownMedia(void); 
....................  
....................  
.................... #if defined __C30__ || defined __C32__ 
....................     extern BYTE ReadByte( BYTE* pBuffer, WORD index ); 
....................     extern WORD ReadWord( BYTE* pBuffer, WORD index ); 
....................     extern DWORD ReadDWord( BYTE* pBuffer, WORD index ); 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "string.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = beg; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "FSconfig.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSconfig.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Dependencies:    None 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _FS_DEF_ 
.................... #define _FS_DEF_ 
....................  
.................... //#include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // something to do with long filenames. 
.................... //#define SUPPORT_LFN 
....................  
.................... // Summary: A macro indicating the maximum number of concurrently open files 
.................... // Description: The FS_MAX_FILES_OPEN #define is only applicable when dynamic memory allocation is not used (FS_DYNAMIC_MEM is not defined). 
.................... //              This macro defines the maximum number of open files at any given time.  The amount of RAM used by FSFILE objects will 
.................... //              be equal to the size of an FSFILE object multipled by this macro value.  This value should be kept as small as possible 
.................... //              as dictated by the application.  This will reduce memory usage. 
.................... #define FS_MAX_FILES_OPEN    1 
....................  
....................  
.................... // if defined, MDD will be configured to use SST25 flash device. this definition 
.................... // should also define the size of the SST25 flash device. 
.................... // if not defined, will use SD card. 
.................... // #define  USE_SST25_INTERFACE  ((unsigned int32)2*1024*1024) 
....................  
.................... // Summary: A macro defining the size of a sector 
.................... // Description: The MEDIA_SECTOR_SIZE macro will define the size of a sector on the FAT file system.  This value must equal 512 bytes, 
.................... //              1024 bytes, 2048 bytes, or 4096 bytes.  The value of a sector will usually be 512 bytes. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define MEDIA_SECTOR_SIZE       4096   //erase size of SST25 flash device 
.................... #else 
.................... #define MEDIA_SECTOR_SIZE       512 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* *******************************************************************************************************/ 
.................... /************** Compiler options to enable/Disable Features based on user's application ******************/ 
.................... /* *******************************************************************************************************/ 
....................  
....................  
.................... // Summary: A macro to enable/disable file search functions. 
.................... // Description: The ALLOW_FILESEARCH definition can be commented out to disable file search functions in the library.  This will 
.................... //              prevent the use of the FindFirst and FindNext functions and reduce code size. 
.................... #define ALLOW_FILESEARCH 
....................  
.................... // Summary: A macro to enable/disable write functionality 
.................... // Description: The ALLOW_WRITES definition can be commented out to disable all operations that write to the device.  This will 
.................... //              greatly reduce code size. 
.................... #define ALLOW_WRITES 
....................  
....................  
.................... // Summary: A macro to enable/disable format functionality 
.................... // Description: The ALLOW_FORMATS definition can be commented out to disable formatting functionality.  This will prevent the use of 
.................... //              the FSformat function.  If formats are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define ALLOW_FORMATS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable directory operations. 
.................... // Description: The ALLOW_DIRS definition can be commented out to disable all directory functionality.  This will reduce code size. 
.................... //              If directories are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES in order to use 
.................... //              the FSmkdir or FSrmdir functions. 
.................... #define ALLOW_DIRS 
....................  
.................... // Summary: A macro to enable/disable PIC18 ROM functions. 
.................... // Description: The ALLOW_PGMFUNCTIONS definition can be commented out to disable all PIC18 functions that allow the user to pass string 
.................... //              arguments in ROM (denoted by the suffix -pgm).  Note that this functionality must be disabled when not using PIC18. 
.................... #if !defined(__CCS__) 
.................... #define ALLOW_PGMFUNCTIONS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable the FSfprintf function. 
.................... // Description: The ALLOW_FSFPRINTF definition can be commented out to disable the FSfprintf function.  This will save code space.  Note that 
.................... //              if FSfprintf is enabled and the PIC18 architecture is used, integer promotions must be enabled in the Project->Build Options 
.................... //              menu.  Write operations must be enabled to use FSfprintf. 
.................... //#define ALLOW_FSFPRINTF 
....................  
.................... // CCS added this config option to disable FAT12 to prevent recursion. 
.................... //__CCS__ added by ccs 
.................... //#define SUPPORT_FAT12 
....................  
.................... // Summary: A macro to enable/disable FAT32 support. 
.................... // Description: The SUPPORT_FAT32 definition can be commented out to disable support for FAT32 functionality.  This will save a small amount 
.................... //              of code space. 
.................... #define SUPPORT_FAT32 
....................  
....................  
....................  
.................... /**************************************************************************************************/ 
.................... // Select a method for updating file timestamps 
.................... /**************************************************************************************************/ 
....................  
.................... // Summary: A macro to enable RTCC based timestamp generation 
.................... // Description: The USEREALTIMECLOCK macro will configure the code to automatically 
.................... //              generate timestamp information for files from the RTCC module. The user 
.................... //              must enable and configure the RTCC module before creating or modifying 
.................... //              files.                                                                  
.................... //#define USEREALTIMECLOCK 
....................  
.................... // Summary: A macro to enable manual timestamp generation 
.................... // Description: The USERDEFINEDCLOCK macro will allow the user to manually set 
.................... //              timestamp information using the SetClockVars function. The user will 
.................... //              need to set the time variables immediately before creating or closing a 
.................... //              file or directory.                                                     
.................... #define USERDEFINEDCLOCK 
....................  
.................... // Summary: A macro to enable don't-care timestamp generation 
.................... // Description: The INCREMENTTIMESTAMP macro will set the create time of a file to a 
.................... //              static value and increment it when a file is updated. This timestamp 
.................... //              generation method should only be used in applications where file times 
.................... //              are not necessary.                                                     
.................... //#define INCREMENTTIMESTAMP 
....................  
....................  
.................... #ifdef __18CXX 
....................    #ifdef USEREALTIMECLOCK 
....................       #error Not all PIC18 devices have a Real-time clock and calander module 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    #ifndef __18CXX 
....................       #error The pgm functions are unneccessary when not using PIC18 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef USEREALTIMECLOCK 
....................     #ifndef USERDEFINEDCLOCK 
....................         #ifndef INCREMENTTIMESTAMP 
....................             #error Please enable USEREALTIMECLOCK, USERDEFINEDCLOCK, or INCREMENTTIMESTAMP 
....................         #endif 
....................     #endif 
.................... #endif 
....................  
.................... /************************************************************************/ 
.................... // Set this preprocessor option to '1' to use dynamic FSFILE object allocation.  It will 
.................... // be necessary to allocate a heap when dynamically allocating FSFILE objects. 
.................... // Set this option to '0' to use static FSFILE object allocation. 
.................... /************************************************************************/ 
....................  
.................... //#if 1  //from mirochip 
.................... #if defined(__PCH__) //__CCS__ 
....................     // Summary: A macro indicating that FSFILE objects will be allocated dynamically 
....................     // Description: The FS_DYNAMIC_MEM macro will cause FSFILE objects to be allocated from a dynamic heap.  If it is undefined, 
....................     //              the file objects will be allocated using a static array. 
....................    //#define FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................         // Description: Function pointer to a dynamic memory allocation function 
....................       #define FS_malloc   SRAMalloc 
....................         // Description: Function pointer to a dynamic memory free function 
....................       #define FS_free      SRAMfree 
....................    #else 
....................       #define FS_malloc   malloc 
....................       #define FS_free      free 
....................    #endif 
.................... #elif defined(__CCS__) 
....................    #error/warning Not using FS_DYNAMIC_MEM for PCD compiler 
.................... #endif 
....................  
....................  
.................... #ifdef __18CXX 
....................     /* Define the locations for the dataBuffer and FATbuffer; PLEASE CHECK THE LINKER FILE */ 
....................     #define DATA_BUFFER_ADDRESS      0x700 
....................     #define FAT_BUFFER_ADDRESS       0x900 
.................... #endif 
....................  
....................  
.................... // Function definitions 
.................... // Associate the physical layer functions with the correct physical layer 
.................... #ifdef USE_SD_INTERFACE_WITH_SPI       // SD-SPI.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_SDSPI_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_SDSPI_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_SDSPI_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_SDSPI_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_SDSPI_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_SDSPI_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_SDSPI_WriteProtectState 
....................  
....................     // Description: Function pointer to the Read Capacity Physical Layer function 
....................     #define MDD_ReadCapacity        MDD_SDSPI_ReadCapacity 
....................  
....................     // Description: Function pointer to the Read Sector Size Physical Layer Function 
....................     #define MDD_ReadSectorSize      MDD_SDSPI_ReadSectorSize 
....................  
.................... #elif defined USE_CF_INTERFACE_WITH_PMP       // CF-PMP.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFPMP_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFPMP_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFPMP_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFPMP_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFPMP_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFPMP_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFPMP_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFPMP_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFPMP_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFPMP_CFread 
....................  
.................... #elif defined USE_MANUAL_CF_INTERFACE         // CF-Bit transaction.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFBT_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFBT_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFBT_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFBT_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFBT_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFBT_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFBT_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFBT_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFBT_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFBT_CFread 
....................  
.................... #elif defined USE_USB_INTERFACE               // USB host MSD library 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     USBHostMSDSCSIMediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         USBHostMSDSCSIMediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          USBHostMSDSCSISectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         USBHostMSDSCSISectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO();               
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       USBHostMSDSCSIMediaReset 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   USBHostMSDSCSIWriteProtectState 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Global Variables 
....................  *****************************************************************************/ 
....................  
.................... // Description:  Used for the mass-storage library to determine capacity 
.................... DWORD MDD_SDSPI_finalLBA; 
.................... WORD gMediaSectorSize; 
.................... BYTE gSDMode; 
.................... static MEDIA_INFORMATION mediaInformation; 
.................... static ASYNC_IO ioInfo; //Declared global context, for fast/code efficient access 
....................  
....................  
.................... #ifdef __18CXX 
....................     // Summary: Table of SD card commands and parameters 
....................     // Description: The sdmmc_cmdtable contains an array of SD card commands, the corresponding CRC code, the 
....................     //              response type that the card will return, and a parameter indicating whether to expect 
....................     //              additional data from the card. 
....................     const rom typMMC_CMD sdmmc_cmdtable[] = 
.................... #else 
....................     const typMMC_CMD sdmmc_cmdtable[] = 
.................... #endif 
.................... { 
....................     // cmd                      crc     response 
....................     {cmdGO_IDLE_STATE,          0x95,   R1,     NODATA}, 
....................     {cmdSEND_OP_COND,           0xF9,   R1,     NODATA}, 
....................     {cmdSEND_IF_COND,            0x87,   R7,     NODATA}, 
....................     {cmdSEND_CSD,               0xAF,   R1,     MOREDATA}, 
....................     {cmdSEND_CID,               0x1B,   R1,     MOREDATA}, 
....................     {cmdSTOP_TRANSMISSION,      0xC3,   R1b,    NODATA}, 
....................     {cmdSEND_STATUS,            0xAF,   R2,     NODATA}, 
....................     {cmdSET_BLOCKLEN,           0xFF,   R1,     NODATA}, 
....................     {cmdREAD_SINGLE_BLOCK,      0xFF,   R1,     MOREDATA}, 
....................     {cmdREAD_MULTI_BLOCK,       0xFF,   R1,     MOREDATA}, 
....................     {cmdWRITE_SINGLE_BLOCK,     0xFF,   R1,     MOREDATA}, 
....................     {cmdWRITE_MULTI_BLOCK,      0xFF,   R1,     MOREDATA},  
....................     {cmdTAG_SECTOR_START,       0xFF,   R1,     NODATA}, 
....................     {cmdTAG_SECTOR_END,         0xFF,   R1,     NODATA}, 
....................     {cmdERASE,                  0xDF,   R1b,    NODATA}, 
....................     {cmdAPP_CMD,                0x73,   R1,     NODATA}, 
....................     {cmdREAD_OCR,               0x25,   R7,     NODATA}, 
....................     {cmdCRC_ON_OFF,             0x25,   R1,     NODATA}, 
....................     {cmdSD_SEND_OP_COND,        0xFF,   R7,     NODATA}, //Actual response is R3, but has same number of bytes as R7. 
....................     {cmdSET_WR_BLK_ERASE_COUNT, 0xFF,   R1,     NODATA} 
.................... }; 
....................  
....................  
....................  
....................  
.................... /****************************************************************************** 
....................  * Prototypes 
....................  *****************************************************************************/ 
.................... extern void Delayms(BYTE milliseconds); 
.................... BYTE MDD_SDSPI_ReadMedia(void); 
.................... MEDIA_INFORMATION * MDD_SDSPI_MediaInitialize(void); 
.................... MMC_RESPONSE SendMMCCmd(BYTE cmd, DWORD address); 
....................  
.................... #if defined __C30__ || defined __C32__ 
....................     void OpenSPIM ( unsigned int sync_mode); 
....................     void CloseSPIM( void ); 
....................     unsigned char WriteSPIM( unsigned char data_out ); 
.................... #elif defined __18CXX 
....................     void OpenSPIM ( unsigned char sync_mode); 
....................     void CloseSPIM( void ); 
....................     unsigned char WriteSPIM( unsigned char data_out ); 
....................  
....................     unsigned char WriteSPIManual(unsigned char data_out); 
....................     BYTE ReadMediaManual (void); 
....................     MMC_RESPONSE SendMMCCmdManual(BYTE cmd, DWORD address); 
.................... #endif 
.................... void InitSPISlowMode(void); 
....................  
.................... #if defined __18CXX 
.................... //Private function prototypes 
.................... static void PIC18_Optimized_SPI_Write_Packet(void); 
.................... static void PIC18_Optimized_SPI_Read_Packet(void); 
.................... #endif 
....................  
.................... //-------------Function name redirects------------------------------------------ 
.................... //During the media initialization sequence, it is 
.................... //necessary to clock the media at no more than 400kHz SPI speeds, since some 
.................... //media types power up in open drain output mode and cannot run fast initially. 
.................... //On PIC18 devices, when the CPU is run at full frequency, the standard SPI  
.................... //prescalars cannot reach a low enough SPI frequency.  Therefore, we initialize 
.................... //the card at low speed using bit-banged SPI on PIC18 devices.  On  
.................... //PIC32/PIC24/dsPIC devices, the SPI module is flexible enough to reach <400kHz 
.................... //speeds regardless of CPU frequency, and therefore bit-banged code is not  
.................... //necessary.  Therefore, we use function redirects where necessary, to point to 
.................... //the proper SPI related code, given the processor type. 
....................  
.................... #if defined __18CXX 
....................     #define SendMediaSlowCmd    SendMMCCmdManual 
....................     #define WriteSPISlow        WriteSPIManual 
.................... #else 
....................     #define SendMediaSlowCmd    SendMMCCmd 
....................     #define WriteSPISlow        WriteSPIM 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... #ifdef __PIC32MX__ 
.................... /********************************************************* 
....................   Function: 
....................     static inline __attribute__((always_inline)) unsigned char SPICacutateBRG (unsigned int pb_clk, unsigned int spi_clk) 
....................   Summary: 
....................     Calculate the PIC32 SPI BRG value 
....................   Conditions: 
....................     None 
....................   Input: 
....................     pb_clk -  The value of the PIC32 peripheral clock 
....................     spi_clk - The desired baud rate 
....................   Return: 
....................     The corresponding BRG register value. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The SPICalutateBRG function is used to determine an appropriate BRG register value for the PIC32 SPI module. 
....................   Remarks: 
....................     None                                                   
....................   *********************************************************/ 
....................  
.................... static inline __attribute__((always_inline)) unsigned char SPICalutateBRG(unsigned int pb_clk, unsigned int spi_clk) 
.................... { 
....................     unsigned int brg; 
....................  
....................     brg = pb_clk / (2 * spi_clk); 
....................  
....................     if(pb_clk % (2 * spi_clk)) 
....................         brg++; 
....................  
....................     if(brg > 0x100) 
....................         brg = 0x100; 
....................  
....................     if(brg) 
....................         brg--; 
....................  
....................     return (unsigned char) brg; 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     BYTE MDD_SDSPI_MediaDetect 
....................   Summary: 
....................     Determines whether an SD card is present 
....................   Conditions: 
....................     The MDD_MediaDetect function pointer must be configured 
....................     to point to this function in FSconfig.h 
....................   Input: 
....................     None 
....................   Return Values: 
....................     TRUE -  Card detected 
....................     FALSE - No card detected 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_MediaDetect function determine if an SD card is connected to  
....................     the microcontroller. 
....................     If the MEDIA_SOFT_DETECT is not defined, the detection is done by polling 
....................     the SD card detect pin. 
....................     The MicroSD connector does not have a card detect pin, and therefore a 
....................     software mechanism must be used. To do this, the SEND_STATUS command is sent  
....................     to the card. If the card is not answering with 0x00, the card is either not  
....................     present, not configured, or in an error state. If this is the case, we try 
....................     to reconfigure the card. If the configuration fails, we consider the card not  
....................     present (it still may be present, but malfunctioning). In order to use the  
....................     software card detect mechanism, the MEDIA_SOFT_DETECT macro must be defined. 
....................      
....................   Remarks: 
....................     None                                                   
....................   *********************************************************/ 
....................  
.................... BYTE MDD_SDSPI_MediaDetect (void) 
*
01462:  MOV     W5,[W15++]
.................... { 
.................... #ifndef MEDIA_SOFT_DETECT 
....................     return(!SD_CD); 
.................... #else 
....................    MMC_RESPONSE    response; 
01464:  CLR     F72
01466:  CLR     F74
01468:  CLR     F76
....................  
....................     //First check if SPI module is enabled or not. 
....................    if (SPIENABLE == 0) 
0146A:  BTSC.B  241.7
0146C:  BRA     14CE
....................    { 
....................         unsigned char timeout; 
0146E:  CLR.B   F78
....................  
....................       //If the SPI module is not enabled, then the media has evidently not 
....................       //been initialized.  Try to send CMD0 and CMD13 to reset the device and 
....................       //get it into SPI mode (if present), and then request the status of 
....................       //the media.  If this times out, then the card is presumably not physically 
....................       //present. 
....................        
....................       InitSPISlowMode(); 
01470:  CALL    ED0
....................        
....................         //Send CMD0 to reset the media 
....................        //If the card is physically present, then we should get a valid response. 
....................         timeout = 4; 
01474:  MOV.B   #4,W0L
01476:  MOV.B   W0L,F78
....................         do 
....................         { 
....................             //Toggle chip select, to make media abandon whatever it may have been doing 
....................             //before.  This ensures the CMD0 is sent freshly after CS is asserted low, 
....................             //minimizing risk of SPI clock pulse master/slave syncronization problems,  
....................             //due to possible application noise on the SCK line. 
....................             SD_CS = 1; 
01478:  BSET.B  2F5.0
....................             WriteSPISlow(0xFF);   //Send some "extraneous" clock pulses.  If a previous 
0147A:  SETM.B  10E2
0147C:  CALL    F36
....................                                   //command was terminated before it completed normally, 
....................                                   //the card might not have received the required clocking 
....................                                   //following the transfer. 
....................             SD_CS = 0; 
01480:  BCLR.B  2F5.0
....................             timeout--; 
01482:  DEC.B   0F78
....................      
....................             //Send CMD0 to software reset the device 
....................             response = SendMediaSlowCmd(GO_IDLE_STATE, 0x0); 
01484:  CLR.B   10C2
01486:  CLR     10C4
01488:  CLR     10C6
0148A:  CALL    F58
0148E:  MOV     W0,F72
01490:  MOV     W1,F74
01492:  MOV     W2,F76
....................         } while((response.r1._byte != 0x01) && (timeout != 0)); 
01494:  MOV     F72,W4
01496:  CP.B    W4L,#1
01498:  BRA     Z,149E
0149A:  CP0.B   F78
0149C:  BRA     NZ,1478
....................  
....................        //Check if response was invalid (R1 response byte should be = 0x01 after GO_IDLE_STATE) 
....................        if(response.r1._byte != 0x01) 
0149E:  MOV     F72,W4
014A0:  CP.B    W4L,#1
014A2:  BRA     Z,14B0
....................        { 
....................            CloseSPIM(); 
014A4:  CALL    1098
....................            return FALSE; 
014A8:  CLR.B   0
014AA:  BRA     1516
....................        }     
014AC:  GOTO    14CA
....................        else 
....................        { 
....................            //Card is presumably present.  The SDI pin should have a pull up resistor on 
....................            //it, so the odds of SDI "floating" to 0x01 after sending CMD0 is very 
....................            //remote, unless the media is genuinely present.  Therefore, we should 
....................            //try to perform a full card initialization sequence now. 
....................           MDD_SDSPI_MediaInitialize();    //Can block and take a long time to execute. 
014B0:  CALL    10FE
....................           if(mediaInformation.errorCode == MEDIA_NO_ERROR) 
014B4:  CP0.B   D4E
014B6:  BRA     NZ,14C2
....................           { 
....................              /* if the card was initialized correctly, it means it is present */ 
....................              return TRUE; 
014B8:  MOV.B   #1,W0L
014BA:  MOV.B   W0L,0
014BC:  BRA     1516
....................           } 
014BE:  GOTO    14CA
....................           else  
....................           { 
....................               CloseSPIM(); 
014C2:  CALL    1098
....................              return FALSE; 
014C6:  CLR.B   0
014C8:  BRA     1516
....................           }       
....................  
....................        }     
....................    }//if (SPIENABLE == 0) 
014CA:  GOTO    1512
....................    else 
....................    { 
....................        //The SPI module was already enabled.  This most likely means the media is 
....................        //present and has already been initialized.  However, it is possible that 
....................        //the user could have unplugged the media, in which case it is no longer 
....................        //present.  We should send it a command, to check the status. 
....................        response = SendMMCCmd(SEND_STATUS,0x0); 
014CE:  MOV.B   #6,W0L
014D0:  MOV.B   W0L,10C2
014D2:  CLR     10C4
014D4:  CLR     10C6
014D6:  CALL    F58
014DA:  MOV     W0,F72
014DC:  MOV     W1,F74
014DE:  MOV     W2,F76
....................        if((response.r2._word & 0xEC0C) != 0x0000) 
014E0:  MOV     #EC0C,W0
014E2:  AND     F72,W0
014E4:  MOV     W0,W5
014E6:  CP0     W5
014E8:  BRA     Z,150C
....................        { 
....................            //The card didn't respond with the expected result.  This probably 
....................            //means it is no longer present.  We can try to re-initialized it, 
....................            //just to be doubly sure. 
....................           CloseSPIM(); 
014EA:  CALL    1098
....................           MDD_SDSPI_MediaInitialize();    //Can block and take a long time to execute. 
014EE:  CALL    10FE
....................           if(mediaInformation.errorCode == MEDIA_NO_ERROR) 
014F2:  CP0.B   D4E
014F4:  BRA     NZ,1500
....................           { 
....................              /* if the card was initialized correctly, it means it is present */ 
....................              return TRUE; 
014F6:  MOV.B   #1,W0L
014F8:  MOV.B   W0L,0
014FA:  BRA     1516
....................           } 
014FC:  GOTO    1508
....................           else  
....................           { 
....................               CloseSPIM(); 
01500:  CALL    1098
....................              return FALSE; 
01504:  CLR.B   0
01506:  BRA     1516
....................           } 
....................        } 
01508:  GOTO    1512
....................        else 
....................        { 
....................            //The CMD13 response to SEND_STATUS was valid.  This presumably 
....................            //means the card is present and working normally. 
....................            return TRUE; 
0150C:  MOV.B   #1,W0L
0150E:  MOV.B   W0L,0
01510:  BRA     1516
....................         }           
....................  
....................    } 
....................  
....................     //Should theoretically never execute to here.  All pathways should have  
....................     //already returned with the status. 
....................     return TRUE; 
01512:  MOV.B   #1,W0L
01514:  MOV.B   W0L,0
....................  
.................... #endif 
01516:  MOV     [--W15],W5
01518:  RETURN  
....................  
.................... }//end MediaDetect 
....................  
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     WORD MDD_SDSPI_ReadSectorSize (void) 
....................   Summary: 
....................     Determines the current sector size on the SD card 
....................   Conditions: 
....................     MDD_MediaInitialize() is complete 
....................   Input: 
....................     None 
....................   Return: 
....................     The size of the sectors for the physical media 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_ReadSectorSize function is used by the 
....................     USB mass storage class to return the card's sector 
....................     size to the PC on request. 
....................   Remarks: 
....................     None 
....................   *********************************************************/ 
....................  
.................... WORD MDD_SDSPI_ReadSectorSize(void) 
.................... { 
....................     return gMediaSectorSize; 
.................... } 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     DWORD MDD_SDSPI_ReadCapacity (void) 
....................   Summary: 
....................     Determines the current capacity of the SD card 
....................   Conditions: 
....................     MDD_MediaInitialize() is complete 
....................   Input: 
....................     None 
....................   Return: 
....................     The capacity of the device 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_ReadCapacity function is used by the 
....................     USB mass storage class to return the total number 
....................     of sectors on the card. 
....................   Remarks: 
....................     None 
....................   *********************************************************/ 
.................... DWORD MDD_SDSPI_ReadCapacity(void) 
.................... { 
....................     return (MDD_SDSPI_finalLBA); 
.................... } 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     WORD MDD_SDSPI_InitIO (void) 
....................   Summary: 
....................     Initializes the I/O lines connected to the card 
....................   Conditions: 
....................     MDD_MediaInitialize() is complete.  The MDD_InitIO 
....................     function pointer is pointing to this function. 
....................   Input: 
....................     None 
....................   Return: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_InitIO function initializes the I/O 
....................     pins connected to the SD card. 
....................   Remarks: 
....................     None 
....................   *********************************************************/ 
....................  
.................... void MDD_SDSPI_InitIO (void) 
.................... { 
....................     // Turn off the card 
....................    #if !defined(MEDIA_SOFT_DETECT) 
....................     SD_CD_TRIS = INPUT;            //Card Detect - input 
....................    #endif     
....................     SD_CS = 1;                     //Initialize Chip Select line 
*
00EB2:  BSET.B  2F5.0
....................     SD_CS_TRIS = OUTPUT;           //Card Select - output 
00EB4:  BCLR.B  2F1.0
....................    #if defined(SD_WE_TRIS) 
....................     SD_WE_TRIS = INPUT;            //Write Protect - input 
00EB6:  BSET.B  800.0
....................    #endif 
....................  
.................... #if defined   (__dsPIC33E__) || defined (__PIC24E__) 
00EB8:  RETURN  
....................     SD_CS_ANSEL = 0; 
....................     SD_SCK_ANSEL = 0; 
....................     SD_SDI_ANSEL = 0; 
....................     SD_SDO_ANSEL = 0; 
.................... #endif     
.................... } 
....................  
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     BYTE MDD_SDSPI_ShutdownMedia (void) 
....................   Summary: 
....................     Disables the SD card 
....................   Conditions: 
....................     The MDD_ShutdownMedia function pointer is pointing  
....................     towards this function. 
....................   Input: 
....................     None 
....................   Return: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     This function will disable the SPI port and deselect 
....................     the SD card. 
....................   Remarks: 
....................     None 
....................   *********************************************************/ 
....................  
.................... BYTE MDD_SDSPI_ShutdownMedia(void) 
.................... { 
....................     // close the spi bus 
....................     CloseSPIM(); 
....................      
....................     // deselect the device 
....................     SD_CS = 1; 
....................  
....................     return 0; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     MMC_RESPONSE SendMMCCmd (BYTE cmd, DWORD address) 
....................   Summary: 
....................     Sends a command packet to the SD card. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     None. 
....................   Return Values: 
....................     MMC_RESPONSE    - The response from the card 
....................                     - Bit 0 - Idle state 
....................                     - Bit 1 - Erase Reset 
....................                     - Bit 2 - Illegal Command 
....................                     - Bit 3 - Command CRC Error 
....................                     - Bit 4 - Erase Sequence Error 
....................                     - Bit 5 - Address Error 
....................                     - Bit 6 - Parameter Error 
....................                     - Bit 7 - Unused. Always 0. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     SendMMCCmd prepares a command packet and sends it out over the SPI interface. 
....................     Response data of type 'R1' (as indicated by the SD/MMC product manual is returned. 
....................   Remarks: 
....................     None. 
....................   *****************************************************************************/ 
....................  
.................... MMC_RESPONSE SendMMCCmd(BYTE cmd, DWORD address) 
*
00F58:  MOV     W5,[W15++]
.................... { 
....................     MMC_RESPONSE    response; 
00F5A:  CLR     10C8
00F5C:  CLR     10CA
00F5E:  CLR     10CC
....................     CMD_PACKET  CmdPacket; 
00F60:  CLR     10CE
00F62:  CLR     10D0
00F64:  CLR     10D2
00F66:  CLR     10D4
....................     WORD timeout; 
00F68:  CLR     10D6
....................     DWORD longTimeout; 
00F6A:  CLR     10D8
00F6C:  CLR     10DA
....................      
....................     SD_CS = 0;                           //Select card 
00F6E:  BCLR.B  2F5.0
....................      
....................     // Copy over data 
....................     CmdPacket.cmd        = sdmmc_cmdtable[cmd].CmdCode; 
00F70:  MOV.B   10C2,W0L
00F72:  CLR.B   1
00F74:  SL      W0,#2,W5
00F76:  MOV     #D62,W4
00F78:  ADD     W5,W4,W0
00F7A:  MOV     10D4,W4
00F7C:  MOV.B   [W0+#0],W4L
00F7E:  MOV     W4,10D4
....................     CmdPacket.address    = address; 
00F80:  PUSH    10C4
00F82:  POP     10D0
00F84:  PUSH    10C6
00F86:  POP     10D2
....................     CmdPacket.crc        = sdmmc_cmdtable[cmd].CRC;       // Calc CRC here 
00F88:  MOV.B   10C2,W0L
00F8A:  CLR.B   1
00F8C:  SL      W0,#2,W5
00F8E:  ADD     W5,#1,W5
00F90:  MOV     W5,W0
00F92:  MOV     #D62,W4
00F94:  ADD     W0,W4,W0
00F96:  MOV     10CE,W4
00F98:  MOV.B   [W0+#0],W4L
00F9A:  MOV     W4,10CE
....................      
....................     CmdPacket.TRANSMIT_BIT = 1;             //Set Tranmission bit 
00F9C:  BSET.B  10D4.6
....................  
....................      #ifdef __DEBUG_UART   
....................      PrintROMASCIIStringUART("SendMMCCmdFast cmd="); 
....................      PrintRAMBytesUART(((unsigned char*)&cmd), 1); 
....................      PrintROMASCIIStringUART(" cmd="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.cmd), 1); 
....................      PrintROMASCIIStringUART(" addy="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.address), 4); 
....................      PrintROMASCIIStringUART(" crc="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.crc), 1); 
....................      PrintROMASCIIStringUART(" type="); 
....................      char type; 
....................      type = sdmmc_cmdtable[cmd].responsetype; 
....................      PrintRAMBytesUART(((unsigned char*)&type), 1); 
....................      #endif 
....................  
....................     WriteSPIM(CmdPacket.cmd);                //Send Command 
00F9E:  MOV.B   10D4,W0L
00FA0:  MOV.B   W0L,10E2
00FA2:  CALL    F36
....................     WriteSPIM(CmdPacket.addr3);              //Most Significant Byte 
00FA6:  MOV.B   10D3,W0L
00FA8:  MOV.B   W0L,10E2
00FAA:  CALL    F36
....................     WriteSPIM(CmdPacket.addr2); 
00FAE:  MOV.B   10D2,W0L
00FB0:  MOV.B   W0L,10E2
00FB2:  CALL    F36
....................     WriteSPIM(CmdPacket.addr1); 
00FB6:  MOV.B   10D1,W0L
00FB8:  MOV.B   W0L,10E2
00FBA:  CALL    F36
....................     WriteSPIM(CmdPacket.addr0);              //Least Significant Byte 
00FBE:  MOV.B   10D0,W0L
00FC0:  MOV.B   W0L,10E2
00FC2:  CALL    F36
....................     WriteSPIM(CmdPacket.crc);                //Send CRC 
00FC6:  MOV.B   10CE,W0L
00FC8:  MOV.B   W0L,10E2
00FCA:  CALL    F36
....................  
....................     //Special handling for CMD12 (STOP_TRANSMISSION).  The very first byte after 
....................     //sending the command packet may contain bogus non-0xFF data.  This  
....................     //"residual data" byte should not be interpreted as the R1 response byte. 
....................     if(cmd == STOP_TRANSMISSION) 
00FCE:  MOV     10C2,W4
00FD0:  CP.B    W4L,#5
00FD2:  BRA     NZ,FD8
....................     { 
....................         MDD_SDSPI_ReadMedia(); //Perform dummy read to fetch the residual non R1 byte 
00FD4:  CALL    F4A
....................     }  
....................  
....................     //Loop until we get a response from the media.  Delay (NCR) could be up  
....................     //to 8 SPI byte times.  First byte of response is always the equivalent of  
....................     //the R1 byte, even for R1b, R2, R3, R7 responses. 
....................     timeout = NCR_TIMEOUT; 
00FD8:  MOV     #14,W4
00FDA:  MOV     W4,10D6
....................     do 
....................     { 
....................         response.r1._byte = MDD_SDSPI_ReadMedia(); 
00FDC:  CALL    F4A
00FE0:  MOV.B   W0L,10C8
....................         timeout--; 
00FE2:  DEC     10D6
....................        #ifdef __DEBUG_UART 
....................         if (response.r1._byte != MMC_FLOATING_BUS) 
....................         { 
....................             PrintROMASCIIStringUART(" r1="); 
....................             PrintRAMBytesUART(&response.r1._byte, 1); 
....................         } 
....................        #endif 
....................     }while((response.r1._byte == MMC_FLOATING_BUS) && (timeout != 0)); 
00FE4:  MOV     10C8,W4
00FE6:  XOR.B   #FF,W4L
00FE8:  BRA     NZ,FEE
00FEA:  CP0     10D6
00FEC:  BRA     NZ,FDC
....................      
....................     //Check if we should read more bytes, depending upon the response type expected.   
....................     if(sdmmc_cmdtable[cmd].responsetype == R2) 
00FEE:  MOV.B   10C2,W0L
00FF0:  CLR.B   1
00FF2:  SL      W0,#2,W5
00FF4:  ADD     W5,#2,W5
00FF6:  MOV     W5,W0
00FF8:  MOV     #D62,W4
00FFA:  ADD     W0,W4,W0
00FFC:  MOV.B   [W0],W4L
00FFE:  CP.B    W4L,#2
01000:  BRA     NZ,1010
....................     { 
....................         response.r2._byte1 = response.r1._byte; //We already received the first byte, just make sure it is in the correct location in the struct. 
01002:  MOV.B   10C8,W0L
01004:  MOV.B   W0L,10C9
....................         response.r2._byte0 = MDD_SDSPI_ReadMedia(); //Fetch the second byte of the response. 
01006:  CALL    F4A
0100A:  MOV.B   W0L,10C8
....................         
....................        #ifdef __DEBUG_UART 
....................         PrintROMASCIIStringUART(" r2="); 
....................         PrintRAMBytesUART(&response.r2._byte0, 1); 
....................        #endif         
....................     } 
0100C:  GOTO    1074
....................     else if(sdmmc_cmdtable[cmd].responsetype == R1b) 
01010:  MOV.B   10C2,W0L
01012:  CLR.B   1
01014:  SL      W0,#2,W5
01016:  ADD     W5,#2,W5
01018:  MOV     W5,W0
0101A:  MOV     #D62,W4
0101C:  ADD     W0,W4,W0
0101E:  MOV.B   [W0],W4L
01020:  CP.B    W4L,#1
01022:  BRA     NZ,1048
....................     { 
....................         //Keep trying to read from the media, until it signals it is no longer 
....................         //busy.  It will continuously send 0x00 bytes until it is not busy. 
....................         //A non-zero value means it is ready for the next command. 
....................         //The R1b response is received after a CMD12 STOP_TRANSMISSION 
....................         //command, where the media card may be busy writing its internal buffer 
....................         //to the flash memory.  This can typically take a few milliseconds,  
....................         //with a recommended maximum timeout of 250ms or longer for SD cards. 
....................         longTimeout = WRITE_TIMEOUT; 
01024:  CLR     10D8
01026:  MOV     #A,W4
01028:  MOV     W4,10DA
....................         do 
....................         { 
....................             response.r1._byte = MDD_SDSPI_ReadMedia(); 
0102A:  CALL    F4A
0102E:  MOV.B   W0L,10C8
....................             longTimeout--; 
01030:  DEC     10D8
01032:  BTSS.B  42.0
01034:  DEC     10DA
....................         }while((response.r1._byte == 0x00) && (longTimeout != 0)); 
01036:  CP0.B   10C8
01038:  BRA     NZ,1042
0103A:  CP0     10D8
0103C:  BRA     NZ,102A
0103E:  CP0     10DA
01040:  BRA     NZ,102A
....................  
....................         response.r1._byte = 0x00; 
01042:  CLR.B   10C8
....................     } 
01044:  GOTO    1074
....................     else if (sdmmc_cmdtable[cmd].responsetype == R7) //also used for response R3 type 
01048:  MOV.B   10C2,W0L
0104A:  CLR.B   1
0104C:  SL      W0,#2,W5
0104E:  ADD     W5,#2,W5
01050:  MOV     W5,W0
01052:  MOV     #D62,W4
01054:  ADD     W0,W4,W0
01056:  MOV.B   [W0],W4L
01058:  CP.B    W4L,#4
0105A:  BRA     NZ,1074
....................     { 
....................         //Fetch the other four bytes of the R3 or R7 response. 
....................         //Note: The SD card argument response field is 32-bit, big endian format. 
....................         //However, the C compiler stores 32-bit values in little endian in RAM. 
....................         //When writing to the _returnVal/argument bytes, make sure the order it  
....................         //gets stored in is correct.       
....................         response.r7.bytewise.argument._byte3 = MDD_SDSPI_ReadMedia(); 
0105C:  CALL    F4A
01060:  MOV.B   W0L,10CD
....................         response.r7.bytewise.argument._byte2 = MDD_SDSPI_ReadMedia(); 
01062:  CALL    F4A
01066:  MOV.B   W0L,10CC
....................         response.r7.bytewise.argument._byte1 = MDD_SDSPI_ReadMedia(); 
01068:  CALL    F4A
0106C:  MOV.B   W0L,10CB
....................         response.r7.bytewise.argument._byte0 = MDD_SDSPI_ReadMedia(); 
0106E:  CALL    F4A
01072:  MOV.B   W0L,10CA
....................     } 
....................  
....................     WriteSPIM(0xFF);    //Device requires at least 8 clock pulses after  
01074:  SETM.B  10E2
01076:  CALL    F36
....................                              //the response has been sent, before if can process 
....................                              //the next command.  CS may be high or low. 
....................  
....................     // see if we are expecting more data or not 
....................     if(!(sdmmc_cmdtable[cmd].moredataexpected)) 
0107A:  MOV.B   10C2,W0L
0107C:  CLR.B   1
0107E:  SL      W0,#2,W5
01080:  ADD     W5,#3,W5
01082:  MOV     W5,W0
01084:  MOV     #D62,W4
01086:  ADD     W0,W4,W0
01088:  CP0.B   [W0]
0108A:  BRA     NZ,108E
....................         SD_CS = 1; 
0108C:  BSET.B  2F5.0
....................       
....................      #ifdef __DEBUG_UART 
....................      PrintROMASCIIStringUART(" r1="); 
....................      PrintRAMBytesUART(((unsigned char*)&response.r1._byte), 1); 
....................      #endif 
....................  
....................  
....................     #ifdef __DEBUG_UART   
....................     UARTSendLineFeedCarriageReturn(); 
....................     #endif 
....................  
....................     return(response); 
0108E:  MOV     10C8,W0
01090:  MOV     10CA,W1
01092:  MOV     10CC,W2
01094:  MOV     [--W15],W5
01096:  RETURN  
.................... } 
....................  
.................... #ifdef __18CXX 
.................... /***************************************************************************** 
....................   Function: 
....................     MMC_RESPONSE SendMMCCmdManual (BYTE cmd, DWORD address) 
....................   Summary: 
....................     Sends a command packet to the SD card with bit-bang SPI. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     Need input cmd index into a rom table of implemented commands. 
....................     Also needs 4 bytes of data as address for some commands (also used for 
....................     other purposes in other commands). 
....................   Return Values: 
....................     Assuming an "R1" type of response, each bit will be set depending upon status: 
....................     MMC_RESPONSE    - The response from the card 
....................                     - Bit 0 - Idle state 
....................                     - Bit 1 - Erase Reset 
....................                     - Bit 2 - Illegal Command 
....................                     - Bit 3 - Command CRC Error 
....................                     - Bit 4 - Erase Sequence Error 
....................                     - Bit 5 - Address Error 
....................                     - Bit 6 - Parameter Error 
....................                     - Bit 7 - Unused. Always 0. 
....................     Other response types (ex: R3/R7) have up to 5 bytes of response.  The first 
....................     byte is always the same as the R1 response.  The contents of the other bytes  
....................     depends on the command. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     SendMMCCmd prepares a command packet and sends it out over the SPI interface. 
....................     Response data of type 'R1' (as indicated by the SD/MMC product manual is returned. 
....................     This function is intended to be used when the clock speed of a PIC18 device is 
....................     so high that the maximum SPI divider can't reduce the clock below the maximum 
....................     SD card initialization sequence speed. 
....................   Remarks: 
....................     None. 
....................   ***************************************************************************************/ 
.................... MMC_RESPONSE SendMMCCmdManual(BYTE cmd, DWORD address) 
.................... { 
....................     BYTE index; 
....................     MMC_RESPONSE    response; 
....................     CMD_PACKET  CmdPacket; 
....................     WORD timeout; 
....................      
....................     SD_CS = 0;                           //Select card 
....................      
....................     // Copy over data 
....................     CmdPacket.cmd        = sdmmc_cmdtable[cmd].CmdCode; 
....................     CmdPacket.address    = address; 
....................     CmdPacket.crc        = sdmmc_cmdtable[cmd].CRC;       // Calc CRC here 
....................     
....................     CmdPacket.TRANSMIT_BIT = 1;             //Set Tranmission bit 
....................  
....................      #ifdef __DEBUG_UART   
....................      PrintROMASCIIStringUART("SendMMCCmdManual cmd="); 
....................      PrintRAMBytesUART(((unsigned char*)&cmd), 1); 
....................      PrintROMASCIIStringUART(" cmd="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.cmd), 1); 
....................      PrintROMASCIIStringUART(" addy="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.address), 4); 
....................      PrintROMASCIIStringUART(" crc="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.crc), 1); 
....................      PrintROMASCIIStringUART(" type="); 
....................      char type; 
....................      type = sdmmc_cmdtable[cmd].responsetype; 
....................      PrintRAMBytesUART(((unsigned char*)&type), 1); 
....................      #endif 
....................  
....................     WriteSPIManual(CmdPacket.cmd);                //Send Command 
....................     WriteSPIManual(CmdPacket.addr3);              //Most Significant Byte 
....................     WriteSPIManual(CmdPacket.addr2); 
....................     WriteSPIManual(CmdPacket.addr1); 
....................     WriteSPIManual(CmdPacket.addr0);              //Least Significant Byte 
....................     WriteSPIManual(CmdPacket.crc);                //Send CRC 
....................  
....................     //Special handling for CMD12 (STOP_TRANSMISSION).  The very first byte after 
....................     //sending the command packet may contain bogus non-0xFF data.  This  
....................     //"residual data" byte should not be interpreted as the R1 response byte. 
....................     if(cmd == STOP_TRANSMISSION) 
....................     { 
....................         ReadMediaManual(); //Perform dummy read to fetch the residual non R1 byte 
....................     }  
....................  
....................     //Loop until we get a response from the media.  Delay (NCR) could be up  
....................     //to 8 SPI byte times.  First byte of response is always the equivalent of  
....................     //the R1 byte, even for R1b, R2, R3, R7 responses. 
....................     timeout = NCR_TIMEOUT; 
....................     do 
....................     { 
....................         response.r1._byte = ReadMediaManual(); 
....................         timeout--; 
....................     }while((response.r1._byte == MMC_FLOATING_BUS) && (timeout != 0)); 
....................      
....................  
....................      #ifdef __DEBUG_UART   
....................      PrintROMASCIIStringUART(" r1="); 
....................      PrintRAMBytesUART(((unsigned char*)&response.r1._byte), 1); 
....................      #endif 
....................  
....................     //Check if we should read more bytes, depending upon the response type expected.   
....................     if(sdmmc_cmdtable[cmd].responsetype == R2) 
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART(" getr2"); 
....................         #endif 
....................      
....................         response.r2._byte1 = response.r1._byte; //We already received the first byte, just make sure it is in the correct location in the struct. 
....................         response.r2._byte0 = ReadMediaManual(); //Fetch the second byte of the response. 
....................     } 
....................     else if(sdmmc_cmdtable[cmd].responsetype == R1b) 
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART(" getr1b"); 
....................         #endif     
....................         //Keep trying to read from the media, until it signals it is no longer 
....................         //busy.  It will continuously send 0x00 bytes until it is not busy. 
....................         //A non-zero value means it is ready for the next command. 
....................         timeout = 0xFFFF; 
....................         do 
....................         { 
....................             response.r1._byte = ReadMediaManual(); 
....................             timeout--; 
....................         }while((response.r1._byte == 0x00) && (timeout != 0)); 
....................  
....................         response.r1._byte = 0x00; 
....................     } 
....................     else if (sdmmc_cmdtable[cmd].responsetype == R7) //also used for response R3 type 
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART(" getr7"); 
....................         #endif     
....................         //Fetch the other four bytes of the R3 or R7 response. 
....................         //Note: The SD card argument response field is 32-bit, big endian format. 
....................         //However, the C compiler stores 32-bit values in little endian in RAM. 
....................         //When writing to the _returnVal/argument bytes, make sure the order it  
....................         //gets stored in is correct.       
....................         response.r7.bytewise.argument._byte3 = ReadMediaManual(); 
....................         response.r7.bytewise.argument._byte2 = ReadMediaManual(); 
....................         response.r7.bytewise.argument._byte1 = ReadMediaManual(); 
....................         response.r7.bytewise.argument._byte0 = ReadMediaManual(); 
....................     } 
....................      
....................  
....................     WriteSPIManual(0xFF);    //Device requires at least 8 clock pulses after  
....................                              //the response has been sent, before if can process 
....................                              //the next command.  CS may be high or low. 
....................  
....................     // see if we are expecting more data or not 
....................     if(!(sdmmc_cmdtable[cmd].moredataexpected)) 
....................     { 
....................        #ifdef __DEBUG_UART   
....................        PrintROMASCIIStringUART(" csup"); 
....................        #endif 
....................  
....................         SD_CS = 1; 
....................     } 
....................  
....................      #ifdef __DEBUG_UART   
....................      PrintROMASCIIStringUART(" r1="); 
....................      PrintRAMBytesUART(((unsigned char*)&response.r1._byte), 1); 
....................      #endif 
....................  
....................  
....................     #ifdef __DEBUG_UART   
....................     UARTSendLineFeedCarriageReturn(); 
....................     #endif 
....................  
....................     return(response); 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE MDD_SDSPI_SectorRead (DWORD sector_addr, BYTE * buffer) 
....................   Summary: 
....................     Reads a sector of data from an SD card. 
....................   Conditions: 
....................     The MDD_SectorRead function pointer must be pointing towards this function. 
....................   Input: 
....................     sector_addr - The address of the sector on the card. 
....................     buffer -      The buffer where the retrieved data will be stored.  If 
....................                   buffer is NULL, do not store the data anywhere. 
....................   Return Values: 
....................     TRUE -  The sector was read successfully 
....................     FALSE - The sector could not be read 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The MDD_SDSPI_SectorRead function reads a sector of data bytes (512 bytes)  
....................     of data from the SD card starting at the sector address and stores them in  
....................     the location pointed to by 'buffer.' 
....................   Remarks: 
....................     The card expects the address field in the command packet to be a byte address. 
....................     The sector_addr value is converted to a byte address by shifting it left nine 
....................     times (multiplying by 512). 
....................      
....................     This function performs a synchronous read operation.  In other words, this 
....................     function is a blocking function, and will not return until either the data 
....................     has fully been read, or, a timeout or other error occurred. 
....................   ***************************************************************************************/ 
.................... BYTE MDD_SDSPI_SectorRead(DWORD sector_addr, BYTE* buffer) 
.................... { 
....................     ASYNC_IO info; 
*
01722:  CLR     109E
01724:  CLR     10A0
01726:  CLR     10A2
01728:  CLR     10A4
0172A:  CLR     10A6
0172C:  CLR     10A8
0172E:  CLR     10AA
....................     BYTE status; 
01730:  CLR.B   10AC
....................      
....................     //Initialize info structure for using the MDD_SDSPI_AsyncReadTasks() function. 
....................     info.wNumBytes = 512; 
01732:  MOV     #200,W4
01734:  MOV     W4,109E
....................     info.dwBytesRemaining = 512; 
01736:  MOV     #200,W4
01738:  MOV     W4,10A0
0173A:  CLR     10A2
....................     info.pBuffer = buffer; 
0173C:  PUSH    109C
0173E:  POP     10A4
....................     info.dwAddress = sector_addr; 
01740:  PUSH    1098
01742:  POP     10A6
01744:  PUSH    109A
01746:  POP     10A8
....................     info.bStateVariable = ASYNC_READ_QUEUED; 
01748:  MOV.B   #1,W0L
0174A:  MOV.B   W0L,10AA
....................      
....................     //Blocking loop, until the state machine finishes reading the sector, 
....................     //or a timeout or other error occurs.  MDD_SDSPI_AsyncReadTasks() will always 
....................     //return either ASYNC_READ_COMPLETE or ASYNC_READ_FAILED eventually  
....................     //(could take awhile in the case of timeout), so this won't be a totally 
....................     //infinite blocking loop. 
....................     while(1) 
....................     { 
....................         status = MDD_SDSPI_AsyncReadTasks(&info); 
0174C:  MOV     #109E,W4
0174E:  MOV     W4,10B2
01750:  CALL    151A
01754:  MOV.B   W0L,10AC
....................         if(status == ASYNC_READ_COMPLETE) 
01756:  CP0.B   10AC
01758:  BRA     NZ,1764
....................         { 
....................             return TRUE; 
0175A:  MOV.B   #1,W0L
0175C:  MOV.B   W0L,0
0175E:  BRA     1774
....................         } 
01760:  GOTO    176E
....................         else if(status == ASYNC_READ_ERROR) 
01764:  MOV     10AC,W4
01766:  XOR.B   #FF,W4L
01768:  BRA     NZ,176E
....................         { 
....................             return FALSE; 
0176A:  CLR.B   0
0176C:  BRA     1774
....................         }  
0176E:  GOTO    174C
....................     }        
....................  
....................     //Impossible to get here, but we will return a value anyay to avoid possible  
....................     //compiler warnings. 
....................     return FALSE; 
01772:  CLR.B   0
01774:  RETURN  
.................... }     
....................  
....................   
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE MDD_SDSPI_AsyncReadTasks(ASYNC_IO* info) 
....................   Summary: 
....................     Speed optimized, non-blocking, state machine based read function that reads  
....................     data packets from the media, and copies them to a user specified RAM buffer. 
....................   Pre-Conditions: 
....................     The ASYNC_IO structure must be initialized correctly, prior to calling 
....................     this function for the first time.  Certain parameters, such as the user 
....................     data buffer pointer (pBuffer) in the ASYNC_IO struct are allowed to be changed 
....................     by the application firmware, in between each call to MDD_SDSPI_AsyncReadTasks(). 
....................     Additionally, the media and microcontroller SPI module should have already  
....................     been initalized before using this function.  This function is mutually 
....................     exclusive with the MDD_SDSPI_AsyncWriteTasks() function.  Only one operation 
....................     (either one read or one write) is allowed to be in progress at a time, as 
....................     both functions share statically allocated resources and monopolize the SPI bus. 
....................   Input: 
....................     ASYNC_IO* info -        A pointer to a ASYNC_IO structure.  The  
....................                             structure contains information about how to complete 
....................                             the read operation (ex: number of total bytes to read, 
....................                             where to copy them once read, maximum number of bytes 
....................                             to return for each call to MDD_SDSPI_AsyncReadTasks(), etc.). 
....................   Return Values: 
....................     BYTE - Returns a status byte indicating the current state of the read  
....................             operation. The possible return values are: 
....................              
....................             ASYNC_READ_BUSY - Returned when the state machine is busy waiting for 
....................                              a data start token from the media.  The media has a 
....................                              random access time, which can often be quite long 
....................                              (<= ~3ms typ, with maximum of 100ms).  No data 
....................                              has been copied yet in this case, and the application 
....................                              should keep calling MDD_SDSPI_AsyncReadTasks() until either 
....................                              an error/timeout occurs, or ASYNC_READ_NEW_PACKET_READY 
....................                              is returned. 
....................             ASYNC_READ_NEW_PACKET_READY -   Returned after a single packet, of 
....................                                             the specified size (in info->numBytes), 
....................                                             is ready to be read from the  
....................                                             media and copied to the user  
....................                                             specified data buffer.  Often, after 
....................                                             receiving this return value, the  
....................                                             application firmware would want to 
....................                                             update the info->pReceiveBuffer pointer 
....................                                             before calling MDD_SDSPI_AsyncReadTasks() 
....................                                             again.  This way, the application can 
....................                                             begin fetching the next packet worth 
....................                                             of data, while still using/consuming 
....................                                             the previous packet of data. 
....................             ASYNC_READ_COMPLETE - Returned when all data bytes in the read  
....................                                  operation have been read and returned successfully, 
....................                                  and the media is now ready for the next operation. 
....................             ASYNC_READ_ERROR - Returned when some failure occurs.  This could be 
....................                                either due to a media timeout, or due to some other 
....................                                unknown type of error.  In this case, the  
....................                                MDD_SDSPI_AsyncReadTasks() handler will terminate 
....................                                the read attempt and will try to put the media  
....................                                back in a default state, ready for a new command.   
....................                                The application firmware may then retry the read 
....................                                attempt (if desired) by re-initializing the  
....................                                ASYNC_IO structure and setting the  
....................                                bStateVariable = ASYNC_READ_QUEUED. 
....................  
....................              
....................   Side Effects: 
....................     Uses the SPI bus and the media.  The media and SPI bus should not be 
....................     used by any other function until the read operation has either completed 
....................     successfully, or returned with the ASYNC_READ_ERROR condition. 
....................   Description: 
....................     Speed optimized, non-blocking, state machine based read function that reads  
....................     data packets from the media, and copies them to a user specified RAM buffer. 
....................     This function uses the multi-block read command (and stop transmission command)  
....................     to perform fast reads of data.  The total amount of data that will be returned  
....................     on any given call to MDD_SDSPI_AsyncReadTasks() will be the info->numBytes parameter. 
....................     However, if the function is called repeatedly, with info->bytesRemaining set 
....................     to a large number, this function can successfully fetch data sizes >> than 
....................     the block size (theoretically anything up to ~4GB, since bytesRemaining is  
....................     a 32-bit DWORD).  The application firmware should continue calling  
....................     MDD_SDSPI_AsyncReadTasks(), until the ASYNC_READ_COMPLETE value is returned  
....................     (or ASYNC_READ_ERROR), even if it has already received all of the data expected. 
....................     This is necessary, so the state machine can issue the CMD12 (STOP_TRANMISSION)  
....................     to terminate the multi-block read operation, once the total expected number  
....................     of bytes have been read.  This puts the media back into the default state  
....................     ready for a new command. 
....................      
....................     During normal/successful operations, calls to MDD_SDSPI_AsyncReadTasks()  
....................     would typically return: 
....................     1. ASYNC_READ_BUSY - repeatedly up to several milliseconds, then  
....................     2. ASYNC_READ_NEW_PACKET_READY - repeatedly, until 512 bytes [media read  
....................         block size] is received, then  
....................     3. Back to ASYNC_READ_BUSY (for awhile, may be short), then 
....................     4. Back to ASYNC_READ_NEW_PACKET_READY (repeatedly, until the next 512 byte 
....................        boundary, then back to #3, etc. 
....................     5. After all data is received successfully, then the function will return  
....................        ASYNC_READ_COMPLETE, for all subsequent calls (until a new read operation 
....................        is started, by re-initializing the ASYNC_IO structure, and re-calling 
....................        the function). 
....................      
....................   Remarks: 
....................     This function will monopolize the SPI module during the operation.  Do not 
....................     use the SPI module for any other purpose, while a fetch operation is in 
....................     progress.  Additionally, the ASYNC_IO structure must not be modified 
....................     in a different context, while the MDD_SDSPI_AsyncReadTasks() function is executing. 
....................     In between calls to MDD_SDSPI_AsyncReadTasks(), certain parameters, namely the 
....................     info->numBytes and info->pReceiveBuffer are allowed to change however. 
....................      
....................     The bytesRemaining value must always be an exact integer multiple of numBytes  
....................     for the function to operate correctly.  Additionally, it is recommended, although 
....................     not essential, for the bytesRemaining to be an integer multiple of the media 
....................     read block size. 
....................      
....................     When starting a read operation, the info->stateVariable must be initalized to 
....................     ASYNC_READ_QUEUED.  All other fields in the info structure should also be 
....................     initialized correctly. 
....................      
....................     The info->wNumBytes must always be less than or equal to the media block size, 
....................     (which is 512 bytes).  Additionally, info->wNumBytes must always be an exact  
....................     integer factor of the media block size (unless info->dwBytesRemaining is less 
....................     than the media block size).  Example values that are allowed for info->wNumBytes 
....................     are: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512. 
....................   *****************************************************************************/ 
....................  
.................... BYTE MDD_SDSPI_AsyncReadTasks(ASYNC_IO* info) 
*
0151A:  MOV     W5,[W15++]
.................... { 
....................     BYTE bData; 
0151C:  CLR.B   10B4
....................     MMC_RESPONSE response; 
0151E:  CLR     10B6
01520:  CLR     10B8
01522:  CLR     10BA
....................     static WORD blockCounter; 
....................     static DWORD longTimeoutCounter; 
....................     static BOOL SingleBlockRead; 
....................      
....................     //Check what state we are in, to decide what to do. 
....................     switch(info->bStateVariable) 
01524:  MOV     #C,W0
01526:  ADD     10B2,W0
01528:  MOV     W0,W5
0152A:  MOV.B   [W5],W0L
0152C:  CLR.B   1
0152E:  XOR     #0,W0
01530:  BRA     Z,1548
01532:  XOR     #1,W0
01534:  BRA     Z,154C
01536:  XOR     #2,W0
01538:  BRA     Z,15DA
0153A:  XOR     #1,W0
0153C:  BRA     Z,163C
0153E:  XOR     #FC,W0
01540:  BRA     Z,16F6
01542:  XOR     #1,W0
01544:  BRA     Z,1710
01546:  BRA     1710
....................     { 
....................         case ASYNC_READ_COMPLETE: 
....................             return ASYNC_READ_COMPLETE; 
01548:  CLR.B   0
0154A:  BRA     171E
....................         case ASYNC_READ_QUEUED: 
....................             //Start the read request.   
....................              
....................             //Initialize some variables we will use later. 
....................             blockCounter = MEDIA_BLOCK_SIZE; //Counter will be used later for block boundary tracking 
0154C:  MOV     #200,W4
0154E:  MOV     W4,DB2
....................             ioInfo = *info; //Get local copy of structure, for quicker access with less code size 
01550:  MOV     10B2,W0
01552:  MOV     #D54,W1
01554:  MOV     W0,W2
01556:  REPEAT  #D
01558:  MOV.B   [W2++],[W1++]
....................  
....................             //SDHC cards are addressed on a 512 byte block basis.  This is 1:1 equivalent 
....................             //to LBA addressing.  For standard capacity media, the media is expecting 
....................             //a complete byte address.  Therefore, to convert from the LBA address to the 
....................             //byte address, we need to multiply by 512. 
....................             if (gSDMode == SD_MODE_NORMAL) 
0155A:  CP0.B   D4C
0155C:  BRA     NZ,156C
....................             { 
....................                 ioInfo.dwAddress <<= 9; //Equivalent to multiply by 512 
0155E:  MOV     #9,W4
01560:  INC     W4,W4
01562:  DEC     W4,W4
01564:  BRA     Z,156C
01566:  SL      D5C
01568:  RLC     D5E
0156A:  BRA     1562
....................             }   
....................             if(ioInfo.dwBytesRemaining <= MEDIA_BLOCK_SIZE) 
0156C:  MOV     D58,W4
0156E:  CP      W4,#0
01570:  BRA     GTU,1598
01572:  BRA     NC,157C
01574:  MOV     D56,W4
01576:  MOV     #200,W3
01578:  CP      W3,W4
0157A:  BRA     NC,1598
....................             { 
....................                 SingleBlockRead = TRUE; 
0157C:  BSET.B  800.2
....................                 response = SendMMCCmd(READ_SINGLE_BLOCK, ioInfo.dwAddress); 
0157E:  MOV.B   #8,W0L
01580:  MOV.B   W0L,10C2
01582:  PUSH    D5C
01584:  POP     10C4
01586:  PUSH    D5E
01588:  POP     10C6
0158A:  CALL    F58
0158E:  MOV     W0,10B6
01590:  MOV     W1,10B8
01592:  MOV     W2,10BA
....................             }     
01594:  GOTO    15B0
....................             else 
....................             { 
....................                 SingleBlockRead = FALSE; 
01598:  BCLR.B  800.2
....................                 response = SendMMCCmd(READ_MULTI_BLOCK, ioInfo.dwAddress); 
0159A:  MOV.B   #9,W0L
0159C:  MOV.B   W0L,10C2
0159E:  PUSH    D5C
015A0:  POP     10C4
015A2:  PUSH    D5E
015A4:  POP     10C6
015A6:  CALL    F58
015AA:  MOV     W0,10B6
015AC:  MOV     W1,10B8
015AE:  MOV     W2,10BA
....................             }     
....................             //Note: SendMMCmd() sends 8 SPI clock cycles after getting the 
....................             //response.  This meets the NAC min timing paramemter, so we don't 
....................             //need additional clocking here. 
....................              
....................             // Make sure the command was accepted successfully 
....................             if(response.r1._byte != 0x00) 
015B0:  CP0.B   10B6
015B2:  BRA     Z,15C4
....................             { 
....................                 //Perhaps the card isn't initialized or present. 
....................                 info->bStateVariable = ASYNC_READ_ABORT; 
015B4:  MOV     #C,W0
015B6:  ADD     10B2,W0
015B8:  MOV     W0,W5
015BA:  MOV.B   #FE,W0L
015BC:  MOV.B   W0L,[W5]
....................                 return ASYNC_READ_BUSY;  
015BE:  MOV.B   #1,W0L
015C0:  MOV.B   W0L,0
015C2:  BRA     171E
....................             } 
....................              
....................             //We successfully sent the READ_MULTI_BLOCK command to the media. 
....................             //We now need to keep polling the media until it sends us the data 
....................             //start token byte. 
....................             longTimeoutCounter = NAC_TIMEOUT; //prepare timeout counter for next state 
015C4:  CLR     DB4
015C6:  MOV     #4,W4
015C8:  MOV     W4,DB6
....................             info->bStateVariable = ASYNC_READ_WAIT_START_TOKEN; 
015CA:  MOV     #C,W0
015CC:  ADD     10B2,W0
015CE:  MOV     W0,W5
015D0:  MOV.B   #3,W0L
015D2:  MOV.B   W0L,[W5]
....................             return ASYNC_READ_BUSY; 
015D4:  MOV.B   #1,W0L
015D6:  MOV.B   W0L,0
015D8:  BRA     171E
....................         case ASYNC_READ_WAIT_START_TOKEN: 
....................             //In this case, we have already issued the READ_MULTI_BLOCK command 
....................             //to the media, and we need to keep polling the media until it sends 
....................             //us the data start token byte.  This could typically take a  
....................             //couple/few milliseconds, up to a maximum of 100ms. 
....................             if(longTimeoutCounter != 0x00000000) 
015DA:  CP0     DB4
015DC:  BRA     NZ,15E2
015DE:  CP0     DB6
015E0:  BRA     Z,162C
....................             { 
....................                 longTimeoutCounter--; 
015E2:  DEC     0DB4
015E4:  BTSS.B  42.0
015E6:  DEC     0DB6
....................                 bData = MDD_SDSPI_ReadMedia(); 
015E8:  CALL    F4A
015EC:  MOV.B   W0L,10B4
....................                  
....................                 if(bData != MMC_FLOATING_BUS) 
015EE:  MOV     10B4,W4
015F0:  XOR.B   #FF,W4L
015F2:  BRA     Z,1622
....................                 { 
....................                     if(bData == DATA_START_TOKEN) 
015F4:  MOV     10B4,W4
015F6:  XOR.B   #FE,W4L
015F8:  BRA     NZ,160E
....................                     {    
....................                         //We got the start token.  Ready to receive the data 
....................                         //block now. 
....................                         info->bStateVariable = ASYNC_READ_NEW_PACKET_READY; 
015FA:  MOV     #C,W0
015FC:  ADD     10B2,W0
015FE:  MOV     W0,W5
01600:  MOV.B   #2,W0L
01602:  MOV.B   W0L,[W5]
....................                         return ASYNC_READ_NEW_PACKET_READY; 
01604:  MOV.B   #2,W0L
01606:  MOV.B   W0L,0
01608:  BRA     171E
....................                     } 
0160A:  GOTO    161E
....................                     else 
....................                     { 
....................                         //We got an unexpected non-0xFF, non-start token byte back? 
....................                         //Some kind of error must have occurred.  
....................                         info->bStateVariable = ASYNC_READ_ABORT;  
0160E:  MOV     #C,W0
01610:  ADD     10B2,W0
01612:  MOV     W0,W5
01614:  MOV.B   #FE,W0L
01616:  MOV.B   W0L,[W5]
....................                         return ASYNC_READ_BUSY; 
01618:  MOV.B   #1,W0L
0161A:  MOV.B   W0L,0
0161C:  BRA     171E
....................                     }         
....................                 } 
0161E:  GOTO    1628
....................                 else 
....................                 { 
....................                     //Media is still busy.  Start token not received yet. 
....................                     return ASYNC_READ_BUSY; 
01622:  MOV.B   #1,W0L
01624:  MOV.B   W0L,0
01626:  BRA     171E
....................                 }                     
....................             }  
01628:  GOTO    163C
....................             else 
....................             { 
....................                 //The media didn't respond with the start data token in the timeout 
....................                 //interval allowed.  Operation failed.  Abort the operation. 
....................                 info->bStateVariable = ASYNC_READ_ABORT;  
0162C:  MOV     #C,W0
0162E:  ADD     10B2,W0
01630:  MOV     W0,W5
01632:  MOV.B   #FE,W0L
01634:  MOV.B   W0L,[W5]
....................                 return ASYNC_READ_BUSY;                 
01636:  MOV.B   #1,W0L
01638:  MOV.B   W0L,0
0163A:  BRA     171E
....................             }        
....................             //Should never execute to here 
....................              
....................         case ASYNC_READ_NEW_PACKET_READY: 
....................             //We have sent the READ_MULTI_BLOCK command and have successfully 
....................             //received the data start token byte.  Therefore, we are ready 
....................             //to receive raw data bytes from the media. 
....................             if(ioInfo.dwBytesRemaining != 0x00000000) 
0163C:  CP0     D56
0163E:  BRA     NZ,1644
01640:  CP0     D58
01642:  BRA     Z,16D2
....................             { 
....................                 //Re-update local copy of pointer and number of bytes to read in this 
....................                 //call.  These parameters are allowed to change between packets. 
....................                 ioInfo.wNumBytes = info->wNumBytes; 
01644:  MOV     #0,W0
01646:  ADD     10B2,W0
01648:  MOV     [W0],[W15++]
0164A:  POP     D54
....................                   ioInfo.pBuffer = info->pBuffer; 
0164C:  MOV     #6,W0
0164E:  ADD     10B2,W0
01650:  MOV     [W0],[W15++]
01652:  POP     D5A
....................                    
....................                   //Update counters for state tracking and loop exit condition tracking. 
....................                 ioInfo.dwBytesRemaining -= ioInfo.wNumBytes; 
01654:  MOV     D56,W4
01656:  MOV     D54,W3
01658:  SUB     W4,W3,W0
0165A:  MOV     W0,D56
0165C:  MOV     D58,W4
0165E:  SUBB    W4,#0,W0
01660:  MOV     W0,D58
....................                 blockCounter -= ioInfo.wNumBytes; 
01662:  MOV     DB2,W4
01664:  MOV     D54,W3
01666:  SUB     W4,W3,W0
01668:  MOV     W0,DB2
....................  
....................                 //Now read a ioInfo.wNumBytes packet worth of SPI bytes,  
....................                 //and place the received bytes in the user specified pBuffer. 
....................                 //This operation directly dictates data thoroughput in the  
....................                 //application, therefore optimized code should be used for each  
....................                 //processor type. 
....................                #if defined __C30__ || defined __C32__ 
....................                 { 
....................                     //PIC24/dsPIC/PIC32 architecture is efficient with pointers. 
....................                     //Therefore, this code can provide good SPI bus utilization,  
....................                     //provided the compiler optimization level is 's' or '3'. 
....................                     BYTE* localPointer = ioInfo.pBuffer; 
....................                     WORD localCounter = ioInfo.wNumBytes; 
0166A:  PUSH    D5A
0166C:  POP     10BC
0166E:  PUSH    D54
01670:  POP     10BE
....................                      
....................                     if(localCounter != 0x0000) 
01672:  CP0     10BE
01674:  BRA     Z,16A0
....................                     { 
....................                         localPointer--; 
01676:  DEC     10BC
....................                         while(1) 
....................                         { 
....................                             SPIBUF = 0xFF; 
01678:  MOV     #FF,W4
0167A:  MOV     W4,248
....................                             localPointer++; 
0167C:  INC     10BC
....................                             if((--localCounter) == 0x0000) 
0167E:  DEC     10BE
01680:  CP0     10BE
01682:  BRA     NZ,1688
....................                             { 
....................                                break;  
01684:  GOTO    1696
....................                             }  
....................                             while(!SPISTAT_RBF); 
01688:  BTSS.B  240.0
0168A:  BRA     1688
....................                             *localPointer = (BYTE)SPIBUF; 
0168C:  MOV     10BC,W5
0168E:  MOV     248,W0
01690:  MOV.B   W0L,[W5+#0]
01692:  GOTO    1678
....................                         } 
....................                         while(!SPISTAT_RBF); 
01696:  BTSS.B  240.0
01698:  BRA     1696
....................                         *localPointer = (BYTE)SPIBUF;   
0169A:  MOV     10BC,W5
0169C:  MOV     248,W0
0169E:  MOV.B   W0L,[W5+#0]
....................                     }   
....................                 }     
....................                 #elif defined __18CXX 
....................                     PIC18_Optimized_SPI_Read_Packet(); 
....................                #endif    
....................  
....................                 //Check if we have received a multiple of the media block  
....................                 //size (ex: 512 bytes).  If so, the next two bytes are going to  
....................                 //be CRC values, rather than data bytes.   
....................                 if(blockCounter == 0) 
016A0:  CP0     DB2
016A2:  BRA     NZ,16C8
....................                 { 
....................                     //Read two bytes to receive the CRC-16 value on the data block. 
....................                     MDD_SDSPI_ReadMedia(); 
016A4:  CALL    F4A
....................                     MDD_SDSPI_ReadMedia(); 
016A8:  CALL    F4A
....................                     //Following sending of the CRC-16 value, the media may still 
....................                     //need more access time to internally fetch the next block. 
....................                     //Therefore, it will send back 0xFF idle value, until it is 
....................                     //ready.  Then it will send a new data start token, followed 
....................                     //by the next block of useful data. 
....................                     if(ioInfo.dwBytesRemaining != 0x00000000) 
016AC:  CP0     D56
016AE:  BRA     NZ,16B4
016B0:  CP0     D58
016B2:  BRA     Z,16BE
....................                     { 
....................                         info->bStateVariable = ASYNC_READ_WAIT_START_TOKEN; 
016B4:  MOV     #C,W0
016B6:  ADD     10B2,W0
016B8:  MOV     W0,W5
016BA:  MOV.B   #3,W0L
016BC:  MOV.B   W0L,[W5]
....................                     } 
....................                     blockCounter = MEDIA_BLOCK_SIZE; 
016BE:  MOV     #200,W4
016C0:  MOV     W4,DB2
....................                     return ASYNC_READ_BUSY; 
016C2:  MOV.B   #1,W0L
016C4:  MOV.B   W0L,0
016C6:  BRA     171E
....................                 } 
....................                      
....................                 return ASYNC_READ_NEW_PACKET_READY; 
016C8:  MOV.B   #2,W0L
016CA:  MOV.B   W0L,0
016CC:  BRA     171E
....................             }//if(ioInfo.dwBytesRemaining != 0x00000000) 
016CE:  GOTO    16F6
....................             else 
....................             { 
....................                 //We completed the read operation successfully and have returned 
....................                 //all data bytes requested. 
....................                 //Send CMD12 to let the media know we are finished reading 
....................                 //blocks from it, if we sent a multi-block read request earlier. 
....................                 if(SingleBlockRead == FALSE) 
016D2:  BTSC.B  800.2
016D4:  BRA     16E2
....................                 { 
....................                     SendMMCCmd(STOP_TRANSMISSION, 0x00000000); 
016D6:  MOV.B   #5,W0L
016D8:  MOV.B   W0L,10C2
016DA:  CLR     10C4
016DC:  CLR     10C6
016DE:  CALL    F58
....................                 }     
....................                 SD_CS = 1;  //De-select media 
016E2:  BSET.B  2F5.0
....................                 mSend8ClkCycles();   
016E4:  SETM.B  10E2
016E6:  CALL    F36
....................                 info->bStateVariable = ASYNC_READ_COMPLETE; 
016EA:  MOV     #C,W0
016EC:  ADD     10B2,W0
016EE:  MOV     W0,W5
016F0:  CLR.B   [W5]
....................                 return ASYNC_READ_COMPLETE; 
016F2:  CLR.B   0
016F4:  BRA     171E
....................             } 
....................         case ASYNC_READ_ABORT: 
....................             //If the application firmware wants to cancel a read request. 
....................             info->bStateVariable = ASYNC_READ_ERROR; 
016F6:  MOV     #C,W0
016F8:  ADD     10B2,W0
016FA:  MOV     W0,W5
016FC:  SETM.B  [W5]
....................             //Send CMD12 to terminate the multi-block read request. 
....................             response = SendMMCCmd(STOP_TRANSMISSION, 0x00000000); 
016FE:  MOV.B   #5,W0L
01700:  MOV.B   W0L,10C2
01702:  CLR     10C4
01704:  CLR     10C6
01706:  CALL    F58
0170A:  MOV     W0,10B6
0170C:  MOV     W1,10B8
0170E:  MOV     W2,10BA
....................             //Fall through to ASYNC_READ_ERROR/default case. 
....................         case ASYNC_READ_ERROR: 
....................         default: 
....................             //Some error must have happened. 
....................             SD_CS = 1;  //De-select media 
01710:  BSET.B  2F5.0
....................             mSend8ClkCycles();   
01712:  SETM.B  10E2
01714:  CALL    F36
....................             return ASYNC_READ_ERROR;  
01718:  SETM.B  0
0171A:  BRA     171E
....................     }//switch(info->stateVariable)     
....................      
....................     //Should never get to here.  All pathways should have already returned. 
....................     return ASYNC_READ_ERROR; 
0171C:  SETM.B  0
0171E:  MOV     [--W15],W5
01720:  RETURN  
.................... }     
....................  
....................  
....................  
....................  
.................... #ifdef __18CXX 
.................... /***************************************************************************** 
....................   Function: 
....................     static void PIC18_Optimized_SPI_Read_Packet(void) 
....................   Summary: 
....................     A private function intended for use internal to the SD-SPI.c file. 
....................     This function reads a specified number of bytes from the SPI module, 
....................     at high speed for optimum thoroughput, and copies them into the user 
....................     specified RAM buffer. 
....................     This function is only implemented and used on PIC18 devices. 
....................   Pre-Conditions: 
....................     The ioInfo.wNumBytes must be pre-initialized prior to calling  
....................     PIC18_Optimized_SPI_Read_Packet(). 
....................     Additionally, the ioInfo.pBuffer must also be pre-initialized, prior 
....................     to calling PIC18_Optimized_SPI_Read_Packet(). 
....................   Input: 
....................     ioInfo.wNumBytes global variable, initialized to the number of bytes to read. 
....................     ioInfo.pBuffer global variable, initialize to point to the RAM location that 
....................         the read data should be copied to. 
....................   Return Values: 
....................     None (although the ioInfo.pBuffer RAM specified will contain new contents) 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     A private function intended for use internal to the SD-SPI.c file. 
....................     This function reads a specified number of bytes from the SPI module, 
....................     at high speed for optimum thoroughput, and copies them into the user 
....................     specified RAM buffer. 
....................     This function is only implemented and used on PIC18 devices. 
....................   Remarks: 
....................     This function is speed optimized, using inline assembly language code, and 
....................     makes use of C compiler managed resources.  It is currently written to work 
....................     with the Microchip MPLAB C18 compiler, and may need modification is built 
....................     with a different PIC18 compiler. 
....................   *****************************************************************************/ 
.................... static void PIC18_Optimized_SPI_Read_Packet(void) 
.................... { 
....................     static WORD FSR0Save; 
....................     static WORD PRODSave; 
....................  
....................     //Make sure the SPI_INTERRUPT_FLAG_ASM has been correctly defined, for the SPI 
....................     //module that is actually being used in the hardware. 
....................     #ifndef SPI_INTERRUPT_FLAG_ASM 
....................         #error "Please define SPI_INTERRUPT_FLAG_ASM.  Double click this message for more info." 
....................         //In the HardwareProfile - [platform name].h file for your project, please 
....................         //add a "#define SPI_INTERRUPT_FLAG_ASM  PIRx, y" definition, where 
....................         //PIRx is the PIR register holding the SSPxIF flag for the SPI module being used 
....................         //to interface with the SD/MMC card, and y is the bit number for the SSPxIF bit (ex: 0-7). 
....................     #endif 
....................  
....................     //Make sure at least one byte needs to be read. 
....................     if(ioInfo.wNumBytes == 0) 
....................     { 
....................         return; 
....................     } 
....................  
....................     //Context save C compiler managed registers that we will modify in this function. 
....................     FSR0Save = FSR0;     
....................     PRODSave = PROD;     
....................      
....................     //Using PRODH and PRODL as convenient 16-bit access bank counter 
....................     PROD = ioInfo.wNumBytes;    //ioInfo.wNumBytes holds the total number of bytes 
....................                                 //this function will read from SPI. 
....................     //Going to use the FSR0 directly.  This is non-conventional, but delivers 
....................     //better performance than using a normal C managed software RAM pointer. 
....................     FSR0 = (WORD)ioInfo.pBuffer; 
....................  
....................     //Initiate the first SPI operation 
....................     WREG = SPIBUF; 
....................     SPI_INTERRUPT_FLAG = 0; 
....................     SPIBUF = 0xFF; 
....................  
.................... #if defined(__CCS__) 
.................... //had to modify this code to get rid of -2 BRA and the ,0 for all byte access 
.................... #endif 
....................  
....................     //Highly speed efficient SPI read loop, written in inline assembly 
....................     //language for best performance.  Total number of bytes that will be fetched 
....................     //is exactly == the value of ioInfo.wNumBytes prior to calling this function. 
....................     _asm 
....................         bra     ASMSPIReadLoopEntryPoint 
....................      
.................... ASMSPIReadLoop: 
....................         //Wait until last hardware SPI transaction is complete 
....................         btfss   SPI_INTERRUPT_FLAG_ASM 
....................         bra     ASMSPIReadLoop 
....................         bcf     SPI_INTERRUPT_FLAG_ASM 
....................  
....................         //Save received byte and start the next transfer 
....................         movf    SPIBUF, 0    //Copy SPIBUF byte into WREG 
....................         setf    SPIBUF       //Write 0xFF to SPIBUF, to start a SPI transaction 
....................         movwf   POSTINC0     //Write the last received byte to the user's RAM buffer 
....................      
.................... ASMSPIReadLoopEntryPoint: 
....................         //Now decrement 16-bit counter for loop exit test condition 
....................         movlw   0x00 
....................         decf    PRODL, 1     //Decrement LSB 
....................         subwfb  PRODH, 1     //Decrement MSB, only if borrow from LSB decrement 
....................         //Check if anymore bytes remain to be sent 
....................         movf    PRODL, 0     //copy PRODL to WREG 
....................         iorwf   PRODH, 0     //Z bit will be set if both PRODL and PRODH == 0x00 
....................         bnz     ASMSPIReadLoop  //Go back and loop if our counter isn't = 0x0000. 
....................  
....................         //Wait until the very last SPI transaction is complete and save the byte 
.................... ASMSPIReadLoopEntryPoint2: 
....................         btfss   SPI_INTERRUPT_FLAG_ASM 
....................         bra     ASMSPIReadLoopEntryPoint2 
....................         movff   SPIBUF, POSTINC0 
....................     _endasm 
....................  
....................     SPI_INTERRUPT_FLAG = 0;     
....................  
....................     //Context restore C compiler managed registers 
....................     PROD = PRODSave; 
....................     FSR0 = FSR0Save;     
.................... }     
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE MDD_SDSPI_AsyncWriteTasks(ASYNC_IO* info) 
....................   Summary: 
....................     Speed optimized, non-blocking, state machine based write function that writes 
....................     data from the user specified buffer, onto the media, at the specified  
....................     media block address. 
....................   Pre-Conditions: 
....................     The ASYNC_IO structure must be initialized correctly, prior to calling 
....................     this function for the first time.  Certain parameters, such as the user 
....................     data buffer pointer (pBuffer) in the ASYNC_IO struct are allowed to be changed 
....................     by the application firmware, in between each call to MDD_SDSPI_AsyncWriteTasks(). 
....................     Additionally, the media and microcontroller SPI module should have already  
....................     been initalized before using this function.  This function is mutually 
....................     exclusive with the MDD_SDSPI_AsyncReadTasks() function.  Only one operation 
....................     (either one read or one write) is allowed to be in progress at a time, as 
....................     both functions share statically allocated resources and monopolize the SPI bus. 
....................   Input: 
....................     ASYNC_IO* info -        A pointer to a ASYNC_IO structure.  The  
....................                             structure contains information about how to complete 
....................                             the write operation (ex: number of total bytes to write, 
....................                             where to obtain the bytes from, number of bytes 
....................                             to write for each call to MDD_SDSPI_AsyncWriteTasks(), etc.). 
....................   Return Values: 
....................     BYTE - Returns a status byte indicating the current state of the write  
....................             operation. The possible return values are: 
....................              
....................             ASYNC_WRITE_BUSY - Returned when the state machine is busy waiting for 
....................                              the media to become ready to accept new data.  The  
....................                              media has write time, which can often be quite long 
....................                              (a few ms typ, with maximum of 250ms).  The application 
....................                              should keep calling MDD_SDSPI_AsyncWriteTasks() until either 
....................                              an error/timeout occurs, ASYNC_WRITE_SEND_PACKET 
....................                              is returned, or ASYNC_WRITE_COMPLETE is returned. 
....................             ASYNC_WRITE_SEND_PACKET -   Returned when the MDD_SDSPI_AsyncWriteTasks() 
....................                                         handler is ready to consume data and send 
....................                                         it to the media.  After ASYNC_WRITE_SEND_PACKET 
....................                                         is returned, the application should make certain 
....................                                         that the info->wNumBytes and pBuffer parameters 
....................                                         are correct, prior to calling  
....................                                         MDD_SDSPI_AsyncWriteTasks() again.  After 
....................                                         the function returns, the application is 
....................                                         then free to write new data into the pBuffer 
....................                                         RAM location.  
....................             ASYNC_WRITE_COMPLETE - Returned when all data bytes in the write 
....................                                  operation have been written to the media successfully, 
....................                                  and the media is now ready for the next operation. 
....................             ASYNC_WRITE_ERROR - Returned when some failure occurs.  This could be 
....................                                either due to a media timeout, or due to some other 
....................                                unknown type of error.  In this case, the  
....................                                MDD_SDSPI_AsyncWriteTasks() handler will terminate 
....................                                the write attempt and will try to put the media  
....................                                back in a default state, ready for a new command.   
....................                                The application firmware may then retry the write 
....................                                attempt (if desired) by re-initializing the  
....................                                ASYNC_IO structure and setting the  
....................                                bStateVariable = ASYNC_WRITE_QUEUED. 
....................  
....................              
....................   Side Effects: 
....................     Uses the SPI bus and the media.  The media and SPI bus should not be 
....................     used by any other function until the read operation has either completed 
....................     successfully, or returned with the ASYNC_WRITE_ERROR condition. 
....................   Description: 
....................     Speed optimized, non-blocking, state machine based write function that writes  
....................     data packets to the media, from a user specified RAM buffer. 
....................     This function uses either the single block or multi-block write command  
....................     to perform fast writes of the data.  The total amount of data that will be  
....................     written on any given call to MDD_SDSPI_AsyncWriteTasks() will be the  
....................     info->numBytes parameter. 
....................     However, if the function is called repeatedly, with info->dwBytesRemaining 
....................     set to a large number, this function can successfully write data sizes >> than 
....................     the block size (theoretically anything up to ~4GB, since dwBytesRemaining is  
....................     a 32-bit DWORD).  The application firmware should continue calling  
....................     MDD_SDSPI_AsyncWriteTasks(), until the ASYNC_WRITE_COMPLETE value is returned  
....................     (or ASYNC_WRITE_ERROR), even if it has already sent all of the data expected. 
....................     This is necessary, so the state machine can finish the write process and  
....................     terminate the multi-block write operation, once the total expected number  
....................     of bytes have been written.  This puts the media back into the default state  
....................     ready for a new command. 
....................      
....................     During normal/successful operations, calls to MDD_SDSPI_AsyncWriteTasks()  
....................     would typically return: 
....................     1. ASYNC_WRITE_SEND_PACKET - repeatedly, until 512 bytes [media read  
....................         block size] is received, then  
....................     2. ASYNC_WRITE_BUSY (for awhile, could be a long time, many milliseconds), then 
....................     3. Back to ASYNC_WRITE_SEND_PACKET (repeatedly, until the next 512 byte 
....................        boundary, then back to #2, etc. 
....................     4. After all data is copied successfully, then the function will return  
....................        ASYNC_WRITE_COMPLETE, for all subsequent calls (until a new write operation 
....................        is started, by re-initializing the ASYNC_IO structure, and re-calling 
....................        the function). 
....................      
....................   Remarks: 
....................     When starting a read operation, the info->stateVariable must be initalized to 
....................     ASYNC_WRITE_QUEUED.  All other fields in the info structure should also be 
....................     initialized correctly. 
....................  
....................     This function will monopolize the SPI module during the operation.  Do not 
....................     use the SPI module for any other purpose, while a write operation is in 
....................     progress.  Additionally, the ASYNC_IO structure must not be modified 
....................     in a different context, while the MDD_SDSPI_AsyncReadTasks() function is  
....................     actively executing. 
....................     In between calls to MDD_SDSPI_AsyncWriteTasks(), certain parameters, namely the 
....................     info->wNumBytes and info->pBuffer are allowed to change however. 
....................      
....................     The dwBytesRemaining value must always be an exact integer multiple of wNumBytes  
....................     for the function to operate correctly.  Additionally, it is required that 
....................     the wNumBytes parameter, must always be less than or equal to the media block size, 
....................     (which is 512 bytes).  Additionally, info->wNumBytes must always be an exact  
....................     integer factor of the media block size.  Example values that are allowed for 
....................     info->wNumBytes are: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512. 
....................   *****************************************************************************/ 
.................... BYTE MDD_SDSPI_AsyncWriteTasks(ASYNC_IO* info) 
*
02918:  MOV     W5,[W15++]
.................... { 
....................     static BYTE data_byte; 
....................     static WORD blockCounter; 
....................     static DWORD WriteTimeout; 
....................     static BYTE command; 
....................     DWORD preEraseBlockCount; 
0291A:  CLR     10A8
0291C:  CLR     10AA
....................     MMC_RESPONSE response; 
0291E:  CLR     10AC
02920:  CLR     10AE
02922:  CLR     10B0
....................  
....................      
....................     //Check what state we are in, to decide what to do. 
....................     switch(info->bStateVariable) 
02924:  MOV     #C,W0
02926:  ADD     10A6,W0
02928:  MOV     W0,W5
0292A:  MOV.B   [W5],W0L
0292C:  CLR.B   1
0292E:  XOR     #0,W0
02930:  BRA     Z,2948
02932:  XOR     #1,W0
02934:  BRA     Z,294C
02936:  XOR     #3,W0
02938:  BRA     Z,2A0C
0293A:  XOR     #1,W0
0293C:  BRA     Z,2AC2
0293E:  XOR     #7,W0
02940:  BRA     Z,2B5A
02942:  XOR     #FA,W0
02944:  BRA     Z,2B8C
02946:  BRA     2BA8
....................     { 
....................         case ASYNC_WRITE_COMPLETE: 
....................             return ASYNC_WRITE_COMPLETE; 
02948:  CLR.B   0
0294A:  BRA     2BBA
....................         case ASYNC_WRITE_QUEUED: 
....................             //Initiate the write sequence. 
....................             blockCounter = MEDIA_BLOCK_SIZE;    //Initialize counter.  Will be used later for block boundary tracking. 
0294C:  MOV     #200,W4
0294E:  MOV     W4,DB8
....................  
....................             //Copy input structure into a statically allocated global instance  
....................             //of the structure, for faster local access of the parameters with  
....................             //smaller code size. 
....................             ioInfo = *info; 
02950:  MOV     10A6,W0
02952:  MOV     #D54,W1
02954:  MOV     W0,W2
02956:  REPEAT  #D
02958:  MOV.B   [W2++],[W1++]
....................  
....................             //Check if we are writing only a single block worth of data, or  
....................             //multiple blocks worth of data. 
....................             if(ioInfo.dwBytesRemaining <= MEDIA_BLOCK_SIZE) 
0295A:  MOV     D58,W4
0295C:  CP      W4,#0
0295E:  BRA     GTU,2972
02960:  BRA     NC,296A
02962:  MOV     D56,W4
02964:  MOV     #200,W3
02966:  CP      W3,W4
02968:  BRA     NC,2972
....................             { 
....................                 command = WRITE_SINGLE_BLOCK; 
0296A:  MOV.B   #A,W0L
0296C:  MOV.B   W0L,D53
....................             }     
0296E:  GOTO    29C0
....................             else 
....................             { 
....................                 command = WRITE_MULTI_BLOCK; 
02972:  MOV.B   #B,W0L
02974:  MOV.B   W0L,D53
....................                  
....................                 //Compute the number of blocks that we are going to be writing in this multi-block write operation. 
....................                 preEraseBlockCount = (ioInfo.dwBytesRemaining >> 9); //Divide by 512 to get the number of blocks to write 
02976:  MOV     #9,W4
02978:  PUSH    D56
0297A:  POP     10A8
0297C:  PUSH    D58
0297E:  POP     10AA
02980:  INC     W4,W4
02982:  DEC     W4,W4
02984:  BRA     Z,298C
02986:  LSR     10AA
02988:  RRC     10A8
0298A:  BRA     2982
....................                 //Always need to erase at least one block. 
....................                 if(preEraseBlockCount == 0) 
0298C:  CP0     10A8
0298E:  BRA     NZ,299A
02990:  CP0     10AA
02992:  BRA     NZ,299A
....................                 { 
....................                     preEraseBlockCount++;    
02994:  INC     10A8
02996:  BTSC.B  42.1
02998:  INC     10AA
....................                 }  
....................      
....................                 //Should send CMD55/ACMD23 to let the media know how many blocks it should  
....................                 //pre-erase.  This isn't essential, but it allows for faster multi-block  
....................                 //writes, and probably also reduces flash wear on the media. 
....................                 response = SendMMCCmd(APP_CMD, 0x00000000);    //Send CMD55 
0299A:  MOV.B   #F,W0L
0299C:  MOV.B   W0L,10C2
0299E:  CLR     10C4
029A0:  CLR     10C6
029A2:  CALL    F58
029A6:  MOV     W0,10AC
029A8:  MOV     W1,10AE
029AA:  MOV     W2,10B0
....................                 if(response.r1._byte == 0x00)   //Check if successful. 
029AC:  CP0.B   10AC
029AE:  BRA     NZ,29C0
....................                 { 
....................                     SendMMCCmd(SET_WR_BLK_ERASE_COUNT , preEraseBlockCount);    //Send ACMD23         
029B0:  MOV.B   #13,W0L
029B2:  MOV.B   W0L,10C2
029B4:  PUSH    10A8
029B6:  POP     10C4
029B8:  PUSH    10AA
029BA:  POP     10C6
029BC:  CALL    F58
....................                 } 
....................             }     
....................  
....................             //The info->dwAddress parameter is the block address. 
....................             //For standard capacity SD cards, the card expects a complete byte address. 
....................             //To convert the block address into a byte address, we multiply by the block size (512). 
....................             //For SDHC (high capacity) cards, the card expects a block address already, so no 
....................             //address cconversion is needed 
....................             if (gSDMode == SD_MODE_NORMAL)   
029C0:  CP0.B   D4C
029C2:  BRA     NZ,29D2
....................             { 
....................                 ioInfo.dwAddress <<= 9;   //<< 9 multiplies by 512 
029C4:  MOV     #9,W4
029C6:  INC     W4,W4
029C8:  DEC     W4,W4
029CA:  BRA     Z,29D2
029CC:  SL      D5C
029CE:  RLC     D5E
029D0:  BRA     29C8
....................             }     
....................  
....................             //Send the write single or write multi command, with the LBA or byte  
....................             //address (depeding upon SDHC or standard capacity card) 
....................             response = SendMMCCmd(command, ioInfo.dwAddress);     
029D2:  MOV.B   D53,W0L
029D4:  MOV.B   W0L,10C2
029D6:  PUSH    D5C
029D8:  POP     10C4
029DA:  PUSH    D5E
029DC:  POP     10C6
029DE:  CALL    F58
029E2:  MOV     W0,10AC
029E4:  MOV     W1,10AE
029E6:  MOV     W2,10B0
....................  
....................             //See if it was accepted 
....................             if(response.r1._byte != 0x00) 
029E8:  CP0.B   10AC
029EA:  BRA     Z,29FC
....................             { 
....................                 //Perhaps the card isn't initialized or present. 
....................                 info->bStateVariable = ASYNC_WRITE_ERROR; 
029EC:  MOV     #C,W0
029EE:  ADD     10A6,W0
029F0:  MOV     W0,W5
029F2:  SETM.B  [W5]
....................                 return ASYNC_WRITE_ERROR;  
029F4:  SETM.B  0
029F6:  BRA     2BBA
....................             }     
029F8:  GOTO    2A06
....................             else 
....................             { 
....................                 //Card is ready to receive start token and data bytes. 
....................                 info->bStateVariable = ASYNC_WRITE_TRANSMIT_PACKET; 
029FC:  MOV     #C,W0
029FE:  ADD     10A6,W0
02A00:  MOV     W0,W5
02A02:  MOV.B   #2,W0L
02A04:  MOV.B   W0L,[W5]
....................             }  
....................             return ASYNC_WRITE_SEND_PACKET;    
02A06:  MOV.B   #2,W0L
02A08:  MOV.B   W0L,0
02A0A:  BRA     2BBA
....................  
....................         case ASYNC_WRITE_TRANSMIT_PACKET: 
....................             //Check if we just finished programming a block, or we are starting 
....................             //for the first time.  In this case, we need to send the data start token. 
....................             if(blockCounter == MEDIA_BLOCK_SIZE) 
02A0C:  MOV     DB8,W4
02A0E:  XOR     #200,W4
02A10:  BRA     NZ,2A2E
....................             { 
....................                 //Send the correct data start token, based on the type of write we are doing 
....................                 if(command == WRITE_MULTI_BLOCK) 
02A12:  MOV     D52,W4
02A14:  LSR     W4,#8,W4
02A16:  CP.B    W4L,#B
02A18:  BRA     NZ,2A26
....................                 { 
....................                     WriteSPIM(DATA_START_MULTI_BLOCK_TOKEN);    
02A1A:  MOV.B   #FC,W0L
02A1C:  MOV.B   W0L,10E2
02A1E:  CALL    F36
....................                 } 
02A22:  GOTO    2A2E
....................                 else 
....................                 { 
....................                     //Else must be a single block write 
....................                     WriteSPIM(DATA_START_TOKEN);    
02A26:  MOV.B   #FE,W0L
02A28:  MOV.B   W0L,10E2
02A2A:  CALL    F36
....................                 }         
....................             }  
....................                 
....................             //Update local copy of pointer and byte count.  Application firmware 
....................             //is alllowed to change these between calls to this handler function. 
....................             ioInfo.wNumBytes = info->wNumBytes; 
02A2E:  MOV     #0,W0
02A30:  ADD     10A6,W0
02A32:  MOV     [W0],[W15++]
02A34:  POP     D54
....................             ioInfo.pBuffer = info->pBuffer; 
02A36:  MOV     #6,W0
02A38:  ADD     10A6,W0
02A3A:  MOV     [W0],[W15++]
02A3C:  POP     D5A
....................              
....................             //Keep track of variables for loop/state exit conditions. 
....................             ioInfo.dwBytesRemaining -= ioInfo.wNumBytes; 
02A3E:  MOV     D56,W4
02A40:  MOV     D54,W3
02A42:  SUB     W4,W3,W0
02A44:  MOV     W0,D56
02A46:  MOV     D58,W4
02A48:  SUBB    W4,#0,W0
02A4A:  MOV     W0,D58
....................             blockCounter -= ioInfo.wNumBytes; 
02A4C:  MOV     DB8,W4
02A4E:  MOV     D54,W3
02A50:  SUB     W4,W3,W0
02A52:  MOV     W0,DB8
....................              
....................             //Now send a packet of raw data bytes to the media, over SPI. 
....................             //This code directly impacts data thoroughput in a significant way.   
....................             //Special care should be used to make sure this code is speed optimized. 
....................            #if defined __C30__ || defined __C32__ 
....................             { 
....................                 //PIC24/dsPIC/PIC32 architecture is efficient with pointers and  
....................                 //local variables due to the large number of WREGs available. 
....................                 //Therefore, this code gives good SPI bus utilization, provided 
....................                 //the compiler optimization level is 's' or '3'. 
....................                 BYTE* localPointer = ioInfo.pBuffer;     
....................                 WORD localCounter = ioInfo.wNumBytes; 
02A54:  PUSH    D5A
02A56:  POP     10B2
02A58:  PUSH    D54
02A5A:  POP     10B4
....................                 do 
....................                 { 
....................                     SPIBUF = *localPointer++; 
02A5C:  MOV     10B2,W0
02A5E:  INC     10B2
02A60:  MOV     248,W4
02A62:  MOV.B   [W0+#0],W4L
02A64:  MOV     W4,248
02A66:  CLR.B   249
....................                     localCounter--; 
02A68:  DEC     10B4
....................                     while(!SPISTAT_RBF); 
02A6A:  BTSS.B  240.0
02A6C:  BRA     2A6A
....................                     data_byte = SPIBUF; //Dummy read to clear SPISTAT_RBF 
02A6E:  MOV.B   248,W0L
02A70:  MOV.B   W0L,D4D
....................                 }while(localCounter);          
02A72:  CP0     10B4
02A74:  BRA     NZ,2A5C
....................             }                        
....................             #elif defined __18CXX    
....................                 PIC18_Optimized_SPI_Write_Packet(); 
....................             #endif 
....................   
....................             //Check if we have finshed sending a 512 byte block.  If so, 
....................             //need to receive 16-bit CRC, and retrieve the data_response token 
....................             if(blockCounter == 0) 
02A76:  CP0     DB8
02A78:  BRA     NZ,2ABC
....................             { 
....................                 blockCounter = MEDIA_BLOCK_SIZE;    //Re-initialize counter 
02A7A:  MOV     #200,W4
02A7C:  MOV     W4,DB8
....................                  
....................                 //Add code to compute CRC, if using CRC. By default, the media  
....................                 //doesn't use CRC unless it is enabled manually during the card  
....................                 //initialization sequence. 
....................                 mSendCRC();  //Send 16-bit CRC for the data block just sent 
02A7E:  SETM.B  10E2
02A80:  CALL    F36
02A84:  SETM.B  10E2
02A86:  CALL    F36
....................                  
....................                 //Read response token byte from media, mask out top three don't  
....................                 //care bits, and check if there was an error 
....................                 if((MDD_SDSPI_ReadMedia() & WRITE_RESPONSE_TOKEN_MASK) != DATA_ACCEPTED) 
02A8A:  CALL    F4A
02A8E:  CLR.B   1
02A90:  AND     W0,#1F,W5
02A92:  CP      W5,#5
02A94:  BRA     Z,2AA6
....................                 { 
....................                     //Something went wrong.  Try and terminate as gracefully as  
....................                     //possible, so as allow possible recovery. 
....................                     info->bStateVariable = ASYNC_WRITE_ABORT;  
02A96:  MOV     #C,W0
02A98:  ADD     10A6,W0
02A9A:  MOV     W0,W5
02A9C:  MOV.B   #FE,W0L
02A9E:  MOV.B   W0L,[W5]
....................                     return ASYNC_WRITE_BUSY; 
02AA0:  MOV.B   #3,W0L
02AA2:  MOV.B   W0L,0
02AA4:  BRA     2BBA
....................                 } 
....................                  
....................                 //The media will now send busy token (0x00) bytes until 
....................                 //it is internally ready again (after the block is successfully 
....................                 //writen and the card is ready to accept a new block. 
....................                 info->bStateVariable = ASYNC_WRITE_MEDIA_BUSY; 
02AA6:  MOV     #C,W0
02AA8:  ADD     10A6,W0
02AAA:  MOV     W0,W5
02AAC:  MOV.B   #3,W0L
02AAE:  MOV.B   W0L,[W5]
....................                 WriteTimeout = WRITE_TIMEOUT;       //Initialize timeout counter 
02AB0:  CLR     DBA
02AB2:  MOV     #A,W4
02AB4:  MOV     W4,DBC
....................                 return ASYNC_WRITE_BUSY; 
02AB6:  MOV.B   #3,W0L
02AB8:  MOV.B   W0L,0
02ABA:  BRA     2BBA
....................             }//if(blockCounter == 0) 
....................              
....................             //If we get to here, we haven't reached a block boundary yet.  Keep  
....................             //on requesting packets of data from the application. 
....................             return ASYNC_WRITE_SEND_PACKET;    
02ABC:  MOV.B   #2,W0L
02ABE:  MOV.B   W0L,0
02AC0:  BRA     2BBA
....................  
....................         case ASYNC_WRITE_MEDIA_BUSY: 
....................             if(WriteTimeout != 0) 
02AC2:  CP0     DBA
02AC4:  BRA     NZ,2ACA
02AC6:  CP0     DBC
02AC8:  BRA     Z,2B4A
....................             { 
....................                 WriteTimeout--; 
02ACA:  DEC     0DBA
02ACC:  BTSS.B  42.0
02ACE:  DEC     0DBC
....................                 mSend8ClkCycles();  //Dummy read to gobble up a byte (ex: to ensure we meet NBR timing parameter) 
02AD0:  SETM.B  10E2
02AD2:  CALL    F36
....................                 data_byte = MDD_SDSPI_ReadMedia();  //Poll the media.  Will return 0x00 if still busy.  Will return non-0x00 is ready for next data block. 
02AD6:  CALL    F4A
02ADA:  MOV.B   W0L,D4D
....................                 if(data_byte != 0x00) 
02ADC:  CP0.B   D4D
02ADE:  BRA     Z,2B40
....................                 { 
....................                     //The media is done and is no longer busy.  Go ahead and 
....................                     //either send the next packet of data to the media, or the stop 
....................                     //token if we are finshed. 
....................                     if(ioInfo.dwBytesRemaining == 0) 
02AE0:  CP0     D56
02AE2:  BRA     NZ,2B2C
02AE4:  CP0     D58
02AE6:  BRA     NZ,2B2C
....................                     { 
....................                         WriteTimeout = WRITE_TIMEOUT; 
02AE8:  CLR     DBA
02AEA:  MOV     #A,W4
02AEC:  MOV     W4,DBC
....................                         if(command == WRITE_MULTI_BLOCK) 
02AEE:  MOV     D52,W4
02AF0:  LSR     W4,#8,W4
02AF2:  CP.B    W4L,#B
02AF4:  BRA     NZ,2B18
....................                         { 
....................                             //We finished sending all bytes of data.  Send the stop token byte. 
....................                             WriteSPIM(DATA_STOP_TRAN_TOKEN); 
02AF6:  MOV.B   #FD,W0L
02AF8:  MOV.B   W0L,10E2
02AFA:  CALL    F36
....................                             //After sending the stop transmission token, we need to 
....................                             //gobble up one byte before checking for media busy (0x00). 
....................                             //This is to meet the NBR timing parameter.  During the NBR 
....................                             //interval the SD card may not respond with the busy signal, even 
....................                             //though it is internally busy. 
....................                             mSend8ClkCycles(); 
02AFE:  SETM.B  10E2
02B00:  CALL    F36
....................                                                  
....................                             //The media still needs to finish internally writing. 
....................                             info->bStateVariable = ASYNC_STOP_TOKEN_SENT_WAIT_BUSY; 
02B04:  MOV     #C,W0
02B06:  ADD     10A6,W0
02B08:  MOV     W0,W5
02B0A:  MOV.B   #4,W0L
02B0C:  MOV.B   W0L,[W5]
....................                             return ASYNC_WRITE_BUSY; 
02B0E:  MOV.B   #3,W0L
02B10:  MOV.B   W0L,0
02B12:  BRA     2BBA
....................                         } 
02B14:  GOTO    2B2C
....................                         else 
....................                         { 
....................                             //In this case we were doing a single block write, 
....................                             //so no stop token is necessary.  In this case we are 
....................                             //now fully complete with the write operation. 
....................                             SD_CS = 1;          //De-select media 
02B18:  BSET.B  2F5.0
....................                             mSend8ClkCycles();   
02B1A:  SETM.B  10E2
02B1C:  CALL    F36
....................                             info->bStateVariable = ASYNC_WRITE_COMPLETE; 
02B20:  MOV     #C,W0
02B22:  ADD     10A6,W0
02B24:  MOV     W0,W5
02B26:  CLR.B   [W5]
....................                             return ASYNC_WRITE_COMPLETE;                             
02B28:  CLR.B   0
02B2A:  BRA     2BBA
....................                         }                             
....................                          
....................                     } 
....................                     //Else we have more data to write in the multi-block write.     
....................                     info->bStateVariable = ASYNC_WRITE_TRANSMIT_PACKET;   
02B2C:  MOV     #C,W0
02B2E:  ADD     10A6,W0
02B30:  MOV     W0,W5
02B32:  MOV.B   #2,W0L
02B34:  MOV.B   W0L,[W5]
....................                     return ASYNC_WRITE_SEND_PACKET;                     
02B36:  MOV.B   #2,W0L
02B38:  MOV.B   W0L,0
02B3A:  BRA     2BBA
....................                 }     
02B3C:  GOTO    2B46
....................                 else 
....................                 { 
....................                     //The media is still busy. 
....................                     return ASYNC_WRITE_BUSY; 
02B40:  MOV.B   #3,W0L
02B42:  MOV.B   W0L,0
02B44:  BRA     2BBA
....................                 }     
....................             } 
02B46:  GOTO    2B5A
....................             else 
....................             { 
....................                 //Timeout occurred.  Something went wrong.  The media should not  
....................                 //have taken this long to finish the write. 
....................                 info->bStateVariable = ASYNC_WRITE_ABORT; 
02B4A:  MOV     #C,W0
02B4C:  ADD     10A6,W0
02B4E:  MOV     W0,W5
02B50:  MOV.B   #FE,W0L
02B52:  MOV.B   W0L,[W5]
....................                 return ASYNC_WRITE_BUSY; 
02B54:  MOV.B   #3,W0L
02B56:  MOV.B   W0L,0
02B58:  BRA     2BBA
....................             }         
....................          
....................         case ASYNC_STOP_TOKEN_SENT_WAIT_BUSY: 
....................             //We already sent the stop transmit token for the multi-block write  
....................             //operation.  Now all we need to do, is keep waiting until the card 
....................             //signals it is no longer busy.  Card will keep sending 0x00 bytes 
....................             //until it is no longer busy. 
....................             if(WriteTimeout != 0) 
02B5A:  CP0     DBA
02B5C:  BRA     NZ,2B62
02B5E:  CP0     DBC
02B60:  BRA     Z,2B8C
....................             { 
....................                 WriteTimeout--; 
02B62:  DEC     0DBA
02B64:  BTSS.B  42.0
02B66:  DEC     0DBC
....................                 data_byte = MDD_SDSPI_ReadMedia(); 
02B68:  CALL    F4A
02B6C:  MOV.B   W0L,D4D
....................                 //Check if card is no longer busy.   
....................                 if(data_byte != 0x00) 
02B6E:  CP0.B   D4D
02B70:  BRA     Z,2B86
....................                 { 
....................                     //If we get to here, multi-block write operation is fully 
....................                     //complete now.   
....................  
....................                     //Should send CMD13 (SEND_STATUS) after a programming sequence,  
....................                     //to confirm if it was successful or not inside the media. 
....................                                  
....................                     //Prepare to receive the next command. 
....................                     SD_CS = 1;          //De-select media 
02B72:  BSET.B  2F5.0
....................                     mSend8ClkCycles();  //NEC timing parameter clocking 
02B74:  SETM.B  10E2
02B76:  CALL    F36
....................                     info->bStateVariable = ASYNC_WRITE_COMPLETE; 
02B7A:  MOV     #C,W0
02B7C:  ADD     10A6,W0
02B7E:  MOV     W0,W5
02B80:  CLR.B   [W5]
....................                     return ASYNC_WRITE_COMPLETE; 
02B82:  CLR.B   0
02B84:  BRA     2BBA
....................                 } 
....................                 //If we get to here, the media is still busy with the write. 
....................                 return ASYNC_WRITE_BUSY;     
02B86:  MOV.B   #3,W0L
02B88:  MOV.B   W0L,0
02B8A:  BRA     2BBA
....................             }     
....................             //Timeout occurred.  Something went wrong.  Fall through to ASYNC_WRITE_ABORT. 
....................         case ASYNC_WRITE_ABORT: 
....................             //An error occurred, and we need to stop the write sequence so as to try and allow 
....................             //for recovery/re-attempt later. 
....................             SendMMCCmd(STOP_TRANSMISSION, 0x00000000); 
02B8C:  MOV.B   #5,W0L
02B8E:  MOV.B   W0L,10C2
02B90:  CLR     10C4
02B92:  CLR     10C6
02B94:  CALL    F58
....................             SD_CS = 1;  //deselect media 
02B98:  BSET.B  2F5.0
....................             mSend8ClkCycles();  //After raising CS pin, media may not tri-state data out for 1 bit time. 
02B9A:  SETM.B  10E2
02B9C:  CALL    F36
....................             info->bStateVariable = ASYNC_WRITE_ERROR;  
02BA0:  MOV     #C,W0
02BA2:  ADD     10A6,W0
02BA4:  MOV     W0,W5
02BA6:  SETM.B  [W5]
....................             //Fall through to default case. 
....................         default: 
....................             //Used for ASYNC_WRITE_ERROR case. 
....................             return ASYNC_WRITE_ERROR;  
02BA8:  SETM.B  0
02BAA:  BRA     2BBA
....................     }//switch(info->stateVariable)     
....................      
....................  
....................     //Should never execute to here.  All pathways should have a hit a return already. 
....................     info->bStateVariable = ASYNC_WRITE_ABORT; 
02BAC:  MOV     #C,W0
02BAE:  ADD     10A6,W0
02BB0:  MOV     W0,W5
02BB2:  MOV.B   #FE,W0L
02BB4:  MOV.B   W0L,[W5]
....................     return ASYNC_WRITE_BUSY; 
02BB6:  MOV.B   #3,W0L
02BB8:  MOV.B   W0L,0
02BBA:  MOV     [--W15],W5
02BBC:  RETURN  
.................... }  
....................  
....................  
.................... #ifdef __18CXX    
.................... /***************************************************************************** 
....................   Function: 
....................     static void PIC18_Optimized_SPI_Write_Packet(void) 
....................   Summary: 
....................     A private function intended for use internal to the SD-SPI.c file. 
....................     This function writes a specified number of bytes to the SPI module, 
....................     at high speed for optimum throughput, copied from the user specified RAM 
....................     buffer. 
....................     This function is only implemented and used on PIC18 devices. 
....................   Pre-Conditions: 
....................     The ioInfo.wNumBytes must be pre-initialized prior to calling  
....................     PIC18_Optimized_SPI_Write_Packet(). 
....................     Additionally, the ioInfo.pBuffer must also be pre-initialized, prior 
....................     to calling PIC18_Optimized_SPI_Write_Packet(). 
....................   Input: 
....................     ioInfo.wNumBytes global variable, initialized to the number of bytes to send 
....................     ioInfo.pBuffer global variable, initialized to point to the RAM location that 
....................         contains the data to send out the SPI port 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     A private function intended for use internal to the SD-SPI.c file. 
....................     This function writes a specified number of bytes to the SPI module, 
....................     at high speed for optimum throughput, copied from the user specified RAM 
....................     buffer. 
....................     This function is only implemented and used on PIC18 devices. 
....................   Remarks: 
....................     This function is speed optimized, using inline assembly language code, and 
....................     makes use of C compiler managed resources.  It is currently written to work 
....................     with the Microchip MPLAB C18 compiler, and may need modification if built 
....................     with a different PIC18 compiler. 
....................   *****************************************************************************/ 
.................... static void PIC18_Optimized_SPI_Write_Packet(void) 
.................... { 
....................     static BYTE bData; 
....................     static WORD FSR0Save; 
....................     static WORD PRODSave; 
....................  
....................     //Make sure the SPI_INTERRUPT_FLAG_ASM has been correctly defined, for the SPI 
....................     //module that is actually being used in the hardware. 
....................     #ifndef SPI_INTERRUPT_FLAG_ASM 
....................         #error Please add "#define SPI_INTERRUPT_FLAG_ASM  PIRx, Y" to your hardware profile.  Replace x and Y with appropriate numbers for your SPI module interrupt flag. 
....................     #endif 
....................      
....................     //Make sure at least one byte needs copying. 
....................     if(ioInfo.wNumBytes == 0) 
....................     { 
....................         return; 
....................     }     
....................  
....................     //Context save C compiler managed registers. 
....................     FSR0Save = FSR0;  
....................     PRODSave = PROD; 
....................      
....................     //Using PRODH and PRODL as 16 bit loop counter.  These are convenient since 
....................     //they are always in the access bank. 
....................     PROD = ioInfo.wNumBytes; 
....................     //Using FSR0 directly, for optimal SPI loop speed. 
....................     FSR0 = (WORD)ioInfo.pBuffer;  
....................  
.................... #if defined(__CCS__) 
.................... //had to modify this code to get rid of -2 BRA and the ,0 for all byte access 
.................... #endif 
....................  
....................  
....................     _asm 
....................         movf    POSTINC0, 0  //Fetch next byte to send and store in WREG 
....................         bra     ASMSPIXmitLoopEntryPoint 
.................... ASMSPIXmitLoop:     
....................         movf    POSTINC0, 0  //Pre-Fetch next byte to send and temporarily store in WREG 
....................         //Wait until last hardware SPI transaction is complete 
.................... ASMSPIXmitLoop2: 
....................         btfss   SPI_INTERRUPT_FLAG_ASM 
....................         bra     ASMSPIXmitLoop2 
....................          
.................... ASMSPIXmitLoopEntryPoint: 
....................         //Start the next SPI transaction 
....................         bcf     SPI_INTERRUPT_FLAG_ASM   //Clear interrupt flag 
....................         movwf   SPIBUF      //Write next byte to transmit to SSPBUF 
....................          
....................         //Now decrement byte counter for loop exit condition 
....................         movlw   0x00 
....................         decf    PRODL, 1     //Decrement LSB 
....................         subwfb  PRODH, 1    //Decrement MSB, only if borrow from LSB decrement 
....................         //Check if anymore bytes remain to be sent 
....................         movf    PRODL, 0     //copy PRODL to WREG 
....................         iorwf   PRODH, 0    //Z bit will be set if both PRODL and PRODH == 0x00 
....................         bnz     ASMSPIXmitLoop  //Go back and loop if our counter isn't = 0x0000. 
....................     _endasm 
....................  
....................     //Wait until the last SPI transaction is really complete.   
....................     //Above loop jumps out after the last byte is started, but not finished yet. 
....................     while(!SPI_INTERRUPT_FLAG); 
....................  
....................     //Leave SPI module in a "clean" state, ready for next transaction. 
....................     bData = SPIBUF;         //Dummy read to clear BF flag. 
....................     SPI_INTERRUPT_FLAG = 0; //Clear interrupt flag. 
....................     //Restore C compiler managed registers that we modified 
....................     PROD = PRODSave; 
....................     FSR0 = FSR0Save; 
.................... }     
.................... #endif     
....................  
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE MDD_SDSPI_SectorWrite (DWORD sector_addr, BYTE * buffer, BYTE allowWriteToZero) 
....................   Summary: 
....................     Writes a sector of data to an SD card. 
....................   Conditions: 
....................     The MDD_SectorWrite function pointer must be pointing to this function. 
....................   Input: 
....................     sector_addr -      The address of the sector on the card. 
....................     buffer -           The buffer with the data to write. 
....................     allowWriteToZero - 
....................                      - TRUE -  Writes to the 0 sector (MBR) are allowed 
....................                      - FALSE - Any write to the 0 sector will fail. 
....................   Return Values: 
....................     TRUE -  The sector was written successfully. 
....................     FALSE - The sector could not be written. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_SectorWrite function writes one sector of data (512 bytes)  
....................     of data from the location pointed to by 'buffer' to the specified sector of  
....................     the SD card. 
....................   Remarks: 
....................     The card expects the address field in the command packet to be a byte address. 
....................     The sector_addr value is ocnverted to a byte address by shifting it left nine 
....................     times (multiplying by 512). 
....................   ***************************************************************************************/ 
.................... BYTE MDD_SDSPI_SectorWrite(DWORD sector_addr, BYTE* buffer, BYTE allowWriteToZero) 
.................... { 
....................     static ASYNC_IO info; 
....................     BYTE status; 
02BBE:  CLR.B   109F
....................      
....................     if(allowWriteToZero == FALSE) 
02BC0:  CP0.B   109E
02BC2:  BRA     NZ,2BD0
....................     { 
....................         if(sector_addr == 0x00000000) 
02BC4:  CP0     1098
02BC6:  BRA     NZ,2BD0
02BC8:  CP0     109A
02BCA:  BRA     NZ,2BD0
....................         { 
....................             return FALSE; 
02BCC:  CLR.B   0
02BCE:  BRA     2C16
....................         }     
....................     }     
....................      
....................     //Initialize structure so we write a single sector worth of data. 
....................     info.wNumBytes = 512; 
02BD0:  MOV     #200,W4
02BD2:  MOV     W4,DBE
....................     info.dwBytesRemaining = 512; 
02BD4:  MOV     #200,W4
02BD6:  MOV     W4,DC0
02BD8:  CLR     DC2
....................     info.pBuffer = buffer; 
02BDA:  PUSH    109C
02BDC:  POP     DC4
....................     info.dwAddress = sector_addr; 
02BDE:  PUSH    1098
02BE0:  POP     DC6
02BE2:  PUSH    109A
02BE4:  POP     DC8
....................     info.bStateVariable = ASYNC_WRITE_QUEUED; 
02BE6:  MOV.B   #1,W0L
02BE8:  MOV.B   W0L,DCA
....................      
....................     //Repeatedly call the write handler until the operation is complete (or a 
....................     //failure/timeout occurred). 
....................     while(1) 
....................     { 
....................         status = MDD_SDSPI_AsyncWriteTasks(&info); 
02BEA:  MOV     #DBE,W4
02BEC:  MOV     W4,10A6
02BEE:  CALL    2918
02BF2:  MOV.B   W0L,109F
....................         if(status == ASYNC_WRITE_COMPLETE) 
02BF4:  CP0.B   109F
02BF6:  BRA     NZ,2C02
....................         { 
....................             return TRUE; 
02BF8:  MOV.B   #1,W0L
02BFA:  MOV.B   W0L,0
02BFC:  BRA     2C16
....................         }     
02BFE:  GOTO    2C0E
....................         else if(status == ASYNC_WRITE_ERROR) 
02C02:  MOV     109E,W4
02C04:  LSR     W4,#8,W4
02C06:  XOR.B   #FF,W4L
02C08:  BRA     NZ,2C0E
....................         { 
....................             return FALSE; 
02C0A:  CLR.B   0
02C0C:  BRA     2C16
....................         } 
02C0E:  GOTO    2BEA
....................     }     
....................     return TRUE; 
02C12:  MOV.B   #1,W0L
02C14:  MOV.B   W0L,0
02C16:  RETURN  
.................... }     
....................  
....................  
....................  
....................  
.................... /******************************************************************************* 
....................   Function: 
....................     BYTE MDD_SDSPI_WriteProtectState 
....................   Summary: 
....................     Indicates whether the card is write-protected. 
....................   Conditions: 
....................     The MDD_WriteProtectState function pointer must be pointing to this function. 
....................   Input: 
....................     None. 
....................   Return Values: 
....................     TRUE -  The card is write-protected 
....................     FALSE - The card is not write-protected 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_WriteProtectState function will determine if the SD card is 
....................     write protected by checking the electrical signal that corresponds to the 
....................     physical write-protect switch. 
....................   Remarks: 
....................     None 
.................... *******************************************************************************/ 
....................  
.................... BYTE MDD_SDSPI_WriteProtectState(void) 
.................... { 
....................    #if defined(SD_WE) 
....................     return(SD_WE); 
*
025A0:  CLR     W0
025A2:  BTSC.B  800.1
025A4:  INC     W0,W0
....................    #else 
025A6:  RETURN  
....................     return(FALSE); 
....................    #endif 
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................   Function: 
....................     void Delayms (BYTE milliseconds) 
....................   Summary: 
....................     Delay. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     BYTE milliseconds - Number of ms to delay 
....................   Return: 
....................     None. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The Delayms function will delay a specified number of milliseconds.  Used for SPI 
....................     timing. 
....................   Remarks: 
....................     Depending on compiler revisions, this function may not delay for the exact  
....................     time specified.  This shouldn't create a significant problem. 
.................... *******************************************************************************/ 
....................  
.................... void Delayms(BYTE milliseconds) 
.................... { 
....................     BYTE    ms; 
*
0109C:  CLR.B   FA5
....................     DWORD   count; 
0109E:  CLR     FA6
010A0:  CLR     FA8
....................      
....................     ms = milliseconds; 
010A2:  MOV.B   FA4,W0L
010A4:  MOV.B   W0L,FA5
....................     while (ms--) 
010A6:  MOV.B   FA5,W0L
010A8:  DEC.B   0FA5
010AA:  CP0.B   W0L
010AC:  BRA     Z,10CA
....................     { 
....................         count = MILLISECDELAY; 
010AE:  MOV     #7CB,W4
010B0:  MOV     W4,FA6
010B2:  CLR     FA8
....................         while (count--); 
010B4:  MOV     FA8,W1
010B6:  MOV     FA6,W0
010B8:  DEC     0FA6
010BA:  BTSS.B  42.0
010BC:  DEC     0FA8
010BE:  CP0     W0
010C0:  BRA     NZ,10B4
010C2:  CP0     W1
010C4:  BRA     NZ,10B4
010C6:  GOTO    10A6
....................     } 
....................     Nop(); 
010CA:  NOP     
....................     return; 
010CC:  RETURN  
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................   Function: 
....................     void CloseSPIM (void) 
....................   Summary: 
....................     Disables the SPI module. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     None. 
....................   Return: 
....................     None. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     Disables the SPI module. 
....................   Remarks: 
....................     None. 
.................... *******************************************************************************/ 
....................  
.................... void CloseSPIM (void) 
.................... { 
.................... #if defined __C30__ || defined __C32__ 
....................  
....................     SPISTAT &= 0x7FFF; 
*
01098:  BCLR.B  241.7
....................  
.................... #elif defined __18CXX 
0109A:  RETURN  
....................  
....................     SPICON1 &= 0xDF; 
....................  
.................... #endif 
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     unsigned char WriteSPIM (unsigned char data_out) 
....................   Summary: 
....................     Writes data to the SD card. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     data_out - The data to write. 
....................   Return: 
....................     0. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The WriteSPIM function will write a byte of data from the microcontroller to the 
....................     SD card. 
....................   Remarks: 
....................     None. 
....................   ***************************************************************************************/ 
....................  
.................... unsigned char WriteSPIM( unsigned char data_out ) 
.................... { 
.................... #ifdef __PIC32MX__ 
....................     BYTE   clear; 
....................     putcSPI((BYTE)data_out); 
....................     clear = getcSPI(); 
....................     return ( 0 );                // return non-negative# 
.................... #elif defined __18CXX 
....................     BYTE clear; 
....................     clear = SPIBUF; 
....................     SPICON1 &= 0x7F;       //__PCH__ __CCS__  clear wcol 
....................     SPI_INTERRUPT_FLAG = 0; 
....................     SPIBUF = data_out; 
....................     if (SPICON1 & 0x80) 
....................         return -1; 
....................     else 
....................         while (!SPI_INTERRUPT_FLAG); 
....................     return 0; 
.................... #else 
....................     BYTE   clear; 
*
00F36:  CLR.B   10E3
....................     SPIBUF = data_out;          // write byte to SSP1BUF register 
00F38:  MOV.B   10E2,W0L
00F3A:  MOV.B   W0L,248
00F3C:  CLR.B   249
....................     while( !SPISTAT_RBF ); // wait until bus cycle complete 
00F3E:  BTSS.B  240.0
00F40:  BRA     F3E
....................     clear = SPIBUF; 
00F42:  MOV.B   248,W0L
00F44:  MOV.B   W0L,10E3
....................     return ( 0 );                // return non-negative# 
00F46:  CLR.B   0
.................... #endif 
00F48:  RETURN  
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE MDD_SDSPI_ReadMedia (void) 
....................   Summary: 
....................     Reads a byte of data from the SD card. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     None. 
....................   Return: 
....................     The byte read. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_ReadMedia function will read one byte from the SPI port. 
....................   Remarks: 
....................     This function replaces ReadSPI, since some implementations of that function 
....................     will initialize SSPBUF/SPIBUF to 0x00 when reading.  The card expects 0xFF. 
....................   ***************************************************************************************/ 
.................... BYTE MDD_SDSPI_ReadMedia(void) 
.................... { 
....................  
.................... #ifdef __C32__ 
....................  
....................     putcSPI((BYTE)0xFF); 
....................     return (BYTE)getcSPI(); 
....................  
.................... #elif defined __18CXX 
....................     BYTE clear; 
....................     clear = SPIBUF; 
....................     SPI_INTERRUPT_FLAG = 0; 
....................     SPIBUF = 0xFF; 
....................     while (!SPI_INTERRUPT_FLAG); 
....................     return SPIBUF; 
....................  
.................... #else 
....................     SPIBUF = 0xFF;                              //Data Out - Logic ones 
00F4A:  MOV     #FF,W4
00F4C:  MOV     W4,248
....................     while(!SPISTAT_RBF);                     //Wait until cycle complete 
00F4E:  BTSS.B  240.0
00F50:  BRA     F4E
....................     return(SPIBUF);                             //Return with byte read 
00F52:  MOV.B   248,W0L
00F54:  MOV.B   W0L,0
.................... #endif 
00F56:  RETURN  
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     void OpenSPIM (unsigned int sync_mode) 
....................   Summary: 
....................     Initializes the SPI module 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     sync_mode - Input parameter that sets the SPI mode/speed. 
....................   Return: 
....................     None. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The OpenSPIM function will enable and configure the SPI module. 
....................   Remarks: 
....................     None. 
....................   ***************************************************************************************/ 
....................  
.................... #ifdef __18CXX 
.................... void OpenSPIM (unsigned char sync_mode) 
.................... #else 
.................... void OpenSPIM( unsigned int sync_mode) 
.................... #endif 
.................... { 
....................     SPISTAT = 0x0000;               // power on state  
*
00EBA:  CLR     240
....................  
....................     //SPI module initilization depends on processor type 
....................     #ifdef __PIC32MX__ 
....................         #if (GetSystemClock() <= 20000000) 
....................             SPIBRG = SPICalutateBRG(GetPeripheralClock(), 10000); 
....................         #else 
....................             SPIBRG = SPICalutateBRG(GetPeripheralClock(), SPI_FREQUENCY); 
....................         #endif 
....................         SPICON1bits.CKP = 1; 
....................         SPICON1bits.CKE = 0; 
....................     #elif defined __C30__ //must be PIC24 or dsPIC device 
....................         SPICON1 = 0x0000;              // power on state 
00EBC:  CLR     242
....................         SPICON1 |= sync_mode;          // select serial mode  
00EBE:  MOV     FAC,W0
00EC0:  IOR     242
....................         SPICON1bits.CKP = 1; 
00EC2:  BSET.B  242.6
....................         SPICON1bits.CKE = 0; 
00EC4:  BCLR.B  243.0
....................     #else   //must be __18CXX (PIC18 processor) 
....................         SPICON1 = 0x00;          
....................         SPICON1 |= sync_mode;    
....................         SPISTATbits.CKE = 1; 
....................     #endif 
....................  
....................     SPICLOCK = 0; 
00EC6:  BCLR.B  2E8.3
....................     SPIOUT = 0;                  // define SDO1 as output (master or slave) 
00EC8:  BCLR.B  2E8.2
....................     SPIIN = 1;                  // define SDI1 as input (master or slave) 
00ECA:  BSET.B  2E8.6
....................     SPIENABLE = 1;             // enable synchronous serial port 
00ECC:  BSET.B  241.7
00ECE:  RETURN  
.................... } 
....................  
....................  
.................... #ifdef __18CXX 
.................... // Description: Delay value for the manual SPI clock 
.................... #define MANUAL_SPI_CLOCK_VALUE             1 
.................... /***************************************************************************** 
....................   Function: 
....................     unsigned char WriteSPIManual (unsigned char data_out) 
....................   Summary: 
....................     Write a character to the SD card with bit-bang SPI. 
....................   Conditions: 
....................     Make sure the SDI pin is pre-configured as a digital pin, if it is  
....................     multiplexed with analog functionality. 
....................   Input: 
....................     data_out - Data to send. 
....................   Return: 
....................     0. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     Writes a character to the SD card. 
....................   Remarks: 
....................     The WriteSPIManual function is for use on a PIC18 when the clock speed is so 
....................     high that the maximum SPI clock divider cannot reduce the SPI clock speed below 
....................     the maximum SD card initialization speed. 
....................   ***************************************************************************************/ 
.................... unsigned char WriteSPIManual(unsigned char data_out) 
.................... { 
....................     unsigned char i; 
....................     unsigned char clock; 
....................  
....................     SPICLOCKLAT = 0; 
....................     SPIOUTLAT = 1; 
....................     SPICLOCK = OUTPUT; 
....................     SPIOUT = OUTPUT; 
....................  
....................    //Loop to send out 8 bits of SDO data and associated SCK clock. 
....................    for(i = 0; i < 8; i++) 
....................    { 
....................       SPICLOCKLAT = 0; 
....................       if(data_out & 0x80) 
....................          SPIOUTLAT = 1; 
....................       else 
....................          SPIOUTLAT = 0; 
....................       data_out = data_out << 1;            //Bit shift, so next bit to send is in MSb position 
....................        clock = MANUAL_SPI_CLOCK_VALUE; 
....................        while (clock--); 
....................        SPICLOCKLAT = 1; 
....................        clock = MANUAL_SPI_CLOCK_VALUE; 
....................        while (clock--);              
....................    }    
....................     SPICLOCKLAT = 0; 
....................  
....................     return 0;  
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE ReadMediaManual (void) 
....................   Summary: 
....................     Reads a byte of data from the SD card. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     None. 
....................   Return: 
....................     The byte read. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_ReadMedia function will read one byte from the SPI port. 
....................   Remarks: 
....................     This function replaces ReadSPI, since some implementations of that function 
....................     will initialize SSPBUF/SPIBUF to 0x00 when reading.  The card expects 0xFF. 
....................     This function is for use on a PIC18 when the clock speed is so high that the 
....................     maximum SPI clock prescaler cannot reduce the SPI clock below the maximum SD card 
....................     initialization speed. 
....................   ***************************************************************************************/ 
.................... BYTE ReadMediaManual (void) 
.................... { 
....................     unsigned char i; 
....................     unsigned char clock; 
....................     unsigned char result = 0x00; 
....................  
....................     SPIOUTLAT = 1; 
....................     SPIOUT = OUTPUT; 
....................     SPIIN = INPUT; 
....................     SPICLOCKLAT = 0; 
....................     SPICLOCK = OUTPUT; 
....................   
....................     //Loop to send 8 clock pulses and read in the returned bits of data. Data "sent" will be = 0xFF 
....................    for(i = 0; i < 8u; i++) 
....................    { 
....................       SPICLOCKLAT = 0; 
....................        clock = MANUAL_SPI_CLOCK_VALUE; 
....................        while (clock--); 
....................        SPICLOCKLAT = 1; 
....................        clock = MANUAL_SPI_CLOCK_VALUE; 
....................        while (clock--); 
....................       result = result << 1;   //Bit shift the previous result.  We receive the byte MSb first. This operation makes LSb = 0.   
....................        if(SPIINPORT) 
....................           result++;         //Set the LSb if we detected a '1' on the SPIINPORT pin, otherwise leave as 0. 
....................    }    
....................     SPICLOCKLAT = 0; 
....................  
....................     return result; 
.................... }//end ReadMedia 
.................... #endif      // End __18CXX 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     void InitSPISlowMode(void) 
....................   Summary: 
....................     Initializes the SPI module to operate at low SPI frequency <= 400kHz. 
....................   Conditions: 
....................     Processor type and GetSystemClock() macro have to be defined correctly 
....................     to get the correct SPI frequency. 
....................   Input: 
....................     Uses GetSystemClock() macro value.  Should be #define in the hardwareprofile. 
....................   Return Values: 
....................     None.  Initializes the hardware SPI module (except on PIC18).  On PIC18, 
....................     The SPI is bit banged to achieve low frequencies, but this function still 
....................     initializes the I/O pins.  
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     This function initalizes and enables the SPI module, configured for low  
....................     SPI frequency, so as to be compatible with media cards which require <400kHz 
....................     SPI frequency during initialization. 
....................   Remarks: 
....................     None. 
....................   ***************************************************************************************/ 
.................... void InitSPISlowMode(void) 
.................... { 
....................     #if defined __C30__ || defined __C32__ 
00ED0:  MOV     W5,[W15++]
00ED2:  MOV     W6,[W15++]
00ED4:  MOV     #3,W4
00ED6:  MOV     W4,FA4
....................        #ifdef __PIC32MX__ 
....................           OpenSPI(SPI_START_CFG_1, SPI_START_CFG_2); 
....................            SPIBRG = SPICalutateBRG(GetPeripheralClock(), 400000); 
....................        #else //else C30 = PIC24/dsPIC devices 
....................           WORD spiconvalue = 0x0003; 
....................             WORD timeout; 
00ED8:  CLR     FA6
....................            // Calculate the prescaler needed for the clock 
....................            timeout = GetSystemClock() / 400000; 
00EDA:  MOV     #50,W4
00EDC:  MOV     W4,FA6
....................            // if timeout is less than 400k and greater than 100k use a 1:1 prescaler 
....................            if (timeout == 0) 
00EDE:  CP0     FA6
00EE0:  BRA     NZ,EEE
....................            { 
....................                OpenSPIM (MASTER_ENABLE_ON | PRI_PRESCAL_1_1 | SEC_PRESCAL_1_1); 
00EE2:  MOV     #3F,W4
00EE4:  MOV     W4,FAC
00EE6:  CALL    EBA
....................            } 
00EEA:  GOTO    F30
....................            else 
....................            { 
....................                while (timeout != 0) 
00EEE:  CP0     FA6
00EF0:  BRA     Z,F18
....................                { 
....................                    if (timeout > 8) 
00EF2:  MOV     FA6,W4
00EF4:  CP      W4,#8
00EF6:  BRA     LEU,F10
....................                    { 
....................                        spiconvalue--; 
00EF8:  DEC     0FA4
....................                        // round up 
....................                        if ((timeout % 4) != 0) 
00EFA:  MOV     FA6,W0
00EFC:  AND     W0,#3,W5
00EFE:  CP0     W5
00F00:  BRA     Z,F08
....................                            timeout += 4; 
00F02:  MOV     FA6,W4
00F04:  ADD     W4,#4,W4
00F06:  MOV     W4,FA6
....................                        timeout /= 4; 
00F08:  LSR     FA6
00F0A:  LSR     FA6
....................                    } 
00F0C:  GOTO    F14
....................                    else 
....................                    { 
....................                        break; 
00F10:  GOTO    F18
....................                    } 
00F14:  GOTO    EEE
....................                } 
....................                 
....................                timeout--; 
00F18:  DEC     0FA6
....................             
....................                OpenSPIM (MASTER_ENABLE_ON | spiconvalue | ((~(timeout << 2)) & 0x1C)); 
00F1A:  MOV     FA4,W5
00F1C:  IOR     #20,W5
00F1E:  MOV     FA6,W0
00F20:  SL      W0,#2,W0
00F22:  COM     W0,W0
00F24:  MOV     W0,W6
00F26:  AND     W6,#1C,W0
00F28:  IOR      W5,  W0,W5
00F2A:  MOV     W5,FAC
00F2C:  CALL    EBA
....................            } 
....................        #endif   //#ifdef __PIC32MX__ (and corresponding #else)     
....................     #else //must be PIC18 device 
00F30:  MOV     [--W15],W6
00F32:  MOV     [--W15],W5
00F34:  RETURN  
....................         //Make sure the SPI module doesn't control the bus, will use  
....................         //bit-banged SPI instead, for slow mode initialization operation 
....................         SPICON1 = 0x00; 
....................         SPICLOCKLAT = 0; 
....................         SPIOUTLAT = 1; 
....................         SPICLOCK = OUTPUT; 
....................         SPIOUT = OUTPUT; 
....................     #endif //#if defined __C30__ || defined __C32__ 
.................... }     
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     MEDIA_INFORMATION *  MDD_SDSPI_MediaInitialize (void) 
....................   Summary: 
....................     Initializes the SD card. 
....................   Conditions: 
....................     The MDD_MediaInitialize function pointer must be pointing to this function. 
....................   Input: 
....................     None. 
....................   Return Values: 
....................     The function returns a pointer to the MEDIA_INFORMATION structure.  The 
....................     errorCode member may contain the following values: 
....................         * MEDIA_NO_ERROR - The media initialized successfully 
....................         * MEDIA_CANNOT_INITIALIZE - Cannot initialize the media.   
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     This function will send initialization commands to and SD card. 
....................   Remarks: 
....................     Psuedo code flow for the media initialization process is as follows: 
....................  
.................... ------------------------------------------------------------------------------------------- 
.................... SD Card SPI Initialization Sequence (for physical layer v1.x or v2.0 device) is as follows: 
.................... ------------------------------------------------------------------------------------------- 
.................... 0.  Power up tasks 
....................     a.  Initialize microcontroller SPI module to no more than 400kbps rate so as to support MMC devices. 
....................     b.  Add delay for SD card power up, prior to sending it any commands.  It wants the  
....................         longer of: 1ms, the Vdd ramp time (time from 2.7V to Vdd stable), and 74+ clock pulses. 
.................... 1.  Send CMD0 (GO_IDLE_STATE) with CS = 0.  This puts the media in SPI mode and software resets the SD/MMC card. 
.................... 2.  Send CMD8 (SEND_IF_COND).  This requests what voltage the card wants to run at.  
....................     Note: Some cards will not support this command. 
....................     a.  If illegal command response is received, this implies either a v1.x physical spec device, or not an SD card (ex: MMC). 
....................     b.  If normal response is received, then it must be a v2.0 or later SD memory card. 
....................  
.................... If v1.x device: 
.................... ----------------- 
.................... 3.  Send CMD1 repeatedly, until initialization complete (indicated by R1 response byte/idle bit == 0) 
.................... 4.  Basic initialization is complete.  May now switch to higher SPI frequencies. 
.................... 5.  Send CMD9 to read the CSD structure.  This will tell us the total flash size and other info which will be useful later. 
.................... 6.  Parse CSD structure bits (based on v1.x structure format) and extract useful information about the media. 
.................... 7.  The card is now ready to perform application data transfers. 
....................  
.................... If v2.0+ device: 
.................... ----------------- 
.................... 3.  Verify the voltage range is feasible.  If not, unusable card, should notify user that the card is incompatible with this host. 
.................... 4.  Send CMD58 (Read OCR). 
.................... 5.  Send CMD55, then ACMD41 (SD_SEND_OP_COND, with HCS = 1). 
....................     a.  Loop CMD55/ACMD41 until R1 response byte == 0x00 (indicating the card is no longer busy/no longer in idle state).   
.................... 6.  Send CMD58 (Get CCS). 
....................     a.  If CCS = 1 --> SDHC card. 
....................     b.  If CCS = 0 --> Standard capacity SD card (which is v2.0+). 
.................... 7.  Basic initialization is complete.  May now switch to higher SPI frequencies. 
.................... 8.  Send CMD9 to read the CSD structure.  This will tell us the total flash size and other info which will be useful later. 
.................... 9.  Parse CSD structure bits (based on v2.0 structure format) and extract useful information about the media. 
.................... 10. The card is now ready to perform application data transfers. 
.................... -------------------------------------------------------------------------------- 
.................... ********************************************************************************/ 
....................  
.................... MEDIA_INFORMATION *  MDD_SDSPI_MediaInitialize(void) 
*
010FE:  MOV     W5,[W15++]
01100:  MOV     W6,[W15++]
01102:  MOV     W7,[W15++]
.................... { 
....................     WORD timeout; 
01104:  CLR     F80
....................     MMC_RESPONSE response; 
01106:  CLR     F82
01108:  CLR     F84
0110A:  CLR     F86
....................    BYTE CSDResponse[20]; 
0110C:  CLR     F88
0110E:  CLR     F8A
01110:  CLR     F8C
01112:  CLR     F8E
01114:  CLR     F90
01116:  CLR     F92
01118:  CLR     F94
0111A:  CLR     F96
0111C:  CLR     F98
0111E:  CLR     F9A
....................    BYTE count, index; 
01120:  CLR.B   F9C
01122:  CLR.B   F9D
....................    DWORD c_size; 
01124:  CLR     F9E
01126:  CLR     FA0
....................    BYTE c_size_mult; 
01128:  CLR.B   FA2
....................    BYTE block_len; 
0112A:  CLR.B   FA3
....................     
....................    #ifdef __DEBUG_UART 
....................    InitUART(); 
....................    #endif 
....................   
....................     //Initialize global variables.  Will get updated later with valid data once 
....................     //the data is known. 
....................     mediaInformation.errorCode = MEDIA_NO_ERROR; 
0112C:  CLR.B   D4E
....................     mediaInformation.validityFlags.value = 0; 
0112E:  CLR.B   D4F
....................     MDD_SDSPI_finalLBA = 0x00000000;   //Will compute a valid size later, from the CSD register values we get from the card 
01130:  CLR     D46
01132:  CLR     D48
....................     gSDMode = SD_MODE_NORMAL;           //Will get updated later with real value, once we know based on initialization flow. 
01134:  CLR.B   D4C
....................  
....................     SD_CS = 1;               //Initialize Chip Select line (1 = card not selected) 
01136:  BSET.B  2F5.0
....................  
....................     //MMC media powers up in the open-drain mode and cannot handle a clock faster 
....................     //than 400kHz. Initialize SPI port to <= 400kHz 
....................     InitSPISlowMode();     
01138:  CALL    ED0
....................      
....................     #ifdef __DEBUG_UART   
....................     PrintROMASCIIStringUART("\r\n\r\nInitializing Media\r\n");  
....................     #endif 
....................  
....................     //Media wants the longer of: Vdd ramp time, 1 ms fixed delay, or 74+ clock pulses. 
....................     //According to spec, CS should be high during the 74+ clock pulses. 
....................     //In practice it is preferrable to wait much longer than 1ms, in case of 
....................     //contact bounce, or incomplete mechanical insertion (by the time we start 
....................     //accessing the media).  
....................     Delayms(30); 
0113C:  MOV.B   #1E,W0L
0113E:  MOV.B   W0L,FA4
01140:  CALL    109C
....................     SD_CS = 1; 
01144:  BSET.B  2F5.0
....................     //Generate 80 clock pulses. 
....................     for(timeout=0; timeout<10u; timeout++) 
01146:  CLR     F80
01148:  MOV     F80,W4
0114A:  CP      W4,#A
0114C:  BRA     C,115A
....................         WriteSPISlow(0xFF); 
0114E:  SETM.B  10E2
01150:  CALL    F36
01154:  INC     0F80
01156:  GOTO    1148
....................  
....................  
....................     // Send CMD0 (with CS = 0) to reset the media and put SD cards into SPI mode. 
....................     timeout = 100; 
0115A:  MOV     #64,W4
0115C:  MOV     W4,F80
....................     do 
....................     { 
....................         //Toggle chip select, to make media abandon whatever it may have been doing 
....................         //before.  This ensures the CMD0 is sent freshly after CS is asserted low, 
....................         //minimizing risk of SPI clock pulse master/slave syncronization problems,  
....................         //due to possible application noise on the SCK line. 
....................         SD_CS = 1; 
0115E:  BSET.B  2F5.0
....................         WriteSPISlow(0xFF);   //Send some "extraneous" clock pulses.  If a previous 
01160:  SETM.B  10E2
01162:  CALL    F36
....................                               //command was terminated before it completed normally, 
....................                               //the card might not have received the required clocking 
....................                               //following the transfer. 
....................         SD_CS = 0; 
01166:  BCLR.B  2F5.0
....................         timeout--; 
01168:  DEC     0F80
....................  
....................         //Send CMD0 to software reset the device 
....................         response = SendMediaSlowCmd(GO_IDLE_STATE, 0x0); 
0116A:  CLR.B   10C2
0116C:  CLR     10C4
0116E:  CLR     10C6
01170:  CALL    F58
01174:  MOV     W0,F82
01176:  MOV     W1,F84
01178:  MOV     W2,F86
....................     }while((response.r1._byte != 0x01) && (timeout != 0)); 
0117A:  MOV     F82,W4
0117C:  CP.B    W4L,#1
0117E:  BRA     Z,1184
01180:  CP0     F80
01182:  BRA     NZ,115E
....................     //Check if all attempts failed and we timed out.  Normally, this won't happen, 
....................     //unless maybe the SD card was busy, because it was previously performing a 
....................     //read or write operation, when it was interrupted by the microcontroller getting 
....................     //reset or power cycled, without also resetting or power cycling the SD card. 
....................     //In this case, the SD card may still be busy (ex: trying to respond with the  
....................     //read request data), and may not be ready to process CMD0.  In this case, 
....................     //we can try to recover by issuing CMD12 (STOP_TRANSMISSION). 
....................     if(timeout == 0) 
01184:  CP0     F80
01186:  BRA     NZ,11CC
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("Media failed CMD0 too many times. R1 response byte = "); 
....................         PrintRAMBytesUART(((unsigned char*)&response + 1), 1); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         PrintROMASCIIStringUART("Trying CMD12 to recover.\r\n"); 
....................         #endif 
....................  
....................         SD_CS = 1; 
01188:  BSET.B  2F5.0
....................         WriteSPISlow(0xFF);       //Send some "extraneous" clock pulses.  If a previous 
0118A:  SETM.B  10E2
0118C:  CALL    F36
....................                                   //command was terminated before it completed normally, 
....................                                   //the card might not have received the required clocking 
....................                                   //following the transfer. 
....................         SD_CS = 0; 
01190:  BCLR.B  2F5.0
....................  
....................         //Send CMD12, to stop any read/write transaction that may have been in progress 
....................         response = SendMediaSlowCmd(STOP_TRANSMISSION, 0x0);    //Blocks until SD card signals non-busy 
01192:  MOV.B   #5,W0L
01194:  MOV.B   W0L,10C2
01196:  CLR     10C4
01198:  CLR     10C6
0119A:  CALL    F58
0119E:  MOV     W0,F82
011A0:  MOV     W1,F84
011A2:  MOV     W2,F86
....................         //Now retry to send send CMD0 to perform software reset on the media 
....................         response = SendMediaSlowCmd(GO_IDLE_STATE, 0x0);         
011A4:  CLR.B   10C2
011A6:  CLR     10C4
011A8:  CLR     10C6
011AA:  CALL    F58
011AE:  MOV     W0,F82
011B0:  MOV     W1,F84
011B2:  MOV     W2,F86
....................         if(response.r1._byte != 0x01) //Check if card in idle state now. 
011B4:  MOV     F82,W4
011B6:  CP.B    W4L,#1
011B8:  BRA     Z,11C8
....................         { 
....................             //Card failed to process CMD0 yet again.  At this point, the proper thing 
....................             //to do would be to power cycle the card and retry, if the host  
....................             //circuitry supports disconnecting the SD card power.  Since the 
....................             //SD/MMC PICtail+ doesn't support software controlled power removal 
....................             //of the SD card, there is nothing that can be done with this hardware. 
....................             //Therefore, we just give up now.  The user needs to physically  
....................             //power cycle the media and/or the whole board. 
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("Media still failed CMD0. Cannot initialize card, returning.\r\n"); 
....................             #endif    
....................             mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE; 
011BA:  MOV.B   #2,W0L
011BC:  MOV.B   W0L,D4E
....................             return &mediaInformation; 
011BE:  MOV     #D4E,W4
011C0:  MOV     W4,0
011C2:  BRA     145A
....................         }             
011C4:  GOTO    11C8
....................         else 
....................         { 
....................             //Card successfully processed CMD0 and is now in the idle state. 
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("Media successfully processed CMD0 after CMD12.\r\n"); 
....................             #endif         
....................         }     
....................     }//if(timeout == 0) [for the CMD0 transmit loop] 
011C8:  GOTO    11CC
....................     else 
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("Media successfully processed CMD0.\r\n"); 
....................         #endif         
....................     }        
....................      
....................  
....................     //Send CMD8 (SEND_IF_COND) to specify/request the SD card interface condition (ex: indicate what voltage the host runs at). 
....................     //0x000001AA --> VHS = 0001b = 2.7V to 3.6V.  The 0xAA LSB is the check pattern, and is arbitrary, but 0xAA is recommended (good blend of 0's and '1's). 
....................     //The SD card has to echo back the check pattern correctly however, in the R7 response. 
....................     //If the SD card doesn't support the operating voltage range of the host, then it may not respond. 
....................     //If it does support the range, it will respond with a type R7 reponse packet (6 bytes/48 bits).            
....................     //Additionally, if the SD card is MMC or SD card v1.x spec device, then it may respond with 
....................     //invalid command.  If it is a v2.0 spec SD card, then it is mandatory that the card respond 
....................     //to CMD8. 
....................     response = SendMediaSlowCmd(SEND_IF_COND, 0x1AA);   //Note: If changing "0x1AA", CRC value in table must also change. 
011CC:  MOV.B   #2,W0L
011CE:  MOV.B   W0L,10C2
011D0:  MOV     #1AA,W4
011D2:  MOV     W4,10C4
011D4:  CLR     10C6
011D6:  CALL    F58
011DA:  MOV     W0,F82
011DC:  MOV     W1,F84
011DE:  MOV     W2,F86
....................     if(((response.r7.bytewise.argument._returnVal & 0xFFF) == 0x1AA) && (!response.r7.bitwise.bits.ILLEGAL_CMD)) 
011E0:  MOV     #FFF,W0
011E2:  AND     F84,W0
011E4:  MOV     W0,W5
011E6:  CLR     W6
011E8:  MOV     #1AA,W4
011EA:  CP      W4,W5
011EC:  BRA     NZ,127C
011EE:  CP0     W6
011F0:  BRA     NZ,127C
011F2:  BTSC.B  F82.2
011F4:  BRA     127C
....................       { 
....................         //If we get to here, the device supported the CMD8 command and didn't complain about our host 
....................         //voltage range. 
....................         //Most likely this means it is either a v2.0 spec standard or high capacity SD card (SDHC) 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("Media successfully processed CMD8. Response = "); 
....................         PrintRAMBytesUART(((unsigned char*)&response + 1), 4); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................  
....................       //Send CMD58 (Read OCR [operating conditions register]).  Reponse type is R3, which has 5 bytes. 
....................       //Byte 4 = normal R1 response byte, Bytes 3-0 are = OCR register value. 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("Sending CMD58.\r\n"); 
....................         #endif 
....................         response = SendMediaSlowCmd(READ_OCR, 0x0); 
011F6:  MOV.B   #10,W0L
011F8:  MOV.B   W0L,10C2
011FA:  CLR     10C4
011FC:  CLR     10C6
011FE:  CALL    F58
01202:  MOV     W0,F82
01204:  MOV     W1,F84
01206:  MOV     W2,F86
....................         //Now that we have the OCR register value in the reponse packet, we could parse 
....................         //the register contents and learn what voltage the SD card wants to run at. 
....................         //If our host circuitry has variable power supply capability, it could  
....................         //theoretically adjust the SD card Vdd to the minimum of the OCR to save power. 
....................        
....................       //Now send CMD55/ACMD41 in a loop, until the card is finished with its internal initialization. 
....................       //Note: SD card specs recommend >= 1 second timeout while waiting for ACMD41 to signal non-busy. 
....................       for(timeout = 0; timeout < 0xFFFF; timeout++) 
01208:  CLR     F80
0120A:  MOV     F80,W4
0120C:  MOV     #FFFF,W3
0120E:  CP      W3,W4
01210:  BRA     Z,1240
....................       {             
....................          //Send CMD55 (lets SD card know that the next command is application specific (going to be ACMD41)). 
....................          SendMediaSlowCmd(APP_CMD, 0x00000000); 
01212:  MOV.B   #F,W0L
01214:  MOV.B   W0L,10C2
01216:  CLR     10C4
01218:  CLR     10C6
0121A:  CALL    F58
....................           
....................          //Send ACMD41.  This is to check if the SD card is finished booting up/ready for full frequency and all 
....................          //further commands.  Response is R3 type (6 bytes/48 bits, middle four bytes contain potentially useful data). 
....................             //Note: When sending ACMD41, the HCS bit is bit 30, and must be = 1 to tell SD card the host supports SDHC 
....................          response = SendMediaSlowCmd(SD_SEND_OP_COND,0x40000000); //bit 30 set 
0121E:  MOV.B   #12,W0L
01220:  MOV.B   W0L,10C2
01222:  CLR     10C4
01224:  MOV     #4000,W4
01226:  MOV     W4,10C6
01228:  CALL    F58
0122C:  MOV     W0,F82
0122E:  MOV     W1,F84
01230:  MOV     W2,F86
....................           
....................          //The R1 response should be = 0x00, meaning the card is now in the "standby" state, instead of 
....................          //the "idle" state (which is the default initialization state after CMD0 reset is issued).  Once 
....................          //in the "standby" state, the SD card is finished with basic intitialization and is ready  
....................          //for read/write and other commands. 
....................          if(response.r1._byte == 0) 
01232:  CP0.B   F82
01234:  BRA     NZ,123A
....................          { 
....................               #ifdef __DEBUG_UART   
....................                 PrintROMASCIIStringUART("Media successfully processed CMD55/ACMD41 and is no longer busy.\r\n"); 
....................             #endif 
....................             break;  //Break out of for() loop.  Card is finished initializing. 
01236:  GOTO    1240
....................             }             
0123A:  INC     0F80
0123C:  GOTO    120A
....................       }       
....................       if(timeout >= 0xFFFF) 
01240:  MOV     F80,W4
01242:  MOV     #FFFF,W3
01244:  CP      W3,W4
01246:  BRA     NZ,124C
....................       { 
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("Media Timeout on CMD55/ACMD41.\r\n"); 
....................             #endif 
....................           mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE; 
01248:  MOV.B   #2,W0L
0124A:  MOV.B   W0L,D4E
....................         }             
....................        
....................        
....................         //Now send CMD58 (Read OCR register).  The OCR register contains important 
....................         //info we will want to know about the card (ex: standard capacity vs. SDHC). 
....................         response = SendMediaSlowCmd(READ_OCR, 0x0);  
0124C:  MOV.B   #10,W0L
0124E:  MOV.B   W0L,10C2
01250:  CLR     10C4
01252:  CLR     10C6
01254:  CALL    F58
01258:  MOV     W0,F82
0125A:  MOV     W1,F84
0125C:  MOV     W2,F86
....................  
....................       //Now check the CCS bit (OCR bit 30) in the OCR register, which is in our response packet. 
....................       //This will tell us if it is a SD high capacity (SDHC) or standard capacity device. 
....................       if(response.r7.bytewise.argument._returnVal & 0x40000000)    //Note the HCS bit is only valid when the busy bit is also set (indicating device ready). 
0125E:  MOV     #4000,W0
01260:  AND     F86,W0
01262:  MOV     W0,W1
01264:  CLR     W0
01266:  CP0     W0
01268:  BRA     NZ,126E
0126A:  CP0     W1
0126C:  BRA     Z,1276
....................       { 
....................          gSDMode = SD_MODE_HC; 
0126E:  MOV.B   #1,W0L
01270:  MOV.B   W0L,D4C
....................           
....................           #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("Media successfully processed CMD58: SD card is SDHC v2.0 (or later) physical spec type.\r\n"); 
....................             #endif 
....................         }             
01272:  GOTO    1278
....................         else 
....................         { 
....................             gSDMode = SD_MODE_NORMAL; 
01276:  CLR.B   D4C
....................  
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("Media successfully processed CMD58: SD card is standard capacity v2.0 (or later) spec.\r\n"); 
....................             #endif 
....................         }  
....................         //SD Card should now be finished with initialization sequence.  Device should be ready 
....................         //for read/write commands. 
....................  
....................    }//if(((response.r7.bytewise._returnVal & 0xFFF) == 0x1AA) && (!response.r7.bitwise.bits.ILLEGAL_CMD)) 
01278:  GOTO    12B8
....................     else 
....................    { 
....................         //The CMD8 wasn't supported.  This means the card is not a v2.0 card. 
....................         //Presumably the card is v1.x device, standard capacity (not SDHC). 
....................  
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("CMD8 Unsupported: Media is most likely MMC or SD 1.x device.\r\n"); 
....................         #endif 
....................  
....................  
....................         SD_CS = 1;                              // deselect the devices 
0127C:  BSET.B  2F5.0
....................         Delayms(1); 
0127E:  MOV.B   #1,W0L
01280:  MOV.B   W0L,FA4
01282:  CALL    109C
....................         SD_CS = 0;                              // select the device 
01286:  BCLR.B  2F5.0
....................  
....................         //The CMD8 wasn't supported.  This means the card is definitely not a v2.0 SDHC card. 
....................         gSDMode = SD_MODE_NORMAL; 
01288:  CLR.B   D4C
....................        // According to the spec CMD1 must be repeated until the card is fully initialized 
....................        timeout = 0x1FFF; 
0128A:  MOV     #1FFF,W4
0128C:  MOV     W4,F80
....................         do 
....................         { 
....................             //Send CMD1 to initialize the media. 
....................             response = SendMediaSlowCmd(SEND_OP_COND, 0x00000000);    //When argument is 0x00000000, this queries MMC cards for operating voltage range 
0128E:  MOV.B   #1,W0L
01290:  MOV.B   W0L,10C2
01292:  CLR     10C4
01294:  CLR     10C6
01296:  CALL    F58
0129A:  MOV     W0,F82
0129C:  MOV     W1,F84
0129E:  MOV     W2,F86
....................             timeout--; 
012A0:  DEC     0F80
....................         }while((response.r1._byte != 0x00) && (timeout != 0)); 
012A2:  CP0.B   F82
012A4:  BRA     Z,12AA
012A6:  CP0     F80
012A8:  BRA     NZ,128E
....................         // see if it failed 
....................         if(timeout == 0) 
012AA:  CP0     F80
012AC:  BRA     NZ,12B8
....................         { 
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("CMD1 failed.\r\n"); 
....................             #endif 
....................  
....................             mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE; 
012AE:  MOV.B   #2,W0L
012B0:  MOV.B   W0L,D4E
....................             SD_CS = 1;                              // deselect the devices 
012B2:  BSET.B  2F5.0
....................         } 
012B4:  GOTO    12B8
....................         else 
....................         { 
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("CMD1 Successfully processed, media is no longer busy.\r\n"); 
....................             #endif 
....................              
....................             //Set read/write block length to 512 bytes.  Note: commented out since 
....................             //this theoretically isn't necessary, since all cards v1 and v2 are  
....................             //required to support 512 byte block size, and this is supposed to be 
....................             //the default size selected on cards that support other sizes as well. 
....................             //response = SendMediaSlowCmd(SET_BLOCKLEN, 0x00000200);    //Set read/write block length to 512 bytes 
....................         } 
....................         
....................    } 
....................  
....................  
....................     //Temporarily deselect device 
....................     SD_CS = 1; 
012B8:  BSET.B  2F5.0
....................      
....................     //Basic initialization of media is now complete.  The card will now use push/pull 
....................     //outputs with fast drivers.  Therefore, we can now increase SPI speed to  
....................     //either the maximum of the microcontroller or maximum of media, whichever  
....................     //is slower.  MMC media is typically good for at least 20Mbps SPI speeds.   
....................     //SD cards would typically operate at up to 25Mbps or higher SPI speeds. 
....................     OpenSPIM(SYNC_MODE_FAST); 
012BA:  MOV     #3E,W4
012BC:  MOV     W4,FAC
012BE:  CALL    EBA
....................  
....................    SD_CS = 0; 
012C2:  BCLR.B  2F5.0
....................  
....................    /* Send the CMD9 to read the CSD register */ 
....................     timeout = NCR_TIMEOUT; 
012C4:  MOV     #14,W4
012C6:  MOV     W4,F80
....................     do 
....................     { 
....................         //Send CMD9: Read CSD data structure. 
....................       response = SendMMCCmd(SEND_CSD, 0x00); 
012C8:  MOV.B   #3,W0L
012CA:  MOV.B   W0L,10C2
012CC:  CLR     10C4
012CE:  CLR     10C6
012D0:  CALL    F58
012D4:  MOV     W0,F82
012D6:  MOV     W1,F84
012D8:  MOV     W2,F86
....................         timeout--; 
012DA:  DEC     0F80
....................     }while((response.r1._byte != 0x00) && (timeout != 0)); 
012DC:  CP0.B   F82
012DE:  BRA     Z,12E4
012E0:  CP0     F80
012E2:  BRA     NZ,12C8
....................     if(timeout != 0x00) 
012E4:  CP0     F80
012E6:  BRA     Z,12EC
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("CMD9 Successfully processed: Read CSD register.\r\n"); 
....................         PrintROMASCIIStringUART("CMD9 response R1 byte = "); 
....................         PrintRAMBytesUART((unsigned char*)&response, 1);  
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................     }     
012E8:  GOTO    12F8
....................     else 
....................     { 
....................         //Media failed to respond to the read CSD register operation. 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("Timeout occurred while processing CMD9 to read CSD register.\r\n"); 
....................         #endif 
....................          
....................         mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE; 
012EC:  MOV.B   #2,W0L
012EE:  MOV.B   W0L,D4E
....................         SD_CS = 1; 
012F0:  BSET.B  2F5.0
....................         return &mediaInformation; 
012F2:  MOV     #D4E,W4
012F4:  MOV     W4,0
012F6:  BRA     145A
....................     }     
....................  
....................    /* According to the simplified spec, section 7.2.6, the card will respond 
....................    with a standard response token, followed by a data block of 16 bytes 
....................    suffixed with a 16-bit CRC.*/ 
....................    index = 0; 
012F8:  CLR.B   F9D
....................    for (count = 0; count < 20u; count ++) 
012FA:  CLR.B   F9C
012FC:  MOV     F9C,W4
012FE:  CP.B    W4L,#14
01300:  BRA     C,1324
....................    { 
....................       CSDResponse[index] = MDD_SDSPI_ReadMedia(); 
01302:  MOV     F9C,W4
01304:  LSR     W4,#8,W4
01306:  MOV     #F88,W3
01308:  ADD     W4,W3,W5
0130A:  CALL    F4A
0130E:  MOV.B   W0L,[W5]
....................       index++;          
01310:  INC.B   0F9D
....................       /* Hopefully the first byte is the datatoken, however, some cards do 
....................       not send the response token before the CSD register.*/ 
....................       if((count == 0) && (CSDResponse[0] == DATA_START_TOKEN)) 
01312:  CP0.B   F9C
01314:  BRA     NZ,131E
01316:  MOV     F88,W4
01318:  XOR.B   #FE,W4L
0131A:  BRA     NZ,131E
....................       { 
....................          /* As the first byte was the datatoken, we can drop it. */ 
....................          index = 0; 
0131C:  CLR.B   F9D
....................       } 
0131E:  INC.B   0F9C
01320:  GOTO    12FC
....................    } 
....................  
....................     #ifdef __DEBUG_UART   
....................     PrintROMASCIIStringUART("CSD data structure contains: "); 
....................     PrintRAMBytesUART((unsigned char*)&CSDResponse, 20);  
....................     UARTSendLineFeedCarriageReturn(); 
....................     #endif 
....................      
....................  
....................  
....................    //Extract some fields from the response for computing the card capacity. 
....................    //Note: The structure format depends on if it is a CSD V1 or V2 device. 
....................    //Therefore, need to first determine version of the specs that the card  
....................    //is designed for, before interpreting the individual fields. 
....................  
....................    //------------------------------------------------------------- 
....................    //READ_BL_LEN: CSD Structure v1 cards always support 512 byte 
....................    //read and write block lengths.  Some v1 cards may optionally report 
....................    //READ_BL_LEN = 1024 or 2048 bytes (and therefore WRITE_BL_LEN also  
....................    //1024 or 2048).  However, even on these cards, 512 byte partial reads 
....................    //and 512 byte write are required to be supported. 
....................    //On CSD structure v2 cards, it is always required that READ_BL_LEN  
....................    //(and therefore WRITE_BL_LEN) be 512 bytes, and partial reads and 
....................    //writes are not allowed. 
....................    //Therefore, all cards support 512 byte reads/writes, but only a subset 
....................    //of cards support other sizes.  For best compatibility with all cards, 
....................    //and the simplest firmware design, it is therefore preferrable to  
....................    //simply ignore the READ_BL_LEN and WRITE_BL_LEN values altogether, 
....................    //and simply hardcode the read/write block size as 512 bytes. 
....................    //------------------------------------------------------------- 
....................    gMediaSectorSize = 512u; 
01324:  MOV     #200,W4
01326:  MOV     W4,D4A
....................    //mediaInformation.sectorSize = gMediaSectorSize; 
....................    mediaInformation.sectorSize = 512u; 
01328:  MOV     #200,W4
0132A:  MOV     W4,D50
....................    mediaInformation.validityFlags.bits.sectorSize = TRUE; 
0132C:  BSET.B  D4F.0
....................    //------------------------------------------------------------- 
....................  
....................    //Calculate the MDD_SDSPI_finalLBA (see SD card physical layer simplified spec 2.0, section 5.3.2). 
....................    //In USB mass storage applications, we will need this information to  
....................    //correctly respond to SCSI get capacity requests.  Note: method of computing  
....................    //MDD_SDSPI_finalLBA depends on CSD structure spec version (either v1 or v2). 
....................    if(CSDResponse[0] & 0xC0)   //Check CSD_STRUCTURE field for v2+ struct device 
0132E:  MOV.B   F88,W0L
01330:  AND     #C0,W0
01332:  CP0     W0
01334:  BRA     Z,1388
....................    { 
....................       //Must be a v2 device (or a reserved higher version, that doesn't currently exist) 
....................  
....................       //Extract the C_SIZE field from the response.  It is a 22-bit number in bit position 69:48.  This is different from v1.   
....................       //It spans bytes 7, 8, and 9 of the response. 
....................       c_size = (((DWORD)CSDResponse[7] & 0x3F) << 16) | ((WORD)CSDResponse[8] << 8) | CSDResponse[9]; 
01336:  MOV.B   F8F,W0L
01338:  MOV.B   W0L,W5L
0133A:  CLR.B   B
0133C:  MOV     #0,W6
0133E:  AND     #3F,W5
01340:  CLR     W6
01342:  MOV     W5,W6
01344:  MOV     #0,W5
01346:  MOV.B   F90,W0L
01348:  MOV.B   W0L,E
0134A:  CLR.B   F
0134C:  MOV.B   W7L,W0L
0134E:  MOV.B   W0L,1
01350:  CLR.B   W0
01352:  IOR      W5,  W0,W5
01354:  MOV.B   F91,W0L
01356:  CLR.B   1
01358:  MOV.B   W0L,F9E
0135A:  CLR.B   F9F
0135C:  MOV     W5,W0
0135E:  IOR     F9E
01360:  MOV     W6,FA0
....................        
....................       MDD_SDSPI_finalLBA = ((DWORD)(c_size + 1) * (WORD)(1024u)) - 1; //-1 on end is correction factor, since LBA = 0 is valid. 
01362:  MOV     F9E,W4
01364:  ADD     W4,#1,W4
01366:  MOV     W4,W5
01368:  MOV     FA0,W4
0136A:  ADDC    W4,#0,W4
0136C:  MOV     W4,W6
0136E:  MOV     #A,W4
01370:  INC     W4,W4
01372:  DEC     W4,W4
01374:  BRA     Z,137C
01376:  SL      W5,W5
01378:  RLC     W6,W6
0137A:  BRA     1372
0137C:  SUB     W5,#1,W0
0137E:  MOV     W0,D46
01380:  SUBB    W6,#0,W0
01382:  MOV     W0,D48
....................    } 
01384:  GOTO    143A
....................    else //if(CSDResponse[0] & 0xC0)   //Check CSD_STRUCTURE field for v1 struct device 
....................    { 
....................       //Must be a v1 device. 
....................       //Extract the C_SIZE field from the response.  It is a 12-bit number in bit position 73:62.   
....................       //Although it is only a 12-bit number, it spans bytes 6, 7, and 8, since it isn't byte aligned. 
....................       c_size = ((DWORD)CSDResponse[6] << 16) | ((WORD)CSDResponse[7] << 8) | CSDResponse[8];   //Get the bytes in the correct positions 
01388:  MOV.B   F8E,W0L
0138A:  MOV.B   W0L,A
0138C:  CLR.B   B
0138E:  MOV     #0,W6
01390:  MOV     W5,W6
01392:  MOV     #0,W5
01394:  MOV.B   F8F,W0L
01396:  MOV.B   W0L,W7L
01398:  CLR.B   F
0139A:  MOV.B   W7L,W0L
0139C:  MOV.B   W0L,1
0139E:  CLR.B   W0
013A0:  IOR      W5,  W0,W5
013A2:  MOV.B   F90,W0L
013A4:  MOV.B   W0L,F9E
013A6:  CLR.B   F9F
013A8:  MOV     W5,W0
013AA:  IOR     F9E
013AC:  MOV     W6,FA0
....................       c_size &= 0x0003FFC0;   //Clear all bits that aren't part of the C_SIZE 
013AE:  MOV     #FFC0,W0
013B0:  AND     F9E
013B2:  MOV     FA0,W0
013B4:  AND     W0,#3,W0
013B6:  MOV     W0,FA0
....................       c_size = c_size >> 6;   //Shift value down, so the 12-bit C_SIZE is properly right justified in the DWORD. 
013B8:  MOV     #6,W4
013BA:  INC     W4,W4
013BC:  DEC     W4,W4
013BE:  BRA     Z,13C6
013C0:  LSR     FA0
013C2:  RRC     F9E
013C4:  BRA     13BC
....................        
....................       //Extract the C_SIZE_MULT field from the response.  It is a 3-bit number in bit position 49:47. 
....................       c_size_mult = ((WORD)((CSDResponse[9] & 0x03) << 1)) | ((WORD)((CSDResponse[10] & 0x80) >> 7)); 
013C6:  MOV.B   F91,W0L
013C8:  CLR.B   1
013CA:  AND     W0,#3,W5
013CC:  SL      W5,#1,W5
013CE:  MOV     F92,W6
013D0:  AND     #80,W6
013D2:  LSR     W6,#7,W0
013D4:  MOV.B   W0L,FA2
013D6:  MOV     W5,W0
013D8:  IOR.B   FA2
....................  
....................         //Extract the BLOCK_LEN field from the response. It is a 4-bit number in bit position 83:80. 
....................         block_len = CSDResponse[5] & 0x0F; 
013DA:  MOV.B   F8D,W0L
013DC:  AND.B   W0L,#F,W0L
013DE:  MOV.B   W0L,FA3
....................  
....................         block_len = 1 << (block_len - 9); //-9 because we report the size in sectors of 512 bytes each 
013E0:  MOV     FA2,W4
013E2:  LSR     W4,#8,W4
013E4:  SUB     W4,#9,W0
013E6:  MOV     W0,W4
013E8:  MOV     #1,W0
013EA:  SL      W0,W4,W0
013EC:  MOV.B   W0L,FA3
013EE:  MOV.B   W0L,FA3
....................        
....................       //Calculate the MDD_SDSPI_finalLBA (see SD card physical layer simplified spec 2.0, section 5.3.2). 
....................       //In USB mass storage applications, we will need this information to  
....................       //correctly respond to SCSI get capacity requests (which will cause MDD_SDSPI_ReadCapacity() to get called). 
....................       MDD_SDSPI_finalLBA = ((DWORD)(c_size + 1) * (WORD)((WORD)1 << (c_size_mult + 2)) * block_len) - 1;   //-1 on end is correction factor, since LBA = 0 is valid.       
013F0:  MOV     F9E,W4
013F2:  ADD     W4,#1,W4
013F4:  MOV     W4,W5
013F6:  MOV     FA0,W4
013F8:  ADDC    W4,#0,W4
013FA:  MOV     W4,W6
013FC:  MOV     FA2,W4
013FE:  CLR.B   9
01400:  ADD     W4,#2,W4
01402:  MOV     W4,W0
01404:  MOV     W0,W4
01406:  MOV     #1,W0
01408:  SL      W0,W4,W0
0140A:  MOV     W6,W1
0140C:  MOV     W0,W2
0140E:  MOV     #0,W3
01410:  MOV     W5,W0
01412:  CALL    10CE
01416:  MOV     W0,W5
01418:  MOV     W1,W6
0141A:  MOV     W0,[W15++]
0141C:  MOV.B   FA3,W0L
0141E:  MOV.B   W0L,W2L
01420:  MOV     [--W15],W0
01422:  CLR.B   5
01424:  MOV     #0,W3
01426:  MOV     W5,W0
01428:  MOV     W6,W1
0142A:  CALL    10CE
0142E:  MOV     W0,W5
01430:  MOV     W1,W6
01432:  SUB     W5,#1,W0
01434:  MOV     W0,D46
01436:  SUBB    W6,#0,W0
01438:  MOV     W0,D48
....................    }    
....................  
....................     //Turn off CRC7 if we can, might be an invalid cmd on some cards (CMD59) 
....................     //Note: POR default for the media is normally with CRC checking off in SPI  
....................     //mode anyway, so this is typically redundant. 
....................     SendMMCCmd(CRC_ON_OFF,0x0); 
0143A:  MOV.B   #11,W0L
0143C:  MOV.B   W0L,10C2
0143E:  CLR     10C4
01440:  CLR     10C6
01442:  CALL    F58
....................  
....................     //Now set the block length to media sector size. It should be already set to this. 
....................     SendMMCCmd(SET_BLOCKLEN,gMediaSectorSize); 
01446:  MOV.B   #7,W0L
01448:  MOV.B   W0L,10C2
0144A:  PUSH    D4A
0144C:  POP     10C4
0144E:  CLR     10C6
01450:  CALL    F58
....................  
....................     //Deselect media while not actively accessing the card. 
....................     SD_CS = 1; 
01454:  BSET.B  2F5.0
....................  
....................     #ifdef __DEBUG_UART   
....................     PrintROMASCIIStringUART("Returning from MediaInitialize() function.\r\n"); 
....................     #endif 
....................  
....................  
....................     return &mediaInformation; 
01456:  MOV     #D4E,W4
01458:  MOV     W4,0
0145A:  MOV     [--W15],W7
0145C:  MOV     [--W15],W6
0145E:  MOV     [--W15],W5
01460:  RETURN  
.................... }//end MediaInitialize 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... ////////////////////// 
.................... ///                /// 
.................... /// Useful Defines /// 
.................... ///                /// 
.................... ////////////////////// 
....................  
.................... #define COMMAND_SIZE 10 
.................... #define NUM_COMMANDS 13 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
....................  
.................... //#USE PWM(OUTPUT=PIN_D1, FREQUENCY=250Hz, STREAM=PH_PWM)      //Pin 49 
.................... //#USE PWM(OUTPUT=PIN_D2, FREQUENCY=250Hz, STREAM=DO_PWM)    //Pin 48 
....................  
.................... char commands[NUM_COMMANDS][COMMAND_SIZE]= 
.................... { 
....................    "del",      //option1=filename.  delete file. 
....................    "make",     //option1=filename.  create an empty file, give error if file already exists 
....................    "append",   //option1=filename, option2=string.  append string to end of file 
....................    "cd",    //option1=new cwd.  change working directory.  / is root. 
....................    "dir",    //show files in directory 
....................    "cat",    //option1=filename.  display full contents in ascii 
....................    "tail",  //option1=filename.  display the last 20 lines of file. 
....................    "mkdir", //option1=dir.  create directory.  see 'cd' for rules on dir 
....................    "rmdir",  //option1=dir.  remove directory.  see 'cd' for rules on dir. 
....................    "format",   // option1=media size in bytes. formats the media. 
....................    "help",   // help! 
....................    "mount",  //mount filesystem. 
....................    "info"    //get and display FS_DISK_PROPERTIES 
.................... }; 
....................  
.................... int1 g_IsMounted = FALSE; 
....................  
.................... //////////////////////////////// 
.................... ///                          /// 
.................... /// Function Implementations /// 
.................... ///                          /// 
.................... //////////////////////////////// 
....................  
.................... /* 
.................... Summary: Finds a command from the global list of commands. 
.................... Param: A pointer to the command string. 
.................... Returns: The command number if the command is found in the command list. 
....................          0xFF if the command isn't found 
.................... */ 
.................... int FindCommand(char *cmd) 
*
05C90:  MOV     W5,[W15++]
05C92:  MOV     W6,[W15++]
.................... { 
....................    char buf[COMMAND_SIZE]; 
05C94:  CLR     F74
05C96:  CLR     F76
05C98:  CLR     F78
05C9A:  CLR     F7A
05C9C:  CLR     F7C
....................    int i; 
05C9E:  CLR     F7E
....................  
....................    for (i=0; i<NUM_COMMANDS; i++) 
05CA0:  CLR     F7E
05CA2:  MOV     F7E,W4
05CA4:  CP      W4,#D
05CA6:  BRA     GE,5CDC
....................    { 
....................       strcpy(buf, &commands[i][0]); 
05CA8:  MOV     F7E,W4
05CAA:  MUL.UU  W4,#A,W0
05CAC:  MOV     W0,W5
05CAE:  MOV     #DCC,W4
05CB0:  ADD     W5,W4,W6
05CB2:  MOV     #F74,W1
05CB4:  MOV     W6,W2
05CB6:  MOV.B   [W2++],[W1]
05CB8:  CP0.B   [W1++]
05CBA:  BTSS.B  42.1
05CBC:  BRA     5CB6
....................       if (stricmp(buf, cmd)==0) 
05CBE:  MOV     #F74,W4
05CC0:  MOV     W4,F82
05CC2:  PUSH    F72
05CC4:  POP     F84
05CC6:  CALL    5BEA
05CCA:  SE      W0,W5
05CCC:  CP0     W5
05CCE:  BRA     NZ,5CD6
....................          return(i); 
05CD0:  PUSH    F7E
05CD2:  POP     0
05CD4:  BRA     5CE0
05CD6:  INC     0F7E
05CD8:  GOTO    5CA2
....................    } 
....................  
....................    return(0xFF); 
05CDC:  MOV     #FF,W4
05CDE:  MOV     W4,0
05CE0:  MOV     [--W15],W6
05CE2:  MOV     [--W15],W5
05CE4:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Displays the current working directory. 
.................... Param: None. 
.................... Returns: None. 
.................... */ 
.................... void DisplayPrompt(void) 
.................... { 
....................    char scr[65], *p; 
*
059A4:  CLR     F72
059A6:  CLR     F74
059A8:  CLR     F76
059AA:  CLR     F78
059AC:  CLR     F7A
059AE:  CLR     F7C
059B0:  CLR     F7E
059B2:  CLR     F80
059B4:  CLR     F82
059B6:  CLR     F84
059B8:  CLR     F86
059BA:  CLR     F88
059BC:  CLR     F8A
059BE:  CLR     F8C
059C0:  CLR     F8E
059C2:  CLR     F90
059C4:  CLR     F92
059C6:  CLR     F94
059C8:  CLR     F96
059CA:  CLR     F98
059CC:  CLR     F9A
059CE:  CLR     F9C
059D0:  CLR     F9E
059D2:  CLR     FA0
059D4:  CLR     FA2
059D6:  CLR     FA4
059D8:  CLR     FA6
059DA:  CLR     FA8
059DC:  CLR     FAA
059DE:  CLR     FAC
059E0:  CLR     FAE
059E2:  CLR     FB0
059E4:  CLR.B   FB2
059E6:  CLR     FB4
....................  
....................    if (g_IsMounted) 
059E8:  BTSS.B  800.3
059EA:  BRA     5A24
....................    { 
....................       p = FSgetcwd(scr, sizeof(scr)-1); 
059EC:  MOV     #F72,W4
059EE:  MOV     W4,FB6
059F0:  MOV     #40,W4
059F2:  MOV     W4,FB8
059F4:  CALL    55BA
059F8:  MOV     W0,FB4
....................       if (!p) 
059FA:  CP0     FB4
059FC:  BRA     NZ,5A20
....................       { 
....................          sprintf(scr, "!!!ERROR!!!"); 
059FE:  MOV     #F72,W4
05A00:  MOV     W4,E4E
05A02:  MOV     #0,W1
05A04:  MOV     W1,W0
05A06:  CLR.B   1
05A08:  CALL    210
05A0C:  INC     W1,W1
05A0E:  MOV     W1,[W15++]
05A10:  MOV     W0,[W15++]
05A12:  MOV     [--W15],W0
05A14:  CALL    2592
05A18:  MOV     [--W15],W1
05A1A:  MOV     #A,W0
05A1C:  CPSGT   W1,W0
05A1E:  BRA     5A04
....................       } 
....................    } 
05A20:  GOTO    5A46
....................    else 
....................    { 
....................       sprintf(scr, "!!!NOT MOUNTED!!!"); 
05A24:  MOV     #F72,W4
05A26:  MOV     W4,E4E
05A28:  MOV     #0,W1
05A2A:  MOV     W1,W0
05A2C:  CLR.B   1
05A2E:  CALL    228
05A32:  INC     W1,W1
05A34:  MOV     W1,[W15++]
05A36:  MOV     W0,[W15++]
05A38:  MOV     [--W15],W0
05A3A:  CALL    2592
05A3E:  MOV     [--W15],W1
05A40:  MOV     #10,W0
05A42:  CPSGT   W1,W0
05A44:  BRA     5A2A
....................    } 
....................  
....................    printf("\r\n\n%s> ", scr); 
05A46:  BTSC.B  223.1
05A48:  BRA     5A46
05A4A:  MOV     #D,W4
05A4C:  MOV     W4,224
05A4E:  BTSC.B  223.1
05A50:  BRA     5A4E
05A52:  MOV     #A,W4
05A54:  MOV     W4,224
05A56:  BTSC.B  223.1
05A58:  BRA     5A56
05A5A:  MOV     #A,W4
05A5C:  MOV     W4,224
05A5E:  MOV     #F72,W1
05A60:  CP0.B   [W1]
05A62:  BRA     Z,5A72
05A64:  BTSC.B  223.1
05A66:  BRA     5A64
05A68:  MOV.B   [W1+#0],W0L
05A6A:  MOV.B   W0L,224
05A6C:  CLR.B   225
05A6E:  INC     W1,W1
05A70:  BRA     5A60
05A72:  BTSC.B  223.1
05A74:  BRA     5A72
05A76:  MOV     #3E,W4
05A78:  MOV     W4,224
05A7A:  BTSC.B  223.1
05A7C:  BRA     5A7A
05A7E:  MOV     #20,W4
05A80:  MOV     W4,224
05A82:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Deletes a file. 
.................... Param: The full path of the file to delete. 
.................... Returns: None. 
.................... */ 
.................... void DeleteFile(char *fileName) 
.................... { 
....................    if (!g_IsMounted) 
*
05DF0:  BTSC.B  800.3
05DF2:  BRA     5E0E
....................    { 
....................       printf("\r\nMedia not mounted, not going to delete file!"); 
05DF4:  MOV     #0,W1
05DF6:  MOV     W1,W0
05DF8:  CLR.B   1
05DFA:  CALL    246
05DFE:  INC     W1,W1
05E00:  BTSC.B  223.1
05E02:  BRA     5E00
05E04:  MOV     W0,224
05E06:  MOV     #2D,W0
05E08:  CPSGT   W1,W0
05E0A:  BRA     5DF6
....................       return; 
05E0C:  BRA     5E88
....................    } 
....................  
....................    printf("\r\nDeleting '%s': ", fileName); 
05E0E:  MOV     #0,W1
05E10:  MOV     W1,W0
05E12:  CLR.B   1
05E14:  CALL    282
05E18:  INC     W1,W1
05E1A:  BTSC.B  223.1
05E1C:  BRA     5E1A
05E1E:  MOV     W0,224
05E20:  MOV     #B,W0
05E22:  CPSGT   W1,W0
05E24:  BRA     5E10
05E26:  MOV     F72,W1
05E28:  CP0.B   [W1]
05E2A:  BRA     Z,5E3A
05E2C:  BTSC.B  223.1
05E2E:  BRA     5E2C
05E30:  MOV.B   [W1+#0],W0L
05E32:  MOV.B   W0L,224
05E34:  CLR.B   225
05E36:  INC     W1,W1
05E38:  BRA     5E28
05E3A:  BTSC.B  223.1
05E3C:  BRA     5E3A
05E3E:  MOV     #27,W4
05E40:  MOV     W4,224
05E42:  BTSC.B  223.1
05E44:  BRA     5E42
05E46:  MOV     #3A,W4
05E48:  MOV     W4,224
05E4A:  BTSC.B  223.1
05E4C:  BRA     5E4A
05E4E:  MOV     #20,W4
05E50:  MOV     W4,224
....................    if(FSremove(fileName)) 
05E52:  PUSH    F72
05E54:  POP     F76
05E56:  CALL    5CE6
05E5A:  CP0     W0
05E5C:  BRA     Z,5E78
....................    { 
....................       printf("Error deleting file"); 
05E5E:  MOV     #0,W1
05E60:  MOV     W1,W0
05E62:  CLR.B   1
05E64:  CALL    2A0
05E68:  INC     W1,W1
05E6A:  BTSC.B  223.1
05E6C:  BRA     5E6A
05E6E:  MOV     W0,224
05E70:  MOV     #12,W0
05E72:  CPSGT   W1,W0
05E74:  BRA     5E60
....................       return; 
05E76:  BRA     5E88
....................    } 
....................    printf("OK"); 
05E78:  BTSC.B  223.1
05E7A:  BRA     5E78
05E7C:  MOV     #4F,W4
05E7E:  MOV     W4,224
05E80:  BTSC.B  223.1
05E82:  BRA     5E80
05E84:  MOV     #4B,W4
05E86:  MOV     W4,224
05E88:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Creates a file. 
.................... Param: The full path of the file to create. 
.................... Returns: None. 
.................... Example Usage: \> make "Log.txt" 
.................... */ 
.................... void MakeFile(char *fileName) 
05E8A:  CLR     F74
.................... { 
....................    FSFILE *f = NULL; 
....................    int ret; 
05E8C:  CLR     F76
....................  
....................    if (!g_IsMounted) 
05E8E:  BTSC.B  800.3
05E90:  BRA     5EAC
....................    { 
....................       printf("\r\nMedia not mounted, not going to make file!"); 
05E92:  MOV     #0,W1
05E94:  MOV     W1,W0
05E96:  CLR.B   1
05E98:  CALL    2C0
05E9C:  INC     W1,W1
05E9E:  BTSC.B  223.1
05EA0:  BRA     5E9E
05EA2:  MOV     W0,224
05EA4:  MOV     #2B,W0
05EA6:  CPSGT   W1,W0
05EA8:  BRA     5E94
....................       return; 
05EAA:  BRA     5F62
....................    } 
....................  
....................  //  printf("\r\nMaking file '%s': ", fileName); 
....................  
....................    f = FSfopen (fileName, "w"); 
05EAC:  MOV     #2,W3
05EAE:  MOV     #0,W2
05EB0:  MOV     #F78,W1
05EB2:  MOV     W3,[W15++]
05EB4:  MOV     W2,W0
05EB6:  CALL    2FA
05EBA:  MOV     [--W15],W3
05EBC:  MOV.B   W0L,[W1++]
05EBE:  INC     W2,W2
05EC0:  DEC     W3,W3
05EC2:  BTSS.B  42.1
05EC4:  BRA     5EB2
05EC6:  PUSH    F72
05EC8:  POP     FC2
05ECA:  MOV     #F78,W4
05ECC:  MOV     W4,FC4
05ECE:  CALL    4A26
05ED2:  MOV     W0,F74
....................    if (!f) 
05ED4:  CP0     F74
05ED6:  BRA     NZ,5F06
....................    { 
....................       printf("Error (open error %X)", FSerrno); 
05ED8:  MOV     #0,W1
05EDA:  MOV     W1,W0
05EDC:  CLR.B   1
05EDE:  CALL    308
05EE2:  INC     W1,W1
05EE4:  BTSC.B  223.1
05EE6:  BRA     5EE4
05EE8:  MOV     W0,224
05EEA:  MOV     #11,W0
05EEC:  CPSGT   W1,W0
05EEE:  BRA     5EDA
05EF0:  MOV.B   857,W0L
05EF2:  CLR.B   1
05EF4:  MOV     #704,W1
05EF6:  CALL    4E3C
05EFA:  BTSC.B  223.1
05EFC:  BRA     5EFA
05EFE:  MOV     #29,W4
05F00:  MOV     W4,224
....................    } 
05F02:  GOTO    5F62
....................    else 
....................    { 
....................       ret = FSfclose(f); 
05F06:  PUSH    F74
05F08:  POP     FC2
05F0A:  CALL    5142
05F0E:  MOV     W0,F76
....................       if (ret) 
05F10:  CP0     F76
05F12:  BRA     Z,5F52
....................       { 
....................          printf("Error (close error %X %X)", ret, FSerrno); 
05F14:  MOV     #0,W1
05F16:  MOV     W1,W0
05F18:  CLR.B   1
05F1A:  CALL    32A
05F1E:  INC     W1,W1
05F20:  BTSC.B  223.1
05F22:  BRA     5F20
05F24:  MOV     W0,224
05F26:  MOV     #12,W0
05F28:  CPSGT   W1,W0
05F2A:  BRA     5F16
05F2C:  MOV     F76,W0
05F2E:  MOV     #704,W1
05F30:  CALL    4E3C
05F34:  BTSC.B  223.1
05F36:  BRA     5F34
05F38:  MOV     #20,W4
05F3A:  MOV     W4,224
05F3C:  MOV.B   857,W0L
05F3E:  CLR.B   1
05F40:  MOV     #704,W1
05F42:  CALL    4E3C
05F46:  BTSC.B  223.1
05F48:  BRA     5F46
05F4A:  MOV     #29,W4
05F4C:  MOV     W4,224
....................       } 
05F4E:  GOTO    5F62
....................       else 
....................       { 
....................          printf("OK"); 
05F52:  BTSC.B  223.1
05F54:  BRA     5F52
05F56:  MOV     #4F,W4
05F58:  MOV     W4,224
05F5A:  BTSC.B  223.1
05F5C:  BRA     5F5A
05F5E:  MOV     #4B,W4
05F60:  MOV     W4,224
....................       } 
....................    } 
05F62:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Append a string to a file. 
.................... Param: The full path of the file to append to. 
.................... Param: A pointer to a string to append to the file. 
.................... Returns: None. 
.................... Example Usage: \> append "Log.txt" "This will be appended to the end of Log.txt" 
.................... Note: A "\r\n" will be appended after the appendString. 
.................... */ 
.................... void AppendFile(char *fileName, char *appendString) 
*
05274:  MOV     W5,[W15++]
.................... { 
....................    FSFILE* f; 
05276:  CLR     F76
....................    char newLine[]="\r\n"; 
05278:  MOV     #A0D,W4
0527A:  MOV     W4,F78
0527C:  CLR.B   F7A
....................    int ret; 
0527E:  CLR     F7C
....................  
....................    if (!g_IsMounted) 
05280:  BTSC.B  800.3
05282:  BRA     529E
....................    { 
....................       printf("\r\nMedia not mounted, not going to append file!"); 
05284:  MOV     #0,W1
05286:  MOV     W1,W0
05288:  CLR.B   1
0528A:  CALL    350
0528E:  INC     W1,W1
05290:  BTSC.B  223.1
05292:  BRA     5290
05294:  MOV     W0,224
05296:  MOV     #2D,W0
05298:  CPSGT   W1,W0
0529A:  BRA     5286
....................       return; 
0529C:  BRA     53F8
....................    } 
....................  
....................    printf("\r\nAppending '%s' to '%s': ", appendString, fileName); 
0529E:  MOV     #0,W1
052A0:  MOV     W1,W0
052A2:  CLR.B   1
052A4:  CALL    38C
052A8:  INC     W1,W1
052AA:  BTSC.B  223.1
052AC:  BRA     52AA
052AE:  MOV     W0,224
052B0:  MOV     #C,W0
052B2:  CPSGT   W1,W0
052B4:  BRA     52A0
052B6:  MOV     F74,W1
052B8:  CP0.B   [W1]
052BA:  BRA     Z,52CA
052BC:  BTSC.B  223.1
052BE:  BRA     52BC
052C0:  MOV.B   [W1+#0],W0L
052C2:  MOV.B   W0L,224
052C4:  CLR.B   225
052C6:  INC     W1,W1
052C8:  BRA     52B8
052CA:  MOV     #F,W1
052CC:  MOV     W1,W0
052CE:  CLR.B   1
052D0:  CALL    38C
052D4:  INC     W1,W1
052D6:  BTSC.B  223.1
052D8:  BRA     52D6
052DA:  MOV     W0,224
052DC:  MOV     #14,W0
052DE:  CPSGT   W1,W0
052E0:  BRA     52CC
052E2:  MOV     F72,W1
052E4:  CP0.B   [W1]
052E6:  BRA     Z,52F6
052E8:  BTSC.B  223.1
052EA:  BRA     52E8
052EC:  MOV.B   [W1+#0],W0L
052EE:  MOV.B   W0L,224
052F0:  CLR.B   225
052F2:  INC     W1,W1
052F4:  BRA     52E4
052F6:  BTSC.B  223.1
052F8:  BRA     52F6
052FA:  MOV     #27,W4
052FC:  MOV     W4,224
052FE:  BTSC.B  223.1
05300:  BRA     52FE
05302:  MOV     #3A,W4
05304:  MOV     W4,224
05306:  BTSC.B  223.1
05308:  BRA     5306
0530A:  MOV     #20,W4
0530C:  MOV     W4,224
....................    f = FSfopen(fileName, "a"); 
0530E:  MOV     #2,W3
05310:  MOV     #0,W2
05312:  MOV     #F7E,W1
05314:  MOV     W3,[W15++]
05316:  MOV     W2,W0
05318:  CALL    3B4
0531C:  MOV     [--W15],W3
0531E:  MOV.B   W0L,[W1++]
05320:  INC     W2,W2
05322:  DEC     W3,W3
05324:  BTSS.B  42.1
05326:  BRA     5314
05328:  PUSH    F72
0532A:  POP     FC2
0532C:  MOV     #F7E,W4
0532E:  MOV     W4,FC4
05330:  CALL    4A26
05334:  MOV     W0,F76
....................    if(!f) 
05336:  CP0     F76
05338:  BRA     NZ,5366
....................    { 
....................       printf("Error (%X)", FSerrno); 
0533A:  MOV     #0,W1
0533C:  MOV     W1,W0
0533E:  CLR.B   1
05340:  CALL    3C2
05344:  INC     W1,W1
05346:  BTSC.B  223.1
05348:  BRA     5346
0534A:  MOV     W0,224
0534C:  MOV     #6,W0
0534E:  CPSGT   W1,W0
05350:  BRA     533C
05352:  MOV.B   857,W0L
05354:  CLR.B   1
05356:  MOV     #704,W1
05358:  CALL    4E3C
0535C:  BTSC.B  223.1
0535E:  BRA     535C
05360:  MOV     #29,W4
05362:  MOV     W4,224
....................       return; 
05364:  BRA     53F8
....................    } 
....................  
....................    FSfwrite(appendString, sizeof(char), strlen(appendString), f); 
05366:  PUSH    F74
05368:  POP     1036
0536A:  CALL    25A8
0536E:  MOV     W0,W5
05370:  MOV     #1,W4
05372:  MOV     W4,F8A
05374:  PUSH    F74
05376:  POP     F88
05378:  MOV     W5,F8C
0537A:  PUSH    F76
0537C:  POP     F8E
0537E:  CALL    4E70
....................    FSfwrite(newLine, sizeof(char), strlen(newLine), f); 
05382:  MOV     #F78,W4
05384:  MOV     W4,1036
05386:  CALL    25A8
0538A:  MOV     W0,W5
0538C:  MOV     #1,W4
0538E:  MOV     W4,F8A
05390:  MOV     #F78,W4
05392:  MOV     W4,F88
05394:  MOV     W5,F8C
05396:  PUSH    F76
05398:  POP     F8E
0539A:  CALL    4E70
....................  
....................    ret = FSfclose(f); 
0539E:  PUSH    F76
053A0:  POP     FC2
053A2:  CALL    5142
053A6:  MOV     W0,F7C
....................    if(ret) 
053A8:  CP0     F7C
053AA:  BRA     Z,53E8
....................    { 
....................       printf("Error (%X %X)", ret, FSerrno); 
053AC:  MOV     #0,W1
053AE:  MOV     W1,W0
053B0:  CLR.B   1
053B2:  CALL    3DA
053B6:  INC     W1,W1
053B8:  BTSC.B  223.1
053BA:  BRA     53B8
053BC:  MOV     W0,224
053BE:  MOV     #6,W0
053C0:  CPSGT   W1,W0
053C2:  BRA     53AE
053C4:  MOV     F7C,W0
053C6:  MOV     #704,W1
053C8:  CALL    4E3C
053CC:  BTSC.B  223.1
053CE:  BRA     53CC
053D0:  MOV     #20,W4
053D2:  MOV     W4,224
053D4:  MOV.B   857,W0L
053D6:  CLR.B   1
053D8:  MOV     #704,W1
053DA:  CALL    4E3C
053DE:  BTSC.B  223.1
053E0:  BRA     53DE
053E2:  MOV     #29,W4
053E4:  MOV     W4,224
....................       return; 
053E6:  BRA     53F8
....................    } 
....................    printf("OK"); 
053E8:  BTSC.B  223.1
053EA:  BRA     53E8
053EC:  MOV     #4F,W4
053EE:  MOV     W4,224
053F0:  BTSC.B  223.1
053F2:  BRA     53F0
053F4:  MOV     #4B,W4
053F6:  MOV     W4,224
053F8:  MOV     [--W15],W5
053FA:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Change the working directory. 
.................... Param: The new working directory to switch to. 
.................... Returns: None. 
.................... Example Usage: \> cd ftp/     -> /ftp/ 
....................                \ftp\> cd files/  -> /ftp/files/ 
....................                \ftp\files> cd..  -> /ftp/ 
....................                \ftp\> cd ..      -> / 
....................                \> cd /ftp/files/ -> /ftp/files/ 
....................  
.................... Note: Changing the directory to .. will go up a directory. 
.................... */ 
.................... void ChangeDirectory(char *newCWD) 
.................... { 
....................    if (!g_IsMounted) 
*
0652A:  BTSC.B  800.3
0652C:  BRA     6548
....................    { 
....................       printf("\r\nMedia not mounted, not going to change directory!"); 
0652E:  MOV     #0,W1
06530:  MOV     W1,W0
06532:  CLR.B   1
06534:  CALL    3F4
06538:  INC     W1,W1
0653A:  BTSC.B  223.1
0653C:  BRA     653A
0653E:  MOV     W0,224
06540:  MOV     #32,W0
06542:  CPSGT   W1,W0
06544:  BRA     6530
....................       return; 
06546:  BRA     656C
....................    } 
....................  
....................    if (FSchdir(newCWD)) 
06548:  PUSH    F72
0654A:  POP     FAE
0654C:  CALL    651A
06550:  CP0     W0
06552:  BRA     Z,656C
....................    { 
....................       printf("\r\nError changing directory"); 
06554:  MOV     #0,W1
06556:  MOV     W1,W0
06558:  CLR.B   1
0655A:  CALL    434
0655E:  INC     W1,W1
06560:  BTSC.B  223.1
06562:  BRA     6560
06564:  MOV     W0,224
06566:  MOV     #19,W0
06568:  CPSGT   W1,W0
0656A:  BRA     6556
....................    } 
0656C:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Display the contents of the working directory. 
.................... Param: The full path of the directory contents to display. 
.................... Returns: None. 
.................... Example Usage: /> dir 
.................... */ 
.................... void DisplayDirectory(void) 
*
06AD8:  MOV     W5,[W15++]
.................... { 
....................    SearchRec s; 
06ADA:  CLR     F72
06ADC:  CLR     F74
06ADE:  CLR     F76
06AE0:  CLR     F78
06AE2:  CLR     F7A
06AE4:  CLR     F7C
06AE6:  CLR     F7E
06AE8:  CLR     F80
06AEA:  CLR     F82
06AEC:  CLR     F84
06AEE:  CLR     F86
06AF0:  CLR     F88
06AF2:  CLR     F8A
06AF4:  CLR     F8C
06AF6:  CLR     F8E
06AF8:  CLR     F90
06AFA:  CLR     F92
06AFC:  CLR     F94
06AFE:  CLR     F96
06B00:  CLR     F98
06B02:  CLR     F9A
06B04:  CLR     F9C
....................    int ret; 
06B06:  CLR     F9E
....................    char str[20]; 
06B08:  CLR     FA0
06B0A:  CLR     FA2
06B0C:  CLR     FA4
06B0E:  CLR     FA6
06B10:  CLR     FA8
06B12:  CLR     FAA
06B14:  CLR     FAC
06B16:  CLR     FAE
06B18:  CLR     FB0
06B1A:  CLR     FB2
....................  
....................    if (!g_IsMounted) 
06B1C:  BTSC.B  800.3
06B1E:  BRA     6B3A
....................    { 
....................       printf("\r\nMedia not mounted, not going to display directory!"); 
06B20:  MOV     #0,W1
06B22:  MOV     W1,W0
06B24:  CLR.B   1
06B26:  CALL    45C
06B2A:  INC     W1,W1
06B2C:  BTSC.B  223.1
06B2E:  BRA     6B2C
06B30:  MOV     W0,224
06B32:  MOV     #33,W0
06B34:  CPSGT   W1,W0
06B36:  BRA     6B22
....................       return; 
06B38:  BRA     6C7C
....................    } 
....................  
....................    memset(&s, 0x00, sizeof(s)); 
06B3A:  MOV     #F72,W1
06B3C:  MOV     #0,W2
06B3E:  REPEAT  #2B
06B40:  CLR.B   [W1++]
....................  
....................    ret = FindFirst("*.*", ATTR_MASK, &s); 
06B42:  MOV     #4,W3
06B44:  MOV     #0,W2
06B46:  MOV     #FB4,W1
06B48:  MOV     W3,[W15++]
06B4A:  MOV     W2,W0
06B4C:  CALL    49C
06B50:  MOV     [--W15],W3
06B52:  MOV.B   W0L,[W1++]
06B54:  INC     W2,W2
06B56:  DEC     W3,W3
06B58:  BTSS.B  42.1
06B5A:  BRA     6B48
06B5C:  MOV     #FB4,W4
06B5E:  MOV     W4,FB8
06B60:  MOV     #3F,W4
06B62:  MOV     W4,FBA
06B64:  MOV     #F72,W4
06B66:  MOV     W4,FBC
06B68:  CALL    656E
06B6C:  MOV     W0,F9E
....................  
....................    for(;;) 
....................    { 
....................       if (ret != 0) 
06B6E:  CP0     F9E
06B70:  BRA     Z,6BC0
....................       { 
....................          printf("\r\n\nDirectory search completed"); 
06B72:  MOV     #0,W1
06B74:  MOV     W1,W0
06B76:  CLR.B   1
06B78:  CALL    4AC
06B7C:  INC     W1,W1
06B7E:  BTSC.B  223.1
06B80:  BRA     6B7E
06B82:  MOV     W0,224
06B84:  MOV     #1C,W0
06B86:  CPSGT   W1,W0
06B88:  BRA     6B74
....................  
....................          if (FSerrno != CE_FILE_NOT_FOUND) 
06B8A:  MOV     856,W4
06B8C:  LSR     W4,#8,W4
06B8E:  CP.B    W4L,#B
06B90:  BRA     Z,6BBC
....................          { 
....................             printf(" (FSerrno = %u)", FSerrno); 
06B92:  MOV     #0,W1
06B94:  MOV     W1,W0
06B96:  CLR.B   1
06B98:  CALL    4D6
06B9C:  INC     W1,W1
06B9E:  BTSC.B  223.1
06BA0:  BRA     6B9E
06BA2:  MOV     W0,224
06BA4:  MOV     #B,W0
06BA6:  CPSGT   W1,W0
06BA8:  BRA     6B94
06BAA:  MOV.B   857,W0L
06BAC:  CLR.B   1
06BAE:  MOV     #0,W4
06BB0:  CALL    23D6
06BB4:  BTSC.B  223.1
06BB6:  BRA     6BB4
06BB8:  MOV     #29,W4
06BBA:  MOV     W4,224
....................          } 
....................          break; 
06BBC:  GOTO    6C7C
....................       } 
....................  
....................       if ((s.attributes & ATTR_VOLUME) != ATTR_VOLUME) 
06BC0:  MOV.B   F7F,W0L
06BC2:  CLR.B   1
06BC4:  AND     W0,#8,W5
06BC6:  CP      W5,#8
06BC8:  BRA     Z,6C6E
....................       { 
....................          if ((s.attributes & ATTR_DIRECTORY) == ATTR_DIRECTORY) 
06BCA:  MOV.B   F7F,W0L
06BCC:  CLR.B   1
06BCE:  AND     W0,#10,W5
06BD0:  CP      W5,#10
06BD2:  BRA     NZ,6BFA
....................             sprintf(str, "<DIR>  "); 
06BD4:  MOV     #FA0,W4
06BD6:  MOV     W4,E4E
06BD8:  MOV     #0,W1
06BDA:  MOV     W1,W0
06BDC:  CLR.B   1
06BDE:  CALL    4F2
06BE2:  INC     W1,W1
06BE4:  MOV     W1,[W15++]
06BE6:  MOV     W0,[W15++]
06BE8:  MOV     [--W15],W0
06BEA:  CALL    2592
06BEE:  MOV     [--W15],W1
06BF0:  MOV     #6,W0
06BF2:  CPSGT   W1,W0
06BF4:  BRA     6BDA
06BF6:  GOTO    6C1C
....................          else 
....................             sprintf(str, "       "); 
06BFA:  MOV     #FA0,W4
06BFC:  MOV     W4,E4E
06BFE:  MOV     #0,W1
06C00:  MOV     W1,W0
06C02:  CLR.B   1
06C04:  CALL    506
06C08:  INC     W1,W1
06C0A:  MOV     W1,[W15++]
06C0C:  MOV     W0,[W15++]
06C0E:  MOV     [--W15],W0
06C10:  CALL    2592
06C14:  MOV     [--W15],W1
06C16:  MOV     #6,W0
06C18:  CPSGT   W1,W0
06C1A:  BRA     6C00
....................  
....................          printf("\r\n%lu\t\t%s%s", s.filesize, str, s.filename); 
06C1C:  BTSC.B  223.1
06C1E:  BRA     6C1C
06C20:  MOV     #D,W4
06C22:  MOV     W4,224
06C24:  BTSC.B  223.1
06C26:  BRA     6C24
06C28:  MOV     #A,W4
06C2A:  MOV     W4,224
06C2C:  MOV     F80,W0
06C2E:  MOV     F82,W1
06C30:  MOV     #0,W4
06C32:  CALL    230E
06C36:  BTSC.B  223.1
06C38:  BRA     6C36
06C3A:  MOV     #9,W4
06C3C:  MOV     W4,224
06C3E:  BTSC.B  223.1
06C40:  BRA     6C3E
06C42:  MOV     #9,W4
06C44:  MOV     W4,224
06C46:  MOV     #FA0,W1
06C48:  CP0.B   [W1]
06C4A:  BRA     Z,6C5A
06C4C:  BTSC.B  223.1
06C4E:  BRA     6C4C
06C50:  MOV.B   [W1+#0],W0L
06C52:  MOV.B   W0L,224
06C54:  CLR.B   225
06C56:  INC     W1,W1
06C58:  BRA     6C48
06C5A:  MOV     #F72,W1
06C5C:  CP0.B   [W1]
06C5E:  BRA     Z,6C6E
06C60:  BTSC.B  223.1
06C62:  BRA     6C60
06C64:  MOV.B   [W1+#0],W0L
06C66:  MOV.B   W0L,224
06C68:  CLR.B   225
06C6A:  INC     W1,W1
06C6C:  BRA     6C5C
....................       } 
....................  
....................       ret = FindNext(&s); 
06C6E:  MOV     #F72,W4
06C70:  MOV     W4,FB8
06C72:  CALL    6850
06C76:  MOV     W0,F9E
06C78:  GOTO    6B6E
....................    } 
06C7C:  MOV     [--W15],W5
06C7E:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Create a directory. 
.................... Param: The full path of the directory to create. 
.................... Returns: None. 
.................... Example Usage: /> mkdir "Backlog" 
.................... */ 
.................... void MakeDirectory(char *dir) 
.................... { 
....................    if (!g_IsMounted) 
*
07698:  BTSC.B  800.3
0769A:  BRA     76B6
....................    { 
....................       printf("\r\nMedia not mounted, not going to make directory!"); 
0769C:  MOV     #0,W1
0769E:  MOV     W1,W0
076A0:  CLR.B   1
076A2:  CALL    51A
076A6:  INC     W1,W1
076A8:  BTSC.B  223.1
076AA:  BRA     76A8
076AC:  MOV     W0,224
076AE:  MOV     #30,W0
076B0:  CPSGT   W1,W0
076B2:  BRA     769E
....................       return; 
076B4:  BRA     7742
....................    } 
....................  
....................    printf("\r\nMaking directory '%s': ", dir); 
076B6:  MOV     #0,W1
076B8:  MOV     W1,W0
076BA:  CLR.B   1
076BC:  CALL    558
076C0:  INC     W1,W1
076C2:  BTSC.B  223.1
076C4:  BRA     76C2
076C6:  MOV     W0,224
076C8:  MOV     #13,W0
076CA:  CPSGT   W1,W0
076CC:  BRA     76B8
076CE:  MOV     F72,W1
076D0:  CP0.B   [W1]
076D2:  BRA     Z,76E2
076D4:  BTSC.B  223.1
076D6:  BRA     76D4
076D8:  MOV.B   [W1+#0],W0L
076DA:  MOV.B   W0L,224
076DC:  CLR.B   225
076DE:  INC     W1,W1
076E0:  BRA     76D0
076E2:  BTSC.B  223.1
076E4:  BRA     76E2
076E6:  MOV     #27,W4
076E8:  MOV     W4,224
076EA:  BTSC.B  223.1
076EC:  BRA     76EA
076EE:  MOV     #3A,W4
076F0:  MOV     W4,224
076F2:  BTSC.B  223.1
076F4:  BRA     76F2
076F6:  MOV     #20,W4
076F8:  MOV     W4,224
....................  
....................    if(FSmkdir(dir)) 
076FA:  PUSH    F72
076FC:  POP     F76
076FE:  CALL    7688
07702:  CP0     W0
07704:  BRA     Z,7732
....................    { 
....................       printf("Error creating directory (FSerrno = %u)", FSerrno); 
07706:  MOV     #0,W1
07708:  MOV     W1,W0
0770A:  CLR.B   1
0770C:  CALL    57E
07710:  INC     W1,W1
07712:  BTSC.B  223.1
07714:  BRA     7712
07716:  MOV     W0,224
07718:  MOV     #23,W0
0771A:  CPSGT   W1,W0
0771C:  BRA     7708
0771E:  MOV.B   857,W0L
07720:  CLR.B   1
07722:  MOV     #0,W4
07724:  CALL    23D6
07728:  BTSC.B  223.1
0772A:  BRA     7728
0772C:  MOV     #29,W4
0772E:  MOV     W4,224
....................       return; 
07730:  BRA     7742
....................    } 
....................    printf("OK"); 
07732:  BTSC.B  223.1
07734:  BRA     7732
07736:  MOV     #4F,W4
07738:  MOV     W4,224
0773A:  BTSC.B  223.1
0773C:  BRA     773A
0773E:  MOV     #4B,W4
07740:  MOV     W4,224
07742:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Remove a directory. 
.................... Param: The full path of the directory to remove. 
.................... Returns: None. 
.................... Example Usage: /> rmdir "Backlog" 
.................... Note: The directory needs to be empty in order for this command to work. 
.................... */ 
.................... void RemoveDirectory(char *dir) 
.................... { 
....................    if (!g_IsMounted) 
*
07ECA:  BTSC.B  800.3
07ECC:  BRA     7EE8
....................    { 
....................       printf("\r\nMedia not mounted, not going to remove directory!"); 
07ECE:  MOV     #0,W1
07ED0:  MOV     W1,W0
07ED2:  CLR.B   1
07ED4:  CALL    5B2
07ED8:  INC     W1,W1
07EDA:  BTSC.B  223.1
07EDC:  BRA     7EDA
07EDE:  MOV     W0,224
07EE0:  MOV     #32,W0
07EE2:  CPSGT   W1,W0
07EE4:  BRA     7ED0
....................       return; 
07EE6:  BRA     7F64
....................    } 
....................  
....................    printf("\r\nRemoving directory '%s': ", dir); 
07EE8:  MOV     #0,W1
07EEA:  MOV     W1,W0
07EEC:  CLR.B   1
07EEE:  CALL    5F2
07EF2:  INC     W1,W1
07EF4:  BTSC.B  223.1
07EF6:  BRA     7EF4
07EF8:  MOV     W0,224
07EFA:  MOV     #15,W0
07EFC:  CPSGT   W1,W0
07EFE:  BRA     7EEA
07F00:  MOV     F72,W1
07F02:  CP0.B   [W1]
07F04:  BRA     Z,7F14
07F06:  BTSC.B  223.1
07F08:  BRA     7F06
07F0A:  MOV.B   [W1+#0],W0L
07F0C:  MOV.B   W0L,224
07F0E:  CLR.B   225
07F10:  INC     W1,W1
07F12:  BRA     7F02
07F14:  BTSC.B  223.1
07F16:  BRA     7F14
07F18:  MOV     #27,W4
07F1A:  MOV     W4,224
07F1C:  BTSC.B  223.1
07F1E:  BRA     7F1C
07F20:  MOV     #3A,W4
07F22:  MOV     W4,224
07F24:  BTSC.B  223.1
07F26:  BRA     7F24
07F28:  MOV     #20,W4
07F2A:  MOV     W4,224
....................  
....................    if(FSrmdir(dir, FALSE)) 
07F2C:  CLR.B   F78
07F2E:  PUSH    F72
07F30:  POP     F76
07F32:  CALL    7EB6
07F36:  CP0     W0
07F38:  BRA     Z,7F54
....................    { 
....................       printf("Error removing directory"); 
07F3A:  MOV     #0,W1
07F3C:  MOV     W1,W0
07F3E:  CLR.B   1
07F40:  CALL    61A
07F44:  INC     W1,W1
07F46:  BTSC.B  223.1
07F48:  BRA     7F46
07F4A:  MOV     W0,224
07F4C:  MOV     #17,W0
07F4E:  CPSGT   W1,W0
07F50:  BRA     7F3C
....................       return; 
07F52:  BRA     7F64
....................    } 
....................    printf("OK"); 
07F54:  BTSC.B  223.1
07F56:  BRA     7F54
07F58:  MOV     #4F,W4
07F5A:  MOV     W4,224
07F5C:  BTSC.B  223.1
07F5E:  BRA     7F5C
07F60:  MOV     #4B,W4
07F62:  MOV     W4,224
07F64:  RETURN  
.................... } 
....................  
.................... #define CAT_FROM_START  FALSE 
.................... #define CAT_FROM_END    TRUE 
.................... /* 
.................... Summary: Prints either all of or the last 80 characters in a file. 
.................... Param: The full path of the file to print off. 
.................... Param: If true, this function will print off the last 80 characters in the file. 
....................        If false, this funciton will print off the entire file. 
.................... Returns: None. 
.................... Example Usage: /> cat "Logs.txt" (this will display the entire file) 
.................... Example Usage: /> tail "Logs.txt" (this will display the last 80 characters in the file) 
.................... */ 
.................... void PrintFile(char *fileName, int1 startFromEnd) 
*
06EAA:  MOV     W5,[W15++]
.................... { 
....................    char scr[65]; 
06EAC:  CLR     F76
06EAE:  CLR     F78
06EB0:  CLR     F7A
06EB2:  CLR     F7C
06EB4:  CLR     F7E
06EB6:  CLR     F80
06EB8:  CLR     F82
06EBA:  CLR     F84
06EBC:  CLR     F86
06EBE:  CLR     F88
06EC0:  CLR     F8A
06EC2:  CLR     F8C
06EC4:  CLR     F8E
06EC6:  CLR     F90
06EC8:  CLR     F92
06ECA:  CLR     F94
06ECC:  CLR     F96
06ECE:  CLR     F98
06ED0:  CLR     F9A
06ED2:  CLR     F9C
06ED4:  CLR     F9E
06ED6:  CLR     FA0
06ED8:  CLR     FA2
06EDA:  CLR     FA4
06EDC:  CLR     FA6
06EDE:  CLR     FA8
06EE0:  CLR     FAA
06EE2:  CLR     FAC
06EE4:  CLR     FAE
06EE6:  CLR     FB0
06EE8:  CLR     FB2
06EEA:  CLR     FB4
06EEC:  CLR.B   FB6
....................    size_t len; 
06EEE:  CLR     FB8
....................    FSFILE* f; 
06EF0:  CLR     FBA
....................  
....................    if (!g_IsMounted) 
06EF2:  BTSC.B  800.3
06EF4:  BRA     6F10
....................    { 
....................       printf("\r\nMedia not mounted, not going to display file!"); 
06EF6:  MOV     #0,W1
06EF8:  MOV     W1,W0
06EFA:  CLR.B   1
06EFC:  CALL    640
06F00:  INC     W1,W1
06F02:  BTSC.B  223.1
06F04:  BRA     6F02
06F06:  MOV     W0,224
06F08:  MOV     #2E,W0
06F0A:  CPSGT   W1,W0
06F0C:  BRA     6EF8
....................       return; 
06F0E:  BRA     7010
....................    } 
....................  
....................    f = FSfopen(fileName, "r"); 
06F10:  MOV     #2,W3
06F12:  MOV     #0,W2
06F14:  MOV     #FBC,W1
06F16:  MOV     W3,[W15++]
06F18:  MOV     W2,W0
06F1A:  CALL    67C
06F1E:  MOV     [--W15],W3
06F20:  MOV.B   W0L,[W1++]
06F22:  INC     W2,W2
06F24:  DEC     W3,W3
06F26:  BTSS.B  42.1
06F28:  BRA     6F16
06F2A:  PUSH    F72
06F2C:  POP     FC2
06F2E:  MOV     #FBC,W4
06F30:  MOV     W4,FC4
06F32:  CALL    4A26
06F36:  MOV     W0,FBA
....................    if (!f) 
06F38:  CP0     FBA
06F3A:  BRA     NZ,6F68
....................    { 
....................       printf("\r\nError opening file (Error %X)", FSerrno); 
06F3C:  MOV     #0,W1
06F3E:  MOV     W1,W0
06F40:  CLR.B   1
06F42:  CALL    68A
06F46:  INC     W1,W1
06F48:  BTSC.B  223.1
06F4A:  BRA     6F48
06F4C:  MOV     W0,224
06F4E:  MOV     #1B,W0
06F50:  CPSGT   W1,W0
06F52:  BRA     6F3E
06F54:  MOV.B   857,W0L
06F56:  CLR.B   1
06F58:  MOV     #704,W1
06F5A:  CALL    4E3C
06F5E:  BTSC.B  223.1
06F60:  BRA     6F5E
06F62:  MOV     #29,W4
06F64:  MOV     W4,224
....................       return; 
06F66:  BRA     7010
....................    } 
....................  
....................    printf("\r\n"); 
06F68:  BTSC.B  223.1
06F6A:  BRA     6F68
06F6C:  MOV     #D,W4
06F6E:  MOV     W4,224
06F70:  BTSC.B  223.1
06F72:  BRA     6F70
06F74:  MOV     #A,W4
06F76:  MOV     W4,224
....................  
....................    if(startFromEnd) 
06F78:  CP0.B   F74
06F7A:  BRA     Z,6F8E
....................       FSfseek(f, 80, SEEK_END); 
06F7C:  PUSH    FBA
06F7E:  POP     FD2
06F80:  MOV     #50,W4
06F82:  MOV     W4,FD4
06F84:  CLR     FD6
06F86:  MOV     #2,W4
06F88:  MOV     W4,FD8
06F8A:  CALL    4760
....................  
....................    do 
....................    { 
....................       len = FSfread(scr, sizeof(char), (sizeof(scr)-1), f); 
06F8E:  MOV     #1,W4
06F90:  MOV     W4,FC4
06F92:  MOV     #F76,W4
06F94:  MOV     W4,FC2
06F96:  MOV     #40,W4
06F98:  MOV     W4,FC6
06F9A:  PUSH    FBA
06F9C:  POP     FC8
06F9E:  CALL    6C80
06FA2:  MOV     W0,FB8
....................       if (FSerrno && (FSerrno != CE_EOF)) 
06FA4:  CP0.B   857
06FA6:  BRA     Z,6FE0
06FA8:  MOV     856,W4
06FAA:  LSR     W4,#8,W4
06FAC:  XOR.B   #3D,W4L
06FAE:  BRA     Z,6FE0
....................       { 
....................          printf("\r\n!!! Error reading file (Error %X)", FSerrno); 
06FB0:  MOV     #0,W1
06FB2:  MOV     W1,W0
06FB4:  CLR.B   1
06FB6:  CALL    6B6
06FBA:  INC     W1,W1
06FBC:  BTSC.B  223.1
06FBE:  BRA     6FBC
06FC0:  MOV     W0,224
06FC2:  MOV     #1F,W0
06FC4:  CPSGT   W1,W0
06FC6:  BRA     6FB2
06FC8:  MOV.B   857,W0L
06FCA:  CLR.B   1
06FCC:  MOV     #704,W1
06FCE:  CALL    4E3C
06FD2:  BTSC.B  223.1
06FD4:  BRA     6FD2
06FD6:  MOV     #29,W4
06FD8:  MOV     W4,224
....................          len = 0; 
06FDA:  CLR     FB8
....................          break; 
06FDC:  GOTO    7008
....................       } 
....................       if (len) 
06FE0:  CP0     FB8
06FE2:  BRA     Z,7000
....................       { 
....................          scr[len] = 0; 
06FE4:  MOV     #F76,W4
06FE6:  MOV     FB8,W3
06FE8:  ADD     W3,W4,W5
06FEA:  CLR.B   [W5]
....................          //DEBUG_STR("PrintFile() got", len); 
....................          printf("%s", scr); 
06FEC:  MOV     #F76,W1
06FEE:  CP0.B   [W1]
06FF0:  BRA     Z,7000
06FF2:  BTSC.B  223.1
06FF4:  BRA     6FF2
06FF6:  MOV.B   [W1+#0],W0L
06FF8:  MOV.B   W0L,224
06FFA:  CLR.B   225
06FFC:  INC     W1,W1
06FFE:  BRA     6FEE
....................       } 
....................    } while(FSerrno != CE_EOF); 
07000:  MOV     856,W4
07002:  LSR     W4,#8,W4
07004:  XOR.B   #3D,W4L
07006:  BRA     NZ,6F8E
....................  
....................    FSfclose(f); 
07008:  PUSH    FBA
0700A:  POP     FC2
0700C:  CALL    5142
07010:  MOV     [--W15],W5
07012:  RETURN  
.................... } 
....................  
.................... //***************************************************************************** 
.................... // Created Dacember 30, 2014 
.................... // Turn on power to card. 
.................... // This is done through Pin_RG9 
.................... //  This input into the function is as follows: 
.................... // Put power to the SD Card:  1 
.................... // Take away power to the SD Card: 0 
.................... //***************************************************************************** 
....................  
.................... void PowerSDCard(int8 state) 
.................... 	{ 
....................  
.................... 	if (state == 0) 
*
00E98:  MOV.B   F72,W0L
00E9A:  SE      W0,W0
00E9C:  CP0     W0
00E9E:  BRA     NZ,EA4
.................... 		{ 
.................... 		TRISGbits.TRISG9 = OUTPUT; 
00EA0:  BCLR.B  2F1.1
.................... 		PORTGbits.RG9 =  0; 
00EA2:  BCLR.B  2F3.1
.................... 		//output_low(PIN_SDPOWER); 
.................... 		}	 
.................... 	if (state == 1) 
00EA4:  MOV.B   F72,W0L
00EA6:  SE      W0,W0
00EA8:  CP      W0,#1
00EAA:  BRA     NZ,EB0
.................... 		{ 
.................... 		TRISGbits.TRISG9 = OUTPUT; 
00EAC:  BCLR.B  2F1.1
.................... 		PORTGbits.RG9 =  1; 
00EAE:  BSET.B  2F3.1
.................... 		} 
00EB0:  RETURN  
.................... 	} 
....................  
....................  
.................... void MountMedia(void) 
*
02488:  MOV     W5,[W15++]
0248A:  MOV     W6,[W15++]
0248C:  MOV     W7,[W15++]
0248E:  MOV     W8,[W15++]
.................... { 
....................    g_IsMounted = FALSE; 
02490:  BCLR.B  800.3
....................  
....................  
.................... PowerSDCard(0);  //Power up the card 
02492:  CLR.B   F72
02494:  CALL    E98
.................... 	 
....................  
....................    MDD_InitIO(); 
02498:  CALL    EB2
....................  
....................    if (!MDD_MediaDetect()) 
0249C:  CALL    1462
024A0:  CP0.B   W0L
024A2:  BRA     NZ,24BE
....................    { 
....................       printf("\r\nError, Media not found!"); 
024A4:  MOV     #0,W1
024A6:  MOV     W1,W0
024A8:  CLR.B   1
024AA:  CALL    6E6
024AE:  INC     W1,W1
024B0:  BTSC.B  223.1
024B2:  BRA     24B0
024B4:  MOV     W0,224
024B6:  MOV     #18,W0
024B8:  CPSGT   W1,W0
024BA:  BRA     24A6
....................       return; 
024BC:  BRA     2588
....................    } 
....................  
....................    if (FSInit()) 
024BE:  CALL    21DC
024C2:  CP0     W0
024C4:  BRA     Z,254E
....................    { 
....................       g_IsMounted = TRUE; 
024C6:  BSET.B  800.3
....................  
....................       printf("\r\nOK (Sector Size=%LU, Sec Per Clus=%U, Type=%U)", 
....................             gDiskData.sectorSize, 
....................             gDiskData.SecPerClus, 
....................             gDiskData.type 
....................          ); 
024C8:  MOV     #0,W1
024CA:  MOV     W1,W0
024CC:  CLR.B   1
024CE:  CALL    70C
024D2:  INC     W1,W1
024D4:  BTSC.B  223.1
024D6:  BRA     24D4
024D8:  MOV     W0,224
024DA:  MOV     #11,W0
024DC:  CPSGT   W1,W0
024DE:  BRA     24CA
024E0:  MOV     #A,W1
024E2:  MOV     #D20,W2
024E4:  REPEAT  #3
024E6:  MOV.B   [W2++],[W1++]
024E8:  MOV     W5,W0
024EA:  MOV     W6,W1
024EC:  MOV     #0,W4
024EE:  CALL    230E
024F2:  MOV     #15,W1
024F4:  MOV     W1,W0
024F6:  CLR.B   1
024F8:  CALL    70C
024FC:  INC     W1,W1
024FE:  BTSC.B  223.1
02500:  BRA     24FE
02502:  MOV     W0,224
02504:  MOV     #23,W0
02506:  CPSGT   W1,W0
02508:  BRA     24F4
0250A:  MOV     #E,W1
0250C:  MOV     #D29,W2
0250E:  MOV.B   [W2++],[W1++]
02510:  MOV.B   W7L,W0L
02512:  CLR.B   1
02514:  MOV     #0,W4
02516:  CALL    23D6
0251A:  MOV     #26,W1
0251C:  MOV     W1,W0
0251E:  CLR.B   1
02520:  CALL    70C
02524:  INC     W1,W1
02526:  BTSC.B  223.1
02528:  BRA     2526
0252A:  MOV     W0,224
0252C:  MOV     #2C,W0
0252E:  CPSGT   W1,W0
02530:  BRA     251C
02532:  MOV     #10,W1
02534:  MOV     #D2A,W2
02536:  MOV.B   [W2++],[W1++]
02538:  MOV.B   W8L,W0L
0253A:  CLR.B   1
0253C:  MOV     #0,W4
0253E:  CALL    23D6
02542:  BTSC.B  223.1
02544:  BRA     2542
02546:  MOV     #29,W4
02548:  MOV     W4,224
....................    } 
0254A:  GOTO    2588
....................    else 
....................    { 
....................       printf("\r\nError, file system not mounted (FSerrno=%U)!!!", FSerrno); 
0254E:  MOV     #0,W1
02550:  MOV     W1,W0
02552:  CLR.B   1
02554:  CALL    74A
02558:  INC     W1,W1
0255A:  BTSC.B  223.1
0255C:  BRA     255A
0255E:  MOV     W0,224
02560:  MOV     #29,W0
02562:  CPSGT   W1,W0
02564:  BRA     2550
02566:  MOV.B   857,W0L
02568:  CLR.B   1
0256A:  MOV     #0,W4
0256C:  CALL    23D6
02570:  MOV     #2C,W1
02572:  MOV     W1,W0
02574:  CLR.B   1
02576:  CALL    74A
0257A:  INC     W1,W1
0257C:  BTSC.B  223.1
0257E:  BRA     257C
02580:  MOV     W0,224
02582:  MOV     #2F,W0
02584:  CPSGT   W1,W0
02586:  BRA     2572
....................    } 
02588:  MOV     [--W15],W8
0258A:  MOV     [--W15],W7
0258C:  MOV     [--W15],W6
0258E:  MOV     [--W15],W5
02590:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Formats the media to a specified size. 
.................... Param: The size of the media, in kB, in string form. 
.................... Returns: None. 
.................... Example Usage: /> format 524288 (format a 512MB card) 
.................... */ 
.................... void FormatMedia(char *mediaSize) 
.................... { 
....................   #if !defined(ALLOW_FORMATS) 
....................    printf("\r\nError, formatting disabled!!!"); 
*
07F66:  MOV     #0,W1
07F68:  MOV     W1,W0
07F6A:  CLR.B   1
07F6C:  CALL    788
07F70:  INC     W1,W1
07F72:  BTSC.B  223.1
07F74:  BRA     7F72
07F76:  MOV     W0,224
07F78:  MOV     #1E,W0
07F7A:  CPSGT   W1,W0
07F7C:  BRA     7F68
....................   #else 
07F7E:  RETURN  
....................    uint32_t size; 
....................    int scr; 
....................    int1 ok = FALSE; 
....................    char c; 
....................    MEDIA_INFORMATION *m; 
....................  
....................    #define MEDIA_SERIAL_NUMBER   "123" 
....................    #define MEDIA_VOLUME_ID       "123" 
....................  
....................    g_IsMounted = FALSE; 
....................  
....................    MDD_InitIO(); 
....................  
....................    if (!MDD_MediaDetect()) 
....................    { 
....................       printf("\r\nError, media not found!"); 
....................       return; 
....................    } 
....................  
....................    m = MDD_MediaInitialize(); 
....................    if (m->errorCode != MEDIA_NO_ERROR) 
....................    { 
....................       printf("\r\nMedia not initialized (ec = %X), media not formatted!", m->errorCode); 
....................       return; 
....................    } 
....................  
....................    size = atoi32(mediaSize); 
....................    scr = strlen(mediaSize); 
....................    if (scr) 
....................    { 
....................       c = toupper(mediaSize[scr-1]); 
....................       if (c == 'K') 
....................          size *= (uint32_t)1024; 
....................       else if (c == 'M') 
....................          size *= (uint32_t)1024*1024; 
....................       else if (c == 'G') 
....................          size *= (uint32_t)1024*1024*1024; 
....................    } 
....................  
....................    printf("\r\nFormatting media (size=%LU, sector size=%LU): ", size, MEDIA_SECTOR_SIZE); 
....................  
....................    if (!FSCreateMBR(1, size/MEDIA_SECTOR_SIZE)) 
....................    { 
....................       if (!FSformat (1, MEDIA_SERIAL_NUMBER, MEDIA_VOLUME_ID)) 
....................       { 
....................          ok = TRUE; 
....................       } 
....................    } 
....................  
....................    if(!ok) 
....................    { 
....................       printf("Error formatting media"); 
....................       return; 
....................    } 
....................  
....................    MountMedia(); 
....................   #endif 
.................... } 
....................  
.................... void MediaInfo(void) 
*
08432:  MOV     W5,[W15++]
08434:  MOV     W6,[W15++]
.................... { 
....................    FS_DISK_PROPERTIES p; 
08436:  CLR     F72
08438:  CLR     F74
0843A:  CLR     F76
0843C:  CLR     F78
0843E:  CLR     F7A
08440:  CLR     F7C
08442:  CLR     F7E
08444:  CLR     F80
08446:  CLR     F82
08448:  CLR     F84
0844A:  CLR     F86
0844C:  CLR     F88
0844E:  CLR     F8A
08450:  CLR     F8C
08452:  CLR     F8E
08454:  CLR     F90
08456:  CLR     F92
....................  
....................  
....................  
....................    if (g_IsMounted) 
08458:  BTSS.B  800.3
0845A:  BRA     85A0
....................    { 
....................       printf("\r\nGetting media info (this may take seconds to minutes)..."); 
0845C:  MOV     #0,W1
0845E:  MOV     W1,W0
08460:  CLR.B   1
08462:  CALL    7B4
08466:  INC     W1,W1
08468:  BTSC.B  223.1
0846A:  BRA     8468
0846C:  MOV     W0,224
0846E:  MOV     #39,W0
08470:  CPSGT   W1,W0
08472:  BRA     845E
....................       p.new_request = TRUE; 
08474:  BSET.B  F74.0
....................  
....................       do 
....................       { 
....................          FSGetDiskProperties(&p); 
08476:  MOV     #F72,W4
08478:  MOV     W4,F94
0847A:  CALL    8162
....................       } while(p.properties_status == FS_GET_PROPERTIES_STILL_WORKING); 
0847E:  MOV     F74,W4
08480:  LSR     W4,#8,W4
08482:  XOR.B   #FF,W4L
08484:  BRA     Z,8476
....................  
....................       if (p.properties_status == FS_GET_PROPERTIES_DISK_NOT_MOUNTED) 
08486:  MOV     F74,W4
08488:  LSR     W4,#8,W4
0848A:  CP.B    W4L,#1
0848C:  BRA     NZ,84AA
....................       { 
....................          printf("\r\n\nFile system thinks media isn't mounted, try mounting again!"); 
0848E:  MOV     #0,W1
08490:  MOV     W1,W0
08492:  CLR.B   1
08494:  CALL    7F8
08498:  INC     W1,W1
0849A:  BTSC.B  223.1
0849C:  BRA     849A
0849E:  MOV     W0,224
084A0:  MOV     #3D,W0
084A2:  CPSGT   W1,W0
084A4:  BRA     8490
....................       } 
084A6:  GOTO    859C
....................       else if (p.properties_status != FS_GET_PROPERTIES_NO_ERRORS) 
084AA:  CP0.B   F75
084AC:  BRA     Z,84CA
....................       { 
....................          printf("\r\n\nError getting info"); 
084AE:  MOV     #0,W1
084B0:  MOV     W1,W0
084B2:  CLR.B   1
084B4:  CALL    83E
084B8:  INC     W1,W1
084BA:  BTSC.B  223.1
084BC:  BRA     84BA
084BE:  MOV     W0,224
084C0:  MOV     #14,W0
084C2:  CPSGT   W1,W0
084C4:  BRA     84B0
....................       } 
084C6:  GOTO    859C
....................       else 
....................       { 
....................          printf("\r\n\nBytes per sector: %LU", p.results.sector_size); 
084CA:  MOV     #0,W1
084CC:  MOV     W1,W0
084CE:  CLR.B   1
084D0:  CALL    860
084D4:  INC     W1,W1
084D6:  BTSC.B  223.1
084D8:  BRA     84D6
084DA:  MOV     W0,224
084DC:  MOV     #14,W0
084DE:  CPSGT   W1,W0
084E0:  BRA     84CC
084E2:  MOV     F78,W0
084E4:  MOV     #0,W4
084E6:  CALL    23D6
....................          printf("\r\nSectors per cluster: %U", p.results.sectors_per_cluster); 
084EA:  MOV     #0,W1
084EC:  MOV     W1,W0
084EE:  CLR.B   1
084F0:  CALL    886
084F4:  INC     W1,W1
084F6:  BTSC.B  223.1
084F8:  BRA     84F6
084FA:  MOV     W0,224
084FC:  MOV     #16,W0
084FE:  CPSGT   W1,W0
08500:  BRA     84EC
08502:  MOV.B   F7A,W0L
08504:  CLR.B   1
08506:  MOV     #0,W4
08508:  CALL    23D6
....................          printf("\r\nTotal size of media: %LU", p.results.total_clusters*p.results.sectors_per_cluster*p.results.sector_size); 
0850C:  MOV.B   F7A,W0L
0850E:  MOV.B   W0L,4
08510:  CLR.B   5
08512:  MOV     #0,W3
08514:  MOV     F7C,W0
08516:  MOV     F7E,W1
08518:  CALL    10CE
0851C:  MOV     W0,W5
0851E:  MOV     W1,W6
08520:  MOV     W5,W0
08522:  MOV     W6,W1
08524:  MOV     F78,W2
08526:  MOV     #0,W3
08528:  CALL    10CE
0852C:  MOV     W0,W5
0852E:  MOV     W1,W6
08530:  MOV     #0,W1
08532:  MOV     W1,W0
08534:  CLR.B   1
08536:  MOV.B   0,W0L
08538:  CALL    8AC
0853C:  INC     W1,W1
0853E:  BTSC.B  223.1
08540:  BRA     853E
08542:  MOV     W0,224
08544:  MOV     #16,W0
08546:  CPSGT   W1,W0
08548:  BRA     8532
0854A:  MOV     W5,W0
0854C:  MOV     W6,W1
0854E:  MOV     #0,W4
08550:  CALL    230E
....................          printf("\r\nFree space of media: %LU", p.results.free_clusters*p.results.sectors_per_cluster*p.results.sector_size); 
08554:  MOV.B   F7A,W0L
08556:  MOV.B   W0L,4
08558:  CLR.B   5
0855A:  MOV     #0,W3
0855C:  MOV     F80,W0
0855E:  MOV     F82,W1
08560:  CALL    10CE
08564:  MOV     W0,W5
08566:  MOV     W1,W6
08568:  MOV     W5,W0
0856A:  MOV     W6,W1
0856C:  MOV     F78,W2
0856E:  MOV     #0,W3
08570:  CALL    10CE
08574:  MOV     W0,W5
08576:  MOV     W1,W6
08578:  MOV     #0,W1
0857A:  MOV     W1,W0
0857C:  CLR.B   1
0857E:  MOV.B   0,W0L
08580:  CALL    8D4
08584:  INC     W1,W1
08586:  BTSC.B  223.1
08588:  BRA     8586
0858A:  MOV     W0,224
0858C:  MOV     #16,W0
0858E:  CPSGT   W1,W0
08590:  BRA     857A
08592:  MOV     W5,W0
08594:  MOV     W6,W1
08596:  MOV     #0,W4
08598:  CALL    230E
....................       } 
....................    } 
0859C:  GOTO    85B8
....................    else 
....................    { 
....................       printf("\r\nMedia not mounted, not getting info!"); 
085A0:  MOV     #0,W1
085A2:  MOV     W1,W0
085A4:  CLR.B   1
085A6:  CALL    8FC
085AA:  INC     W1,W1
085AC:  BTSC.B  223.1
085AE:  BRA     85AC
085B0:  MOV     W0,224
085B2:  MOV     #25,W0
085B4:  CPSGT   W1,W0
085B6:  BRA     85A2
....................    } 
085B8:  MOV     [--W15],W6
085BA:  MOV     [--W15],W5
085BC:  RETURN  
.................... } 
....................  
.................... /* 
.................... Summary: Shows a help prompt. 
.................... Param: None. 
.................... Returns: None. 
.................... Example Usage: /> help 
.................... */ 
.................... void ShowHelp() 
.................... { 
....................    printf("\r\nFAT Shell Help - Compiled with CCS C Compiler "); 
*
07F80:  MOV     #0,W1
07F82:  MOV     W1,W0
07F84:  CLR.B   1
07F86:  CALL    930
07F8A:  INC     W1,W1
07F8C:  BTSC.B  223.1
07F8E:  BRA     7F8C
07F90:  MOV     W0,224
07F92:  MOV     #2F,W0
07F94:  CPSGT   W1,W0
07F96:  BRA     7F82
....................   #if defined(__PCD__) 
....................    printf("PCD "); 
07F98:  MOV     #0,W1
07F9A:  MOV     W1,W0
07F9C:  CLR.B   1
07F9E:  CALL    96E
07FA2:  INC     W1,W1
07FA4:  BTSC.B  223.1
07FA6:  BRA     7FA4
07FA8:  MOV     W0,224
07FAA:  MOV     #3,W0
07FAC:  CPSGT   W1,W0
07FAE:  BRA     7F9A
....................    printf(__PCD__); 
07FB0:  MOV     #0,W1
07FB2:  MOV     W1,W0
07FB4:  CLR.B   1
07FB6:  CALL    980
07FBA:  INC     W1,W1
07FBC:  BTSC.B  223.1
07FBE:  BRA     7FBC
07FC0:  MOV     W0,224
07FC2:  MOV     #4,W0
07FC4:  CPSGT   W1,W0
07FC6:  BRA     7FB2
....................   #else 
....................    printf("PCH "); 
....................    printf(__PCH__); 
....................   #endif 
....................    printf("\r\n mount --- initialize and mount file system.  required before file access"); 
07FC8:  MOV     #0,W1
07FCA:  MOV     W1,W0
07FCC:  CLR.B   1
07FCE:  CALL    992
07FD2:  INC     W1,W1
07FD4:  BTSC.B  223.1
07FD6:  BRA     7FD4
07FD8:  MOV     W0,224
07FDA:  MOV     #4A,W0
07FDC:  CPSGT   W1,W0
07FDE:  BRA     7FCA
....................    printf("\r\n del filename --- Deletes the file"); 
07FE0:  MOV     #0,W1
07FE2:  MOV     W1,W0
07FE4:  CLR.B   1
07FE6:  CALL    9E2
07FEA:  INC     W1,W1
07FEC:  BTSC.B  223.1
07FEE:  BRA     7FEC
07FF0:  MOV     W0,224
07FF2:  MOV     #23,W0
07FF4:  CPSGT   W1,W0
07FF6:  BRA     7FE2
....................    printf("\r\n make filename --- Creates an empty file"); 
07FF8:  MOV     #0,W1
07FFA:  MOV     W1,W0
07FFC:  CLR.B   1
07FFE:  CALL    A14
08002:  INC     W1,W1
08004:  BTSC.B  223.1
08006:  BRA     8004
08008:  MOV     W0,224
0800A:  MOV     #29,W0
0800C:  CPSGT   W1,W0
0800E:  BRA     7FFA
....................    printf("\r\n append filename string --- Appends string to the end of the file"); 
08010:  MOV     #0,W1
08012:  MOV     W1,W0
08014:  CLR.B   1
08016:  CALL    A4E
0801A:  INC     W1,W1
0801C:  BTSC.B  223.1
0801E:  BRA     801C
08020:  MOV     W0,224
08022:  MOV     #42,W0
08024:  CPSGT   W1,W0
08026:  BRA     8012
....................    printf("\r\n cd dir --- Change the working directory"); 
08028:  MOV     #0,W1
0802A:  MOV     W1,W0
0802C:  CLR.B   1
0802E:  CALL    A98
08032:  INC     W1,W1
08034:  BTSC.B  223.1
08036:  BRA     8034
08038:  MOV     W0,224
0803A:  MOV     #29,W0
0803C:  CPSGT   W1,W0
0803E:  BRA     802A
....................    printf("\r\n dir --- Shows the contents of the directory"); 
08040:  MOV     #0,W1
08042:  MOV     W1,W0
08044:  CLR.B   1
08046:  CALL    AD2
0804A:  INC     W1,W1
0804C:  BTSC.B  223.1
0804E:  BRA     804C
08050:  MOV     W0,224
08052:  MOV     #2D,W0
08054:  CPSGT   W1,W0
08056:  BRA     8042
....................    printf("\r\n cat filename --- Displays content of file"); 
08058:  MOV     #0,W1
0805A:  MOV     W1,W0
0805C:  CLR.B   1
0805E:  CALL    B0E
08062:  INC     W1,W1
08064:  BTSC.B  223.1
08066:  BRA     8064
08068:  MOV     W0,224
0806A:  MOV     #2B,W0
0806C:  CPSGT   W1,W0
0806E:  BRA     805A
....................    printf("\r\n tail filename --- Displays the last 80 characters of file"); 
08070:  MOV     #0,W1
08072:  MOV     W1,W0
08074:  CLR.B   1
08076:  CALL    B48
0807A:  INC     W1,W1
0807C:  BTSC.B  223.1
0807E:  BRA     807C
08080:  MOV     W0,224
08082:  MOV     #3B,W0
08084:  CPSGT   W1,W0
08086:  BRA     8072
....................    printf("\r\n mkdir dir --- Create a directory"); 
08088:  MOV     #0,W1
0808A:  MOV     W1,W0
0808C:  CLR.B   1
0808E:  CALL    B8E
08092:  INC     W1,W1
08094:  BTSC.B  223.1
08096:  BRA     8094
08098:  MOV     W0,224
0809A:  MOV     #22,W0
0809C:  CPSGT   W1,W0
0809E:  BRA     808A
....................    printf("\r\n rmdir dir --- Deletes the directory"); 
080A0:  MOV     #0,W1
080A2:  MOV     W1,W0
080A4:  CLR.B   1
080A6:  CALL    BBE
080AA:  INC     W1,W1
080AC:  BTSC.B  223.1
080AE:  BRA     80AC
080B0:  MOV     W0,224
080B2:  MOV     #25,W0
080B4:  CPSGT   W1,W0
080B6:  BRA     80A2
....................    printf("\r\n format size --- Format card.  (Example: 'format 536870912' -or- 'format 512M' "); 
080B8:  MOV     #0,W1
080BA:  MOV     W1,W0
080BC:  CLR.B   1
080BE:  CALL    BF2
080C2:  INC     W1,W1
080C4:  BTSC.B  223.1
080C6:  BRA     80C4
080C8:  MOV     W0,224
080CA:  MOV     #50,W0
080CC:  CPSGT   W1,W0
080CE:  BRA     80BA
....................    printf("\r\n                 formats a 512MB card).  Creates MBR and Partition 0.  This is "); 
080D0:  MOV     #0,W1
080D2:  MOV     W1,W0
080D4:  CLR.B   1
080D6:  CALL    C46
080DA:  INC     W1,W1
080DC:  BTSC.B  223.1
080DE:  BRA     80DC
080E0:  MOV     W0,224
080E2:  MOV     #50,W0
080E4:  CPSGT   W1,W0
080E6:  BRA     80D2
....................    printf("\r\n                 not recommended on devices which you can use a computer to"); 
080E8:  MOV     #0,W1
080EA:  MOV     W1,W0
080EC:  CLR.B   1
080EE:  CALL    C9A
080F2:  INC     W1,W1
080F4:  BTSC.B  223.1
080F6:  BRA     80F4
080F8:  MOV     W0,224
080FA:  MOV     #4C,W0
080FC:  CPSGT   W1,W0
080FE:  BRA     80EA
....................    printf("\r\n                 format the drive (such as an SD or CF device)."); 
08100:  MOV     #0,W1
08102:  MOV     W1,W0
08104:  CLR.B   1
08106:  CALL    CEA
0810A:  INC     W1,W1
0810C:  BTSC.B  223.1
0810E:  BRA     810C
08110:  MOV     W0,224
08112:  MOV     #40,W0
08114:  CPSGT   W1,W0
08116:  BRA     8102
....................    printf("\r\n info --- Show some info about the media/file system.  Can take several seconds!"); 
08118:  MOV     #0,W1
0811A:  MOV     W1,W0
0811C:  CLR.B   1
0811E:  CALL    D32
08122:  INC     W1,W1
08124:  BTSC.B  223.1
08126:  BRA     8124
08128:  MOV     W0,224
0812A:  MOV     #51,W0
0812C:  CPSGT   W1,W0
0812E:  BRA     811A
....................    printf("\r\n help\tYou are here"); 
08130:  MOV     #0,W1
08132:  MOV     W1,W0
08134:  CLR.B   1
08136:  CALL    D86
0813A:  INC     W1,W1
0813C:  BTSC.B  223.1
0813E:  BRA     813C
08140:  MOV     W0,224
08142:  MOV     #13,W0
08144:  CPSGT   W1,W0
08146:  BRA     8132
....................    printf("\r\n\n Put a parameter in quotes if it has spaces"); 
08148:  MOV     #0,W1
0814A:  MOV     W1,W0
0814C:  CLR.B   1
0814E:  CALL    DA8
08152:  INC     W1,W1
08154:  BTSC.B  223.1
08156:  BRA     8154
08158:  MOV     W0,224
0815A:  MOV     #2D,W0
0815C:  CPSGT   W1,W0
0815E:  BRA     814A
....................  
....................    DEBUG_STR("SPICON1", SPICON1); 
....................    DEBUG_STR("SPISTAT", SPISTAT); 
08160:  RETURN  
.................... } 
....................  
.................... char * GetCMD(char *in) 
.................... { 
....................    char tokens[]=" \r\n"; 
*
05B82:  MOV     #D20,W4
05B84:  MOV     W4,F74
05B86:  MOV     #A,W4
05B88:  MOV     W4,F76
....................    return(strtok(in,tokens)); 
05B8A:  PUSH    F72
05B8C:  POP     F82
05B8E:  MOV     #F74,W4
05B90:  MOV     W4,F84
05B92:  CALL    5B22
05B96:  MOV     W0,0
05B98:  RETURN  
.................... } 
....................  
.................... char * GetOption(char *in) 
05B9A:  MOV     W5,[W15++]
.................... { 
....................    char tokensSpace[]=" \r\n"; 
05B9C:  MOV     #D20,W4
05B9E:  MOV     W4,F78
05BA0:  MOV     #A,W4
05BA2:  MOV     W4,F7A
....................    char tokensQuote[]="\"\r\n"; 
05BA4:  MOV     #D22,W4
05BA6:  MOV     W4,F7C
05BA8:  MOV     #A,W4
05BAA:  MOV     W4,F7E
....................  
....................    //trim leading spaces 
....................    while (*in==' ') 
05BAC:  MOV     F76,W0
05BAE:  MOV.B   [W0],W4L
05BB0:  XOR.B   #20,W4L
05BB2:  BRA     NZ,5BBA
....................       in++; 
05BB4:  INC     0F76
05BB6:  GOTO    5BAC
....................  
....................    //if first char is a quote, then end token on a quote.  ELSE end token on a space 
....................    if (*in == '\"') 
05BBA:  MOV     F76,W0
05BBC:  MOV.B   [W0],W4L
05BBE:  XOR.B   #22,W4L
05BC0:  BRA     NZ,5BD6
....................       return(strtok(in,tokensQuote)); 
05BC2:  PUSH    F76
05BC4:  POP     F82
05BC6:  MOV     #F7C,W4
05BC8:  MOV     W4,F84
05BCA:  CALL    5B22
05BCE:  MOV     W0,0
05BD0:  BRA     5BE6
05BD2:  GOTO    5BE6
....................    else 
....................       return(strtok(in,tokensSpace)); 
05BD6:  PUSH    F76
05BD8:  POP     F82
05BDA:  MOV     #F78,W4
05BDC:  MOV     W4,F84
05BDE:  CALL    5B22
05BE2:  MOV     W0,0
05BE4:  BRA     5BE6
05BE6:  MOV     [--W15],W5
05BE8:  RETURN  
.................... } 
....................  
.................... void main(void) 
*
085BE:  MOV     #4780,W15
085C0:  MOV     #47FF,W0
085C2:  MOV     W0,20
085C4:  NOP     
085C6:  BSET.B  81.7
085C8:  MOV     #46,W0
085CA:  MOV.B   W0L,742
085CC:  MOV     #57,W0
085CE:  MOV.B   W0L,742
085D0:  BCLR.B  742.6
085D2:  MOV     #3F19,W0
085D4:  MOV     W0,6A4
085D6:  MOV     #3F2D,W0
085D8:  MOV     W0,6A8
085DA:  MOV     #8,W0
085DC:  MOV     W0,6D0
085DE:  MOV     #3,W0
085E0:  MOV     W0,6D4
085E2:  MOV     #7,W0
085E4:  MOV     W0,6DE
085E6:  MOV     #46,W0
085E8:  MOV.B   W0L,742
085EA:  MOV     #57,W0
085EC:  MOV.B   W0L,742
085EE:  BSET.B  742.6
085F0:  MOV     #800,W0
085F2:  MOV     #1FFE,W1
085F4:  REPEAT  W1
085F6:  CLR     [W0++]
085F8:  BCLR.B  800.1
085FA:  CLR     744
085FC:  MOV     #8000,W4
085FE:  MOV     W4,220
08600:  MOV     #400,W4
08602:  MOV     W4,222
08604:  BSET.B  220.3
08606:  MOV     #1A0,W4
08608:  MOV     W4,228
0860A:  SETM    84A
0860C:  SETM    84C
0860E:  CLR.B   83F
08610:  CLR     84E
08612:  SETM    850
08614:  SETM    852
08616:  CLR.B   854
08618:  CLR.B   855
0861A:  CLR.B   856
0861C:  CLR.B   861
0861E:  MOV     #8CE,W4
08620:  MOV     W4,904
08622:  BCLR.B  800.3
08624:  CLR     E4E
08626:  SETM    32C
08628:  BRA     86DC
0862A:  DATA    80,01,08
0862C:  DATA    00,00,80
0862E:  DATA    02,08,02
08630:  DATA    00,00,80
08632:  DATA    01,0D,4D
08634:  DATA    00,80,01
08636:  DATA    0D,53,00
08638:  DATA    80,4E,0D
0863A:  DATA    62,00,95
0863C:  DATA    00,00,01
0863E:  DATA    F9,00,00
08640:  DATA    08,87,04
08642:  DATA    00,09,AF
08644:  DATA    00,01,0A
08646:  DATA    1B,00,01
08648:  DATA    0C,C3,01
0864A:  DATA    00,0D,AF
0864C:  DATA    02,00,10
0864E:  DATA    FF,00,00
08650:  DATA    11,FF,00
08652:  DATA    01,12,FF
08654:  DATA    00,01,18
08656:  DATA    FF,00,01
08658:  DATA    19,FF,00
0865A:  DATA    01,20,FF
0865C:  DATA    00,00,21
0865E:  DATA    FF,00,00
08660:  DATA    26,DF,01
08662:  DATA    00,37,73
08664:  DATA    00,00,3A
08666:  DATA    25,04,00
08668:  DATA    3B,25,00
0866A:  DATA    00,29,FF
0866C:  DATA    04,00,17
0866E:  DATA    FF,40,1C
08670:  DATA    00,00,03
08672:  DATA    64,65,6C
08674:  DATA    40,07,00
08676:  DATA    00,04,6D
08678:  DATA    61,6B,65
0867A:  DATA    40,06,00
0867C:  DATA    00,06,61
0867E:  DATA    70,70,65
08680:  DATA    6E,64,40
08682:  DATA    04,00,00
08684:  DATA    02,63,64
08686:  DATA    40,08,00
08688:  DATA    00,03,64
0868A:  DATA    69,72,40
0868C:  DATA    07,00,00
0868E:  DATA    03,63,61
08690:  DATA    74,40,07
08692:  DATA    00,00,04
08694:  DATA    74,61,69
08696:  DATA    6C,40,06
08698:  DATA    00,00,05
0869A:  DATA    6D,6B,64
0869C:  DATA    69,72,40
0869E:  DATA    05,00,00
086A0:  DATA    05,72,6D
086A2:  DATA    64,69,72
086A4:  DATA    40,05,00
086A6:  DATA    00,06,66
086A8:  DATA    6F,72,6D
086AA:  DATA    61,74,40
086AC:  DATA    04,00,00
086AE:  DATA    04,68,65
086B0:  DATA    6C,70,40
086B2:  DATA    06,00,00
086B4:  DATA    05,6D,6F
086B6:  DATA    75,6E,74
086B8:  DATA    40,05,00
086BA:  DATA    00,05,69
086BC:  DATA    6E,66,6F
086BE:  DATA    00,00,00
086C0:  INC     W2,W2
086C2:  CP      W2,#1
086C4:  BRA     NZ,86CE
086C6:  TBLRDL  [W1],W3
086C8:  TBLRDH  [W1++],W4
086CA:  MOV.B   6,W0L
086CC:  RETURN  
086CE:  CP      W2,#2
086D0:  BRA     NZ,86D6
086D2:  MOV.B   7,W0L
086D4:  RETURN  
086D6:  MOV.B   8,W0L
086D8:  CLR     W2
086DA:  RETURN  
086DC:  MOV     #0,W6
086DE:  MOV     #0,W0
086E0:  MOV     W0,32
086E2:  MOV     #862A,W0
086E4:  MOV     W0,W1
086E6:  CLR     W2
086E8:  CALL    86C0
086EC:  MOV.B   W0L,B
086EE:  CALL    86C0
086F2:  MOV.B   W0L,A
086F4:  CP0     W5
086F6:  BRA     Z,872A
086F8:  BTSS    W5.F
086FA:  BRA     870A
086FC:  CALL    86C0
08700:  MOV.B   W0L,D
08702:  CALL    86C0
08706:  MOV.B   W0L,C
08708:  BCLR    W5.F
0870A:  BTSS    W5.E
0870C:  BRA     871E
0870E:  BCLR    W5.E
08710:  DEC     W5,W5
08712:  CALL    86C0
08716:  MOV.B   W0L,W7L
08718:  REPEAT  W5
0871A:  MOV.B   W7L,[W6++]
0871C:  BRA     86E8
0871E:  CALL    86C0
08722:  MOV.B   W0L,[W6++]
08724:  DEC     W5,W5
08726:  BRA     NZ,871E
08728:  BRA     86E8
.................... { 
....................    char buffer[255]; 
0872A:  CLR     E50
0872C:  CLR     E52
0872E:  CLR     E54
08730:  CLR     E56
08732:  CLR     E58
08734:  CLR     E5A
08736:  CLR     E5C
08738:  CLR     E5E
0873A:  CLR     E60
0873C:  CLR     E62
0873E:  CLR     E64
08740:  CLR     E66
08742:  CLR     E68
08744:  CLR     E6A
08746:  CLR     E6C
08748:  CLR     E6E
0874A:  CLR     E70
0874C:  CLR     E72
0874E:  CLR     E74
08750:  CLR     E76
08752:  CLR     E78
08754:  CLR     E7A
08756:  CLR     E7C
08758:  CLR     E7E
0875A:  CLR     E80
0875C:  CLR     E82
0875E:  CLR     E84
08760:  CLR     E86
08762:  CLR     E88
08764:  CLR     E8A
08766:  CLR     E8C
08768:  CLR     E8E
0876A:  CLR     E90
0876C:  CLR     E92
0876E:  CLR     E94
08770:  CLR     E96
08772:  CLR     E98
08774:  CLR     E9A
08776:  CLR     E9C
08778:  CLR     E9E
0877A:  CLR     EA0
0877C:  CLR     EA2
0877E:  CLR     EA4
08780:  CLR     EA6
08782:  CLR     EA8
08784:  CLR     EAA
08786:  CLR     EAC
08788:  CLR     EAE
0878A:  CLR     EB0
0878C:  CLR     EB2
0878E:  CLR     EB4
08790:  CLR     EB6
08792:  CLR     EB8
08794:  CLR     EBA
08796:  CLR     EBC
08798:  CLR     EBE
0879A:  CLR     EC0
0879C:  CLR     EC2
0879E:  CLR     EC4
087A0:  CLR     EC6
087A2:  CLR     EC8
087A4:  CLR     ECA
087A6:  CLR     ECC
087A8:  CLR     ECE
087AA:  CLR     ED0
087AC:  CLR     ED2
087AE:  CLR     ED4
087B0:  CLR     ED6
087B2:  CLR     ED8
087B4:  CLR     EDA
087B6:  CLR     EDC
087B8:  CLR     EDE
087BA:  CLR     EE0
087BC:  CLR     EE2
087BE:  CLR     EE4
087C0:  CLR     EE6
087C2:  CLR     EE8
087C4:  CLR     EEA
087C6:  CLR     EEC
087C8:  CLR     EEE
087CA:  CLR     EF0
087CC:  CLR     EF2
087CE:  CLR     EF4
087D0:  CLR     EF6
087D2:  CLR     EF8
087D4:  CLR     EFA
087D6:  CLR     EFC
087D8:  CLR     EFE
087DA:  CLR     F00
087DC:  CLR     F02
087DE:  CLR     F04
087E0:  CLR     F06
087E2:  CLR     F08
087E4:  CLR     F0A
087E6:  CLR     F0C
087E8:  CLR     F0E
087EA:  CLR     F10
087EC:  CLR     F12
087EE:  CLR     F14
087F0:  CLR     F16
087F2:  CLR     F18
087F4:  CLR     F1A
087F6:  CLR     F1C
087F8:  CLR     F1E
087FA:  CLR     F20
087FC:  CLR     F22
087FE:  CLR     F24
08800:  CLR     F26
08802:  CLR     F28
08804:  CLR     F2A
08806:  CLR     F2C
08808:  CLR     F2E
0880A:  CLR     F30
0880C:  CLR     F32
0880E:  CLR     F34
08810:  CLR     F36
08812:  CLR     F38
08814:  CLR     F3A
08816:  CLR     F3C
08818:  CLR     F3E
0881A:  CLR     F40
0881C:  CLR     F42
0881E:  CLR     F44
08820:  CLR     F46
08822:  CLR     F48
08824:  CLR     F4A
08826:  CLR     F4C
08828:  CLR.B   F4E
....................    char *cmd, *option1, *option2; 
0882A:  CLR     F50
0882C:  CLR     F52
0882E:  CLR     F54
....................  
....................    int i;   // pointer to the buffer 
08830:  CLR     F56
....................  
....................  
....................  
....................  
....................  
....................  //  HW_INIT(); 
....................  
....................  
....................    //printf("\r\n\nex_fat.c - MDD Example"); 
.................... MountMedia(); 
08832:  CALL    2488
....................  
....................             if (!g_IsMounted) 
08836:  BTSC.B  800.3
08838:  BRA     8860
....................             { 
....................                sprintf(buffer, "mount"); 
0883A:  MOV     #E50,W4
0883C:  MOV     W4,E4E
0883E:  MOV     #0,W1
08840:  MOV     W1,W0
08842:  CLR.B   1
08844:  CALL    DE4
08848:  INC     W1,W1
0884A:  MOV     W1,[W15++]
0884C:  MOV     W0,[W15++]
0884E:  MOV     [--W15],W0
08850:  CALL    2592
08854:  MOV     [--W15],W1
08856:  MOV     #4,W0
08858:  CPSGT   W1,W0
0885A:  BRA     8840
....................             } 
0885C:  GOTO    8882
....................             else 
....................             { 
....................                sprintf(buffer, "append log.txt button pressed!!"); 
08860:  MOV     #E50,W4
08862:  MOV     W4,E4E
08864:  MOV     #0,W1
08866:  MOV     W1,W0
08868:  CLR.B   1
0886A:  CALL    DF6
0886E:  INC     W1,W1
08870:  MOV     W1,[W15++]
08872:  MOV     W0,[W15++]
08874:  MOV     [--W15],W0
08876:  CALL    2592
0887A:  MOV     [--W15],W1
0887C:  MOV     #1E,W0
0887E:  CPSGT   W1,W0
08880:  BRA     8866
....................             } 
....................  
....................  
....................    // main loop 
....................  
....................  
.................... //option1 = GetOption(cmd + strlen(cmd) + 1); 
.................... //MakeFile("testfile.txt"); 
....................  
.................... AppendFile("testfile.txt", "Hello World"); 
08882:  MOV     #D,W3
08884:  MOV     #0,W2
08886:  MOV     #F58,W1
08888:  MOV     W3,[W15++]
0888A:  MOV     W2,W0
0888C:  CALL    E22
08890:  MOV     [--W15],W3
08892:  MOV.B   W0L,[W1++]
08894:  INC     W2,W2
08896:  DEC     W3,W3
08898:  BTSS.B  42.1
0889A:  BRA     8888
0889C:  MOV     #C,W3
0889E:  MOV     #0,W2
088A0:  MOV     #F65,W1
088A2:  MOV     W3,[W15++]
088A4:  MOV     W2,W0
088A6:  CALL    E3C
088AA:  MOV     [--W15],W3
088AC:  MOV.B   W0L,[W1++]
088AE:  INC     W2,W2
088B0:  DEC     W3,W3
088B2:  BTSS.B  42.1
088B4:  BRA     88A2
088B6:  MOV     #F58,W4
088B8:  MOV     W4,F72
088BA:  MOV     #F65,W4
088BC:  MOV     W4,F74
088BE:  CALL    5274
....................  
....................  
....................  
....................  
....................  
....................    for(;;) 
....................    { 
....................       i = 0; 
088C2:  CLR     F56
....................  
....................       DisplayPrompt(); 
088C4:  CALL    59A4
....................  
....................       for(;;) 
....................       { 
....................         #if 1 
....................          if (BUTTON_PRESSED()) 
088C8:  BTSC.B  2EA.0
088CA:  BRA     8926
....................          { 
....................             while(BUTTON_PRESSED()); 
088CC:  BTSS.B  2EA.0
088CE:  BRA     88CC
....................             delay_ms(150); 
088D0:  MOV     #96,W0
088D2:  CALL    5A84
....................             if (!g_IsMounted) 
088D6:  BTSC.B  800.3
088D8:  BRA     8900
....................             { 
....................                sprintf(buffer, "mount"); 
088DA:  MOV     #E50,W4
088DC:  MOV     W4,E4E
088DE:  MOV     #0,W1
088E0:  MOV     W1,W0
088E2:  CLR.B   1
088E4:  CALL    DE4
088E8:  INC     W1,W1
088EA:  MOV     W1,[W15++]
088EC:  MOV     W0,[W15++]
088EE:  MOV     [--W15],W0
088F0:  CALL    2592
088F4:  MOV     [--W15],W1
088F6:  MOV     #4,W0
088F8:  CPSGT   W1,W0
088FA:  BRA     88E0
....................             } 
088FC:  GOTO    8922
....................             else 
....................             { 
....................                sprintf(buffer, "append log.txt button pressed!!"); 
08900:  MOV     #E50,W4
08902:  MOV     W4,E4E
08904:  MOV     #0,W1
08906:  MOV     W1,W0
08908:  CLR.B   1
0890A:  CALL    DF6
0890E:  INC     W1,W1
08910:  MOV     W1,[W15++]
08912:  MOV     W0,[W15++]
08914:  MOV     [--W15],W0
08916:  CALL    2592
0891A:  MOV     [--W15],W1
0891C:  MOV     #1E,W0
0891E:  CPSGT   W1,W0
08920:  BRA     8906
....................             } 
....................             break; 
08922:  GOTO    89A4
....................          } 
....................         #endif 
....................  
....................          if (kbhit()) 
08926:  BTSS.B  222.0
08928:  BRA     89A0
....................          { 
....................             buffer[i] = getch(); 
0892A:  MOV     #E50,W4
0892C:  MOV     F56,W3
0892E:  ADD     W3,W4,W5
08930:  BTSS.B  222.0
08932:  BRA     8930
08934:  MOV     226,W0
08936:  MOV.B   W0L,[W5]
....................  
....................             // check for a backspace 
....................             if(buffer[i] != 8) 
08938:  MOV     #E50,W4
0893A:  MOV     F56,W3
0893C:  ADD     W3,W4,W0
0893E:  MOV.B   [W0],W5L
08940:  SE      W5,W5
08942:  CP      W5,#8
08944:  BRA     Z,8960
....................             { 
....................                printf("%c", buffer[i]); 
08946:  MOV     #E50,W4
08948:  MOV     F56,W3
0894A:  ADD     W3,W4,W0
0894C:  MOV.B   [W0],W5L
0894E:  BTSC.B  223.1
08950:  BRA     894E
08952:  PUSH    224
08954:  MOV.B   W5L,[W15-#2]
08956:  POP     224
08958:  CLR.B   225
....................                i++; 
0895A:  INC     0F56
....................             } 
0895C:  GOTO    8986
....................             else if(i > 0) 
08960:  MOV     F56,W4
08962:  CP      W4,#0
08964:  BRA     LE,8986
....................             { 
....................                // delete the last character 
....................                i--; 
08966:  DEC     0F56
....................                putc(8); 
08968:  MOV.B   #8,W0L
0896A:  BTSC.B  223.1
0896C:  BRA     896A
0896E:  MOV.B   W0L,224
08970:  CLR.B   225
....................                putc(' '); 
08972:  MOV.B   #20,W0L
08974:  BTSC.B  223.1
08976:  BRA     8974
08978:  MOV.B   W0L,224
0897A:  CLR.B   225
....................                putc(8); 
0897C:  MOV.B   #8,W0L
0897E:  BTSC.B  223.1
08980:  BRA     897E
08982:  MOV.B   W0L,224
08984:  CLR.B   225
....................             } 
....................             buffer[i] = '\0'; 
08986:  MOV     #E50,W4
08988:  MOV     F56,W3
0898A:  ADD     W3,W4,W5
0898C:  CLR.B   [W5]
....................             if (buffer[i - 1] == '\r') 
0898E:  MOV     F56,W4
08990:  SUB     W4,#1,W5
08992:  MOV     #E50,W4
08994:  ADD     W5,W4,W0
08996:  MOV.B   [W0],W4L
08998:  CP.B    W4L,#D
0899A:  BRA     NZ,89A0
....................                break; 
0899C:  GOTO    89A4
....................          } 
089A0:  GOTO    88C8
....................       } 
....................  
....................       // parse the command and options 
....................       cmd = GetCMD(buffer); 
089A4:  MOV     #E50,W4
089A6:  MOV     W4,F72
089A8:  CALL    5B82
089AC:  MOV     W0,F50
....................       option1 = GetOption(cmd + strlen(cmd) + 1); 
089AE:  PUSH    F50
089B0:  POP     1036
089B2:  CALL    25A8
089B6:  MOV     F50,W4
089B8:  ADD     W0,W4,W5
089BA:  ADD     W5,#1,W5
089BC:  MOV     W5,F76
089BE:  CALL    5B9A
089C2:  MOV     W0,F52
....................       option2 = GetOption(option1 + strlen(option1) + 1); 
089C4:  PUSH    F52
089C6:  POP     1036
089C8:  CALL    25A8
089CC:  MOV     F52,W4
089CE:  ADD     W0,W4,W5
089D0:  ADD     W5,#1,W5
089D2:  MOV     W5,F76
089D4:  CALL    5B9A
089D8:  MOV     W0,F54
....................  
....................       if (cmd) 
089DA:  CP0     F50
089DC:  BRA     Z,8AFA
....................       { 
....................          switch(FindCommand(cmd)) 
089DE:  PUSH    F50
089E0:  POP     F72
089E2:  CALL    5C90
089E6:  XOR     #0,W0
089E8:  BRA     Z,8A1C
089EA:  XOR     #1,W0
089EC:  BRA     Z,8A28
089EE:  XOR     #3,W0
089F0:  BRA     Z,8A34
089F2:  XOR     #1,W0
089F4:  BRA     Z,8A44
089F6:  XOR     #7,W0
089F8:  BRA     Z,8A50
089FA:  XOR     #1,W0
089FC:  BRA     Z,8A58
089FE:  XOR     #3,W0
08A00:  BRA     Z,8A66
08A02:  XOR     #1,W0
08A04:  BRA     Z,8A76
08A06:  XOR     #F,W0
08A08:  BRA     Z,8A82
08A0A:  XOR     #1,W0
08A0C:  BRA     Z,8A8E
08A0E:  XOR     #3,W0
08A10:  BRA     Z,8A9A
08A12:  XOR     #1,W0
08A14:  BRA     Z,8AA2
08A16:  XOR     #7,W0
08A18:  BRA     Z,8AAA
08A1A:  BRA     8AB2
....................          { 
....................             case 0:  //del 
....................                DeleteFile(option1); 
08A1C:  PUSH    F52
08A1E:  POP     F72
08A20:  CALL    5DF0
....................                break; 
08A24:  GOTO    8AFA
....................  
....................             case 1:  //make 
....................                MakeFile(option1); 
08A28:  PUSH    F52
08A2A:  POP     F72
08A2C:  CALL    5E8A
....................                break; 
08A30:  GOTO    8AFA
....................  
....................             case 2:  //append 
....................                AppendFile(option1, option2); 
08A34:  PUSH    F52
08A36:  POP     F72
08A38:  PUSH    F54
08A3A:  POP     F74
08A3C:  CALL    5274
....................                break; 
08A40:  GOTO    8AFA
....................  
....................             case 3:  //change directory 
....................                ChangeDirectory(option1); 
08A44:  PUSH    F52
08A46:  POP     F72
08A48:  CALL    652A
....................                break; 
08A4C:  GOTO    8AFA
....................  
....................             case 4:  //show directory contents 
....................                DisplayDirectory(); 
08A50:  CALL    6AD8
....................                break; 
08A54:  GOTO    8AFA
....................  
....................             case 5:  //cat, display file 
....................                PrintFile(option1, CAT_FROM_START); 
08A58:  CLR.B   F74
08A5A:  PUSH    F52
08A5C:  POP     F72
08A5E:  CALL    6EAA
....................                break; 
08A62:  GOTO    8AFA
....................  
....................             case 6:  //tail, display last 80 charachters 
....................                PrintFile(option1, CAT_FROM_END); 
08A66:  MOV.B   #1,W0L
08A68:  MOV.B   W0L,F74
08A6A:  PUSH    F52
08A6C:  POP     F72
08A6E:  CALL    6EAA
....................                break; 
08A72:  GOTO    8AFA
....................  
....................             case 7: //mkdir, make a directory 
....................                MakeDirectory(option1); 
08A76:  PUSH    F52
08A78:  POP     F72
08A7A:  CALL    7698
....................                break; 
08A7E:  GOTO    8AFA
....................  
....................             case 8: //rmdir, make a directory 
....................                RemoveDirectory(option1); 
08A82:  PUSH    F52
08A84:  POP     F72
08A86:  CALL    7ECA
....................                break; 
08A8A:  GOTO    8AFA
....................  
....................             case 9: //format, format the card 
....................                FormatMedia(option1); 
08A8E:  PUSH    F52
08A90:  POP     F72
08A92:  CALL    7F66
....................                break; 
08A96:  GOTO    8AFA
....................  
....................             case 10: //help, display help 
....................                ShowHelp(); 
08A9A:  CALL    7F80
....................                break; 
08A9E:  GOTO    8AFA
....................  
....................             case 11: //mount 
....................                MountMedia(); 
08AA2:  CALL    2488
....................                break; 
08AA6:  GOTO    8AFA
....................  
....................             case 12: //info 
....................                MediaInfo(); 
08AAA:  CALL    8432
....................                break; 
08AAE:  GOTO    8AFA
....................  
....................             default: 
....................                printf("\r\nUnknown Command '%s', use 'help' to get list of commands", cmd); 
08AB2:  MOV     #0,W1
08AB4:  MOV     W1,W0
08AB6:  CLR.B   1
08AB8:  CALL    E54
08ABC:  INC     W1,W1
08ABE:  BTSC.B  223.1
08AC0:  BRA     8ABE
08AC2:  MOV     W0,224
08AC4:  MOV     #12,W0
08AC6:  CPSGT   W1,W0
08AC8:  BRA     8AB4
08ACA:  MOV     F50,W1
08ACC:  CP0.B   [W1]
08ACE:  BRA     Z,8ADE
08AD0:  BTSC.B  223.1
08AD2:  BRA     8AD0
08AD4:  MOV.B   [W1+#0],W0L
08AD6:  MOV.B   W0L,224
08AD8:  CLR.B   225
08ADA:  INC     W1,W1
08ADC:  BRA     8ACC
08ADE:  MOV     #15,W1
08AE0:  MOV     W1,W0
08AE2:  CLR.B   1
08AE4:  CALL    E54
08AE8:  INC     W1,W1
08AEA:  BTSC.B  223.1
08AEC:  BRA     8AEA
08AEE:  MOV     W0,224
08AF0:  MOV     #39,W0
08AF2:  CPSGT   W1,W0
08AF4:  BRA     8AE0
....................                break; 
08AF6:  GOTO    8AFA
....................          } 
....................       } 
08AFA:  GOTO    88C2
....................    } 
.................... } 
....................  
08AFE:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 3E5F   WPOSTS16 WDT128 WINDIS NOWDT ICSP2 NODEBUG NOWRT NOPROTECT NOJTAG
          H: FF00  
   Word  2L: 83F9   XT IOL1WAY NOOSCIO PR_PLL IESO
          H: FF00  
   Word  3L: FFFF   WPFP WPDIS NOWPCFG WPEND
          H: FF00  
   Word  4L: 0000  
          H: FF00  
