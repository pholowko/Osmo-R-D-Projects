CCS PCD C Compiler, Version 5.032, 17542               12-Mar-15 18:15

               Filename:   F:\Osmobot4PostProduction\main.lst

               ROM used:   33210 bytes (19%)
                           Largest free fragment is 65536
               RAM used:   12330 (76%) at main() level
                           12792 (79%) worst case
               Stack used: 104 locations (46 in main + 58 for interrupts)
               Stack size: 128

*
00000:  GOTO    77BE
*
00006:  DATA    8E,1F,00
00008:  DATA    F2,18,00
0000A:  DATA    5A,1D,00
0000C:  DATA    26,1B,00
*
0002A:  DATA    8E,16,00
*
000B8:  DATA    F0,16,00
.................... #include <24FJ256GA106.h> 
.................... //////////// Standard Header file for the PIC24FJ256GA106 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ256GA106 
*
00200:  CLR     32
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    41,54,00
0020E:  DATA    2B,5A,00
00210:  DATA    0D,00,00
00212:  CLR     32
00214:  MOV     #21E,W3
00216:  ADD     W3,W0,W0
00218:  TBLRDL.B[W0],W0L
0021A:  CLR.B   1
0021C:  RETURN  
0021E:  DATA    41,54,00
00220:  DATA    2B,46,00
00222:  DATA    41,50,00
00224:  DATA    53,54,00
00226:  DATA    41,3D,00
00228:  DATA    6F,6E,00
0022A:  DATA    0D,00,00
0022C:  CLR     32
0022E:  MOV     #238,W3
00230:  ADD     W3,W0,W0
00232:  TBLRDL.B[W0],W0L
00234:  CLR.B   1
00236:  RETURN  
00238:  DATA    41,54,00
0023A:  DATA    2B,57,00
0023C:  DATA    53,53,00
0023E:  DATA    53,49,00
00240:  DATA    44,3D,00
00242:  DATA    25,73,00
00244:  DATA    0D,00,00
00246:  CLR     32
00248:  MOV     #252,W3
0024A:  ADD     W3,W0,W0
0024C:  TBLRDL.B[W0],W0L
0024E:  CLR.B   1
00250:  RETURN  
00252:  DATA    41,54,00
00254:  DATA    2B,57,00
00256:  DATA    53,4B,00
00258:  DATA    45,59,00
0025A:  DATA    3D,25,00
0025C:  DATA    73,2C,00
0025E:  DATA    25,73,00
00260:  DATA    2C,25,00
00262:  DATA    73,0D,00
00264:  DATA    00,00,00
00266:  CLR     32
00268:  MOV     #272,W3
0026A:  ADD     W3,W0,W0
0026C:  TBLRDL.B[W0],W0L
0026E:  CLR.B   1
00270:  RETURN  
00272:  DATA    41,54,00
00274:  DATA    2B,57,00
00276:  DATA    4D,4F,00
00278:  DATA    44,45,00
0027A:  DATA    3D,53,00
0027C:  DATA    54,41,00
0027E:  DATA    0D,00,00
00280:  CLR     32
00282:  MOV     #28C,W3
00284:  ADD     W3,W0,W0
00286:  TBLRDL.B[W0],W0L
00288:  CLR.B   1
0028A:  RETURN  
0028C:  DATA    41,54,00
0028E:  DATA    2B,57,00
00290:  DATA    41,50,00
00292:  DATA    3D,31,00
00294:  DATA    31,42,00
00296:  DATA    47,4E,00
00298:  DATA    2C,4F,00
0029A:  DATA    53,4D,00
0029C:  DATA    4F,42,00
0029E:  DATA    4F,54,00
002A0:  DATA    5F,41,00
002A2:  DATA    50,2C,00
002A4:  DATA    41,55,00
002A6:  DATA    54,4F,00
002A8:  DATA    0D,00,00
002AA:  CLR     32
002AC:  MOV     #2B6,W3
002AE:  ADD     W3,W0,W0
002B0:  TBLRDL.B[W0],W0L
002B2:  CLR.B   1
002B4:  RETURN  
002B6:  DATA    41,54,00
002B8:  DATA    2B,57,00
002BA:  DATA    41,4B,00
002BC:  DATA    45,59,00
002BE:  DATA    3D,57,00
002C0:  DATA    50,41,00
002C2:  DATA    50,53,00
002C4:  DATA    4B,2C,00
002C6:  DATA    41,45,00
002C8:  DATA    53,2C,00
002CA:  DATA    6F,73,00
002CC:  DATA    6D,6F,00
002CE:  DATA    70,61,00
002D0:  DATA    73,73,00
002D2:  DATA    21,0D,00
002D4:  DATA    00,00,00
002D6:  CLR     32
002D8:  MOV     #2E2,W3
002DA:  ADD     W3,W0,W0
002DC:  TBLRDL.B[W0],W0L
002DE:  CLR.B   1
002E0:  RETURN  
002E2:  DATA    41,54,00
002E4:  DATA    2B,54,00
002E6:  DATA    43,50,00
002E8:  DATA    54,4F,00
002EA:  DATA    3D,33,00
002EC:  DATA    0D,00,00
002EE:  CLR     32
002F0:  MOV     #2FA,W3
002F2:  ADD     W3,W0,W0
002F4:  TBLRDL.B[W0],W0L
002F6:  CLR.B   1
002F8:  RETURN  
002FA:  DATA    41,54,00
002FC:  DATA    2B,54,00
002FE:  DATA    43,50,00
00300:  DATA    42,3D,00
00302:  DATA    6F,66,00
00304:  DATA    66,0D,00
00306:  DATA    00,00,00
00308:  CLR     32
0030A:  MOV     #314,W3
0030C:  ADD     W3,W0,W0
0030E:  TBLRDL.B[W0],W0L
00310:  CLR.B   1
00312:  RETURN  
00314:  DATA    41,54,00
00316:  DATA    2B,54,00
00318:  DATA    43,50,00
0031A:  DATA    41,44,00
0031C:  DATA    44,42,00
0031E:  DATA    3D,6F,00
00320:  DATA    73,6D,00
00322:  DATA    6F,62,00
00324:  DATA    6F,74,00
00326:  DATA    2E,6F,00
00328:  DATA    72,67,00
0032A:  DATA    0D,00,00
0032C:  CLR     32
0032E:  MOV     #338,W3
00330:  ADD     W3,W0,W0
00332:  TBLRDL.B[W0],W0L
00334:  CLR.B   1
00336:  RETURN  
00338:  DATA    41,54,00
0033A:  DATA    2B,54,00
0033C:  DATA    43,50,00
0033E:  DATA    54,4F,00
00340:  DATA    42,3D,00
00342:  DATA    35,0D,00
00344:  DATA    00,00,00
00346:  CLR     32
00348:  MOV     #352,W3
0034A:  ADD     W3,W0,W0
0034C:  TBLRDL.B[W0],W0L
0034E:  CLR.B   1
00350:  RETURN  
00352:  DATA    41,54,00
00354:  DATA    2B,4E,00
00356:  DATA    45,54,00
00358:  DATA    50,3D,00
0035A:  DATA    54,43,00
0035C:  DATA    50,2C,00
0035E:  DATA    43,4C,00
00360:  DATA    49,45,00
00362:  DATA    4E,54,00
00364:  DATA    2C,38,00
00366:  DATA    30,2C,00
00368:  DATA    6F,73,00
0036A:  DATA    6D,6F,00
0036C:  DATA    62,6F,00
0036E:  DATA    74,2E,00
00370:  DATA    6F,72,00
00372:  DATA    67,0D,00
00374:  DATA    00,00,00
00376:  CLR     32
00378:  MOV     #382,W3
0037A:  ADD     W3,W0,W0
0037C:  TBLRDL.B[W0],W0L
0037E:  CLR.B   1
00380:  RETURN  
00382:  DATA    41,54,00
00384:  DATA    2B,4E,00
00386:  DATA    45,54,00
00388:  DATA    50,3D,00
0038A:  DATA    54,43,00
0038C:  DATA    50,2C,00
0038E:  DATA    53,45,00
00390:  DATA    52,56,00
00392:  DATA    45,52,00
00394:  DATA    2C,38,00
00396:  DATA    38,39,00
00398:  DATA    39,2C,00
0039A:  DATA    31,30,00
0039C:  DATA    2E,31,00
0039E:  DATA    30,2E,00
003A0:  DATA    31,30,00
003A2:  DATA    30,2E,00
003A4:  DATA    32,35,00
003A6:  DATA    34,0D,00
003A8:  DATA    00,00,00
003AA:  CLR     32
003AC:  MOV     #64,W3
003AE:  SUB     W0,W3,W3
003B0:  BRA     C,3BC
003B2:  MOV     #3C6,W3
003B4:  ADD     W3,W0,W0
003B6:  TBLRDL.B[W0],W0L
003B8:  CLR.B   1
003BA:  RETURN  
003BC:  MOV     #3C6,W0
003BE:  ADD     W3,W3,W3
003C0:  ADD     W3,W0,W3
003C2:  TBLRDH  [W3],W0
003C4:  RETURN  
003C6:  DATA    48,54,3A
003C8:  DATA    54,50,50
003CA:  DATA    2F,31,4F
003CC:  DATA    2E,31,52
003CE:  DATA    20,34,54
003D0:  DATA    30,34,25
003D2:  DATA    20,4E,73
003D4:  DATA    6F,74,20
003D6:  DATA    20,46,44
003D8:  DATA    6F,75,6F
003DA:  DATA    6E,64,65
003DC:  DATA    0A,43,73
003DE:  DATA    6F,6E,20
003E0:  DATA    74,65,4E
003E2:  DATA    6E,74,6F
003E4:  DATA    2D,54,74
003E6:  DATA    79,70,20
003E8:  DATA    65,3A,45
003EA:  DATA    20,74,78
003EC:  DATA    65,78,69
003EE:  DATA    74,2F,73
003F0:  DATA    68,74,74
003F2:  DATA    6D,6C,2C
003F4:  DATA    0A,0A,20
003F6:  DATA    3C,21,53
003F8:  DATA    44,4F,6F
003FA:  DATA    43,54,72
003FC:  DATA    59,50,72
003FE:  DATA    45,20,79
00400:  DATA    48,54,2E
00402:  DATA    4D,4C,0A
00404:  DATA    3E,0A,3C
00406:  DATA    3C,68,62
00408:  DATA    74,6D,72
0040A:  DATA    6C,3E,20
0040C:  DATA    0A,54,2F
0040E:  DATA    68,65,3E
00410:  DATA    20,52,0A
00412:  DATA    65,71,3C
00414:  DATA    75,65,2F
00416:  DATA    73,74,68
00418:  DATA    65,64,74
0041A:  DATA    20,50,6D
0041C:  DATA    61,67,6C
0041E:  DATA    65,3A,3E
00420:  DATA    20,4F,0D
00422:  DATA    53,4D,0A
00424:  DATA    4F,42,00
00426:  DATA    4F,54,00
00428:  DATA    49,50,00
0042A:  CLR     32
0042C:  MOV     #1E,W3
0042E:  SUB     W0,W3,W3
00430:  BRA     C,43C
00432:  MOV     #446,W3
00434:  ADD     W3,W0,W0
00436:  TBLRDL.B[W0],W0L
00438:  CLR.B   1
0043A:  RETURN  
0043C:  MOV     #446,W0
0043E:  ADD     W3,W3,W3
00440:  ADD     W3,W0,W3
00442:  TBLRDH  [W3],W0
00444:  RETURN  
00446:  DATA    48,54,74
00448:  DATA    54,50,65
0044A:  DATA    2F,31,78
0044C:  DATA    2E,31,74
0044E:  DATA    20,32,2F
00450:  DATA    30,30,68
00452:  DATA    20,4F,74
00454:  DATA    4B,0A,6D
00456:  DATA    43,6F,6C
00458:  DATA    6E,74,0D
0045A:  DATA    65,6E,0A
0045C:  DATA    74,2D,0D
0045E:  DATA    54,79,0A
00460:  DATA    70,65,00
00462:  DATA    3A,20,00
00464:  CLR     32
00466:  MOV     #6C,W3
00468:  SUB     W0,W3,W3
0046A:  BRA     C,476
0046C:  MOV     #480,W3
0046E:  ADD     W3,W0,W0
00470:  TBLRDL.B[W0],W0L
00472:  CLR.B   1
00474:  RETURN  
00476:  MOV     #480,W0
00478:  ADD     W3,W3,W3
0047A:  ADD     W3,W0,W3
0047C:  TBLRDH  [W3],W0
0047E:  RETURN  
00480:  DATA    3C,68,6F
00482:  DATA    74,6D,75
00484:  DATA    6C,3E,74
00486:  DATA    3C,62,65
00488:  DATA    6F,64,72
0048A:  DATA    79,3E,20
0048C:  DATA    3C,66,50
0048E:  DATA    6F,72,61
00490:  DATA    6D,20,73
00492:  DATA    61,63,73
00494:  DATA    74,69,77
00496:  DATA    6F,6E,6F
00498:  DATA    3D,22,72
0049A:  DATA    72,6F,64
0049C:  DATA    75,74,3A
0049E:  DATA    65,72,20
004A0:  DATA    5F,73,3C
004A2:  DATA    75,62,69
004A4:  DATA    6D,69,6E
004A6:  DATA    74,2E,70
004A8:  DATA    68,74,75
004AA:  DATA    6D,6C,74
004AC:  DATA    22,20,20
004AE:  DATA    6D,65,74
004B0:  DATA    74,68,79
004B2:  DATA    6F,64,70
004B4:  DATA    3D,22,65
004B6:  DATA    67,65,3D
004B8:  DATA    74,22,22
004BA:  DATA    3E,52,74
004BC:  DATA    6F,75,65
004BE:  DATA    74,65,78
004C0:  DATA    72,20,74
004C2:  DATA    6E,61,22
004C4:  DATA    6D,65,20
004C6:  DATA    3A,20,6E
004C8:  DATA    3C,69,61
004CA:  DATA    6E,70,6D
004CC:  DATA    75,74,65
004CE:  DATA    20,74,3D
004D0:  DATA    79,70,22
004D2:  DATA    65,3D,50
004D4:  DATA    22,74,41
004D6:  DATA    65,78,53
004D8:  DATA    74,22,53
004DA:  DATA    20,6E,22
004DC:  DATA    61,6D,3E
004DE:  DATA    65,3D,3C
004E0:  DATA    22,53,62
004E2:  DATA    53,49,72
004E4:  DATA    44,22,3E
004E6:  DATA    3E,3C,00
004E8:  DATA    62,72,00
004EA:  DATA    3E,52,00
004EC:  CLR     32
004EE:  MOV     #8A,W3
004F0:  SUB     W0,W3,W3
004F2:  BRA     C,4FE
004F4:  MOV     #508,W3
004F6:  ADD     W3,W0,W0
004F8:  TBLRDL.B[W0],W0L
004FA:  CLR.B   1
004FC:  RETURN  
004FE:  MOV     #508,W0
00500:  ADD     W3,W3,W3
00502:  ADD     W3,W0,W3
00504:  TBLRDH  [W3],W0
00506:  RETURN  
00508:  DATA    41,75,6F
0050A:  DATA    74,68,70
0050C:  DATA    3A,20,74
0050E:  DATA    3C,73,69
00510:  DATA    65,6C,6F
00512:  DATA    65,63,6E
00514:  DATA    74,20,20
00516:  DATA    20,6E,76
00518:  DATA    61,6D,61
0051A:  DATA    65,3D,6C
0051C:  DATA    22,41,75
0051E:  DATA    55,54,65
00520:  DATA    48,22,3D
00522:  DATA    3E,3C,22
00524:  DATA    6F,70,57
00526:  DATA    74,69,50
00528:  DATA    6F,6E,41
0052A:  DATA    20,76,32
0052C:  DATA    61,6C,50
0052E:  DATA    75,65,53
00530:  DATA    3D,22,4B
00532:  DATA    4F,50,22
00534:  DATA    45,4E,20
00536:  DATA    22,3E,73
00538:  DATA    4F,50,65
0053A:  DATA    45,4E,6C
0053C:  DATA    3C,2F,65
0053E:  DATA    6F,70,63
00540:  DATA    74,69,74
00542:  DATA    6F,6E,65
00544:  DATA    3E,3C,64
00546:  DATA    6F,70,3D
00548:  DATA    74,69,22
0054A:  DATA    6F,6E,73
0054C:  DATA    20,76,65
0054E:  DATA    61,6C,6C
00550:  DATA    75,65,65
00552:  DATA    3D,22,63
00554:  DATA    53,48,74
00556:  DATA    41,52,65
00558:  DATA    45,44,64
0055A:  DATA    22,3E,22
0055C:  DATA    53,48,3E
0055E:  DATA    41,52,57
00560:  DATA    45,44,50
00562:  DATA    3C,2F,41
00564:  DATA    6F,70,32
00566:  DATA    74,69,50
00568:  DATA    6F,6E,53
0056A:  DATA    3E,3C,4B
0056C:  DATA    6F,70,3C
0056E:  DATA    74,69,2F
00570:  DATA    6F,6E,6F
00572:  DATA    20,76,70
00574:  DATA    61,6C,74
00576:  DATA    75,65,69
00578:  DATA    3D,22,6F
0057A:  DATA    57,50,6E
0057C:  DATA    41,50,3E
0057E:  DATA    53,4B,3C
00580:  DATA    22,3E,2F
00582:  DATA    57,50,73
00584:  DATA    41,50,65
00586:  DATA    53,4B,6C
00588:  DATA    3C,2F,65
0058A:  DATA    6F,70,63
0058C:  DATA    74,69,74
0058E:  DATA    6F,6E,3E
00590:  DATA    3E,3C,00
00592:  CLR     32
00594:  MOV     #74,W3
00596:  SUB     W0,W3,W3
00598:  BRA     C,5A4
0059A:  MOV     #5AE,W3
0059C:  ADD     W3,W0,W0
0059E:  TBLRDL.B[W0],W0L
005A0:  CLR.B   1
005A2:  RETURN  
005A4:  MOV     #5AE,W0
005A6:  ADD     W3,W3,W3
005A8:  ADD     W3,W0,W3
005AA:  TBLRDH  [W3],W0
005AC:  RETURN  
005AE:  DATA    3C,2F,4B
005B0:  DATA    62,72,49
005B2:  DATA    3E,45,50
005B4:  DATA    6E,63,22
005B6:  DATA    3A,20,3E
005B8:  DATA    3C,73,54
005BA:  DATA    65,6C,4B
005BC:  DATA    65,63,49
005BE:  DATA    74,20,50
005C0:  DATA    20,6E,3C
005C2:  DATA    61,6D,2F
005C4:  DATA    65,3D,6F
005C6:  DATA    22,45,70
005C8:  DATA    4E,43,74
005CA:  DATA    52,59,69
005CC:  DATA    50,54,6F
005CE:  DATA    22,3E,6E
005D0:  DATA    3C,6F,3E
005D2:  DATA    70,74,3C
005D4:  DATA    69,6F,6F
005D6:  DATA    6E,20,70
005D8:  DATA    76,61,74
005DA:  DATA    6C,75,69
005DC:  DATA    65,3D,6F
005DE:  DATA    22,4E,6E
005E0:  DATA    4F,4E,20
005E2:  DATA    45,22,76
005E4:  DATA    3E,4E,61
005E6:  DATA    4F,4E,6C
005E8:  DATA    45,3C,75
005EA:  DATA    2F,6F,65
005EC:  DATA    70,74,3D
005EE:  DATA    69,6F,22
005F0:  DATA    6E,3E,41
005F2:  DATA    3C,6F,45
005F4:  DATA    70,74,53
005F6:  DATA    69,6F,22
005F8:  DATA    6E,20,20
005FA:  DATA    76,61,63
005FC:  DATA    6C,75,68
005FE:  DATA    65,3D,65
00600:  DATA    22,57,63
00602:  DATA    45,50,6B
00604:  DATA    22,3E,65
00606:  DATA    57,45,64
00608:  DATA    50,3C,3D
0060A:  DATA    2F,6F,22
0060C:  DATA    70,74,63
0060E:  DATA    69,6F,68
00610:  DATA    6E,3E,65
00612:  DATA    3C,6F,63
00614:  DATA    70,74,6B
00616:  DATA    69,6F,65
00618:  DATA    6E,20,64
0061A:  DATA    76,61,22
0061C:  DATA    6C,75,00
0061E:  DATA    65,3D,00
00620:  DATA    22,54,00
00622:  CLR     32
00624:  MOV     #48,W3
00626:  SUB     W0,W3,W3
00628:  BRA     C,634
0062A:  MOV     #63E,W3
0062C:  ADD     W3,W0,W0
0062E:  TBLRDL.B[W0],W0L
00630:  CLR.B   1
00632:  RETURN  
00634:  MOV     #63E,W0
00636:  ADD     W3,W3,W3
00638:  ADD     W3,W0,W3
0063A:  TBLRDH  [W3],W0
0063C:  RETURN  
0063E:  DATA    73,65,3D
00640:  DATA    6C,65,22
00642:  DATA    63,74,53
00644:  DATA    65,64,75
00646:  DATA    3D,22,62
00648:  DATA    73,65,6D
0064A:  DATA    6C,65,69
0064C:  DATA    63,74,74
0064E:  DATA    65,64,22
00650:  DATA    22,3E,3E
00652:  DATA    41,45,3C
00654:  DATA    53,3C,2F
00656:  DATA    2F,6F,66
00658:  DATA    70,74,6F
0065A:  DATA    69,6F,72
0065C:  DATA    6E,3E,6D
0065E:  DATA    3C,2F,3E
00660:  DATA    73,65,3C
00662:  DATA    6C,65,2F
00664:  DATA    63,74,62
00666:  DATA    3E,3C,6F
00668:  DATA    2F,62,64
0066A:  DATA    72,3E,79
0066C:  DATA    3C,69,3E
0066E:  DATA    6E,70,3C
00670:  DATA    75,74,2F
00672:  DATA    20,74,68
00674:  DATA    79,70,74
00676:  DATA    65,3D,6D
00678:  DATA    22,73,6C
0067A:  DATA    75,62,3E
0067C:  DATA    6D,69,0D
0067E:  DATA    74,22,0A
00680:  DATA    20,76,0D
00682:  DATA    61,6C,0A
00684:  DATA    75,65,00
00686:  CLR     32
00688:  MOV     #86,W3
0068A:  SUB     W0,W3,W3
0068C:  BRA     C,698
0068E:  MOV     #6A2,W3
00690:  ADD     W3,W0,W0
00692:  TBLRDL.B[W0],W0L
00694:  CLR.B   1
00696:  RETURN  
00698:  MOV     #6A2,W0
0069A:  ADD     W3,W3,W3
0069C:  ADD     W3,W0,W3
0069E:  TBLRDH  [W3],W0
006A0:  RETURN  
006A2:  DATA    3C,21,65
006A4:  DATA    44,4F,63
006A6:  DATA    43,54,3D
006A8:  DATA    59,50,64
006AA:  DATA    45,20,6F
006AC:  DATA    68,74,63
006AE:  DATA    6D,6C,75
006B0:  DATA    3E,3C,6D
006B2:  DATA    68,74,65
006B4:  DATA    6D,6C,6E
006B6:  DATA    3E,3C,74
006B8:  DATA    73,63,2E
006BA:  DATA    72,69,71
006BC:  DATA    70,74,75
006BE:  DATA    3E,0A,65
006C0:  DATA    20,66,72
006C2:  DATA    75,6E,79
006C4:  DATA    63,74,53
006C6:  DATA    69,6F,65
006C8:  DATA    6E,20,6C
006CA:  DATA    68,61,65
006CC:  DATA    6E,64,63
006CE:  DATA    6C,65,74
006D0:  DATA    52,42,6F
006D2:  DATA    43,6C,72
006D4:  DATA    69,63,28
006D6:  DATA    6B,28,27
006D8:  DATA    29,7B,69
006DA:  DATA    63,68,6E
006DC:  DATA    65,63,70
006DE:  DATA    6B,76,75
006E0:  DATA    61,6C,74
006E2:  DATA    3D,64,5B
006E4:  DATA    6F,63,6E
006E6:  DATA    75,6D,61
006E8:  DATA    65,6E,6D
006EA:  DATA    74,2E,65
006EC:  DATA    71,75,20
006EE:  DATA    65,72,3D
006F0:  DATA    79,53,20
006F2:  DATA    65,6C,22
006F4:  DATA    65,63,53
006F6:  DATA    74,6F,53
006F8:  DATA    72,28,49
006FA:  DATA    27,69,44
006FC:  DATA    6E,70,72
006FE:  DATA    75,74,22
00700:  DATA    5B,6E,5D
00702:  DATA    61,6D,3A
00704:  DATA    65,20,63
00706:  DATA    3D,20,68
00708:  DATA    22,53,65
0070A:  DATA    53,49,63
0070C:  DATA    44,72,6B
0070E:  DATA    22,5D,65
00710:  DATA    3A,63,64
00712:  DATA    68,65,27
00714:  DATA    63,6B,29
00716:  DATA    65,64,2E
00718:  DATA    27,29,74
0071A:  DATA    2E,76,69
0071C:  DATA    61,6C,74
0071E:  DATA    75,65,6C
00720:  DATA    3B,20,65
00722:  DATA    63,68,3B
00724:  DATA    65,63,00
00726:  DATA    6B,73,00
00728:  CLR     32
0072A:  MOV     #72,W3
0072C:  SUB     W0,W3,W3
0072E:  BRA     C,73A
00730:  MOV     #744,W3
00732:  ADD     W3,W0,W0
00734:  TBLRDL.B[W0],W0L
00736:  CLR.B   1
00738:  RETURN  
0073A:  MOV     #744,W0
0073C:  ADD     W3,W3,W3
0073E:  ADD     W3,W0,W3
00740:  TBLRDH  [W3],W0
00742:  RETURN  
00744:  DATA    69,66,75
00746:  DATA    28,63,6D
00748:  DATA    68,65,65
0074A:  DATA    63,6B,6E
0074C:  DATA    76,61,74
0074E:  DATA    6C,3D,2E
00750:  DATA    3D,22,67
00752:  DATA    7E,21,65
00754:  DATA    24,4F,74
00756:  DATA    74,68,45
00758:  DATA    65,72,6C
0075A:  DATA    22,29,65
0075C:  DATA    7B,76,6D
0075E:  DATA    69,73,65
00760:  DATA    56,61,6E
00762:  DATA    72,3D,74
00764:  DATA    22,76,42
00766:  DATA    69,73,79
00768:  DATA    69,62,49
0076A:  DATA    6C,65,64
0076C:  DATA    22,3B,28
0076E:  DATA    7D,20,22
00770:  DATA    65,6C,53
00772:  DATA    73,65,53
00774:  DATA    7B,76,49
00776:  DATA    69,73,44
00778:  DATA    56,61,74
0077A:  DATA    72,3D,62
0077C:  DATA    22,68,22
0077E:  DATA    69,64,29
00780:  DATA    64,65,2E
00782:  DATA    6E,22,73
00784:  DATA    3B,20,74
00786:  DATA    64,6F,79
00788:  DATA    63,75,6C
0078A:  DATA    6D,65,65
0078C:  DATA    6E,74,2E
0078E:  DATA    2E,67,76
00790:  DATA    65,74,69
00792:  DATA    45,6C,73
00794:  DATA    65,6D,69
00796:  DATA    65,6E,62
00798:  DATA    74,42,69
0079A:  DATA    79,49,6C
0079C:  DATA    64,28,69
0079E:  DATA    22,53,74
007A0:  DATA    53,49,79
007A2:  DATA    44,74,3D
007A4:  DATA    62,22,76
007A6:  DATA    29,2E,69
007A8:  DATA    76,61,73
007AA:  DATA    6C,75,56
007AC:  DATA    65,3D,61
007AE:  DATA    22,22,72
007B0:  DATA    3B,7D,3B
007B2:  DATA    20,64,00
007B4:  DATA    6F,63,00
007B6:  CLR     32
007B8:  MOV     #8C,W3
007BA:  SUB     W0,W3,W3
007BC:  BRA     C,7C8
007BE:  MOV     #7D2,W3
007C0:  ADD     W3,W0,W0
007C2:  TBLRDL.B[W0],W0L
007C4:  CLR.B   1
007C6:  RETURN  
007C8:  MOV     #7D2,W0
007CA:  ADD     W3,W3,W3
007CC:  ADD     W3,W0,W3
007CE:  TBLRDH  [W3],W0
007D0:  RETURN  
007D2:  DATA    64,6F,2E
007D4:  DATA    63,75,76
007D6:  DATA    6D,65,69
007D8:  DATA    6E,74,73
007DA:  DATA    2E,67,69
007DC:  DATA    65,74,62
007DE:  DATA    45,6C,69
007E0:  DATA    65,6D,6C
007E2:  DATA    65,6E,69
007E4:  DATA    74,42,74
007E6:  DATA    79,49,79
007E8:  DATA    64,28,3D
007EA:  DATA    22,63,22
007EC:  DATA    75,73,68
007EE:  DATA    74,6F,69
007F0:  DATA    6D,50,64
007F2:  DATA    72,6F,64
007F4:  DATA    70,65,65
007F6:  DATA    72,74,6E
007F8:  DATA    69,65,22
007FA:  DATA    73,22,3B
007FC:  DATA    29,2E,20
007FE:  DATA    73,74,64
00800:  DATA    79,6C,6F
00802:  DATA    65,2E,63
00804:  DATA    76,69,75
00806:  DATA    73,69,6D
00808:  DATA    62,69,65
0080A:  DATA    6C,69,6E
0080C:  DATA    74,79,74
0080E:  DATA    3D,76,2E
00810:  DATA    69,73,67
00812:  DATA    56,61,65
00814:  DATA    72,3B,74
00816:  DATA    0A,69,45
00818:  DATA    66,28,6C
0081A:  DATA    63,68,65
0081C:  DATA    65,63,6D
0081E:  DATA    6B,73,65
00820:  DATA    65,63,6E
00822:  DATA    2E,69,74
00824:  DATA    6E,64,42
00826:  DATA    65,78,79
00828:  DATA    4F,66,49
0082A:  DATA    28,22,64
0082C:  DATA    4E,4F,28
0082E:  DATA    4E,45,27
00830:  DATA    22,29,50
00832:  DATA    3E,2D,41
00834:  DATA    31,29,53
00836:  DATA    20,7B,53
00838:  DATA    64,6F,74
0083A:  DATA    63,75,62
0083C:  DATA    6D,65,27
0083E:  DATA    6E,74,29
00840:  DATA    2E,67,2E
00842:  DATA    65,74,76
00844:  DATA    45,6C,61
00846:  DATA    65,6D,6C
00848:  DATA    65,6E,75
0084A:  DATA    74,42,65
0084C:  DATA    79,49,3D
0084E:  DATA    64,28,22
00850:  DATA    22,70,22
00852:  DATA    77,64,3B
00854:  DATA    69,76,7D
00856:  DATA    22,29,0A
00858:  DATA    2E,73,00
0085A:  DATA    74,79,00
0085C:  DATA    6C,65,00
0085E:  CLR     32
00860:  MOV     #70,W3
00862:  SUB     W0,W3,W3
00864:  BRA     C,870
00866:  MOV     #87A,W3
00868:  ADD     W3,W0,W0
0086A:  TBLRDL.B[W0],W0L
0086C:  CLR.B   1
0086E:  RETURN  
00870:  MOV     #87A,W0
00872:  ADD     W3,W3,W3
00874:  ADD     W3,W0,W3
00876:  TBLRDH  [W3],W0
00878:  RETURN  
0087A:  DATA    65,6C,2E
0087C:  DATA    73,65,71
0087E:  DATA    7B,64,75
00880:  DATA    6F,63,65
00882:  DATA    75,6D,72
00884:  DATA    65,6E,79
00886:  DATA    74,2E,53
00888:  DATA    67,65,65
0088A:  DATA    74,45,6C
0088C:  DATA    6C,65,65
0088E:  DATA    6D,65,63
00890:  DATA    6E,74,74
00892:  DATA    42,79,6F
00894:  DATA    49,64,72
00896:  DATA    28,22,28
00898:  DATA    70,77,27
0089A:  DATA    64,69,69
0089C:  DATA    76,22,6E
0089E:  DATA    29,2E,70
008A0:  DATA    73,74,75
008A2:  DATA    79,6C,74
008A4:  DATA    65,2E,5B
008A6:  DATA    76,69,6E
008A8:  DATA    73,69,61
008AA:  DATA    62,69,6D
008AC:  DATA    6C,69,65
008AE:  DATA    74,79,20
008B0:  DATA    3D,22,3D
008B2:  DATA    76,69,20
008B4:  DATA    73,69,22
008B6:  DATA    62,6C,53
008B8:  DATA    65,22,53
008BA:  DATA    3B,7D,49
008BC:  DATA    7D,66,44
008BE:  DATA    75,6E,72
008C0:  DATA    63,74,22
008C2:  DATA    69,6F,5D
008C4:  DATA    6E,20,3A
008C6:  DATA    73,75,63
008C8:  DATA    62,6D,68
008CA:  DATA    69,74,65
008CC:  DATA    46,6F,63
008CE:  DATA    72,6D,6B
008D0:  DATA    28,29,65
008D2:  DATA    20,7B,64
008D4:  DATA    76,61,27
008D6:  DATA    72,20,29
008D8:  DATA    73,73,2E
008DA:  DATA    69,64,76
008DC:  DATA    76,61,61
008DE:  DATA    6C,20,6C
008E0:  DATA    3D,20,75
008E2:  DATA    64,6F,65
008E4:  DATA    63,75,3B
008E6:  DATA    6D,65,00
008E8:  DATA    6E,74,00
008EA:  CLR     32
008EC:  MOV     #7A,W3
008EE:  SUB     W0,W3,W3
008F0:  BRA     C,8FC
008F2:  MOV     #906,W3
008F4:  ADD     W3,W0,W0
008F6:  TBLRDL.B[W0],W0L
008F8:  CLR.B   1
008FA:  RETURN  
008FC:  MOV     #906,W0
008FE:  ADD     W3,W3,W3
00900:  ADD     W3,W0,W3
00902:  TBLRDH  [W3],W0
00904:  RETURN  
00906:  DATA    76,61,42
00908:  DATA    72,20,79
0090A:  DATA    65,6E,49
0090C:  DATA    63,72,64
0090E:  DATA    79,70,28
00910:  DATA    53,74,27
00912:  DATA    72,20,53
00914:  DATA    3D,20,53
00916:  DATA    64,6F,49
00918:  DATA    63,75,44
0091A:  DATA    6D,65,68
0091C:  DATA    6E,74,27
0091E:  DATA    2E,71,29
00920:  DATA    75,65,2E
00922:  DATA    72,79,76
00924:  DATA    53,65,61
00926:  DATA    6C,65,6C
00928:  DATA    63,74,75
0092A:  DATA    6F,72,65
0092C:  DATA    28,27,3D
0092E:  DATA    69,6E,64
00930:  DATA    70,75,6F
00932:  DATA    74,5B,63
00934:  DATA    6E,61,75
00936:  DATA    6D,65,6D
00938:  DATA    20,3D,65
0093A:  DATA    20,22,6E
0093C:  DATA    53,53,74
0093E:  DATA    49,44,2E
00940:  DATA    72,22,67
00942:  DATA    5D,3A,65
00944:  DATA    63,68,74
00946:  DATA    65,63,45
00948:  DATA    6B,65,6C
0094A:  DATA    64,27,65
0094C:  DATA    29,2E,6D
0094E:  DATA    74,69,65
00950:  DATA    74,6C,6E
00952:  DATA    65,3B,74
00954:  DATA    20,69,42
00956:  DATA    66,28,79
00958:  DATA    73,73,49
0095A:  DATA    69,64,64
0095C:  DATA    76,61,28
0095E:  DATA    6C,3D,27
00960:  DATA    3D,22,53
00962:  DATA    7E,21,53
00964:  DATA    24,4F,49
00966:  DATA    74,68,44
00968:  DATA    65,72,74
0096A:  DATA    22,29,62
0096C:  DATA    7B,64,27
0096E:  DATA    6F,63,29
00970:  DATA    75,6D,2E
00972:  DATA    65,6E,76
00974:  DATA    74,2E,61
00976:  DATA    67,65,6C
00978:  DATA    74,45,75
0097A:  DATA    6C,65,65
0097C:  DATA    6D,65,3B
0097E:  DATA    6E,74,00
00980:  CLR     32
00982:  MOV     #70,W3
00984:  SUB     W0,W3,W3
00986:  BRA     C,992
00988:  MOV     #99C,W3
0098A:  ADD     W3,W0,W0
0098C:  TBLRDL.B[W0],W0L
0098E:  CLR.B   1
00990:  RETURN  
00992:  MOV     #99C,W0
00994:  ADD     W3,W3,W3
00996:  ADD     W3,W0,W3
00998:  TBLRDH  [W3],W0
0099A:  RETURN  
0099C:  DATA    64,6F,68
0099E:  DATA    63,75,27
009A0:  DATA    6D,65,29
009A2:  DATA    6E,74,2E
009A4:  DATA    2E,67,76
009A6:  DATA    65,74,61
009A8:  DATA    45,6C,6C
009AA:  DATA    65,6D,75
009AC:  DATA    65,6E,65
009AE:  DATA    74,42,3D
009B0:  DATA    79,49,64
009B2:  DATA    64,28,6F
009B4:  DATA    27,41,63
009B6:  DATA    55,54,75
009B8:  DATA    48,68,6D
009BA:  DATA    27,29,65
009BC:  DATA    2E,76,6E
009BE:  DATA    61,6C,74
009C0:  DATA    75,65,2E
009C2:  DATA    3D,64,67
009C4:  DATA    6F,63,65
009C6:  DATA    75,6D,74
009C8:  DATA    65,6E,45
009CA:  DATA    74,2E,6C
009CC:  DATA    67,65,65
009CE:  DATA    74,45,6D
009D0:  DATA    6C,65,65
009D2:  DATA    6D,65,6E
009D4:  DATA    6E,74,74
009D6:  DATA    42,79,42
009D8:  DATA    49,64,79
009DA:  DATA    28,27,49
009DC:  DATA    41,55,64
009DE:  DATA    54,48,28
009E0:  DATA    44,4D,27
009E2:  DATA    27,29,45
009E4:  DATA    2E,76,4E
009E6:  DATA    61,6C,43
009E8:  DATA    75,65,52
009EA:  DATA    3B,20,59
009EC:  DATA    64,6F,50
009EE:  DATA    63,75,54
009F0:  DATA    6D,65,44
009F2:  DATA    6E,74,4D
009F4:  DATA    2E,67,27
009F6:  DATA    65,74,29
009F8:  DATA    45,6C,2E
009FA:  DATA    65,6D,76
009FC:  DATA    65,6E,61
009FE:  DATA    74,42,6C
00A00:  DATA    79,49,75
00A02:  DATA    64,28,65
00A04:  DATA    27,45,3B
00A06:  DATA    4E,43,7D
00A08:  DATA    52,59,0A
00A0A:  DATA    50,54,00
00A0C:  CLR     32
00A0E:  MOV     #5C,W3
00A10:  SUB     W0,W3,W3
00A12:  BRA     C,A1E
00A14:  MOV     #A28,W3
00A16:  ADD     W3,W0,W0
00A18:  TBLRDL.B[W0],W0L
00A1A:  CLR.B   1
00A1C:  RETURN  
00A1E:  MOV     #A28,W0
00A20:  ADD     W3,W3,W3
00A22:  ADD     W3,W0,W3
00A24:  TBLRDH  [W3],W0
00A26:  RETURN  
00A28:  DATA    65,6C,6E
00A2A:  DATA    73,65,74
00A2C:  DATA    7B,64,2E
00A2E:  DATA    6F,63,67
00A30:  DATA    75,6D,65
00A32:  DATA    65,6E,74
00A34:  DATA    74,2E,45
00A36:  DATA    67,65,6C
00A38:  DATA    74,45,65
00A3A:  DATA    6C,65,6D
00A3C:  DATA    6D,65,65
00A3E:  DATA    6E,74,6E
00A40:  DATA    42,79,74
00A42:  DATA    49,64,42
00A44:  DATA    28,27,79
00A46:  DATA    53,53,49
00A48:  DATA    49,44,64
00A4A:  DATA    68,27,28
00A4C:  DATA    29,2E,27
00A4E:  DATA    76,61,41
00A50:  DATA    6C,75,55
00A52:  DATA    65,3D,54
00A54:  DATA    73,73,48
00A56:  DATA    69,64,68
00A58:  DATA    76,61,27
00A5A:  DATA    6C,3B,29
00A5C:  DATA    0A,69,2E
00A5E:  DATA    66,28,76
00A60:  DATA    65,6E,61
00A62:  DATA    63,72,6C
00A64:  DATA    79,70,75
00A66:  DATA    53,74,65
00A68:  DATA    72,2E,3D
00A6A:  DATA    69,6E,22
00A6C:  DATA    64,65,57
00A6E:  DATA    78,4F,50
00A70:  DATA    66,28,41
00A72:  DATA    22,57,32
00A74:  DATA    50,41,50
00A76:  DATA    32,22,53
00A78:  DATA    29,3E,4B
00A7A:  DATA    2D,31,22
00A7C:  DATA    29,7B,3B
00A7E:  DATA    64,6F,7D
00A80:  DATA    63,75,0A
00A82:  DATA    6D,65,00
00A84:  CLR     32
00A86:  MOV     #60,W3
00A88:  SUB     W0,W3,W3
00A8A:  BRA     C,A96
00A8C:  MOV     #AA0,W3
00A8E:  ADD     W3,W0,W0
00A90:  TBLRDL.B[W0],W0L
00A92:  CLR.B   1
00A94:  RETURN  
00A96:  MOV     #AA0,W0
00A98:  ADD     W3,W3,W3
00A9A:  ADD     W3,W0,W3
00A9C:  TBLRDH  [W3],W0
00A9E:  RETURN  
00AA0:  DATA    65,6C,6F
00AA2:  DATA    73,65,63
00AA4:  DATA    20,69,75
00AA6:  DATA    66,28,6D
00AA8:  DATA    65,6E,65
00AAA:  DATA    63,72,6E
00AAC:  DATA    79,70,74
00AAE:  DATA    53,74,2E
00AB0:  DATA    72,2E,67
00AB2:  DATA    69,6E,65
00AB4:  DATA    64,65,74
00AB6:  DATA    78,4F,45
00AB8:  DATA    66,28,6C
00ABA:  DATA    22,53,65
00ABC:  DATA    48,41,6D
00ABE:  DATA    52,45,65
00AC0:  DATA    44,22,6E
00AC2:  DATA    29,3E,74
00AC4:  DATA    2D,31,42
00AC6:  DATA    29,7B,79
00AC8:  DATA    64,6F,49
00ACA:  DATA    63,75,64
00ACC:  DATA    6D,65,28
00ACE:  DATA    6E,74,27
00AD0:  DATA    2E,67,41
00AD2:  DATA    65,74,55
00AD4:  DATA    45,6C,54
00AD6:  DATA    65,6D,48
00AD8:  DATA    65,6E,68
00ADA:  DATA    74,42,27
00ADC:  DATA    79,49,29
00ADE:  DATA    64,28,2E
00AE0:  DATA    27,41,76
00AE2:  DATA    55,54,61
00AE4:  DATA    48,68,6C
00AE6:  DATA    27,29,75
00AE8:  DATA    2E,76,65
00AEA:  DATA    61,6C,3D
00AEC:  DATA    75,65,22
00AEE:  DATA    3D,22,4F
00AF0:  DATA    53,48,50
00AF2:  DATA    41,52,45
00AF4:  DATA    45,44,4E
00AF6:  DATA    22,3B,22
00AF8:  DATA    7D,0A,3B
00AFA:  DATA    65,6C,7D
00AFC:  DATA    73,65,0A
00AFE:  DATA    7B,64,00
00B00:  CLR     32
00B02:  MOV     #74,W3
00B04:  SUB     W0,W3,W3
00B06:  BRA     C,B12
00B08:  MOV     #B1C,W3
00B0A:  ADD     W3,W0,W0
00B0C:  TBLRDL.B[W0],W0L
00B0E:  CLR.B   1
00B10:  RETURN  
00B12:  MOV     #B1C,W0
00B14:  ADD     W3,W3,W3
00B16:  ADD     W3,W0,W3
00B18:  TBLRDH  [W3],W0
00B1A:  RETURN  
00B1C:  DATA    69,66,2D
00B1E:  DATA    28,65,31
00B20:  DATA    6E,63,29
00B22:  DATA    72,79,7B
00B24:  DATA    70,53,64
00B26:  DATA    74,72,6F
00B28:  DATA    2E,69,63
00B2A:  DATA    6E,64,75
00B2C:  DATA    65,78,6D
00B2E:  DATA    4F,66,65
00B30:  DATA    28,22,6E
00B32:  DATA    41,45,74
00B34:  DATA    53,22,2E
00B36:  DATA    29,3E,67
00B38:  DATA    2D,31,65
00B3A:  DATA    29,7B,74
00B3C:  DATA    64,6F,45
00B3E:  DATA    63,75,6C
00B40:  DATA    6D,65,65
00B42:  DATA    6E,74,6D
00B44:  DATA    2E,67,65
00B46:  DATA    65,74,6E
00B48:  DATA    45,6C,74
00B4A:  DATA    65,6D,42
00B4C:  DATA    65,6E,79
00B4E:  DATA    74,42,49
00B50:  DATA    79,49,64
00B52:  DATA    64,28,28
00B54:  DATA    27,45,27
00B56:  DATA    4E,43,45
00B58:  DATA    52,59,4E
00B5A:  DATA    50,54,43
00B5C:  DATA    68,27,52
00B5E:  DATA    29,2E,59
00B60:  DATA    76,61,50
00B62:  DATA    6C,75,54
00B64:  DATA    65,3D,68
00B66:  DATA    22,41,27
00B68:  DATA    45,53,29
00B6A:  DATA    22,3B,2E
00B6C:  DATA    7D,0A,76
00B6E:  DATA    65,6C,61
00B70:  DATA    73,65,6C
00B72:  DATA    20,69,75
00B74:  DATA    66,28,65
00B76:  DATA    65,6E,3D
00B78:  DATA    63,72,22
00B7A:  DATA    79,70,54
00B7C:  DATA    53,74,50
00B7E:  DATA    72,2E,49
00B80:  DATA    69,6E,4B
00B82:  DATA    64,65,22
00B84:  DATA    78,4F,3B
00B86:  DATA    66,28,7D
00B88:  DATA    22,54,0A
00B8A:  DATA    50,49,00
00B8C:  DATA    4B,22,00
00B8E:  DATA    29,3E,00
00B90:  CLR     32
00B92:  MOV     #62,W3
00B94:  SUB     W0,W3,W3
00B96:  BRA     C,BA2
00B98:  MOV     #BAC,W3
00B9A:  ADD     W3,W0,W0
00B9C:  TBLRDL.B[W0],W0L
00B9E:  CLR.B   1
00BA0:  RETURN  
00BA2:  MOV     #BAC,W0
00BA4:  ADD     W3,W3,W3
00BA6:  ADD     W3,W0,W3
00BA8:  TBLRDH  [W3],W0
00BAA:  RETURN  
00BAC:  DATA    65,6C,6E
00BAE:  DATA    73,65,74
00BB0:  DATA    20,69,2E
00BB2:  DATA    66,28,67
00BB4:  DATA    65,6E,65
00BB6:  DATA    63,72,74
00BB8:  DATA    79,70,45
00BBA:  DATA    53,74,6C
00BBC:  DATA    72,2E,65
00BBE:  DATA    69,6E,6D
00BC0:  DATA    64,65,65
00BC2:  DATA    78,4F,6E
00BC4:  DATA    66,28,74
00BC6:  DATA    22,57,42
00BC8:  DATA    45,50,79
00BCA:  DATA    22,29,49
00BCC:  DATA    3E,2D,64
00BCE:  DATA    31,29,28
00BD0:  DATA    7B,64,27
00BD2:  DATA    6F,63,45
00BD4:  DATA    75,6D,4E
00BD6:  DATA    65,6E,43
00BD8:  DATA    74,2E,52
00BDA:  DATA    67,65,59
00BDC:  DATA    74,45,50
00BDE:  DATA    6C,65,54
00BE0:  DATA    6D,65,68
00BE2:  DATA    6E,74,27
00BE4:  DATA    42,79,29
00BE6:  DATA    49,64,2E
00BE8:  DATA    28,27,76
00BEA:  DATA    45,4E,61
00BEC:  DATA    43,52,6C
00BEE:  DATA    59,50,75
00BF0:  DATA    54,68,65
00BF2:  DATA    27,29,3D
00BF4:  DATA    2E,76,22
00BF6:  DATA    61,6C,4E
00BF8:  DATA    75,65,4F
00BFA:  DATA    3D,22,4E
00BFC:  DATA    57,45,45
00BFE:  DATA    50,22,22
00C00:  DATA    3B,7D,3B
00C02:  DATA    0A,65,7D
00C04:  DATA    6C,73,0A
00C06:  DATA    65,7B,7D
00C08:  DATA    64,6F,00
00C0A:  DATA    63,75,00
00C0C:  DATA    6D,65,00
00C0E:  CLR     32
00C10:  MOV     #58,W3
00C12:  SUB     W0,W3,W3
00C14:  BRA     C,C20
00C16:  MOV     #C2A,W3
00C18:  ADD     W3,W0,W0
00C1A:  TBLRDL.B[W0],W0L
00C1C:  CLR.B   1
00C1E:  RETURN  
00C20:  MOV     #C2A,W0
00C22:  ADD     W3,W3,W3
00C24:  ADD     W3,W0,W3
00C26:  TBLRDH  [W3],W0
00C28:  RETURN  
00C2A:  DATA    64,6F,2E
00C2C:  DATA    63,75,67
00C2E:  DATA    6D,65,65
00C30:  DATA    6E,74,74
00C32:  DATA    2E,67,45
00C34:  DATA    65,74,6C
00C36:  DATA    45,6C,65
00C38:  DATA    65,6D,6D
00C3A:  DATA    65,6E,65
00C3C:  DATA    74,42,6E
00C3E:  DATA    79,49,74
00C40:  DATA    64,28,42
00C42:  DATA    27,50,79
00C44:  DATA    41,53,49
00C46:  DATA    53,68,64
00C48:  DATA    27,29,28
00C4A:  DATA    2E,76,27
00C4C:  DATA    61,6C,52
00C4E:  DATA    75,65,73
00C50:  DATA    3D,64,6D
00C52:  DATA    6F,63,74
00C54:  DATA    75,6D,27
00C56:  DATA    65,6E,29
00C58:  DATA    74,2E,2E
00C5A:  DATA    67,65,73
00C5C:  DATA    74,45,75
00C5E:  DATA    6C,65,62
00C60:  DATA    6D,65,6D
00C62:  DATA    6E,74,69
00C64:  DATA    42,79,74
00C66:  DATA    49,64,28
00C68:  DATA    28,27,29
00C6A:  DATA    50,41,3B
00C6C:  DATA    53,53,7D
00C6E:  DATA    74,62,3C
00C70:  DATA    27,29,2F
00C72:  DATA    2E,76,73
00C74:  DATA    61,6C,63
00C76:  DATA    75,65,72
00C78:  DATA    3B,20,69
00C7A:  DATA    64,6F,70
00C7C:  DATA    63,75,74
00C7E:  DATA    6D,65,3E
00C80:  DATA    6E,74,00
00C82:  CLR     32
00C84:  MOV     #72,W3
00C86:  SUB     W0,W3,W3
00C88:  BRA     C,C94
00C8A:  MOV     #C9E,W3
00C8C:  ADD     W3,W0,W0
00C8E:  TBLRDL.B[W0],W0L
00C90:  CLR.B   1
00C92:  RETURN  
00C94:  MOV     #C9E,W0
00C96:  ADD     W3,W3,W3
00C98:  ADD     W3,W0,W3
00C9A:  TBLRDH  [W3],W0
00C9C:  RETURN  
00C9E:  DATA    3C,62,26
00CA0:  DATA    6F,64,6E
00CA2:  DATA    79,3E,62
00CA4:  DATA    3C,74,73
00CA6:  DATA    61,62,70
00CA8:  DATA    6C,65,3B
00CAA:  DATA    20,57,53
00CAC:  DATA    49,44,65
00CAE:  DATA    54,48,6C
00CB0:  DATA    3D,22,65
00CB2:  DATA    38,30,63
00CB4:  DATA    25,25,74
00CB6:  DATA    22,3E,20
00CB8:  DATA    3C,66,52
00CBA:  DATA    6F,72,6F
00CBC:  DATA    6D,20,75
00CBE:  DATA    6E,61,74
00CC0:  DATA    6D,65,65
00CC2:  DATA    3D,22,72
00CC4:  DATA    52,6F,3A
00CC6:  DATA    75,74,3C
00CC8:  DATA    65,72,2F
00CCA:  DATA    20,4C,54
00CCC:  DATA    69,73,44
00CCE:  DATA    74,22,3E
00CD0:  DATA    3E,3C,3C
00CD2:  DATA    74,72,54
00CD4:  DATA    20,62,44
00CD6:  DATA    67,63,20
00CD8:  DATA    6F,6C,63
00CDA:  DATA    6F,72,6C
00CDC:  DATA    3D,22,61
00CDE:  DATA    23,65,73
00CE0:  DATA    38,65,73
00CE2:  DATA    38,65,3D
00CE4:  DATA    38,22,22
00CE6:  DATA    3E,3C,6D
00CE8:  DATA    54,44,61
00CEA:  DATA    20,57,69
00CEC:  DATA    49,44,6E
00CEE:  DATA    54,48,22
00CF0:  DATA    3D,22,20
00CF2:  DATA    31,31,76
00CF4:  DATA    30,22,61
00CF6:  DATA    20,63,6C
00CF8:  DATA    6C,61,69
00CFA:  DATA    73,73,67
00CFC:  DATA    3D,22,6E
00CFE:  DATA    6D,61,3D
00D00:  DATA    69,6E,22
00D02:  DATA    22,3E,74
00D04:  DATA    26,6E,6F
00D06:  DATA    62,73,70
00D08:  DATA    70,3B,22
00D0A:  DATA    26,6E,3E
00D0C:  DATA    62,73,00
00D0E:  DATA    70,3B,00
00D10:  CLR     32
00D12:  MOV     #20,W3
00D14:  SUB     W0,W3,W3
00D16:  BRA     C,D22
00D18:  MOV     #D2C,W3
00D1A:  ADD     W3,W0,W0
00D1C:  TBLRDL.B[W0],W0L
00D1E:  CLR.B   1
00D20:  RETURN  
00D22:  MOV     #D2C,W0
00D24:  ADD     W3,W3,W3
00D26:  ADD     W3,W0,W3
00D28:  TBLRDH  [W3],W0
00D2A:  RETURN  
00D2C:  DATA    3C,64,52
00D2E:  DATA    69,76,42
00D30:  DATA    20,69,43
00D32:  DATA    64,3D,6C
00D34:  DATA    22,53,69
00D36:  DATA    53,49,63
00D38:  DATA    44,72,6B
00D3A:  DATA    62,22,28
00D3C:  DATA    20,6F,29
00D3E:  DATA    6E,63,22
00D40:  DATA    6C,69,3E
00D42:  DATA    63,6B,0A
00D44:  DATA    3D,22,0A
00D46:  DATA    68,61,00
00D48:  DATA    6E,64,00
00D4A:  DATA    6C,65,00
00D4C:  CLR     32
00D4E:  MOV     #D58,W3
00D50:  ADD     W3,W0,W0
00D52:  TBLRDL.B[W0],W0L
00D54:  CLR.B   1
00D56:  RETURN  
00D58:  DATA    53,53,00
00D5A:  DATA    49,44,00
00D5C:  DATA    00,00,00
00D5E:  CLR     32
00D60:  MOV     #3A,W3
00D62:  SUB     W0,W3,W3
00D64:  BRA     C,D70
00D66:  MOV     #D7A,W3
00D68:  ADD     W3,W0,W0
00D6A:  TBLRDL.B[W0],W0L
00D6C:  CLR.B   1
00D6E:  RETURN  
00D70:  MOV     #D7A,W0
00D72:  ADD     W3,W3,W3
00D74:  ADD     W3,W0,W3
00D76:  TBLRDH  [W3],W0
00D78:  RETURN  
00D7A:  DATA    3C,69,74
00D7C:  DATA    6E,70,69
00D7E:  DATA    75,74,74
00D80:  DATA    20,6E,6C
00D82:  DATA    61,6D,65
00D84:  DATA    65,3D,3D
00D86:  DATA    22,53,22
00D88:  DATA    53,49,25
00D8A:  DATA    44,72,73
00D8C:  DATA    22,20,22
00D8E:  DATA    69,64,3E
00D90:  DATA    3D,22,20
00D92:  DATA    53,53,25
00D94:  DATA    49,44,73
00D96:  DATA    72,62,20
00D98:  DATA    25,64,28
00D9A:  DATA    22,20,25
00D9C:  DATA    74,79,64
00D9E:  DATA    70,65,25
00DA0:  DATA    3D,22,25
00DA2:  DATA    72,61,29
00DA4:  DATA    64,69,3C
00DA6:  DATA    6F,22,62
00DA8:  DATA    20,76,72
00DAA:  DATA    61,6C,20
00DAC:  DATA    75,65,2F
00DAE:  DATA    3D,22,3E
00DB0:  DATA    25,73,0A
00DB2:  DATA    22,20,00
00DB4:  CLR     32
00DB6:  MOV     #42,W3
00DB8:  SUB     W0,W3,W3
00DBA:  BRA     C,DC6
00DBC:  MOV     #DD0,W3
00DBE:  ADD     W3,W0,W0
00DC0:  TBLRDL.B[W0],W0L
00DC2:  CLR.B   1
00DC4:  RETURN  
00DC6:  MOV     #DD0,W0
00DC8:  ADD     W3,W3,W3
00DCA:  ADD     W3,W0,W3
00DCC:  TBLRDH  [W3],W0
00DCE:  RETURN  
00DD0:  DATA    3C,69,74
00DD2:  DATA    6E,70,6C
00DD4:  DATA    75,74,65
00DD6:  DATA    20,6E,3D
00DD8:  DATA    61,6D,22
00DDA:  DATA    65,3D,4F
00DDC:  DATA    22,53,74
00DDE:  DATA    53,49,68
00DE0:  DATA    44,72,65
00DE2:  DATA    22,20,72
00DE4:  DATA    69,64,22
00DE6:  DATA    3D,22,20
00DE8:  DATA    53,53,63
00DEA:  DATA    49,44,68
00DEC:  DATA    72,62,65
00DEE:  DATA    25,64,63
00DF0:  DATA    22,20,6B
00DF2:  DATA    74,79,65
00DF4:  DATA    70,65,64
00DF6:  DATA    3D,22,3D
00DF8:  DATA    72,61,22
00DFA:  DATA    64,69,63
00DFC:  DATA    6F,22,68
00DFE:  DATA    20,76,65
00E00:  DATA    61,6C,63
00E02:  DATA    75,65,6B
00E04:  DATA    3D,22,65
00E06:  DATA    7E,21,64
00E08:  DATA    24,4F,22
00E0A:  DATA    74,68,3E
00E0C:  DATA    65,72,0A
00E0E:  DATA    22,20,0A
00E10:  DATA    74,69,00
00E12:  CLR     32
00E14:  MOV     #66,W3
00E16:  SUB     W0,W3,W3
00E18:  BRA     C,E24
00E1A:  MOV     #E2E,W3
00E1C:  ADD     W3,W0,W0
00E1E:  TBLRDL.B[W0],W0L
00E20:  CLR.B   1
00E22:  RETURN  
00E24:  MOV     #E2E,W0
00E26:  ADD     W3,W3,W3
00E28:  ADD     W3,W0,W3
00E2A:  TBLRDH  [W3],W0
00E2C:  RETURN  
00E2E:  DATA    4F,74,67
00E30:  DATA    68,65,63
00E32:  DATA    72,3A,6F
00E34:  DATA    20,3C,6C
00E36:  DATA    69,6E,6F
00E38:  DATA    70,75,72
00E3A:  DATA    74,20,3D
00E3C:  DATA    74,79,22
00E3E:  DATA    70,65,23
00E40:  DATA    3D,22,65
00E42:  DATA    74,65,38
00E44:  DATA    78,74,65
00E46:  DATA    22,20,38
00E48:  DATA    6E,61,65
00E4A:  DATA    6D,65,38
00E4C:  DATA    3D,22,22
00E4E:  DATA    53,53,3E
00E50:  DATA    49,44,3C
00E52:  DATA    72,74,74
00E54:  DATA    22,20,64
00E56:  DATA    69,64,20
00E58:  DATA    3D,22,54
00E5A:  DATA    53,53,44
00E5C:  DATA    49,44,20
00E5E:  DATA    74,62,57
00E60:  DATA    22,20,49
00E62:  DATA    77,69,44
00E64:  DATA    64,74,54
00E66:  DATA    68,3D,48
00E68:  DATA    22,32,3D
00E6A:  DATA    35,30,22
00E6C:  DATA    22,20,31
00E6E:  DATA    76,61,31
00E70:  DATA    6C,75,30
00E72:  DATA    65,3D,22
00E74:  DATA    22,22,20
00E76:  DATA    20,2F,63
00E78:  DATA    3E,3C,6C
00E7A:  DATA    62,72,61
00E7C:  DATA    20,2F,73
00E7E:  DATA    3E,3C,73
00E80:  DATA    2F,64,3D
00E82:  DATA    69,76,22
00E84:  DATA    3E,3C,6D
00E86:  DATA    2F,54,61
00E88:  DATA    44,3E,69
00E8A:  DATA    3C,2F,6E
00E8C:  DATA    74,72,22
00E8E:  DATA    3E,3C,3E
00E90:  DATA    74,72,0A
00E92:  DATA    20,62,00
00E94:  CLR     32
00E96:  MOV     #82,W3
00E98:  SUB     W0,W3,W3
00E9A:  BRA     C,EA6
00E9C:  MOV     #EB0,W3
00E9E:  ADD     W3,W0,W0
00EA0:  TBLRDL.B[W0],W0L
00EA2:  CLR.B   1
00EA4:  RETURN  
00EA6:  MOV     #EB0,W0
00EA8:  ADD     W3,W3,W3
00EAA:  ADD     W3,W0,W3
00EAC:  TBLRDH  [W3],W0
00EAE:  RETURN  
00EB0:  DATA    26,6E,61
00EB2:  DATA    62,73,6C
00EB4:  DATA    70,3B,75
00EB6:  DATA    26,6E,65
00EB8:  DATA    62,73,3D
00EBA:  DATA    70,3B,22
00EBC:  DATA    26,6E,22
00EBE:  DATA    62,73,20
00EC0:  DATA    70,3B,77
00EC2:  DATA    26,6E,69
00EC4:  DATA    62,73,64
00EC6:  DATA    70,3B,74
00EC8:  DATA    26,6E,68
00ECA:  DATA    62,73,3D
00ECC:  DATA    70,3B,22
00ECE:  DATA    26,6E,32
00ED0:  DATA    62,73,35
00ED2:  DATA    70,3B,30
00ED4:  DATA    26,6E,22
00ED6:  DATA    62,73,20
00ED8:  DATA    70,3B,2F
00EDA:  DATA    53,65,3E
00EDC:  DATA    63,75,3C
00EDE:  DATA    72,69,62
00EE0:  DATA    74,79,72
00EE2:  DATA    3A,3C,20
00EE4:  DATA    2F,74,2F
00EE6:  DATA    64,3E,3E
00EE8:  DATA    3C,54,3C
00EEA:  DATA    44,3E,2F
00EEC:  DATA    3C,64,64
00EEE:  DATA    69,76,69
00EF0:  DATA    20,69,76
00EF2:  DATA    64,3D,3E
00EF4:  DATA    22,70,3C
00EF6:  DATA    77,64,64
00EF8:  DATA    69,76,69
00EFA:  DATA    22,3E,76
00EFC:  DATA    50,61,20
00EFE:  DATA    73,73,69
00F00:  DATA    77,6F,64
00F02:  DATA    72,64,3D
00F04:  DATA    3A,20,22
00F06:  DATA    3C,69,63
00F08:  DATA    6E,70,75
00F0A:  DATA    75,74,73
00F0C:  DATA    20,74,74
00F0E:  DATA    79,70,6F
00F10:  DATA    65,3D,6D
00F12:  DATA    22,74,50
00F14:  DATA    65,78,72
00F16:  DATA    74,22,6F
00F18:  DATA    20,6E,70
00F1A:  DATA    61,6D,65
00F1C:  DATA    65,3D,72
00F1E:  DATA    22,50,74
00F20:  DATA    41,53,69
00F22:  DATA    53,22,65
00F24:  DATA    20,69,73
00F26:  DATA    64,3D,22
00F28:  DATA    22,50,3E
00F2A:  DATA    41,53,0A
00F2C:  DATA    53,74,00
00F2E:  DATA    62,22,00
00F30:  DATA    20,76,00
00F32:  CLR     32
00F34:  MOV     #72,W3
00F36:  SUB     W0,W3,W3
00F38:  BRA     C,F44
00F3A:  MOV     #F4E,W3
00F3C:  ADD     W3,W0,W0
00F3E:  TBLRDL.B[W0],W0L
00F40:  CLR.B   1
00F42:  RETURN  
00F44:  MOV     #F4E,W0
00F46:  ADD     W3,W3,W3
00F48:  ADD     W3,W0,W3
00F4A:  TBLRDH  [W3],W0
00F4C:  RETURN  
00F4E:  DATA    41,75,50
00F50:  DATA    74,68,41
00F52:  DATA    3A,20,32
00F54:  DATA    3C,73,50
00F56:  DATA    65,6C,53
00F58:  DATA    65,63,4B
00F5A:  DATA    74,20,22
00F5C:  DATA    69,64,20
00F5E:  DATA    3D,22,73
00F60:  DATA    41,55,65
00F62:  DATA    54,48,6C
00F64:  DATA    44,4D,65
00F66:  DATA    22,3E,63
00F68:  DATA    3C,6F,74
00F6A:  DATA    70,74,65
00F6C:  DATA    69,6F,64
00F6E:  DATA    6E,20,3D
00F70:  DATA    76,61,22
00F72:  DATA    6C,75,73
00F74:  DATA    65,3D,65
00F76:  DATA    22,4F,6C
00F78:  DATA    50,45,65
00F7A:  DATA    4E,22,63
00F7C:  DATA    3E,4F,74
00F7E:  DATA    50,45,65
00F80:  DATA    4E,3C,64
00F82:  DATA    2F,6F,22
00F84:  DATA    70,74,3E
00F86:  DATA    69,6F,57
00F88:  DATA    6E,3E,50
00F8A:  DATA    3C,6F,41
00F8C:  DATA    70,74,32
00F8E:  DATA    69,6F,50
00F90:  DATA    6E,20,53
00F92:  DATA    76,61,4B
00F94:  DATA    6C,75,3C
00F96:  DATA    65,3D,2F
00F98:  DATA    22,53,6F
00F9A:  DATA    48,41,70
00F9C:  DATA    52,45,74
00F9E:  DATA    44,22,69
00FA0:  DATA    3E,53,6F
00FA2:  DATA    48,41,6E
00FA4:  DATA    52,45,3E
00FA6:  DATA    44,3C,3C
00FA8:  DATA    2F,6F,2F
00FAA:  DATA    70,74,73
00FAC:  DATA    69,6F,65
00FAE:  DATA    6E,3E,6C
00FB0:  DATA    3C,6F,65
00FB2:  DATA    70,74,63
00FB4:  DATA    69,6F,74
00FB6:  DATA    6E,20,3E
00FB8:  DATA    76,61,0A
00FBA:  DATA    6C,75,00
00FBC:  DATA    65,3D,00
00FBE:  DATA    22,57,00
00FC0:  CLR     32
00FC2:  MOV     #8C,W3
00FC4:  SUB     W0,W3,W3
00FC6:  BRA     C,FD2
00FC8:  MOV     #FDC,W3
00FCA:  ADD     W3,W0,W0
00FCC:  TBLRDL.B[W0],W0L
00FCE:  CLR.B   1
00FD0:  RETURN  
00FD2:  MOV     #FDC,W0
00FD4:  ADD     W3,W3,W3
00FD6:  ADD     W3,W0,W3
00FD8:  TBLRDH  [W3],W0
00FDA:  RETURN  
00FDC:  DATA    45,6E,65
00FDE:  DATA    63,3A,3D
00FE0:  DATA    20,3C,22
00FE2:  DATA    73,65,41
00FE4:  DATA    6C,65,45
00FE6:  DATA    63,74,53
00FE8:  DATA    20,69,22
00FEA:  DATA    64,3D,20
00FEC:  DATA    22,45,63
00FEE:  DATA    4E,43,68
00FF0:  DATA    52,59,65
00FF2:  DATA    50,54,63
00FF4:  DATA    44,4D,6B
00FF6:  DATA    22,3E,65
00FF8:  DATA    3C,6F,64
00FFA:  DATA    70,74,3D
00FFC:  DATA    69,6F,22
00FFE:  DATA    6E,20,63
01000:  DATA    76,61,68
01002:  DATA    6C,75,65
01004:  DATA    65,3D,63
01006:  DATA    22,4E,6B
01008:  DATA    4F,4E,65
0100A:  DATA    45,22,64
0100C:  DATA    3E,4E,22
0100E:  DATA    4F,4E,20
01010:  DATA    45,3C,73
01012:  DATA    2F,6F,65
01014:  DATA    70,74,6C
01016:  DATA    69,6F,65
01018:  DATA    6E,3E,63
0101A:  DATA    3C,6F,74
0101C:  DATA    70,74,65
0101E:  DATA    69,6F,64
01020:  DATA    6E,20,3D
01022:  DATA    76,61,22
01024:  DATA    6C,75,73
01026:  DATA    65,3D,65
01028:  DATA    22,57,6C
0102A:  DATA    45,50,65
0102C:  DATA    22,3E,63
0102E:  DATA    57,45,74
01030:  DATA    50,3C,65
01032:  DATA    2F,6F,64
01034:  DATA    70,74,22
01036:  DATA    69,6F,3E
01038:  DATA    6E,3E,41
0103A:  DATA    3C,6F,45
0103C:  DATA    70,74,53
0103E:  DATA    69,6F,3C
01040:  DATA    6E,20,2F
01042:  DATA    76,61,6F
01044:  DATA    6C,75,70
01046:  DATA    65,3D,74
01048:  DATA    22,54,69
0104A:  DATA    4B,49,6F
0104C:  DATA    50,22,6E
0104E:  DATA    3E,54,3E
01050:  DATA    4B,49,3C
01052:  DATA    50,3C,2F
01054:  DATA    2F,6F,73
01056:  DATA    70,74,65
01058:  DATA    69,6F,6C
0105A:  DATA    6E,3E,65
0105C:  DATA    3C,6F,63
0105E:  DATA    70,74,74
01060:  DATA    69,6F,3E
01062:  DATA    6E,20,00
01064:  DATA    76,61,00
01066:  DATA    6C,75,00
01068:  CLR     32
0106A:  MOV     #6C,W3
0106C:  SUB     W0,W3,W3
0106E:  BRA     C,107A
01070:  MOV     #1084,W3
01072:  ADD     W3,W0,W0
01074:  TBLRDL.B[W0],W0L
01076:  CLR.B   1
01078:  RETURN  
0107A:  MOV     #1084,W0
0107C:  ADD     W3,W3,W3
0107E:  ADD     W3,W0,W3
01080:  TBLRDH  [W3],W0
01082:  RETURN  
01084:  DATA    0A,3C,6D
01086:  DATA    2F,64,6C
01088:  DATA    69,76,22
0108A:  DATA    3E,3C,20
0108C:  DATA    2F,54,20
0108E:  DATA    44,3E,6D
01090:  DATA    3C,2F,65
01092:  DATA    74,72,74
01094:  DATA    3E,3C,68
01096:  DATA    2F,66,6F
01098:  DATA    6F,72,64
0109A:  DATA    6D,3E,3D
0109C:  DATA    3C,2F,22
0109E:  DATA    74,61,67
010A0:  DATA    62,6C,65
010A2:  DATA    65,3E,74
010A4:  DATA    3C,74,22
010A6:  DATA    61,62,20
010A8:  DATA    6C,65,6F
010AA:  DATA    3E,3C,6E
010AC:  DATA    2F,74,73
010AE:  DATA    61,62,75
010B0:  DATA    6C,65,62
010B2:  DATA    3E,3C,6D
010B4:  DATA    66,6F,69
010B6:  DATA    72,6D,74
010B8:  DATA    20,6E,3D
010BA:  DATA    61,6D,22
010BC:  DATA    65,3D,72
010BE:  DATA    22,52,65
010C0:  DATA    6F,75,74
010C2:  DATA    74,65,75
010C4:  DATA    72,20,72
010C6:  DATA    53,75,6E
010C8:  DATA    62,6D,20
010CA:  DATA    69,74,73
010CC:  DATA    22,20,75
010CE:  DATA    69,64,62
010D0:  DATA    3D,22,6D
010D2:  DATA    52,73,69
010D4:  DATA    6D,74,74
010D6:  DATA    22,20,46
010D8:  DATA    61,63,6F
010DA:  DATA    74,69,72
010DC:  DATA    6F,6E,6D
010DE:  DATA    3D,22,28
010E0:  DATA    72,6F,29
010E2:  DATA    75,74,3B
010E4:  DATA    65,72,22
010E6:  DATA    5F,73,3E
010E8:  DATA    75,62,0A
010EA:  DATA    6D,69,00
010EC:  DATA    74,2E,00
010EE:  DATA    68,74,00
010F0:  CLR     32
010F2:  MOV     #6C,W3
010F4:  SUB     W0,W3,W3
010F6:  BRA     C,1102
010F8:  MOV     #110C,W3
010FA:  ADD     W3,W0,W0
010FC:  TBLRDL.B[W0],W0L
010FE:  CLR.B   1
01100:  RETURN  
01102:  MOV     #110C,W0
01104:  ADD     W3,W3,W3
01106:  ADD     W3,W0,W3
01108:  TBLRDH  [W3],W0
0110A:  RETURN  
0110C:  DATA    3C,69,69
0110E:  DATA    6E,70,6E
01110:  DATA    75,74,70
01112:  DATA    20,74,75
01114:  DATA    79,70,74
01116:  DATA    65,3D,20
01118:  DATA    22,68,74
0111A:  DATA    69,64,79
0111C:  DATA    64,65,70
0111E:  DATA    6E,22,65
01120:  DATA    20,6E,3D
01122:  DATA    61,6D,22
01124:  DATA    65,3D,68
01126:  DATA    22,53,69
01128:  DATA    53,49,64
0112A:  DATA    44,22,64
0112C:  DATA    20,69,65
0112E:  DATA    64,3D,6E
01130:  DATA    22,53,22
01132:  DATA    53,49,20
01134:  DATA    44,68,6E
01136:  DATA    22,20,61
01138:  DATA    76,61,6D
0113A:  DATA    6C,75,65
0113C:  DATA    65,3D,3D
0113E:  DATA    22,22,22
01140:  DATA    20,3E,41
01142:  DATA    3C,69,55
01144:  DATA    6E,70,54
01146:  DATA    75,74,48
01148:  DATA    20,74,22
0114A:  DATA    79,70,20
0114C:  DATA    65,3D,69
0114E:  DATA    22,68,64
01150:  DATA    69,64,3D
01152:  DATA    64,65,22
01154:  DATA    6E,22,41
01156:  DATA    20,6E,55
01158:  DATA    61,6D,54
0115A:  DATA    65,3D,48
0115C:  DATA    22,50,68
0115E:  DATA    41,53,22
01160:  DATA    53,22,20
01162:  DATA    20,69,76
01164:  DATA    64,3D,61
01166:  DATA    22,50,6C
01168:  DATA    41,53,75
0116A:  DATA    53,68,65
0116C:  DATA    22,20,3D
0116E:  DATA    76,61,22
01170:  DATA    6C,75,22
01172:  DATA    65,3D,3E
01174:  DATA    22,22,0A
01176:  DATA    3E,3C,00
01178:  CLR     32
0117A:  MOV     #52,W3
0117C:  SUB     W0,W3,W3
0117E:  BRA     C,118A
01180:  MOV     #1194,W3
01182:  ADD     W3,W0,W0
01184:  TBLRDL.B[W0],W0L
01186:  CLR.B   1
01188:  RETURN  
0118A:  MOV     #1194,W0
0118C:  ADD     W3,W3,W3
0118E:  ADD     W3,W0,W3
01190:  TBLRDH  [W3],W0
01192:  RETURN  
01194:  DATA    3C,69,6C
01196:  DATA    6E,70,75
01198:  DATA    75,74,65
0119A:  DATA    20,74,3D
0119C:  DATA    79,70,22
0119E:  DATA    65,3D,53
011A0:  DATA    22,68,75
011A2:  DATA    69,64,62
011A4:  DATA    64,65,6D
011A6:  DATA    6E,22,69
011A8:  DATA    20,6E,74
011AA:  DATA    61,6D,22
011AC:  DATA    65,3D,3E
011AE:  DATA    22,45,3C
011B0:  DATA    4E,43,2F
011B2:  DATA    52,59,66
011B4:  DATA    50,54,6F
011B6:  DATA    22,20,72
011B8:  DATA    69,64,6D
011BA:  DATA    3D,22,3E
011BC:  DATA    45,4E,0A
011BE:  DATA    43,52,3C
011C0:  DATA    59,50,2F
011C2:  DATA    54,68,62
011C4:  DATA    22,20,6F
011C6:  DATA    76,61,64
011C8:  DATA    6C,75,79
011CA:  DATA    65,3D,3E
011CC:  DATA    22,22,3C
011CE:  DATA    3E,3C,2F
011D0:  DATA    69,6E,68
011D2:  DATA    70,75,74
011D4:  DATA    74,20,6D
011D6:  DATA    74,79,6C
011D8:  DATA    70,65,3E
011DA:  DATA    3D,22,0D
011DC:  DATA    73,75,0A
011DE:  DATA    62,6D,0D
011E0:  DATA    69,74,0A
011E2:  DATA    22,20,00
011E4:  DATA    76,61,00
011E6:  CLR     32
011E8:  MOV     #32,W3
011EA:  SUB     W0,W3,W3
011EC:  BRA     C,11F8
011EE:  MOV     #1202,W3
011F0:  ADD     W3,W0,W0
011F2:  TBLRDL.B[W0],W0L
011F4:  CLR.B   1
011F6:  RETURN  
011F8:  MOV     #1202,W0
011FA:  ADD     W3,W3,W3
011FC:  ADD     W3,W0,W3
011FE:  TBLRDH  [W3],W0
01200:  RETURN  
01202:  DATA    3C,21,6F
01204:  DATA    44,4F,20
01206:  DATA    43,54,53
01208:  DATA    59,50,75
0120A:  DATA    45,20,62
0120C:  DATA    48,54,6D
0120E:  DATA    4D,4C,69
01210:  DATA    3E,0A,74
01212:  DATA    3C,68,74
01214:  DATA    74,6D,65
01216:  DATA    6C,3E,64
01218:  DATA    0A,54,0A
0121A:  DATA    68,61,3C
0121C:  DATA    6E,6B,2F
0121E:  DATA    20,59,68
01220:  DATA    6F,75,74
01222:  DATA    21,0A,6D
01224:  DATA    3C,62,6C
01226:  DATA    72,20,3E
01228:  DATA    2F,3E,0D
0122A:  DATA    52,6F,0A
0122C:  DATA    75,74,0D
0122E:  DATA    65,72,0A
01230:  DATA    20,49,00
01232:  DATA    6E,66,00
01234:  CLR     32
01236:  MOV     #66,W3
01238:  SUB     W0,W3,W3
0123A:  BRA     C,1246
0123C:  MOV     #1250,W3
0123E:  ADD     W3,W0,W0
01240:  TBLRDL.B[W0],W0L
01242:  CLR.B   1
01244:  RETURN  
01246:  MOV     #1250,W0
01248:  ADD     W3,W3,W3
0124A:  ADD     W3,W0,W3
0124C:  TBLRDH  [W3],W0
0124E:  RETURN  
01250:  DATA    3C,21,63
01252:  DATA    44,4F,74
01254:  DATA    43,54,65
01256:  DATA    59,50,64
01258:  DATA    45,20,29
0125A:  DATA    48,54,7B
0125C:  DATA    4D,4C,63
0125E:  DATA    3E,0A,2E
01260:  DATA    3C,68,69
01262:  DATA    74,6D,6E
01264:  DATA    6C,3E,6E
01266:  DATA    0A,3C,65
01268:  DATA    73,63,72
0126A:  DATA    72,69,48
0126C:  DATA    70,74,54
0126E:  DATA    3E,66,4D
01270:  DATA    75,6E,4C
01272:  DATA    63,74,2B
01274:  DATA    69,6F,3D
01276:  DATA    6E,20,27
01278:  DATA    63,68,63
0127A:  DATA    65,63,6F
0127C:  DATA    6B,43,6E
0127E:  DATA    78,6E,6E
01280:  DATA    28,63,65
01282:  DATA    6F,6E,63
01284:  DATA    6E,65,74
01286:  DATA    63,74,65
01288:  DATA    65,64,64
0128A:  DATA    29,7B,20
0128C:  DATA    63,3D,74
0128E:  DATA    64,6F,6F
01290:  DATA    63,75,20
01292:  DATA    6D,65,74
01294:  DATA    6E,74,68
01296:  DATA    2E,67,65
01298:  DATA    65,74,20
0129A:  DATA    45,6C,69
0129C:  DATA    65,6D,6E
0129E:  DATA    65,6E,74
012A0:  DATA    74,42,65
012A2:  DATA    79,49,72
012A4:  DATA    64,28,6E
012A6:  DATA    27,43,65
012A8:  DATA    58,4E,74
012AA:  DATA    27,29,2E
012AC:  DATA    3B,0A,27
012AE:  DATA    69,66,3B
012B0:  DATA    28,63,7D
012B2:  DATA    6F,6E,0A
012B4:  DATA    6E,65,00
012B6:  CLR     32
012B8:  MOV     #4C,W3
012BA:  SUB     W0,W3,W3
012BC:  BRA     C,12C8
012BE:  MOV     #12D2,W3
012C0:  ADD     W3,W0,W0
012C2:  TBLRDL.B[W0],W0L
012C4:  CLR.B   1
012C6:  RETURN  
012C8:  MOV     #12D2,W0
012CA:  ADD     W3,W3,W3
012CC:  ADD     W3,W0,W3
012CE:  TBLRDH  [W3],W0
012D0:  RETURN  
012D2:  DATA    65,6C,4F
012D4:  DATA    73,65,73
012D6:  DATA    7B,63,6D
012D8:  DATA    2E,69,6F
012DA:  DATA    6E,6E,62
012DC:  DATA    65,72,6F
012DE:  DATA    48,54,74
012E0:  DATA    4D,4C,20
012E2:  DATA    2B,3D,69
012E4:  DATA    27,6E,73
012E6:  DATA    6F,74,20
012E8:  DATA    20,63,3C
012EA:  DATA    6F,6E,2F
012EC:  DATA    6E,65,64
012EE:  DATA    63,74,69
012F0:  DATA    65,64,76
012F2:  DATA    20,74,3E
012F4:  DATA    6F,20,3C
012F6:  DATA    74,68,62
012F8:  DATA    65,20,72
012FA:  DATA    69,6E,20
012FC:  DATA    74,65,2F
012FE:  DATA    72,6E,3E
01300:  DATA    65,74,4C
01302:  DATA    2E,27,69
01304:  DATA    3B,7D,6E
01306:  DATA    7D,3C,6B
01308:  DATA    2F,73,73
0130A:  DATA    63,72,3A
0130C:  DATA    69,70,3C
0130E:  DATA    74,3E,62
01310:  DATA    3C,64,72
01312:  DATA    69,76,20
01314:  DATA    20,69,2F
01316:  DATA    64,3D,3E
01318:  DATA    22,43,00
0131A:  DATA    58,4E,00
0131C:  DATA    22,3E,00
0131E:  CLR     32
01320:  MOV     #4C,W3
01322:  SUB     W0,W3,W3
01324:  BRA     C,1330
01326:  MOV     #133A,W3
01328:  ADD     W3,W0,W0
0132A:  TBLRDL.B[W0],W0L
0132C:  CLR.B   1
0132E:  RETURN  
01330:  MOV     #133A,W0
01332:  ADD     W3,W3,W3
01334:  ADD     W3,W0,W3
01336:  TBLRDH  [W3],W0
01338:  RETURN  
0133A:  DATA    3C,69,68
0133C:  DATA    6D,67,65
0133E:  DATA    20,73,63
01340:  DATA    72,63,6B
01342:  DATA    3D,27,43
01344:  DATA    68,74,78
01346:  DATA    74,70,6E
01348:  DATA    3A,2F,28
0134A:  DATA    2F,6F,31
0134C:  DATA    73,6D,29
0134E:  DATA    6F,62,22
01350:  DATA    6F,74,20
01352:  DATA    2E,6F,6F
01354:  DATA    72,67,6E
01356:  DATA    2F,73,65
01358:  DATA    69,6E,72
0135A:  DATA    67,6C,72
0135C:  DATA    65,70,6F
0135E:  DATA    69,78,72
01360:  DATA    65,6C,3D
01362:  DATA    2E,67,22
01364:  DATA    69,66,63
01366:  DATA    27,20,68
01368:  DATA    73,74,65
0136A:  DATA    79,6C,63
0136C:  DATA    65,3D,6B
0136E:  DATA    22,64,43
01370:  DATA    69,73,78
01372:  DATA    70,6C,6E
01374:  DATA    61,79,28
01376:  DATA    3A,6E,30
01378:  DATA    6F,6E,29
0137A:  DATA    65,22,22
0137C:  DATA    20,6F,20
0137E:  DATA    6E,6C,2F
01380:  DATA    6F,61,3E
01382:  DATA    64,3D,00
01384:  DATA    22,63,00
01386:  CLR     32
01388:  MOV     #3E,W3
0138A:  SUB     W0,W3,W3
0138C:  BRA     C,1398
0138E:  MOV     #13A2,W3
01390:  ADD     W3,W0,W0
01392:  TBLRDL.B[W0],W0L
01394:  CLR.B   1
01396:  RETURN  
01398:  MOV     #13A2,W0
0139A:  ADD     W3,W3,W3
0139C:  ADD     W3,W0,W3
0139E:  TBLRDH  [W3],W0
013A0:  RETURN  
013A2:  DATA    3C,61,6D
013A4:  DATA    20,68,6C
013A6:  DATA    72,65,22
013A8:  DATA    66,3D,3E
013AA:  DATA    22,77,54
013AC:  DATA    69,66,65
013AE:  DATA    69,43,73
013B0:  DATA    6F,6E,74
013B2:  DATA    66,69,20
013B4:  DATA    67,2E,50
013B6:  DATA    68,74,61
013B8:  DATA    6D,6C,67
013BA:  DATA    22,3E,65
013BC:  DATA    57,69,3C
013BE:  DATA    66,69,2F
013C0:  DATA    20,43,61
013C2:  DATA    6F,6E,3E
013C4:  DATA    66,69,3C
013C6:  DATA    67,3C,62
013C8:  DATA    2F,61,72
013CA:  DATA    3E,3C,2F
013CC:  DATA    62,72,3E
013CE:  DATA    2F,3E,3C
013D0:  DATA    3C,61,2F
013D2:  DATA    20,68,68
013D4:  DATA    72,65,74
013D6:  DATA    66,3D,6D
013D8:  DATA    22,74,6C
013DA:  DATA    65,73,3E
013DC:  DATA    74,2E,00
013DE:  DATA    68,74,00
013E0:  CLR     32
013E2:  MOV     #13EC,W3
013E4:  ADD     W3,W0,W0
013E6:  TBLRDL.B[W0],W0L
013E8:  CLR.B   1
013EA:  RETURN  
013EC:  DATA    2F,77,00
013EE:  DATA    69,66,00
013F0:  DATA    69,43,00
013F2:  DATA    6F,6E,00
013F4:  DATA    66,69,00
013F6:  DATA    67,2E,00
013F8:  DATA    68,74,00
013FA:  DATA    6D,6C,00
013FC:  DATA    00,00,00
013FE:  CLR     32
01400:  MOV     #140A,W3
01402:  ADD     W3,W0,W0
01404:  TBLRDL.B[W0],W0L
01406:  CLR.B   1
01408:  RETURN  
0140A:  DATA    2F,74,00
0140C:  DATA    65,73,00
0140E:  DATA    74,2E,00
01410:  DATA    68,74,00
01412:  DATA    6D,6C,00
01414:  DATA    00,00,00
01416:  CLR     32
01418:  MOV     #1422,W3
0141A:  ADD     W3,W0,W0
0141C:  TBLRDL.B[W0],W0L
0141E:  CLR.B   1
01420:  RETURN  
01422:  DATA    2F,72,00
01424:  DATA    6F,75,00
01426:  DATA    74,65,00
01428:  DATA    72,5F,00
0142A:  DATA    73,75,00
0142C:  DATA    62,6D,00
0142E:  DATA    69,74,00
01430:  DATA    2E,68,00
01432:  DATA    74,6D,00
01434:  DATA    6C,00,00
01436:  CLR     32
01438:  MOV     #1442,W3
0143A:  ADD     W3,W0,W0
0143C:  TBLRDL.B[W0],W0L
0143E:  CLR.B   1
01440:  RETURN  
01442:  DATA    53,53,00
01444:  DATA    49,44,00
01446:  DATA    3D,00,00
01448:  CLR     32
0144A:  MOV     #1454,W3
0144C:  ADD     W3,W0,W0
0144E:  TBLRDL.B[W0],W0L
01450:  CLR.B   1
01452:  RETURN  
01454:  DATA    00,00,00
01456:  CLR     32
01458:  MOV     #1462,W3
0145A:  ADD     W3,W0,W0
0145C:  TBLRDL.B[W0],W0L
0145E:  CLR.B   1
01460:  RETURN  
01462:  DATA    50,41,00
01464:  DATA    53,53,00
01466:  DATA    3D,00,00
01468:  CLR     32
0146A:  MOV     #1474,W3
0146C:  ADD     W3,W0,W0
0146E:  TBLRDL.B[W0],W0L
01470:  CLR.B   1
01472:  RETURN  
01474:  DATA    41,55,00
01476:  DATA    54,48,00
01478:  DATA    3D,00,00
0147A:  CLR     32
0147C:  MOV     #1486,W3
0147E:  ADD     W3,W0,W0
01480:  TBLRDL.B[W0],W0L
01482:  CLR.B   1
01484:  RETURN  
01486:  DATA    45,4E,00
01488:  DATA    43,52,00
0148A:  DATA    59,50,00
0148C:  DATA    54,3D,00
0148E:  DATA    00,00,00
01490:  CLR     32
01492:  MOV     #149C,W3
01494:  ADD     W3,W0,W0
01496:  TBLRDL.B[W0],W0L
01498:  CLR.B   1
0149A:  RETURN  
0149C:  DATA    20,25,00
0149E:  DATA    4C,75,00
014A0:  DATA    20,20,00
014A2:  DATA    50,57,00
014A4:  DATA    4D,20,00
014A6:  DATA    25,4C,00
014A8:  DATA    75,20,00
014AA:  DATA    20,25,00
014AC:  DATA    4C,75,00
014AE:  DATA    20,00,00
014B0:  CLR     32
014B2:  MOV     #14BC,W3
014B4:  ADD     W3,W0,W0
014B6:  TBLRDL.B[W0],W0L
014B8:  CLR.B   1
014BA:  RETURN  
014BC:  DATA    20,50,00
014BE:  DATA    43,3A,00
014C0:  DATA    25,4C,00
014C2:  DATA    58,20,00
014C4:  DATA    00,00,00
014C6:  CLR     32
014C8:  MOV     #14D2,W3
014CA:  ADD     W3,W0,W0
014CC:  TBLRDL.B[W0],W0L
014CE:  CLR.B   1
014D0:  RETURN  
014D2:  DATA    50,53,00
014D4:  DATA    56,50,00
014D6:  DATA    41,47,00
014D8:  DATA    3A,25,00
014DA:  DATA    4C,58,00
014DC:  DATA    20,00,00
014DE:  CLR     32
014E0:  MOV     #14EA,W3
014E2:  ADD     W3,W0,W0
014E4:  TBLRDL.B[W0],W0L
014E6:  CLR.B   1
014E8:  RETURN  
014EA:  DATA    54,42,00
014EC:  DATA    4C,50,00
014EE:  DATA    41,47,00
014F0:  DATA    3A,25,00
014F2:  DATA    4C,58,00
014F4:  DATA    20,00,00
014F6:  CLR     32
014F8:  MOV     #1502,W3
014FA:  ADD     W3,W0,W0
014FC:  TBLRDL.B[W0],W0L
014FE:  CLR.B   1
01500:  RETURN  
01502:  DATA    43,4F,00
01504:  DATA    52,43,00
01506:  DATA    4F,4E,00
01508:  DATA    3A,25,00
0150A:  DATA    4C,58,00
0150C:  DATA    20,00,00
0150E:  CLR     32
01510:  MOV     #151A,W3
01512:  ADD     W3,W0,W0
01514:  TBLRDL.B[W0],W0L
01516:  CLR.B   1
01518:  RETURN  
0151A:  DATA    41,44,00
0151C:  DATA    44,52,00
0151E:  DATA    45,53,00
01520:  DATA    53,20,00
01522:  DATA    46,41,00
01524:  DATA    55,4C,00
01526:  DATA    54,00,00
01528:  CLR     32
0152A:  MOV     #1534,W3
0152C:  ADD     W3,W0,W0
0152E:  TBLRDL.B[W0],W0L
01530:  CLR.B   1
01532:  RETURN  
01534:  DATA    4D,41,00
01536:  DATA    54,48,00
01538:  DATA    20,46,00
0153A:  DATA    41,55,00
0153C:  DATA    4C,54,00
0153E:  DATA    00,00,00
01540:  CLR     32
01542:  MOV     #154C,W3
01544:  ADD     W3,W0,W0
01546:  TBLRDL.B[W0],W0L
01548:  CLR.B   1
0154A:  RETURN  
0154C:  DATA    53,54,00
0154E:  DATA    41,43,00
01550:  DATA    4B,20,00
01552:  DATA    46,41,00
01554:  DATA    55,4C,00
01556:  DATA    54,00,00
01558:  CLR     32
0155A:  MOV     #1564,W3
0155C:  ADD     W3,W0,W0
0155E:  TBLRDL.B[W0],W0L
01560:  CLR.B   1
01562:  RETURN  
01564:  DATA    4F,53,00
01566:  DATA    43,49,00
01568:  DATA    4C,4C,00
0156A:  DATA    41,54,00
0156C:  DATA    4F,52,00
0156E:  DATA    20,46,00
01570:  DATA    41,55,00
01572:  DATA    4C,54,00
01574:  DATA    00,00,00
01576:  CLR     32
01578:  MOV     #1582,W3
0157A:  ADD     W3,W0,W0
0157C:  TBLRDL.B[W0],W0L
0157E:  CLR.B   1
01580:  RETURN  
01582:  DATA    45,72,00
01584:  DATA    69,6B,00
01586:  DATA    73,5F,00
01588:  DATA    42,6F,00
0158A:  DATA    61,72,00
0158C:  DATA    64,3A,00
0158E:  DATA    57,54,00
01590:  DATA    53,00,00
01592:  CLR     32
01594:  MOV     #159E,W3
01596:  ADD     W3,W0,W0
01598:  TBLRDL.B[W0],W0L
0159A:  CLR.B   1
0159C:  RETURN  
0159E:  DATA    49,6E,00
015A0:  DATA    69,74,00
015A2:  DATA    69,61,00
015A4:  DATA    6C,69,00
015A6:  DATA    7A,65,00
015A8:  DATA    3A,20,00
015AA:  DATA    00,00,00
015AC:  CLR     32
015AE:  MOV     #15B8,W3
015B0:  ADD     W3,W0,W0
015B2:  TBLRDL.B[W0],W0L
015B4:  CLR.B   1
015B6:  RETURN  
015B8:  DATA    4C,6F,00
015BA:  DATA    61,64,00
015BC:  DATA    69,6E,00
015BE:  DATA    67,00,00
015C0:  CLR     32
015C2:  MOV     #15CC,W3
015C4:  ADD     W3,W0,W0
015C6:  TBLRDL.B[W0],W0L
015C8:  CLR.B   1
015CA:  RETURN  
015CC:  DATA    43,68,00
015CE:  DATA    65,63,00
015D0:  DATA    6B,20,00
015D2:  DATA    4C,69,00
015D4:  DATA    6E,6B,00
015D6:  DATA    00,00,00
015D8:  CLR     32
015DA:  MOV     #15E4,W3
015DC:  ADD     W3,W0,W0
015DE:  TBLRDL.B[W0],W0L
015E0:  CLR.B   1
015E2:  RETURN  
015E4:  DATA    41,6C,00
015E6:  DATA    72,65,00
015E8:  DATA    61,64,00
015EA:  DATA    79,20,00
015EC:  DATA    4C,69,00
015EE:  DATA    6E,6B,00
015F0:  DATA    65,64,00
015F2:  DATA    20,20,00
015F4:  DATA    20,20,00
015F6:  DATA    00,00,00
015F8:  CLR     32
015FA:  MOV     #30,W3
015FC:  SUB     W0,W3,W3
015FE:  BRA     C,160A
01600:  MOV     #1614,W3
01602:  ADD     W3,W0,W0
01604:  TBLRDL.B[W0],W0L
01606:  CLR.B   1
01608:  RETURN  
0160A:  MOV     #1614,W0
0160C:  ADD     W3,W3,W3
0160E:  ADD     W3,W0,W3
01610:  TBLRDH  [W3],W0
01612:  RETURN  
01614:  DATA    43,72,6C
01616:  DATA    61,62,75
01618:  DATA    24,25,24
0161A:  DATA    73,24,25
0161C:  DATA    25,73,6C
0161E:  DATA    24,25,75
01620:  DATA    35,66,24
01622:  DATA    24,25,25
01624:  DATA    35,66,6C
01626:  DATA    24,25,75
01628:  DATA    35,66,24
0162A:  DATA    24,25,25
0162C:  DATA    35,66,6C
0162E:  DATA    24,25,75
01630:  DATA    35,66,24
01632:  DATA    24,25,25
01634:  DATA    35,66,35
01636:  DATA    24,25,66
01638:  DATA    35,66,24
0163A:  DATA    24,25,25
0163C:  DATA    6C,64,35
0163E:  DATA    24,25,66
01640:  DATA    35,66,00
01642:  DATA    24,25,00
01644:  CLR     32
01646:  MOV     #2E,W3
01648:  SUB     W0,W3,W3
0164A:  BRA     C,1656
0164C:  MOV     #1660,W3
0164E:  ADD     W3,W0,W0
01650:  TBLRDL.B[W0],W0L
01652:  CLR.B   1
01654:  RETURN  
01656:  MOV     #1660,W0
01658:  ADD     W3,W3,W3
0165A:  ADD     W3,W0,W3
0165C:  TBLRDH  [W3],W0
0165E:  RETURN  
01660:  DATA    47,45,0A
01662:  DATA    54,20,48
01664:  DATA    2F,77,6F
01666:  DATA    65,6C,73
01668:  DATA    63,6F,74
0166A:  DATA    6D,65,3A
0166C:  DATA    79,6F,20
0166E:  DATA    75,2E,6F
01670:  DATA    70,68,73
01672:  DATA    70,3F,6D
01674:  DATA    6E,61,6F
01676:  DATA    6D,65,62
01678:  DATA    3D,25,6F
0167A:  DATA    73,26,74
0167C:  DATA    63,68,2E
0167E:  DATA    6B,73,6F
01680:  DATA    6D,3D,72
01682:  DATA    25,75,67
01684:  DATA    20,48,0D
01686:  DATA    54,54,0A
01688:  DATA    50,2F,0D
0168A:  DATA    31,2E,0A
0168C:  DATA    31,0D,00
*
01760:  MOV     W5,[W15++]
01762:  MOV     W6,[W15++]
01764:  MOV     W7,[W15++]
01766:  MOV     W4,W5
01768:  MOV     W0,W4
0176A:  SWAP    W5
0176C:  MOV.B   #11,W7L
0176E:  DEC.B   000B
01770:  DEC.B   000E
01772:  BRA     Z,17BC
01774:  MOV     W3,W0
01776:  MOV     #4,W6
01778:  RLC     W4,W4
0177A:  RLC     W1,W1
0177C:  RLC     W2,W2
0177E:  RLC     W3,W3
01780:  DEC     W6,W6
01782:  BRA     NZ,1778
01784:  LSR     W0,#C,W0
01786:  AND     #F,W0
01788:  BRA     NZ,1792
0178A:  CP.B    W7L,#1
0178C:  BRA     Z,1792
0178E:  BTSS.B  B.7
01790:  BRA     176E
01792:  ADD     #30,W0
01794:  MOV     #3A,W6
01796:  CP      W0,W6
01798:  BRA     NC,179C
0179A:  ADD.B   A,W0L
0179C:  MOV     W1,[W15++]
0179E:  MOV     W3,[W15++]
017A0:  MOV     W4,[W15++]
017A2:  PUSH    39D0
017A4:  MOV.B   W0L,[W15-#2]
017A6:  POP     39D0
*
017B2:  MOV     [--W15],W4
017B4:  MOV     [--W15],W3
017B6:  MOV     [--W15],W1
017B8:  BSET.B  B.7
017BA:  BRA     176E
017BC:  MOV     [--W15],W7
017BE:  MOV     [--W15],W6
017C0:  MOV     [--W15],W5
017C2:  RETURN  
017C4:  MOV     W5,[W15++]
017C6:  MOV     #C,W5
017C8:  REPEAT  #3
017CA:  MOV     [W5++],[W15++]
017CC:  MOV     W0,W7
017CE:  MOV     W4,W9
017D0:  BCLR    W4.F
017D2:  CP0     W4
017D4:  BRA     NZ,17E2
017D6:  BTSC    W9.F
017D8:  BRA     17DE
017DA:  MOV     #0,W5
017DC:  BRA     180E
017DE:  MOV     #0,W5
017E0:  BRA     180E
017E2:  SUB.B   W4L,#6,W5L
017E4:  BRA     NC,180C
017E6:  MOV     #30,W0
017E8:  BTSS    W9.F
017EA:  MOV     #20,W0
017EC:  MOV     W1,[W15++]
017EE:  MOV.D   W2,[W15++]
017F0:  PUSH    39D0
017F2:  MOV.B   W0L,[W15-#2]
017F4:  POP     39D0
*
01800:  MOV.D   [--W15],W2
01802:  MOV     [--W15],W1
01804:  DEC     W5,W5
01806:  BRA     NN,17EC
01808:  MOV     #5,W5
0180A:  BRA     180E
0180C:  MOV     W4,W5
0180E:  MOV     #6,W4
01810:  BSET    W5.E
01812:  BTSC    W9.F
01814:  BSET    W5.F
01816:  MOV     #2710,W8
01818:  REPEAT  #11
0181A:  DIV.U   W7,W8
0181C:  CALL    1862
01820:  MOV     W1,W7
01822:  MOV     #3E8,W8
01824:  REPEAT  #11
01826:  DIV.U   W7,W8
01828:  CALL    1862
0182C:  MOV     W1,W7
0182E:  MOV     #64,W8
01830:  REPEAT  #11
01832:  DIV.U   W7,W8
01834:  CALL    1862
01838:  MOV     W1,W7
0183A:  MOV     #A,W8
0183C:  REPEAT  #11
0183E:  DIV.U   W7,W8
01840:  CALL    1862
01844:  MOV     #30,W0
01846:  ADD.B   W1L,W0L,W0L
01848:  MOV     W1,[W15++]
0184A:  MOV.D   W2,[W15++]
0184C:  PUSH    39D0
0184E:  MOV.B   W0L,[W15-#2]
01850:  POP     39D0
*
0185C:  MOV.D   [--W15],W2
0185E:  MOV     [--W15],W1
01860:  BRA     189E
01862:  MOV     #30,W6
01864:  CP0     W0
01866:  BRA     NZ,1884
01868:  BTSS    W5.E
0186A:  BRA     1886
0186C:  DEC     W4,W4
0186E:  CP.B    W4L,W5L
01870:  BRA     Z,1876
01872:  BTSC.B  42.0
01874:  RETURN  
01876:  CP0     W0
01878:  BRA     NZ,1884
0187A:  BTSS    W5.E
0187C:  BRA     1886
0187E:  BTSS    W5.F
01880:  MOV     #20,W6
01882:  BRA     1886
01884:  BCLR    W5.E
01886:  ADD.B   W6L,W0L,W0L
01888:  MOV     W1,[W15++]
0188A:  PUSH    39D0
0188C:  MOV.B   W0L,[W15-#2]
0188E:  POP     39D0
*
0189A:  MOV     [--W15],W1
0189C:  RETURN  
0189E:  MOV     #12,W5
018A0:  REPEAT  #3
018A2:  MOV     [--W15],[W5--]
018A4:  MOV     [--W15],W5
018A6:  RETURN  
018A8:  MOV     W0,W3
018AA:  SWAP    W1
018AC:  MOV.B   #5,W4L
018AE:  DEC.B   0003
018B0:  DEC.B   0008
018B2:  BRA     Z,18F0
018B4:  MOV     W3,W0
018B6:  SL      W3,#4,W3
018B8:  LSR     W0,#C,W0
018BA:  AND     #F,W0
018BC:  BRA     NZ,18C6
018BE:  CP.B    W4L,#1
018C0:  BRA     Z,18C6
018C2:  BTSS.B  3.7
018C4:  BRA     18AE
018C6:  ADD     #30,W0
018C8:  MOV     #3A,W2
018CA:  CP      W0,W2
018CC:  BRA     NC,18D0
018CE:  ADD.B   2,W0L
018D0:  MOV     W1,[W15++]
018D2:  MOV     W3,[W15++]
018D4:  MOV     W4,[W15++]
018D6:  PUSH    39D0
018D8:  MOV.B   W0L,[W15-#2]
018DA:  POP     39D0
*
018E6:  MOV     [--W15],W4
018E8:  MOV     [--W15],W3
018EA:  MOV     [--W15],W1
018EC:  BSET.B  3.7
018EE:  BRA     18AE
018F0:  RETURN  
*
02938:  MOV     W5,[W15++]
0293A:  MOV     #C,W5
0293C:  REPEAT  #3
0293E:  MOV     [W5++],[W15++]
02940:  MUL.UU  W0,W2,W4
02942:  BTSS    W3.F
02944:  BRA     294A
02946:  MUL.SS  W0,W3,W6
02948:  BRA     294C
0294A:  MUL.UU  W0,W3,W6
0294C:  BCLR.B  42.0
0294E:  ADD     W6,W5,W5
02950:  ADDC    W7,#0,W8
02952:  BTSS    W1.F
02954:  BRA     295A
02956:  MUL.SS  W1,W2,W6
02958:  BRA     295C
0295A:  MUL.UU  W1,W2,W6
0295C:  ADDC    W6,W5,W5
0295E:  ADDC    W7,W8,W8
02960:  ADDC    #0,W9
02962:  MUL.SS  W1,W3,W6
02964:  ADDC    W6,W8,W8
02966:  ADDC    W9,W7,W7
02968:  MOV     W7,W3
0296A:  MOV     W8,W2
0296C:  MOV     W5,W1
0296E:  MOV     W4,W0
02970:  MOV     #12,W5
02972:  REPEAT  #3
02974:  MOV     [--W15],[W5--]
02976:  MOV     [--W15],W5
02978:  RETURN  
*
02FB0:  MOV     W5,[W15++]
02FB2:  MOV     #C,W5
02FB4:  REPEAT  #3
02FB6:  MOV     [W5++],[W15++]
02FB8:  BTSS    W0.F
02FBA:  BRA     2FD4
02FBC:  NEG     W0,W0
02FBE:  BSET    W4.8
02FC0:  BTSS    W4.F
02FC2:  BRA     2FD4
02FC4:  MOV     W0,[W15++]
02FC6:  MOV     #2D,W0
02FC8:  BTSC.B  253.1
02FCA:  BRA     2FC8
02FCC:  MOV     W0,254
02FCE:  MOV     [--W15],W0
02FD0:  BCLR    W4.8
02FD2:  DEC.B   0008
02FD4:  CLR     W5
02FD6:  MOV     W0,W7
02FD8:  MOV     W4,W9
02FDA:  BCLR    W4.F
02FDC:  CP0.B   W4L
02FDE:  BRA     NZ,2FEC
02FE0:  BTSC    W9.F
02FE2:  BRA     2FE8
02FE4:  MOV     #0,W5
02FE6:  BRA     3006
02FE8:  MOV     #0,W5
02FEA:  BRA     3006
02FEC:  SUB.B   W4L,#6,W5L
02FEE:  BRA     NC,3004
02FF0:  MOV     #30,W0
02FF2:  BTSS    W9.F
02FF4:  MOV     #20,W0
02FF6:  BTSC.B  253.1
02FF8:  BRA     2FF6
02FFA:  MOV     W0,254
02FFC:  DEC     W5,W5
02FFE:  BRA     NN,2FF6
03000:  MOV     #5,W5
03002:  BRA     3006
03004:  MOV     W4,W5
03006:  MOV     #6,W4
03008:  BTSC    W5.8
0300A:  INC     W4,W4
0300C:  BSET    W5.E
0300E:  BTSC    W9.F
03010:  BSET    W5.F
03012:  MOV     #2710,W8
03014:  REPEAT  #11
03016:  DIV.U   W7,W8
03018:  CALL    305C
0301C:  MOV     W1,W7
0301E:  MOV     #3E8,W8
03020:  REPEAT  #11
03022:  DIV.U   W7,W8
03024:  CALL    305C
03028:  MOV     W1,W7
0302A:  MOV     #64,W8
0302C:  REPEAT  #11
0302E:  DIV.U   W7,W8
03030:  CALL    305C
03034:  MOV     W1,W7
03036:  MOV     #A,W8
03038:  REPEAT  #11
0303A:  DIV.U   W7,W8
0303C:  CALL    305C
03040:  BTSS    W9.8
03042:  BRA     304E
03044:  MOV     #2D,W0
03046:  BTSC.B  253.1
03048:  BRA     3046
0304A:  MOV     W0,254
0304C:  BCLR    W9.8
0304E:  MOV     #30,W0
03050:  ADD.B   W1L,W0L,W0L
03052:  MOV     W0,2A
03054:  BTSC.B  253.1
03056:  BRA     3054
03058:  MOV     W0,254
0305A:  BRA     309C
0305C:  MOV     #30,W6
0305E:  CP0     W0
03060:  BRA     NZ,307E
03062:  BTSS    W5.E
03064:  BRA     3092
03066:  DEC     W4,W4
03068:  CP.B    W4L,W5L
0306A:  BRA     Z,3070
0306C:  BTSC.B  42.0
0306E:  RETURN  
03070:  CP0     W0
03072:  BRA     NZ,307E
03074:  BTSS    W5.E
03076:  BRA     3092
03078:  BTSS    W5.F
0307A:  MOV     #20,W6
0307C:  BRA     3092
0307E:  BCLR    W5.E
03080:  BTSS    W9.8
03082:  BRA     3092
03084:  MOV     W0,W10
03086:  MOV     #2D,W0
03088:  BTSC.B  253.1
0308A:  BRA     3088
0308C:  MOV     W0,254
0308E:  BCLR    W9.8
03090:  MOV     W10,W0
03092:  ADD.B   W6L,W0L,W0L
03094:  BTSC.B  253.1
03096:  BRA     3094
03098:  MOV     W0,254
0309A:  RETURN  
0309C:  MOV     #12,W5
0309E:  REPEAT  #3
030A0:  MOV     [--W15],[W5--]
030A2:  MOV     [--W15],W5
030A4:  RETURN  
*
035EA:  MOV     W1,[W15++]
035EC:  MOV     214A,W1
035EE:  MOV.B   W0L,[W1++]
035F0:  CLR.B   [W1]
035F2:  MOV     [--W15],W1
035F4:  MOV     214A,W0
035F6:  INC     W0,W0
035F8:  MOV     W0,214A
035FA:  RETURN  
035FC:  MOV     W5,[W15++]
035FE:  MOV     #C,W5
03600:  REPEAT  #3
03602:  MOV     [W5++],[W15++]
03604:  BTSS    W0.F
03606:  BRA     3622
03608:  NEG     W0,W0
0360A:  BSET    W4.8
0360C:  BTSS    W4.F
0360E:  BRA     3622
03610:  MOV     W0,[W15++]
03612:  MOV     #2D,W0
03614:  MOV     W0,[W15++]
03616:  MOV     [--W15],W0
03618:  CALL    35EA
0361C:  MOV     [--W15],W0
0361E:  BCLR    W4.8
03620:  DEC.B   0008
03622:  CLR     W5
03624:  MOV     W0,W7
03626:  MOV     W4,W9
03628:  BCLR    W4.F
0362A:  CP0.B   W4L
0362C:  BRA     NZ,363A
0362E:  BTSC    W9.F
03630:  BRA     3636
03632:  MOV     #0,W5
03634:  BRA     3656
03636:  MOV     #0,W5
03638:  BRA     3656
0363A:  SUB.B   W4L,#6,W5L
0363C:  BRA     NC,3654
0363E:  MOV     #30,W0
03640:  BTSS    W9.F
03642:  MOV     #20,W0
03644:  MOV     W0,[W15++]
03646:  MOV     [--W15],W0
03648:  CALL    35EA
0364C:  DEC     W5,W5
0364E:  BRA     NN,3644
03650:  MOV     #5,W5
03652:  BRA     3656
03654:  MOV     W4,W5
03656:  MOV     #6,W4
03658:  BTSC    W5.8
0365A:  INC     W4,W4
0365C:  BSET    W5.E
0365E:  BTSC    W9.F
03660:  BSET    W5.F
03662:  MOV     #2710,W8
03664:  REPEAT  #11
03666:  DIV.U   W7,W8
03668:  CALL    36B0
0366C:  MOV     W1,W7
0366E:  MOV     #3E8,W8
03670:  REPEAT  #11
03672:  DIV.U   W7,W8
03674:  CALL    36B0
03678:  MOV     W1,W7
0367A:  MOV     #64,W8
0367C:  REPEAT  #11
0367E:  DIV.U   W7,W8
03680:  CALL    36B0
03684:  MOV     W1,W7
03686:  MOV     #A,W8
03688:  REPEAT  #11
0368A:  DIV.U   W7,W8
0368C:  CALL    36B0
03690:  BTSS    W9.8
03692:  BRA     36A0
03694:  MOV     #2D,W0
03696:  MOV     W0,[W15++]
03698:  MOV     [--W15],W0
0369A:  CALL    35EA
0369E:  BCLR    W9.8
036A0:  MOV     #30,W0
036A2:  ADD.B   W1L,W0L,W0L
036A4:  MOV     W0,2A
036A6:  MOV     W0,[W15++]
036A8:  MOV     [--W15],W0
036AA:  CALL    35EA
036AE:  BRA     36F8
036B0:  MOV     #30,W6
036B2:  CP0     W0
036B4:  BRA     NZ,36D2
036B6:  BTSS    W5.E
036B8:  BRA     36E8
036BA:  DEC     W4,W4
036BC:  CP.B    W4L,W5L
036BE:  BRA     Z,36C4
036C0:  BTSC.B  42.0
036C2:  RETURN  
036C4:  CP0     W0
036C6:  BRA     NZ,36D2
036C8:  BTSS    W5.E
036CA:  BRA     36E8
036CC:  BTSS    W5.F
036CE:  MOV     #20,W6
036D0:  BRA     36E8
036D2:  BCLR    W5.E
036D4:  BTSS    W9.8
036D6:  BRA     36E8
036D8:  MOV     W0,W10
036DA:  MOV     #2D,W0
036DC:  MOV     W0,[W15++]
036DE:  MOV     [--W15],W0
036E0:  CALL    35EA
036E4:  BCLR    W9.8
036E6:  MOV     W10,W0
036E8:  ADD.B   W6L,W0L,W0L
036EA:  MOV     W1,[W15++]
036EC:  MOV     W0,[W15++]
036EE:  MOV     [--W15],W0
036F0:  CALL    35EA
036F4:  MOV     [--W15],W1
036F6:  RETURN  
036F8:  MOV     #12,W5
036FA:  REPEAT  #3
036FC:  MOV     [--W15],[W5--]
036FE:  MOV     [--W15],W5
03700:  RETURN  
*
044E6:  MOV     W5,[W15++]
044E8:  MOV     W6,[W15++]
044EA:  MOV     #8E,W1
044EC:  BCLR    W6.0
044EE:  BTSS    W0.F
044F0:  BRA     44F8
044F2:  BSET    W6.0
044F4:  NEG     W0,W0
044F6:  BRA     44F8
044F8:  CP0     W0
044FA:  BRA     Z,4524
044FC:  BTSC    W0.F
044FE:  BRA     4508
04500:  BCLR.B  42.0
04502:  RLC     W0,W0
04504:  DEC     W1,W1
04506:  BRA     44FC
04508:  SWAP    W1
0450A:  BCLR.B  42.0
0450C:  RRC     W1,W1
0450E:  BCLR    W0.F
04510:  SWAP    W0
04512:  XOR.B   W0L,W1L,W1L
04514:  AND.B   #0,W0L
04516:  BTSC    W6.0
04518:  BSET    W1.F
0451A:  BRA     452A
0451C:  MOV.B   W1L,W0L
0451E:  BSET    W1.7
04520:  AND.B   #0,W1L
04522:  BRA     452A
04524:  CLR     W0
04526:  CLR     W1
04528:  BRA     452A
0452A:  MOV     [--W15],W6
0452C:  MOV     [--W15],W5
0452E:  RETURN  
04530:  MOV     W5,[W15++]
04532:  MOV     #C,W5
04534:  REPEAT  #4
04536:  MOV     [W5++],[W15++]
04538:  CLR     W9
0453A:  XOR     W1,W3,W9
0453C:  MOV     W1,W6
0453E:  MOV     W0,W5
04540:  MOV     W3,W8
04542:  MOV     W2,W7
04544:  RLC     W1,W1
04546:  SWAP    W1
04548:  ZE      W1,W1
0454A:  CP0     W1
0454C:  BRA     Z,45EA
0454E:  RLC     W3,W3
04550:  SWAP    W3
04552:  ZE      W3,W3
04554:  CP0     W3
04556:  BRA     Z,45EA
04558:  CLR     W0
0455A:  SUB.B   W1L,W3L,W0L
0455C:  BRA     NC,4564
0455E:  ADD.B   #7F,W0L
04560:  BRA     C,45EA
04562:  BRA     456A
04564:  SUB.B   #81,W0L
04566:  BRA     NC,45EA
04568:  BRA     Z,45EA
0456A:  MOV     W5,W1
0456C:  MOV     W6,W2
0456E:  BSET    W2.7
04570:  AND     #FF,W2
04572:  AND     #FF,W8
04574:  BSET    W8.7
04576:  MOV     #19,W10
04578:  CLR     W3
0457A:  CLR     W4
0457C:  SUB     W1,W7,W1
0457E:  SUBB    W2,W8,W2
04580:  BRA     N,4586
04582:  BRA     C,458C
04584:  BRA     NZ,458E
04586:  ADD     W1,W7,W1
04588:  ADDC    W2,W8,W2
0458A:  BRA     458E
0458C:  BSET    W4.0
0458E:  DEC     W10,W10
04590:  BRA     Z,45A0
04592:  BCLR.B  42.0
04594:  RLC     W1,W1
04596:  RLC     W2,W2
04598:  BCLR.B  42.0
0459A:  RLC     W4,W4
0459C:  RLC     W3,W3
0459E:  BRA     457C
045A0:  CLR     W10
045A2:  BTSC    W3.8
045A4:  BRA     45A8
045A6:  BRA     45B4
045A8:  BCLR.B  42.0
045AA:  RRC     W3,W3
045AC:  BCLR    W3.7
045AE:  RRC     W4,W4
045B0:  RLC     W10,W10
045B2:  BRA     45B8
045B4:  DEC     W0,W0
045B6:  BRA     Z,45EA
045B8:  BTSC    W10.F
045BA:  BRA     NC,45C6
045BC:  RLC     W1,W1
045BE:  RLC     W2,W2
045C0:  SUB     W1,W7,W1
045C2:  SUBB    W2,W8,W2
045C4:  BRA     NC,45D8
045C6:  INC     W4,W4
045C8:  BRA     NZ,45D8
045CA:  INC     W3,W3
045CC:  BRA     NZ,45D8
045CE:  INC     W0,W0
045D0:  BRA     Z,45EA
045D2:  BRA     45D8
045D4:  DEC     W0,W0
045D6:  BRA     Z,45EA
045D8:  SWAP    W0
045DA:  RRC     W0,W1
045DC:  BSET    W1.F
045DE:  BTSS    W9.F
045E0:  BCLR    W1.F
045E2:  BCLR    W3.7
045E4:  XOR.B   W3L,W1L,W1L
045E6:  MOV     W4,W0
045E8:  BRA     45F0
045EA:  MOV     #0,W0
045EC:  MOV     #0,W1
045EE:  BRA     45F0
045F0:  MOV     #14,W5
045F2:  REPEAT  #4
045F4:  MOV     [--W15],[W5--]
045F6:  MOV     [--W15],W5
045F8:  RETURN  
045FA:  MOV     W5,[W15++]
045FC:  MOV     W6,[W15++]
045FE:  MOV     W7,[W15++]
04600:  XOR     W1,W3,W4
04602:  BTSS    W4.F
04604:  BRA     4612
04606:  BCLR.B  42.0
04608:  BCLR.B  42.1
0460A:  BTSS    W1.F
0460C:  BRA     465A
0460E:  BSET.B  42.0
04610:  BRA     465A
04612:  MOV     W1,W4
04614:  MOV     W0,W5
04616:  MOV     W3,W6
04618:  MOV     W2,W7
0461A:  RLC     W1,W1
0461C:  SWAP    W1
0461E:  RLC     W3,W3
04620:  SWAP    W3
04622:  SUB.B   W3L,W1L,W1L
04624:  BRA     Z,4630
04626:  BTSS    W4.F
04628:  BRA     465A
0462A:  MOV     #1,W0
0462C:  XOR.B   42
0462E:  BRA     465A
04630:  MOV.B   W4L,W1L
04632:  MOV.B   W6L,W3L
04634:  BCLR    W1.7
04636:  BCLR    W3.7
04638:  SUB.B   W3L,W1L,W1L
0463A:  BRA     Z,4646
0463C:  BTSS    W4.F
0463E:  BRA     465A
04640:  MOV     #1,W0
04642:  XOR.B   42
04644:  BRA     465A
04646:  SUB     W7,W5,W1
04648:  BRA     Z,4654
0464A:  BTSS    W4.F
0464C:  BRA     465A
0464E:  MOV     #1,W0
04650:  XOR.B   42
04652:  BRA     465A
04654:  BCLR.B  42.0
04656:  BRA     465A
04658:  BRA     465A
0465A:  MOV     [--W15],W7
0465C:  MOV     [--W15],W6
0465E:  MOV     [--W15],W5
04660:  RETURN  
*
046C6:  MOV     W5,[W15++]
046C8:  MOV     #C,W5
046CA:  REPEAT  #4
046CC:  MOV     [W5++],[W15++]
046CE:  MOV     W0,W4
046D0:  MOV     W1,W5
046D2:  MOV     W3,W7
046D4:  MOV     W2,W6
046D6:  BCLR.B  42.0
046D8:  BCLR.B  42.1
046DA:  RLC     W1,W1
046DC:  SWAP    W1
046DE:  AND     #FF,W1
046E0:  CP0     W1
046E2:  BRA     Z,477A
046E4:  BCLR.B  42.0
046E6:  BCLR.B  42.1
046E8:  RLC     W3,W3
046EA:  SWAP    W3
046EC:  AND     #FF,W3
046EE:  CP0     W3
046F0:  BRA     Z,477A
046F2:  ZE      W0,W0
046F4:  ADD.B   W3L,W1L,W0L
046F6:  BRA     C,4700
046F8:  SUB     #7F,W0
046FA:  BRA     Z,477A
046FC:  BRA     NC,477A
046FE:  BRA     4704
04700:  ADD.B   #81,W0L
04702:  BRA     C,477A
04704:  XOR     W5,W7,W10
04706:  BCLR.B  42.0
04708:  BCLR.B  42.1
0470A:  AND     #FF,W5
0470C:  BSET    W5.7
0470E:  BCLR.B  42.0
04710:  AND     #FF,W7
04712:  BSET    W7.7
04714:  MUL.UU  W4,W6,W2
04716:  MUL.UU  W5,W6,W8
04718:  ADDC    W8,W3,W3
0471A:  MOV     W9,W1
0471C:  BTSC.B  42.0
0471E:  INC     W1,W1
04720:  BCLR.B  42.0
04722:  MUL.UU  W7,W4,W8
04724:  ADDC    W8,W3,W3
04726:  ADDC    W9,W1,W1
04728:  MUL.UU  W5,W7,W8
0472A:  ADDC    W8,W1,W1
0472C:  INC     W0,W0
0472E:  CP0     W1
04730:  BTSC.B  42.1
04732:  BRA     4736
04734:  BRA     473C
04736:  CP0     W3
04738:  BTSC.B  42.1
0473A:  BRA     4746
0473C:  BTSC    W1.F
0473E:  BRA     4746
04740:  RLC     W3,W3
04742:  RLC     W1,W1
04744:  DEC     W0,W0
04746:  MOV     W1,W2
04748:  BCLR.B  42.0
0474A:  BTSS    W3.7
0474C:  BRA     4760
0474E:  MOV     #FF00,W7
04750:  AND     W3,W7,W3
04752:  ADD     #100,W3
04754:  ADDC    W2,#0,W2
04756:  CP0     W2
04758:  BRA     NZ,4760
0475A:  CP0     W3
0475C:  BRA     NZ,4760
0475E:  INC     W0,W0
04760:  SWAP    W0
04762:  BCLR.B  42.0
04764:  BCLR.B  42.1
04766:  RRC     W0,W1
04768:  BTSC    W10.F
0476A:  BSET    W1.F
0476C:  BCLR    W2.F
0476E:  SWAP    W2
04770:  XOR.B   W2L,W1L,W1L
04772:  SWAP    W3
04774:  MOV.B   W3L,W2L
04776:  MOV     W2,W0
04778:  BRA     4780
0477A:  MOV     #0,W0
0477C:  MOV     #0,W1
0477E:  BRA     4780
04780:  MOV     #14,W5
04782:  REPEAT  #4
04784:  MOV     [--W15],[W5--]
04786:  MOV     [--W15],W5
04788:  RETURN  
0478A:  MOV     W5,[W15++]
0478C:  MOV     #C,W5
0478E:  REPEAT  #3
04790:  MOV     [W5++],[W15++]
04792:  CLR     W9
04794:  MOV     #8000,W8
04796:  BTSC.B  43.0
04798:  XOR     W8,W3,W3
0479A:  CP0     W0
0479C:  BRA     NZ,47A4
0479E:  MOV     #7FFF,W10
047A0:  AND     W1,W10,W10
047A2:  BTSS.B  42.1
047A4:  MOV     W1,W10
047A6:  XOR     W3,W10,W11
047A8:  MOV     W1,W6
047AA:  MOV     W3,W7
047AC:  MOV     W3,W12
047AE:  BCLR.B  42.1
047B0:  BCLR.B  42.0
047B2:  RLC     W6,W6
047B4:  SWAP    W6
047B6:  AND     #FF,W6
047B8:  CP0     W6
047BA:  BRA     Z,48FE
047BC:  BCLR.B  42.1
047BE:  BCLR.B  42.0
047C0:  RLC     W7,W7
047C2:  SWAP    W7
047C4:  AND     #FF,W7
047C6:  CP0     W7
047C8:  BRA     Z,4908
047CA:  BCLR.B  42.1
047CC:  BCLR.B  42.0
047CE:  CP      W7,W6
047D0:  BRA     Z,490A
047D2:  BRA     N,491A
047D4:  BCLR    W9.0
047D6:  BSET    W9.1
047D8:  SUB     W7,W6,W8
047DA:  MOV     W7,W6
047DC:  AND     #FF,W1
047DE:  BSET    W1.7
047E0:  AND     #FF,W3
047E2:  BSET    W3.7
047E4:  MOV     #28,W7
047E6:  CP      W7,W8
047E8:  BRA     N,480C
047EA:  BCLR.B  42.1
047EC:  BCLR.B  42.0
047EE:  RRC     W1,W1
047F0:  RRC     W0,W0
047F2:  DEC     W8,W8
047F4:  BRA     NZ,47EA
047F6:  BRA     4812
047F8:  MOV     #28,W7
047FA:  CP      W7,W8
047FC:  BRA     N,4810
047FE:  BCLR.B  42.1
04800:  BCLR.B  42.0
04802:  RRC     W3,W3
04804:  RRC     W2,W2
04806:  DEC     W8,W8
04808:  BRA     NZ,47FE
0480A:  BRA     482A
0480C:  MOV     W2,W0
0480E:  MOV     W3,W1
04810:  BRA     4898
04812:  BTSS    W11.F
04814:  BRA     4838
04816:  BTSC    W9.4
04818:  MOV     W12,W11
0481A:  NEG     W0,W0
0481C:  BRA     Z,4822
0481E:  COM.B   W1L,W1L
04820:  BRA     4824
04822:  NEG     W1,W1
04824:  BTSC    W9.4
04826:  BRA     487E
04828:  BRA     4838
0482A:  BTSS    W11.F
0482C:  BRA     4838
0482E:  NEG     W2,W2
04830:  BRA     Z,4836
04832:  COM.B   W3L,W3L
04834:  BRA     4838
04836:  NEG     W3,W3
04838:  AND     #FF,W5
0483A:  BCLR.B  42.1
0483C:  BCLR.B  42.0
0483E:  ADD     W0,W2,W0
04840:  ADDC.B  W1L,W3L,W1L
04842:  BTSC.B  42.0
04844:  BSET    W9.3
04846:  BTSC    W9.0
04848:  BRA     485C
0484A:  BTSC    W9.1
0484C:  BRA     4850
0484E:  BRA     4866
04850:  BTSC    W11.F
04852:  BRA     487E
04854:  BTSC    W9.3
04856:  BRA     48AA
04858:  BSET    W9.6
0485A:  BRA     4898
0485C:  BTSC    W11.F
0485E:  BRA     487E
04860:  BTSC    W9.3
04862:  BRA     48AA
04864:  BRA     4898
04866:  BCLR    W9.2
04868:  BTSC    W11.F
0486A:  BRA     4874
0486C:  MOV     W10,W11
0486E:  BTSC    W9.3
04870:  BRA     48AA
04872:  BRA     48E0
04874:  BSET    W9.4
04876:  XOR.B   #80,W1L
04878:  BTSC    W1.7
0487A:  BRA     4816
0487C:  MOV     W10,W11
0487E:  AND     #FF,W1
04880:  IOR      W0,  W1,W7
04882:  BRA     Z,4898
04884:  BTSC    W1.7
04886:  BRA     4898
04888:  BCLR.B  42.1
0488A:  BCLR.B  42.0
0488C:  RLC     W0,W0
0488E:  RLC     W1,W1
04890:  DEC     W6,W6
04892:  BTSC.B  42.1
04894:  BRA     48F8
04896:  BRA     4884
04898:  BTSC    W9.0
0489A:  MOV     W10,W11
0489C:  BTSC    W9.1
0489E:  MOV     W12,W11
048A0:  BTSS    W9.5
048A2:  BRA     48D8
048A4:  BTSC    W10.F
048A6:  BSET    W0.8
048A8:  BRA     48E0
048AA:  BSET.B  42.0
048AC:  RRC.B   W1L,W1L
048AE:  RRC     W0,W0
048B0:  BTSC.B  42.0
048B2:  BSET    W9.5
048B4:  INC     W6,W6
048B6:  BRA     Z,48F8
048B8:  BTSS    W9.5
048BA:  BRA     48CC
048BC:  INC     W0,W0
048BE:  BRA     NZ,48CC
048C0:  INC.B   W1L,W1L
048C2:  BRA     NZ,48CC
048C4:  RRC.B   W1L,W1L
048C6:  RRC     W0,W0
048C8:  INC     W6,W6
048CA:  BRA     Z,48F8
048CC:  BTSC    W9.0
048CE:  MOV     W10,W11
048D0:  BTSC    W9.1
048D2:  MOV     W12,W11
048D4:  BTSC.B  42.1
048D6:  BRA     48F8
048D8:  BTSC    W9.6
048DA:  MOV     W10,W11
048DC:  BTSC    W9.7
048DE:  MOV     W12,W11
048E0:  IOR      W0,  W1,W2
048E2:  BRA     Z,492A
048E4:  BCLR    W1.7
048E6:  SWAP    W6
048E8:  BCLR.B  42.1
048EA:  BCLR.B  42.0
048EC:  RRC     W6,W6
048EE:  XOR     W6,W1,W1
048F0:  BSET    W1.F
048F2:  BTSS    W11.F
048F4:  BCLR    W1.F
048F6:  BRA     492A
048F8:  MOV     #0,W0
048FA:  MOV     #0,W1
048FC:  BRA     492A
048FE:  BTSC    W10.F
04900:  XOR     W8,W3,W3
04902:  MOV     W2,W0
04904:  MOV     W3,W1
04906:  BRA     492A
04908:  BRA     492A
0490A:  AND     #FF,W3
0490C:  BSET    W3.7
0490E:  AND     #FF,W1
04910:  BSET    W1.7
04912:  BTSC    W11.F
04914:  BCLR    W3.7
04916:  BSET    W9.2
04918:  BRA     482A
0491A:  SUB     W6,W7,W8
0491C:  AND     #FF,W1
0491E:  BSET    W1.7
04920:  AND     #FF,W3
04922:  BSET    W3.7
04924:  BCLR    W9.1
04926:  BSET    W9.0
04928:  BRA     47F8
0492A:  MOV     #12,W5
0492C:  REPEAT  #3
0492E:  MOV     [--W15],[W5--]
04930:  MOV     [--W15],W5
04932:  RETURN  
*
05098:  MOV     W5,[W15++]
0509A:  MOV     W6,[W15++]
0509C:  MOV     W0,W4
0509E:  MOV     W1,W5
050A0:  CLR     W0
050A2:  CLR     W1
050A4:  BCLR    W6.0
050A6:  BTSS    W5.F
050A8:  BRA     50B6
050AA:  BSET    W6.0
050AC:  NEG     W4,W4
050AE:  BRA     Z,50B4
050B0:  COM     W5,W5
050B2:  BRA     50B6
050B4:  NEG     W5,W5
050B6:  IOR      W4,  W5,W3
050B8:  BRA     Z,50E0
050BA:  CLR     W2
050BC:  MOV     #B6,W1
050BE:  BTSC    W2.7
050C0:  BRA     50D0
050C2:  BCLR.B  42.0
050C4:  RLC     W4,W4
050C6:  RLC     W5,W5
050C8:  RLC     W0,W0
050CA:  RLC     W2,W2
050CC:  DEC     W1,W1
050CE:  BRA     NZ,50BE
050D0:  SWAP    W1
050D2:  BCLR.B  42.0
050D4:  RRC     W1,W1
050D6:  BCLR    W1.F
050D8:  BCLR    W2.7
050DA:  XOR.B   W2L,W1L,W1L
050DC:  BTSC    W6.0
050DE:  BSET    W1.F
050E0:  MOV     [--W15],W6
050E2:  MOV     [--W15],W5
050E4:  RETURN  
*
06000:  MOV     W5,[W15++]
06002:  MOV     #C,W5
06004:  REPEAT  #3
06006:  MOV     [W5++],[W15++]
06008:  MUL.UU  W0,W2,W4
0600A:  MUL.UU  W0,W3,W6
0600C:  BCLR.B  42.0
0600E:  ADD     W6,W5,W5
06010:  ADDC    W7,#0,W8
06012:  MUL.UU  W1,W2,W6
06014:  ADDC    W6,W5,W5
06016:  ADDC    W7,W8,W8
06018:  MUL.UU  W1,W3,W6
0601A:  ADD     W6,W8,W8
0601C:  ADDC    #0,W7
0601E:  MOV     W7,W3
06020:  MOV     W8,W2
06022:  MOV     W5,W1
06024:  MOV     W4,W0
06026:  MOV     #12,W5
06028:  REPEAT  #3
0602A:  MOV     [--W15],[W5--]
0602C:  MOV     [--W15],W5
0602E:  RETURN  
*
0630A:  MOV     W5,[W15++]
0630C:  MOV     W6,[W15++]
0630E:  MOV     W0,W4
06310:  MOV     W1,W5
06312:  CLR     W0
06314:  CLR     W1
06316:  IOR      W4,  W5,W3
06318:  BRA     Z,633C
0631A:  CLR     W2
0631C:  MOV     #B6,W1
0631E:  BTSC    W2.7
06320:  BRA     6330
06322:  BCLR.B  42.0
06324:  RLC     W4,W4
06326:  RLC     W5,W5
06328:  RLC     W0,W0
0632A:  RLC     W2,W2
0632C:  DEC     W1,W1
0632E:  BRA     NZ,631E
06330:  SWAP    W1
06332:  BCLR.B  42.0
06334:  RRC     W1,W1
06336:  BCLR    W1.F
06338:  BCLR    W2.7
0633A:  XOR.B   W2L,W1L,W1L
0633C:  MOV     [--W15],W6
0633E:  MOV     [--W15],W5
06340:  RETURN  
06342:  MOV     W5,[W15++]
06344:  MOV     W1,W5
06346:  MOV     W0,W2
06348:  MOV     #B6,W4
0634A:  RLC     W1,W1
0634C:  SWAP    W1
0634E:  AND     #FF,W1
06350:  SUB.B   W4L,W1L,W4L
06352:  MOV.B   W5L,W3L
06354:  BSET    W3.7
06356:  AND     #FF,W3
06358:  CLR     W0
0635A:  CLR     W1
0635C:  CP      W4,#18
0635E:  BRA     N,637E
06360:  BCLR.B  42.0
06362:  RRC     W3,W3
06364:  RRC     W2,W2
06366:  RRC     W1,W1
06368:  RRC     W0,W0
0636A:  DEC     W4,W4
0636C:  BRA     NZ,6360
0636E:  BTSS    W5.F
06370:  BRA     637E
06372:  NEG     W0,W0
06374:  BRA     Z,637A
06376:  COM     W1,W1
06378:  BRA     637E
0637A:  NEG     W1,W1
0637C:  BRA     637E
0637E:  MOV     [--W15],W5
06380:  RETURN  
*
06796:  MOV     W5,[W15++]
06798:  MOV     W2,W3
0679A:  MOV     W2,W5
0679C:  BCLR.B  42.0
0679E:  RLC     W3,W3
067A0:  SWAP    W3
067A2:  AND     #FF,W3
067A4:  BRA     NZ,67AC
067A6:  MUL.UU  W0,#0,W0
067A8:  MUL.UU  W2,#0,W2
067AA:  BRA     67D8
067AC:  ADD     #380,W3
067AE:  AND     #7F,W2
067B0:  MOV     #3,W6
067B2:  CLR     W4
067B4:  BCLR.B  42.0
067B6:  RRC     W2,W2
067B8:  RRC     W1,W1
067BA:  RRC     W0,W0
067BC:  BTSC.B  42.0
067BE:  INC     W4,W4
067C0:  DEC     W6,W6
067C2:  BRA     NZ,67B4
067C4:  BCLR    W2.7
067C6:  SL      W3,#4,W3
067C8:  BCLR    W3.F
067CA:  BTSC    W5.F
067CC:  BSET    W3.F
067CE:  XOR     W2,W3,W3
067D0:  MOV     W1,W2
067D2:  MOV     W0,W1
067D4:  ADD     W4,W1,W1
067D6:  CLR     W0
067D8:  MOV     [--W15],W5
067DA:  RETURN  
067DC:  MOV     W5,[W15++]
067DE:  MOV     #C,W5
067E0:  REPEAT  #7
067E2:  MOV     [W5++],[W15++]
067E4:  MUL.UU  W6,#0,W6
067E6:  MUL.UU  W8,#0,W8
067E8:  MUL.UU  W10,#0,W10
067EA:  MUL.UU  W12,#0,W12
067EC:  MOV     #E,W8
067EE:  MOV     #0,W9
067F0:  LNK     #10
067F2:  MOV     W12,[W14+W8]
067F4:  DEC2    W8,W8
067F6:  BRA     NN,67F2
067F8:  BTSS    W3.F
067FA:  BRA     6800
067FC:  BSET    W4.6
067FE:  DEC.B   0009
06800:  MOV     #7FF0,W5
06802:  AND     W3,W5,W5
06804:  BRA     Z,6946
06806:  AND     W3,#F,W3
06808:  BSET    W3.4
0680A:  LSR     W5,#4,W5
0680C:  MOV     #3FF,W6
0680E:  SUB     W5,W6,W5
06810:  BRA     NC,68C6
06812:  CLR     W8
06814:  MOV     #4,W6
06816:  BCLR.B  42.0
06818:  RLC     W0,W0
0681A:  RLC     W1,W1
0681C:  RLC     W2,W2
0681E:  RLC     W3,W3
06820:  DEC     W6,W6
06822:  BRA     NZ,6816
06824:  CP      W5,#4
06826:  BRA     C,6834
06828:  CP      W5,#3
0682A:  BRA     NZ,693E
0682C:  LSR     W3,#5,W6
0682E:  CP      W6,#A
06830:  BTSS.B  42.0
06832:  BRA     693E
06834:  MOV     #3,W6
06836:  SUB     W5,W6,W5
06838:  INC     W8,W8
0683A:  CALL    6B42
0683E:  CALL    6B26
06842:  BCLR.B  42.0
06844:  RLC     W0,W0
06846:  RLC     W1,W1
06848:  RLC     W2,W2
0684A:  RLC     W3,W3
0684C:  CALL    6B02
06850:  MOV     #2,W6
06852:  BCLR.B  42.0
06854:  RRC     W3,W3
06856:  RRC     W2,W2
06858:  RRC     W1,W1
0685A:  RRC     W0,W0
0685C:  DEC     W6,W6
0685E:  BRA     NZ,6852
06860:  CALL    6B26
06864:  MOV     #4,W6
06866:  BCLR.B  42.0
06868:  RRC     W13,W13
0686A:  RRC     W12,W12
0686C:  RRC     W11,W11
0686E:  RRC     W10,W10
06870:  DEC     W6,W6
06872:  BRA     NZ,6866
06874:  CALL    6B02
06878:  CALL    6B26
0687C:  MOV     #8,W6
0687E:  BCLR.B  42.0
06880:  RRC     W13,W13
06882:  RRC     W12,W12
06884:  RRC     W11,W11
06886:  RRC     W10,W10
06888:  DEC     W6,W6
0688A:  BRA     NZ,687E
0688C:  AND     #FF,W13
0688E:  CALL    6B02
06892:  CALL    6B26
06896:  MOV     W11,W10
06898:  MOV     W12,W11
0689A:  MOV     W13,W12
0689C:  CLR     W13
0689E:  CALL    6B02
068A2:  CALL    6B30
068A6:  BTSC    W3.8
068A8:  BRA     6824
068AA:  CP0     W5
068AC:  BRA     NZ,68B8
068AE:  INC     W0,W0
068B0:  INC     W1,W1
068B2:  INC     W2,W2
068B4:  INC     W3,W3
068B6:  BRA     693E
068B8:  BCLR.B  42.0
068BA:  RLC     W0,W0
068BC:  RLC     W1,W1
068BE:  RLC     W2,W2
068C0:  RLC     W3,W3
068C2:  DEC     W5,W5
068C4:  BRA     6824
068C6:  COM     W5,W5
068C8:  INC     W5,W5
068CA:  MOV     #3FF,W6
068CC:  ADD     W5,W6,W5
068CE:  CLR     W8
068D0:  MOV     #4,W6
068D2:  BCLR.B  42.0
068D4:  RLC     W0,W0
068D6:  RLC     W1,W1
068D8:  RLC     W2,W2
068DA:  RLC     W3,W3
068DC:  DEC     W6,W6
068DE:  BRA     NZ,68D2
068E0:  ADD     W5,#4,W5
068E2:  MOV     #3FF,W6
068E4:  SUB     W5,W6,W5
068E6:  CP      W5,#5
068E8:  BRA     NC,6950
068EA:  CALL    6B42
068EE:  CALL    6B26
068F2:  BCLR.B  42.0
068F4:  RLC     W0,W0
068F6:  RLC     W1,W1
068F8:  RLC     W2,W2
068FA:  RLC     W3,W3
068FC:  BCLR.B  42.0
068FE:  RLC     W0,W0
06900:  RLC     W1,W1
06902:  RLC     W2,W2
06904:  RLC     W3,W3
06906:  CALL    6B02
0690A:  CALL    6B30
0690E:  BCLR.B  42.0
06910:  RLC     W0,W0
06912:  RLC     W1,W1
06914:  RLC     W2,W2
06916:  RLC     W3,W3
06918:  INC     W8,W8
0691A:  MOV     #3,W6
0691C:  BCLR.B  42.0
0691E:  RRC     W3,W3
06920:  RRC     W2,W2
06922:  RRC     W1,W1
06924:  RRC     W0,W0
06926:  DEC     W6,W6
06928:  BRA     NZ,691C
0692A:  SUB     W5,#3,W5
0692C:  BTSS    W3.9
0692E:  BRA     68E6
06930:  BCLR.B  42.0
06932:  RRC     W3,W3
06934:  RRC     W2,W2
06936:  RRC     W1,W1
06938:  RRC     W0,W0
0693A:  DEC     W5,W5
0693C:  BRA     68E6
0693E:  NEG     W5,W5
06940:  ADD     W5,#3,W5
06942:  MOV     #2B,W6
06944:  BRA     6954
06946:  MUL.UU  W0,#0,W0
06948:  MUL.UU  W2,#0,W2
0694A:  CLR     W8
0694C:  CLR     W6
0694E:  BRA     6954
06950:  DEC     W5,W5
06952:  MOV     #2D,W6
06954:  BTSS    W4.6
06956:  BRA     6972
06958:  MOV     W0,W7
0695A:  MOV     W4,[W15++]
0695C:  MOV     W1,[W15++]
0695E:  MOV.D   W2,[W15++]
06960:  MOV.B   #2D,W0L
06962:  CALL    35EA
06966:  MOV.D   [--W15],W2
06968:  MOV     [--W15],W1
0696A:  MOV     [--W15],W4
0696C:  MOV     W7,W0
0696E:  BCLR    W4.6
06970:  BCLR    W4.7
06972:  CLR     W10
06974:  LSR     W3,#5,W9
06976:  CP0     W5
06978:  BRA     Z,6984
0697A:  MOV     W5,W11
0697C:  BCLR.B  42.0
0697E:  RRC     W9,W9
06980:  DEC     W11,W11
06982:  BRA     NZ,697C
06984:  CP.B    W4L,W10L
06986:  BRA     NC,6A08
06988:  MOV     W0,W7
0698A:  MOV     #30,W0
0698C:  ADD     W9,W0,W0
0698E:  MOV     W4,[W15++]
06990:  MOV     W1,[W15++]
06992:  MOV.D   W2,[W15++]
06994:  MOV     W0,[W15++]
06996:  MOV     [--W15],W0
06998:  CALL    35EA
0699C:  MOV.D   [--W15],W2
0699E:  MOV     [--W15],W1
069A0:  MOV     [--W15],W4
069A2:  MOV     W7,W0
069A4:  CP0     W10
069A6:  BRA     NZ,69BE
069A8:  MOV     W0,W7
069AA:  MOV     W4,[W15++]
069AC:  MOV     W1,[W15++]
069AE:  MOV.D   W2,[W15++]
069B0:  MOV.B   #2E,W0L
069B2:  CALL    35EA
069B6:  MOV.D   [--W15],W2
069B8:  MOV     [--W15],W1
069BA:  MOV     [--W15],W4
069BC:  MOV     W7,W0
069BE:  INC     W10,W10
069C0:  CP0     W5
069C2:  BRA     Z,69CE
069C4:  MOV     W5,W11
069C6:  BCLR.B  42.0
069C8:  RLC     W9,W9
069CA:  DEC     W11,W11
069CC:  BRA     NZ,69C6
069CE:  LSR     W3,#5,W7
069D0:  SUB     W7,W9,W7
069D2:  SL      W7,#5,W7
069D4:  AND     W3,#1F,W3
069D6:  IOR      W7,  W3,W3
069D8:  CALL    6B42
069DC:  CALL    6B26
069E0:  BCLR.B  42.0
069E2:  RLC     W0,W0
069E4:  RLC     W1,W1
069E6:  RLC     W2,W2
069E8:  RLC     W3,W3
069EA:  BCLR.B  42.0
069EC:  RLC     W0,W0
069EE:  RLC     W1,W1
069F0:  RLC     W2,W2
069F2:  RLC     W3,W3
069F4:  CALL    6B02
069F8:  CALL    6B30
069FC:  BCLR.B  42.0
069FE:  RLC     W0,W0
06A00:  RLC     W1,W1
06A02:  RLC     W2,W2
06A04:  RLC     W3,W3
06A06:  BRA     6974
06A08:  MOV     W0,W7
06A0A:  MOV     W4,[W15++]
06A0C:  MOV     W1,[W15++]
06A0E:  MOV.D   W2,[W15++]
06A10:  MOV.B   #45,W0L
06A12:  CALL    35EA
06A16:  MOV.D   [--W15],W2
06A18:  MOV     [--W15],W1
06A1A:  MOV     [--W15],W4
06A1C:  MOV     W7,W0
06A1E:  CP0     W6
06A20:  BRA     Z,6A3A
06A22:  MOV     W0,W7
06A24:  MOV     W6,W0
06A26:  MOV     W4,[W15++]
06A28:  MOV     W1,[W15++]
06A2A:  MOV.D   W2,[W15++]
06A2C:  MOV     W0,[W15++]
06A2E:  MOV     [--W15],W0
06A30:  CALL    35EA
06A34:  MOV.D   [--W15],W2
06A36:  MOV     [--W15],W1
06A38:  MOV     [--W15],W4
06A3A:  CLR     W12
06A3C:  MOV     W8,W13
06A3E:  SUB     W13,#A,W13
06A40:  BRA     NC,6AD4
06A42:  INC     W12,W12
06A44:  SUB     W13,#A,W13
06A46:  BRA     C,6A42
06A48:  ADD     W13,#A,W13
06A4A:  CP      W12,#A
06A4C:  BRA     C,6A80
06A4E:  MOV     W0,W7
06A50:  MOV     #30,W0
06A52:  ADD.B   W0L,W12L,W0L
06A54:  MOV     W4,[W15++]
06A56:  MOV     W1,[W15++]
06A58:  MOV.D   W2,[W15++]
06A5A:  MOV     W0,[W15++]
06A5C:  MOV     [--W15],W0
06A5E:  CALL    35EA
06A62:  MOV.D   [--W15],W2
06A64:  MOV     [--W15],W1
06A66:  MOV     #30,W0
06A68:  ADD.B   W0L,W13L,W0L
06A6A:  MOV     W1,[W15++]
06A6C:  MOV.D   W2,[W15++]
06A6E:  MOV     W0,[W15++]
06A70:  MOV     [--W15],W0
06A72:  CALL    35EA
06A76:  MOV.D   [--W15],W2
06A78:  MOV     [--W15],W1
06A7A:  MOV     [--W15],W4
06A7C:  MOV     W7,W0
06A7E:  BRA     6B54
06A80:  CLR     W11
06A82:  SUB     W12,#A,W12
06A84:  INC     W11,W11
06A86:  SUB.B   W12L,#A,W12L
06A88:  BRA     C,6A84
06A8A:  MOV     #30,W0
06A8C:  ADD.B   W12L,#A,W12L
06A8E:  MOV     W0,W7
06A90:  MOV     #30,W0
06A92:  ADD.B   W0L,W11L,W0L
06A94:  MOV     W4,[W15++]
06A96:  MOV     W1,[W15++]
06A98:  MOV.D   W2,[W15++]
06A9A:  MOV     W0,[W15++]
06A9C:  MOV     [--W15],W0
06A9E:  CALL    35EA
06AA2:  MOV.D   [--W15],W2
06AA4:  MOV     [--W15],W1
06AA6:  MOV     #30,W0
06AA8:  ADD.B   W0L,W12L,W0L
06AAA:  MOV     W1,[W15++]
06AAC:  MOV.D   W2,[W15++]
06AAE:  MOV     W0,[W15++]
06AB0:  MOV     [--W15],W0
06AB2:  CALL    35EA
06AB6:  MOV.D   [--W15],W2
06AB8:  MOV     [--W15],W1
06ABA:  MOV     #30,W0
06ABC:  ADD.B   W0L,W13L,W0L
06ABE:  MOV     W1,[W15++]
06AC0:  MOV.D   W2,[W15++]
06AC2:  MOV     W0,[W15++]
06AC4:  MOV     [--W15],W0
06AC6:  CALL    35EA
06ACA:  MOV.D   [--W15],W2
06ACC:  MOV     [--W15],W1
06ACE:  MOV     [--W15],W4
06AD0:  MOV     W7,W0
06AD2:  BRA     6B54
06AD4:  ADD.B   W13L,#A,W13L
06AD6:  MOV     W0,W7
06AD8:  MOV     W4,[W15++]
06ADA:  MOV     W1,[W15++]
06ADC:  MOV.D   W2,[W15++]
06ADE:  MOV.B   #30,W0L
06AE0:  CALL    35EA
06AE4:  MOV.D   [--W15],W2
06AE6:  MOV     [--W15],W1
06AE8:  MOV     #30,W0
06AEA:  ADD.B   W0L,W13L,W0L
06AEC:  MOV     W1,[W15++]
06AEE:  MOV.D   W2,[W15++]
06AF0:  MOV     W0,[W15++]
06AF2:  MOV     [--W15],W0
06AF4:  CALL    35EA
06AF8:  MOV.D   [--W15],W2
06AFA:  MOV     [--W15],W1
06AFC:  MOV     [--W15],W4
06AFE:  MOV     W7,W0
06B00:  BRA     6B54
06B02:  ADD     W10,W0,W0
06B04:  BRA     NC,6B12
06B06:  INC     W1,W1
06B08:  BRA     NZ,6B12
06B0A:  INC     W2,W2
06B0C:  BRA     NZ,6B12
06B0E:  INC     W3,W3
06B10:  BRA     NZ,6B12
06B12:  ADD     W11,W1,W1
06B14:  BRA     NC,6B1C
06B16:  INC     W2,W2
06B18:  BRA     NZ,6B1C
06B1A:  INC     W3,W3
06B1C:  ADD     W12,W2,W2
06B1E:  BTSC.B  42.0
06B20:  INC     W3,W3
06B22:  ADD     W3,W13,W3
06B24:  RETURN  
06B26:  MOV     W3,W13
06B28:  MOV     W2,W12
06B2A:  MOV     W1,W11
06B2C:  MOV     W0,W10
06B2E:  RETURN  
06B30:  MOV     W10,[W14+#8]
06B32:  MOV     W11,[W14+#A]
06B34:  MOV     W12,[W14+#C]
06B36:  MOV     W13,[W14+#E]
06B38:  MOV     [W14],W10
06B3A:  MOV     [W14+#2],W11
06B3C:  MOV     [W14+#4],W12
06B3E:  MOV     [W14+#6],W13
06B40:  RETURN  
06B42:  MOV     W10,[W14]
06B44:  MOV     W11,[W14+#2]
06B46:  MOV     W12,[W14+#4]
06B48:  MOV     W13,[W14+#6]
06B4A:  MOV     [W14+#8],W10
06B4C:  MOV     [W14+#A],W11
06B4E:  MOV     [W14+#C],W12
06B50:  MOV     [W14+#E],W13
06B52:  RETURN  
06B54:  ULNK    
06B56:  MOV     #1A,W5
06B58:  REPEAT  #7
06B5A:  MOV     [--W15],[W5--]
06B5C:  MOV     [--W15],W5
06B5E:  RETURN  
*
06CE8:  MOV     W0,W2
06CEA:  MOV     W1,W3
06CEC:  MOV.B   W1L,W0L
06CEE:  SWAP    W0
06CF0:  BSET    W0.F
06CF2:  RLC     W1,W1
06CF4:  SWAP    W1
06CF6:  ZE      W1,W1
06CF8:  MOV     #8E,W4
06CFA:  SUB.B   W4L,W1L,W1L
06CFC:  BRA     Z,6D0A
06CFE:  CP0     W0
06D00:  BRA     Z,6D0A
06D02:  BCLR.B  42.0
06D04:  RRC     W0,W0
06D06:  DEC     W1,W1
06D08:  BRA     NZ,6CFE
06D0A:  BTSS    W3.F
06D0C:  BRA     6D12
06D0E:  NEG     W0,W0
06D10:  BRA     6D12
06D12:  RETURN  
06D14:  MOV     W5,[W15++]
06D16:  MOV     #C,W5
06D18:  REPEAT  #3
06D1A:  MOV     [W5++],[W15++]
06D1C:  MOV     W0,W7
06D1E:  MOV     W4,W9
06D20:  BCLR    W4.F
06D22:  CP0     W4
06D24:  BRA     NZ,6D32
06D26:  BTSC    W9.F
06D28:  BRA     6D2E
06D2A:  MOV     #0,W5
06D2C:  BRA     6D56
06D2E:  MOV     #0,W5
06D30:  BRA     6D56
06D32:  SUB.B   W4L,#6,W5L
06D34:  BRA     NC,6D54
06D36:  MOV     #30,W0
06D38:  BTSS    W9.F
06D3A:  MOV     #20,W0
06D3C:  MOV     W1,[W15++]
06D3E:  MOV.D   W2,[W15++]
06D40:  MOV     W0,[W15++]
06D42:  MOV     [--W15],W0
06D44:  CALL    35EA
06D48:  MOV.D   [--W15],W2
06D4A:  MOV     [--W15],W1
06D4C:  DEC     W5,W5
06D4E:  BRA     NN,6D3C
06D50:  MOV     #5,W5
06D52:  BRA     6D56
06D54:  MOV     W4,W5
06D56:  MOV     #6,W4
06D58:  BSET    W5.E
06D5A:  BTSC    W9.F
06D5C:  BSET    W5.F
06D5E:  MOV     #2710,W8
06D60:  REPEAT  #11
06D62:  DIV.U   W7,W8
06D64:  CALL    6DA2
06D68:  MOV     W1,W7
06D6A:  MOV     #3E8,W8
06D6C:  REPEAT  #11
06D6E:  DIV.U   W7,W8
06D70:  CALL    6DA2
06D74:  MOV     W1,W7
06D76:  MOV     #64,W8
06D78:  REPEAT  #11
06D7A:  DIV.U   W7,W8
06D7C:  CALL    6DA2
06D80:  MOV     W1,W7
06D82:  MOV     #A,W8
06D84:  REPEAT  #11
06D86:  DIV.U   W7,W8
06D88:  CALL    6DA2
06D8C:  MOV     #30,W0
06D8E:  ADD.B   W1L,W0L,W0L
06D90:  MOV     W1,[W15++]
06D92:  MOV.D   W2,[W15++]
06D94:  MOV     W0,[W15++]
06D96:  MOV     [--W15],W0
06D98:  CALL    35EA
06D9C:  MOV.D   [--W15],W2
06D9E:  MOV     [--W15],W1
06DA0:  BRA     6DD6
06DA2:  MOV     #30,W6
06DA4:  CP0     W0
06DA6:  BRA     NZ,6DC4
06DA8:  BTSS    W5.E
06DAA:  BRA     6DC6
06DAC:  DEC     W4,W4
06DAE:  CP.B    W4L,W5L
06DB0:  BRA     Z,6DB6
06DB2:  BTSC.B  42.0
06DB4:  RETURN  
06DB6:  CP0     W0
06DB8:  BRA     NZ,6DC4
06DBA:  BTSS    W5.E
06DBC:  BRA     6DC6
06DBE:  BTSS    W5.F
06DC0:  MOV     #20,W6
06DC2:  BRA     6DC6
06DC4:  BCLR    W5.E
06DC6:  ADD.B   W6L,W0L,W0L
06DC8:  MOV     W1,[W15++]
06DCA:  MOV     W0,[W15++]
06DCC:  MOV     [--W15],W0
06DCE:  CALL    35EA
06DD2:  MOV     [--W15],W1
06DD4:  RETURN  
06DD6:  MOV     #12,W5
06DD8:  REPEAT  #3
06DDA:  MOV     [--W15],[W5--]
06DDC:  MOV     [--W15],W5
06DDE:  RETURN  
*
0730C:  MOV     W8,[W15++]
0730E:  MOV     #12,W8
07310:  REPEAT  #4
07312:  MOV     [W8++],[W15++]
07314:  CLR     W11
07316:  MUL.UU  W12,#0,W12
07318:  MOV     W3,W8
0731A:  MOV     W7,W9
0731C:  MOV     #7FF,W10
0731E:  BCLR.B  42.0
07320:  BCLR.B  42.1
07322:  ASR     W8,#4,W8
07324:  AND     W10,W8,W8
07326:  CP0     W8
07328:  BRA     Z,740C
0732A:  BCLR.B  42.0
0732C:  BCLR.B  42.1
0732E:  ASR     W9,#4,W9
07330:  AND     W10,W9,W9
07332:  CP0     W9
07334:  BRA     Z,740C
07336:  ADD     W9,W8,W8
07338:  BTSC    W9.B
0733A:  BRA     7344
0733C:  SUB     #3FF,W8
0733E:  BRA     Z,740C
07340:  BRA     NC,740C
07342:  BRA     734A
07344:  MOV     #401,W10
07346:  ADD.B   W10L,W5L,W5L
07348:  BRA     C,740C
0734A:  XOR     W3,W7,W13
0734C:  BCLR.B  42.0
0734E:  BCLR.B  42.1
07350:  AND     #F,W3
07352:  BSET    W3.4
07354:  AND     #F,W7
07356:  BSET    W7.4
07358:  MOV     W8,[W15++]
0735A:  MUL.UU  W4,W1,W8
0735C:  MUL.UU  W5,W0,W10
0735E:  ADD     W8,W10,W10
07360:  ADDC    W9,W11,W11
07362:  ADDC    #0,W12
07364:  MUL.UU  W4,W2,W8
07366:  ADD     W8,W11,W11
07368:  ADDC    W9,W12,W12
0736A:  MUL.UU  W5,W1,W8
0736C:  CLR     W10
0736E:  ADD     W8,W11,W11
07370:  ADDC    W9,W12,W12
07372:  ADDC    #0,W10
07374:  MUL.UU  W6,W0,W8
07376:  ADD     W8,W11,W11
07378:  ADDC    W9,W12,W12
0737A:  ADDC    #0,W10
0737C:  CLR     W11
0737E:  MUL.UU  W4,W3,W8
07380:  ADD     W8,W12,W12
07382:  ADDC    W9,W10,W10
07384:  ADDC    #0,W11
07386:  MUL.UU  W5,W2,W8
07388:  ADD     W8,W12,W12
0738A:  ADDC    W9,W10,W10
0738C:  ADDC    #0,W11
0738E:  MUL.UU  W6,W1,W8
07390:  ADD     W8,W12,W12
07392:  ADDC    W9,W10,W10
07394:  ADDC    #0,W11
07396:  MUL.UU  W7,W0,W8
07398:  ADD     W8,W12,W12
0739A:  ADDC    W9,W10,W10
0739C:  ADDC    #0,W11
0739E:  MOV     W12,W0
073A0:  CLR     W12
073A2:  MUL.UU  W5,W3,W8
073A4:  ADD     W8,W10,W10
073A6:  ADDC    W9,W11,W11
073A8:  ADDC    #0,W12
073AA:  MUL.UU  W6,W2,W8
073AC:  ADD     W8,W10,W10
073AE:  ADDC    W9,W11,W11
073B0:  ADDC    #0,W12
073B2:  MUL.UU  W6,W3,W8
073B4:  ADD     W8,W11,W11
073B6:  ADDC    W9,W12,W12
073B8:  MUL.UU  W7,W1,W8
073BA:  ADD     W8,W10,W10
073BC:  ADDC    W9,W11,W11
073BE:  ADDC    #0,W12
073C0:  MUL.UU  W7,W2,W8
073C2:  ADD     W8,W11,W11
073C4:  ADDC    W9,W12,W12
073C6:  MUL.UU  W7,W3,W8
073C8:  ADD     W8,W12,W12
073CA:  MOV     W10,W1
073CC:  MOV     W11,W2
073CE:  MOV     W12,W3
073D0:  MOV     #5,W4
073D2:  BCLR.B  42.0
073D4:  RRC     W3,W3
073D6:  RRC     W2,W2
073D8:  RRC     W1,W1
073DA:  RRC     W0,W0
073DC:  DEC     W4,W4
073DE:  BRA     NZ,73D2
073E0:  MOV     [--W15],W8
073E2:  INC     W8,W8
073E4:  IOR      W0,  W1,W6
073E6:  BRA     Z,73EA
073E8:  BRA     73EE
073EA:  IOR      W2,  W3,W6
073EC:  BRA     Z,73FE
073EE:  BTSC    W3.4
073F0:  BRA     73FE
073F2:  BCLR.B  42.0
073F4:  RLC     W0,W0
073F6:  RLC     W1,W1
073F8:  RLC     W2,W2
073FA:  RLC     W3,W3
073FC:  DEC     W8,W8
073FE:  SL      W8,#4,W8
07400:  BCLR    W3.F
07402:  BTSC    W13.F
07404:  BSET    W3.F
07406:  BCLR    W3.4
07408:  XOR     W8,W3,W3
0740A:  BRA     7412
0740C:  MUL.UU  W0,#0,W0
0740E:  MUL.UU  W0,#0,W2
07410:  BRA     7412
07412:  MOV     #1A,W8
07414:  REPEAT  #4
07416:  MOV     [--W15],[W8--]
07418:  MOV     [--W15],W8
0741A:  RETURN  
0741C:  MOV     W5,[W15++]
0741E:  MOV     #C,W5
07420:  REPEAT  #5
07422:  MOV     [W5++],[W15++]
07424:  MOV     W3,W8
07426:  MOV     W2,W7
07428:  MOV     W1,W6
0742A:  MOV     W0,W5
0742C:  MOV     W3,W9
0742E:  MOV     #473,W11
07430:  ASR     W3,#4,W3
07432:  MOV     #7FF,W10
07434:  AND     W10,W3,W3
07436:  SUB     W11,W3,W11
07438:  AND     #1F,W8
0743A:  BSET    W8.4
0743C:  CLR     W0
0743E:  CLR     W1
07440:  CLR     W2
07442:  CLR     W3
07444:  BCLR.B  42.0
07446:  RRC     W8,W8
07448:  RRC     W7,W7
0744A:  RRC     W6,W6
0744C:  RRC     W5,W5
0744E:  RRC     W3,W3
07450:  RRC     W2,W2
07452:  RRC     W1,W1
07454:  RRC     W0,W0
07456:  DEC     W11,W11
07458:  BRA     NZ,7444
0745A:  BTSS    W9.F
0745C:  BRA     7468
0745E:  NEG     W0,W0
07460:  COM     W1,W1
07462:  COM     W2,W2
07464:  COM     W3,W3
07466:  BRA     7468
07468:  MOV     #16,W5
0746A:  REPEAT  #5
0746C:  MOV     [--W15],[W5--]
0746E:  MOV     [--W15],W5
07470:  RETURN  
07472:  MOV     W12,[W15++]
07474:  MOV     W13,[W15++]
07476:  CLR     W8
07478:  CLR     W9
0747A:  CLR     W10
0747C:  CLR     W11
0747E:  CLR     W12
07480:  CLR     W13
07482:  MOV     #E,W8
07484:  MOV     #0,W9
07486:  LNK     #10
07488:  MOV     W12,[W14+W8]
0748A:  DEC2    W8,W8
0748C:  BRA     NN,7488
0748E:  XOR     W4,W5,W8
07490:  BRA     NZ,7496
07492:  XOR     W6,W7,W8
07494:  BRA     Z,74F4
07496:  CLR     W8
07498:  MOV     #40,W13
0749A:  MOV     #40,W13
0749C:  BCLR.B  42.0
0749E:  RLC     W0,W0
074A0:  RLC     W1,W1
074A2:  RLC     W2,W2
074A4:  RLC     W3,W3
074A6:  RLC     W8,W8
074A8:  RLC     W9,W9
074AA:  RLC     W10,W10
074AC:  RLC     W11,W11
074AE:  CP      W11,W7
074B0:  BRA     NZ,74BC
074B2:  CPB     W10,W6
074B4:  BRA     NZ,74BC
074B6:  CPB     W9,W5
074B8:  BRA     NZ,74BC
074BA:  CPB     W8,W4
074BC:  BRA     NC,74C8
074BE:  SUB     W8,W4,W8
074C0:  SUBB    W9,W5,W9
074C2:  SUBB    W10,W6,W10
074C4:  SUBB    W11,W7,W11
074C6:  BSET.B  42.0
074C8:  MOV     W8,[W14]
074CA:  MOV     W9,[W14+#2]
074CC:  MOV     W10,[W14+#4]
074CE:  MOV     W11,[W14+#6]
074D0:  MOV     [W14+#8],W8
074D2:  MOV     [W14+#A],W9
074D4:  MOV     [W14+#C],W10
074D6:  MOV     [W14+#E],W11
074D8:  RLC     W8,W8
074DA:  RLC     W9,W9
074DC:  RLC     W10,W10
074DE:  RLC     W11,W11
074E0:  MOV     W8,[W14+#8]
074E2:  MOV     W9,[W14+#A]
074E4:  MOV     W10,[W14+#C]
074E6:  MOV     W11,[W14+#E]
074E8:  MOV     [W14],W8
074EA:  MOV     [W14+#2],W9
074EC:  MOV     [W14+#4],W10
074EE:  MOV     [W14+#6],W11
074F0:  DEC     W13,W13
074F2:  BRA     NZ,749C
074F4:  MOV     [W14+#8],W0
074F6:  MOV     [W14+#A],W1
074F8:  MOV     [W14+#C],W2
074FA:  MOV     [W14+#E],W3
074FC:  ULNK    
074FE:  BRA     7500
07500:  MOV     [--W15],W13
07502:  MOV     [--W15],W12
07504:  RETURN  
07506:  MOV     W5,[W15++]
07508:  MOV     #C,W5
0750A:  REPEAT  #7
0750C:  MOV     [W5++],[W15++]
0750E:  LNK     #2A
07510:  MOV     #28,W8
07512:  CLR     W12
07514:  MOV     W12,[W14+W8]
07516:  DEC2    W8,W8
07518:  BRA     NN,7514
0751A:  MOV     W10,[W14+#28]
0751C:  CP0     W9
0751E:  BRA     Z,753A
07520:  MOV     W9,[W14+#26]
07522:  MOV     #4024,W7
07524:  CLR     W6
07526:  MUL.UU  W4,#0,W4
07528:  MOV     W9,[W14+#24]
0752A:  MOV     #4024,W7
0752C:  CLR     W6
0752E:  MUL.UU  W4,#0,W4
07530:  CALL    730C
07534:  MOV     [W14+#24],W9
07536:  DEC     W9,W9
07538:  BRA     NZ,7528
0753A:  MOV     [W14+#26],W9
0753C:  MOV     #14,W8
0753E:  MOV     W8,[W14+#24]
07540:  MOV     #41CD,W7
07542:  MOV     #CD65,W6
07544:  MUL.UU  W4,#0,W4
07546:  MOV     W0,[W14+#10]
07548:  MOV     W1,[W14+#12]
0754A:  MOV     W2,[W14+#14]
0754C:  MOV     W3,[W14+#16]
0754E:  MOV     #14,W8
07550:  MOV     W8,[W14+#20]
07552:  MOV     #0,W4
07554:  MOV     #89E8,W5
07556:  MOV     #2304,W6
07558:  MOV     #8AC7,W7
0755A:  MOV     W4,[W14+#18]
0755C:  MOV     W5,[W14+#1A]
0755E:  MOV     W6,[W14+#1C]
07560:  MOV     W7,[W14+#1E]
07562:  BTSS    W3.F
07564:  BRA     756E
07566:  MOV     [W14+#28],W8
07568:  DEC     W8,W8
0756A:  BSET    W8.D
0756C:  MOV     W8,[W14+#28]
0756E:  BCLR    W3.F
07570:  CALL    741C
07574:  MOV     [W14+#28],W8
07576:  MOV     [W14+#26],W9
07578:  CP0     W9
0757A:  BTSC.B  42.1
0757C:  INC.B   W8L,W8L
0757E:  MOV     W8,[W14+#28]
07580:  MOV     [W14+#22],W9
07582:  CLR     W9
07584:  MOV     W9,[W14+#22]
07586:  MOV     [W14+#18],W4
07588:  MOV     [W14+#1A],W5
0758A:  MOV     [W14+#1C],W6
0758C:  MOV     [W14+#1E],W7
0758E:  CALL    7472
07592:  MOV     [W14+#22],W13
07594:  BTSC    W13.0
07596:  BRA     7668
07598:  MOV     W8,[W14+#10]
0759A:  MOV     W9,[W14+#12]
0759C:  MOV     W10,[W14+#14]
0759E:  MOV     W11,[W14+#16]
075A0:  MOV     [W14+#22],W13
075A2:  BTG     W13.0
075A4:  MOV     W13,[W14+#22]
075A6:  CP0     W0
075A8:  BRA     NZ,75CE
075AA:  MOV     [W14+#26],W9
075AC:  INC     W9,W9
075AE:  MOV     [W14+#24],W10
075B0:  SUB     W10,W9,W8
075B2:  BRA     Z,75CE
075B4:  MOV     [W14+#28],W11
075B6:  CP0     W11
075B8:  BRA     Z,75D6
075BA:  AND     W11,#1F,W8
075BC:  SUB     W10,W8,W8
075BE:  BRA     Z,75C2
075C0:  BRA     C,7650
075C2:  BTSC    W11.F
075C4:  BRA     7650
075C6:  BTSC    W11.E
075C8:  BRA     75D6
075CA:  MOV     #20,W0
075CC:  BRA     7642
075CE:  MOV     [W14+#28],W11
075D0:  MOV     #2000,W12
075D2:  AND     W12,W11,W11
075D4:  MOV     W11,[W14+#28]
075D6:  MOV     [W14+#28],W11
075D8:  BTSS    W11.D
075DA:  BRA     75FC
075DC:  BCLR    W11.D
075DE:  MOV     [W14+#26],W9
075E0:  CP0     W9
075E2:  BTSS.B  42.1
075E4:  DEC     W11,W11
075E6:  CLR     W11
075E8:  MOV     W11,[W14+#28]
075EA:  MOV     W0,W10
075EC:  MOV     W1,[W15++]
075EE:  MOV.B   #2D,W0L
075F0:  CALL    35EA
075F4:  MOV     [--W15],W1
075F6:  MOV     W10,W0
075F8:  CLR     W11
075FA:  MOV     W11,[W14+#28]
075FC:  MOV     [W14+#26],W9
075FE:  MOV     [W14+#24],W10
07600:  SUB     W10,W9,W8
07602:  BRA     NZ,761E
07604:  CLR     W11
07606:  MOV     W11,[W14+#28]
07608:  MOV     W0,W10
0760A:  MOV     W1,[W15++]
0760C:  MOV.B   #2E,W0L
0760E:  CALL    35EA
07612:  MOV     [--W15],W1
07614:  MOV     [W14+#28],W11
07616:  MOV     #2000,W12
07618:  AND     W12,W11,W11
0761A:  MOV     W11,[W14+#28]
0761C:  MOV     W10,W0
0761E:  MOV     #30,W1
07620:  MOV     [W14+#28],W11
07622:  BTSS    W11.D
07624:  BRA     7642
07626:  BCLR    W11.D
07628:  MOV     [W14+#26],W9
0762A:  CP0     W9
0762C:  BTSS.B  42.1
0762E:  DEC     W11,W11
07630:  CLR     W11
07632:  MOV     W11,[W14+#28]
07634:  MOV     W1,[W15++]
07636:  MOV.B   #2D,W0L
07638:  CALL    35EA
0763C:  MOV     [--W15],W1
0763E:  CLR     W0
07640:  MOV     #30,W1
07642:  ADD     W1,W0,W0
07644:  MOV     W1,[W15++]
07646:  MOV     W0,[W15++]
07648:  MOV     [--W15],W0
0764A:  CALL    35EA
0764E:  MOV     [--W15],W1
07650:  MOV     [W14+#24],W13
07652:  DEC     W13,W13
07654:  BRA     Z,7688
07656:  MOV     W13,[W14+#24]
07658:  MOV     [W14+#18],W0
0765A:  MOV     [W14+#1A],W1
0765C:  MOV     [W14+#1C],W2
0765E:  MOV     [W14+#1E],W3
07660:  MOV     #A,W4
07662:  CLR     W5
07664:  MUL.UU  W6,#0,W6
07666:  BRA     758E
07668:  MOV     W0,[W14+#18]
0766A:  MOV     W1,[W14+#1A]
0766C:  MOV     W2,[W14+#1C]
0766E:  MOV     W3,[W14+#1E]
07670:  MOV     W0,W4
07672:  MOV     W1,W5
07674:  MOV     W2,W6
07676:  MOV     W3,W7
07678:  MOV     [W14+#10],W0
0767A:  MOV     [W14+#12],W1
0767C:  MOV     [W14+#14],W2
0767E:  MOV     [W14+#16],W3
07680:  MOV     [W14+#22],W13
07682:  BTG     W13.0
07684:  MOV     W13,[W14+#22]
07686:  BRA     758E
07688:  ULNK    
0768A:  MOV     #1A,W5
0768C:  REPEAT  #7
0768E:  MOV     [--W15],[W5--]
07690:  MOV     [--W15],W5
07692:  RETURN  
*
0770C:  MOV     W5,[W15++]
0770E:  MOV     #C,W5
07710:  REPEAT  #3
07712:  MOV     [W5++],[W15++]
07714:  MOV     W0,W7
07716:  MOV     W4,W9
07718:  BCLR    W4.F
0771A:  CP0     W4
0771C:  BRA     NZ,772A
0771E:  BTSC    W9.F
07720:  BRA     7726
07722:  MOV     #0,W5
07724:  BRA     7744
07726:  MOV     #0,W5
07728:  BRA     7744
0772A:  SUB.B   W4L,#6,W5L
0772C:  BRA     NC,7742
0772E:  MOV     #30,W0
07730:  BTSS    W9.F
07732:  MOV     #20,W0
07734:  BTSC.B  253.1
07736:  BRA     7734
07738:  MOV     W0,254
0773A:  DEC     W5,W5
0773C:  BRA     NN,7734
0773E:  MOV     #5,W5
07740:  BRA     7744
07742:  MOV     W4,W5
07744:  MOV     #6,W4
07746:  BSET    W5.E
07748:  BTSC    W9.F
0774A:  BSET    W5.F
0774C:  MOV     #2710,W8
0774E:  REPEAT  #11
07750:  DIV.U   W7,W8
07752:  CALL    7786
07756:  MOV     W1,W7
07758:  MOV     #3E8,W8
0775A:  REPEAT  #11
0775C:  DIV.U   W7,W8
0775E:  CALL    7786
07762:  MOV     W1,W7
07764:  MOV     #64,W8
07766:  REPEAT  #11
07768:  DIV.U   W7,W8
0776A:  CALL    7786
0776E:  MOV     W1,W7
07770:  MOV     #A,W8
07772:  REPEAT  #11
07774:  DIV.U   W7,W8
07776:  CALL    7786
0777A:  MOV     #30,W0
0777C:  ADD.B   W1L,W0L,W0L
0777E:  BTSC.B  253.1
07780:  BRA     777E
07782:  MOV     W0,254
07784:  BRA     77B4
07786:  MOV     #30,W6
07788:  CP0     W0
0778A:  BRA     NZ,77A8
0778C:  BTSS    W5.E
0778E:  BRA     77AA
07790:  DEC     W4,W4
07792:  CP.B    W4L,W5L
07794:  BRA     Z,779A
07796:  BTSC.B  42.0
07798:  RETURN  
0779A:  CP0     W0
0779C:  BRA     NZ,77A8
0779E:  BTSS    W5.E
077A0:  BRA     77AA
077A2:  BTSS    W5.F
077A4:  MOV     #20,W6
077A6:  BRA     77AA
077A8:  BCLR    W5.E
077AA:  ADD.B   W6L,W0L,W0L
077AC:  BTSC.B  253.1
077AE:  BRA     77AC
077B0:  MOV     W0,254
077B2:  RETURN  
077B4:  MOV     #12,W5
077B6:  REPEAT  #3
077B8:  MOV     [--W15],[W5--]
077BA:  MOV     [--W15],W5
077BC:  RETURN  
....................  
.................... #list 
....................  
.................... #define PIC24 1 
.................... #device PASS_STRINGS = IN_RAM 
.................... #DEVICE ICD=2 
.................... #device ADC=10 
.................... #device PSV=16 
.................... #device CONST=READ_ONLY 
.................... #use delay( crystal=8mhz, clock=32mhz ) 
*
021F2:  CP0     W0
021F4:  BTSC.B  42.1
021F6:  BRA     2200
021F8:  REPEAT  #3E7B
021FA:  NOP     
021FC:  DEC     W0,W0
021FE:  BRA     NZ,21F8
02200:  RETURN  
....................  
....................  
....................  
....................  
.................... #define debugDisplay 0 
.................... #define BUFFERSIZE 600 
.................... #define USEWEBSERVER 1 
.................... int16 testcntr=0; 
....................  
.................... #define USESENSORS 1 
....................  
.................... #define BTDEBUG 0 
.................... int1 wifisetup = 0; 
....................  
....................  
.................... #define SENDINTERVAL 800 
....................  
....................  
....................  
.................... int1 ROUTERHOLD=0; 
.................... int1 SCANERROR=0; 
.................... int1 ROUTERSCANING=0; 
.................... int1 checkScanError=0; 
....................  
.................... int1 ISWWWPARSE=0; 
....................  
.................... #define CLIENT 0 
.................... #define SERVER 1 
....................  
.................... int1 clientOrServer=SERVER;	//0 for client, 1 for server 
....................  
....................  
....................  
.................... char requestURLBuff[255]; 
.................... char WebPageTxtBuff[4000]; 
....................  
....................  
.................... int1 checkATOK =0; 
.................... int1 ATisOK=0; 
.................... int1 WFIsConfig=0; 
.................... int1 USEAT=0; 
.................... int1 resetParsing=0; 
....................  
....................  
.................... typedef struct outputDataStruct{ 
.................... char deviceID[16]; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int8 taosVersion; 
.................... float dOxy; 
.................... float wTemp; 
.................... float pH; 
.................... float wLevel; 
.................... float lLevelX; 
.................... float lLevelY; 
....................  
.................... int16 lLevelRed; 
.................... int16 lLevelGreen; 
.................... int16 lLevelBlue; 
.................... int16 lLevelClear; 
.................... int8 time; 
.................... int16 date; 
....................  
....................  
.................... float lLevelScale; 
.................... float rH,averagepH; 
.................... float aTemp; 
.................... int16 cO2; 
.................... float nH4; 
.................... float dPoint; 
.................... char DIEHARD[8]; 
.................... }outputData; 
....................  
....................  
.................... outputData sysOutput; 
.................... char timeString[28]; 
.................... int16 xp,yy; 
.................... float averagepH; 
....................  
.................... typedef struct inputDataStruct{ 
.................... unsigned int8 chksum; 
.................... unsigned int8 hour; 
.................... unsigned int8 minute; 
.................... unsigned int8 second; 
.................... unsigned int8 day; 
.................... unsigned int8 month; 
.................... unsigned int16 year; 
.................... unsigned int1 io1; 
.................... unsigned int1 io2; 
.................... unsigned int1 io3; 
.................... unsigned int8 uploadinterval;   //This is the upload time interval  It's default to 2 minutes for now. 
.................... }inputData; 
.................... inputData sysInput; 
....................  
....................  
....................  
....................  
....................  
.................... #include <float.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /* float.h  */ 
....................  
....................  
.................... #ifndef _FLOAT 
.................... #define _FLOAT 
....................     /* Float properties */ 
....................  
.................... #define FLT_RADIX       2 
.................... #define FLT_MANT_DIG    24                              // # of bits in mantissa 
....................  
.................... #define FLT_DIG         6                               // # of decimal digits of precision 
....................  
.................... #define FLT_MIN_EXP     (-125)                          // min binary exponent 
.................... #define FLT_MIN_10_EXP  (-37)                           // min decimal exponent 
.................... #define FLT_MAX_EXP     128                             // max binary exponent 
.................... #define FLT_MAX_10_EXP  38                              // max decimal exponent 
.................... #define FLT_MAX         3.402823466e+38F                // max value 
.................... #define FLT_EPSILON     1.192092896e-07F                // smallest such that 1.0+FLT_EPSILON != 1.0 
.................... #define FLT_MIN         1.175494351e-38F                // min positive value 
....................  
....................  
....................       /* Double properties */ 
.................... #define DBL_MANT_DIG    53                              // # of bits in mantissa 
....................  
.................... #define DBL_DIG         15                              // # of decimal digits of precision 
....................  
.................... #define DBL_MIN_EXP     (-1021)                         // min binary exponent 
.................... #define DBL_MIN_10_EXP  (-307)                          // min decimal exponent 
.................... #define DBL_MAX_EXP     1024                            // max binary exponent 
.................... #define DBL_MAX_10_EXP  308                             // max decimal exponent 
.................... #define DBL_MAX         1.79769313486231e+308F          // max value 
.................... #define DBL_EPSILON     2.2204460492503131e-16F         // smallest such that 1.0+FLT_EPSILON != 1.0 
.................... #define DBL_MIN         2.22507385850721e-308F          // min positive value 
....................  
....................          /*Long double properties */ 
....................           
.................... #define LDBL_MANT_DIG    64                             // # of bits in mantissa 
....................  
.................... #define LDBL_DIG         18                             // # of decimal digits of precision 
....................  
.................... #define LDBL_MIN_EXP     (-16381)                       // min binary exponent 
.................... #define LDBL_MIN_10_EXP  (-4931)                        // min decimal exponent 
.................... #define LDBL_MAX_EXP     16384                          // max binary exponent 
.................... #define LDBL_MAX_10_EXP  4932                           // max decimal exponent 
.................... #define LDBL_MAX         1.18973149535723176502e+4932F  // max value 
.................... #define LDBL_EPSILON     1.084202172485504434e-019F     // smallest such that 1.0+FLT_EPSILON != 1.0 
.................... #define LDBL_MIN         3.36210314311209350626e-4932F  // min positive value 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "HC-06.c" 
.................... //////////////////////////////////////////////////////////////// 
.................... //HC-06.c 
.................... // 
.................... //By: Erik Gokbora 
.................... // 
.................... //Associated functions to automate the setup and communication with the bluetooth module 
....................  
....................  
....................  
.................... //int32 baudArray[20]={50,75,110,134,150,200,300,600,1200,2400,9600,19200,38400,57600,115200,230400,345600,460800}; 
....................  
.................... #ifdef PIC24 
.................... #pin_select U1TX=PIN_B1  
.................... #pin_select U1RX=PIN_B0  
.................... #use rs232(UART1, baud=9600, stream=BT) 
.................... #else 
.................... #use rs232(uart1, baud=9600, xmit=PIN_C6, rcv=PIN_C7, stream=BT) 
.................... //#use rs232(uart1, baud=BTBAUDR, parity=N,bits=8,stop=1, stream=BT) 
.................... #endif 
.................... ////////////////////////RS232 Interrupt////////////////////// 
.................... #ifndef BT_BUFF_SIZE  
.................... #define BT_BUFF_SIZE 255 
.................... #endif 
....................  
....................  
....................  
....................  
.................... //int8 buffer[255]; 
....................  
.................... int8 BTbuffer[BT_BUFF_SIZE]; 
....................  
.................... //int8 next_in  = 0; 
.................... //int8 next_out = 0; 
....................  
.................... int16 BTnext_in  = 0; 
.................... int16 BTnext_out = 0; 
....................  
....................  
....................  
....................  
.................... #ifdef PIC24 
.................... #INT_RDA 
.................... #else 
.................... #INT_RDA 
.................... #endif 
.................... void RDA_isr() 
*
0168E:  PUSH    42
01690:  PUSH    36
01692:  PUSH    32
01694:  MOV     W0,[W15++]
01696:  MOV     #2,W0
01698:  REPEAT  #C
0169A:  MOV     [W0++],[W15++]
.................... { 
....................    int8 tbt; 
....................  
....................    BTbuffer[BTnext_in] = fgetc(BT); 
0169C:  MOV     #198C,W4
0169E:  MOV     1A8C,W3
016A0:  ADD     W3,W4,W5
016A2:  BTSS.B  222.0
016A4:  BRA     16A2
016A6:  MOV     226,W0
016A8:  MOV.B   W0L,[W5]
....................    tbt = BTnext_in; 
016AA:  MOV.B   1A8C,W0L
016AC:  PUSH    39CA
016AE:  MOV.B   W0L,[W15-#2]
016B0:  POP     39CA
....................    BTnext_in = (BTnext_in+1) % sizeof(BTbuffer); 
016B2:  MOV     1A8C,W4
016B4:  ADD     W4,#1,W4
016B6:  MOV     W4,W5
016B8:  MOV     W5,W4
016BA:  MOV     #FF,W3
016BC:  REPEAT  #11
016BE:  DIV.S   W4,W3
016C0:  MOV     W1,1A8C
....................    if(BTnext_in == BTnext_out) 
016C2:  MOV     1A8C,W0
016C4:  CP      1A8E
016C6:  BRA     NZ,16CE
.................... 		{ 
....................       	BTnext_in=tbt;        // Buffer full !! 
016C8:  MOV     39CA,W0
016CA:  SE      W0,W0
016CC:  MOV     W0,1A8C
.................... 		} 
.................... 	//ADDED Crap 
.................... 	if(BTnext_in==BT_BUFF_SIZE) 
016CE:  MOV     1A8C,W4
016D0:  XOR     #FF,W4
016D2:  BRA     NZ,16D6
.................... 	{ 
.................... 		BTnext_in=0; 
016D4:  CLR     1A8C
.................... 	}	 
.................... 	//ADDED Crap 
.................... 	if(BTnext_out==BT_BUFF_SIZE) 
016D6:  MOV     1A8E,W4
016D8:  XOR     #FF,W4
016DA:  BRA     NZ,16DE
.................... 	{ 
.................... 		BTnext_out=0; 
016DC:  CLR     1A8E
.................... 	} 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
.................... //////////////////////////////////////////////////////////// 
....................  
016DE:  BCLR.B  85.3
016E0:  MOV     #1A,W0
016E2:  REPEAT  #C
016E4:  MOV     [--W15],[W0--]
016E6:  MOV     [--W15],W0
016E8:  POP     32
016EA:  POP     36
016EC:  POP     42
016EE:  RETFIE  
.................... #define BTbkbhit (BTnext_in != BTnext_out) 
.................... //#define bkbhitDebug (next_in != next_outDebug) 
....................  
.................... int8 BTbgetc() 
.................... { 
....................    int8 c; 
....................  
....................    while(!BTbkbhit); 
....................    c = BTbuffer[BTnext_out]; 
....................    BTnext_out = (BTnext_out+1) % sizeof(BTbuffer);  
....................    return c; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////// 
....................  
.................... void BTBasicTest(){ 
.................... 	if(BTbkbhit){ 
.................... 	//if(kbhit()){ 
.................... 		//putc('!'); 
.................... 		//putc(getc()); 
.................... 		//char cvl= getc(); 
....................  
.................... 		//char cvl = bgetc(); 
.................... 		char cvl =BTbgetc(); 		//getWIFIChar(); 
.................... 		putc(cvl,BT); 
.................... 		putc('\n',BT); 
.................... 	} 
.................... } 
....................  
.................... /////////////////////////////////////////////////////////// 
....................  
.................... void setupBT() 
.................... { 
.................... printf("AT+NAMEPaul's Tesla Meter"); 
.................... } 
....................  
.................... #include "crc8.c" 
....................   
.................... //////////////////////////////////////////////////// 
.................... // name:crc8.c 
.................... // origional author: HabibS (http://stackoverflow.com/questions/14079444/how-to-generate-8bit-crc-in-php) 
.................... // Transcribed By: Erik Gokbora 
.................... // 
.................... // description: Uses a lookup table to generate a CRC8 checksum from a string of characters 
.................... // 
....................   
....................  
....................  
....................  
....................  
.................... unsigned int8 crcLookup[] = {0x00, 0x3e, 0x7c, 0x42, 0xf8, 0xc6, 0x84, 0xba, 0x95, 0xab, 0xe9, 0xd7, 
....................     0x6d, 0x53, 0x11, 0x2f, 0x4f, 0x71, 0x33, 0x0d, 0xb7, 0x89, 0xcb, 0xf5, 
....................     0xda, 0xe4, 0xa6, 0x98, 0x22, 0x1c, 0x5e, 0x60, 0x9e, 0xa0, 0xe2, 0xdc, 
....................     0x66, 0x58, 0x1a, 0x24, 0x0b, 0x35, 0x77, 0x49, 0xf3, 0xcd, 0x8f, 0xb1, 
....................     0xd1, 0xef, 0xad, 0x93, 0x29, 0x17, 0x55, 0x6b, 0x44, 0x7a, 0x38, 0x06, 
....................     0xbc, 0x82, 0xc0, 0xfe, 0x59, 0x67, 0x25, 0x1b, 0xa1, 0x9f, 0xdd, 0xe3, 
....................     0xcc, 0xf2, 0xb0, 0x8e, 0x34, 0x0a, 0x48, 0x76, 0x16, 0x28, 0x6a, 0x54, 
....................     0xee, 0xd0, 0x92, 0xac, 0x83, 0xbd, 0xff, 0xc1, 0x7b, 0x45, 0x07, 0x39, 
....................     0xc7, 0xf9, 0xbb, 0x85, 0x3f, 0x01, 0x43, 0x7d, 0x52, 0x6c, 0x2e, 0x10, 
....................     0xaa, 0x94, 0xd6, 0xe8, 0x88, 0xb6, 0xf4, 0xca, 0x70, 0x4e, 0x0c, 0x32, 
....................     0x1d, 0x23, 0x61, 0x5f, 0xe5, 0xdb, 0x99, 0xa7, 0xb2, 0x8c, 0xce, 0xf0, 
....................     0x4a, 0x74, 0x36, 0x08, 0x27, 0x19, 0x5b, 0x65, 0xdf, 0xe1, 0xa3, 0x9d, 
....................     0xfd, 0xc3, 0x81, 0xbf, 0x05, 0x3b, 0x79, 0x47, 0x68, 0x56, 0x14, 0x2a, 
....................     0x90, 0xae, 0xec, 0xd2, 0x2c, 0x12, 0x50, 0x6e, 0xd4, 0xea, 0xa8, 0x96, 
....................     0xb9, 0x87, 0xc5, 0xfb, 0x41, 0x7f, 0x3d, 0x03, 0x63, 0x5d, 0x1f, 0x21, 
....................     0x9b, 0xa5, 0xe7, 0xd9, 0xf6, 0xc8, 0x8a, 0xb4, 0x0e, 0x30, 0x72, 0x4c, 
....................     0xeb, 0xd5, 0x97, 0xa9, 0x13, 0x2d, 0x6f, 0x51, 0x7e, 0x40, 0x02, 0x3c, 
....................     0x86, 0xb8, 0xfa, 0xc4, 0xa4, 0x9a, 0xd8, 0xe6, 0x5c, 0x62, 0x20, 0x1e, 
....................     0x31, 0x0f, 0x4d, 0x73, 0xc9, 0xf7, 0xb5, 0x8b, 0x75, 0x4b, 0x09, 0x37, 
....................     0x8d, 0xb3, 0xf1, 0xcf, 0xe0, 0xde, 0x9c, 0xa2, 0x18, 0x26, 0x64, 0x5a, 
....................     0x3a, 0x04, 0x46, 0x78, 0xc2, 0xfc, 0xbe, 0x80, 0xaf, 0x91, 0xd3, 0xed, 
....................     0x57, 0x69, 0x2b, 0x15}; 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... unsigned int8 Calc_Crc8(char inVal[],int16 length) 
*
076B8:  MOV     W5,[W15++]
076BA:  MOV     #0,W4
076BC:  MOV     W4,380A
076BE:  MOV     380C,W0
076C0:  MOV.B   #FF,W0L
076C2:  MOV     W0,380C
076C4:  MOV     #0,W4
076C6:  MOV     W4,380E
.................... { 
.................... unsigned int16 cntr=0; 
.................... unsigned int8 crc=0xFF; 
.................... unsigned int16 cntrEFF=0; 
.................... 	for(cntrEFF=0;cntrEFF<length;cntrEFF++) 
076C8:  MOV     #0,W4
076CA:  MOV     W4,380E
076CC:  MOV     380E,W0
076CE:  MOV     3808,W4
076D0:  CP      W4,W0
076D2:  BRA     LE,7702
.................... 	{ 
.................... 	crc=crcLookup[crc ^ inVal[cntr]]; 
076D4:  MOV     380A,W0
076D6:  MOV     3806,W4
076D8:  ADD     W0,W4,W0
076DA:  MOV     W0,W4
076DC:  MOV.B   [W4],W0L
076DE:  MOV     380C,W4
076E0:  CLR.B   9
076E2:  XOR.B   W4L,W0L,W0L
076E4:  ZE      W0,W0
076E6:  CLR.B   1
076E8:  MOV     #1A90,W4
076EA:  ADD     W0,W4,W0
076EC:  MOV     380C,W4
076EE:  MOV.B   [W0+#0],W4L
076F0:  MOV     W4,380C
....................     cntr++; 
076F2:  MOV     380A,W0
076F4:  INC     W0,W0
076F6:  MOV     W0,380A
076F8:  MOV     380E,W0
076FA:  INC     W0,W0
076FC:  MOV     W0,380E
076FE:  GOTO    76CC
.................... 	} 
.................... return crc^0xFF; 
07702:  MOV     380C,W0
07704:  CLR.B   1
07706:  XOR     #FF,W0
07708:  MOV     [--W15],W5
0770A:  RETURN  
.................... } 
....................  
....................  
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
*
04934:  MOV     W5,[W15++]
04936:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
04938:  PUSH    383C
0493A:  POP     3840
0493C:  PUSH    383E
0493E:  POP     3842
....................  
....................    if (y != 1.0) 
04940:  MOV     3840,W0
04942:  MOV     3842,W1
04944:  MOV     #0,W2
04946:  MOV     #3F80,W3
04948:  CALL    45FA
0494C:  BRA     Z,4AE2
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
0494E:  MOV     #3843,W0
04950:  MOV     W0,[W15++]
04952:  MOV.B   [W0],W0L
04954:  PUSH    3850
04956:  MOV.B   W0L,[W15-#1]
04958:  POP     3850
0495A:  MOV     [--W15],W0
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
0495C:  MOV     #3843,W5
0495E:  MOV.B   #3F,W0L
04960:  MOV.B   W0L,[W5]
....................    data1 = *(((unsigned int8 *)(&y))+2); 
04962:  MOV     #3842,W0
04964:  MOV     3850,W4
04966:  MOV.B   [W0+#0],W4L
04968:  MOV     W4,3850
....................    bit_clear(data1,7); 
0496A:  MOV     3850,W0
0496C:  CLR.B   1
0496E:  BCLR    W0.7
04970:  PUSH    3850
04972:  MOV.B   W0L,[W15-#2]
04974:  POP     3850
....................    *(((unsigned int8 *)(&y))+2) = data1; 
04976:  MOV     #3842,W5
04978:  MOV     3850,W0
0497A:  MOV.B   W0L,[W5+#0]
....................    if(bit_test(data2,7)) 
0497C:  MOV     3850,W4
0497E:  BTSS    W4.F
04980:  BRA     4990
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
04982:  MOV     #3840,W5
04984:  ADD     W5,#3,W5
04986:  MOV     W5,W0
04988:  MOV     W0,W5
0498A:  MOV.B   [W5],W4L
0498C:  IOR.B   #80,W4L
0498E:  MOV.B   W4L,[W5+#0]
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
04990:  BSET.B  43.0
04992:  MOV     3840,W0
04994:  MOV     3842,W1
04996:  MOV     #0,W2
04998:  MOV     #3F80,W3
0499A:  CALL    478A
0499E:  MOV     W0,W5
049A0:  MOV     W1,W6
049A2:  BCLR.B  43.0
049A4:  MOV     3840,W0
049A6:  MOV     3842,W1
049A8:  MOV     #0,W2
049AA:  MOV     #3F80,W3
049AC:  CALL    478A
049B0:  MOV     W0,W2
049B2:  MOV     W1,W3
049B4:  MOV     W5,W0
049B6:  MOV     W6,W1
049B8:  CALL    4530
049BC:  MOV     W0,3840
049BE:  MOV     W1,3842
....................  
....................       y2=y*y; 
049C0:  MOV     3840,W0
049C2:  MOV     3842,W1
049C4:  MOV     3840,W2
049C6:  MOV     3842,W3
049C8:  CALL    46C6
049CC:  MOV     W0,384C
049CE:  MOV     W1,384E
....................  
....................       res = pl[0]*y2 + pl[1]; 
049D0:  MOV     1C08,W0
049D2:  MOV     1C0A,W1
049D4:  MOV     384C,W2
049D6:  MOV     384E,W3
049D8:  CALL    46C6
049DC:  MOV     W0,W5
049DE:  MOV     W1,W6
049E0:  BCLR.B  43.0
049E2:  MOV     W5,W0
049E4:  MOV     W6,W1
049E6:  MOV     1C0C,W2
049E8:  MOV     1C0E,W3
049EA:  CALL    478A
049EE:  MOV     W0,3844
049F0:  MOV     W1,3846
....................  
....................       r = ql[0]*y2 + ql[1]; 
049F2:  MOV     1C18,W0
049F4:  MOV     1C1A,W1
049F6:  MOV     384C,W2
049F8:  MOV     384E,W3
049FA:  CALL    46C6
049FE:  MOV     W0,W5
04A00:  MOV     W1,W6
04A02:  BCLR.B  43.0
04A04:  MOV     W5,W0
04A06:  MOV     W6,W1
04A08:  MOV     1C1C,W2
04A0A:  MOV     1C1E,W3
04A0C:  CALL    478A
04A10:  MOV     W0,3848
04A12:  MOV     W1,384A
....................       r = r*y2 + 1.0; 
04A14:  MOV     3848,W0
04A16:  MOV     384A,W1
04A18:  MOV     384C,W2
04A1A:  MOV     384E,W3
04A1C:  CALL    46C6
04A20:  MOV     W0,W5
04A22:  MOV     W1,W6
04A24:  BCLR.B  43.0
04A26:  MOV     W5,W0
04A28:  MOV     W6,W1
04A2A:  MOV     #0,W2
04A2C:  MOV     #3F80,W3
04A2E:  CALL    478A
04A32:  MOV     W0,3848
04A34:  MOV     W1,384A
....................  
....................       res = y*res/r; 
04A36:  MOV     3840,W0
04A38:  MOV     3842,W1
04A3A:  MOV     3844,W2
04A3C:  MOV     3846,W3
04A3E:  CALL    46C6
04A42:  MOV     W0,W5
04A44:  MOV     W1,W6
04A46:  MOV     W5,W0
04A48:  MOV     W6,W1
04A4A:  MOV     3848,W2
04A4C:  MOV     384A,W3
04A4E:  CALL    4530
04A52:  MOV     W0,3844
04A54:  MOV     W1,3846
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
04A56:  MOV     #383F,W0
04A58:  MOV     3850,W4
04A5A:  MOV.B   [W0+#0],W4L
04A5C:  MOV     W4,3850
....................     rotate_left(&data1,1); 
04A5E:  MOV     #3850,W1
04A60:  RLNC.B  [W1],[W1++]
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
04A62:  MOV     #383E,W0
04A64:  MOV     W0,[W15++]
04A66:  MOV.B   [W0],W0L
04A68:  PUSH    3850
04A6A:  MOV.B   W0L,[W15-#1]
04A6C:  POP     3850
04A6E:  MOV     [--W15],W0
....................     if(bit_test (data2,7)) 
04A70:  MOV     3850,W4
04A72:  BTSS    W4.F
04A74:  BRA     4A82
....................       bit_set(data1,0); 
04A76:  MOV     3850,W0
04A78:  CLR.B   1
04A7A:  BSET    W0.0
04A7C:  PUSH    3850
04A7E:  MOV.B   W0L,[W15-#2]
04A80:  POP     3850
....................     n = data1 - 0x7E; 
04A82:  MOV     3850,W4
04A84:  CLR.B   9
04A86:  MOV     #7E,W3
04A88:  SUB     W4,W3,W0
04A8A:  PUSH    3852
04A8C:  MOV.B   W0L,[W15-#2]
04A8E:  POP     3852
.................... #endif 
....................  
....................       if (n<0)  
04A90:  MOV     3852,W0
04A92:  SE      W0,W0
04A94:  CP      W0,#0
04A96:  BRA     GE,4AB4
....................          r = -(float32)-n; 
04A98:  MOV     3852,W0
04A9A:  CLR.B   1
04A9C:  MOV     #0,W4
04A9E:  SUB.B   W4L,W0L,W0L
04AA0:  SE      W0,W0
04AA2:  CALL    44E6
04AA6:  MOV     W0,3848
04AA8:  MOV     W1,384A
04AAA:  MOV     384A,W0
04AAC:  BTG     W0.F
04AAE:  MOV     W0,384A
04AB0:  GOTO    4AC0
....................       else 
....................          r = (float32)n; 
04AB4:  MOV     3852,W0
04AB6:  SE      W0,W0
04AB8:  CALL    44E6
04ABC:  MOV     W0,3848
04ABE:  MOV     W1,384A
....................  
....................       res += r*LN2; 
04AC0:  MOV     3848,W0
04AC2:  MOV     384A,W1
04AC4:  MOV     #7218,W2
04AC6:  MOV     #3F31,W3
04AC8:  CALL    46C6
04ACC:  BCLR.B  43.0
04ACE:  MOV     W0,W2
04AD0:  MOV     W1,W3
04AD2:  MOV     3844,W0
04AD4:  MOV     3846,W1
04AD6:  CALL    478A
04ADA:  MOV     W0,3844
04ADC:  MOV     W1,3846
....................    } 
04ADE:  GOTO    4AEA
....................  
....................    else 
....................       res = 0.0; 
04AE2:  MOV     #0,W4
04AE4:  MOV     W4,3844
04AE6:  MOV     #0,W4
04AE8:  MOV     W4,3846
....................  
....................    return(res); 
04AEA:  MOV     3844,W0
04AEC:  MOV     3846,W1
04AEE:  MOV     [--W15],W6
04AF0:  MOV     [--W15],W5
04AF2:  RETURN  
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
*
05458:  PUSH    3820
0545A:  POP     383C
0545C:  PUSH    3822
0545E:  POP     383E
05460:  CALL    4934
05464:  MOV     W0,3824
05466:  MOV     W1,3826
....................    r = r*LN10_INV; 
05468:  MOV     3824,W0
0546A:  MOV     3826,W1
0546C:  MOV     #5BD9,W2
0546E:  MOV     #3EDE,W3
05470:  CALL    46C6
05474:  MOV     W0,3824
05476:  MOV     W1,3826
....................    return(r); 
05478:  MOV     3824,W0
0547A:  MOV     3826,W1
0547C:  RETURN  
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
*
03578:  MOV     W5,[W15++]
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
0357A:  PUSH    39B6
0357C:  POP     39BC
0357E:  MOV     39BA,W0
03580:  CP0     W0
03582:  BRA     Z,35AC
03584:  MOV     39B8,W0
03586:  CP0.B   [W0]
03588:  BRA     Z,35AC
....................      *s++ = *s2++; 
0358A:  MOV     39BC,W0
0358C:  MOV     W0,[W15++]
0358E:  INC     W0,W0
03590:  MOV     W0,39BC
03592:  MOV     [--W15],W0
03594:  MOV     W0,W5
03596:  MOV     39B8,W0
03598:  MOV     W0,[W15++]
0359A:  INC     W0,W0
0359C:  MOV     W0,39B8
0359E:  MOV     [--W15],W0
035A0:  MOV.B   [W0],[W5]
035A2:  MOV     39BA,W0
035A4:  DEC     W0,W0
035A6:  MOV     W0,39BA
035A8:  GOTO    357E
....................   for (; n > 0; n--) 
035AC:  MOV     39BA,W0
035AE:  CP0     W0
035B0:  BRA     Z,35CA
....................      *s++ = '\0'; 
035B2:  MOV     39BC,W0
035B4:  MOV     W0,[W15++]
035B6:  INC     W0,W0
035B8:  MOV     W0,39BC
035BA:  MOV     [--W15],W0
035BC:  MOV     W0,W5
035BE:  CLR.B   [W5]
035C0:  MOV     39BA,W0
035C2:  DEC     W0,W0
035C4:  MOV     W0,39BA
035C6:  GOTO    35AC
....................  
....................   return(s1); 
035CA:  PUSH    39B6
035CC:  POP     0
035CE:  MOV     [--W15],W5
035D0:  RETURN  
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
*
02F00:  MOV     W5,[W15++]
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
02F02:  MOV     39B6,W0
02F04:  CP0     W0
02F06:  BRA     Z,2F5A
....................       if (*s1 != *s2) 
02F08:  MOV     39B2,W0
02F0A:  MOV.B   [W0],W5L
02F0C:  MOV     39B4,W0
02F0E:  MOV     W0,W4
02F10:  MOV.B   [W4],W0L
02F12:  CP.B    W5L,W0L
02F14:  BRA     Z,2F32
....................          return((*s1 <*s2) ? -1: 1); 
02F16:  MOV     39B2,W0
02F18:  MOV.B   [W0],W5L
02F1A:  MOV     39B4,W0
02F1C:  MOV     W0,W4
02F1E:  MOV.B   [W4],W0L
02F20:  CP.B    W5L,W0L
02F22:  BRA     C,2F2A
02F24:  SETM.B  W0
02F26:  GOTO    2F2C
02F2A:  MOV.B   #1,W0L
02F2C:  BRA     2F5C
02F2E:  GOTO    2F3C
....................       else if (*s1 == '\0') 
02F32:  MOV     39B2,W0
02F34:  CP0.B   [W0]
02F36:  BRA     NZ,2F3C
....................          return(0); 
02F38:  CLR.B   0
02F3A:  BRA     2F5C
02F3C:  MOV     39B2,W0
02F3E:  MOV     W0,[W15++]
02F40:  INC     W0,W0
02F42:  MOV     W0,39B2
02F44:  MOV     [--W15],W0
02F46:  MOV     39B4,W0
02F48:  MOV     W0,[W15++]
02F4A:  INC     W0,W0
02F4C:  MOV     W0,39B4
02F4E:  MOV     [--W15],W0
02F50:  MOV     39B6,W0
02F52:  DEC     W0,W0
02F54:  MOV     W0,39B6
02F56:  GOTO    2F02
....................    return(0); 
02F5A:  CLR.B   0
02F5C:  MOV     [--W15],W5
02F5E:  RETURN  
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
*
028FC:  MOV     W5,[W15++]
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
028FE:  MOV     3982,W0
02900:  PUSH    3982
02902:  MOV.B   W0L,[W15-#1]
02904:  POP     3982
....................    for(su=s;0<n;++su,--n) 
02906:  PUSH    3980
02908:  POP     3986
0290A:  MOV     3984,W0
0290C:  CP      W0,#0
0290E:  BRA     LEU,2932
....................       if(*su==uc) 
02910:  MOV     3986,W0
02912:  MOV     3982,W4
02914:  LSR     W4,#8,W4
02916:  MOV.B   [W0],W3L
02918:  CP.B    W4L,W3L
0291A:  BRA     NZ,2922
....................       return su; 
0291C:  PUSH    3986
0291E:  POP     0
02920:  BRA     2934
02922:  MOV     3986,W0
02924:  INC     W0,W0
02926:  MOV     W0,3986
02928:  MOV     3984,W0
0292A:  DEC     W0,W0
0292C:  MOV     W0,3984
0292E:  GOTO    290A
....................    return NULL; 
02932:  CLR     0
02934:  MOV     [--W15],W5
02936:  RETURN  
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
*
0354E:  MOV     W5,[W15++]
.................... { 
....................    for (; *s != c; s++) 
03550:  MOV     39B2,W0
03552:  MOV     39B4,W4
03554:  CLR.B   9
03556:  MOV.B   [W0],W3L
03558:  CP.B    W4L,W3L
0355A:  BRA     Z,3570
....................       if (*s == '\0') 
0355C:  MOV     39B2,W0
0355E:  CP0.B   [W0]
03560:  BRA     NZ,3566
....................          return(0); 
03562:  CLR     0
03564:  BRA     3574
03566:  MOV     39B2,W0
03568:  INC     W0,W0
0356A:  MOV     W0,39B2
0356C:  GOTO    3550
....................    return(s); 
03570:  PUSH    39B2
03572:  POP     0
03574:  MOV     [--W15],W5
03576:  RETURN  
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
*
02F60:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
02F62:  MOV     39C6,W0
02F64:  CP0.B   [W0]
02F66:  BRA     Z,2FAA
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
02F68:  PUSH    39C6
02F6A:  POP     39CA
02F6C:  PUSH    39C8
02F6E:  POP     39CC
02F70:  MOV     39CC,W0
02F72:  CP0.B   [W0]
02F74:  BRA     Z,2F94
02F76:  MOV     39CA,W0
02F78:  MOV.B   [W0],W5L
02F7A:  MOV     39CC,W0
02F7C:  MOV     W0,W4
02F7E:  MOV.B   [W4],W0L
02F80:  CP.B    W5L,W0L
02F82:  BRA     NZ,2F94
02F84:  MOV     39CA,W0
02F86:  INC     W0,W0
02F88:  MOV     W0,39CA
02F8A:  MOV     39CC,W0
02F8C:  INC     W0,W0
02F8E:  MOV     W0,39CC
02F90:  GOTO    2F70
....................  
....................       if (*t == '\0') 
02F94:  MOV     39CC,W0
02F96:  CP0.B   [W0]
02F98:  BRA     NZ,2FA0
....................          return s1; 
02F9A:  PUSH    39C6
02F9C:  POP     0
02F9E:  BRA     2FAC
....................       ++s1; 
02FA0:  MOV     39C6,W0
02FA2:  INC     W0,W0
02FA4:  MOV     W0,39C6
....................       #ifdef FASTER_BUT_MORE_ROM 
02FA6:  GOTO    2F62
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
02FAA:  CLR     0
02FAC:  MOV     [--W15],W5
02FAE:  RETURN  
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = beg; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
*
02744:  MOV     W5,[W15++]
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
02746:  PUSH    39CE
02748:  POP     39D0
0274A:  MOV     39D0,W0
0274C:  CP0.B   [W0]
0274E:  BRA     Z,275A
02750:  MOV     39D0,W0
02752:  INC     W0,W0
02754:  MOV     W0,39D0
02756:  GOTO    274A
....................    return(sc - s); 
0275A:  MOV     39D0,W0
0275C:  MOV     39CE,W4
0275E:  SUB     W0,W4,W0
02760:  MOV     W0,0
02762:  MOV     [--W15],W5
02764:  RETURN  
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
*
03DD8:  MOV     W5,[W15++]
03DDA:  MOV     W6,[W15++]
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
03DDC:  MOV     #0,W4
03DDE:  MOV     W4,3946
....................    sign = 0; 
03DE0:  MOV     #0,W4
03DE2:  MOV     W4,3942
....................    base = 10; 
03DE4:  MOV     #A,W4
03DE6:  MOV     W4,3944
....................    result = 0; 
03DE8:  MOV     #0,W4
03DEA:  MOV     W4,3940
....................  
....................    if (!s) 
03DEC:  MOV     393E,W0
03DEE:  CP0     W0
03DF0:  BRA     NZ,3DF6
....................       return 0; 
03DF2:  CLR     0
03DF4:  BRA     3FDC
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
03DF6:  MOV     3946,W0
03DF8:  MOV     W0,[W15++]
03DFA:  INC     W0,W0
03DFC:  MOV     W0,3946
03DFE:  MOV     [--W15],W0
03E00:  MOV     W0,W5
03E02:  MOV     393E,W0
03E04:  ADD     W5,W0,W0
03E06:  MOV     3948,W4
03E08:  MOV.B   [W0+#0],W4L
03E0A:  MOV     W4,3948
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
03E0C:  MOV     3948,W0
03E0E:  CLR.B   1
03E10:  MOV     #2D,W4
03E12:  CP.B    W4L,W0L
03E14:  BRA     NZ,3E34
....................    { 
....................       sign = 1;         // Set the sign to negative 
03E16:  MOV     #1,W4
03E18:  MOV     W4,3942
....................       c = s[index++]; 
03E1A:  MOV     3946,W0
03E1C:  MOV     W0,[W15++]
03E1E:  INC     W0,W0
03E20:  MOV     W0,3946
03E22:  MOV     [--W15],W0
03E24:  MOV     W0,W5
03E26:  MOV     393E,W0
03E28:  ADD     W5,W0,W0
03E2A:  MOV     3948,W4
03E2C:  MOV.B   [W0+#0],W4L
03E2E:  MOV     W4,3948
....................    } 
03E30:  GOTO    3E54
....................    else if (c == '+') 
03E34:  MOV     3948,W0
03E36:  CLR.B   1
03E38:  MOV     #2B,W4
03E3A:  CP.B    W4L,W0L
03E3C:  BRA     NZ,3E54
....................    { 
....................       c = s[index++]; 
03E3E:  MOV     3946,W0
03E40:  MOV     W0,[W15++]
03E42:  INC     W0,W0
03E44:  MOV     W0,3946
03E46:  MOV     [--W15],W0
03E48:  MOV     W0,W5
03E4A:  MOV     393E,W0
03E4C:  ADD     W5,W0,W0
03E4E:  MOV     3948,W4
03E50:  MOV.B   [W0+#0],W4L
03E52:  MOV     W4,3948
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
03E54:  MOV     3948,W0
03E56:  CLR.B   1
03E58:  MOV     #30,W4
03E5A:  CP.B    W4L,W0L
03E5C:  BRA     GT,3FC4
03E5E:  MOV     3948,W0
03E60:  CLR.B   1
03E62:  MOV     #39,W4
03E64:  CP.B    W4L,W0L
03E66:  BRA     LT,3FC4
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
03E68:  MOV     3948,W0
03E6A:  CLR.B   1
03E6C:  MOV     #30,W4
03E6E:  CP.B    W4L,W0L
03E70:  BRA     NZ,3EAA
03E72:  MOV     3946,W0
03E74:  MOV     393E,W4
03E76:  ADD     W0,W4,W0
03E78:  MOV.B   [W0],W4L
03E7A:  XOR.B   #78,W4L
03E7C:  BRA     Z,3E8A
03E7E:  MOV     3946,W0
03E80:  MOV     393E,W4
03E82:  ADD     W0,W4,W0
03E84:  MOV.B   [W0],W4L
03E86:  XOR.B   #58,W4L
03E88:  BRA     NZ,3EAA
....................       { 
....................          base = 16; 
03E8A:  MOV     #10,W4
03E8C:  MOV     W4,3944
....................          index++; 
03E8E:  MOV     3946,W0
03E90:  INC     W0,W0
03E92:  MOV     W0,3946
....................          c = s[index++]; 
03E94:  MOV     3946,W0
03E96:  MOV     W0,[W15++]
03E98:  INC     W0,W0
03E9A:  MOV     W0,3946
03E9C:  MOV     [--W15],W0
03E9E:  MOV     W0,W5
03EA0:  MOV     393E,W0
03EA2:  ADD     W5,W0,W0
03EA4:  MOV     3948,W4
03EA6:  MOV.B   [W0+#0],W4L
03EA8:  MOV     W4,3948
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
03EAA:  MOV     3944,W0
03EAC:  CP      W0,#A
03EAE:  BRA     NZ,3EF6
....................       { 
....................          while (c >= '0' && c <= '9') 
03EB0:  MOV     3948,W0
03EB2:  CLR.B   1
03EB4:  MOV     #30,W4
03EB6:  CP.B    W4L,W0L
03EB8:  BRA     GT,3EF2
03EBA:  MOV     3948,W0
03EBC:  CLR.B   1
03EBE:  MOV     #39,W4
03EC0:  CP.B    W4L,W0L
03EC2:  BRA     LT,3EF2
....................          { 
....................             result = 10*result + (c - '0'); 
03EC4:  MOV     3940,W0
03EC6:  MOV     W0,W4
03EC8:  MUL.UU  W4,#A,W0
03ECA:  MOV     W0,W5
03ECC:  MOV     3948,W0
03ECE:  CLR.B   1
03ED0:  SUB.B   #30,W0L
03ED2:  SE      W0,W0
03ED4:  ADD     W0,W5,W0
03ED6:  MOV     W0,3940
....................             c = s[index++]; 
03ED8:  MOV     3946,W0
03EDA:  MOV     W0,[W15++]
03EDC:  INC     W0,W0
03EDE:  MOV     W0,3946
03EE0:  MOV     [--W15],W0
03EE2:  MOV     W0,W5
03EE4:  MOV     393E,W0
03EE6:  ADD     W5,W0,W0
03EE8:  MOV     3948,W4
03EEA:  MOV.B   [W0+#0],W4L
03EEC:  MOV     W4,3948
03EEE:  GOTO    3EB0
....................          } 
....................       } 
03EF2:  GOTO    3FC4
....................       else if (base == 16)    // The number is a hexa number 
03EF6:  MOV     3944,W0
03EF8:  CP      W0,#10
03EFA:  BRA     NZ,3FC4
....................       { 
....................          c = toupper(c); 
03EFC:  MOV     3948,W0
03EFE:  CLR.B   1
03F00:  MOV     #61,W4
03F02:  CP.B    W4L,W0L
03F04:  BRA     GTU,3F18
03F06:  MOV     3948,W0
03F08:  CLR.B   1
03F0A:  MOV     #7A,W4
03F0C:  CP.B    W4L,W0L
03F0E:  BRA     NC,3F18
03F10:  MOV     3948,W0
03F12:  CLR.B   1
03F14:  BCLR    W0.5
03F16:  BRA     3F1A
03F18:  MOV     3948,W0
03F1A:  PUSH    3948
03F1C:  MOV.B   W0L,[W15-#2]
03F1E:  POP     3948
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
03F20:  MOV     3948,W0
03F22:  CLR.B   1
03F24:  MOV     #30,W4
03F26:  CP.B    W4L,W0L
03F28:  BRA     GT,3F36
03F2A:  MOV     3948,W0
03F2C:  CLR.B   1
03F2E:  MOV     #39,W4
03F30:  CP.B    W4L,W0L
03F32:  BRA     LT,3F36
03F34:  BRA     3F4A
03F36:  MOV     3948,W0
03F38:  CLR.B   1
03F3A:  MOV     #41,W4
03F3C:  CP.B    W4L,W0L
03F3E:  BRA     GT,3FC4
03F40:  MOV     3948,W0
03F42:  CLR.B   1
03F44:  MOV     #46,W4
03F46:  CP.B    W4L,W0L
03F48:  BRA     LT,3FC4
....................          { 
....................             if (c >= '0' && c <= '9') 
03F4A:  MOV     3948,W0
03F4C:  CLR.B   1
03F4E:  MOV     #30,W4
03F50:  CP.B    W4L,W0L
03F52:  BRA     GT,3F72
03F54:  MOV     3948,W0
03F56:  CLR.B   1
03F58:  MOV     #39,W4
03F5A:  CP.B    W4L,W0L
03F5C:  BRA     LT,3F72
....................                result = (result << 4) + (c - '0'); 
03F5E:  MOV     3940,W5
03F60:  SL      W5,#4,W5
03F62:  MOV     3948,W0
03F64:  CLR.B   1
03F66:  SUB.B   #30,W0L
03F68:  SE      W0,W0
03F6A:  ADD     W0,W5,W0
03F6C:  MOV     W0,3940
03F6E:  GOTO    3F86
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
03F72:  MOV     3940,W5
03F74:  SL      W5,#4,W5
03F76:  MOV     3948,W0
03F78:  CLR.B   1
03F7A:  SUB.B   #41,W0L
03F7C:  ZE      W0,W0
03F7E:  CLR.B   1
03F80:  ADD     W0,#A,W0
03F82:  ADD     W0,W5,W0
03F84:  MOV     W0,3940
....................  
....................             c = s[index++]; 
03F86:  MOV     3946,W0
03F88:  MOV     W0,[W15++]
03F8A:  INC     W0,W0
03F8C:  MOV     W0,3946
03F8E:  MOV     [--W15],W0
03F90:  MOV     W0,W5
03F92:  MOV     393E,W0
03F94:  ADD     W5,W0,W0
03F96:  MOV     3948,W4
03F98:  MOV.B   [W0+#0],W4L
03F9A:  MOV     W4,3948
....................             c = toupper(c); 
03F9C:  MOV     3948,W0
03F9E:  CLR.B   1
03FA0:  MOV     #61,W4
03FA2:  CP.B    W4L,W0L
03FA4:  BRA     GTU,3FB8
03FA6:  MOV     3948,W0
03FA8:  CLR.B   1
03FAA:  MOV     #7A,W4
03FAC:  CP.B    W4L,W0L
03FAE:  BRA     NC,3FB8
03FB0:  MOV     3948,W0
03FB2:  CLR.B   1
03FB4:  BCLR    W0.5
03FB6:  BRA     3FBA
03FB8:  MOV     3948,W0
03FBA:  PUSH    3948
03FBC:  MOV.B   W0L,[W15-#2]
03FBE:  POP     3948
03FC0:  GOTO    3F20
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
03FC4:  MOV     3942,W0
03FC6:  CP      W0,#1
03FC8:  BRA     NZ,3FD8
03FCA:  MOV     3944,W0
03FCC:  CP      W0,#A
03FCE:  BRA     NZ,3FD8
....................        result = -result; 
03FD0:  MOV     3940,W0
03FD2:  MOV     #0,W4
03FD4:  SUB     W4,W0,W0
03FD6:  MOV     W0,3940
....................  
....................    return(result); 
03FD8:  PUSH    3940
03FDA:  POP     0
03FDC:  MOV     [--W15],W6
03FDE:  MOV     [--W15],W5
03FE0:  RETURN  
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
*
0297A:  MOV     W5,[W15++]
0297C:  MOV     W6,[W15++]
0297E:  MOV     #0,W4
02980:  MOV     W4,394E
02982:  MOV     #0,W4
02984:  MOV     W4,3950
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
02986:  MOV     #3130,W4
02988:  MOV     W4,3954
0298A:  MOV     #3332,W4
0298C:  MOV     W4,3956
0298E:  MOV     #3534,W4
02990:  MOV     W4,3958
02992:  MOV     #3736,W4
02994:  MOV     W4,395A
02996:  MOV     #3938,W4
02998:  MOV     W4,395C
0299A:  MOV     #6261,W4
0299C:  MOV     W4,395E
0299E:  MOV     #6463,W4
029A0:  MOV     W4,3960
029A2:  MOV     #6665,W4
029A4:  MOV     W4,3962
029A6:  MOV     #6867,W4
029A8:  MOV     W4,3964
029AA:  MOV     #6A69,W4
029AC:  MOV     W4,3966
029AE:  MOV     #6C6B,W4
029B0:  MOV     W4,3968
029B2:  MOV     #6E6D,W4
029B4:  MOV     W4,396A
029B6:  MOV     #706F,W4
029B8:  MOV     W4,396C
029BA:  MOV     #7371,W4
029BC:  MOV     W4,396E
029BE:  MOV     #7574,W4
029C0:  MOV     W4,3970
029C2:  MOV     #7776,W4
029C4:  MOV     W4,3972
029C6:  MOV     #7978,W4
029C8:  MOV     W4,3974
029CA:  MOV     #7A,W4
029CC:  MOV     W4,3976
....................    for(sc=s;isspace(*sc);++sc); 
029CE:  PUSH    3942
029D0:  POP     3948
029D2:  MOV     3948,W0
029D4:  MOV.B   [W0],W4L
029D6:  XOR.B   #20,W4L
029D8:  BRA     NZ,29E4
029DA:  MOV     3948,W0
029DC:  INC     W0,W0
029DE:  MOV     W0,3948
029E0:  GOTO    29D2
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
029E4:  MOV     3948,W0
029E6:  MOV.B   [W0],W4L
029E8:  XOR.B   #2D,W4L
029EA:  BRA     Z,29F4
029EC:  MOV     3948,W0
029EE:  MOV.B   [W0],W4L
029F0:  XOR.B   #2B,W4L
029F2:  BRA     NZ,2A06
029F4:  MOV     3948,W0
029F6:  MOV     W0,[W15++]
029F8:  INC     W0,W0
029FA:  MOV     W0,3948
029FC:  MOV     [--W15],W0
029FE:  MOV     W0,W4
02A00:  MOV.B   [W4],W0L
02A02:  GOTO    2A08
02A06:  MOV.B   #2B,W0L
02A08:  PUSH    3952
02A0A:  MOV.B   W0L,[W15-#2]
02A0C:  POP     3952
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
02A0E:  MOV     3952,W0
02A10:  CLR.B   1
02A12:  MOV     #2D,W4
02A14:  CP.B    W4L,W0L
02A16:  BRA     Z,2A2C
02A18:  MOV     3946,W0
02A1A:  CP      W0,#0
02A1C:  BRA     LT,2A2C
02A1E:  MOV     3946,W0
02A20:  CP      W0,#1
02A22:  BRA     Z,2A2C
02A24:  MOV     3946,W0
02A26:  MOV     #24,W4
02A28:  CP      W4,W0
02A2A:  BRA     GE,2A34
....................    goto StrtoulGO; 
02A2C:  GOTO    2BA8
02A30:  GOTO    2AF2
....................  
....................    else if (base) 
02A34:  MOV     3946,W0
02A36:  CP0     W0
02A38:  BRA     Z,2A9E
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
02A3A:  MOV     3946,W0
02A3C:  CP      W0,#10
02A3E:  BRA     NZ,2A66
02A40:  MOV     3948,W0
02A42:  MOV.B   [W0],W4L
02A44:  XOR.B   #30,W4L
02A46:  BRA     NZ,2A66
02A48:  MOV     3948,W0
02A4A:  MOV     #1,W4
02A4C:  ADD     W4,W0,W0
02A4E:  MOV.B   [W0],W4L
02A50:  XOR.B   #78,W4L
02A52:  BRA     Z,2A60
02A54:  MOV     3948,W0
02A56:  MOV     #1,W4
02A58:  ADD     W4,W0,W0
02A5A:  MOV.B   [W0],W4L
02A5C:  XOR.B   #58,W4L
02A5E:  BRA     NZ,2A66
....................          sc+=2; 
02A60:  MOV     3948,W0
02A62:  ADD     W0,#2,W0
02A64:  MOV     W0,3948
....................       if(base==8 && *sc =='0') 
02A66:  MOV     3946,W0
02A68:  CP      W0,#8
02A6A:  BRA     NZ,2A7A
02A6C:  MOV     3948,W0
02A6E:  MOV.B   [W0],W4L
02A70:  XOR.B   #30,W4L
02A72:  BRA     NZ,2A7A
....................          sc+=1; 
02A74:  MOV     3948,W0
02A76:  ADD     W0,#1,W0
02A78:  MOV     W0,3948
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
02A7A:  MOV     3946,W0
02A7C:  CP      W0,#2
02A7E:  BRA     NZ,2A9A
02A80:  MOV     3948,W0
02A82:  MOV.B   [W0],W4L
02A84:  XOR.B   #30,W4L
02A86:  BRA     NZ,2A9A
02A88:  MOV     3948,W0
02A8A:  MOV     #1,W4
02A8C:  ADD     W4,W0,W0
02A8E:  MOV.B   [W0],W4L
02A90:  XOR.B   #62,W4L
02A92:  BRA     NZ,2A9A
....................          sc+=2; 
02A94:  MOV     3948,W0
02A96:  ADD     W0,#2,W0
02A98:  MOV     W0,3948
....................  
....................    } 
02A9A:  GOTO    2AF2
....................    else if(*sc!='0') // base is 0, find base 
02A9E:  MOV     3948,W0
02AA0:  MOV.B   [W0],W4L
02AA2:  XOR.B   #30,W4L
02AA4:  BRA     Z,2AAE
....................       base=10; 
02AA6:  MOV     #A,W4
02AA8:  MOV     W4,3946
02AAA:  GOTO    2AF2
....................    else if (sc[1]=='x' || sc[1]=='X') 
02AAE:  MOV     3948,W0
02AB0:  MOV     #1,W4
02AB2:  ADD     W4,W0,W0
02AB4:  MOV.B   [W0],W4L
02AB6:  XOR.B   #78,W4L
02AB8:  BRA     Z,2AC6
02ABA:  MOV     3948,W0
02ABC:  MOV     #1,W4
02ABE:  ADD     W4,W0,W0
02AC0:  MOV.B   [W0],W4L
02AC2:  XOR.B   #58,W4L
02AC4:  BRA     NZ,2AD4
....................       base =16,sc+=2; 
02AC6:  MOV     #10,W4
02AC8:  MOV     W4,3946
02ACA:  MOV     3948,W0
02ACC:  ADD     W0,#2,W0
02ACE:  MOV     W0,3948
02AD0:  GOTO    2AF2
....................    else if(sc[1]=='b') 
02AD4:  MOV     3948,W0
02AD6:  MOV     #1,W4
02AD8:  ADD     W4,W0,W0
02ADA:  MOV.B   [W0],W4L
02ADC:  XOR.B   #62,W4L
02ADE:  BRA     NZ,2AEE
....................       base=2,sc+=2; 
02AE0:  MOV     #2,W4
02AE2:  MOV     W4,3946
02AE4:  MOV     3948,W0
02AE6:  ADD     W0,#2,W0
02AE8:  MOV     W0,3948
02AEA:  GOTO    2AF2
....................    else 
....................       base=8; 
02AEE:  MOV     #8,W4
02AF0:  MOV     W4,3946
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
02AF2:  PUSH    3948
02AF4:  POP     394A
02AF6:  MOV     3948,W0
02AF8:  MOV.B   [W0],W4L
02AFA:  XOR.B   #30,W4L
02AFC:  BRA     NZ,2B08
02AFE:  MOV     3948,W0
02B00:  INC     W0,W0
02B02:  MOV     W0,3948
02B04:  GOTO    2AF6
....................    sd=memchr(digits,tolower(*sc),base); 
02B08:  MOV     3948,W0
02B0A:  MOV.B   [W0],W5L
02B0C:  MOV     #41,W4
02B0E:  CP.B    W4L,W5L
02B10:  BRA     GTU,2B1E
02B12:  MOV     #5A,W4
02B14:  CP.B    W4L,W5L
02B16:  BRA     NC,2B1E
02B18:  MOV.B   W5L,W0L
02B1A:  IOR.B   #20,W0L
02B1C:  BRA     2B20
02B1E:  MOV.B   W5L,W0L
02B20:  MOV.B   W0L,W5L
02B22:  PUSH    3982
02B24:  MOV.B   W5L,[W15-#2]
02B26:  POP     3982
02B28:  MOV     #3954,W4
02B2A:  MOV     W4,3980
02B2C:  PUSH    3946
02B2E:  POP     3984
02B30:  CALL    28FC
02B34:  MOV     W0,394C
....................    for(; sd!=0; ) 
02B36:  MOV     394C,W0
02B38:  CP0     W0
02B3A:  BRA     Z,2BA0
....................    { 
....................       x=x*base+(int16)(sd-digits); 
02B3C:  MOV     3946,W0
02B3E:  CLR     W1
02B40:  BTSC    W0.F
02B42:  SETM    W1
02B44:  MOV     W0,W2
02B46:  MOV     W1,W3
02B48:  MOV     394E,W0
02B4A:  MOV     3950,W1
02B4C:  CALL    2938
02B50:  MOV     W0,W5
02B52:  MOV     W1,W6
02B54:  MOV     394C,W0
02B56:  MOV     #3954,W4
02B58:  SUB     W0,W4,W0
02B5A:  CLR     W1
02B5C:  BTSC    W0.F
02B5E:  SETM    W1
02B60:  ADD     W0,W5,W0
02B62:  MOV     W0,394E
02B64:  ADDC    W1,W6,W0
02B66:  MOV     W0,3950
....................       ++sc; 
02B68:  MOV     3948,W0
02B6A:  INC     W0,W0
02B6C:  MOV     W0,3948
....................       sd=memchr(digits,tolower(*sc),base); 
02B6E:  MOV     3948,W0
02B70:  MOV.B   [W0],W5L
02B72:  MOV     #41,W4
02B74:  CP.B    W4L,W5L
02B76:  BRA     GTU,2B84
02B78:  MOV     #5A,W4
02B7A:  CP.B    W4L,W5L
02B7C:  BRA     NC,2B84
02B7E:  MOV.B   W5L,W0L
02B80:  IOR.B   #20,W0L
02B82:  BRA     2B86
02B84:  MOV.B   W5L,W0L
02B86:  MOV.B   W0L,W5L
02B88:  PUSH    3982
02B8A:  MOV.B   W5L,[W15-#2]
02B8C:  POP     3982
02B8E:  MOV     #3954,W4
02B90:  MOV     W4,3980
02B92:  PUSH    3946
02B94:  POP     3984
02B96:  CALL    28FC
02B9A:  MOV     W0,394C
02B9C:  GOTO    2B36
....................    } 
....................    if(s1==sc) 
02BA0:  MOV     394A,W0
02BA2:  MOV     3948,W4
02BA4:  CP      W4,W0
02BA6:  BRA     NZ,2BBA
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
02BA8:  MOV     3944,W0
02BAA:  CP0     W0
02BAC:  BRA     Z,2BB4
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
02BAE:  MOV     3944,W5
02BB0:  MOV     3942,W4
02BB2:  MOV     W4,[W5+#0]
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
02BB4:  MOV     #0,W0
02BB6:  MOV     #0,W1
02BB8:  BRA     2BCA
....................    } 
....................    if (endptr) 
02BBA:  MOV     3944,W0
02BBC:  CP0     W0
02BBE:  BRA     Z,2BC6
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
02BC0:  MOV     3944,W5
02BC2:  MOV     3948,W4
02BC4:  MOV     W4,[W5+#0]
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
02BC6:  MOV     394E,W0
02BC8:  MOV     3950,W1
02BCA:  MOV     [--W15],W6
02BCC:  MOV     [--W15],W5
02BCE:  RETURN  
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "string.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "stdio.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = beg; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include "C:\Aquarium Software\OSMOBOT_PROTOTYPES\MCU_WEB_SERVER\VacDisplayRoutines.c" 
....................  
....................  
....................  
.................... #define RS PIN_E0 
.................... #define E PIN_E1 
....................  
.................... #define LCD_DB7 PIN_E5 
.................... #define LCD_DB6 PIN_E4 
.................... #define LCD_DB5 PIN_E3 
.................... #define LCD_DB4 PIN_E2 
....................  
....................  
....................  
.................... //Create an override condition to replace lcd function calls with blank macros 
.................... #define LCD_EN 1 
....................  
.................... #if LCD_EN 
....................  
.................... //******************************************************************************** 
.................... // Created Sept 30, 2014 
.................... // This routine sends the whole byte into two nibbles to the upper nibble of the display 
.................... //******************************************************************************** 
....................  
.................... void SendByteToVFDNibble(byte data) 
.................... { 
.................... byte temp; 
.................... 	output_high(E); // Pin 11 E/(~RD) 
*
02202:  BCLR.B  2E0.1
02204:  BSET.B  2E4.1
.................... //	delay_us(25); 
.................... //Setup the bottom nibble on the inputs. 
....................  
.................... //Setup the top nibble on the inputs. 
.................... 	temp=data&0x80; 
02206:  MOV     39D2,W0
02208:  CLR.B   1
0220A:  AND.B   #80,W0L
0220C:  PUSH    39D2
0220E:  MOV.B   W0L,[W15-#1]
02210:  POP     39D2
.................... 	if (temp) 
02212:  MOV     39D2,W0
02214:  LSR     W0,#8,W0
02216:  CP0.B   W0L
02218:  BRA     Z,2222
.................... 		{ 
.................... 		output_high(PIN_E5);		 
0221A:  BCLR.B  2E0.5
0221C:  BSET.B  2E4.5
.................... 		}	 
0221E:  GOTO    2226
.................... 		else 
.................... 		{ 
.................... 		output_low(PIN_E5); 
02222:  BCLR.B  2E0.5
02224:  BCLR.B  2E4.5
.................... 		} 
.................... 	temp=data&0x40; 
02226:  MOV     39D2,W0
02228:  CLR.B   1
0222A:  AND.B   #40,W0L
0222C:  PUSH    39D2
0222E:  MOV.B   W0L,[W15-#1]
02230:  POP     39D2
.................... 	if (temp) 
02232:  MOV     39D2,W0
02234:  LSR     W0,#8,W0
02236:  CP0.B   W0L
02238:  BRA     Z,2242
.................... 		{ 
.................... 		output_high(PIN_E4);		 
0223A:  BCLR.B  2E0.4
0223C:  BSET.B  2E4.4
.................... 		}	 
0223E:  GOTO    2246
.................... 		else 
.................... 		{ 
.................... 		output_low(PIN_E4); 
02242:  BCLR.B  2E0.4
02244:  BCLR.B  2E4.4
.................... 		} 
.................... 	temp=data&0x20; 
02246:  MOV     39D2,W0
02248:  CLR.B   1
0224A:  AND.B   #20,W0L
0224C:  PUSH    39D2
0224E:  MOV.B   W0L,[W15-#1]
02250:  POP     39D2
.................... 	if (temp) 
02252:  MOV     39D2,W0
02254:  LSR     W0,#8,W0
02256:  CP0.B   W0L
02258:  BRA     Z,2262
.................... 		{ 
.................... 		output_high(PIN_E3);		 
0225A:  BCLR.B  2E0.3
0225C:  BSET.B  2E4.3
.................... 		}	 
0225E:  GOTO    2266
.................... 		else 
.................... 		{ 
.................... 		output_low(PIN_E3); 
02262:  BCLR.B  2E0.3
02264:  BCLR.B  2E4.3
.................... 		} 
.................... 	temp=data&0x10; 
02266:  MOV     39D2,W0
02268:  CLR.B   1
0226A:  AND.B   W0L,#10,W0L
0226C:  PUSH    39D2
0226E:  MOV.B   W0L,[W15-#1]
02270:  POP     39D2
.................... 	if (temp) 
02272:  MOV     39D2,W0
02274:  LSR     W0,#8,W0
02276:  CP0.B   W0L
02278:  BRA     Z,2282
.................... 		{ 
.................... 		output_high(PIN_E2);		 
0227A:  BCLR.B  2E0.2
0227C:  BSET.B  2E4.2
.................... 		}	 
0227E:  GOTO    2286
.................... 		else 
.................... 		{ 
.................... 		output_low(PIN_E2); 
02282:  BCLR.B  2E0.2
02284:  BCLR.B  2E4.2
.................... 		} 
....................  
....................  
.................... 	delay_us(10); 
02286:  REPEAT  #9E
02288:  NOP     
.................... 	output_low(E); // Pin 11 E/(~RD) 
0228A:  BCLR.B  2E0.1
0228C:  BCLR.B  2E4.1
.................... 	delay_us(10); 
0228E:  REPEAT  #9E
02290:  NOP     
.................... 	output_high(E); // Pin 11 E/(~RD) 
02292:  BCLR.B  2E0.1
02294:  BSET.B  2E4.1
.................... //delay_us(25); 
....................  
....................  
....................  
.................... 	temp=data&0x08; 
02296:  MOV     39D2,W0
02298:  CLR.B   1
0229A:  AND.B   W0L,#8,W0L
0229C:  PUSH    39D2
0229E:  MOV.B   W0L,[W15-#1]
022A0:  POP     39D2
.................... 	if (temp) 
022A2:  MOV     39D2,W0
022A4:  LSR     W0,#8,W0
022A6:  CP0.B   W0L
022A8:  BRA     Z,22B2
.................... 		{ 
.................... 		output_high(PIN_E5);		 
022AA:  BCLR.B  2E0.5
022AC:  BSET.B  2E4.5
.................... 		}	 
022AE:  GOTO    22B6
.................... 		else 
.................... 		{ 
.................... 		output_low(PIN_E5); 
022B2:  BCLR.B  2E0.5
022B4:  BCLR.B  2E4.5
.................... 		} 
.................... 	temp=data&0x04; 
022B6:  MOV     39D2,W0
022B8:  CLR.B   1
022BA:  AND.B   W0L,#4,W0L
022BC:  PUSH    39D2
022BE:  MOV.B   W0L,[W15-#1]
022C0:  POP     39D2
.................... 	if (temp) 
022C2:  MOV     39D2,W0
022C4:  LSR     W0,#8,W0
022C6:  CP0.B   W0L
022C8:  BRA     Z,22D2
.................... 		{ 
.................... 		output_high(PIN_E4);		 
022CA:  BCLR.B  2E0.4
022CC:  BSET.B  2E4.4
.................... 		}	 
022CE:  GOTO    22D6
.................... 		else 
.................... 		{ 
.................... 		output_low(PIN_E4); 
022D2:  BCLR.B  2E0.4
022D4:  BCLR.B  2E4.4
.................... 		} 
.................... 	temp=data&0x02; 
022D6:  MOV     39D2,W0
022D8:  CLR.B   1
022DA:  AND.B   W0L,#2,W0L
022DC:  PUSH    39D2
022DE:  MOV.B   W0L,[W15-#1]
022E0:  POP     39D2
.................... 	if (temp) 
022E2:  MOV     39D2,W0
022E4:  LSR     W0,#8,W0
022E6:  CP0.B   W0L
022E8:  BRA     Z,22F2
.................... 		{ 
.................... 		output_high(PIN_E3);		 
022EA:  BCLR.B  2E0.3
022EC:  BSET.B  2E4.3
.................... 		}	 
022EE:  GOTO    22F6
.................... 		else 
.................... 		{ 
.................... 		output_low(PIN_E3); 
022F2:  BCLR.B  2E0.3
022F4:  BCLR.B  2E4.3
.................... 		} 
.................... 	temp=data&0x01; 
022F6:  MOV     39D2,W0
022F8:  CLR.B   1
022FA:  AND.B   W0L,#1,W0L
022FC:  PUSH    39D2
022FE:  MOV.B   W0L,[W15-#1]
02300:  POP     39D2
.................... 	if (temp) 
02302:  MOV     39D2,W0
02304:  LSR     W0,#8,W0
02306:  CP0.B   W0L
02308:  BRA     Z,2312
.................... 		{ 
.................... 		output_high(PIN_E2);		 
0230A:  BCLR.B  2E0.2
0230C:  BSET.B  2E4.2
.................... 		}	 
0230E:  GOTO    2316
.................... 		else 
.................... 		{ 
.................... 		output_low(PIN_E2); 
02312:  BCLR.B  2E0.2
02314:  BCLR.B  2E4.2
.................... 		} 
....................  
.................... 	delay_us(10); 
02316:  REPEAT  #9E
02318:  NOP     
.................... 	output_low(E); // Pin 11 E/(~RD)  return to the init state 
0231A:  BCLR.B  2E0.1
0231C:  BCLR.B  2E4.1
.................... 	delay_us(10); 
0231E:  REPEAT  #9E
02320:  NOP     
02322:  RETURN  
.................... } 
....................  
....................  
....................  
.................... void VacDisplayinit(void) 
.................... { 
.................... 	output_low(RS); // Pin 9 RS This means it's a command.  A 1 means it's data 
02324:  BCLR.B  2E0.0
02326:  BCLR.B  2E4.0
.................... 	output_low(E); // Pin 11 E/(~RD) 
02328:  BCLR.B  2E0.1
0232A:  BCLR.B  2E4.1
....................  
.................... 	delay_ms(1000); 
0232C:  MOV     #3E8,W0
0232E:  CALL    21F2
.................... 	output_low(RS); // Pin 9 RS This means it's a command.  A 1 means it's data 
02332:  BCLR.B  2E0.0
02334:  BCLR.B  2E4.0
.................... 	output_high(E); // Pin 11 E/(~RD) 
02336:  BCLR.B  2E0.1
02338:  BSET.B  2E4.1
.................... 	delay_us(25); 
0233A:  REPEAT  #18E
0233C:  NOP     
.................... //  First set up the command where we are only using 4 bits in M68 mode, not Intel86 mode. 
.................... 	output_low(PIN_E5);   //This sends byte 0x2X  to the upper part of the nibble. 
0233E:  BCLR.B  2E0.5
02340:  BCLR.B  2E4.5
.................... 	output_low(PIN_E4);   //This command sets the display to take nibbles, not bytes. 
02342:  BCLR.B  2E0.4
02344:  BCLR.B  2E4.4
.................... 	output_high(PIN_E3); 
02346:  BCLR.B  2E0.3
02348:  BSET.B  2E4.3
.................... 	output_low(PIN_E2); 
0234A:  BCLR.B  2E0.2
0234C:  BCLR.B  2E4.2
....................  
....................  
.................... 	delay_us(100); 
0234E:  REPEAT  #63E
02350:  NOP     
.................... 	output_low(E); // Pin 11 E/(~RD) 
02352:  BCLR.B  2E0.1
02354:  BCLR.B  2E4.1
.................... 	delay_us(100); 
02356:  REPEAT  #63E
02358:  NOP     
.................... /*	output_high(E); // Pin 11 E/(~RD) 
.................... 	delay_us(25); 
.................... //  First set up the command where we are only using 4 bits in M68 mode, not Intel86 mode. 
.................... 	output_low(PIN_E5);   //This sends byte 0x2X  to the upper part of the nibble. 
.................... 	output_low(PIN_E4);   //This command sets the display to take nibbles, not bytes. 
.................... 	output_high(PIN_E3); 
.................... 	output_low(PIN_E2); 
....................  
....................  
.................... 	delay_us(100); 
.................... 	output_low(E); // Pin 11 E/(~RD) 
.................... 	delay_us(100); 
.................... 	output_high(E); // Pin 11 E/(~RD)   
.................... 	delay_us(25); 
....................  
.................... //  First set up the command where we are only using 4 bits in M68 mode, not Intel86 mode. 
.................... 	output_low(PIN_E5);   //This sends byte 0x2X  to the upper part of the nibble. 
.................... 	output_low(PIN_E4);   //This command sets the display to take nibbles, not bytes. 
.................... 	output_high(PIN_E3); 
.................... 	output_low(PIN_E2); 
....................  
....................  
.................... 	delay_us(100); 
.................... 	output_low(E); // Pin 11 E/(~RD) 
.................... 	delay_us(100); 
.................... 	output_low(RS); // Pin 9 RS  
.................... 	output_high(E); // Pin 11 E/(~RD) 
.................... 	delay_us(25); 
.................... */ 
....................     SendByteToVFDNibble(0x0E); 
0235A:  MOV     39D2,W0
0235C:  MOV.B   #E,W0L
0235E:  MOV     W0,39D2
02360:  CALL    2202
.................... //	output_d(0x0F);	//  Dispaly Turns ON, Blink Off. 
.................... 	output_low(RS); // Pin 9 RS  
02364:  BCLR.B  2E0.0
02366:  BCLR.B  2E4.0
.................... 	delay_us(100); 
02368:  REPEAT  #63E
0236A:  NOP     
0236C:  RETURN  
.................... //	output_low(E); // Pin 11 E/(~RD) 
....................  
.................... } 
....................  
.................... void VacWriteChar(char letter) 
.................... { 
.................... 	//wait(10); 
....................  
.................... 	output_high(RS);  //RS  set to data mode 
*
02766:  BCLR.B  2E0.0
02768:  BSET.B  2E4.0
....................  
....................     SendByteToVFDNibble(letter);	 
0276A:  MOV     39D0,W0
0276C:  PUSH    39D2
0276E:  MOV.B   W0L,[W15-#2]
02770:  POP     39D2
02772:  CALL    2202
02776:  RETURN  
....................  
....................  
....................  
.................... 	} 
....................  
.................... void VacDisplayClear(void) 
.................... { 
....................  
.................... 	delay_ms(500); 
*
0236E:  MOV     #1F4,W0
02370:  CALL    21F2
.................... 	output_low(RS);  //RS 
02374:  BCLR.B  2E0.0
02376:  BCLR.B  2E4.0
....................     SendByteToVFDNibble(0x01); 
02378:  MOV     39D2,W0
0237A:  MOV.B   #1,W0L
0237C:  MOV     W0,39D2
0237E:  CALL    2202
.................... //	output_d(0x01);	 
.................... 	output_high(RS);  //RS 
02382:  BCLR.B  2E0.0
02384:  BSET.B  2E4.0
02386:  RETURN  
.................... } 
....................  
.................... void VacSetXY(int X, int Y) 
.................... { 
.................... 	output_low(RS); 
*
026E4:  BCLR.B  2E0.0
026E6:  BCLR.B  2E4.0
....................    SendByteToVFDNibble(0x06); 
026E8:  MOV     39D2,W0
026EA:  MOV.B   #6,W0L
026EC:  MOV     W0,39D2
026EE:  CALL    2202
.................... //	output_d(0x06); //  Address counter incremented, coursor shift en 
....................  
.................... 	int location=0; 
026F2:  MOV     #0,W4
026F4:  MOV     W4,39CA
.................... 	switch (Y) 
026F6:  MOV     39C8,W0
026F8:  XOR     #1,W0
026FA:  BRA     Z,270A
026FC:  XOR     #3,W0
026FE:  BRA     Z,2712
02700:  XOR     #1,W0
02702:  BRA     Z,271A
02704:  XOR     #7,W0
02706:  BRA     Z,2722
02708:  BRA     272A
.................... 	{ 
.................... 	case 1 : 
.................... 		location = 128; 
0270A:  MOV     #80,W4
0270C:  MOV     W4,39CA
.................... 		break;	 
0270E:  GOTO    272A
....................  
.................... 	case 2 : 
.................... 		location = 160; 
02712:  MOV     #A0,W4
02714:  MOV     W4,39CA
.................... 		break;	 
02716:  GOTO    272A
.................... 		 
.................... 	case 3 : 
.................... 		location = 192; 
0271A:  MOV     #C0,W4
0271C:  MOV     W4,39CA
.................... 		break;	 
0271E:  GOTO    272A
.................... 	 
.................... 	case 4 : 
.................... 		location = 224; 
02722:  MOV     #E0,W4
02724:  MOV     W4,39CA
.................... 		break;	 
02726:  GOTO    272A
.................... 	} 
.................... 	location = location + x; 
0272A:  MOV     39CA,W0
0272C:  MOV     39C6,W4
0272E:  ADD     W0,W4,W0
02730:  MOV     W0,39CA
.................... //	output_d(location); 
....................    SendByteToVFDNibble(location); 
02732:  MOV     39CA,W0
02734:  PUSH    39D2
02736:  MOV.B   W0L,[W15-#2]
02738:  POP     39D2
0273A:  CALL    2202
....................  
.................... 	delay_us(100); 
0273E:  REPEAT  #63E
02740:  NOP     
02742:  RETURN  
....................  
....................  
.................... } 
....................  
.................... void VacDisplayString(char* string) 
*
02778:  MOV     W5,[W15++]
0277A:  PUSH    39C6
0277C:  POP     39CE
0277E:  CALL    2744
02782:  MOV     W0,39CA
.................... { 
.................... 	 
.................... 	int i; 
.................... 	int len = strlen(string); 
.................... 	//for length of string, take i-th position and output 
.................... 	for (i = 0; i < len; i++) 
02784:  MOV     #0,W4
02786:  MOV     W4,39C8
02788:  MOV     39C8,W0
0278A:  MOV     39CA,W4
0278C:  CP      W4,W0
0278E:  BRA     LE,27AC
.................... 	{ 
.................... 		VacWriteChar(string[i]); 
02790:  MOV     39C8,W0
02792:  MOV     39C6,W4
02794:  ADD     W0,W4,W0
02796:  MOV.B   [W0],W5L
02798:  PUSH    39D0
0279A:  MOV.B   W5L,[W15-#2]
0279C:  POP     39D0
0279E:  CALL    2766
027A2:  MOV     39C8,W0
027A4:  INC     W0,W0
027A6:  MOV     W0,39C8
027A8:  GOTO    2788
.................... 		//sprintf 
.................... 	} 
027AC:  MOV     [--W15],W5
027AE:  RETURN  
....................  
.................... } 
.................... void Display_XYString(int x, int y, char* string) 
.................... { 
.................... 	VacSetXY(x,y); 
027B0:  PUSH    39BA
027B2:  POP     39C6
027B4:  PUSH    39BC
027B6:  POP     39C8
027B8:  CALL    26E4
.................... //	wait(50); 
.................... 	delay_ms(100); 
027BC:  MOV     #64,W0
027BE:  CALL    21F2
.................... 	VacDisplayString(string); 
027C2:  PUSH    39BE
027C4:  POP     39C6
027C6:  CALL    2778
027CA:  RETURN  
.................... } 
....................  
....................  
....................  
.................... #else //If you dont want to use the LCD display 
.................... #define SendByteToVFDNibble(d) 
.................... #define VacDisplayinit() 
.................... #define VacWriteChar(c) 
.................... #define VacDisplayClear() 
.................... #define VacDisplayString(s) 
.................... #define Display_XYString(x, y, s) 
.................... #endif 
....................  
.................... #include "USR-WIFI232-X.c" 
.................... //////////////////////////////////////////////////////////////// 
.................... //USR-WIFI232-X.c 
.................... // 
.................... //By: Erik Gokbora 
.................... // 
.................... //Associated functions to automate the setup and communication with the wifi module 
....................  
.................... //#define BAUDR 115200 
....................  
.................... #define I2CDEBUG 0 
.................... char STA_SSID[32]="NETGEAR31"; 
.................... char STA_PW[64]="royalumbrella053"; 
.................... //char STA_SSID[32]="NETGEAR31"; 
.................... //char STA_PW[64]="royalumbrella053"; 
.................... char STA_AUTH[8]="WPA2PSK"; 
.................... char STA_ENC[4]="AES"; 
.................... char ATBUFF[100]; 
....................  
....................  
....................  
....................  
....................  
.................... //int32 baudArray[20]={50,75,110,134,150,200,300,600,1200,2400,9600,19200,38400,57600,115200,230400,345600,460800}; 
....................  
....................  
.................... #ifdef PIC24 
.................... //#use delay(clock=8100000 ) 
.................... #define BAUDR 9600 
.................... #pin_select U3TX=PIN_B15  
.................... #pin_select U3RX=PIN_B14  
.................... //XMIT=PIN_B15, RCV=PIN_B14, 
.................... #use rs232(uart3, baud=57600, xmit=PIN_B15, rcv=PIN_B14, stream=WIFI) 
.................... //#use delay(clock=800000) 
.................... #else 
.................... /* 
.................... #define BAUDR 115200 
.................... #use rs232(uart1, baud=BAUDR, FLOW_CONTROL_MODE, stream=WIFI) 
.................... */ 
.................... #endif 
....................  
....................  
....................  
....................  
.................... ////////////////////////RS232 Interrupt////////////////////// 
.................... #ifndef WIFI_BUFF_SIZE  
.................... #define WIFI_BUFF_SIZE 800 
.................... #endif 
....................  
.................... //int8 buffer[255]; 
....................  
.................... int8 buffer[WIFI_BUFF_SIZE]; 
....................  
.................... //int8 next_in  = 0; 
.................... //int8 next_out = 0; 
....................  
.................... int16 next_in  = 0; 
.................... int16 next_out = 0; 
....................  
....................  
.................... #INT_RDA3 
.................... void RDA3_isr() 
*
016F0:  PUSH    42
016F2:  PUSH    36
016F4:  PUSH    32
016F6:  MOV     W0,[W15++]
016F8:  MOV     #2,W0
016FA:  REPEAT  #C
016FC:  MOV     [W0++],[W15++]
.................... { 
....................    int8 t; 
.................... output_High(PIN_D1); 
016FE:  BCLR.B  2D8.1
01700:  BSET.B  2DC.1
....................    buffer[next_in] = fgetc(WIFI); 
01702:  MOV     2146,W0
01704:  MOV     #1E26,W4
01706:  ADD     W0,W4,W5
01708:  BTSS.B  252.0
0170A:  BRA     1708
0170C:  MOV     256,W0
0170E:  MOV.B   W0L,[W5]
....................    t = next_in; 
01710:  MOV     2146,W0
01712:  PUSH    39CA
01714:  MOV.B   W0L,[W15-#2]
01716:  POP     39CA
....................    next_in = (next_in+1) % sizeof(buffer); 
01718:  MOV     2146,W0
0171A:  ADD     W0,#1,W0
0171C:  MOV     W0,W5
0171E:  MOV     W5,W4
01720:  MOV     #320,W3
01722:  REPEAT  #11
01724:  DIV.S   W4,W3
01726:  MOV     W1,2146
....................    if(next_in == next_out) 
01728:  MOV     2146,W0
0172A:  MOV     2148,W4
0172C:  CP      W4,W0
0172E:  BRA     NZ,1736
.................... 		{ 
....................       	next_in=t;        // Buffer full !! 
01730:  MOV     39CA,W0
01732:  SE      W0,W0
01734:  MOV     W0,2146
.................... 		} 
....................  
.................... 	//ADDED Crap 
.................... 	if(next_in==WIFI_BUFF_SIZE) 
01736:  MOV     2146,W0
01738:  MOV     #320,W4
0173A:  CP      W4,W0
0173C:  BRA     NZ,1742
.................... 	{ 
.................... 		next_in=0; 
0173E:  MOV     #0,W4
01740:  MOV     W4,2146
.................... 	}	 
.................... 	//ADDED Crap 
.................... 	if(next_out==WIFI_BUFF_SIZE) 
01742:  MOV     2148,W0
01744:  MOV     #320,W4
01746:  CP      W4,W0
01748:  BRA     NZ,174E
.................... 	{ 
.................... 		next_out=0; 
0174A:  MOV     #0,W4
0174C:  MOV     W4,2148
.................... 	} 
....................  
.................... } 
....................  
.................... //////////////////////////////////////////////////////////// 
....................  
0174E:  BCLR.B  8E.2
01750:  MOV     #1A,W0
01752:  REPEAT  #C
01754:  MOV     [--W15],[W0--]
01756:  MOV     [--W15],W0
01758:  POP     32
0175A:  POP     36
0175C:  POP     42
0175E:  RETFIE  
.................... #define bkbhit (next_in != next_out) 
.................... //#define bkbhitDebug (next_in != next_outDebug) 
....................  
.................... int8 bgetc() 
*
02850:  MOV     W5,[W15++]
.................... { 
....................    int8 c; 
....................  
....................    while(!bkbhit); 
02852:  MOV     2146,W0
02854:  MOV     2148,W4
02856:  CP      W4,W0
02858:  BRA     Z,2852
....................    c = buffer[next_out]; 
0285A:  MOV     2148,W0
0285C:  MOV     #1E26,W4
0285E:  ADD     W0,W4,W0
02860:  MOV     39BC,W4
02862:  MOV.B   [W0+#0],W4L
02864:  MOV     W4,39BC
....................    next_out = (next_out+1) % sizeof(buffer);  
02866:  MOV     2148,W0
02868:  ADD     W0,#1,W0
0286A:  MOV     W0,W5
0286C:  MOV     W5,W4
0286E:  MOV     #320,W3
02870:  REPEAT  #11
02872:  DIV.S   W4,W3
02874:  MOV     W1,2148
....................    return c; 
02876:  MOV     39BC,W0
02878:  MOV.B   W0L,0
0287A:  MOV     [--W15],W5
0287C:  RETURN  
.................... } 
....................  
....................  
.................... int8 bpeekc() 
.................... { 
....................    int8 c; 
....................  
....................    while(!bkbhit); 
....................    c = buffer[next_out]; 
....................    return c; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////// 
....................  
.................... 	#if I2CDEBUG 
....................  
.................... #USE I2C(MASTER,I2C1, sda=PIN_C4, scl=PIN_C3,FAST=10000,  NOINIT) 
....................  
.................... charI2CWrite(int8 c) 
.................... { 
.................... 		i2c_start(); 
.................... 		i2c_write(0xa0); 
.................... 		i2c_write(c); 
.................... 		i2c_stop();  
.................... } 
.................... 	#endif 
....................  
.................... ////////////////////////////////////////// 
....................  
.................... 	int8 getWIFIChar() 
.................... { 
.................... 	int8 c = bgetc(); 
....................  
.................... 		//Bake the I2C Debug right in 
.................... 		#if I2CDEBUG 
.................... 		i2c_start(); 
.................... 		i2c_write(0xa0); 
.................... 		i2c_write(c); 
.................... 		i2c_stop();  
.................... 		#endif 
....................  
....................  
.................... 	return c; 
.................... } 
....................  
....................  
....................  
.................... /////////////////////////// 
.................... /////////////////////////// 
.................... ///////WIFI NONSENSE/////// 
.................... /////////////////////////// 
.................... /////////////////////////// 
....................  
....................  
.................... void enableWIFIModule() 
.................... { 
....................  
....................    enable_interrupts(INT_RDA); 
....................    enable_interrupts(INT_RDA); 
....................    enable_interrupts(GLOBAL); 
.................... } 
....................  
.................... int8 WIFIBasicTest(){ 
.................... 	if(bkbhit){ 
.................... 	//if(kbhit()){ 
.................... 		//putc('!'); 
.................... 		//putc(getc()); 
.................... 		//char cvl= getc(); 
....................  
.................... 		//char cvl = bgetc(); 
.................... 		char cvl = bgetc(); //getWIFIChar(); 
.................... 		fputc(cvl,WIFI); 
.................... 		return cvl; 
.................... 	} 
.................... } 
....................  
....................  
.................... void WIFIBasicBroadcast(){ 
.................... 		if(bkbhit){ 
.................... 		fputc('T',WIFI); 
.................... 		fputc('e',WIFI); 
.................... 		fputc('s',WIFI); 
.................... 		fputc('t',WIFI); 
.................... 		fputc('\r',WIFI); 
.................... 		fputc('\n',WIFI); 
.................... 		delay_ms(500); 
.................... 		} 
.................... } 
....................  
....................  
....................  
.................... //************************************************************************* 
.................... // Created December 23, 2014 
.................... // This routine returns the nLink State of the WiFi 
.................... //************************************************************************* 
.................... int8 nLinkWiFi() 
.................... 	{ 
.................... 	int8 tempvalue; 
....................     //This returns a 1 when the WiFi Module is n link connected. 
.................... 	//get the current inputstate of the WiFi 
.................... 	tempvalue = input(PIN_B8); 
*
027FC:  BSET.B  2C9.0
027FE:  CLR     W4
02800:  BTSC.B  2CB.0
02802:  INC     W4,W4
02804:  PUSH    3802
02806:  MOV.B   W4L,[W15-#2]
02808:  POP     3802
.................... //	tempvalue=!tempvalue; 
.................... 	return(tempvalue); 
0280A:  MOV     3802,W0
0280C:  MOV.B   W0L,0
0280E:  RETURN  
.................... 	} 
....................  
....................  
....................  
....................  
....................  
.................... //************************************************************************* 
.................... // Created December 23, 2014 
.................... // This routine returns the Ready State of the WiFi 
.................... //************************************************************************* 
.................... int8 xReadyWiFi() 
.................... 	{ 
.................... 	int8 tempvalue; 
....................     //This returns a 1 when the WiFi Module is ready to recevie commands. 
.................... 	//get the current inputstate of the WiFi 
.................... 	tempvalue = input(PIN_B11); 
*
027E8:  BSET.B  2C9.3
027EA:  CLR     W4
027EC:  BTSC.B  2CB.3
027EE:  INC     W4,W4
027F0:  PUSH    39BA
027F2:  MOV.B   W4L,[W15-#2]
027F4:  POP     39BA
.................... //	tempvalue=!tempvalue; 
.................... 	return(tempvalue); 
027F6:  MOV     39BA,W0
027F8:  MOV.B   W0L,0
027FA:  RETURN  
.................... 	} 
....................  
.................... //************************************************************************* 
.................... // Created December 23, 2014 
.................... // This routine resets the  WiFi device 
.................... //************************************************************************* 
.................... void xRST() 
.................... 	{ 
.................... output_high(PIN_D5);   //reset.  needs to be at least 300 ms	 
*
027D8:  BCLR.B  2D8.5
027DA:  BSET.B  2DC.5
.................... delay_ms(600);    //Delay for 600 ms to make sure 
027DC:  MOV     #258,W0
027DE:  CALL    21F2
.................... output_low(PIN_D5); 
027E2:  BCLR.B  2D8.5
027E4:  BCLR.B  2DC.5
027E6:  RETURN  
.................... 	} 
....................  
.................... ////////////////////////////// 
.................... //MCU WIFI MODULE FACTORY RESET 
.................... ////////////////////////////// 
.................... void wifiRestore(){ 
.................... #ifdef PIC24 
.................... output_high(PIN_B10);   //reload 
.................... delay_ms(8000); 
.................... output_low(PIN_B10); 
....................  
.................... #endif 
.................... } 
....................  
....................  
....................  
....................  
.................... //////////////////////////////// 
.................... //WIFI SETUP 
.................... //////////////////////////////// 
.................... void wifiInit(){ 
.................... output_low(PIN_D5);   //reset modula 
*
02842:  BCLR.B  2D8.5
02844:  BCLR.B  2DC.5
.................... output_low(PIN_B10);  //WiFi Restore input signal - Active High 
02846:  BCLR.B  2C9.2
02848:  BCLR.B  2CD.2
.................... input(PIN_B11);   //This is the xReady signal 
0284A:  BSET.B  2C9.3
.................... input(PIN_B8);   //This is the nLink signal 
0284C:  BSET.B  2C9.0
0284E:  RETURN  
.................... } 
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //AT COMMANDS 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
....................  
....................  
....................  
.................... ///////////////////////// 
.................... //Enter AT Command Mode 
.................... ///////////////////////// 
.................... void WIFI_enter_setup(){ 
.................... fprintf(WIFI,"+++"); 
*
0287E:  BTSC.B  253.1
02880:  BRA     287E
02882:  MOV     #2B,W4
02884:  MOV     W4,254
02886:  BTSC.B  253.1
02888:  BRA     2886
0288A:  MOV     #2B,W4
0288C:  MOV     W4,254
0288E:  BTSC.B  253.1
02890:  BRA     288E
02892:  MOV     #2B,W4
02894:  MOV     W4,254
.................... //while(!bkbhit) 
.................... delay_ms(600); 
02896:  MOV     #258,W0
02898:  CALL    21F2
.................... fprintf(WIFI,"a"); 
0289C:  BTSC.B  253.1
0289E:  BRA     289C
028A0:  MOV     #61,W4
028A2:  MOV     W4,254
.................... delay_ms(600); 
028A4:  MOV     #258,W0
028A6:  CALL    21F2
.................... //fprintf(WIFI,"AT+E"); 
.................... //while(!bkbhit) 
.................... { 
....................  
.................... } 
028AA:  RETURN  
.................... } 
....................  
....................  
....................  
.................... ///////////////////////// 
.................... //Reset Module 
.................... ///////////////////////// 
.................... void WIFI_reset() 
.................... { 
.................... fprintf(WIFI,"AT+Z\r"); 
028AC:  MOV     #0,W1
028AE:  MOV     W1,W0
028B0:  CLR.B   1
028B2:  CALL    200
028B6:  INC     W1,W1
028B8:  BTSC.B  253.1
028BA:  BRA     28B8
028BC:  MOV     W0,254
028BE:  MOV     #4,W0
028C0:  CPSGT   W1,W0
028C2:  BRA     28AE
.................... //while(!bkbhit) 
.................... { 
....................  
.................... } 
.................... //delay_ms(500); 
.................... wifisetup=1; 
028C4:  BSET.B  85C.0
028C6:  RETURN  
.................... } 
....................  
....................  
.................... ///////////////////////// 
.................... //Query Ap's 
.................... ///////////////////////// 
.................... void WIFI_ap_scan(){ 
.................... fprintf(WIFI,"AT+WSCAN\r"); 
.................... //while(!bkbhit) 
.................... { 
....................  
.................... } 
.................... } 
....................  
....................  
.................... void WIFI_AT_Help() 
.................... { 
.................... fprintf(WIFI,"AT+H\r"); 
.................... } 
....................  
....................  
.................... void WIFI_APSTA(int1 enable) 
.................... { 
.................... if(enable) 
.................... { 
.................... sprintf(ATBUFF,"AT+FAPSTA=on\r"); 
.................... } 
.................... else 
.................... { 
.................... sprintf(ATBUFF,"AT+FAPSTA=off\r"); 
.................... } 
....................  
.................... fprintf(WIFI,ATBUFF); 
.................... } 
....................  
.................... void WIFI_STA_SSID() 
.................... { 
.................... fprintf(WIFI,"AT+WSSSID=%s\r",STA_SSID); 
*
03702:  MOV     #0,W1
03704:  MOV     W1,W0
03706:  CLR.B   1
03708:  CALL    22C
0370C:  INC     W1,W1
0370E:  BTSC.B  253.1
03710:  BRA     370E
03712:  MOV     W0,254
03714:  MOV     #9,W0
03716:  CPSGT   W1,W0
03718:  BRA     3704
0371A:  MOV     #1D56,W1
0371C:  CP0.B   [W1]
0371E:  BRA     Z,372E
03720:  BTSC.B  253.1
03722:  BRA     3720
03724:  MOV.B   [W1+#0],W0L
03726:  MOV.B   W0L,254
03728:  CLR.B   255
0372A:  INC     W1,W1
0372C:  BRA     371C
0372E:  BTSC.B  253.1
03730:  BRA     372E
03732:  MOV     #D,W4
03734:  MOV     W4,254
03736:  RETURN  
.................... } 
....................  
.................... void WIFI_STA_KEY() 
.................... { 
.................... fprintf(WIFI,"AT+WSKEY=%s,%s,%s\r",STA_AUTH,STA_ENC,STA_PW); 
03738:  MOV     #0,W1
0373A:  MOV     W1,W0
0373C:  CLR.B   1
0373E:  CALL    246
03742:  INC     W1,W1
03744:  BTSC.B  253.1
03746:  BRA     3744
03748:  MOV     W0,254
0374A:  MOV     #8,W0
0374C:  CPSGT   W1,W0
0374E:  BRA     373A
03750:  MOV     #1DB6,W1
03752:  CP0.B   [W1]
03754:  BRA     Z,3764
03756:  BTSC.B  253.1
03758:  BRA     3756
0375A:  MOV.B   [W1+#0],W0L
0375C:  MOV.B   W0L,254
0375E:  CLR.B   255
03760:  INC     W1,W1
03762:  BRA     3752
03764:  BTSC.B  253.1
03766:  BRA     3764
03768:  MOV     #2C,W4
0376A:  MOV     W4,254
0376C:  MOV     #1DBE,W1
0376E:  CP0.B   [W1]
03770:  BRA     Z,3780
03772:  BTSC.B  253.1
03774:  BRA     3772
03776:  MOV.B   [W1+#0],W0L
03778:  MOV.B   W0L,254
0377A:  CLR.B   255
0377C:  INC     W1,W1
0377E:  BRA     376E
03780:  BTSC.B  253.1
03782:  BRA     3780
03784:  MOV     #2C,W4
03786:  MOV     W4,254
03788:  MOV     #1D76,W1
0378A:  CP0.B   [W1]
0378C:  BRA     Z,379C
0378E:  BTSC.B  253.1
03790:  BRA     378E
03792:  MOV.B   [W1+#0],W0L
03794:  MOV.B   W0L,254
03796:  CLR.B   255
03798:  INC     W1,W1
0379A:  BRA     378A
0379C:  BTSC.B  253.1
0379E:  BRA     379C
037A0:  MOV     #D,W4
037A2:  MOV     W4,254
037A4:  RETURN  
.................... //fprintf(WIFI,ATBUFF); 
.................... } 
....................  
....................  
....................  
.................... void purgeBuff() 
.................... { 
.................... while(bkbhit) 
*
035D2:  MOV     2146,W0
035D4:  MOV     2148,W4
035D6:  CP      W4,W0
035D8:  BRA     Z,35E8
.................... 	{ 
.................... 	char c=bgetc(); 
035DA:  CALL    2850
035DE:  PUSH    39BA
035E0:  MOV.B   W0L,[W15-#2]
035E2:  POP     39BA
035E4:  GOTO    35D2
.................... 	} 
035E8:  RETURN  
....................  
.................... } 
....................  
....................  
....................  
.................... void readCharCFG() 
.................... { 
.................... delay_ms(100); 
.................... while(bkbhit) 
.................... 	{ 
.................... 	char c=bgetc(); 
.................... 	//VacWriteChar(c); 
.................... 	putc(c,BT); 
.................... 	} 
.................... delay_ms(200); 
.................... } 
....................  
....................  
.................... #define WFSETUPDEBUG 1 
.................... #define USETCPB 0 
....................  
.................... void WIFI_STA_CCONFIG(int1 resetConfig) 
*
037A6:  MOV     W5,[W15++]
037A8:  MOV     W6,[W15++]
.................... { 
.................... char cntrstr[4]; 
.................... static int8 WFSetupState=0; 
.................... static int1 WFHasWritten=0; 
.................... static int16 jankycntr=0; 
.................... USEAT=1; 
037AA:  BSET.B  85D.2
.................... 	if(resetConfig) 
037AC:  MOV     39B2,W0
037AE:  CLR.B   1
037B0:  CP0.B   W0L
037B2:  BRA     Z,37C0
.................... 	{ 
.................... 	purgeBuff(); 
037B4:  CALL    35D2
.................... 	WFSetupState=0; 
037B8:  CLR.B   95D
.................... 	WFHasWritten=0; 
037BA:  BCLR.B  85D.4
.................... 	jankycntr=0; 
037BC:  MOV     #0,W4
037BE:  MOV     W4,214C
.................... 	} 
....................  
.................... 	if(ATisOK==1) 
037C0:  BTSS.B  85D.0
037C2:  BRA     37D8
.................... 	{ 
.................... 	ATisOK=0; 
037C4:  BCLR.B  85D.0
.................... 	WFSetupState++; 
037C6:  INC.B   095D
.................... 	WFHasWritten=0; 
037C8:  BCLR.B  85D.4
.................... 	#if WFSETUPDEBUG 
.................... 	delay_ms(5000); 
037CA:  MOV     #1388,W0
037CC:  CALL    21F2
.................... 	VacDisplayClear(); 
037D0:  CALL    236E
.................... 	#endif 
.................... 	} 
037D4:  GOTO    37DE
.................... 	else 
.................... 	{ 
.................... 	jankycntr++; 
037D8:  MOV     214C,W0
037DA:  INC     W0,W0
037DC:  MOV     W0,214C
.................... 	} 
....................  
.................... 	if(jankycntr>=100) 
037DE:  MOV     214C,W0
037E0:  MOV     #64,W4
037E2:  CP      W4,W0
037E4:  BRA     GT,37EC
.................... 	{ 
.................... 	jankycntr=0; 
037E6:  MOV     #0,W4
037E8:  MOV     W4,214C
.................... 	WFHasWritten=0;	 
037EA:  BCLR.B  85D.4
.................... 	} 
....................  
.................... sprintf(cntrstr,"%d%d%d-%LD",WFSetupState,ATisOK,WFHasWritten,jankycntr); 
037EC:  CLR     W0
037EE:  BTSC.B  85D.0
037F0:  INC     W0,W0
037F2:  MOV.B   W0L,W5L
037F4:  CLR     W0
037F6:  BTSC.B  85D.4
037F8:  INC     W0,W0
037FA:  MOV.B   W0L,W6L
037FC:  MOV     #39B4,W4
037FE:  MOV     W4,214A
03800:  MOV.B   95D,W0L
03802:  SE      W0,W0
03804:  MOV     #0,W4
03806:  CALL    35FC
0380A:  SE      W5,W0
0380C:  MOV     #0,W4
0380E:  CALL    35FC
03812:  SE      W6,W0
03814:  MOV     #0,W4
03816:  CALL    35FC
0381A:  MOV.B   #2D,W0L
0381C:  CALL    35EA
03820:  MOV     214C,W0
03822:  MOV     #0,W4
03824:  CALL    35FC
.................... Display_XYString(12,1,cntrstr); 
03828:  MOV     #C,W4
0382A:  MOV     W4,39BA
0382C:  MOV     #1,W4
0382E:  MOV     W4,39BC
03830:  MOV     #39B4,W4
03832:  MOV     W4,39BE
03834:  CALL    27B0
....................  
.................... if(WFHasWritten==0) 
03838:  BTSC.B  85D.4
0383A:  BRA     39F6
.................... { 
.................... switch(WFSetupState) 
0383C:  MOV.B   95D,W0L
0383E:  CLR.B   1
03840:  XOR     #0,W0
03842:  BRA     Z,3882
03844:  XOR     #1,W0
03846:  BRA     Z,38AC
03848:  XOR     #3,W0
0384A:  BRA     Z,38CA
0384C:  XOR     #1,W0
0384E:  BRA     Z,38E8
03850:  XOR     #7,W0
03852:  BRA     Z,38F2
03854:  XOR     #1,W0
03856:  BRA     Z,38FC
03858:  XOR     #3,W0
0385A:  BRA     Z,391E
0385C:  XOR     #1,W0
0385E:  BRA     Z,393C
03860:  XOR     #F,W0
03862:  BRA     Z,3942
03864:  XOR     #1,W0
03866:  BRA     Z,3960
03868:  XOR     #3,W0
0386A:  BRA     Z,397E
0386C:  XOR     #1,W0
0386E:  BRA     Z,3986
03870:  XOR     #7,W0
03872:  BRA     Z,39A4
03874:  XOR     #1,W0
03876:  BRA     Z,39C2
03878:  XOR     #3,W0
0387A:  BRA     Z,39C8
0387C:  XOR     #1,W0
0387E:  BRA     Z,39E0
03880:  BRA     39F6
.................... { 
....................  
.................... //Enter AT Command Mode 
.................... case 0: 
.................... //xRST(); 
.................... delay_ms(50); 
03882:  MOV     #32,W0
03884:  CALL    21F2
.................... 	while (xReadyWiFi()) 
03888:  CALL    27E8
0388C:  CP0.B   W0L
0388E:  BRA     Z,389A
.................... 		{ 
.................... 		delay_ms(100); 
03890:  MOV     #64,W0
03892:  CALL    21F2
03896:  GOTO    3888
.................... 		} 
.................... WIFI_enter_setup(); 
0389A:  CALL    287E
.................... delay_ms(50); 
0389E:  MOV     #32,W0
038A0:  CALL    21F2
.................... //fprintf(WIFI,"AT+E=off\r"); 
.................... WFHasWritten=1; 
038A4:  BSET.B  85D.4
.................... WFSetupState++; 
038A6:  INC.B   095D
.................... break; 
038A8:  GOTO    39F6
.................... //readCharCFG(); 
.................... //VacSetXY(1,1); 
....................  
.................... //Setup AP and STA mode 
.................... case 1: 
.................... //WIFI_APSTA(1); 
.................... fprintf(WIFI,"AT+FAPSTA=on\r"); 
038AC:  MOV     #0,W1
038AE:  MOV     W1,W0
038B0:  CLR.B   1
038B2:  CALL    212
038B6:  INC     W1,W1
038B8:  BTSC.B  253.1
038BA:  BRA     38B8
038BC:  MOV     W0,254
038BE:  MOV     #C,W0
038C0:  CPSGT   W1,W0
038C2:  BRA     38AE
.................... WFHasWritten=1; 
038C4:  BSET.B  85D.4
.................... break; 
038C6:  GOTO    39F6
....................  
.................... //fprintf(WIFI,"AT+NETP\r"); 
.................... //delay_ms(20); 
.................... //readCharCFG(); 
.................... //fprintf(WIFI,"AT+UART\r"); 
.................... //readCharCFG(); 
....................  
.................... //delay_ms(20); 
....................  
.................... //delay_ms(20); 
.................... //fprintf(WIFI,"AT+WMODE=STA\r"); 
....................  
....................  
....................  
.................... case 2: 
.................... fprintf(WIFI,"AT+WMODE=STA\r"); 
038CA:  MOV     #0,W1
038CC:  MOV     W1,W0
038CE:  CLR.B   1
038D0:  CALL    266
038D4:  INC     W1,W1
038D6:  BTSC.B  253.1
038D8:  BRA     38D6
038DA:  MOV     W0,254
038DC:  MOV     #C,W0
038DE:  CPSGT   W1,W0
038E0:  BRA     38CC
.................... //WIFI_APSTA(1); 
....................  
.................... WFHasWritten=1; 
038E2:  BSET.B  85D.4
.................... break; 
038E4:  GOTO    39F6
....................  
....................  
.................... case 3: 
.................... WIFI_STA_SSID(); 
038E8:  CALL    3702
.................... //WIFI_APSTA(1); 
....................  
.................... WFHasWritten=1; 
038EC:  BSET.B  85D.4
.................... break; 
038EE:  GOTO    39F6
....................  
....................  
....................  
.................... case 4: 
.................... WIFI_STA_KEY(); 
038F2:  CALL    3738
....................  
.................... WFHasWritten=1; 
038F6:  BSET.B  85D.4
.................... break; 
038F8:  GOTO    39F6
....................  
....................  
....................  
....................  
....................  
.................... //VacSetXY(1,2); 
....................  
.................... case 5: 
.................... delay_ms(2000); 
038FC:  MOV     #7D0,W0
038FE:  CALL    21F2
.................... fprintf(WIFI,"AT+WAP=11BGN,OSMOBOT_AP,AUTO\r"); 
03902:  MOV     #0,W1
03904:  MOV     W1,W0
03906:  CLR.B   1
03908:  CALL    280
0390C:  INC     W1,W1
0390E:  BTSC.B  253.1
03910:  BRA     390E
03912:  MOV     W0,254
03914:  MOV     #1C,W0
03916:  CPSGT   W1,W0
03918:  BRA     3904
.................... //WFSetupState++; 
.................... //WFHasWritten=1; 
.................... break; 
0391A:  GOTO    39F6
....................  
.................... case 6: 
.................... fprintf(WIFI,"AT+WAKEY=WPAPSK,AES,osmopass!\r"); 
0391E:  MOV     #0,W1
03920:  MOV     W1,W0
03922:  CLR.B   1
03924:  CALL    2AA
03928:  INC     W1,W1
0392A:  BTSC.B  253.1
0392C:  BRA     392A
0392E:  MOV     W0,254
03930:  MOV     #1D,W0
03932:  CPSGT   W1,W0
03934:  BRA     3920
.................... WFHasWritten=1; 
03936:  BSET.B  85D.4
.................... //WFSetupState++; 
.................... break; 
03938:  GOTO    39F6
.................... //readCharCFG(); 
....................  
.................... //VacSetXY(1,3); 
....................  
.................... //readCharCFG(); 
....................  
....................  
.................... case 7: 
.................... #if USETCPB 
.................... fprintf(WIFI,"AT+NETP=TCP,SERVER,8899,10.10.100.254\r"); 
.................... #else 
.................... //fprintf(WIFI,"AT+NETP=TCP,CLIENT,80,osmobot.org\r"); 
.................... #endif 
....................  
.................... WFHasWritten=1; 
0393C:  BSET.B  85D.4
.................... //WFSetupState++; 
.................... break; 
0393E:  GOTO    39F6
....................  
.................... case 8: 
.................... fprintf(WIFI,"AT+TCPTO=3\r"); 
03942:  MOV     #0,W1
03944:  MOV     W1,W0
03946:  CLR.B   1
03948:  CALL    2D6
0394C:  INC     W1,W1
0394E:  BTSC.B  253.1
03950:  BRA     394E
03952:  MOV     W0,254
03954:  MOV     #A,W0
03956:  CPSGT   W1,W0
03958:  BRA     3944
.................... WFHasWritten=1; 
0395A:  BSET.B  85D.4
.................... //WFSetupState++; 
.................... break; 
0395C:  GOTO    39F6
....................  
....................  
....................  
....................  
.................... case 9: 
....................  
.................... #if USETCPB 
.................... fprintf(WIFI,"AT+TCPB=on\r"); 
.................... WFHasWritten=1; 
.................... //WFSetupState++; 
....................  
.................... #else 
.................... fprintf(WIFI,"AT+TCPB=off\r"); 
03960:  MOV     #0,W1
03962:  MOV     W1,W0
03964:  CLR.B   1
03966:  CALL    2EE
0396A:  INC     W1,W1
0396C:  BTSC.B  253.1
0396E:  BRA     396C
03970:  MOV     W0,254
03972:  MOV     #B,W0
03974:  CPSGT   W1,W0
03976:  BRA     3962
.................... WFHasWritten=1; 
03978:  BSET.B  85D.4
....................  
.................... #endif 
....................  
.................... break; 
0397A:  GOTO    39F6
....................  
.................... case 10: 
.................... #if USETCPB 
.................... fprintf(WIFI,"AT+TCPPTB=80\r"); 
.................... WFHasWritten=1; 
.................... #else 
.................... WFSetupState=13; 
0397E:  MOV.B   #D,W0L
03980:  MOV.B   W0L,95D
.................... #endif 
....................  
....................  
.................... //WFSetupState++; 
.................... break; 
03982:  GOTO    39F6
....................  
.................... case 11: 
.................... fprintf(WIFI,"AT+TCPADDB=osmobot.org\r"); 
03986:  MOV     #0,W1
03988:  MOV     W1,W0
0398A:  CLR.B   1
0398C:  CALL    308
03990:  INC     W1,W1
03992:  BTSC.B  253.1
03994:  BRA     3992
03996:  MOV     W0,254
03998:  MOV     #16,W0
0399A:  CPSGT   W1,W0
0399C:  BRA     3988
.................... WFHasWritten=1; 
0399E:  BSET.B  85D.4
.................... //WFSetupState++; 
.................... break; 
039A0:  GOTO    39F6
....................  
.................... case 12: 
.................... fprintf(WIFI,"AT+TCPTOB=5\r"); 
039A4:  MOV     #0,W1
039A6:  MOV     W1,W0
039A8:  CLR.B   1
039AA:  CALL    32C
039AE:  INC     W1,W1
039B0:  BTSC.B  253.1
039B2:  BRA     39B0
039B4:  MOV     W0,254
039B6:  MOV     #B,W0
039B8:  CPSGT   W1,W0
039BA:  BRA     39A6
.................... WFHasWritten=1; 
039BC:  BSET.B  85D.4
.................... //WFSetupState++; 
.................... break; 
039BE:  GOTO    39F6
....................  
.................... case 13: 
.................... //fprintf(WIFI,"AT+WSCAN\r"); 
.................... //WFHasWritten=1; 
.................... WFSetupState++; 
039C2:  INC.B   095D
.................... break; 
039C4:  GOTO    39F6
....................  
....................  
.................... case 14: 
.................... WIFI_reset(); 
039C8:  CALL    28AC
.................... delay_ms(5000); 
039CC:  MOV     #1388,W0
039CE:  CALL    21F2
.................... VacDisplayClear(); 
039D2:  CALL    236E
.................... WFSetupState=0; 
039D6:  CLR.B   95D
.................... WFIsConfig=1; 
039D8:  BSET.B  85D.1
.................... USEAT=0; 
039DA:  BCLR.B  85D.2
.................... //WFSetupState++; 
.................... break; 
039DC:  GOTO    39F6
....................  
.................... case 15: 
.................... WFSetupState=0; 
039E0:  CLR.B   95D
.................... WFIsConfig=1; 
039E2:  BSET.B  85D.1
.................... USEAT=0; 
039E4:  BCLR.B  85D.2
.................... VacDisplayClear(); 
039E6:  CALL    236E
.................... ROUTERHOLD=1; 
039EA:  BSET.B  85C.1
.................... delay_ms(5000); 
039EC:  MOV     #1388,W0
039EE:  CALL    21F2
.................... break; 
039F2:  GOTO    39F6
....................  
.................... //readCharCFG(); 
.................... 	} 
.................... 	} 
039F6:  MOV     [--W15],W6
039F8:  MOV     [--W15],W5
039FA:  RETURN  
.................... } 
....................  
....................  
.................... void WIFI_CONFIG_ROUTER_SETTINGS() 
.................... { 
....................  
.................... char cntrstr[4]; 
.................... static int8 WFSetupState=0; 
.................... static int1 WFHasWritten=0; 
.................... static int16 jankycntr=0; 
.................... while(WFSetupState<4) 
.................... { 
.................... USEAT=1; 
.................... 	if(ATisOK==1) 
.................... 	{ 
.................... 	ATisOK=0; 
.................... 	WFSetupState++; 
.................... 	WFHasWritten=0; 
.................... 	#if WFSETUPDEBUG 
.................... 	delay_ms(5000); 
.................... 	VacDisplayClear(); 
.................... 	#endif 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 	jankycntr++; 
.................... 	} 
....................  
.................... 	if(jankycntr>=100) 
.................... 	{ 
.................... 	jankycntr=0; 
.................... 	WFHasWritten=0;	 
.................... 	} 
....................  
.................... sprintf(cntrstr,"%d%d%d-%LD",WFSetupState,ATisOK,WFHasWritten,jankycntr); 
.................... Display_XYString(12,1,cntrstr); 
....................  
.................... switch(WFSetupState) 
.................... { 
.................... 	case 0: 
.................... 	WIFI_enter_setup(); 
.................... 	delay_ms(30); 
.................... 	fprintf(WIFI,"AT+E=off\r"); 
.................... 	WFHasWritten=1; 
.................... 	//WFSetupState++; 
.................... 	break; 
.................... 	 
.................... 	case 1: 
.................... 	WIFI_STA_SSID(); 
.................... 	 
.................... 	WFHasWritten=1; 
.................... 	break; 
....................  
....................  
....................  
.................... 	case 2: 
.................... 	WIFI_STA_KEY(); 
.................... 	 
.................... 	WFHasWritten=1; 
.................... 	break; 
....................  
.................... 	case 3: 
.................... 	WIFI_reset(); 
.................... 	VacDisplayClear(); 
.................... 	WFSetupState=0; 
.................... 	USEAT=0; 
.................... 	//WFSetupState++; 
.................... 	break; 
....................  
.................... 	case 4: 
.................... 	break; 
.................... 	} 
....................  
.................... } 
.................... } 
....................  
....................  
....................  
....................  
.................... void scanForRouters(int rst) 
.................... { 
.................... char dispBuff[20]; 
....................  
.................... static int scanState=0; 
.................... static int wroteCmd=0; 
....................  
.................... if(SCANERROR>0) 
.................... { 
.................... delay_ms(1000); 
.................... scanState=1; 
.................... wroteCmd=0; 
.................... SCANERROR=0; 
.................... } 
....................  
....................  
.................... switch(scanState) 
.................... { 
....................  
.................... //Enter Config Mode 
.................... case 0: 
.................... delay_ms(50); 
.................... 	while (xReadyWiFi()) 
.................... 		{ 
.................... 		delay_ms(100); 
.................... 		} 
.................... WIFI_enter_setup(); 
.................... delay_ms(50); 
.................... ROUTERSCANING=1; 
.................... delay_ms(50); 
.................... scanState++; 
.................... break; 
....................  
.................... //Start The Scan 
.................... case 1: 
.................... if(wroteCmd==0) 
.................... { 
.................... fprintf(WIFI,"AT+WSCAN\r"); 
.................... wroteCmd=1; 
.................... } 
.................... if(ROUTERSCANING==0) 
.................... { 
.................... scanState++; 
.................... wroteCmd=0; 
.................... } 
....................  
....................  
....................  
.................... break; 
....................  
.................... //Reset The module 
.................... case 2: 
.................... WIFI_reset(); 
.................... delay_ms(500); 
.................... ROUTERHOLD=0; 
.................... scanState=0; 
.................... resetParsing=1; 
.................... break; 
....................  
.................... default: 
.................... scanState=0; 
.................... break; 
....................  
....................  
.................... } 
.................... sprintf(dispBuff,"Scan,%d,%d,%d"scanState,ROUTERSCANING,ROUTERHOLD); 
....................  
.................... Display_XYString(0,3,dispBuff); 
.................... } 
....................  
....................  
....................  
.................... void setClient()//Configures WIFI module to be server 
.................... { 
.................... WIFI_enter_setup(); 
*
04460:  CALL    287E
.................... delay_ms(1000); 
04464:  MOV     #3E8,W0
04466:  CALL    21F2
.................... fprintf(WIFI,"AT+NETP=TCP,CLIENT,80,osmobot.org\r"); 
0446A:  MOV     #0,W1
0446C:  MOV     W1,W0
0446E:  CLR.B   1
04470:  CALL    346
04474:  INC     W1,W1
04476:  BTSC.B  253.1
04478:  BRA     4476
0447A:  MOV     W0,254
0447C:  MOV     #21,W0
0447E:  CPSGT   W1,W0
04480:  BRA     446C
....................  
.................... delay_ms(7000); 
04482:  MOV     #1B58,W0
04484:  CALL    21F2
.................... 	WIFI_reset(); 
04488:  CALL    28AC
.................... 	VacDisplayClear(); 
0448C:  CALL    236E
.................... clientOrServer=CLIENT; 
04490:  BCLR.B  85C.6
04492:  RETURN  
.................... } 
....................  
....................  
.................... void setServer() 
.................... { 
.................... WIFI_enter_setup(); 
*
028C8:  CALL    287E
.................... delay_ms(1000); 
028CC:  MOV     #3E8,W0
028CE:  CALL    21F2
.................... fprintf(WIFI,"AT+NETP=TCP,SERVER,8899,10.10.100.254\r"); 
028D2:  MOV     #0,W1
028D4:  MOV     W1,W0
028D6:  CLR.B   1
028D8:  CALL    376
028DC:  INC     W1,W1
028DE:  BTSC.B  253.1
028E0:  BRA     28DE
028E2:  MOV     W0,254
028E4:  MOV     #25,W0
028E6:  CPSGT   W1,W0
028E8:  BRA     28D4
.................... delay_ms(7000); 
028EA:  MOV     #1B58,W0
028EC:  CALL    21F2
.................... 	WIFI_reset(); 
028F0:  CALL    28AC
.................... 	VacDisplayClear(); 
028F4:  CALL    236E
.................... clientOrServer=SERVER; 
028F8:  BSET.B  85C.6
028FA:  RETURN  
.................... } 
....................  
.................... #include <routerParse.h> 
.................... #ifndef ROUTERPARSE_H 
.................... #define ROUTERPARSE_H 
....................  
.................... #define MAXNUMROUTERS 10 
....................  
.................... //#define XMLSIZE 30+MAXNUMROUTERS*125 
.................... #define RTRHTMLSIZE 1300 
....................  
....................  
.................... //Router Datastructure declaration 
....................  
.................... typedef struct Routerstruct { 
.................... char SSID[32];  
.................... char secType[24]; 
.................... int sigStr; 
.................... }Router; 
....................  
.................... //Router Table initialization 
.................... Router routerTable[MAXNUMROUTERS]; 
....................  
....................  
.................... //Buffer to hold router information as an XML file 
....................  
....................  
.................... char routerXML[RTRHTMLSIZE];//Preallocate memory for each router entry to be stored in XML 
....................  
....................  
.................... char tempXMLBuff[130]; 
....................  
....................  
.................... //Function Declarations 
.................... void printRouter(Router router); 
.................... int parseRouter(Router router[], char c, int RST); 
.................... void clearRouters(Router router[]); 
....................  
....................  
.................... #include "routerParse.c" 
....................  
.................... //#include <stdio.h> 
....................  
.................... //#define MAXNUMROUTERS 10 
....................  
....................  
.................... //Test String for the parser 
.................... /* 
.................... char testStr[]="+ok=\r\n\ 
.................... Ch,SSID,BSSID,Security,Signal(5)W-Mode,ExtCH,NT,WPS,DPID\r\n\ 
.................... 1,NETGEAR31,04:a1:51:1a:1d:73,WPA2PSK/AES,60,11b/g/n,NONE,IN,NO,\r\n\ 
.................... 4,2WIRE796,64:0f:28:6a:dd:59,WPA1PSKWPA2PSK/TKIPAES,0,11b/g/n,NONE,In,NO,\r\n\ 
.................... \r\n"; 
.................... */ 
....................  
....................  
....................  
.................... //Test program to validate functionality 
.................... /* 
.................... int main() 
.................... { 
....................     int mainCntr=0; 
....................     char cC; 
....................     do 
....................     { 
....................     cC=testStr[mainCntr]; 
....................       
....................     parseRouter(routerTable,cC,0);  
....................       
....................     mainCntr++;     
....................     } while(cC != '\0'); 
....................      
....................      
....................      
....................      
....................     //Generate Test Router 
....................     sprintf(routerTable[6].SSID,"Netgear31"); 
....................     sprintf(routerTable[6].secType,"WPA2PSK/AES"); 
....................     routerTable[6].sigStr=65; 
....................      
....................      
....................     printRouter(routerTable[0]); 
....................     printRouter(routerTable[1]); 
....................     //printf("%s\n",testStr); 
....................  
....................     return 0; 
.................... } 
.................... */ 
....................  
....................  
.................... //Test Function to ensure prober router data copy 
.................... void printRouter(Router router) 
.................... {  
.................... 	//PC Version 
....................    //printf("%s-%s-%d\n",router.SSID,router.secType,router.sigStr);   
.................... } 
....................  
....................  
....................  
.................... int parseRouter(Router router[], char c, int RST) 
*
03FE2:  MOV     W5,[W15++]
03FE4:  MOV     W6,[W15++]
03FE6:  MOV     #0,W4
03FE8:  MOV     W4,3934
.................... { 
.................... int doneParsing=0; 
.................... //Variables     
.................... static int rtrCntr=0; 
.................... static int charCntr=0; 
.................... static int itemCntr=-1; 
.................... static char tempBuff[42]; 
.................... static int rctr=0; 
.................... static char lastChar=0; 
.................... static int timeoutCtr=0; 
....................  
.................... //Semaphores 
.................... static int newLine=0;   //Semaphore can be int1 
.................... static int logData=0;   //Semaphore can be int1 
....................  
.................... if(c==lastChar) 
03FEA:  MOV     3930,W0
03FEC:  CLR.B   1
03FEE:  MOV     2960,W4
03FF0:  CLR.B   9
03FF2:  CP.B    W4L,W0L
03FF4:  BRA     NZ,3FFC
.................... { 
.................... timeoutCtr++; 
03FF6:  MOV     2962,W0
03FF8:  INC     W0,W0
03FFA:  MOV     W0,2962
.................... } 
....................  
....................  
.................... if(timeoutCtr>1500) 
03FFC:  MOV     2962,W0
03FFE:  MOV     #5DC,W4
04000:  CP      W4,W0
04002:  BRA     GE,4022
.................... { 
.................... lastChar=0; 
04004:  MOV     2960,W0
04006:  MOV.B   #0,W0L
04008:  MOV     W0,2960
.................... timeoutCtr=0; 
0400A:  MOV     #0,W4
0400C:  MOV     W4,2962
.................... rtrCntr=0; 
0400E:  MOV     #0,W4
04010:  MOV     W4,292E
.................... charCntr=0; 
04012:  MOV     #0,W4
04014:  MOV     W4,2930
.................... itemCntr=0; 
04016:  MOV     #0,W4
04018:  MOV     W4,2932
.................... doneParsing=1; 
0401A:  MOV     #1,W4
0401C:  MOV     W4,3934
.................... rctr=0;; 
0401E:  MOV     #0,W4
04020:  MOV     W4,295E
.................... } 
.................... switch(c)   //Switch what to do based on character 
04022:  MOV     3930,W0
04024:  CLR.B   1
04026:  XOR     #2C,W0
04028:  BRA     Z,4034
0402A:  XOR     #26,W0
0402C:  BRA     Z,4052
0402E:  XOR     #7,W0
04030:  BRA     Z,406A
04032:  BRA     409C
....................     { 
....................     case ',':   //Next Item in the list 
....................     tempBuff[charCntr]='\0'; 
04034:  MOV     2930,W0
04036:  MOV     #2934,W4
04038:  ADD     W0,W4,W5
0403A:  CLR.B   [W5]
....................     charCntr=0; 
0403C:  MOV     #0,W4
0403E:  MOV     W4,2930
....................     itemCntr++; 
04040:  MOV     2932,W0
04042:  INC     W0,W0
04044:  MOV     W0,2932
....................     logData=1; 
04046:  MOV     #1,W4
04048:  MOV     W4,2966
.................... 	newLine=0; 
0404A:  MOV     #0,W4
0404C:  MOV     W4,2964
....................  
....................     break; 
0404E:  GOTO    40B8
....................      
....................     case'\n':   //Next Line 
....................     tempBuff[charCntr]='\0'; 
04052:  MOV     2930,W0
04054:  MOV     #2934,W4
04056:  ADD     W0,W4,W5
04058:  CLR.B   [W5]
....................     newLine=1; 
0405A:  MOV     #1,W4
0405C:  MOV     W4,2964
....................     //logData=1; 
....................     charCntr=0; 
0405E:  MOV     #0,W4
04060:  MOV     W4,2930
....................     itemCntr=-1; 
04062:  MOV     #FFFF,W4
04064:  MOV     W4,2932
....................      
....................  
....................     break; 
04066:  GOTO    40B8
....................      
....................     case'\r':    //Check for end of response(\r\n\r\n) 
....................     if(newLine==1) 
0406A:  MOV     2964,W0
0406C:  CP      W0,#1
0406E:  BRA     NZ,4094
....................         { 
.................... 		rctr++; 
04070:  MOV     295E,W0
04072:  INC     W0,W0
04074:  MOV     W0,295E
.................... 		if(rctr>1) 
04076:  MOV     295E,W0
04078:  CP      W0,#1
0407A:  BRA     LE,4090
.................... 			{ 
....................         	//printf("-----Done!-----\n"); 
....................         	rtrCntr=0; 
0407C:  MOV     #0,W4
0407E:  MOV     W4,292E
....................         	charCntr=0; 
04080:  MOV     #0,W4
04082:  MOV     W4,2930
....................         	itemCntr=0; 
04084:  MOV     #0,W4
04086:  MOV     W4,2932
.................... 			doneParsing=1; 
04088:  MOV     #1,W4
0408A:  MOV     W4,3934
.................... 			rctr=0;; 
0408C:  MOV     #0,W4
0408E:  MOV     W4,295E
....................   			}       
.................... 		} 
04090:  GOTO    4098
....................     else 
....................         { 
....................         logData=1;     
04094:  MOV     #1,W4
04096:  MOV     W4,2966
....................         } 
....................     break; 
04098:  GOTO    40B8
....................      
....................     default:    //Any other character 
....................     tempBuff[charCntr]=c; 
0409C:  MOV     2930,W0
0409E:  MOV     #2934,W4
040A0:  ADD     W0,W4,W5
040A2:  MOV     3930,W0
040A4:  MOV.B   W0L,[W5+#0]
....................     charCntr++; 
040A6:  MOV     2930,W0
040A8:  INC     W0,W0
040AA:  MOV     W0,2930
.................... 	newLine=0; 
040AC:  MOV     #0,W4
040AE:  MOV     W4,2964
.................... 	rctr=0; 
040B0:  MOV     #0,W4
040B2:  MOV     W4,295E
....................     break; 
040B4:  GOTO    40B8
....................     } 
.................... //Resets newline if character isnt \n     
.................... if(c!='\n') 
040B8:  MOV     3930,W0
040BA:  CLR.B   1
040BC:  CP.B    W0L,#A
040BE:  BRA     Z,40C4
.................... { 
.................... newLine=0;    
040C0:  MOV     #0,W4
040C2:  MOV     W4,2964
.................... }     
....................  
.................... //printf("%d,%d,%d: %c\n",rtrCntr,itemCntr,charCntr,c); 
.................... //Do more useful stuff later, for now just print string... 
....................  
....................  
.................... if(logData==1) 
040C4:  MOV     2966,W0
040C6:  CP      W0,#1
040C8:  BRA     NZ,419E
....................     { 
....................     //printf("%d,%d,%d: %s\n",rtrCntr,itemCntr,charCntr,tempBuff+1-1);    
....................     if(rtrCntr>=0)  //If actually a router, offsets compensate for extra data 
040CA:  MOV     292E,W0
040CC:  CP      W0,#0
040CE:  BRA     LT,419E
....................         { 
....................         switch(itemCntr) 
040D0:  MOV     2932,W0
040D2:  XOR     #1,W0
040D4:  BRA     Z,40E0
040D6:  XOR     #2,W0
040D8:  BRA     Z,4138
040DA:  XOR     #7,W0
040DC:  BRA     Z,417C
040DE:  BRA     419A
....................             { 
....................             case 1: //SSID     
....................             sprintf(routerTable[rtrCntr].SSID,tempBuff); 
040E0:  MOV     292E,W0
040E2:  MOV     #3A,W4
040E4:  MUL.SS  W0,W4,W0
040E6:  MOV     W0,W5
040E8:  MOV     #2154,W4
040EA:  ADD     W5,W4,W6
040EC:  MOV     W6,214A
040EE:  MOV     214A,W0
040F0:  CLR.B   [W0]
040F2:  MOV.B   #0,W4L
040F4:  MOV.B   W4L,[W0+#1]
040F6:  MOV     #2934,W1
040F8:  CP0.B   [W1]
040FA:  BRA     Z,410C
040FC:  MOV     W1,[W15++]
040FE:  MOV     W1,W4
04100:  MOV.B   [W4],W0L
04102:  CALL    35EA
04106:  MOV     [--W15],W1
04108:  INC     W1,W1
0410A:  BRA     40F8
.................... 			Display_XYString(2,1,tempBuff); 
0410C:  MOV     #2,W4
0410E:  MOV     W4,39BA
04110:  MOV     #1,W4
04112:  MOV     W4,39BC
04114:  MOV     #2934,W4
04116:  MOV     W4,39BE
04118:  CALL    27B0
.................... 			//if(strncmp(tempBuff,"SSID",3)) 
.................... 				//{ 
.................... 				routerTable[rtrCntr].sigStr=-2;//blacklist it 
0411C:  MOV     292E,W0
0411E:  MOV     #3A,W4
04120:  MUL.SS  W0,W4,W0
04122:  MOV     W0,W5
04124:  MOV     #38,W4
04126:  ADD     W5,W4,W0
04128:  MOV     #2154,W4
0412A:  ADD     W0,W4,W5
0412C:  MOV.B   #FE,W0L
0412E:  MOV.B   W0L,[W5]
04130:  MOV.B   #FF,W0L
04132:  MOV.B   W0L,[W5+#1]
.................... 			//	} 
....................             break; 
04134:  GOTO    419E
....................              
....................             case 3: //Security Mode 
....................             sprintf(routerTable[rtrCntr].secType,tempBuff); 
04138:  MOV     292E,W0
0413A:  MOV     #3A,W4
0413C:  MUL.SS  W0,W4,W0
0413E:  MOV     W0,W5
04140:  MOV     #20,W4
04142:  ADD     W5,W4,W0
04144:  MOV     #2154,W4
04146:  ADD     W0,W4,W5
04148:  MOV     W5,214A
0414A:  MOV     214A,W0
0414C:  CLR.B   [W0]
0414E:  MOV.B   #0,W4L
04150:  MOV.B   W4L,[W0+#1]
04152:  MOV     #2934,W1
04154:  CP0.B   [W1]
04156:  BRA     Z,4168
04158:  MOV     W1,[W15++]
0415A:  MOV     W1,W4
0415C:  MOV.B   [W4],W0L
0415E:  CALL    35EA
04162:  MOV     [--W15],W1
04164:  INC     W1,W1
04166:  BRA     4154
.................... 			Display_XYString(3,1,tempBuff); 
04168:  MOV     #3,W4
0416A:  MOV     W4,39BA
0416C:  MOV     #1,W4
0416E:  MOV     W4,39BC
04170:  MOV     #2934,W4
04172:  MOV     W4,39BE
04174:  CALL    27B0
....................             break; 
04178:  GOTO    419E
....................              
....................             case 4: //Signal Strength 
.................... 		//	if(routerTable[rtrCntr].sigStr!=-2) 
.................... 				//{ 
....................             	routerTable[rtrCntr].sigStr=atoi(tempBuff); 
0417C:  MOV     292E,W0
0417E:  MOV     #3A,W4
04180:  MUL.SS  W0,W4,W0
04182:  MOV     W0,W5
04184:  MOV     #38,W4
04186:  ADD     W5,W4,W0
04188:  MOV     #2154,W4
0418A:  ADD     W0,W4,W5
0418C:  MOV     #2934,W4
0418E:  MOV     W4,393E
04190:  CALL    3DD8
04194:  MOV     W0,[W5]
....................     			//}        	 
.................... 			break; 
04196:  GOTO    419E
....................                  
....................             default:    //I Dont Care about it 
....................              
....................             break; 
0419A:  GOTO    419E
....................             } 
....................         } 
....................     } 
....................  
....................  
.................... if(newLine==1) 
0419E:  MOV     2964,W0
041A0:  CP      W0,#1
041A2:  BRA     NZ,41AA
....................     { 
....................         //printf("-----Next Router-----\n"); 
....................         rtrCntr++; 
041A4:  MOV     292E,W0
041A6:  INC     W0,W0
041A8:  MOV     W0,292E
....................     } 
....................  
.................... logData=0;  //Reset logData everytime  
041AA:  MOV     #0,W4
041AC:  MOV     W4,2966
....................  
.................... return doneParsing;  
041AE:  PUSH    3934
041B0:  POP     0
041B2:  MOV     [--W15],W6
041B4:  MOV     [--W15],W5
041B6:  RETURN  
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... //Function sets all of the router channels equal to -1 which indicates they should not be used 
.................... void clearRouters(Router router[]) 
*
021C2:  MOV     W5,[W15++]
021C4:  MOV     #0,W4
021C6:  MOV     W4,3804
.................... { 
.................... int cntr=0; 
.................... while(cntr<MAXNUMROUTERS) 
021C8:  MOV     3804,W0
021CA:  CP      W0,#A
021CC:  BRA     GE,21EE
.................... 	{ 
.................... 	routerTable[cntr].sigStr=-1; 
021CE:  MOV     3804,W0
021D0:  MOV     #3A,W4
021D2:  MUL.SS  W0,W4,W0
021D4:  MOV     W0,W5
021D6:  MOV     #38,W4
021D8:  ADD     W5,W4,W0
021DA:  MOV     #2154,W4
021DC:  ADD     W0,W4,W5
021DE:  SETM.B  [W5]
021E0:  MOV.B   #FF,W0L
021E2:  MOV.B   W0L,[W5+#1]
.................... 	cntr++; 
021E4:  MOV     3804,W0
021E6:  INC     W0,W0
021E8:  MOV     W0,3804
021EA:  GOTO    21C8
.................... 	}	 
021EE:  MOV     [--W15],W5
021F0:  RETURN  
.................... } 
....................  
....................  
.................... void testRouter() 
.................... { 
.................... 	routerTable[0].sigStr=71; 
....................     sprintf(routerTable[0].SSID,"NETGEAR31"); 
....................     sprintf(routerTable[0].secType,"WPA2/AES"); 
....................  
.................... 	routerTable[1].sigStr=15; 
....................     sprintf(routerTable[1].SSID,"Test1"); 
....................     sprintf(routerTable[1].secType,"NONE/NONE"); 
....................  
.................... 	routerTable[2].sigStr=17; 
....................     sprintf(routerTable[2].SSID,"Test2"); 
....................     sprintf(routerTable[2].secType,"WPA1PSKWPA2PSK/TKIPAES"); 
....................  
....................     sprintf(routerTable[6].SSID,"Test3"); 
....................     sprintf(routerTable[6].secType,"WPA2PSK/AES"); 
....................     routerTable[6].sigStr=65; 
.................... } 
....................  
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "wwwParser.c" 
.................... ////////////////////////////////////////// 
.................... //Data Storer 
.................... ////////////////////////////////////////// 
....................  
....................  
....................  
.................... //sysOutput.,sysInput. 
....................  
.................... //void storeRecievedData(char strBuff[], unsigned int8 index, unsigned int8 dataSet,outputDataStruct *oStruct, inputDataStruct *iStruct) 
....................  
.................... void storeRecievedData(char strBuff[], unsigned int8 index, unsigned int8 dataSet) 
*
02BD0:  MOV     W5,[W15++]
.................... { 
.................... char *garbage;	//Just to please the string function gods... 
....................  
.................... switch(dataSet) 
02BD2:  PUSH    3938
02BD4:  MOV     [--W15],W0
02BD6:  LSR     W0,#8,W0
02BD8:  CLR.B   1
02BDA:  XOR     #0,W0
02BDC:  BRA     Z,2BE8
02BDE:  XOR     #1,W0
02BE0:  BRA     Z,2BFE
02BE2:  XOR     #3,W0
02BE4:  BRA     Z,2CA4
02BE6:  BRA     2D4E
.................... 	{	 
.................... 	case 0:	//Checksum Value 
.................... 	sysInput.chksum=strtoul(strBuff,&garbage,10); 
02BE8:  PUSH    3936
02BEA:  POP     3942
02BEC:  MOV     #393A,W4
02BEE:  MOV     W4,3944
02BF0:  MOV     #A,W4
02BF2:  MOV     W4,3946
02BF4:  CALL    297A
02BF8:  MOV.B   W0L,1982
....................  
.................... 		#ifdef STACK_USE_PICDEM_LCD 
....................          //printf(lcd_putc,"\fOsmobot: %u\nServer: %u",checksum,sysInput.chksum); 
.................... 		#endif 
.................... 		//newChksum=1; 
.................... 	break; 
02BFA:  GOTO    2D52
....................  
.................... 	case 1:	//Time 
.................... 	 
.................... 		switch(index){ 
02BFE:  MOV     3938,W0
02C00:  CLR.B   1
02C02:  XOR     #0,W0
02C04:  BRA     Z,2C1C
02C06:  XOR     #1,W0
02C08:  BRA     Z,2C32
02C0A:  XOR     #3,W0
02C0C:  BRA     Z,2C48
02C0E:  XOR     #1,W0
02C10:  BRA     Z,2C5E
02C12:  XOR     #7,W0
02C14:  BRA     Z,2C74
02C16:  XOR     #1,W0
02C18:  BRA     Z,2C8A
02C1A:  BRA     2CA0
.................... 			case 0://year 
.................... 			sysInput.year=strtoul(strBuff,&garbage,10); 
02C1C:  PUSH    3936
02C1E:  POP     3942
02C20:  MOV     #393A,W4
02C22:  MOV     W4,3944
02C24:  MOV     #A,W4
02C26:  MOV     W4,3946
02C28:  CALL    297A
02C2C:  MOV     W0,1988
.................... 			break; 
02C2E:  GOTO    2CA0
....................  
.................... 			case 1://month 
.................... 			sysInput.month=strtoul(strBuff,&garbage,10); 
02C32:  PUSH    3936
02C34:  POP     3942
02C36:  MOV     #393A,W4
02C38:  MOV     W4,3944
02C3A:  MOV     #A,W4
02C3C:  MOV     W4,3946
02C3E:  CALL    297A
02C42:  MOV.B   W0L,1987
.................... 			break; 
02C44:  GOTO    2CA0
....................  
.................... 			case 2://day 
.................... 			sysInput.day=strtoul(strBuff,&garbage,10); 
02C48:  PUSH    3936
02C4A:  POP     3942
02C4C:  MOV     #393A,W4
02C4E:  MOV     W4,3944
02C50:  MOV     #A,W4
02C52:  MOV     W4,3946
02C54:  CALL    297A
02C58:  MOV.B   W0L,1986
.................... 			break; 
02C5A:  GOTO    2CA0
....................  
.................... 			case 3://hour 
.................... 			sysInput.hour=strtoul(strBuff,&garbage,10); 
02C5E:  PUSH    3936
02C60:  POP     3942
02C62:  MOV     #393A,W4
02C64:  MOV     W4,3944
02C66:  MOV     #A,W4
02C68:  MOV     W4,3946
02C6A:  CALL    297A
02C6E:  MOV.B   W0L,1983
.................... 			break; 
02C70:  GOTO    2CA0
....................  
.................... 			case 4://minute 
.................... 			sysInput.minute=strtoul(strBuff,&garbage,10); 
02C74:  PUSH    3936
02C76:  POP     3942
02C78:  MOV     #393A,W4
02C7A:  MOV     W4,3944
02C7C:  MOV     #A,W4
02C7E:  MOV     W4,3946
02C80:  CALL    297A
02C84:  MOV.B   W0L,1984
....................       
.................... 			break; 
02C86:  GOTO    2CA0
....................  
.................... 			case 5://second 
.................... 			sysInput.second=strtoul(strBuff,&garbage,10); 
02C8A:  PUSH    3936
02C8C:  POP     3942
02C8E:  MOV     #393A,W4
02C90:  MOV     W4,3944
02C92:  MOV     #A,W4
02C94:  MOV     W4,3946
02C96:  CALL    297A
02C9A:  MOV.B   W0L,1985
.................... 			break; 
02C9C:  GOTO    2CA0
....................  
.................... 		} 
.................... 	break; 
02CA0:  GOTO    2D52
....................  
.................... 	case 2:	//General Control 
.................... //	TCPHold=0; 
....................  
.................... switch(index){ 
02CA4:  MOV     3938,W0
02CA6:  CLR.B   1
02CA8:  XOR     #0,W0
02CAA:  BRA     Z,2CC2
02CAC:  XOR     #1,W0
02CAE:  BRA     Z,2CC6
02CB0:  XOR     #3,W0
02CB2:  BRA     Z,2D3A
02CB4:  XOR     #1,W0
02CB6:  BRA     Z,2D3E
02CB8:  XOR     #7,W0
02CBA:  BRA     Z,2D42
02CBC:  XOR     #1,W0
02CBE:  BRA     Z,2D46
02CC0:  BRA     2D4A
.................... 			case 0://Serial Number 
.................... 			//nothing for now add SN check later 
.................... 			break; 
02CC2:  GOTO    2D4A
....................  
.................... 			case 1://SSR Control BITS 
.................... 			//////////Recieved:### 
.................... 			///////Bit Mapping:123 
.................... 			int ctrlNum=strtoul(strBuff,&garbage,10); 
02CC6:  PUSH    3936
02CC8:  POP     3942
02CCA:  MOV     #393A,W4
02CCC:  MOV     W4,3944
02CCE:  MOV     #A,W4
02CD0:  MOV     W4,3946
02CD2:  CALL    297A
02CD6:  MOV     W0,393C
.................... 			sysInput.io3=(ctrlNum%10); 
02CD8:  MOV     393C,W0
02CDA:  MOV     W0,W4
02CDC:  MOV     #A,W3
02CDE:  REPEAT  #11
02CE0:  DIV.S   W4,W3
02CE2:  MOV     W1,W0
02CE4:  BCLR.B  198A.2
02CE6:  BTSC.B  0.0
02CE8:  BSET.B  198A.2
.................... 			ctrlNum-=sysInput.io3;	//Get rid of that pesky 1's place 
02CEA:  CLR     W0
02CEC:  BTSC.B  198A.2
02CEE:  INC     W0,W0
02CF0:  ZE      W0,W0
02CF2:  MOV     393C,W4
02CF4:  CLR.B   1
02CF6:  SUB     W4,W0,W0
02CF8:  MOV     W0,393C
.................... 			sysInput.io2=(ctrlNum%100)/10; 
02CFA:  MOV     393C,W0
02CFC:  MOV     W0,W4
02CFE:  MOV     #64,W3
02D00:  REPEAT  #11
02D02:  DIV.S   W4,W3
02D04:  MOV     W1,W5
02D06:  MOV     W5,W4
02D08:  MOV     #A,W3
02D0A:  REPEAT  #11
02D0C:  DIV.S   W4,W3
02D0E:  BCLR.B  198A.1
02D10:  BTSC.B  0.0
02D12:  BSET.B  198A.1
.................... 			ctrlNum-=(sysInput.io2)*10;	//Get rid of that pesky 10's place 
02D14:  CLR     W0
02D16:  BTSC.B  198A.1
02D18:  INC     W0,W0
02D1A:  MOV.B   W0L,W4L
02D1C:  CLR.B   9
02D1E:  MUL.UU  W4,#A,W0
02D20:  MOV     393C,W4
02D22:  SUB     W4,W0,W0
02D24:  MOV     W0,393C
.................... 			sysInput.io1=(ctrlNum/100); 
02D26:  MOV     393C,W0
02D28:  MOV     W0,W4
02D2A:  MOV     #64,W3
02D2C:  REPEAT  #11
02D2E:  DIV.S   W4,W3
02D30:  BCLR.B  198A.0
02D32:  BTSC.B  0.0
02D34:  BSET.B  198A.0
....................  
.................... 			 
.................... 			break; 
02D36:  GOTO    2D4A
....................  
.................... 			case 2://month 
.................... 			//Stuff? 
.................... 			break; 
02D3A:  GOTO    2D4A
....................  
.................... 			case 3://month 
.................... 			//Stuff? 
.................... 			break; 
02D3E:  GOTO    2D4A
....................  
.................... 			case 4://month 
.................... 			//Stuff? 
.................... 			break; 
02D42:  GOTO    2D4A
....................  
.................... 			case 5://month 
.................... 			//Stuff? 
.................... 			break; 
02D46:  GOTO    2D4A
....................  
.................... 			}			 
.................... 	break; 
02D4A:  GOTO    2D52
....................  
.................... 	default: 
.................... 	//nothing 
.................... 	break; 
02D4E:  GOTO    2D52
....................  
.................... 	} 
02D52:  MOV     [--W15],W5
02D54:  RETURN  
.................... }  
....................  
....................  
....................  
....................  
.................... ///////////////////////////////////// 
.................... //End Stored Recieved Data 
.................... //////////////////////////////////// 
....................  
....................  
....................  
....................  
.................... #define HTTPDEBUG 0 
....................  
....................  
....................  
.................... ///////////////////////////////////////////// 
.................... //Text Parser 
.................... ///////////////////////////////////////////// 
....................  int1 startText=0; 
....................  unsigned int8 i = 0; 
....................  unsigned int8 valNum =0; 
....................  unsigned int8 dataSet=0; 
....................  
....................  
....................  
.................... void parseHTTP(char c, char tempBuff[]) 
02D56:  MOV     W5,[W15++]
.................... { 
....................   
.................... //if(testcntr>2500000) 
.................... if(1) 
.................... { 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #if HTTPDEBUG  
.................... char Myteststr[10]; 
.................... sprintf(Myteststr,"%c,%i,%i",c,valNum,dataSet); 
.................... Display_XYString(12,1,Myteststr); 
.................... delay_ms(5); 
.................... #endif 
....................  
....................  
....................       //while (TCPGet(socket, &c)) { 
.................... 	//	while (bkbhit){ 
.................... 	//	if (bkbhit){ 
.................... 	//	  sysOutput.nH4=sysOutput.nH4+1;     
.................... 		//char c= getWIFIChar();	 
.................... 		 
.................... 		#if I2CDEBUG 
.................... 		i2c_start(); 
.................... 		i2c_write(0xa0); 
.................... 		i2c_write(c); 
.................... 		i2c_stop();  
.................... 		#endif 
....................  
.................... 		 
.................... 		 
.................... 		if(c=='~') 
02D58:  MOV     392E,W0
02D5A:  CLR.B   1
02D5C:  MOV     #7E,W4
02D5E:  CP.B    W4L,W0L
02D60:  BRA     NZ,2D70
.................... 		{ 
.................... 			#if HTTPDEBUG  
.................... 				Display_XYString(10,1,"1"); 
.................... 			#endif 
.................... 		startText=1; 
02D62:  BSET.B  85D.6
.................... 		valNum =0; 
02D64:  MOV     2968,W0
02D66:  MOV.B   #0,W0L
02D68:  MOV     W0,2968
.................... 		dataSet=0; 
02D6A:  MOV     2968,W0
02D6C:  CLR.B   1
02D6E:  MOV     W0,2968
.................... 		//printf(lcd_putc,"\f"); 
.................... 		} 
.................... 	if(startText)	//once you're in the meat of the code 
02D70:  BTSS.B  85D.6
02D72:  BRA     2E2C
.................... 	{ 
....................  
.................... 		switch(c){ 
02D74:  MOV     392E,W0
02D76:  CLR.B   1
02D78:  XOR     #7E,W0
02D7A:  BRA     Z,2D8A
02D7C:  XOR     #23,W0
02D7E:  BRA     Z,2D8E
02D80:  XOR     #71,W0
02D82:  BRA     Z,2D94
02D84:  XOR     #26,W0
02D86:  BRA     Z,2DCE
02D88:  BRA     2E10
.................... 		case'~': 
.................... 		//Nothing 
.................... 		break; 
02D8A:  GOTO    2E2C
....................  
.................... 		case']': 
.................... 		startText=0; 
02D8E:  BCLR.B  85D.6
.................... 			#if HTTPDEBUG  
.................... 				Display_XYString(10,1,"0"); 
.................... 			#endif 
.................... 		break; 
02D90:  GOTO    2E2C
....................  
.................... 		case',':	//next number 
.................... 		tempBuff[i]='\0';	//Ensures that buffer wont be overwritten in a way that causes data corruption 
02D94:  MOV     2960,W4
02D96:  LSR     W4,#8,W4
02D98:  MOV     3930,W0
02D9A:  ADD     W4,W0,W5
02D9C:  CLR.B   [W5]
.................... 		storeRecievedData(tempBuff,valNum,dataSet); 
02D9E:  MOV     2968,W0
02DA0:  PUSH    3938
02DA2:  MOV.B   W0L,[W15-#2]
02DA4:  POP     3938
02DA6:  PUSH    2968
02DA8:  MOV     [--W15],W0
02DAA:  LSR     W0,#8,W0
02DAC:  PUSH    3938
02DAE:  MOV.B   W0L,[W15-#1]
02DB0:  POP     3938
02DB2:  PUSH    3930
02DB4:  POP     3936
02DB6:  CALL    2BD0
.................... 		i=0; 
02DBA:  MOV     2960,W0
02DBC:  CLR.B   1
02DBE:  MOV     W0,2960
.................... 		valNum++; 
02DC0:  MOV     2968,W0
02DC2:  INC.B   W0L,W0L
02DC4:  PUSH    2968
02DC6:  MOV.B   W0L,[W15-#2]
02DC8:  POP     2968
....................  
.................... 		#if HTTPDEBUG  
.................... 			Display_XYString(7,2,tempBuff); 
.................... 		#endif 
....................  
.................... 		break; 
02DCA:  GOTO    2E2C
....................  
.................... 		case'\n':	//Next Dataset 
.................... 		tempBuff[i]='\0';	//Ensures that buffer wont be overwritten in a way that causes data corruption 
02DCE:  MOV     2960,W4
02DD0:  LSR     W4,#8,W4
02DD2:  MOV     3930,W0
02DD4:  ADD     W4,W0,W5
02DD6:  CLR.B   [W5]
.................... 		storeRecievedData(tempBuff,valNum,dataSet); 
02DD8:  MOV     2968,W0
02DDA:  PUSH    3938
02DDC:  MOV.B   W0L,[W15-#2]
02DDE:  POP     3938
02DE0:  PUSH    2968
02DE2:  MOV     [--W15],W0
02DE4:  LSR     W0,#8,W0
02DE6:  PUSH    3938
02DE8:  MOV.B   W0L,[W15-#1]
02DEA:  POP     3938
02DEC:  PUSH    3930
02DEE:  POP     3936
02DF0:  CALL    2BD0
.................... 		i=0; 
02DF4:  MOV     2960,W0
02DF6:  CLR.B   1
02DF8:  MOV     W0,2960
.................... 		valNum=0; 
02DFA:  MOV     2968,W0
02DFC:  MOV.B   #0,W0L
02DFE:  MOV     W0,2968
.................... 		 
.................... 			#if HTTPDEBUG  
.................... 			Display_XYString(7,2,tempBuff); 
.................... 			#endif 
.................... 		 
.................... 		dataSet++; 
02E00:  MOV     2968,W0
02E02:  LSR     W0,#8,W0
02E04:  INC.B   W0L,W0L
02E06:  PUSH    2968
02E08:  MOV.B   W0L,[W15-#1]
02E0A:  POP     2968
.................... 		break; 
02E0C:  GOTO    2E2C
.................... 	 
.................... 		default:	//Regular ol' number 
.................... 		tempBuff[i]=c;	//add the character to the buffer 
02E10:  MOV     2960,W4
02E12:  LSR     W4,#8,W4
02E14:  MOV     3930,W0
02E16:  ADD     W4,W0,W5
02E18:  MOV     392E,W0
02E1A:  MOV.B   W0L,[W5+#0]
.................... 		i++;	//increment 
02E1C:  MOV     2960,W0
02E1E:  LSR     W0,#8,W0
02E20:  INC.B   W0L,W0L
02E22:  PUSH    2960
02E24:  MOV.B   W0L,[W15-#1]
02E26:  POP     2960
.................... 		break; 
02E28:  GOTO    2E2C
.................... 		} 
....................  
.................... 	} 
.................... 	 
.................... 	}	 
02E2C:  MOV     [--W15],W5
02E2E:  RETURN  
.................... } 
.................... /////////////////////////////////////////////////////// 
.................... //End Text Parser 
.................... /////////////////////////////////////////////////////// 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "osmoWebServer.c" 
.................... /* 
.................... static int danweb_readline_client (char *buf, int length) 
.................... { 
.................... 	if (!client.available()) 
.................... 		return -1; 
....................  
.................... 	int8 count = 0; 
.................... 	char c; 
.................... 	while ((c = client.read()) > 0) { 
.................... 		if (c == '\r') 
.................... 			continue; 
.................... 		if (c == '\n') 
.................... 			break; 
.................... 		if (count >= length) 
.................... 			break; 
.................... 		buf[count++] = c; 
.................... 	} 
.................... 	buf[count] = 0; 
.................... 	return count; 
.................... } 
.................... */ 
....................  
....................  
.................... #define SERVERLCD 0 
....................  
....................  
.................... unsigned int8 httprlinecntr=0; 
....................  
.................... //Parse a Line of HTTP Request, returns 1 if end of line returns 0 otherwise 
.................... int1 getRequestLine(char c, char buff[]) 
02E30:  MOV     W5,[W15++]
02E32:  MOV     W6,[W15++]
.................... { 
.................... //Reached The End of a Line 
.................... buff[httprlinecntr]=c; 
02E34:  MOV     296A,W4
02E36:  CLR.B   9
02E38:  MOV     3930,W0
02E3A:  ADD     W4,W0,W5
02E3C:  MOV     392E,W0
02E3E:  MOV.B   W0L,[W5+#0]
.................... int1 returnval =0; 
02E40:  MOV     392E,W0
02E42:  BCLR.B  1.0
02E44:  MOV     W0,392E
.................... if(c=='\n') 
02E46:  MOV     392E,W0
02E48:  CLR.B   1
02E4A:  CP.B    W0L,#A
02E4C:  BRA     NZ,2E6C
.................... 	{ 
....................  
.................... 	buff[httprlinecntr+1]='\0'; 
02E4E:  MOV     296A,W4
02E50:  CLR.B   9
02E52:  ADD     W4,#1,W4
02E54:  MOV     W4,W5
02E56:  MOV     3930,W0
02E58:  ADD     W5,W0,W6
02E5A:  CLR.B   [W6]
.................... 	httprlinecntr=0; 
02E5C:  MOV     296A,W0
02E5E:  MOV.B   #0,W0L
02E60:  MOV     W0,296A
.................... 	returnval=1; 
02E62:  MOV     392E,W0
02E64:  BSET.B  1.0
02E66:  MOV     W0,392E
.................... 	} 
02E68:  GOTO    2E76
.................... //Any Other Character 
.................... else 
.................... 	{ 
.................... 	httprlinecntr++; 
02E6C:  MOV     296A,W0
02E6E:  INC.B   W0L,W0L
02E70:  PUSH    296A
02E72:  MOV.B   W0L,[W15-#2]
02E74:  POP     296A
.................... 	//return 0; 
.................... 	}	 
.................... return returnval; 
02E76:  MOV     392E,W4
02E78:  CLR     W0
02E7A:  BTSC    W4.8
02E7C:  INC     W0,W0
02E7E:  MOV     [--W15],W6
02E80:  MOV     [--W15],W5
02E82:  RETURN  
.................... } 
....................  
....................  
.................... int1 lineIsGetRequest(char buff[]) 
02E84:  MOV     W5,[W15++]
.................... { 
.................... 	// Looks for GET in the line 
.................... //	if (strstr(buff, "GET ") != 0) 
.................... if (buff[0]=='G') 
02E86:  MOV     392E,W0
02E88:  MOV     #0,W4
02E8A:  ADD     W4,W0,W0
02E8C:  MOV.B   [W0],W4L
02E8E:  XOR.B   #47,W4L
02E90:  BRA     NZ,2E9C
.................... 		{ 
.................... 		return 1; 
02E92:  MOV.B   #1,W0L
02E94:  MOV.B   W0L,0
02E96:  BRA     2EA0
.................... 		} 
02E98:  GOTO    2EA0
.................... 	else 
.................... 		{ 
.................... 		return 0; 
02E9C:  CLR.B   0
02E9E:  BRA     2EA0
.................... 		} 
02EA0:  MOV     [--W15],W5
02EA2:  RETURN  
.................... } 
....................  
....................  
....................  
.................... //Returns 1 if the request has a page text, 0 if blank host request 
.................... int1 parseGetRequest(char lineBuff[], char pageRequestBuff[]) 
02EA4:  MOV     W5,[W15++]
.................... { 
.................... //No Page Requested 
.................... if(lineBuff[5]==' ') 
02EA6:  MOV     392E,W0
02EA8:  MOV     #5,W4
02EAA:  ADD     W4,W0,W0
02EAC:  MOV.B   [W0],W4L
02EAE:  XOR.B   #20,W4L
02EB0:  BRA     NZ,2EC2
.................... 	{ 
.................... 	pageRequestBuff[0]='\0';	//Blank it just in case 
02EB2:  MOV     3930,W0
02EB4:  MOV     #0,W4
02EB6:  ADD     W4,W0,W5
02EB8:  CLR.B   [W5]
.................... 	#if SERVERLCD 
.................... 	VacDisplayClear(); 
.................... 	Display_XYString(0,1,"ROOT PAGE"); 
.................... 	#endif 
.................... 	return 0; 
02EBA:  CLR.B   0
02EBC:  BRA     2EFC
.................... 	} 
02EBE:  GOTO    2EFC
.................... //There is a type of page 
.................... else 
.................... { 
.................... int16 pageParseCntr=0; 
.................... char c; 
02EC2:  MOV     #0,W4
02EC4:  MOV     W4,3932
.................... //Copy The Request Text 
.................... while((c=lineBuff[4+pageParseCntr])!=' ')//Get Character until space 
02EC6:  MOV     3932,W0
02EC8:  MOV     #4,W4
02ECA:  ADD     W4,W0,W5
02ECC:  MOV     392E,W0
02ECE:  ADD     W5,W0,W0
02ED0:  MOV     3934,W4
02ED2:  MOV.B   [W0+#0],W4L
02ED4:  MOV     W4,3934
02ED6:  MOV     3934,W0
02ED8:  CLR.B   1
02EDA:  MOV     #20,W4
02EDC:  CP.B    W4L,W0L
02EDE:  BRA     Z,2EF4
.................... { 
.................... pageRequestBuff[pageParseCntr]=c; 
02EE0:  MOV     3932,W0
02EE2:  MOV     3930,W4
02EE4:  ADD     W0,W4,W5
02EE6:  MOV     3934,W0
02EE8:  MOV.B   W0L,[W5+#0]
.................... pageParseCntr++; 
02EEA:  MOV     3932,W0
02EEC:  INC     W0,W0
02EEE:  MOV     W0,3932
02EF0:  GOTO    2EC6
.................... } 
.................... //Null Terminate The String After parsing 
.................... pageRequestBuff[pageParseCntr]='\0'; 
02EF4:  MOV     3932,W0
02EF6:  MOV     3930,W4
02EF8:  ADD     W0,W4,W5
02EFA:  CLR.B   [W5]
.................... 	#if SERVERLCD 
.................... 	VacDisplayClear(); 
.................... 	Display_XYString(0,1,pageRequestBuff); 
.................... 	#endif 
.................... } 
02EFC:  MOV     [--W15],W5
02EFE:  RETURN  
....................  
.................... } 
....................  
.................... void sendTestPage(void) 
.................... { 
.................... fprintf(WIFI,"HTTP/1.1 200 OK\nContent-Type: text/html\n\n<!DOCTYPE HTML>\n<html>\nHello World!\n<br />This Is The Root Page\n<br />\n</html>\r\n"); 
.................... } 
....................  
.................... void sendTestPage2(char requestedPage[]) 
.................... { 
.................... fprintf(WIFI,"HTTP/1.1 200 OK\nContent-Type: text/html\n\n<!DOCTYPE HTML>\n<html>\nYou Requested Page: \n%s\n<br />\n</html>\r\n",requestedPage); 
.................... } 
....................  
.................... void send404Page(requestedPage[]) 
.................... { 
.................... fprintf(WIFI,"HTTP/1.1 404 Not Found\nContent-Type: text/html\n\n<!DOCTYPE HTML>\n<html>\nThe Requested Page: OSMOBOTIP:PORT%s Does Not Exist, Sorry.\n<br />\n</html>\r\n",requestedPage); 
*
039FC:  MOV     #0,W1
039FE:  MOV     W1,W0
03A00:  CLR.B   1
03A02:  CALL    3AA
03A06:  INC     W1,W1
03A08:  BTSC.B  253.1
03A0A:  BRA     3A08
03A0C:  MOV     W0,254
03A0E:  MOV     #68,W0
03A10:  CPSGT   W1,W0
03A12:  BRA     39FE
03A14:  MOV     39B2,W1
03A16:  CP0.B   [W1]
03A18:  BRA     Z,3A28
03A1A:  BTSC.B  253.1
03A1C:  BRA     3A1A
03A1E:  MOV.B   [W1+#0],W0L
03A20:  MOV.B   W0L,254
03A22:  CLR.B   255
03A24:  INC     W1,W1
03A26:  BRA     3A16
03A28:  MOV     #6B,W1
03A2A:  MOV     W1,W0
03A2C:  CLR.B   1
03A2E:  CALL    3AA
03A32:  INC     W1,W1
03A34:  BTSC.B  253.1
03A36:  BRA     3A34
03A38:  MOV     W0,254
03A3A:  MOV     #92,W0
03A3C:  CPSGT   W1,W0
03A3E:  BRA     3A2A
03A40:  RETURN  
.................... } 
....................  
....................  
....................  
.................... void sendHTTPPage(char pageString[]) 
.................... { 
.................... fprintf(WIFI,"HTTP/1.1 200 OK\nContent-Type: text/html\r\n\r\n%s\r\n\r\n",pageString); 
.................... delay_ms(1000); 
.................... } 
....................  
....................  
.................... void genTestPage(char outString[]) 
*
03490:  MOV     W5,[W15++]
.................... //void genWifiConfigPage(char outString[]) 
.................... { 
.................... //OLD PAGE NO AUTHENTICATION SELECT 
.................... /* 
.................... sprintf(outString,"\ 
.................... <html>\ 
.................... <body>\ 
.................... <form action=\"router_submit.html\" method=\"get\">\ 
....................   Router name: <input type=\"text\" name=\"SSID\"><br>\ 
....................   Router Password: <input type=\"text\" name=\"PASS\"><br>\ 
....................   Auth: <input type=\"text\" name=\"AUTH\"><br>\ 
....................   Enc: <input type=\"text\" name=\"ENCRYPT\"><br>\ 
....................   <input type=\"submit\" value=\"Submit\">\ 
.................... </form>\ 
.................... </body>\ 
.................... </html>\ 
.................... \r\n"); 
.................... */ 
.................... outstring[0]='\0'; 
03492:  MOV     39B2,W0
03494:  MOV     #0,W4
03496:  ADD     W4,W0,W5
03498:  CLR.B   [W5]
.................... //NEW PAGE Basoc 
.................... fprintf(WIFI,"HTTP/1.1 200 OK\nContent-Type: text/html\r\n\r\n"); 
0349A:  MOV     #0,W1
0349C:  MOV     W1,W0
0349E:  CLR.B   1
034A0:  CALL    42A
034A4:  INC     W1,W1
034A6:  BTSC.B  253.1
034A8:  BRA     34A6
034AA:  MOV     W0,254
034AC:  MOV     #2A,W0
034AE:  CPSGT   W1,W0
034B0:  BRA     349C
.................... fprintf(WIFI,"<html><body><form action=\"router_submit.html\" method=\"get\">Router name: <input type=\"text\" name=\"SSID\"><br>Router Password: <input type=\"text\" name=\"PASS\"><br>"); 
034B2:  MOV     #0,W1
034B4:  MOV     W1,W0
034B6:  CLR.B   1
034B8:  CALL    464
034BC:  INC     W1,W1
034BE:  BTSC.B  253.1
034C0:  BRA     34BE
034C2:  MOV     W0,254
034C4:  MOV     #9E,W0
034C6:  CPSGT   W1,W0
034C8:  BRA     34B4
.................... fprintf(WIFI,"Auth: <select  name=\"AUTH\"><option value=\"OPEN\">OPEN</option><option value=\"SHARED\">SHARED</option><option value=\"WPAPSK\">WPAPSK</option><option value=\"WPA2PSK\" selected=\"selected\">WPA2PSK</option></select>"); 
034CA:  MOV     #0,W1
034CC:  MOV     W1,W0
034CE:  CLR.B   1
034D0:  CALL    4EC
034D4:  INC     W1,W1
034D6:  BTSC.B  253.1
034D8:  BRA     34D6
034DA:  MOV     W0,254
034DC:  MOV     #CD,W0
034DE:  CPSGT   W1,W0
034E0:  BRA     34CC
.................... fprintf(WIFI,"</br>Enc: <select  name=\"ENCRYPT\"><option value=\"NONE\">NONE</option><option value=\"WEP\">WEP</option><option value=\"TKIP\">TKIP</option><option value=\"AES\" checked=\"checked\""); 
034E2:  MOV     #0,W1
034E4:  MOV     W1,W0
034E6:  CLR.B   1
034E8:  CALL    592
034EC:  INC     W1,W1
034EE:  BTSC.B  253.1
034F0:  BRA     34EE
034F2:  MOV     W0,254
034F4:  MOV     #AA,W0
034F6:  CPSGT   W1,W0
034F8:  BRA     34E4
.................... fprintf(WIFI,"selected=\"selected\">AES</option></select></br><input type=\"submit\" value=\"Submit\"></form></body></html>\r\n\r\n"); 
034FA:  MOV     #0,W1
034FC:  MOV     W1,W0
034FE:  CLR.B   1
03500:  CALL    622
03504:  INC     W1,W1
03506:  BTSC.B  253.1
03508:  BRA     3506
0350A:  MOV     W0,254
0350C:  MOV     #6A,W0
0350E:  CPSGT   W1,W0
03510:  BRA     34FC
.................... delay_ms(1000); 
03512:  MOV     #3E8,W0
03514:  CALL    21F2
03518:  MOV     [--W15],W5
0351A:  RETURN  
.................... } 
....................  
.................... //void genTestPage(char outString[]) 
.................... void genWifiConfigPage(char outString[]) 
*
030A6:  MOV     W5,[W15++]
030A8:  MOV     #C,W5
030AA:  REPEAT  #4
030AC:  MOV     [W5++],[W15++]
.................... { 
.................... /* //Original Test Page 
.................... sprintf(outString,"<!DOCTYPE HTML>\n<html>\nHello World!\n<br />This Is The Test Page\n<br />\n</html>"); 
.................... */ 
.................... fprintf(WIFI,"HTTP/1.1 200 OK\nContent-Type: text/html\r\n\r\n"); 
030AE:  MOV     #0,W1
030B0:  MOV     W1,W0
030B2:  CLR.B   1
030B4:  CALL    42A
030B8:  INC     W1,W1
030BA:  BTSC.B  253.1
030BC:  BRA     30BA
030BE:  MOV     W0,254
030C0:  MOV     #2A,W0
030C2:  CPSGT   W1,W0
030C4:  BRA     30B0
....................  
.................... fprintf(WIFI,"<!DOCTYPE html><html><script>\n function handleRBClick(){checkval=document.querySelector('input[name = \"SSIDr\"]:checked').value; checksec=document.querySelector('input[name = \"SSIDr\"]:checked').title;"); 
030C6:  MOV     #0,W1
030C8:  MOV     W1,W0
030CA:  CLR.B   1
030CC:  CALL    686
030D0:  INC     W1,W1
030D2:  BTSC.B  253.1
030D4:  BRA     30D2
030D6:  MOV     W0,254
030D8:  MOV     #C6,W0
030DA:  CPSGT   W1,W0
030DC:  BRA     30C8
.................... fprintf(WIFI,"if(checkval==\"~!$Other\"){visVar=\"visible\";} else{visVar=\"hidden\"; document.getElementById(\"SSIDtb\").value=\"\";} document.getElementById(\"SSIDtb\").style.visibility=visVar;"); 
030DE:  MOV     #0,W1
030E0:  MOV     W1,W0
030E2:  CLR.B   1
030E4:  CALL    728
030E8:  INC     W1,W1
030EA:  BTSC.B  253.1
030EC:  BRA     30EA
030EE:  MOV     W0,254
030F0:  MOV     #A8,W0
030F2:  CPSGT   W1,W0
030F4:  BRA     30E0
.................... fprintf(WIFI,"document.getElementById(\"customProperties\").style.visibility=visVar;\nif(checksec.indexOf(\"NONE\")>-1) {document.getElementById(\"pwdiv\").style.visibility=\"hidden\"; document.getElementById('PASStb').value=\"\";}\n"); 
030F6:  MOV     #0,W1
030F8:  MOV     W1,W0
030FA:  CLR.B   1
030FC:  CALL    7B6
03100:  INC     W1,W1
03102:  BTSC.B  253.1
03104:  BRA     3102
03106:  MOV     W0,254
03108:  MOV     #CE,W0
0310A:  CPSGT   W1,W0
0310C:  BRA     30F8
.................... fprintf(WIFI,"else{document.getElementById(\"pwdiv\").style.visibility=\"visible\";}}function submitForm() {var ssidval = document.querySelector('input[name = \"SSIDr\"]:checked').value;"); 
0310E:  MOV     #0,W1
03110:  MOV     W1,W0
03112:  CLR.B   1
03114:  CALL    85E
03118:  INC     W1,W1
0311A:  BTSC.B  253.1
0311C:  BRA     311A
0311E:  MOV     W0,254
03120:  MOV     #A5,W0
03122:  CPSGT   W1,W0
03124:  BRA     3110
.................... fprintf(WIFI,"var encrypStr = document.querySelector('input[name = \"SSIDr\"]:checked').title; if(ssidval==\"~!$Other\"){document.getElementById('SSIDh').value=document.getElementById('SSIDtb').value;"); 
03126:  MOV     #0,W1
03128:  MOV     W1,W0
0312A:  CLR.B   1
0312C:  CALL    8EA
03130:  INC     W1,W1
03132:  BTSC.B  253.1
03134:  BRA     3132
03136:  MOV     W0,254
03138:  MOV     #B5,W0
0313A:  CPSGT   W1,W0
0313C:  BRA     3128
.................... fprintf(WIFI,"document.getElementById('AUTHh').value=document.getElementById('AUTHDM').value; document.getElementById('ENCRYPTh').value=document.getElementById('ENCRYPTDM').value;}\n"); 
0313E:  MOV     #0,W1
03140:  MOV     W1,W0
03142:  CLR.B   1
03144:  CALL    980
03148:  INC     W1,W1
0314A:  BTSC.B  253.1
0314C:  BRA     314A
0314E:  MOV     W0,254
03150:  MOV     #A6,W0
03152:  CPSGT   W1,W0
03154:  BRA     3140
.................... fprintf(WIFI,"else{document.getElementById('SSIDh').value=ssidval;\nif(encrypStr.indexOf(\"WPA2\")>-1){document.getElementById('AUTHh').value=\"WPA2PSK\";}\n"); 
03156:  MOV     #0,W1
03158:  MOV     W1,W0
0315A:  CLR.B   1
0315C:  CALL    A0C
03160:  INC     W1,W1
03162:  BTSC.B  253.1
03164:  BRA     3162
03166:  MOV     W0,254
03168:  MOV     #88,W0
0316A:  CPSGT   W1,W0
0316C:  BRA     3158
.................... fprintf(WIFI,"else if(encrypStr.indexOf(\"SHARED\")>-1){document.getElementById('AUTHh').value=\"SHARED\";}\nelse{document.getElementById('AUTHh').value=\"OPEN\";}\n");   
0316E:  MOV     #0,W1
03170:  MOV     W1,W0
03172:  CLR.B   1
03174:  CALL    A84
03178:  INC     W1,W1
0317A:  BTSC.B  253.1
0317C:  BRA     317A
0317E:  MOV     W0,254
03180:  MOV     #8E,W0
03182:  CPSGT   W1,W0
03184:  BRA     3170
.................... fprintf(WIFI,"if(encrypStr.indexOf(\"AES\")>-1){document.getElementById('ENCRYPTh').value=\"AES\";}\nelse if(encrypStr.indexOf(\"TPIK\")>-1){document.getElementById('ENCRYPTh').value=\"TPIK\";}\n");    
03186:  MOV     #0,W1
03188:  MOV     W1,W0
0318A:  CLR.B   1
0318C:  CALL    B00
03190:  INC     W1,W1
03192:  BTSC.B  253.1
03194:  BRA     3192
03196:  MOV     W0,254
03198:  MOV     #AA,W0
0319A:  CPSGT   W1,W0
0319C:  BRA     3188
.................... fprintf(WIFI,"else if(encrypStr.indexOf(\"WEP\")>-1){document.getElementById('ENCRYPTh').value=\"WEP\";}\nelse{document.getElementById('ENCRYPTh').value=\"NONE\";}\n}"); 
0319E:  MOV     #0,W1
031A0:  MOV     W1,W0
031A2:  CLR.B   1
031A4:  CALL    B90
031A8:  INC     W1,W1
031AA:  BTSC.B  253.1
031AC:  BRA     31AA
031AE:  MOV     W0,254
031B0:  MOV     #8F,W0
031B2:  CPSGT   W1,W0
031B4:  BRA     31A0
.................... fprintf(WIFI,"document.getElementById('PASSh').value=document.getElementById('PASStb').value; document.getElementById('Rsmt').submit();}</script>");        
031B6:  MOV     #0,W1
031B8:  MOV     W1,W0
031BA:  CLR.B   1
031BC:  CALL    C0E
031C0:  INC     W1,W1
031C2:  BTSC.B  253.1
031C4:  BRA     31C2
031C6:  MOV     W0,254
031C8:  MOV     #82,W0
031CA:  CPSGT   W1,W0
031CC:  BRA     31B8
.................... fprintf(WIFI,"<body><table WIDTH=\"80%%\"><form name=\"Router List\"><tr bgcolor=\"#e8e8e8\"><TD WIDTH=\"110\" class=\"main\">&nbsp;&nbsp;&nbsp;Select Router:</TD><TD class=\"main\" valign=\"top\">"); 
031CE:  MOV     #0,W1
031D0:  MOV     W1,W0
031D2:  CLR.B   1
031D4:  CALL    C82
031D8:  INC     W1,W1
031DA:  BTSC.B  253.1
031DC:  BRA     31DA
031DE:  MOV     W0,254
031E0:  MOV     #15,W0
031E2:  CPSGT   W1,W0
031E4:  BRA     31D0
031E6:  BTSC.B  253.1
031E8:  BRA     31E6
031EA:  MOV     #25,W4
031EC:  MOV     W4,254
031EE:  MOV     #18,W1
031F0:  MOV     W1,W0
031F2:  CLR.B   1
031F4:  CALL    C82
031F8:  INC     W1,W1
031FA:  BTSC.B  253.1
031FC:  BRA     31FA
031FE:  MOV     W0,254
03200:  MOV     #A8,W0
03202:  CPSGT   W1,W0
03204:  BRA     31F0
.................... fprintf(WIFI,"<div id=\"SSIDrb\" onclick=\"handleRBClick()\">\n\n"); 
03206:  MOV     #0,W1
03208:  MOV     W1,W0
0320A:  CLR.B   1
0320C:  CALL    D10
03210:  INC     W1,W1
03212:  BTSC.B  253.1
03214:  BRA     3212
03216:  MOV     W0,254
03218:  MOV     #2C,W0
0321A:  CPSGT   W1,W0
0321C:  BRA     3208
.................... //Router Table Custom Text  
.................... int rctr=0; 
.................... int ractr=1; 
0321E:  MOV     #0,W4
03220:  MOV     W4,39B4
03222:  MOV     #1,W4
03224:  MOV     W4,39B6
.................... while(rctr<MAXNUMROUTERS) 
03226:  MOV     39B4,W0
03228:  CP      W0,#A
0322A:  BRA     GE,33A0
.................... { 
.................... 	if(routerTable[rctr].sigStr>-1) 
0322C:  MOV     39B4,W0
0322E:  MOV     #3A,W4
03230:  MUL.SS  W0,W4,W0
03232:  MOV     W0,W5
03234:  MOV     #38,W4
03236:  ADD     W5,W4,W0
03238:  MOV     #2154,W4
0323A:  ADD     W0,W4,W0
0323C:  MOV     [W0],W5
0323E:  MOV     #FFFF,W4
03240:  CP      W4,W5
03242:  BRA     GE,3396
.................... 	{ 
.................... 	if(strstr(routerTable[rctr].SSID,"SSID")==NULL) 
03244:  MOV     39B4,W0
03246:  MOV     #3A,W4
03248:  MUL.SS  W0,W4,W0
0324A:  MOV     W0,W5
0324C:  MOV     #2154,W4
0324E:  ADD     W5,W4,W6
03250:  MOV     #5,W3
03252:  MOV     #0,W2
03254:  MOV     #39B8,W1
03256:  MOV     W3,[W15++]
03258:  MOV     W2,W0
0325A:  CALL    D4C
0325E:  MOV     [--W15],W3
03260:  MOV.B   W0L,[W1++]
03262:  INC     W2,W2
03264:  DEC     W3,W3
03266:  BTSS.B  42.1
03268:  BRA     3256
0326A:  MOV     W6,39C6
0326C:  MOV     #39B8,W4
0326E:  MOV     W4,39C8
03270:  CALL    2F60
03274:  MOV     W0,W6
03276:  CP0     W6
03278:  BRA     NZ,3396
.................... 		{ 
.................... 		fprintf(WIFI,"<input name=\"SSIDr\" id=\"SSIDrb%d\" type=\"radio\" value=\"%s\" title=\"%s\"> %s (%d%%)<br />\n",ractr,routerTable[rctr].SSID,routerTable[rctr].secTYPE,routerTable[rctr].SSID,routerTable[rctr].sigStr); 
0327A:  MOV     39B4,W0
0327C:  MOV     #3A,W4
0327E:  MUL.SS  W0,W4,W0
03280:  MOV     W0,W5
03282:  MOV     #2154,W4
03284:  ADD     W5,W4,W6
03286:  MOV     39B4,W0
03288:  MOV     #3A,W4
0328A:  MUL.SS  W0,W4,W0
0328C:  MOV     W0,W7
0328E:  MOV     #20,W4
03290:  ADD     W7,W4,W0
03292:  MOV     #2154,W4
03294:  ADD     W0,W4,W7
03296:  MOV     39B4,W0
03298:  MOV     #3A,W4
0329A:  MUL.SS  W0,W4,W0
0329C:  MOV     W0,W8
0329E:  MOV     #2154,W4
032A0:  ADD     W8,W4,W9
032A2:  MOV     39B4,W0
032A4:  MOV     #3A,W4
032A6:  MUL.SS  W0,W4,W0
032A8:  MOV     W0,W10
032AA:  MOV     #38,W4
032AC:  ADD     W10,W4,W0
032AE:  MOV     #2154,W4
032B0:  ADD     W0,W4,W0
032B2:  MOV     [W0],W10
032B4:  MOV     #0,W1
032B6:  MOV     W1,W0
032B8:  CLR.B   1
032BA:  CALL    D5E
032BE:  INC     W1,W1
032C0:  BTSC.B  253.1
032C2:  BRA     32C0
032C4:  MOV     W0,254
032C6:  MOV     #1D,W0
032C8:  CPSGT   W1,W0
032CA:  BRA     32B6
032CC:  MOV     39B6,W0
032CE:  MOV     #0,W4
032D0:  CALL    2FB0
032D4:  MOV     #20,W1
032D6:  MOV     W1,W0
032D8:  CLR.B   1
032DA:  CALL    D5E
032DE:  INC     W1,W1
032E0:  BTSC.B  253.1
032E2:  BRA     32E0
032E4:  MOV     W0,254
032E6:  MOV     #35,W0
032E8:  CPSGT   W1,W0
032EA:  BRA     32D6
032EC:  MOV     W6,W1
032EE:  CP0.B   [W1]
032F0:  BRA     Z,3300
032F2:  BTSC.B  253.1
032F4:  BRA     32F2
032F6:  MOV.B   [W1+#0],W0L
032F8:  MOV.B   W0L,254
032FA:  CLR.B   255
032FC:  INC     W1,W1
032FE:  BRA     32EE
03300:  MOV     #38,W1
03302:  MOV     W1,W0
03304:  CLR.B   1
03306:  CALL    D5E
0330A:  INC     W1,W1
0330C:  BTSC.B  253.1
0330E:  BRA     330C
03310:  MOV     W0,254
03312:  MOV     #40,W0
03314:  CPSGT   W1,W0
03316:  BRA     3302
03318:  MOV     W7,W1
0331A:  CP0.B   [W1]
0331C:  BRA     Z,332C
0331E:  BTSC.B  253.1
03320:  BRA     331E
03322:  MOV.B   [W1+#0],W0L
03324:  MOV.B   W0L,254
03326:  CLR.B   255
03328:  INC     W1,W1
0332A:  BRA     331A
0332C:  BTSC.B  253.1
0332E:  BRA     332C
03330:  MOV     #22,W4
03332:  MOV     W4,254
03334:  BTSC.B  253.1
03336:  BRA     3334
03338:  MOV     #3E,W4
0333A:  MOV     W4,254
0333C:  BTSC.B  253.1
0333E:  BRA     333C
03340:  MOV     #20,W4
03342:  MOV     W4,254
03344:  MOV     W9,W1
03346:  CP0.B   [W1]
03348:  BRA     Z,3358
0334A:  BTSC.B  253.1
0334C:  BRA     334A
0334E:  MOV.B   [W1+#0],W0L
03350:  MOV.B   W0L,254
03352:  CLR.B   255
03354:  INC     W1,W1
03356:  BRA     3346
03358:  BTSC.B  253.1
0335A:  BRA     3358
0335C:  MOV     #20,W4
0335E:  MOV     W4,254
03360:  BTSC.B  253.1
03362:  BRA     3360
03364:  MOV     #28,W4
03366:  MOV     W4,254
03368:  MOV     W10,W0
0336A:  MOV     #0,W4
0336C:  CALL    2FB0
03370:  BTSC.B  253.1
03372:  BRA     3370
03374:  MOV     #25,W4
03376:  MOV     W4,254
03378:  MOV     #4E,W1
0337A:  MOV     W1,W0
0337C:  CLR.B   1
0337E:  CALL    D5E
03382:  INC     W1,W1
03384:  BTSC.B  253.1
03386:  BRA     3384
03388:  MOV     W0,254
0338A:  MOV     #55,W0
0338C:  CPSGT   W1,W0
0338E:  BRA     337A
.................... 		ractr++; 
03390:  MOV     39B6,W0
03392:  INC     W0,W0
03394:  MOV     W0,39B6
.................... 		} 
.................... 	} 
.................... rctr++; 
03396:  MOV     39B4,W0
03398:  INC     W0,W0
0339A:  MOV     W0,39B4
0339C:  GOTO    3226
.................... } 
.................... fprintf(WIFI,"<input name=\"SSIDr\" id=\"SSIDrb%d\" type=\"radio\" value=\"~!$Other\" title=\"Other\" checked=\"checked\">\n\n",ractr); 
033A0:  MOV     #0,W1
033A2:  MOV     W1,W0
033A4:  CLR.B   1
033A6:  CALL    DB4
033AA:  INC     W1,W1
033AC:  BTSC.B  253.1
033AE:  BRA     33AC
033B0:  MOV     W0,254
033B2:  MOV     #1D,W0
033B4:  CPSGT   W1,W0
033B6:  BRA     33A2
033B8:  MOV     39B6,W0
033BA:  MOV     #0,W4
033BC:  CALL    2FB0
033C0:  MOV     #20,W1
033C2:  MOV     W1,W0
033C4:  CLR.B   1
033C6:  CALL    DB4
033CA:  INC     W1,W1
033CC:  BTSC.B  253.1
033CE:  BRA     33CC
033D0:  MOV     W0,254
033D2:  MOV     #61,W0
033D4:  CPSGT   W1,W0
033D6:  BRA     33C2
....................  
.................... /* 
.................... fprintf(WIFI,"<input name=\"SSIDr\" id=\"SSIDrb1\" type=\"radio\" value=\"NETGEAR31\" title=\"WPA2/AES\"> NETGEAR31<br />\n"); 
.................... fprintf(WIFI,"<input name=\"SSIDr\" id=\"SSIDrb2\" type=\"radio\" value=\"Test1\" title=\"NONE/NONE\"> Test1<br />\n"); 
.................... fprintf(WIFI,"<input name=\"SSIDr\" id=\"SSIDrb3\" type=\"radio\" value=\"Test2\" title=\"NONE/NONE\"> Test2<br />\n"); 
.................... fprintf(WIFI,"<input name=\"SSIDr\" id=\"SSIDrb4\" type=\"radio\" value=\"Test3\" title=\"WPA1PSKWPA2PSK/TKIPAES\"> MyRouter<br />\n"); 
.................... fprintf(WIFI,"<input name=\"SSIDr\" id=\"SSIDrb5\" type=\"radio\" value=\"~!$Other\" title=\"Other\" checked=\"checked\">\n\n"); 
.................... */ 
.................... //Back To Stock Text 
.................... fprintf(WIFI,"Other: <input type=\"text\" name=\"SSIDrt\" id=\"SSIDtb\" width=\"250\" value=\"\" /><br /></div></TD></tr><tr bgcolor=\"#e8e8e8\"><td TD WIDTH=\"110\" class=\"main\">\n"); 
033D8:  MOV     #0,W1
033DA:  MOV     W1,W0
033DC:  CLR.B   1
033DE:  CALL    E12
033E2:  INC     W1,W1
033E4:  BTSC.B  253.1
033E6:  BRA     33E4
033E8:  MOV     W0,254
033EA:  MOV     #97,W0
033EC:  CPSGT   W1,W0
033EE:  BRA     33DA
.................... fprintf(WIFI,"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Security:</td><TD><div id=\"pwdiv\">Password: <input type=\"text\" name=\"PASS\" id=\"PASStb\" value=\"\" width=\"250\" /><br /></div><div id=\"customProperties\">\n"); 
033F0:  MOV     #0,W1
033F2:  MOV     W1,W0
033F4:  CLR.B   1
033F6:  CALL    E94
033FA:  INC     W1,W1
033FC:  BTSC.B  253.1
033FE:  BRA     33FC
03400:  MOV     W0,254
03402:  MOV     #BF,W0
03404:  CPSGT   W1,W0
03406:  BRA     33F2
.................... fprintf(WIFI,"Auth: <select id=\"AUTHDM\"><option value=\"OPEN\">OPEN</option><option value=\"SHARED\">SHARED</option><option value=\"WPA2PSK\" selected=\"selected\">WPA2PSK</option></select>\n");  
03408:  MOV     #0,W1
0340A:  MOV     W1,W0
0340C:  CLR.B   1
0340E:  CALL    F32
03412:  INC     W1,W1
03414:  BTSC.B  253.1
03416:  BRA     3414
03418:  MOV     W0,254
0341A:  MOV     #A7,W0
0341C:  CPSGT   W1,W0
0341E:  BRA     340A
....................  
.................... //Potentially a trouble line 
.................... fprintf(WIFI,"Enc: <select id=\"ENCRYPTDM\"><option value=\"NONE\">NONE</option><option value=\"WEP\">WEP</option><option value=\"TKIP\">TKIP</option><option value=\"AES\" checked=\"checked\" selected=\"selected\">AES</option></select>");      
03420:  MOV     #0,W1
03422:  MOV     W1,W0
03424:  CLR.B   1
03426:  CALL    FC0
0342A:  INC     W1,W1
0342C:  BTSC.B  253.1
0342E:  BRA     342C
03430:  MOV     W0,254
03432:  MOV     #CE,W0
03434:  CPSGT   W1,W0
03436:  BRA     3422
.................... //         
.................... fprintf(WIFI,"\n</div></TD></tr></form></table><table></table><form name=\"Router Submit\" id=\"Rsmt\" action=\"router_submit.html\"  method=\"get\" onsubmit=\"return submitForm();\">\n"); 
03438:  MOV     #0,W1
0343A:  MOV     W1,W0
0343C:  CLR.B   1
0343E:  CALL    1068
03442:  INC     W1,W1
03444:  BTSC.B  253.1
03446:  BRA     3444
03448:  MOV     W0,254
0344A:  MOV     #9E,W0
0344C:  CPSGT   W1,W0
0344E:  BRA     343A
.................... fprintf(WIFI,"<input type=\"hidden\" name=\"SSID\" id=\"SSIDh\" value=\"\" ><input type=\"hidden\" name=\"PASS\" id=\"PASSh\" value=\"\"><input type=\"hidden\" name=\"AUTH\" id=\"AUTHh\" value=\"\">\n"); 
03450:  MOV     #0,W1
03452:  MOV     W1,W0
03454:  CLR.B   1
03456:  CALL    10F0
0345A:  INC     W1,W1
0345C:  BTSC.B  253.1
0345E:  BRA     345C
03460:  MOV     W0,254
03462:  MOV     #A0,W0
03464:  CPSGT   W1,W0
03466:  BRA     3452
.................... fprintf(WIFI,"<input type=\"hidden\" name=\"ENCRYPT\" id=\"ENCRYPTh\" value=\"\"><input type=\"submit\" value=\"Submit\"></form>\n</body></html>\r\n\r\n"); 
03468:  MOV     #0,W1
0346A:  MOV     W1,W0
0346C:  CLR.B   1
0346E:  CALL    1178
03472:  INC     W1,W1
03474:  BTSC.B  253.1
03476:  BRA     3474
03478:  MOV     W0,254
0347A:  MOV     #78,W0
0347C:  CPSGT   W1,W0
0347E:  BRA     346A
.................... delay_ms(1000); 
03480:  MOV     #3E8,W0
03482:  CALL    21F2
03486:  MOV     #14,W5
03488:  REPEAT  #4
0348A:  MOV     [--W15],[W5--]
0348C:  MOV     [--W15],W5
0348E:  RETURN  
....................  
.................... //Test of the big router page 
....................  
.................... } 
....................  
.................... void genSubmittedPage(char outString[], char SSID[], char PASSSTR[]) 
.................... { 
.................... sprintf(outString,"<!DOCTYPE HTML>\n<html>\nThank You!\n<br />Router Info Submitted\n<br />SSID:%s\n<br />Password:%s\n</html>",SSID,PASSSTR); 
.................... } 
....................  
.................... void sendSubmittedPage(char SSID[], char PASSSTR[]) 
.................... { 
.................... fprintf(WIFI,"HTTP/1.1 200 OK\nContent-Type: text/html\r\n\r\n"); 
.................... fprintf(WIFI,"<!DOCTYPE HTML>\n<html>\nThank You!\n<br />Router Info Submitted\n<br />SSID:%s\n<br />Password:%s\n</html>",SSID,PASSSTR); 
.................... } 
....................  
....................  
.................... void simpleSubmittedPage() 
.................... { 
.................... fprintf(WIFI,"HTTP/1.1 200 OK\nContent-Type: text/html\r\n\r\n"); 
*
0351C:  MOV     #0,W1
0351E:  MOV     W1,W0
03520:  CLR.B   1
03522:  CALL    42A
03526:  INC     W1,W1
03528:  BTSC.B  253.1
0352A:  BRA     3528
0352C:  MOV     W0,254
0352E:  MOV     #2A,W0
03530:  CPSGT   W1,W0
03532:  BRA     351E
.................... fprintf(WIFI,"<!DOCTYPE HTML>\n<html>\nThank You!\n<br />Router Info Submitted\n</html>\r\n\r\n"); 
03534:  MOV     #0,W1
03536:  MOV     W1,W0
03538:  CLR.B   1
0353A:  CALL    11E6
0353E:  INC     W1,W1
03540:  BTSC.B  253.1
03542:  BRA     3540
03544:  MOV     W0,254
03546:  MOV     #48,W0
03548:  CPSGT   W1,W0
0354A:  BRA     3536
0354C:  RETURN  
.................... } 
....................  
.................... void genHostPage(char outString[]) 
*
03D4C:  MOV     W5,[W15++]
.................... { 
.................... /*	//Old Home Page 
.................... sprintf(outString,"<!DOCTYPE HTML>\n\ 
.................... <html>\ 
.................... <br />\ 
.................... Osmobot is:<img src='http://www.example.com/singlepixel.gif' alt=\"Not Connected To The Internet\" />\ 
.................... <br />\ 
.................... <a href=\"wifiConfig.html\">Wifi Config</a>\ 
.................... <br /> 
.................... <a href=\"test.html\">Test Page</a>\ 
.................... <br />\n\ 
.................... </html>"); 
....................  
.................... */ 
....................  
.................... //New Home Page with Internet Link Indicator 
.................... outString[0]='\0'; 
03D4E:  MOV     392E,W0
03D50:  MOV     #0,W4
03D52:  ADD     W4,W0,W5
03D54:  CLR.B   [W5]
.................... fprintf(WIFI,"HTTP/1.1 200 OK\nContent-Type: text/html\r\n\r\n"); 
03D56:  MOV     #0,W1
03D58:  MOV     W1,W0
03D5A:  CLR.B   1
03D5C:  CALL    42A
03D60:  INC     W1,W1
03D62:  BTSC.B  253.1
03D64:  BRA     3D62
03D66:  MOV     W0,254
03D68:  MOV     #2A,W0
03D6A:  CPSGT   W1,W0
03D6C:  BRA     3D58
.................... fprintf(WIFI,"<!DOCTYPE HTML>\n<html>\n<script>function checkCxn(connected){c=document.getElementById('CXN');\nif(connected){c.innerHTML+='connected to the internet.';}\n"); 
03D6E:  MOV     #0,W1
03D70:  MOV     W1,W0
03D72:  CLR.B   1
03D74:  CALL    1234
03D78:  INC     W1,W1
03D7A:  BTSC.B  253.1
03D7C:  BRA     3D7A
03D7E:  MOV     W0,254
03D80:  MOV     #97,W0
03D82:  CPSGT   W1,W0
03D84:  BRA     3D70
.................... fprintf(WIFI,"else{c.innerHTML+='not connected to the internet.';}}</script><div id=\"CXN\">Osmobot is </div><br />Links:<br />"); 
03D86:  MOV     #0,W1
03D88:  MOV     W1,W0
03D8A:  CLR.B   1
03D8C:  CALL    12B6
03D90:  INC     W1,W1
03D92:  BTSC.B  253.1
03D94:  BRA     3D92
03D96:  MOV     W0,254
03D98:  MOV     #6E,W0
03D9A:  CPSGT   W1,W0
03D9C:  BRA     3D88
.................... fprintf(WIFI,"<img src='http://osmobot.org/singlepixel.gif' style=\"display:none\" onload=\"checkCxn(1)\" onerror=\"checkCxn(0)\" />"); 
03D9E:  MOV     #0,W1
03DA0:  MOV     W1,W0
03DA2:  CLR.B   1
03DA4:  CALL    131E
03DA8:  INC     W1,W1
03DAA:  BTSC.B  253.1
03DAC:  BRA     3DAA
03DAE:  MOV     W0,254
03DB0:  MOV     #6F,W0
03DB2:  CPSGT   W1,W0
03DB4:  BRA     3DA0
.................... fprintf(WIFI,"<a href=\"wifiConfig.html\">Wifi Config</a><br/><a href=\"test.html\">Test Page</a><br/></html>"); 
03DB6:  MOV     #0,W1
03DB8:  MOV     W1,W0
03DBA:  CLR.B   1
03DBC:  CALL    1386
03DC0:  INC     W1,W1
03DC2:  BTSC.B  253.1
03DC4:  BRA     3DC2
03DC6:  MOV     W0,254
03DC8:  MOV     #5A,W0
03DCA:  CPSGT   W1,W0
03DCC:  BRA     3DB8
.................... delay_ms(1000); 
03DCE:  MOV     #3E8,W0
03DD0:  CALL    21F2
03DD4:  MOV     [--W15],W5
03DD6:  RETURN  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... ////PUT THIS AFTER ALL THE WEBPAGE FUCTIONS 
....................  
.................... //Takes Variable string out of URL 
.................... void stripArgs(char url[], char argStr[]) 
.................... { 
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... void copyCredentials(char target[], char source[]) 
.................... { 
.................... char c; 
.................... int8 charcntr=0; 
.................... while((c=source[charcntr])!='&') 
.................... 	{ 
.................... 	target[charcntr]=c; 
.................... 	} 
.................... target[charcntr]='\0'; 
.................... } 
....................  
.................... //Serves The Webpage 
.................... void osmobotServePage(char url[]) 
*
03A42:  MOV     W5,[W15++]
03A44:  MOV     W6,[W15++]
.................... { 
.................... //Add conditionals as webpages are added 
.................... if (strncmp(url,"/wifiConfig.html",16)==0) 
03A46:  MOV     #11,W3
03A48:  MOV     #0,W2
03A4A:  MOV     #3930,W1
03A4C:  MOV     W3,[W15++]
03A4E:  MOV     W2,W0
03A50:  CALL    13E0
03A54:  MOV     [--W15],W3
03A56:  MOV.B   W0L,[W1++]
03A58:  INC     W2,W2
03A5A:  DEC     W3,W3
03A5C:  BTSS.B  42.1
03A5E:  BRA     3A4C
03A60:  PUSH    392E
03A62:  POP     39B2
03A64:  MOV     #3930,W4
03A66:  MOV     W4,39B4
03A68:  MOV     #10,W4
03A6A:  MOV     W4,39B6
03A6C:  CALL    2F00
03A70:  SE      W0,W5
03A72:  CP0     W5
03A74:  BRA     NZ,3A82
.................... 	{ 
.................... 	genWifiConfigPage(WebPageTxtBuff); 
03A76:  MOV     #95E,W4
03A78:  MOV     W4,39B2
03A7A:  CALL    30A6
.................... 	//sendHTTPPage(WebPageTxtBuff); 
.................... 	} 
03A7E:  GOTO    3D46
....................  
.................... else if (strncmp(url,"/test.html",10)==0) 
03A82:  MOV     #B,W3
03A84:  MOV     #0,W2
03A86:  MOV     #3930,W1
03A88:  MOV     W3,[W15++]
03A8A:  MOV     W2,W0
03A8C:  CALL    13FE
03A90:  MOV     [--W15],W3
03A92:  MOV.B   W0L,[W1++]
03A94:  INC     W2,W2
03A96:  DEC     W3,W3
03A98:  BTSS.B  42.1
03A9A:  BRA     3A88
03A9C:  PUSH    392E
03A9E:  POP     39B2
03AA0:  MOV     #3930,W4
03AA2:  MOV     W4,39B4
03AA4:  MOV     #A,W4
03AA6:  MOV     W4,39B6
03AA8:  CALL    2F00
03AAC:  SE      W0,W5
03AAE:  CP0     W5
03AB0:  BRA     NZ,3ABE
.................... 	{ 
.................... 	genTestPage(WebPageTxtBuff); 
03AB2:  MOV     #95E,W4
03AB4:  MOV     W4,39B2
03AB6:  CALL    3490
.................... 	//sendHTTPPage(WebPageTxtBuff); 
.................... 	} 
03ABA:  GOTO    3D46
.................... else if (strncmp(url,"/router_submit.html",19)==0) 
03ABE:  MOV     #14,W3
03AC0:  MOV     #0,W2
03AC2:  MOV     #3930,W1
03AC4:  MOV     W3,[W15++]
03AC6:  MOV     W2,W0
03AC8:  CALL    1416
03ACC:  MOV     [--W15],W3
03ACE:  MOV.B   W0L,[W1++]
03AD0:  INC     W2,W2
03AD2:  DEC     W3,W3
03AD4:  BTSS.B  42.1
03AD6:  BRA     3AC4
03AD8:  PUSH    392E
03ADA:  POP     39B2
03ADC:  MOV     #3930,W4
03ADE:  MOV     W4,39B4
03AE0:  MOV     #13,W4
03AE2:  MOV     W4,39B6
03AE4:  CALL    2F00
03AE8:  SE      W0,W5
03AEA:  CP0     W5
03AEC:  BRA     NZ,3D3E
.................... 	{ 
.................... 	simpleSubmittedPage(); 
03AEE:  CALL    351C
.................... 	delay_ms(1000); 
03AF2:  MOV     #3E8,W0
03AF4:  CALL    21F2
.................... 	char *varStart=strchr(url,'?'); 
.................... 	char fakeSSID[32]; 
.................... 	char fakePASS[64]; 
.................... 	#if SERVERLCD 
03AF8:  MOV     39B4,W0
03AFA:  MOV.B   #3F,W0L
03AFC:  MOV     W0,39B4
03AFE:  PUSH    392E
03B00:  POP     39B2
03B02:  CALL    354E
03B06:  MOV     W0,3944
.................... 		VacDisplayClear(); 
.................... 	#endif 
.................... 	if(varStart!=null)	//Look For those Variables 
03B08:  MOV     3944,W0
03B0A:  CP0     W0
03B0C:  BRA     Z,3D18
.................... 		{ 
.................... 		//simpleSubmittedPage(); 
.................... 		//STA_SSID 
.................... 		//"SSID="\ 
.................... 		char *ssidpntr= strstr(varStart,"SSID=")+5; 
.................... 		char *doneptr= strchr(varStart,'&'); 
.................... 		 
.................... 		//fakeSSID[doneptr-ssidpntr]='\0'; 
....................  
....................  
.................... 		#if SERVERLCD 
03B0E:  MOV     #6,W3
03B10:  MOV     #0,W2
03B12:  MOV     #3930,W1
03B14:  MOV     W3,[W15++]
03B16:  MOV     W2,W0
03B18:  CALL    1436
03B1C:  MOV     [--W15],W3
03B1E:  MOV.B   W0L,[W1++]
03B20:  INC     W2,W2
03B22:  DEC     W3,W3
03B24:  BTSS.B  42.1
03B26:  BRA     3B14
03B28:  PUSH    3944
03B2A:  POP     39C6
03B2C:  MOV     #3930,W4
03B2E:  MOV     W4,39C8
03B30:  CALL    2F60
03B34:  MOV     W0,W5
03B36:  ADD     W5,#5,W5
03B38:  MOV     W5,39A6
03B3A:  MOV     39B4,W0
03B3C:  MOV.B   #26,W0L
03B3E:  MOV     W0,39B4
03B40:  PUSH    3944
03B42:  POP     39B2
03B44:  CALL    354E
03B48:  MOV     W0,39A8
.................... 		Display_XYString(0,1,"SSID"); 
.................... 		#endif 
.................... 		strncpy(STA_SSID,ssidpntr,(doneptr-ssidpntr)); 
03B4A:  MOV     39A8,W0
03B4C:  MOV     39A6,W4
03B4E:  SUB     W0,W4,W5
03B50:  MOV     #1D56,W4
03B52:  MOV     W4,39B6
03B54:  PUSH    39A6
03B56:  POP     39B8
03B58:  MOV     W5,39BA
03B5A:  CALL    3578
.................... 		strncpy(STA_SSID+(doneptr-ssidpntr),"\0",1); 
03B5E:  MOV     39A8,W0
03B60:  MOV     39A6,W4
03B62:  SUB     W0,W4,W0
03B64:  MOV     #1D56,W4
03B66:  ADD     W0,W4,W5
03B68:  MOV     #1,W3
03B6A:  MOV     #0,W2
03B6C:  MOV     #3930,W1
03B6E:  MOV     W3,[W15++]
03B70:  MOV     W2,W0
03B72:  CALL    1448
03B76:  MOV     [--W15],W3
03B78:  MOV.B   W0L,[W1++]
03B7A:  INC     W2,W2
03B7C:  DEC     W3,W3
03B7E:  BTSS.B  42.1
03B80:  BRA     3B6E
03B82:  MOV     W5,39B6
03B84:  MOV     #3930,W4
03B86:  MOV     W4,39B8
03B88:  MOV     #1,W4
03B8A:  MOV     W4,39BA
03B8C:  CALL    3578
....................  
.................... 		//copyCredentials(STA_SSID,fakeSSID,); 
.................... 		//STA_PW 
.................... 		//"PASS=" 
.................... 		#if SERVERLCD 
.................... 		Display_XYString(1,2,"PASS "); 
.................... 		#endif 
.................... 		char *passpntr= strstr(varStart,"PASS=")+5; 
.................... 		#if SERVERLCD 
03B90:  MOV     #6,W3
03B92:  MOV     #0,W2
03B94:  MOV     #3930,W1
03B96:  MOV     W3,[W15++]
03B98:  MOV     W2,W0
03B9A:  CALL    1456
03B9E:  MOV     [--W15],W3
03BA0:  MOV.B   W0L,[W1++]
03BA2:  INC     W2,W2
03BA4:  DEC     W3,W3
03BA6:  BTSS.B  42.1
03BA8:  BRA     3B96
03BAA:  PUSH    3944
03BAC:  POP     39C6
03BAE:  MOV     #3930,W4
03BB0:  MOV     W4,39C8
03BB2:  CALL    2F60
03BB6:  MOV     W0,W5
03BB8:  ADD     W5,#5,W5
03BBA:  MOV     W5,39AA
.................... 			VacWriteChar('1'); 
.................... 			VacWriteChar(*passpntr); 
.................... 		#endif 
.................... 		doneptr= strchr(passpntr,'&'); 
03BBC:  MOV     39B4,W0
03BBE:  MOV.B   #26,W0L
03BC0:  MOV     W0,39B4
03BC2:  PUSH    39AA
03BC4:  POP     39B2
03BC6:  CALL    354E
03BCA:  MOV     W0,39A8
.................... 		#if SERVERLCD 
.................... 			VacWriteChar('2'); 
.................... 			VacWriteChar(*doneptr); 
.................... 		#endif 
.................... 		strncpy(STA_PW,passpntr,doneptr-passpntr); 
03BCC:  MOV     39A8,W0
03BCE:  MOV     39AA,W4
03BD0:  SUB     W0,W4,W5
03BD2:  MOV     #1D76,W4
03BD4:  MOV     W4,39B6
03BD6:  PUSH    39AA
03BD8:  POP     39B8
03BDA:  MOV     W5,39BA
03BDC:  CALL    3578
.................... 		#if SERVERLCD		 
.................... 			VacWriteChar('3'); 
.................... 		#endif 
.................... 		strncpy(STA_PW+(doneptr-passpntr),"\0",1); 
03BE0:  MOV     39A8,W0
03BE2:  MOV     39AA,W4
03BE4:  SUB     W0,W4,W0
03BE6:  MOV     #1D76,W4
03BE8:  ADD     W0,W4,W5
03BEA:  MOV     #1,W3
03BEC:  MOV     #0,W2
03BEE:  MOV     #3930,W1
03BF0:  MOV     W3,[W15++]
03BF2:  MOV     W2,W0
03BF4:  CALL    1448
03BF8:  MOV     [--W15],W3
03BFA:  MOV.B   W0L,[W1++]
03BFC:  INC     W2,W2
03BFE:  DEC     W3,W3
03C00:  BTSS.B  42.1
03C02:  BRA     3BF0
03C04:  MOV     W5,39B6
03C06:  MOV     #3930,W4
03C08:  MOV     W4,39B8
03C0A:  MOV     #1,W4
03C0C:  MOV     W4,39BA
03C0E:  CALL    3578
.................... 		#if SERVERLCD 
.................... 			VacWriteChar('4'); 
....................  
.................... 			Display_XYString(2,3,"AUTH"); 
.................... 		#endif 
.................... 		char *authpntr= strstr(varStart,"AUTH=")+5; 
.................... 		#if SERVERLCD 
03C12:  MOV     #6,W3
03C14:  MOV     #0,W2
03C16:  MOV     #3930,W1
03C18:  MOV     W3,[W15++]
03C1A:  MOV     W2,W0
03C1C:  CALL    1468
03C20:  MOV     [--W15],W3
03C22:  MOV.B   W0L,[W1++]
03C24:  INC     W2,W2
03C26:  DEC     W3,W3
03C28:  BTSS.B  42.1
03C2A:  BRA     3C18
03C2C:  PUSH    3944
03C2E:  POP     39C6
03C30:  MOV     #3930,W4
03C32:  MOV     W4,39C8
03C34:  CALL    2F60
03C38:  MOV     W0,W5
03C3A:  ADD     W5,#5,W5
03C3C:  MOV     W5,39AC
.................... 			VacWriteChar('1'); 
.................... 			VacWriteChar(*authpntr); 
.................... 		#endif 
.................... 		doneptr= strchr(authpntr,'&'); 
03C3E:  MOV     39B4,W0
03C40:  MOV.B   #26,W0L
03C42:  MOV     W0,39B4
03C44:  PUSH    39AC
03C46:  POP     39B2
03C48:  CALL    354E
03C4C:  MOV     W0,39A8
.................... 		#if SERVERLCD 
.................... 			VacWriteChar('2'); 
.................... 			VacWriteChar(*doneptr); 
.................... 		#endif 
.................... 		strncpy(STA_AUTH,authpntr,doneptr-authpntr); 
03C4E:  MOV     39A8,W0
03C50:  MOV     39AC,W4
03C52:  SUB     W0,W4,W5
03C54:  MOV     #1DB6,W4
03C56:  MOV     W4,39B6
03C58:  PUSH    39AC
03C5A:  POP     39B8
03C5C:  MOV     W5,39BA
03C5E:  CALL    3578
.................... 		#if SERVERLCD 
.................... 		VacWriteChar('3'); 
.................... 		#endif 
.................... 		strncpy(STA_AUTH+(doneptr-authpntr),"\0",1); 
03C62:  MOV     39A8,W0
03C64:  MOV     39AC,W4
03C66:  SUB     W0,W4,W0
03C68:  MOV     #1DB6,W4
03C6A:  ADD     W0,W4,W5
03C6C:  MOV     #1,W3
03C6E:  MOV     #0,W2
03C70:  MOV     #3930,W1
03C72:  MOV     W3,[W15++]
03C74:  MOV     W2,W0
03C76:  CALL    1448
03C7A:  MOV     [--W15],W3
03C7C:  MOV.B   W0L,[W1++]
03C7E:  INC     W2,W2
03C80:  DEC     W3,W3
03C82:  BTSS.B  42.1
03C84:  BRA     3C72
03C86:  MOV     W5,39B6
03C88:  MOV     #3930,W4
03C8A:  MOV     W4,39B8
03C8C:  MOV     #1,W4
03C8E:  MOV     W4,39BA
03C90:  CALL    3578
.................... 		#if SERVERLCD 
.................... 		VacWriteChar('4'); 
.................... 		#endif 
.................... 		 
....................  
.................... 		char *encpntr= strstr(varStart,"ENCRYPT=")+8; 
03C94:  MOV     #9,W3
03C96:  MOV     #0,W2
03C98:  MOV     #3930,W1
03C9A:  MOV     W3,[W15++]
03C9C:  MOV     W2,W0
03C9E:  CALL    147A
03CA2:  MOV     [--W15],W3
03CA4:  MOV.B   W0L,[W1++]
03CA6:  INC     W2,W2
03CA8:  DEC     W3,W3
03CAA:  BTSS.B  42.1
03CAC:  BRA     3C9A
03CAE:  PUSH    3944
03CB0:  POP     39C6
03CB2:  MOV     #3930,W4
03CB4:  MOV     W4,39C8
03CB6:  CALL    2F60
03CBA:  MOV     W0,W5
03CBC:  ADD     W5,#8,W5
03CBE:  MOV     W5,39AE
.................... 		doneptr= strchr(encpntr,'\0'); 
03CC0:  MOV     39B4,W0
03CC2:  MOV.B   #0,W0L
03CC4:  MOV     W0,39B4
03CC6:  PUSH    39AE
03CC8:  POP     39B2
03CCA:  CALL    354E
03CCE:  MOV     W0,39A8
....................  
.................... 		 
.................... 		strncpy(STA_ENC,encpntr,encpntr-passpntr); 
03CD0:  MOV     39AE,W0
03CD2:  MOV     39AA,W4
03CD4:  SUB     W0,W4,W5
03CD6:  MOV     #1DBE,W4
03CD8:  MOV     W4,39B6
03CDA:  PUSH    39AE
03CDC:  POP     39B8
03CDE:  MOV     W5,39BA
03CE0:  CALL    3578
.................... 		strncpy(STA_ENC+(doneptr-encpntr),"\0",1); 
03CE4:  MOV     39A8,W0
03CE6:  MOV     39AE,W4
03CE8:  SUB     W0,W4,W0
03CEA:  MOV     #1DBE,W4
03CEC:  ADD     W0,W4,W5
03CEE:  MOV     #1,W3
03CF0:  MOV     #0,W2
03CF2:  MOV     #3930,W1
03CF4:  MOV     W3,[W15++]
03CF6:  MOV     W2,W0
03CF8:  CALL    1448
03CFC:  MOV     [--W15],W3
03CFE:  MOV.B   W0L,[W1++]
03D00:  INC     W2,W2
03D02:  DEC     W3,W3
03D04:  BTSS.B  42.1
03D06:  BRA     3CF4
03D08:  MOV     W5,39B6
03D0A:  MOV     #3930,W4
03D0C:  MOV     W4,39B8
03D0E:  MOV     #1,W4
03D10:  MOV     W4,39BA
03D12:  CALL    3578
.................... 		 
.................... 		//sendSubmittedPage(STA_SSID,STA_PW); 
.................... 		WFIsConfig=0; 
03D16:  BCLR.B  85D.1
.................... 		} 
.................... 	//genSubmittedPage(WebPageTxtBuff,STA_SSID,STA_PW); 
.................... 	//genSubmittedPage(WebPageTxtBuff,fakeSSID,fakePASS); 
.................... 	//sendHTTPPage(WebPageTxtBuff); 
.................... 	//WIFI_CONFIG_ROUTER_SETTINGS(); 
.................... 	xRST(); 
03D18:  CALL    27D8
.................... 	VacDisplayClear(); 
03D1C:  CALL    236E
.................... 	resetParsing=1; 
03D20:  BSET.B  85D.3
.................... 	delay_ms(10000); 
03D22:  MOV     #2710,W0
03D24:  CALL    21F2
.................... 	WIFI_enter_setup(); 
03D28:  CALL    287E
.................... 	WFIsConfig=0; 
03D2C:  BCLR.B  85D.1
.................... 	USEAT=1; 
03D2E:  BSET.B  85D.2
.................... 	WIFI_STA_CCONFIG(1); 
03D30:  MOV     39B2,W0
03D32:  MOV.B   #1,W0L
03D34:  MOV     W0,39B2
03D36:  CALL    37A6
.................... 	} 
03D3A:  GOTO    3D46
....................  
....................  
....................  
.................... //IF There isnt a Page 404 It 
.................... else 
.................... 	{ 
.................... 	send404Page(url); 
03D3E:  PUSH    392E
03D40:  POP     39B2
03D42:  CALL    39FC
.................... 	} 
03D46:  MOV     [--W15],W6
03D48:  MOV     [--W15],W5
03D4A:  RETURN  
....................  
.................... } 
....................  
.................... #include <Stringsplitter.h> 
.................... #ifndef STRSPLITTER_H 
.................... #define STRSPLITTER_H 
.................... //char dataSplitter(int bkbhit); 
.................... char dataSplitter(); 
....................  
.................... #include"Stringsplitter.c" 
....................  
....................  
.................... //Function That takes Data Input  
.................... #define SPLITTERDEBUG 0 
.................... #define LAZYDEBUG 0 
.................... #ifndef int1 
.................... #define int1 int 
.................... #endif 
....................  
....................  
....................  
.................... //char dataSplitter(int bkbhit) 
.................... char dataSplitter() 
*
041B8:  MOV     W5,[W15++]
.................... { 
.................... static char stateType=0; 
.................... static int1 isSet=0;	//Lazy way of checking if one of the modes is on 
.................... static int1 nsaWATCHLIST=0;	//used to identify when one of a series of escape characters is seen 
.................... //static int1 resetbuff=0; 
....................  
.................... if(resetParsing) 
041BA:  BTSS.B  85D.3
041BC:  BRA     41CA
.................... { 
.................... stateType=0; 
041BE:  MOV     296A,W0
041C0:  CLR.B   1
041C2:  MOV     W0,296A
.................... isSet=0; 
041C4:  BCLR.B  85D.7
.................... resetParsing=0; 
041C6:  BCLR.B  85D.3
.................... ISWWWPARSE=0; 
041C8:  BCLR.B  85C.5
.................... } 
....................  
.................... //int8 HTTPCTR=0; 
.................... //int8 WWWCTR=0; 
.................... //int8 ATCTR=0; 
.................... //int8 ENGRCTR=0; 
....................  
.................... //fprintf(WIFI,"%i\r\n",bkbhit); 
.................... //static char daBuff[24]; 
.................... char daBuff[24]; 
.................... char requestBuff[255]; 
....................  
.................... while(bkbhit) 
041CA:  MOV     2146,W0
041CC:  MOV     2148,W4
041CE:  CP      W4,W0
041D0:  BRA     Z,4454
.................... 	{ 
.................... 	char c=bgetc(); 
.................... 	#if LAZYDEBUG 
041D2:  CALL    2850
041D6:  PUSH    3918
041D8:  MOV.B   W0L,[W15-#1]
041DA:  POP     3918
.................... 	char atstbuf[6]; 
.................... 	sprintf(atstbuf,"%c,%d",c,USEAT); 
.................... 	Display_XYString(0,4,atstbuf); 
.................... 	#endif 
.................... 	 
.................... //fprintf(WIFI,"%c\r\n",c); 
.................... ////////////////////////////////////////////////////////////	 
.................... 	if(isSet==0) 
041DC:  BTSC.B  85D.7
041DE:  BRA     4264
.................... 		{ 
.................... 		//if(c=='\n'){ 
.................... 	//	VacWriteChar('n'); 
.................... 	//	} 
.................... 	//	else 
.................... 	//	{ 
....................  
.................... 	//	} 
.................... 		nsaWATCHLIST=0; 
041E0:  MOV     296C,W0
041E2:  BCLR.B  0.0
041E4:  MOV     W0,296C
.................... 		//Try to figure out what the hell is going on 
.................... 		char dispBuff[20]; 
.................... 		switch(c) 
041E6:  PUSH    3918
041E8:  MOV     [--W15],W0
041EA:  LSR     W0,#8,W0
041EC:  CLR.B   1
041EE:  XOR     #48,W0
041F0:  BRA     Z,4200
041F2:  XOR     #F,W0
041F4:  BRA     Z,4210
041F6:  XOR     #6C,W0
041F8:  BRA     Z,4220
041FA:  XOR     #6E,W0
041FC:  BRA     Z,4244
041FE:  BRA     4254
.................... 			{ 
.................... 			case 'H':	//HTTP/1.1 ... 
.................... 			stateType='w'; 
04200:  MOV     296A,W0
04202:  SWAP    W0
04204:  MOV.B   #77,W0L
04206:  SWAP    W0
04208:  MOV     W0,296A
.................... 			isSet=1; 
0420A:  BSET.B  85D.7
.................... 			//VacWriteChar('['); 
.................... 			break; 
0420C:  GOTO    4260
.................... 			case 'G':	//GET ... 
.................... 			stateType='r'; 
04210:  MOV     296A,W0
04212:  SWAP    W0
04214:  MOV.B   #72,W0L
04216:  SWAP    W0
04218:  MOV     W0,296A
.................... 			isSet=1; 
0421A:  BSET.B  85D.7
.................... 			//VacWriteChar('['); 
.................... 			break; 
0421C:  GOTO    4260
.................... 			case '+':	//+ok= ... 
.................... 			if(WFIsConfig==0) 
04220:  BTSC.B  85D.1
04222:  BRA     4230
.................... 			{ 
.................... 			stateType='a'; 
04224:  MOV     296A,W0
04226:  SWAP    W0
04228:  MOV.B   #61,W0L
0422A:  SWAP    W0
0422C:  MOV     W0,296A
.................... 			isSet=1; 
0422E:  BSET.B  85D.7
.................... 			} 
....................  
.................... 			if(ROUTERSCANING==1) 
04230:  BTSS.B  85C.3
04232:  BRA     4240
.................... 			{ 
.................... 			stateType='s'; 
04234:  MOV     296A,W0
04236:  SWAP    W0
04238:  MOV.B   #73,W0L
0423A:  SWAP    W0
0423C:  MOV     W0,296A
.................... 			isSet=1; 
0423E:  BSET.B  85D.7
.................... 			} 
....................  
.................... 			//VacWriteChar('['); 
.................... 			break; 
04240:  GOTO    4260
.................... 			case 'E':	//TBD 
.................... 			stateType='e'; 
04244:  MOV     296A,W0
04246:  SWAP    W0
04248:  MOV.B   #65,W0L
0424A:  SWAP    W0
0424C:  MOV     W0,296A
.................... 			isSet=1; 
0424E:  BSET.B  85D.7
.................... 			//VacWriteChar('['); 
.................... 			break; 
04250:  GOTO    4260
.................... 			default:		//None of the above keep going 
.................... 			stateType=0; 
04254:  MOV     296A,W0
04256:  CLR.B   1
04258:  MOV     W0,296A
.................... 			isSet=0; 
0425A:  BCLR.B  85D.7
.................... 			 
.................... 			break; 
0425C:  GOTO    4260
.................... 			} 
....................  
....................  
.................... 		#if SPLITTERDEBUG 
.................... 		//printf("\nState:%c\n",stateType); 
.................... 		//fprintf(WIFI,"HI\n"); 
.................... 		//fprintf(WIFI,"%c\n",stateType); 
.................... 		//VacWriteChar(stateType); 
.................... 		//VacWriteChar(':'); 
.................... 		VacWriteChar(c); 
.................... 		#endif 
.................... 		} 
04260:  GOTO    4450
.................... 		 
.................... //////////////////////////////////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////// 
.................... 	else	//if you know what you're doing 
.................... 		{ 
.................... 				#if SPLITTERDEBUG 
.................... 				VacWriteChar(c); 
.................... 				#endif 
.................... 		switch(stateType) 
04264:  PUSH    296A
04266:  MOV     [--W15],W0
04268:  LSR     W0,#8,W0
0426A:  CLR.B   1
0426C:  XOR     #77,W0
0426E:  BRA     Z,4282
04270:  XOR     #5,W0
04272:  BRA     Z,42D4
04274:  XOR     #13,W0
04276:  BRA     Z,434E
04278:  XOR     #4,W0
0427A:  BRA     Z,43C2
0427C:  XOR     #16,W0
0427E:  BRA     Z,43DA
04280:  BRA     43CE
.................... 			{ 
.................... 			//OSMOBOT.ORG gangster stuff 
.................... 			case 'w': 
.................... 			ISWWWPARSE=1; 
04282:  BSET.B  85C.5
.................... 			if(nsaWATCHLIST==1) 
04284:  MOV     296C,W4
04286:  BTSS    W4.0
04288:  BRA     42AC
.................... 			{ 
.................... 			if(c=='h')		//Identity verified 
0428A:  MOV     3918,W0
0428C:  LSR     W0,#8,W0
0428E:  MOV     #68,W4
04290:  CP.B    W4L,W0L
04292:  BRA     NZ,42A6
.................... 				{ 
.................... 				//go back to not knowing what you're doing 
.................... 				isSet=0;	 
04294:  BCLR.B  85D.7
.................... 				stateType=0; 
04296:  MOV     296A,W0
04298:  CLR.B   1
0429A:  MOV     W0,296A
.................... 				setServer(); 
0429C:  CALL    28C8
.................... 				ISWWWPARSE=0; 
042A0:  BCLR.B  85C.5
.................... 				#if SPLITTERDEBUG 
.................... 				VacWriteChar(']'); 
.................... 				#endif	 
.................... 				} 
042A2:  GOTO    42AC
.................... 			else 
.................... 				{ 
.................... 				nsaWATCHLIST=0;				 
042A6:  MOV     296C,W0
042A8:  BCLR.B  0.0
042AA:  MOV     W0,296C
.................... 				} 
.................... 			} 
....................  
.................... 			if(c=='/')	//</html> 
042AC:  MOV     3918,W0
042AE:  LSR     W0,#8,W0
042B0:  MOV     #2F,W4
042B2:  CP.B    W4L,W0L
042B4:  BRA     NZ,42BC
.................... 			{ 
.................... 			nsaWATCHLIST=1;	//Youre on a list 
042B6:  MOV     296C,W0
042B8:  BSET.B  0.0
042BA:  MOV     W0,296C
.................... 			#if SPLITTERDEBUG 
.................... 			VacWriteChar('|'); 
.................... 			#endif 
.................... 			} 
....................  
....................  
.................... 			parseHTTP(c,daBuff);	//Parse the character 
042BC:  PUSH    3918
042BE:  MOV     [--W15],W0
042C0:  LSR     W0,#8,W0
042C2:  PUSH    392E
042C4:  MOV.B   W0L,[W15-#2]
042C6:  POP     392E
042C8:  MOV     #3802,W4
042CA:  MOV     W4,3930
042CC:  CALL    2D56
.................... 			break; 
042D0:  GOTO    4450
....................  
....................  
....................  
.................... 			//Someone wants a webpage 
.................... 			case 'r': 
.................... 			//Have to do this first because 2 consecutive characters are the same 
.................... 			if(nsaWATCHLIST==1) 
042D4:  MOV     296C,W4
042D6:  BTSS    W4.0
042D8:  BRA     42F4
.................... 			{ 
.................... 			if(c=='\n')		//Identity verified 
042DA:  MOV     3918,W0
042DC:  LSR     W0,#8,W0
042DE:  CP.B    W0L,#A
042E0:  BRA     NZ,42EE
.................... 				{ 
.................... 				//go back to not knowing what you're doing 
.................... 				isSet=0;	 
042E2:  BCLR.B  85D.7
.................... 				stateType=0; 
042E4:  MOV     296A,W0
042E6:  CLR.B   1
042E8:  MOV     W0,296A
.................... 				#if SPLITTERDEBUG 
.................... 				VacWriteChar(']');	 
.................... 				#endif 
.................... 				} 
042EA:  GOTO    42F4
.................... 			else 
.................... 				{ 
.................... 				nsaWATCHLIST=0; 
042EE:  MOV     296C,W0
042F0:  BCLR.B  0.0
042F2:  MOV     W0,296C
.................... 				} 
.................... 			} 
.................... 			if(c=='\n')	//</html> 
042F4:  MOV     3918,W0
042F6:  LSR     W0,#8,W0
042F8:  CP.B    W0L,#A
042FA:  BRA     NZ,4302
.................... 			{ 
.................... 			//VacWriteChar('|'); 
.................... 			nsaWATCHLIST=1;	//Youre on a list 
042FC:  MOV     296C,W0
042FE:  BSET.B  0.0
04300:  MOV     W0,296C
.................... 			} 
....................  
....................  
.................... 			//Parse your web request somewhere here 
.................... 			//VacWriteChar(c); 
.................... #if USEWEBSERVER 
.................... 			if(getRequestLine(c,requestBuff)) 
04302:  PUSH    3918
04304:  MOV     [--W15],W0
04306:  LSR     W0,#8,W0
04308:  PUSH    392E
0430A:  MOV.B   W0L,[W15-#2]
0430C:  POP     392E
0430E:  MOV     #381A,W4
04310:  MOV     W4,3930
04312:  CALL    2E30
04316:  CP0.B   W0L
04318:  BRA     Z,434A
.................... 				{ 
.................... 				 
.................... 				if(lineIsGetRequest(requestBuff)) 
0431A:  MOV     #381A,W4
0431C:  MOV     W4,392E
0431E:  CALL    2E84
04322:  CP0.B   W0L
04324:  BRA     Z,434A
.................... 					{ 
.................... 				//	VacDisplayClear(); 
.................... 				//	Display_XYString(0,1,requestBuff); 
.................... 					if(parseGetRequest(requestBuff,requestURLBuff)) 
04326:  MOV     #381A,W4
04328:  MOV     W4,392E
0432A:  MOV     #85E,W4
0432C:  MOV     W4,3930
0432E:  CALL    2EA4
04332:  CP0.B   W0L
04334:  BRA     Z,4342
.................... 					{ 
.................... 					//sendTestPage(); 
.................... 					//sendTestPage2(requestURLBuff); 
.................... 					//send404Page(requestURLBuff); 
.................... 					osmobotServePage(requestURLBuff); 
04336:  MOV     #85E,W4
04338:  MOV     W4,392E
0433A:  CALL    3A42
.................... 					} 
0433E:  GOTO    434A
.................... 					else 
.................... 					{ 
.................... 					//sendTestPage(); 
.................... 					genHostPage(WebPageTxtBuff); 
04342:  MOV     #95E,W4
04344:  MOV     W4,392E
04346:  CALL    3D4C
.................... 					//sendHTTPPage(WebPageTxtBuff); 
.................... 					//genWifiConfigPage(WebPageTxtBuff); 
.................... 					//genTestPage(WebPageTxtBuff); 
.................... 					//sendHTTPPage(WebPageTxtBuff); 
.................... 					} 
.................... 				} 
.................... 			} 
.................... #endif 
.................... 			break; 
0434A:  GOTO    4450
....................  
....................  
.................... 			//AT commands... 
.................... 			case 'a': 
....................  
.................... 			if(USEAT==0) 
0434E:  BTSC.B  85D.2
04350:  BRA     435A
.................... 			{ 
.................... 				isSet=0;	 
04352:  BCLR.B  85D.7
.................... 				stateType=0; 
04354:  MOV     296A,W0
04356:  CLR.B   1
04358:  MOV     W0,296A
.................... 			} 
.................... 	//Have to do this first because 2 consecutive characters are the same 
.................... 			if(nsaWATCHLIST==1) 
0435A:  MOV     296C,W4
0435C:  BTSS    W4.0
0435E:  BRA     437A
.................... 			{ 
.................... 			//VacWriteChar('b'); 
.................... 			if(c=='\n')		//Identity verified 
04360:  MOV     3918,W0
04362:  LSR     W0,#8,W0
04364:  CP.B    W0L,#A
04366:  BRA     NZ,4374
.................... 				{ 
.................... 				//go back to not knowing what you're doing 
.................... 				isSet=0;	 
04368:  BCLR.B  85D.7
.................... 				stateType=0; 
0436A:  MOV     296A,W0
0436C:  CLR.B   1
0436E:  MOV     W0,296A
.................... 				#if SPLITTERDEBUG 
.................... 				VacWriteChar(']'); 
.................... 				#endif	 
.................... 				} 
04370:  GOTO    437A
.................... 			else 
.................... 				{ 
.................... 				nsaWATCHLIST=0; 
04374:  MOV     296C,W0
04376:  BCLR.B  0.0
04378:  MOV     W0,296C
.................... 				//VacWriteChar('x'); 
.................... 				} 
.................... 			} 
.................... 			VacWriteChar(c); 
0437A:  PUSH    3918
0437C:  MOV     [--W15],W0
0437E:  LSR     W0,#8,W0
04380:  PUSH    39D0
04382:  MOV.B   W0L,[W15-#2]
04384:  POP     39D0
04386:  CALL    2766
.................... 			if(c=='+') 
0438A:  MOV     3918,W0
0438C:  LSR     W0,#8,W0
0438E:  MOV     #2B,W4
04390:  CP.B    W4L,W0L
04392:  BRA     NZ,439A
.................... 				{ 
.................... 				checkATOK=1; 
04394:  BSET.B  85C.7
.................... 				} 
04396:  GOTO    43B0
.................... 			else if(c=='o') 
0439A:  MOV     3918,W0
0439C:  LSR     W0,#8,W0
0439E:  MOV     #6F,W4
043A0:  CP.B    W4L,W0L
043A2:  BRA     NZ,43B0
.................... 				{ 
.................... 				ATisOK=checkATOK; 
043A4:  BCLR.B  85D.0
043A6:  BTSC.B  85C.7
043A8:  BSET.B  85D.0
.................... 				checkATOK=0; 
043AA:  BCLR.B  85C.7
.................... 				} 
043AC:  GOTO    43B0
.................... 			else 
.................... 				{ 
.................... 				} 
.................... 			 
.................... 			break; 
043B0:  GOTO    4450
....................  
....................  
....................  
.................... 			if(c=='\r')	//</html> 
043B4:  MOV     3918,W0
043B6:  LSR     W0,#8,W0
043B8:  CP.B    W0L,#D
043BA:  BRA     NZ,43C2
.................... 			{ 
.................... 			//VacWriteChar('?'); 
.................... 			nsaWATCHLIST=1;	//Youre on a list 
043BC:  MOV     296C,W0
043BE:  BSET.B  0.0
043C0:  MOV     W0,296C
.................... 			} 
....................  
....................  
.................... 			//Parse your AT Commands somewhere here 
.................... 			 
....................  
.................... 				 
....................  
.................... 			//Engineering config stuff 
.................... 			case 'e': 
.................... 				//Just to make sure we dont get stuck for now 
.................... 				isSet=0;	 
043C2:  BCLR.B  85D.7
.................... 				stateType=0; 
043C4:  MOV     296A,W0
043C6:  CLR.B   1
043C8:  MOV     W0,296A
.................... 			break; 
043CA:  GOTO    4450
....................  
.................... 			//WHAT? 
.................... 			default: 
.................... 			//DO NOT PASS GO DO NOT COLLECT $200 
....................  
.................... 			stateType=0; 
043CE:  MOV     296A,W0
043D0:  CLR.B   1
043D2:  MOV     W0,296A
.................... 			isSet=0; 
043D4:  BCLR.B  85D.7
.................... 			break; 
043D6:  GOTO    4450
.................... 			 
....................  
.................... 			//scan for routers 
.................... 			case 's': 
.................... 			VacWriteChar(c); 
043DA:  PUSH    3918
043DC:  MOV     [--W15],W0
043DE:  LSR     W0,#8,W0
043E0:  PUSH    39D0
043E2:  MOV.B   W0L,[W15-#2]
043E4:  POP     39D0
043E6:  CALL    2766
....................  
.................... 			if(c=='+') 
043EA:  MOV     3918,W0
043EC:  LSR     W0,#8,W0
043EE:  MOV     #2B,W4
043F0:  CP.B    W4L,W0L
043F2:  BRA     NZ,43FA
.................... 			{ 
.................... 				checkScanError=1; 
043F4:  BSET.B  85C.4
.................... 			} 
043F6:  GOTO    4424
.................... 			else if(c=='E')	//Check For Error 
043FA:  MOV     3918,W0
043FC:  LSR     W0,#8,W0
043FE:  MOV     #45,W4
04400:  CP.B    W4L,W0L
04402:  BRA     NZ,4422
.................... 			{ 
.................... 			if(checkScanError) 
04404:  BTSS.B  85C.4
04406:  BRA     441E
.................... 			{ 
.................... 			SCANERROR=checkScanError; 
04408:  BCLR.B  85C.2
0440A:  BTSC.B  85C.4
0440C:  BSET.B  85C.2
.................... 			VacWriteChar('!'); 
0440E:  MOV     39D0,W0
04410:  MOV.B   #21,W0L
04412:  MOV     W0,39D0
04414:  CALL    2766
.................... 			delay_ms(500); 
04418:  MOV     #1F4,W0
0441A:  CALL    21F2
.................... 				} 
.................... 			} 
0441E:  GOTO    4424
.................... 			else 
.................... 			{ 
.................... 			checkScanError=0; 
04422:  BCLR.B  85C.4
.................... 			} 
....................  
....................  
.................... 							 
.................... 			if(parseRouter(routerTable,c,0))	//Runs the parser and checks if its done 
04424:  PUSH    3918
04426:  MOV     [--W15],W0
04428:  LSR     W0,#8,W0
0442A:  PUSH    3930
0442C:  MOV.B   W0L,[W15-#2]
0442E:  POP     3930
04430:  MOV     #2154,W4
04432:  MOV     W4,392E
04434:  MOV     #0,W4
04436:  MOV     W4,3932
04438:  CALL    3FE2
0443C:  CP0     W0
0443E:  BRA     Z,444C
.................... 			{ 
.................... 				isSet=0;	 
04440:  BCLR.B  85D.7
.................... 				stateType=0; 
04442:  MOV     296A,W0
04444:  CLR.B   1
04446:  MOV     W0,296A
.................... 				ROUTERSCANING=0; 
04448:  BCLR.B  85C.3
.................... 				resetParsing=1; 
0444A:  BSET.B  85D.3
.................... 			} 
.................... 			break; 
0444C:  GOTO    4450
.................... /////////////////////////////////////////////// 
.................... 		} 
....................  
.................... 	} 
.................... 	 
.................... 	//printf("%c",c); 
.................... 	 
.................... 	} 
.................... #if SPLITTERDEBUG 
04450:  GOTO    41CA
.................... //fprintf(WIFI,"%c\n",stateType); 
.................... //fprintf(WIFI,"%c\n",'m'); 
.................... //fputc(stateType,WIFI); 
.................... //fputc('\n',WIFI); 
....................  
.................... #endif 
.................... return stateType; 
04454:  PUSH    296A
04456:  MOV     [--W15],W0
04458:  LSR     W0,#8,W0
0445A:  MOV     [--W15],W5
0445C:  RETURN  
.................... } 
....................  
.................... /// 
.................... //Yep 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define ALLOW_GET_DISK_PROPERTIES q  //used by 'info' command 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #USE PWM(OUTPUT=PIN_D1, FREQUENCY=8000Hz, STREAM=PH_PWM)      //Pin 49 
*
027D2:  PUSH    3872
027D4:  POP     196
027D6:  RETURN  
.................... #USE PWM(OUTPUT=PIN_D2, FREQUENCY=8000Hz, STREAM=DO_PWM)    //Pin 48 
*
027CC:  PUSH    3802
027CE:  POP     1A0
027D0:  RETURN  
....................  
....................  
.................... //#USE PWM(OUTPUT=PIN_D1, STREAM=PH_PWM)      //Pin 49 
.................... //#USE PWM(OUTPUT=PIN_D2, STREAM=DO_PWM)    //Pin 48 
....................  
.................... #if USESENSORS  
....................  
....................  
.................... #use i2c(stream=PH_Light, MASTER, sda=PIN_F4, scl=PIN_F5, FORCE_HW, SLOW)    // SDA2 
*
02398:  MOV     #FFFF,W0
0239A:  BTSS.B  218.3
0239C:  BRA     23A8
0239E:  BTSC.B  219.6
023A0:  BRA     239E
023A2:  MOV     W1,212
023A4:  BTSC.B  219.6
023A6:  BRA     23A4
023A8:  MOV     #0,W0
023AA:  BTSC.B  219.7
023AC:  INC     W0,W0
023AE:  RETURN  
*
05536:  MOV     #FFFF,W0
05538:  BTSS.B  218.3
0553A:  BRA     555E
0553C:  MOV     216,W2
0553E:  AND     W2,#1F,W2
05540:  BRA     NZ,553C
05542:  BSET.B  216.3
05544:  BTSC    W1.0
05546:  BCLR.B  216.5
05548:  BTSS    W1.0
0554A:  BSET.B  216.5
0554C:  MOV     216,W2
0554E:  AND     W2,#1F,W2
05550:  BRA     NZ,554C
05552:  BSET.B  216.4
05554:  BTSS.B  218.1
05556:  BRA     5554
05558:  MOV     210,W0
0555A:  BTSC.B  218.6
0555C:  BCLR.B  218.6
0555E:  RETURN  
.................... #use i2c(stream=DO_Light, MASTER, sda=PIN_E7, scl=PIN_E6, FORCE_HW, SLOW)    // SDA3  
*
023B0:  MOV     #FFFF,W0
023B2:  BTSS.B  278.3
023B4:  BRA     23C0
023B6:  BTSC.B  279.6
023B8:  BRA     23B6
023BA:  MOV     W1,272
023BC:  BTSC.B  279.6
023BE:  BRA     23BC
023C0:  MOV     #0,W0
023C2:  BTSC.B  279.7
023C4:  INC     W0,W0
023C6:  RETURN  
*
05560:  MOV     #FFFF,W0
05562:  BTSS.B  278.3
05564:  BRA     5588
05566:  MOV     276,W2
05568:  AND     W2,#1F,W2
0556A:  BRA     NZ,5566
0556C:  BSET.B  276.3
0556E:  BTSC    W1.0
05570:  BCLR.B  276.5
05572:  BTSS    W1.0
05574:  BSET.B  276.5
05576:  MOV     276,W2
05578:  AND     W2,#1F,W2
0557A:  BRA     NZ,5576
0557C:  BSET.B  276.4
0557E:  BTSS.B  278.1
05580:  BRA     557E
05582:  MOV     270,W0
05584:  BTSC.B  278.6
05586:  BCLR.B  278.6
05588:  RETURN  
.................... #use i2c(stream=Room_Light, MASTER, sda=PIN_G3, scl=PIN_G2, FORCE_HW, SLOW)    // SDA1 
*
023C8:  MOV     #FFFF,W0
023CA:  BTSS.B  208.3
023CC:  BRA     23D8
023CE:  BTSC.B  209.6
023D0:  BRA     23CE
023D2:  MOV     W1,202
023D4:  BTSC.B  209.6
023D6:  BRA     23D4
023D8:  MOV     #0,W0
023DA:  BTSC.B  209.7
023DC:  INC     W0,W0
023DE:  RETURN  
*
0558A:  MOV     #FFFF,W0
0558C:  BTSS.B  208.3
0558E:  BRA     55B2
05590:  MOV     206,W2
05592:  AND     W2,#1F,W2
05594:  BRA     NZ,5590
05596:  BSET.B  206.3
05598:  BTSC    W1.0
0559A:  BCLR.B  206.5
0559C:  BTSS    W1.0
0559E:  BSET.B  206.5
055A0:  MOV     206,W2
055A2:  AND     W2,#1F,W2
055A4:  BRA     NZ,55A0
055A6:  BSET.B  206.4
055A8:  BTSS.B  208.1
055AA:  BRA     55A8
055AC:  MOV     200,W0
055AE:  BTSC.B  208.6
055B0:  BCLR.B  208.6
055B2:  RETURN  
....................  
....................  
.................... #include "sdcard\ex_mdd_common.h" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// 
.................... //// ex_mdd_common.h 
.................... //// 
.................... //// Common header file for CCS's MDD examples 
.................... //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //#define HW_CCS_3V_ETHERNET 
.................... //#define HW_CCS_DSP_AUDIO    //dsPIC33FJ 
.................... //#define HW_CCS_DSP_AUDIO2   //dsPIC33EP 
.................... #define HW_CCS_PIC24USB 
....................  
....................  
....................  
.................... #if defined(HW_CCS_PIC24USB) 
.................... //   #include <24FJ256GA106.h> 
....................  
.................... //   #fuses HS,PR_PLL,NOWDT,ICSP2,PLL5  did noy like 
.................... //   #fuses HS,PR_PLL,NOWDT,ICSP2 
....................    //C30/XC16 compiler to CCS PCH compiler compatability. 
....................    //also includes the filesystem. 
....................    //since this changes some #device settings, this needs to be include 
....................    //fairly soon in the build process. 
....................    #include "filesystem\filesystem.h"  
.................... //see about.txt in filesystem/ for information 
....................  
.................... #ifndef __FILESYSTEM_H__ 
.................... #define __FILESYSTEM_H__ 
....................  
.................... // If you cannot find these files, then change your include path 
.................... // to include the "CCSIncludes" directory.  This directory contains 
.................... // files that help port code from Microchip C to CCS C. 
.................... #if defined(__PCH__) 
....................    #include <p18cxxx.h> //Microchip C18 C Compiler to CCS PCH Conversion 
.................... #elif defined(__PCD__) 
....................    #define __CONST_IS_READONLY__ //work around for a difference between how CCS and C30 treats 'const' pointers 
....................    #include <SDCard\CCSIncludes\PCDxxxx.h>  //Microchip C30 C Compiler to CCS PCH Conversion 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... // pcdxxxx.h 
.................... // 
.................... // Microchip C30 to CCS conversion library. 
....................  
.................... #ifndef __PCDXXXX_H__ 
.................... #define __PCDXXXX_H__ 
....................  
.................... #case 
....................  
.................... #include "ccspics.h" 
.................... //C18/C30 defines to CCS device h mapping 
....................  
.................... #ifndef __DEFINES_TO_CCS_H__ 
.................... #define __DEFINES_TO_CCS_H__ 
....................  
.................... #define __CCS__ 
....................  
.................... #if defined(__dsPIC14000__) || (getenv("DEVICE")=="DSPIC14000") 
....................     #if !defined(__dsPIC14000__) 
....................         #define __dsPIC14000__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <14000.h> 
....................     #endif 
....................     #if !defined(__dsPIC140000__) 
....................         #define __dsPIC140000__ 
....................     #endif 
....................     #include "14000_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C242) || (getenv("DEVICE")=="PIC18C242") 
....................     #if !defined(__18C242) 
....................         #define __18C242 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C242.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C242_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C252) || (getenv("DEVICE")=="PIC18C252") 
....................     #if !defined(__18C252) 
....................         #define __18C252 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C252.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C252_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C442) || (getenv("DEVICE")=="PIC18C442") 
....................     #if !defined(__18C442) 
....................         #define __18C442 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C442.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C442_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C452) || (getenv("DEVICE")=="PIC18C452") 
....................     #if !defined(__18C452) 
....................         #define __18C452 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C452.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C452_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C601) || (getenv("DEVICE")=="PIC18C601") 
....................     #if !defined(__18C601) 
....................         #define __18C601 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C601.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C601_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C658) || (getenv("DEVICE")=="PIC18C658") 
....................     #if !defined(__18C658) 
....................         #define __18C658 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C658.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C658_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C801) || (getenv("DEVICE")=="PIC18C801") 
....................     #if !defined(__18C801) 
....................         #define __18C801 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C801.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C801_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18C858) || (getenv("DEVICE")=="PIC18C858") 
....................     #if !defined(__18C858) 
....................         #define __18C858 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18C858.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18C858_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F1220) || (getenv("DEVICE")=="PIC18F1220") 
....................     #if !defined(__18F1220) 
....................         #define __18F1220 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F1220.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F1220_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F1230) || (getenv("DEVICE")=="PIC18F1230") 
....................     #if !defined(__18F1230) 
....................         #define __18F1230 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F1230.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F1230_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F1320) || (getenv("DEVICE")=="PIC18F1320") 
....................     #if !defined(__18F1320) 
....................         #define __18F1320 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F1320.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F1320_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F1330) || (getenv("DEVICE")=="PIC18F1330") 
....................     #if !defined(__18F1330) 
....................         #define __18F1330 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F1330.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F1330_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F13K22) || (getenv("DEVICE")=="PIC18F13K22") 
....................     #if !defined(__18F13K22) 
....................         #define __18F13K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F13K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F13K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F13K50) || (getenv("DEVICE")=="PIC18F13K50") 
....................     #if !defined(__18F13K50) 
....................         #define __18F13K50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F13K50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F13K50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F14K22) || (getenv("DEVICE")=="PIC18F14K22") 
....................     #if !defined(__18F14K22) 
....................         #define __18F14K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F14K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F14K22_registers.h" 
.................... #endif 
....................  
.................... /* 
.................... #if defined(__18F14K50-ICD) || (getenv("DEVICE")=="PIC18F14K50-ICD") 
....................     #if !defined(__18F14K50-ICD) 
....................         #define __18F14K50-ICD 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F14K50-ICD.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F14K50-ICD_registers.h" 
.................... #endif 
.................... */ 
....................  
.................... #if defined(__18F14K50) || (getenv("DEVICE")=="PIC18F14K50") 
....................     #if !defined(__18F14K50) 
....................         #define __18F14K50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F14K50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F14K50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2220) || (getenv("DEVICE")=="PIC18F2220") 
....................     #if !defined(__18F2220) 
....................         #define __18F2220 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2220.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2220_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2221) || (getenv("DEVICE")=="PIC18F2221") 
....................     #if !defined(__18F2221) 
....................         #define __18F2221 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2221.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2221_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2320) || (getenv("DEVICE")=="PIC18F2320") 
....................     #if !defined(__18F2320) 
....................         #define __18F2320 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2320.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2320_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2321) || (getenv("DEVICE")=="PIC18F2321") 
....................     #if !defined(__18F2321) 
....................         #define __18F2321 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2321.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2321_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2331) || (getenv("DEVICE")=="PIC18F2331") 
....................     #if !defined(__18F2331) 
....................         #define __18F2331 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2331.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2331_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F23K20) || (getenv("DEVICE")=="PIC18F23K20") 
....................     #if !defined(__18F23K20) 
....................         #define __18F23K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F23K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F23K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F23K22) || (getenv("DEVICE")=="PIC18F23K22") 
....................     #if !defined(__18F23K22) 
....................         #define __18F23K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F23K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F23K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2410) || (getenv("DEVICE")=="PIC18F2410") 
....................     #if !defined(__18F2410) 
....................         #define __18F2410 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2410.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2410_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F242) || (getenv("DEVICE")=="PIC18F242") 
....................     #if !defined(__18F242) 
....................         #define __18F242 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F242.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F242_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2420) || (getenv("DEVICE")=="PIC18F2420") 
....................     #if !defined(__18F2420) 
....................         #define __18F2420 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2420.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2420_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2423) || (getenv("DEVICE")=="PIC18F2423") 
....................     #if !defined(__18F2423) 
....................         #define __18F2423 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2423.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2423_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2431) || (getenv("DEVICE")=="PIC18F2431") 
....................     #if !defined(__18F2431) 
....................         #define __18F2431 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2431.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2431_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2439) || (getenv("DEVICE")=="PIC18F2439") 
....................     #if !defined(__18F2439) 
....................         #define __18F2439 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2439.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2439_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2450) || (getenv("DEVICE")=="PIC18F2450") 
....................     #if !defined(__18F2450) 
....................         #define __18F2450 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2450.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2450_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2455) || (getenv("DEVICE")=="PIC18F2455") 
....................     #if !defined(__18F2455) 
....................         #define __18F2455 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2455.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2455_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2458) || (getenv("DEVICE")=="PIC18F2458") 
....................     #if !defined(__18F2458) 
....................         #define __18F2458 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2458.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2458_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F248) || (getenv("DEVICE")=="PIC18F248") 
....................     #if !defined(__18F248) 
....................         #define __18F248 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F248.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F248_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2480) || (getenv("DEVICE")=="PIC18F2480") 
....................     #if !defined(__18F2480) 
....................         #define __18F2480 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2480.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2480_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24J10) || (getenv("DEVICE")=="PIC18F24J10") 
....................     #if !defined(__18F24J10) 
....................         #define __18F24J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24J11) || (getenv("DEVICE")=="PIC18F24J11") 
....................     #if !defined(__18F24J11) 
....................         #define __18F24J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24J50) || (getenv("DEVICE")=="PIC18F24J50") 
....................     #if !defined(__18F24J50) 
....................         #define __18F24J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24K20) || (getenv("DEVICE")=="PIC18F24K20") 
....................     #if !defined(__18F24K20) 
....................         #define __18F24K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24K22) || (getenv("DEVICE")=="PIC18F24K22") 
....................     #if !defined(__18F24K22) 
....................         #define __18F24K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F24K50) || (getenv("DEVICE")=="PIC18F24K50") 
....................     #if !defined(__18F24K50) 
....................         #define __18F24K50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F24K50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F24K50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2510) || (getenv("DEVICE")=="PIC18F2510") 
....................     #if !defined(__18F2510) 
....................         #define __18F2510 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2510.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2515) || (getenv("DEVICE")=="PIC18F2515") 
....................     #if !defined(__18F2515) 
....................         #define __18F2515 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2515.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2515_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F252) || (getenv("DEVICE")=="PIC18F252") 
....................     #if !defined(__18F252) 
....................         #define __18F252 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F252.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F252_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2520) || (getenv("DEVICE")=="PIC18F2520") 
....................     #if !defined(__18F2520) 
....................         #define __18F2520 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2520.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2520_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2523) || (getenv("DEVICE")=="PIC18F2523") 
....................     #if !defined(__18F2523) 
....................         #define __18F2523 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2523.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2523_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2525) || (getenv("DEVICE")=="PIC18F2525") 
....................     #if !defined(__18F2525) 
....................         #define __18F2525 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2525.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2525_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2539) || (getenv("DEVICE")=="PIC18F2539") 
....................     #if !defined(__18F2539) 
....................         #define __18F2539 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2539.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2539_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2550) || (getenv("DEVICE")=="PIC18F2550") 
....................     #if !defined(__18F2550) 
....................         #define __18F2550 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2550.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2550_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2553) || (getenv("DEVICE")=="PIC18F2553") 
....................     #if !defined(__18F2553) 
....................         #define __18F2553 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2553.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2553_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F258) || (getenv("DEVICE")=="PIC18F258") 
....................     #if !defined(__18F258) 
....................         #define __18F258 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F258.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F258_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2580) || (getenv("DEVICE")=="PIC18F2580") 
....................     #if !defined(__18F2580) 
....................         #define __18F2580 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2580.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2580_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2585) || (getenv("DEVICE")=="PIC18F2585") 
....................     #if !defined(__18F2585) 
....................         #define __18F2585 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2585.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2585_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25J10) || (getenv("DEVICE")=="PIC18F25J10") 
....................     #if !defined(__18F25J10) 
....................         #define __18F25J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25J11) || (getenv("DEVICE")=="PIC18F25J11") 
....................     #if !defined(__18F25J11) 
....................         #define __18F25J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25J50) || (getenv("DEVICE")=="PIC18F25J50") 
....................     #if !defined(__18F25J50) 
....................         #define __18F25J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25K20) || (getenv("DEVICE")=="PIC18F25K20") 
....................     #if !defined(__18F25K20) 
....................         #define __18F25K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25K22) || (getenv("DEVICE")=="PIC18F25K22") 
....................     #if !defined(__18F25K22) 
....................         #define __18F25K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25K50) || (getenv("DEVICE")=="PIC18F25K50") 
....................     #if !defined(__18F25K50) 
....................         #define __18F25K50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25K50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25K50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F25K80) || (getenv("DEVICE")=="PIC18F25K80") 
....................     #if !defined(__18F25K80) 
....................         #define __18F25K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F25K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F25K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2610) || (getenv("DEVICE")=="PIC18F2610") 
....................     #if !defined(__18F2610) 
....................         #define __18F2610 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2610.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2610_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2620) || (getenv("DEVICE")=="PIC18F2620") 
....................     #if !defined(__18F2620) 
....................         #define __18F2620 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2620.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2680) || (getenv("DEVICE")=="PIC18F2680") 
....................     #if !defined(__18F2680) 
....................         #define __18F2680 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2680.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2680_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2682) || (getenv("DEVICE")=="PIC18F2682") 
....................     #if !defined(__18F2682) 
....................         #define __18F2682 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2682.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2682_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F2685) || (getenv("DEVICE")=="PIC18F2685") 
....................     #if !defined(__18F2685) 
....................         #define __18F2685 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F2685.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F2685_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26J11) || (getenv("DEVICE")=="PIC18F26J11") 
....................     #if !defined(__18F26J11) 
....................         #define __18F26J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26J13) || (getenv("DEVICE")=="PIC18F26J13") 
....................     #if !defined(__18F26J13) 
....................         #define __18F26J13 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26J13.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26J13_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26J50) || (getenv("DEVICE")=="PIC18F26J50") 
....................     #if !defined(__18F26J50) 
....................         #define __18F26J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26J53) || (getenv("DEVICE")=="PIC18F26J53") 
....................     #if !defined(__18F26J53) 
....................         #define __18F26J53 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26J53.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26J53_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26K20) || (getenv("DEVICE")=="PIC18F26K20") 
....................     #if !defined(__18F26K20) 
....................         #define __18F26K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26K22) || (getenv("DEVICE")=="PIC18F26K22") 
....................     #if !defined(__18F26K22) 
....................         #define __18F26K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F26K80) || (getenv("DEVICE")=="PIC18F26K80") 
....................     #if !defined(__18F26K80) 
....................         #define __18F26K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F26K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F26K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F27J13) || (getenv("DEVICE")=="PIC18F27J13") 
....................     #if !defined(__18F27J13) 
....................         #define __18F27J13 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F27J13.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F27J13_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F27J53) || (getenv("DEVICE")=="PIC18F27J53") 
....................     #if !defined(__18F27J53) 
....................         #define __18F27J53 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F27J53.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F27J53_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4220) || (getenv("DEVICE")=="PIC18F4220") 
....................     #if !defined(__18F4220) 
....................         #define __18F4220 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4220.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4220_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4221) || (getenv("DEVICE")=="PIC18F4221") 
....................     #if !defined(__18F4221) 
....................         #define __18F4221 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4221.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4221_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4320) || (getenv("DEVICE")=="PIC18F4320") 
....................     #if !defined(__18F4320) 
....................         #define __18F4320 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4320.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4320_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4321) || (getenv("DEVICE")=="PIC18F4321") 
....................     #if !defined(__18F4321) 
....................         #define __18F4321 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4321.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4321_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4331) || (getenv("DEVICE")=="PIC18F4331") 
....................     #if !defined(__18F4331) 
....................         #define __18F4331 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4331.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4331_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F43K20) || (getenv("DEVICE")=="PIC18F43K20") 
....................     #if !defined(__18F43K20) 
....................         #define __18F43K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F43K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F43K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F43K22) || (getenv("DEVICE")=="PIC18F43K22") 
....................     #if !defined(__18F43K22) 
....................         #define __18F43K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F43K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F43K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4410) || (getenv("DEVICE")=="PIC18F4410") 
....................     #if !defined(__18F4410) 
....................         #define __18F4410 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4410.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4410_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F442) || (getenv("DEVICE")=="PIC18F442") 
....................     #if !defined(__18F442) 
....................         #define __18F442 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F442.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F442_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4420) || (getenv("DEVICE")=="PIC18F4420") 
....................     #if !defined(__18F4420) 
....................         #define __18F4420 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4420.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4420_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4423) || (getenv("DEVICE")=="PIC18F4423") 
....................     #if !defined(__18F4423) 
....................         #define __18F4423 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4423.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4423_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4431) || (getenv("DEVICE")=="PIC18F4431") 
....................     #if !defined(__18F4431) 
....................         #define __18F4431 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4431.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4431_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4439) || (getenv("DEVICE")=="PIC18F4439") 
....................     #if !defined(__18F4439) 
....................         #define __18F4439 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4439.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4439_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4450) || (getenv("DEVICE")=="PIC18F4450") 
....................     #if !defined(__18F4450) 
....................         #define __18F4450 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4450.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4450_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4455) || (getenv("DEVICE")=="PIC18F4455") 
....................     #if !defined(__18F4455) 
....................         #define __18F4455 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4455.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4455_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4458) || (getenv("DEVICE")=="PIC18F4458") 
....................     #if !defined(__18F4458) 
....................         #define __18F4458 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4458.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4458_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F448) || (getenv("DEVICE")=="PIC18F448") 
....................     #if !defined(__18F448) 
....................         #define __18F448 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F448.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F448_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4480) || (getenv("DEVICE")=="PIC18F4480") 
....................     #if !defined(__18F4480) 
....................         #define __18F4480 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4480.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4480_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F44J10) || (getenv("DEVICE")=="PIC18F44J10") 
....................     #if !defined(__18F44J10) 
....................         #define __18F44J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F44J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F44J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F44J11) || (getenv("DEVICE")=="PIC18F44J11") 
....................     #if !defined(__18F44J11) 
....................         #define __18F44J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F44J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F44J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F44J50) || (getenv("DEVICE")=="PIC18F44J50") 
....................     #if !defined(__18F44J50) 
....................         #define __18F44J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F44J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F44J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F44K20) || (getenv("DEVICE")=="PIC18F44K20") 
....................     #if !defined(__18F44K20) 
....................         #define __18F44K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F44K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F44K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F44K22) || (getenv("DEVICE")=="PIC18F44K22") 
....................     #if !defined(__18F44K22) 
....................         #define __18F44K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F44K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F44K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4510) || (getenv("DEVICE")=="PIC18F4510") 
....................     #if !defined(__18F4510) 
....................         #define __18F4510 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4510.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4515) || (getenv("DEVICE")=="PIC18F4515") 
....................     #if !defined(__18F4515) 
....................         #define __18F4515 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4515.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4515_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F452) || (getenv("DEVICE")=="PIC18F452") 
....................     #if !defined(__18F452) 
....................         #define __18F452 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F452.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F452_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4520) || (getenv("DEVICE")=="PIC18F4520") 
....................     #if !defined(__18F4520) 
....................         #define __18F4520 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4520.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4520_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4523) || (getenv("DEVICE")=="PIC18F4523") 
....................     #if !defined(__18F4523) 
....................         #define __18F4523 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4523.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4523_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4525) || (getenv("DEVICE")=="PIC18F4525") 
....................     #if !defined(__18F4525) 
....................         #define __18F4525 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4525.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4525_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4539) || (getenv("DEVICE")=="PIC18F4539") 
....................     #if !defined(__18F4539) 
....................         #define __18F4539 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4539.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4539_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4550) || (getenv("DEVICE")=="PIC18F4550") 
....................     #if !defined(__18F4550) 
....................         #define __18F4550 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4550.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4550_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4553) || (getenv("DEVICE")=="PIC18F4553") 
....................     #if !defined(__18F4553) 
....................         #define __18F4553 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4553.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4553_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F458) || (getenv("DEVICE")=="PIC18F458") 
....................     #if !defined(__18F458) 
....................         #define __18F458 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F458.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F458_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4580) || (getenv("DEVICE")=="PIC18F4580") 
....................     #if !defined(__18F4580) 
....................         #define __18F4580 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4580.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4580_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4585) || (getenv("DEVICE")=="PIC18F4585") 
....................     #if !defined(__18F4585) 
....................         #define __18F4585 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4585.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4585_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45J10) || (getenv("DEVICE")=="PIC18F45J10") 
....................     #if !defined(__18F45J10) 
....................         #define __18F45J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45J11) || (getenv("DEVICE")=="PIC18F45J11") 
....................     #if !defined(__18F45J11) 
....................         #define __18F45J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45J50) || (getenv("DEVICE")=="PIC18F45J50") 
....................     #if !defined(__18F45J50) 
....................         #define __18F45J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45K20) || (getenv("DEVICE")=="PIC18F45K20") 
....................     #if !defined(__18F45K20) 
....................         #define __18F45K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45K22) || (getenv("DEVICE")=="PIC18F45K22") 
....................     #if !defined(__18F45K22) 
....................         #define __18F45K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45K50) || (getenv("DEVICE")=="PIC18F45K50") 
....................     #if !defined(__18F45K50) 
....................         #define __18F45K50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45K50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45K50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F45K80) || (getenv("DEVICE")=="PIC18F45K80") 
....................     #if !defined(__18F45K80) 
....................         #define __18F45K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F45K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F45K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4610) || (getenv("DEVICE")=="PIC18F4610") 
....................     #if !defined(__18F4610) 
....................         #define __18F4610 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4610.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4610_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4620) || (getenv("DEVICE")=="PIC18F4620") 
....................     #if !defined(__18F4620) 
....................         #define __18F4620 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4620.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4680) || (getenv("DEVICE")=="PIC18F4680") 
....................     #if !defined(__18F4680) 
....................         #define __18F4680 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4680.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4680_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4682) || (getenv("DEVICE")=="PIC18F4682") 
....................     #if !defined(__18F4682) 
....................         #define __18F4682 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4682.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4682_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F4685) || (getenv("DEVICE")=="PIC18F4685") 
....................     #if !defined(__18F4685) 
....................         #define __18F4685 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F4685.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F4685_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46J11) || (getenv("DEVICE")=="PIC18F46J11") 
....................     #if !defined(__18F46J11) 
....................         #define __18F46J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46J13) || (getenv("DEVICE")=="PIC18F46J13") 
....................     #if !defined(__18F46J13) 
....................         #define __18F46J13 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46J13.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46J13_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46J50) || (getenv("DEVICE")=="PIC18F46J50") 
....................     #if !defined(__18F46J50) 
....................         #define __18F46J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46J53) || (getenv("DEVICE")=="PIC18F46J53") 
....................     #if !defined(__18F46J53) 
....................         #define __18F46J53 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46J53.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46J53_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46K20) || (getenv("DEVICE")=="PIC18F46K20") 
....................     #if !defined(__18F46K20) 
....................         #define __18F46K20 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46K20.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46K20_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46K22) || (getenv("DEVICE")=="PIC18F46K22") 
....................     #if !defined(__18F46K22) 
....................         #define __18F46K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F46K80) || (getenv("DEVICE")=="PIC18F46K80") 
....................     #if !defined(__18F46K80) 
....................         #define __18F46K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F46K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F46K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F47J13) || (getenv("DEVICE")=="PIC18F47J13") 
....................     #if !defined(__18F47J13) 
....................         #define __18F47J13 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F47J13.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F47J13_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F47J53) || (getenv("DEVICE")=="PIC18F47J53") 
....................     #if !defined(__18F47J53) 
....................         #define __18F47J53 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F47J53.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F47J53_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6310) || (getenv("DEVICE")=="PIC18F6310") 
....................     #if !defined(__18F6310) 
....................         #define __18F6310 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6310.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6390) || (getenv("DEVICE")=="PIC18F6390") 
....................     #if !defined(__18F6390) 
....................         #define __18F6390 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6390.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6390_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6393) || (getenv("DEVICE")=="PIC18F6393") 
....................     #if !defined(__18F6393) 
....................         #define __18F6393 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6393.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6393_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F63J11) || (getenv("DEVICE")=="PIC18F63J11") 
....................     #if !defined(__18F63J11) 
....................         #define __18F63J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F63J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F63J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F63J90) || (getenv("DEVICE")=="PIC18F63J90") 
....................     #if !defined(__18F63J90) 
....................         #define __18F63J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F63J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F63J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6410) || (getenv("DEVICE")=="PIC18F6410") 
....................     #if !defined(__18F6410) 
....................         #define __18F6410 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6410.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6410_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6490) || (getenv("DEVICE")=="PIC18F6490") 
....................     #if !defined(__18F6490) 
....................         #define __18F6490 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6490.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6490_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6493) || (getenv("DEVICE")=="PIC18F6493") 
....................     #if !defined(__18F6493) 
....................         #define __18F6493 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6493.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6493_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F64J11) || (getenv("DEVICE")=="PIC18F64J11") 
....................     #if !defined(__18F64J11) 
....................         #define __18F64J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F64J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F64J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F64J90) || (getenv("DEVICE")=="PIC18F64J90") 
....................     #if !defined(__18F64J90) 
....................         #define __18F64J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F64J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F64J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6520) || (getenv("DEVICE")=="PIC18F6520") 
....................     #if !defined(__18F6520) 
....................         #define __18F6520 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6520.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6520_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6525) || (getenv("DEVICE")=="PIC18F6525") 
....................     #if !defined(__18F6525) 
....................         #define __18F6525 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6525.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6525_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6527) || (getenv("DEVICE")=="PIC18F6527") 
....................     #if !defined(__18F6527) 
....................         #define __18F6527 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6527.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6527_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6585) || (getenv("DEVICE")=="PIC18F6585") 
....................     #if !defined(__18F6585) 
....................         #define __18F6585 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6585.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6585_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J10) || (getenv("DEVICE")=="PIC18F65J10") 
....................     #if !defined(__18F65J10) 
....................         #define __18F65J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J11) || (getenv("DEVICE")=="PIC18F65J11") 
....................     #if !defined(__18F65J11) 
....................         #define __18F65J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J15) || (getenv("DEVICE")=="PIC18F65J15") 
....................     #if !defined(__18F65J15) 
....................         #define __18F65J15 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J15.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J15_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J50) || (getenv("DEVICE")=="PIC18F65J50") 
....................     #if !defined(__18F65J50) 
....................         #define __18F65J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J90) || (getenv("DEVICE")=="PIC18F65J90") 
....................     #if !defined(__18F65J90) 
....................         #define __18F65J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65J94) || (getenv("DEVICE")=="PIC18F65J94") 
....................     #if !defined(__18F65J94) 
....................         #define __18F65J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65K22) || (getenv("DEVICE")=="PIC18F65K22") 
....................     #if !defined(__18F65K22) 
....................         #define __18F65K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65K80) || (getenv("DEVICE")=="PIC18F65K80") 
....................     #if !defined(__18F65K80) 
....................         #define __18F65K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F65K90) || (getenv("DEVICE")=="PIC18F65K90") 
....................     #if !defined(__18F65K90) 
....................         #define __18F65K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F65K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F65K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6620) || (getenv("DEVICE")=="PIC18F6620") 
....................     #if !defined(__18F6620) 
....................         #define __18F6620 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6620.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6621) || (getenv("DEVICE")=="PIC18F6621") 
....................     #if !defined(__18F6621) 
....................         #define __18F6621 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6621.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6621_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6622) || (getenv("DEVICE")=="PIC18F6622") 
....................     #if !defined(__18F6622) 
....................         #define __18F6622 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6622.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6622_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6627) || (getenv("DEVICE")=="PIC18F6627") 
....................     #if !defined(__18F6627) 
....................         #define __18F6627 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6627.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6627_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6628) || (getenv("DEVICE")=="PIC18F6628") 
....................     #if !defined(__18F6628) 
....................         #define __18F6628 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6628.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6628_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6680) || (getenv("DEVICE")=="PIC18F6680") 
....................     #if !defined(__18F6680) 
....................         #define __18F6680 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6680.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6680_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J10) || (getenv("DEVICE")=="PIC18F66J10") 
....................     #if !defined(__18F66J10) 
....................         #define __18F66J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J11) || (getenv("DEVICE")=="PIC18F66J11") 
....................     #if !defined(__18F66J11) 
....................         #define __18F66J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J15) || (getenv("DEVICE")=="PIC18F66J15") 
....................     #if !defined(__18F66J15) 
....................         #define __18F66J15 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J15.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J15_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J16) || (getenv("DEVICE")=="PIC18F66J16") 
....................     #if !defined(__18F66J16) 
....................         #define __18F66J16 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J16.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J16_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J50) || (getenv("DEVICE")=="PIC18F66J50") 
....................     #if !defined(__18F66J50) 
....................         #define __18F66J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J55) || (getenv("DEVICE")=="PIC18F66J55") 
....................     #if !defined(__18F66J55) 
....................         #define __18F66J55 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J55.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J55_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J60) || (getenv("DEVICE")=="PIC18F66J60") 
....................     #if !defined(__18F66J60) 
....................         #define __18F66J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J65) || (getenv("DEVICE")=="PIC18F66J65") 
....................     #if !defined(__18F66J65) 
....................         #define __18F66J65 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J65.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J65_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J90) || (getenv("DEVICE")=="PIC18F66J90") 
....................     #if !defined(__18F66J90) 
....................         #define __18F66J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J93) || (getenv("DEVICE")=="PIC18F66J93") 
....................     #if !defined(__18F66J93) 
....................         #define __18F66J93 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J93.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J93_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J94) || (getenv("DEVICE")=="PIC18F66J94") 
....................     #if !defined(__18F66J94) 
....................         #define __18F66J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66J99) || (getenv("DEVICE")=="PIC18F66J99") 
....................     #if !defined(__18F66J99) 
....................         #define __18F66J99 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66J99.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66J99_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66K22) || (getenv("DEVICE")=="PIC18F66K22") 
....................     #if !defined(__18F66K22) 
....................         #define __18F66K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66K80) || (getenv("DEVICE")=="PIC18F66K80") 
....................     #if !defined(__18F66K80) 
....................         #define __18F66K80 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66K80.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66K80_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F66K90) || (getenv("DEVICE")=="PIC18F66K90") 
....................     #if !defined(__18F66K90) 
....................         #define __18F66K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F66K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F66K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6720) || (getenv("DEVICE")=="PIC18F6720") 
....................     #if !defined(__18F6720) 
....................         #define __18F6720 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6720.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6720_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6722) || (getenv("DEVICE")=="PIC18F6722") 
....................     #if !defined(__18F6722) 
....................         #define __18F6722 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6722.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6722_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F6723) || (getenv("DEVICE")=="PIC18F6723") 
....................     #if !defined(__18F6723) 
....................         #define __18F6723 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F6723.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F6723_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J10) || (getenv("DEVICE")=="PIC18F67J10") 
....................     #if !defined(__18F67J10) 
....................         #define __18F67J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J11) || (getenv("DEVICE")=="PIC18F67J11") 
....................     #if !defined(__18F67J11) 
....................         #define __18F67J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J50) || (getenv("DEVICE")=="PIC18F67J50") 
....................     #if !defined(__18F67J50) 
....................         #define __18F67J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J60) || (getenv("DEVICE")=="PIC18F67J60") 
....................     #if !defined(__18F67J60) 
....................         #define __18F67J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J90) || (getenv("DEVICE")=="PIC18F67J90") 
....................     #if !defined(__18F67J90) 
....................         #define __18F67J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J93) || (getenv("DEVICE")=="PIC18F67J93") 
....................     #if !defined(__18F67J93) 
....................         #define __18F67J93 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J93.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J93_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67J94) || (getenv("DEVICE")=="PIC18F67J94") 
....................     #if !defined(__18F67J94) 
....................         #define __18F67J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67K22) || (getenv("DEVICE")=="PIC18F67K22") 
....................     #if !defined(__18F67K22) 
....................         #define __18F67K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F67K90) || (getenv("DEVICE")=="PIC18F67K90") 
....................     #if !defined(__18F67K90) 
....................         #define __18F67K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F67K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F67K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8310) || (getenv("DEVICE")=="PIC18F8310") 
....................     #if !defined(__18F8310) 
....................         #define __18F8310 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8310.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8390) || (getenv("DEVICE")=="PIC18F8390") 
....................     #if !defined(__18F8390) 
....................         #define __18F8390 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8390.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8390_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8393) || (getenv("DEVICE")=="PIC18F8393") 
....................     #if !defined(__18F8393) 
....................         #define __18F8393 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8393.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8393_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F83J11) || (getenv("DEVICE")=="PIC18F83J11") 
....................     #if !defined(__18F83J11) 
....................         #define __18F83J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F83J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F83J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F83J90) || (getenv("DEVICE")=="PIC18F83J90") 
....................     #if !defined(__18F83J90) 
....................         #define __18F83J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F83J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F83J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8410) || (getenv("DEVICE")=="PIC18F8410") 
....................     #if !defined(__18F8410) 
....................         #define __18F8410 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8410.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8410_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8490) || (getenv("DEVICE")=="PIC18F8490") 
....................     #if !defined(__18F8490) 
....................         #define __18F8490 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8490.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8490_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8493) || (getenv("DEVICE")=="PIC18F8493") 
....................     #if !defined(__18F8493) 
....................         #define __18F8493 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8493.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8493_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F84J11) || (getenv("DEVICE")=="PIC18F84J11") 
....................     #if !defined(__18F84J11) 
....................         #define __18F84J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F84J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F84J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F84J90) || (getenv("DEVICE")=="PIC18F84J90") 
....................     #if !defined(__18F84J90) 
....................         #define __18F84J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F84J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F84J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8520) || (getenv("DEVICE")=="PIC18F8520") 
....................     #if !defined(__18F8520) 
....................         #define __18F8520 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8520.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8520_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8525) || (getenv("DEVICE")=="PIC18F8525") 
....................     #if !defined(__18F8525) 
....................         #define __18F8525 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8525.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8525_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8527) || (getenv("DEVICE")=="PIC18F8527") 
....................     #if !defined(__18F8527) 
....................         #define __18F8527 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8527.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8527_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8585) || (getenv("DEVICE")=="PIC18F8585") 
....................     #if !defined(__18F8585) 
....................         #define __18F8585 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8585.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8585_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J10) || (getenv("DEVICE")=="PIC18F85J10") 
....................     #if !defined(__18F85J10) 
....................         #define __18F85J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J11) || (getenv("DEVICE")=="PIC18F85J11") 
....................     #if !defined(__18F85J11) 
....................         #define __18F85J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J15) || (getenv("DEVICE")=="PIC18F85J15") 
....................     #if !defined(__18F85J15) 
....................         #define __18F85J15 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J15.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J15_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J50) || (getenv("DEVICE")=="PIC18F85J50") 
....................     #if !defined(__18F85J50) 
....................         #define __18F85J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J90) || (getenv("DEVICE")=="PIC18F85J90") 
....................     #if !defined(__18F85J90) 
....................         #define __18F85J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85J94) || (getenv("DEVICE")=="PIC18F85J94") 
....................     #if !defined(__18F85J94) 
....................         #define __18F85J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85K22) || (getenv("DEVICE")=="PIC18F85K22") 
....................     #if !defined(__18F85K22) 
....................         #define __18F85K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F85K90) || (getenv("DEVICE")=="PIC18F85K90") 
....................     #if !defined(__18F85K90) 
....................         #define __18F85K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F85K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F85K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8620) || (getenv("DEVICE")=="PIC18F8620") 
....................     #if !defined(__18F8620) 
....................         #define __18F8620 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8620.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8620_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8621) || (getenv("DEVICE")=="PIC18F8621") 
....................     #if !defined(__18F8621) 
....................         #define __18F8621 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8621.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8621_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8622) || (getenv("DEVICE")=="PIC18F8622") 
....................     #if !defined(__18F8622) 
....................         #define __18F8622 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8622.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8622_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8627) || (getenv("DEVICE")=="PIC18F8627") 
....................     #if !defined(__18F8627) 
....................         #define __18F8627 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8627.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8627_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8628) || (getenv("DEVICE")=="PIC18F8628") 
....................     #if !defined(__18F8628) 
....................         #define __18F8628 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8628.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8628_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8680) || (getenv("DEVICE")=="PIC18F8680") 
....................     #if !defined(__18F8680) 
....................         #define __18F8680 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8680.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8680_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J10) || (getenv("DEVICE")=="PIC18F86J10") 
....................     #if !defined(__18F86J10) 
....................         #define __18F86J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J11) || (getenv("DEVICE")=="PIC18F86J11") 
....................     #if !defined(__18F86J11) 
....................         #define __18F86J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J15) || (getenv("DEVICE")=="PIC18F86J15") 
....................     #if !defined(__18F86J15) 
....................         #define __18F86J15 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J15.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J15_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J16) || (getenv("DEVICE")=="PIC18F86J16") 
....................     #if !defined(__18F86J16) 
....................         #define __18F86J16 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J16.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J16_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J50) || (getenv("DEVICE")=="PIC18F86J50") 
....................     #if !defined(__18F86J50) 
....................         #define __18F86J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J55) || (getenv("DEVICE")=="PIC18F86J55") 
....................     #if !defined(__18F86J55) 
....................         #define __18F86J55 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J55.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J55_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J60) || (getenv("DEVICE")=="PIC18F86J60") 
....................     #if !defined(__18F86J60) 
....................         #define __18F86J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J65) || (getenv("DEVICE")=="PIC18F86J65") 
....................     #if !defined(__18F86J65) 
....................         #define __18F86J65 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J65.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J65_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J72) || (getenv("DEVICE")=="PIC18F86J72") 
....................     #if !defined(__18F86J72) 
....................         #define __18F86J72 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J72.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J72_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J90) || (getenv("DEVICE")=="PIC18F86J90") 
....................     #if !defined(__18F86J90) 
....................         #define __18F86J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J93) || (getenv("DEVICE")=="PIC18F86J93") 
....................     #if !defined(__18F86J93) 
....................         #define __18F86J93 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J93.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J93_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J94) || (getenv("DEVICE")=="PIC18F86J94") 
....................     #if !defined(__18F86J94) 
....................         #define __18F86J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86J99) || (getenv("DEVICE")=="PIC18F86J99") 
....................     #if !defined(__18F86J99) 
....................         #define __18F86J99 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86J99.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86J99_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86K22) || (getenv("DEVICE")=="PIC18F86K22") 
....................     #if !defined(__18F86K22) 
....................         #define __18F86K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F86K90) || (getenv("DEVICE")=="PIC18F86K90") 
....................     #if !defined(__18F86K90) 
....................         #define __18F86K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F86K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F86K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8720) || (getenv("DEVICE")=="PIC18F8720") 
....................     #if !defined(__18F8720) 
....................         #define __18F8720 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8720.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8720_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8722) || (getenv("DEVICE")=="PIC18F8722") 
....................     #if !defined(__18F8722) 
....................         #define __18F8722 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8722.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8722_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F8723) || (getenv("DEVICE")=="PIC18F8723") 
....................     #if !defined(__18F8723) 
....................         #define __18F8723 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F8723.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F8723_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J10) || (getenv("DEVICE")=="PIC18F87J10") 
....................     #if !defined(__18F87J10) 
....................         #define __18F87J10 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J10.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J10_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J11) || (getenv("DEVICE")=="PIC18F87J11") 
....................     #if !defined(__18F87J11) 
....................         #define __18F87J11 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J11.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J11_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J50) || (getenv("DEVICE")=="PIC18F87J50") 
....................     #if !defined(__18F87J50) 
....................         #define __18F87J50 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J50.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J50_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J60) || (getenv("DEVICE")=="PIC18F87J60") 
....................     #if !defined(__18F87J60) 
....................         #define __18F87J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J72) || (getenv("DEVICE")=="PIC18F87J72") 
....................     #if !defined(__18F87J72) 
....................         #define __18F87J72 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J72.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J72_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J90) || (getenv("DEVICE")=="PIC18F87J90") 
....................     #if !defined(__18F87J90) 
....................         #define __18F87J90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J93) || (getenv("DEVICE")=="PIC18F87J93") 
....................     #if !defined(__18F87J93) 
....................         #define __18F87J93 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J93.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J93_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87J94) || (getenv("DEVICE")=="PIC18F87J94") 
....................     #if !defined(__18F87J94) 
....................         #define __18F87J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87K22) || (getenv("DEVICE")=="PIC18F87K22") 
....................     #if !defined(__18F87K22) 
....................         #define __18F87K22 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87K22.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87K22_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F87K90) || (getenv("DEVICE")=="PIC18F87K90") 
....................     #if !defined(__18F87K90) 
....................         #define __18F87K90 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F87K90.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F87K90_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F95J94) || (getenv("DEVICE")=="PIC18F95J94") 
....................     #if !defined(__18F95J94) 
....................         #define __18F95J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F95J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F95J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F96J60) || (getenv("DEVICE")=="PIC18F96J60") 
....................     #if !defined(__18F96J60) 
....................         #define __18F96J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F96J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F96J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F96J65) || (getenv("DEVICE")=="PIC18F96J65") 
....................     #if !defined(__18F96J65) 
....................         #define __18F96J65 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F96J65.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F96J65_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F96J94) || (getenv("DEVICE")=="PIC18F96J94") 
....................     #if !defined(__18F96J94) 
....................         #define __18F96J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F96J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F96J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F96J99) || (getenv("DEVICE")=="PIC18F96J99") 
....................     #if !defined(__18F96J99) 
....................         #define __18F96J99 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F96J99.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F96J99_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || (getenv("DEVICE")=="PIC18F97J60") 
....................     #if !defined(__18F97J60) 
....................         #define __18F97J60 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F97J60.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F97J60_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F97J94) || (getenv("DEVICE")=="PIC18F97J94") 
....................     #if !defined(__18F97J94) 
....................         #define __18F97J94 
....................     #endif 
....................     #if !defined(GLOBAL) 
....................         #include <18F97J94.h> 
....................     #endif 
....................     #if !defined(__18CXX) 
....................         #define __18CXX 
....................     #endif 
....................     #include "18F97J94_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC19111__) || (getenv("DEVICE")=="DSPIC19111") 
....................     #if !defined(__dsPIC19111__) 
....................         #define __dsPIC19111__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <19111.h> 
....................     #endif 
....................     #if !defined(__dsPIC191111__) 
....................         #define __dsPIC191111__ 
....................     #endif 
....................     #include "19111_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128GP202__) || (getenv("DEVICE")=="PIC24EP128GP202") 
....................     #if !defined(__PIC24EP128GP202__) 
....................         #define __PIC24EP128GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128GP204__) || (getenv("DEVICE")=="PIC24EP128GP204") 
....................     #if !defined(__PIC24EP128GP204__) 
....................         #define __PIC24EP128GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128GP206__) || (getenv("DEVICE")=="PIC24EP128GP206") 
....................     #if !defined(__PIC24EP128GP206__) 
....................         #define __PIC24EP128GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128MC202__) || (getenv("DEVICE")=="PIC24EP128MC202") 
....................     #if !defined(__PIC24EP128MC202__) 
....................         #define __PIC24EP128MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128MC202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128MC204__) || (getenv("DEVICE")=="PIC24EP128MC204") 
....................     #if !defined(__PIC24EP128MC204__) 
....................         #define __PIC24EP128MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128MC204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP128MC206__) || (getenv("DEVICE")=="PIC24EP128MC206") 
....................     #if !defined(__PIC24EP128MC206__) 
....................         #define __PIC24EP128MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP128MC206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP128MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256GP202__) || (getenv("DEVICE")=="PIC24EP256GP202") 
....................     #if !defined(__PIC24EP256GP202__) 
....................         #define __PIC24EP256GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256GP204__) || (getenv("DEVICE")=="PIC24EP256GP204") 
....................     #if !defined(__PIC24EP256GP204__) 
....................         #define __PIC24EP256GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256GP206__) || (getenv("DEVICE")=="PIC24EP256GP206") 
....................     #if !defined(__PIC24EP256GP206__) 
....................         #define __PIC24EP256GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256GU810__) || (getenv("DEVICE")=="PIC24EP256GU810") 
....................     #if !defined(__PIC24EP256GU810__) 
....................         #define __PIC24EP256GU810__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256GU810.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256GU810_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256GU814__) || (getenv("DEVICE")=="PIC24EP256GU814") 
....................     #if !defined(__PIC24EP256GU814__) 
....................         #define __PIC24EP256GU814__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256GU814.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256GU814_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256MC202__) || (getenv("DEVICE")=="PIC24EP256MC202") 
....................     #if !defined(__PIC24EP256MC202__) 
....................         #define __PIC24EP256MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256MC202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256MC204__) || (getenv("DEVICE")=="PIC24EP256MC204") 
....................     #if !defined(__PIC24EP256MC204__) 
....................         #define __PIC24EP256MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256MC204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP256MC206__) || (getenv("DEVICE")=="PIC24EP256MC206") 
....................     #if !defined(__PIC24EP256MC206__) 
....................         #define __PIC24EP256MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP256MC206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP256MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32GP202__) || (getenv("DEVICE")=="PIC24EP32GP202") 
....................     #if !defined(__PIC24EP32GP202__) 
....................         #define __PIC24EP32GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32GP203__) || (getenv("DEVICE")=="PIC24EP32GP203") 
....................     #if !defined(__PIC24EP32GP203__) 
....................         #define __PIC24EP32GP203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32GP203.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32GP203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32GP204__) || (getenv("DEVICE")=="PIC24EP32GP204") 
....................     #if !defined(__PIC24EP32GP204__) 
....................         #define __PIC24EP32GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32MC202__) || (getenv("DEVICE")=="PIC24EP32MC202") 
....................     #if !defined(__PIC24EP32MC202__) 
....................         #define __PIC24EP32MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32MC202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32MC203__) || (getenv("DEVICE")=="PIC24EP32MC203") 
....................     #if !defined(__PIC24EP32MC203__) 
....................         #define __PIC24EP32MC203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32MC203.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32MC203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP32MC204__) || (getenv("DEVICE")=="PIC24EP32MC204") 
....................     #if !defined(__PIC24EP32MC204__) 
....................         #define __PIC24EP32MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP32MC204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP32MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP512GP806__) || (getenv("DEVICE")=="PIC24EP512GP806") 
....................     #if !defined(__PIC24EP512GP806__) 
....................         #define __PIC24EP512GP806__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP512GP806.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP512GP806_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP512GU810__) || (getenv("DEVICE")=="PIC24EP512GU810") 
....................     #if !defined(__PIC24EP512GU810__) 
....................         #define __PIC24EP512GU810__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP512GU810.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP512GU810_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP512GU814__) || (getenv("DEVICE")=="PIC24EP512GU814") 
....................     #if !defined(__PIC24EP512GU814__) 
....................         #define __PIC24EP512GU814__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP512GU814.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP512GU814_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64GP202__) || (getenv("DEVICE")=="PIC24EP64GP202") 
....................     #if !defined(__PIC24EP64GP202__) 
....................         #define __PIC24EP64GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64GP203__) || (getenv("DEVICE")=="PIC24EP64GP203") 
....................     #if !defined(__PIC24EP64GP203__) 
....................         #define __PIC24EP64GP203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64GP203.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64GP203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64GP204__) || (getenv("DEVICE")=="PIC24EP64GP204") 
....................     #if !defined(__PIC24EP64GP204__) 
....................         #define __PIC24EP64GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64GP206__) || (getenv("DEVICE")=="PIC24EP64GP206") 
....................     #if !defined(__PIC24EP64GP206__) 
....................         #define __PIC24EP64GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64MC202__) || (getenv("DEVICE")=="PIC24EP64MC202") 
....................     #if !defined(__PIC24EP64MC202__) 
....................         #define __PIC24EP64MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64MC202.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64MC203__) || (getenv("DEVICE")=="PIC24EP64MC203") 
....................     #if !defined(__PIC24EP64MC203__) 
....................         #define __PIC24EP64MC203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64MC203.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64MC203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64MC204__) || (getenv("DEVICE")=="PIC24EP64MC204") 
....................     #if !defined(__PIC24EP64MC204__) 
....................         #define __PIC24EP64MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64MC204.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24EP64MC206__) || (getenv("DEVICE")=="PIC24EP64MC206") 
....................     #if !defined(__PIC24EP64MC206__) 
....................         #define __PIC24EP64MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24EP64MC206.h> 
....................     #endif 
....................     #if !defined(__PIC24E__) 
....................         #define __PIC24E__ 
....................     #endif 
....................     #include "24EP64MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F04KA200__) || (getenv("DEVICE")=="PIC24F04KA200") 
....................     #if !defined(__PIC24F04KA200__) 
....................         #define __PIC24F04KA200__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F04KA200.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F04KA200_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F04KA201__) || (getenv("DEVICE")=="PIC24F04KA201") 
....................     #if !defined(__PIC24F04KA201__) 
....................         #define __PIC24F04KA201__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F04KA201.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F04KA201_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F04KL100__) || (getenv("DEVICE")=="PIC24F04KL100") 
....................     #if !defined(__PIC24F04KL100__) 
....................         #define __PIC24F04KL100__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F04KL100.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F04KL100_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F04KL101__) || (getenv("DEVICE")=="PIC24F04KL101") 
....................     #if !defined(__PIC24F04KL101__) 
....................         #define __PIC24F04KL101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F04KL101.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F04KL101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KA101__) || (getenv("DEVICE")=="PIC24F08KA101") 
....................     #if !defined(__PIC24F08KA101__) 
....................         #define __PIC24F08KA101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KA101.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F08KA101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KA102__) || (getenv("DEVICE")=="PIC24F08KA102") 
....................     #if !defined(__PIC24F08KA102__) 
....................         #define __PIC24F08KA102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KA102.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F08KA102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL200__) || (getenv("DEVICE")=="PIC24F08KL200") 
....................     #if !defined(__PIC24F08KL200__) 
....................         #define __PIC24F08KL200__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL200.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL200_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL201__) || (getenv("DEVICE")=="PIC24F08KL201") 
....................     #if !defined(__PIC24F08KL201__) 
....................         #define __PIC24F08KL201__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL201.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL201_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL301__) || (getenv("DEVICE")=="PIC24F08KL301") 
....................     #if !defined(__PIC24F08KL301__) 
....................         #define __PIC24F08KL301__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL301.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL301_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL302__) || (getenv("DEVICE")=="PIC24F08KL302") 
....................     #if !defined(__PIC24F08KL302__) 
....................         #define __PIC24F08KL302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL302.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL401__) || (getenv("DEVICE")=="PIC24F08KL401") 
....................     #if !defined(__PIC24F08KL401__) 
....................         #define __PIC24F08KL401__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL401.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL401_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KL402__) || (getenv("DEVICE")=="PIC24F08KL402") 
....................     #if !defined(__PIC24F08KL402__) 
....................         #define __PIC24F08KL402__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KL402.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KL402_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KM101__) || (getenv("DEVICE")=="PIC24F08KM101") 
....................     #if !defined(__PIC24F08KM101__) 
....................         #define __PIC24F08KM101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KM101.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KM101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KM102__) || (getenv("DEVICE")=="PIC24F08KM102") 
....................     #if !defined(__PIC24F08KM102__) 
....................         #define __PIC24F08KM102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KM102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KM102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KM202__) || (getenv("DEVICE")=="PIC24F08KM202") 
....................     #if !defined(__PIC24F08KM202__) 
....................         #define __PIC24F08KM202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KM202.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KM202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F08KM204__) || (getenv("DEVICE")=="PIC24F08KM204") 
....................     #if !defined(__PIC24F08KM204__) 
....................         #define __PIC24F08KM204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F08KM204.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F08KM204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KA101__) || (getenv("DEVICE")=="PIC24F16KA101") 
....................     #if !defined(__PIC24F16KA101__) 
....................         #define __PIC24F16KA101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KA101.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F16KA101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KA102__) || (getenv("DEVICE")=="PIC24F16KA102") 
....................     #if !defined(__PIC24F16KA102__) 
....................         #define __PIC24F16KA102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KA102.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F16KA102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KA301__) || (getenv("DEVICE")=="PIC24F16KA301") 
....................     #if !defined(__PIC24F16KA301__) 
....................         #define __PIC24F16KA301__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KA301.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F16KA301_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KA302__) || (getenv("DEVICE")=="PIC24F16KA302") 
....................     #if !defined(__PIC24F16KA302__) 
....................         #define __PIC24F16KA302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KA302.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F16KA302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KA304__) || (getenv("DEVICE")=="PIC24F16KA304") 
....................     #if !defined(__PIC24F16KA304__) 
....................         #define __PIC24F16KA304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KA304.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F16KA304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KL401__) || (getenv("DEVICE")=="PIC24F16KL401") 
....................     #if !defined(__PIC24F16KL401__) 
....................         #define __PIC24F16KL401__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KL401.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KL401_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KL402__) || (getenv("DEVICE")=="PIC24F16KL402") 
....................     #if !defined(__PIC24F16KL402__) 
....................         #define __PIC24F16KL402__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KL402.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KL402_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KM102__) || (getenv("DEVICE")=="PIC24F16KM102") 
....................     #if !defined(__PIC24F16KM102__) 
....................         #define __PIC24F16KM102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KM102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KM102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KM104__) || (getenv("DEVICE")=="PIC24F16KM104") 
....................     #if !defined(__PIC24F16KM104__) 
....................         #define __PIC24F16KM104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KM104.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KM104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KM202__) || (getenv("DEVICE")=="PIC24F16KM202") 
....................     #if !defined(__PIC24F16KM202__) 
....................         #define __PIC24F16KM202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KM202.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KM202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F16KM204__) || (getenv("DEVICE")=="PIC24F16KM204") 
....................     #if !defined(__PIC24F16KM204__) 
....................         #define __PIC24F16KM204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F16KM204.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24F16KM204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F32KA301__) || (getenv("DEVICE")=="PIC24F32KA301") 
....................     #if !defined(__PIC24F32KA301__) 
....................         #define __PIC24F32KA301__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F32KA301.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F32KA301_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F32KA302__) || (getenv("DEVICE")=="PIC24F32KA302") 
....................     #if !defined(__PIC24F32KA302__) 
....................         #define __PIC24F32KA302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F32KA302.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F32KA302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24F32KA304__) || (getenv("DEVICE")=="PIC24F32KA304") 
....................     #if !defined(__PIC24F32KA304__) 
....................         #define __PIC24F32KA304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24F32KA304.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24F32KA304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128DA106__) || (getenv("DEVICE")=="PIC24FJ128DA106") 
....................     #if !defined(__PIC24FJ128DA106__) 
....................         #define __PIC24FJ128DA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128DA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128DA106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128DA110__) || (getenv("DEVICE")=="PIC24FJ128DA110") 
....................     #if !defined(__PIC24FJ128DA110__) 
....................         #define __PIC24FJ128DA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128DA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128DA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128DA206__) || (getenv("DEVICE")=="PIC24FJ128DA206") 
....................     #if !defined(__PIC24FJ128DA206__) 
....................         #define __PIC24FJ128DA206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128DA206.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128DA206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128DA210__) || (getenv("DEVICE")=="PIC24FJ128DA210") 
....................     #if !defined(__PIC24FJ128DA210__) 
....................         #define __PIC24FJ128DA210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128DA210.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128DA210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA006__) || (getenv("DEVICE")=="PIC24FJ128GA006") 
....................     #if !defined(__PIC24FJ128GA006__) 
....................         #define __PIC24FJ128GA006__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA006.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA006_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA008__) || (getenv("DEVICE")=="PIC24FJ128GA008") 
....................     #if !defined(__PIC24FJ128GA008__) 
....................         #define __PIC24FJ128GA008__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA008.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA008_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA010__) || (getenv("DEVICE")=="PIC24FJ128GA010") 
....................     #if !defined(__PIC24FJ128GA010__) 
....................         #define __PIC24FJ128GA010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA010.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA106__) || (getenv("DEVICE")=="PIC24FJ128GA106") 
....................     #if !defined(__PIC24FJ128GA106__) 
....................         #define __PIC24FJ128GA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA108__) || (getenv("DEVICE")=="PIC24FJ128GA108") 
....................     #if !defined(__PIC24FJ128GA108__) 
....................         #define __PIC24FJ128GA108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA110__) || (getenv("DEVICE")=="PIC24FJ128GA110") 
....................     #if !defined(__PIC24FJ128GA110__) 
....................         #define __PIC24FJ128GA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA306__) || (getenv("DEVICE")=="PIC24FJ128GA306") 
....................     #if !defined(__PIC24FJ128GA306__) 
....................         #define __PIC24FJ128GA306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA306.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA308__) || (getenv("DEVICE")=="PIC24FJ128GA308") 
....................     #if !defined(__PIC24FJ128GA308__) 
....................         #define __PIC24FJ128GA308__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA308.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA308_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GA310__) || (getenv("DEVICE")=="PIC24FJ128GA310") 
....................     #if !defined(__PIC24FJ128GA310__) 
....................         #define __PIC24FJ128GA310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GA310.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GA310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GB106__) || (getenv("DEVICE")=="PIC24FJ128GB106") 
....................     #if !defined(__PIC24FJ128GB106__) 
....................         #define __PIC24FJ128GB106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GB106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GB106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GB108__) || (getenv("DEVICE")=="PIC24FJ128GB108") 
....................     #if !defined(__PIC24FJ128GB108__) 
....................         #define __PIC24FJ128GB108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GB108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GB108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GB110__) || (getenv("DEVICE")=="PIC24FJ128GB110") 
....................     #if !defined(__PIC24FJ128GB110__) 
....................         #define __PIC24FJ128GB110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GB110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GB110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GB206__) || (getenv("DEVICE")=="PIC24FJ128GB206") 
....................     #if !defined(__PIC24FJ128GB206__) 
....................         #define __PIC24FJ128GB206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GB206.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GB206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ128GB210__) || (getenv("DEVICE")=="PIC24FJ128GB210") 
....................     #if !defined(__PIC24FJ128GB210__) 
....................         #define __PIC24FJ128GB210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ128GB210.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ128GB210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ16GA002__) || (getenv("DEVICE")=="PIC24FJ16GA002") 
....................     #if !defined(__PIC24FJ16GA002__) 
....................         #define __PIC24FJ16GA002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ16GA002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ16GA002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ16GA004__) || (getenv("DEVICE")=="PIC24FJ16GA004") 
....................     #if !defined(__PIC24FJ16GA004__) 
....................         #define __PIC24FJ16GA004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ16GA004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ16GA004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ16MC101__) || (getenv("DEVICE")=="PIC24FJ16MC101") 
....................     #if !defined(__PIC24FJ16MC101__) 
....................         #define __PIC24FJ16MC101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ16MC101.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ16MC101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ16MC102__) || (getenv("DEVICE")=="PIC24FJ16MC102") 
....................     #if !defined(__PIC24FJ16MC102__) 
....................         #define __PIC24FJ16MC102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ16MC102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ16MC102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GA106__) || (getenv("DEVICE")=="PIC24FJ192GA106") 
....................     #if !defined(__PIC24FJ192GA106__) 
....................         #define __PIC24FJ192GA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GA106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GA108__) || (getenv("DEVICE")=="PIC24FJ192GA108") 
....................     #if !defined(__PIC24FJ192GA108__) 
....................         #define __PIC24FJ192GA108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GA108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GA108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GA110__) || (getenv("DEVICE")=="PIC24FJ192GA110") 
....................     #if !defined(__PIC24FJ192GA110__) 
....................         #define __PIC24FJ192GA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GB106__) || (getenv("DEVICE")=="PIC24FJ192GB106") 
....................     #if !defined(__PIC24FJ192GB106__) 
....................         #define __PIC24FJ192GB106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GB106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GB106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GB108__) || (getenv("DEVICE")=="PIC24FJ192GB108") 
....................     #if !defined(__PIC24FJ192GB108__) 
....................         #define __PIC24FJ192GB108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GB108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GB108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ192GB110__) || (getenv("DEVICE")=="PIC24FJ192GB110") 
....................     #if !defined(__PIC24FJ192GB110__) 
....................         #define __PIC24FJ192GB110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ192GB110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ192GB110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256DA106__) || (getenv("DEVICE")=="PIC24FJ256DA106") 
....................     #if !defined(__PIC24FJ256DA106__) 
....................         #define __PIC24FJ256DA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256DA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256DA106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256DA110__) || (getenv("DEVICE")=="PIC24FJ256DA110") 
....................     #if !defined(__PIC24FJ256DA110__) 
....................         #define __PIC24FJ256DA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256DA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256DA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256DA206__) || (getenv("DEVICE")=="PIC24FJ256DA206") 
....................     #if !defined(__PIC24FJ256DA206__) 
....................         #define __PIC24FJ256DA206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256DA206.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256DA206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256DA210__) || (getenv("DEVICE")=="PIC24FJ256DA210") 
....................     #if !defined(__PIC24FJ256DA210__) 
....................         #define __PIC24FJ256DA210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256DA210.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256DA210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GA106__) || (getenv("DEVICE")=="PIC24FJ256GA106") 
....................     #if !defined(__PIC24FJ256GA106__) 
....................         #define __PIC24FJ256GA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GA106_registers.h" 
.................... #word WREG0 = 0x000 
....................  
.................... #word WREG1 = 0x002 
....................  
.................... #word WREG2 = 0x004 
....................  
.................... #word WREG3 = 0x006 
....................  
.................... #word WREG4 = 0x008 
....................  
.................... #word WREG5 = 0x00A 
....................  
.................... #word WREG6 = 0x00C 
....................  
.................... #word WREG7 = 0x00E 
....................  
.................... #word WREG8 = 0x010 
....................  
.................... #word WREG9 = 0x012 
....................  
.................... #word WREG10 = 0x014 
....................  
.................... #word WREG11 = 0x016 
....................  
.................... #word WREG12 = 0x018 
....................  
.................... #word WREG13 = 0x01A 
....................  
.................... #word WREG14 = 0x01C 
....................  
.................... #word WREG15 = 0x01E 
....................  
.................... #word SPLIM = 0x020 
....................  
.................... #word PC = 0x02E 
....................  
.................... #word DSRPAG = 0x032 
....................  
.................... #word DSWPAG = 0x034 
....................  
.................... #word RCOUNT = 0x036 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int C:1; 
....................          unsigned int Z:1; 
....................          unsigned int OV:1; 
....................          unsigned int N:1; 
....................          unsigned int RA:1; 
....................          unsigned int IPL0:3; 
....................          unsigned int DC:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int IPL:3; 
....................       }; 
.................... } SRBITS; 
.................... SRBITS SRbits; 
.................... #word SRbits = 0x042 
.................... #word SR = 0x042 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :2; 
....................    unsigned int RES:1; 
....................    unsigned int IPL3:1; 
.................... } CORCONBITS; 
.................... CORCONBITS CORCONbits; 
.................... #word CORCONbits = 0x044 
.................... #word CORCON = 0x044 
....................  
.................... #word DISICNT = 0x052 
....................  
.................... #word TBLPAG = 0x054 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN0PDE:1; 
....................    unsigned int CN1PDE:1; 
....................    unsigned int CN2PDE:1; 
....................    unsigned int CN3PDE:1; 
....................    unsigned int CN4PDE:1; 
....................    unsigned int CN5PDE:1; 
....................    unsigned int CN6PDE:1; 
....................    unsigned int CN7PDE:1; 
....................    unsigned int CN8PDE:1; 
....................    unsigned int CN9PDE:1; 
....................    unsigned int CN10PDE:1; 
....................    unsigned int CN11PDE:1; 
....................    unsigned int CN12PDE:1; 
....................    unsigned int CN13PDE:1; 
....................    unsigned int CN14PDE:1; 
....................    unsigned int CN15PDE:1; 
.................... } CNPD1BITS; 
.................... CNPD1BITS CNPD1bits; 
.................... #word CNPD1bits = 0x056 
.................... #word CNPD1 = 0x056 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN16PDE:1; 
....................    unsigned int CN17PDE:1; 
....................    unsigned int CN18PDE:1; 
....................    unsigned int :3; 
....................    unsigned int CN22PDE:1; 
....................    unsigned int CN23PDE:1; 
....................    unsigned int CN24PDE:1; 
....................    unsigned int CN25PDE:1; 
....................    unsigned int CN26PDE:1; 
....................    unsigned int CN27PDE:1; 
....................    unsigned int CN28PDE:1; 
....................    unsigned int CN29PDE:1; 
....................    unsigned int CN30PDE:1; 
....................    unsigned int CN31PDE:1; 
.................... } CNPD2BITS; 
.................... CNPD2BITS CNPD2bits; 
.................... #word CNPD2bits = 0x058 
.................... #word CNPD2 = 0x058 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN32PDE:1; 
.................... } CNPD3BITS; 
.................... CNPD3BITS CNPD3bits; 
.................... #word CNPD3bits = 0x05A 
.................... #word CNPD3 = 0x05A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int CN49PDE:1; 
....................    unsigned int CN50PDE:1; 
....................    unsigned int CN51PDE:1; 
....................    unsigned int CN52PDE:1; 
....................    unsigned int CN53PDE:1; 
....................    unsigned int CN54PDE:1; 
....................    unsigned int CN55PDE:1; 
....................    unsigned int CN56PDE:1; 
....................    unsigned int :1; 
....................    unsigned int CN58PDE:1; 
....................    unsigned int CN59PDE:1; 
....................    unsigned int CN60PDE:1; 
....................    unsigned int CN61PDE:1; 
....................    unsigned int CN62PDE:1; 
....................    unsigned int CN63PDE:1; 
.................... } CNPD4BITS; 
.................... CNPD4BITS CNPD4bits; 
.................... #word CNPD4bits = 0x05C 
.................... #word CNPD4 = 0x05C 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN64PDE:1; 
....................    unsigned int CN65PDE:1; 
....................    unsigned int :2; 
....................    unsigned int CN68PDE:1; 
....................    unsigned int CN69PDE:1; 
....................    unsigned int :1; 
....................    unsigned int CN71PDE:1; 
.................... } CNPD5BITS; 
.................... CNPD5BITS CNPD5bits; 
.................... #word CNPD5bits = 0x05E 
.................... #word CNPD5 = 0x05E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :3; 
....................    unsigned int CN83PDE:1; 
....................    unsigned int CN84PDE:1; 
.................... } CNPD6BITS; 
.................... CNPD6BITS CNPD6bits; 
.................... #word CNPD6bits = 0x060 
.................... #word CNPD6 = 0x060 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN0IE:1; 
....................    unsigned int CN1IE:1; 
....................    unsigned int CN2IE:1; 
....................    unsigned int CN3IE:1; 
....................    unsigned int CN4IE:1; 
....................    unsigned int CN5IE:1; 
....................    unsigned int CN6IE:1; 
....................    unsigned int CN7IE:1; 
....................    unsigned int CN8IE:1; 
....................    unsigned int CN9IE:1; 
....................    unsigned int CN10IE:1; 
....................    unsigned int CN11IE:1; 
....................    unsigned int CN12IE:1; 
....................    unsigned int CN13IE:1; 
....................    unsigned int CN14IE:1; 
....................    unsigned int CN15IE:1; 
.................... } CNEN1BITS; 
.................... CNEN1BITS CNEN1bits; 
.................... #word CNEN1bits = 0x062 
.................... #word CNEN1 = 0x062 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN16IE:1; 
....................    unsigned int CN17IE:1; 
....................    unsigned int CN18IE:1; 
....................    unsigned int :3; 
....................    unsigned int CN22IE:1; 
....................    unsigned int CN23IE:1; 
....................    unsigned int CN24IE:1; 
....................    unsigned int CN25IE:1; 
....................    unsigned int CN26IE:1; 
....................    unsigned int CN27IE:1; 
....................    unsigned int CN28IE:1; 
....................    unsigned int CN29IE:1; 
....................    unsigned int CN30IE:1; 
....................    unsigned int CN31IE:1; 
.................... } CNEN2BITS; 
.................... CNEN2BITS CNEN2bits; 
.................... #word CNEN2bits = 0x064 
.................... #word CNEN2 = 0x064 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN32IE:1; 
.................... } CNEN3BITS; 
.................... CNEN3BITS CNEN3bits; 
.................... #word CNEN3bits = 0x066 
.................... #word CNEN3 = 0x066 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int CN49IE:1; 
....................    unsigned int CN50IE:1; 
....................    unsigned int CN51IE:1; 
....................    unsigned int CN52IE:1; 
....................    unsigned int CN53IE:1; 
....................    unsigned int CN54IE:1; 
....................    unsigned int CN55IE:1; 
....................    unsigned int CN56IE:1; 
....................    unsigned int :1; 
....................    unsigned int CN58IE:1; 
....................    unsigned int CN59IE:1; 
....................    unsigned int CN60IE:1; 
....................    unsigned int CN61IE:1; 
....................    unsigned int CN62IE:1; 
....................    unsigned int CN63IE:1; 
.................... } CNEN4BITS; 
.................... CNEN4BITS CNEN4bits; 
.................... #word CNEN4bits = 0x068 
.................... #word CNEN4 = 0x068 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN64IE:1; 
....................    unsigned int CN65IE:1; 
....................    unsigned int :2; 
....................    unsigned int CN68IE:1; 
....................    unsigned int CN69IE:1; 
....................    unsigned int :1; 
....................    unsigned int CN71IE:1; 
.................... } CNEN5BITS; 
.................... CNEN5BITS CNEN5bits; 
.................... #word CNEN5bits = 0x06A 
.................... #word CNEN5 = 0x06A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :3; 
....................    unsigned int CN83IE:1; 
....................    unsigned int CN84IE:1; 
.................... } CNEN6BITS; 
.................... CNEN6BITS CNEN6bits; 
.................... #word CNEN6bits = 0x06C 
.................... #word CNEN6 = 0x06C 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN0PUE:1; 
....................    unsigned int CN1PUE:1; 
....................    unsigned int CN2PUE:1; 
....................    unsigned int CN3PUE:1; 
....................    unsigned int CN4PUE:1; 
....................    unsigned int CN5PUE:1; 
....................    unsigned int CN6PUE:1; 
....................    unsigned int CN7PUE:1; 
....................    unsigned int CN8PUE:1; 
....................    unsigned int CN9PUE:1; 
....................    unsigned int CN10PUE:1; 
....................    unsigned int CN11PUE:1; 
....................    unsigned int CN12PUE:1; 
....................    unsigned int CN13PUE:1; 
....................    unsigned int CN14PUE:1; 
....................    unsigned int CN15PUE:1; 
.................... } CNPU1BITS; 
.................... CNPU1BITS CNPU1bits; 
.................... #word CNPU1bits = 0x06E 
.................... #word CNPU1 = 0x06E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN16PUE:1; 
....................    unsigned int CN17PUE:1; 
....................    unsigned int CN18PUE:1; 
....................    unsigned int :3; 
....................    unsigned int CN22PUE:1; 
....................    unsigned int CN23PUE:1; 
....................    unsigned int CN24PUE:1; 
....................    unsigned int CN25PUE:1; 
....................    unsigned int CN26PUE:1; 
....................    unsigned int CN27PUE:1; 
....................    unsigned int CN28PUE:1; 
....................    unsigned int CN29PUE:1; 
....................    unsigned int CN30PUE:1; 
....................    unsigned int CN31PUE:1; 
.................... } CNPU2BITS; 
.................... CNPU2BITS CNPU2bits; 
.................... #word CNPU2bits = 0x070 
.................... #word CNPU2 = 0x070 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN32PUE:1; 
.................... } CNPU3BITS; 
.................... CNPU3BITS CNPU3bits; 
.................... #word CNPU3bits = 0x072 
.................... #word CNPU3 = 0x072 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int CN49PUE:1; 
....................    unsigned int CN50PUE:1; 
....................    unsigned int CN51PUE:1; 
....................    unsigned int CN52PUE:1; 
....................    unsigned int CN53PUE:1; 
....................    unsigned int CN54PUE:1; 
....................    unsigned int CN55PUE:1; 
....................    unsigned int CN56PUE:1; 
....................    unsigned int :1; 
....................    unsigned int CN58PUE:1; 
....................    unsigned int CN59PUE:1; 
....................    unsigned int CN60PUE:1; 
....................    unsigned int CN61PUE:1; 
....................    unsigned int CN62PUE:1; 
....................    unsigned int CN63PUE:1; 
.................... } CNPU4BITS; 
.................... CNPU4BITS CNPU4bits; 
.................... #word CNPU4bits = 0x074 
.................... #word CNPU4 = 0x074 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int CN64PUE:1; 
....................    unsigned int CN65PUE:1; 
....................    unsigned int :2; 
....................    unsigned int CN68PUE:1; 
....................    unsigned int CN69PUE:1; 
....................    unsigned int :1; 
....................    unsigned int CN71PUE:1; 
.................... } CNPU5BITS; 
.................... CNPU5BITS CNPU5bits; 
.................... #word CNPU5bits = 0x076 
.................... #word CNPU5 = 0x076 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :3; 
....................    unsigned int CN83PUE:1; 
....................    unsigned int CN84PUE:1; 
.................... } CNPU6BITS; 
.................... CNPU6BITS CNPU6bits; 
.................... #word CNPU6bits = 0x078 
.................... #word CNPU6 = 0x078 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int OSCFAIL:1; 
....................    unsigned int STKERR:1; 
....................    unsigned int ADDRERR:1; 
....................    unsigned int MATHERR:1; 
....................    unsigned int :10; 
....................    unsigned int NSTDIS:1; 
.................... } INTCON1BITS; 
.................... INTCON1BITS INTCON1bits; 
.................... #word INTCON1bits = 0x080 
.................... #word INTCON1 = 0x080 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int INT0EP:1; 
....................    unsigned int INT1EP:1; 
....................    unsigned int INT2EP:1; 
....................    unsigned int INT3EP:1; 
....................    unsigned int INT4EP:1; 
....................    unsigned int :9; 
....................    unsigned int DISI:1; 
....................    unsigned int ALTIVT:1; 
.................... } INTCON2BITS; 
.................... INTCON2BITS INTCON2bits; 
.................... #word INTCON2bits = 0x082 
.................... #word INTCON2 = 0x082 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int INT0IF:1; 
....................    unsigned int IC1IF:1; 
....................    unsigned int OC1IF:1; 
....................    unsigned int T1IF:1; 
....................    unsigned int :1; 
....................    unsigned int IC2IF:1; 
....................    unsigned int OC2IF:1; 
....................    unsigned int T2IF:1; 
....................    unsigned int T3IF:1; 
....................    unsigned int SPF1IF:1; 
....................    unsigned int SPI1IF:1; 
....................    unsigned int U1RXIF:1; 
....................    unsigned int U1TXIF:1; 
....................    unsigned int AD1IF:1; 
.................... } IFS0BITS; 
.................... IFS0BITS IFS0bits; 
.................... #word IFS0bits = 0x084 
.................... #word IFS0 = 0x084 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SI2C1IF:1; 
....................    unsigned int MI2C1IF:1; 
....................    unsigned int CMIF:1; 
....................    unsigned int CNIF:1; 
....................    unsigned int INT1IF:1; 
....................    unsigned int :1; 
....................    unsigned int IC7IF:1; 
....................    unsigned int IC8IF:1; 
....................    unsigned int :1; 
....................    unsigned int OC3IF:1; 
....................    unsigned int OC4IF:1; 
....................    unsigned int T4IF:1; 
....................    unsigned int T5IF:1; 
....................    unsigned int INT2IF:1; 
....................    unsigned int U2RXIF:1; 
....................    unsigned int U2TXIF:1; 
.................... } IFS1BITS; 
.................... IFS1BITS IFS1bits; 
.................... #word IFS1bits = 0x086 
.................... #word IFS1 = 0x086 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPF2IF:1; 
....................    unsigned int SPI2IF:1; 
....................    unsigned int :3; 
....................    unsigned int IC3IF:1; 
....................    unsigned int IC4IF:1; 
....................    unsigned int IC5IF:1; 
....................    unsigned int IC6IF:1; 
....................    unsigned int OC5IF:1; 
....................    unsigned int OC6IF:1; 
....................    unsigned int OC7IF:1; 
....................    unsigned int OC8IF:1; 
....................    unsigned int PMPIF:1; 
.................... } IFS2BITS; 
.................... IFS2BITS IFS2bits; 
.................... #word IFS2bits = 0x088 
.................... #word IFS2 = 0x088 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int SI2C2IF:1; 
....................    unsigned int MI2C2IF:1; 
....................    unsigned int :2; 
....................    unsigned int INT3IF:1; 
....................    unsigned int INT4IF:1; 
....................    unsigned int :7; 
....................    unsigned int RTCIF:1; 
.................... } IFS3BITS; 
.................... IFS3BITS IFS3bits; 
.................... #word IFS3bits = 0x08A 
.................... #word IFS3 = 0x08A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int U1ERIF:1; 
....................    unsigned int U2ERIF:1; 
....................    unsigned int CRCIF:1; 
....................    unsigned int :4; 
....................    unsigned int LVDIF:1; 
....................    unsigned int :4; 
....................    unsigned int CTMUIF:1; 
.................... } IFS4BITS; 
.................... IFS4BITS IFS4bits; 
.................... #word IFS4bits = 0x08C 
.................... #word IFS4 = 0x08C 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int U3ERIF:1; 
....................    unsigned int U3RXIF:1; 
....................    unsigned int U3TXIF:1; 
....................    unsigned int SI2C3IF:1; 
....................    unsigned int MI2C3IF:1; 
....................    unsigned int USB1IF:1; 
....................    unsigned int U4ERIF:1; 
....................    unsigned int U4RXIF:1; 
....................    unsigned int U4TXIF:1; 
....................    unsigned int SPF3IF:1; 
....................    unsigned int SPI3IF:1; 
....................    unsigned int OC9IF:1; 
....................    unsigned int IC9IF:1; 
.................... } IFS5BITS; 
.................... IFS5BITS IFS5bits; 
.................... #word IFS5bits = 0x08E 
.................... #word IFS5 = 0x08E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int INT0IE:1; 
....................    unsigned int IC1IE:1; 
....................    unsigned int OC1IE:1; 
....................    unsigned int T1IE:1; 
....................    unsigned int :1; 
....................    unsigned int IC2IE:1; 
....................    unsigned int OC2IE:1; 
....................    unsigned int T2IE:1; 
....................    unsigned int T3IE:1; 
....................    unsigned int SPF1IE:1; 
....................    unsigned int SPI1IE:1; 
....................    unsigned int U1RXIE:1; 
....................    unsigned int U1TXIE:1; 
....................    unsigned int AD1IE:1; 
.................... } IEC0BITS; 
.................... IEC0BITS IEC0bits; 
.................... #word IEC0bits = 0x094 
.................... #word IEC0 = 0x094 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SI2C1IE:1; 
....................    unsigned int MI2C1IE:1; 
....................    unsigned int CMIE:1; 
....................    unsigned int CNIE:1; 
....................    unsigned int INT1IE:1; 
....................    unsigned int :1; 
....................    unsigned int IC7IE:1; 
....................    unsigned int IC8IE:1; 
....................    unsigned int :1; 
....................    unsigned int OC3IE:1; 
....................    unsigned int OC4IE:1; 
....................    unsigned int T4IE:1; 
....................    unsigned int T5IE:1; 
....................    unsigned int INT2IE:1; 
....................    unsigned int U2RXIE:1; 
....................    unsigned int U2TXIE:1; 
.................... } IEC1BITS; 
.................... IEC1BITS IEC1bits; 
.................... #word IEC1bits = 0x096 
.................... #word IEC1 = 0x096 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPF2IE:1; 
....................    unsigned int SPI2IE:1; 
....................    unsigned int :3; 
....................    unsigned int IC3IE:1; 
....................    unsigned int IC4IE:1; 
....................    unsigned int IC5IE:1; 
....................    unsigned int IC6IE:1; 
....................    unsigned int OC5IE:1; 
....................    unsigned int OC6IE:1; 
....................    unsigned int OC7IE:1; 
....................    unsigned int OC8IE:1; 
....................    unsigned int PMPIE:1; 
.................... } IEC2BITS; 
.................... IEC2BITS IEC2bits; 
.................... #word IEC2bits = 0x098 
.................... #word IEC2 = 0x098 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int SI2C2IE:1; 
....................    unsigned int MI2C2IE:1; 
....................    unsigned int :2; 
....................    unsigned int INT3IE:1; 
....................    unsigned int INT4IE:1; 
....................    unsigned int :7; 
....................    unsigned int RTCIE:1; 
.................... } IEC3BITS; 
.................... IEC3BITS IEC3bits; 
.................... #word IEC3bits = 0x09A 
.................... #word IEC3 = 0x09A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int U1ERIE:1; 
....................    unsigned int U2ERIE:1; 
....................    unsigned int CRCIE:1; 
....................    unsigned int :4; 
....................    unsigned int LVDIE:1; 
....................    unsigned int :4; 
....................    unsigned int CTMUIE:1; 
.................... } IEC4BITS; 
.................... IEC4BITS IEC4bits; 
.................... #word IEC4bits = 0x09C 
.................... #word IEC4 = 0x09C 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int U3ERIE:1; 
....................    unsigned int U3RXIE:1; 
....................    unsigned int U3TXIE:1; 
....................    unsigned int SI2C3IE:1; 
....................    unsigned int MI2C3IE:1; 
....................    unsigned int USB1IE:1; 
....................    unsigned int U4ERIE:1; 
....................    unsigned int U4RXIE:1; 
....................    unsigned int U4TXIE:1; 
....................    unsigned int SPF3IE:1; 
....................    unsigned int SPI3IE:1; 
....................    unsigned int OC9IE:1; 
....................    unsigned int IC9IE:1; 
.................... } IEC5BITS; 
.................... IEC5BITS IEC5bits; 
.................... #word IEC5bits = 0x09E 
.................... #word IEC5 = 0x09E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int INT0IP0:3; 
....................          unsigned int :1; 
....................          unsigned int IC1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int T1IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int INT0IP:3; 
....................          unsigned int :1; 
....................          unsigned int IC1IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC1IP:3; 
....................          unsigned int :1; 
....................          unsigned int T1IP:3; 
....................       }; 
.................... } IPC0BITS; 
.................... IPC0BITS IPC0bits; 
.................... #word IPC0bits = 0x0A4 
.................... #word IPC0 = 0x0A4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int IC2IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC2IP0:3; 
....................          unsigned int :1; 
....................          unsigned int T2IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int IC2IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC2IP:3; 
....................          unsigned int :1; 
....................          unsigned int T2IP:3; 
....................       }; 
.................... } IPC1BITS; 
.................... IPC1BITS IPC1bits; 
.................... #word IPC1bits = 0x0A6 
.................... #word IPC1 = 0x0A6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int T3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int SPF1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int SPI1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int U1RXIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int T3IP:3; 
....................          unsigned int :1; 
....................          unsigned int SPF1IP:3; 
....................          unsigned int :1; 
....................          unsigned int SPI1IP:3; 
....................          unsigned int :1; 
....................          unsigned int U1RXIP:3; 
....................       }; 
.................... } IPC2BITS; 
.................... IPC2BITS IPC2bits; 
.................... #word IPC2bits = 0x0A8 
.................... #word IPC2 = 0x0A8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int U1TXIP0:3; 
....................          unsigned int :1; 
....................          unsigned int AD1IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int U1TXIP:3; 
....................          unsigned int :1; 
....................          unsigned int AD1IP:3; 
....................       }; 
.................... } IPC3BITS; 
.................... IPC3BITS IPC3bits; 
.................... #word IPC3bits = 0x0AA 
.................... #word IPC3 = 0x0AA 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SI2C1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int CMIP0:3; 
....................          unsigned int :1; 
....................          unsigned int CNIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int SI2C1IP:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C1IP:3; 
....................          unsigned int :1; 
....................          unsigned int CMIP:3; 
....................          unsigned int :1; 
....................          unsigned int CNIP:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int SI2C1P0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C1P0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int SI2C1P:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C1P:3; 
....................       }; 
.................... } IPC4BITS; 
.................... IPC4BITS IPC4bits; 
.................... #word IPC4bits = 0x0AC 
.................... #word IPC4 = 0x0AC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int INT1IP0:3; 
....................          unsigned int :5; 
....................          unsigned int IC7IP0:3; 
....................          unsigned int :1; 
....................          unsigned int IC8IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int INT1IP:3; 
....................          unsigned int :5; 
....................          unsigned int IC7IP:3; 
....................          unsigned int :1; 
....................          unsigned int IC8IP:3; 
....................       }; 
.................... } IPC5BITS; 
.................... IPC5BITS IPC5bits; 
.................... #word IPC5bits = 0x0AE 
.................... #word IPC5 = 0x0AE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int OC3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC4IP0:3; 
....................          unsigned int :1; 
....................          unsigned int T4IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int OC3IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC4IP:3; 
....................          unsigned int :1; 
....................          unsigned int T4IP:3; 
....................       }; 
.................... } IPC6BITS; 
.................... IPC6BITS IPC6bits; 
.................... #word IPC6bits = 0x0B0 
.................... #word IPC6 = 0x0B0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int T5IP0:3; 
....................          unsigned int :1; 
....................          unsigned int INT2IP0:3; 
....................          unsigned int :1; 
....................          unsigned int U2RXIP0:3; 
....................          unsigned int :1; 
....................          unsigned int U2TXIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int T5IP:3; 
....................          unsigned int :1; 
....................          unsigned int INT2IP:3; 
....................          unsigned int :1; 
....................          unsigned int U2RXIP:3; 
....................          unsigned int :1; 
....................          unsigned int U2TXIP:3; 
....................       }; 
.................... } IPC7BITS; 
.................... IPC7BITS IPC7bits; 
.................... #word IPC7bits = 0x0B2 
.................... #word IPC7 = 0x0B2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SPF2IP0:3; 
....................          unsigned int :1; 
....................          unsigned int SPI2IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int SPF2IP:3; 
....................          unsigned int :1; 
....................          unsigned int SPI2IP:3; 
....................       }; 
.................... } IPC8BITS; 
.................... IPC8BITS IPC8bits; 
.................... #word IPC8bits = 0x0B4 
.................... #word IPC8 = 0x0B4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int IC3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int IC4IP0:3; 
....................          unsigned int :1; 
....................          unsigned int IC5IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int IC3IP:3; 
....................          unsigned int :1; 
....................          unsigned int IC4IP:3; 
....................          unsigned int :1; 
....................          unsigned int IC5IP:3; 
....................       }; 
.................... } IPC9BITS; 
.................... IPC9BITS IPC9bits; 
.................... #word IPC9bits = 0x0B6 
.................... #word IPC9 = 0x0B6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IC6IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC5IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC6IP0:3; 
....................          unsigned int :1; 
....................          unsigned int OC7IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int IC6IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC5IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC6IP:3; 
....................          unsigned int :1; 
....................          unsigned int OC7IP:3; 
....................       }; 
.................... } IPC10BITS; 
.................... IPC10BITS IPC10bits; 
.................... #word IPC10bits = 0x0B8 
.................... #word IPC10 = 0x0B8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OC8IP0:3; 
....................          unsigned int :1; 
....................          unsigned int PMPIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int OC8IP:3; 
....................          unsigned int :1; 
....................          unsigned int PMPIP:3; 
....................       }; 
.................... } IPC11BITS; 
.................... IPC11BITS IPC11bits; 
.................... #word IPC11bits = 0x0BA 
.................... #word IPC11 = 0x0BA 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int SI2C2IP0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C2IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int SI2C2IP:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C2IP:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int SI2C2P0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C2P0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int SI2C2P:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C2P:3; 
....................       }; 
.................... } IPC12BITS; 
.................... IPC12BITS IPC12bits; 
.................... #word IPC12bits = 0x0BC 
.................... #word IPC12 = 0x0BC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int INT3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int INT4IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int INT3IP:3; 
....................          unsigned int :1; 
....................          unsigned int INT4IP:3; 
....................       }; 
.................... } IPC13BITS; 
.................... IPC13BITS IPC13bits; 
.................... #word IPC13bits = 0x0BE 
.................... #word IPC13 = 0x0BE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int RTCIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int RTCIP:3; 
....................       }; 
.................... } IPC15BITS; 
.................... IPC15BITS IPC15bits; 
.................... #word IPC15bits = 0x0C2 
.................... #word IPC15 = 0x0C2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int U1ERIP0:3; 
....................          unsigned int :1; 
....................          unsigned int U2ERIP0:3; 
....................          unsigned int :1; 
....................          unsigned int CRCIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int U1ERIP:3; 
....................          unsigned int :1; 
....................          unsigned int U2ERIP:3; 
....................          unsigned int :1; 
....................          unsigned int CRCIP:3; 
....................       }; 
.................... } IPC16BITS; 
.................... IPC16BITS IPC16bits; 
.................... #word IPC16bits = 0x0C4 
.................... #word IPC16 = 0x0C4 
....................  
.................... #word IPC18 = 0x0C8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int CTMUIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int CTMUIP:3; 
....................       }; 
.................... } IPC19BITS; 
.................... IPC19BITS IPC19bits; 
.................... #word IPC19bits = 0x0CA 
.................... #word IPC19 = 0x0CA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int U3ERIP0:3; 
....................          unsigned int :1; 
....................          unsigned int U3RXIP0:3; 
....................          unsigned int :1; 
....................          unsigned int U3TXIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int U3ERIP:3; 
....................          unsigned int :1; 
....................          unsigned int U3RXIP:3; 
....................          unsigned int :1; 
....................          unsigned int U3TXIP:3; 
....................       }; 
.................... } IPC20BITS; 
.................... IPC20BITS IPC20bits; 
.................... #word IPC20bits = 0x0CC 
.................... #word IPC20 = 0x0CC 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SI2C3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int USB1IP0:3; 
....................          unsigned int :1; 
....................          unsigned int U4ERIP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int SI2C3IP:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C3IP:3; 
....................          unsigned int :1; 
....................          unsigned int USB1IP:3; 
....................          unsigned int :1; 
....................          unsigned int U4ERIP:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int SI2C3P0:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C3P0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int SI2C3P:3; 
....................          unsigned int :1; 
....................          unsigned int MI2C3P:3; 
....................       }; 
.................... } IPC21BITS; 
.................... IPC21BITS IPC21bits; 
.................... #word IPC21bits = 0x0CE 
.................... #word IPC21 = 0x0CE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int U4RXIP0:3; 
....................          unsigned int :1; 
....................          unsigned int U4TXIP0:3; 
....................          unsigned int :1; 
....................          unsigned int SPF3IP0:3; 
....................          unsigned int :1; 
....................          unsigned int SPI3IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int U4RXIP:3; 
....................          unsigned int :1; 
....................          unsigned int U4TXIP:3; 
....................          unsigned int :1; 
....................          unsigned int SPF3IP:3; 
....................          unsigned int :1; 
....................          unsigned int SPI3IP:3; 
....................       }; 
.................... } IPC22BITS; 
.................... IPC22BITS IPC22bits; 
.................... #word IPC22bits = 0x0D0 
.................... #word IPC22 = 0x0D0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OC9IP0:3; 
....................          unsigned int :1; 
....................          unsigned int IC9IP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int OC9IP:3; 
....................          unsigned int :1; 
....................          unsigned int IC9IP:3; 
....................       }; 
.................... } IPC23BITS; 
.................... IPC23BITS IPC23bits; 
.................... #word IPC23bits = 0x0D2 
.................... #word IPC23 = 0x0D2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int VECNUM0:7; 
....................          unsigned int :1; 
....................          unsigned int ILR0:4; 
....................          unsigned int :1; 
....................          unsigned int VHOLD:1; 
....................          unsigned int :1; 
....................          unsigned int CPUIRQ:1; 
....................       }; 
....................       struct { 
....................          unsigned int VECNUM:7; 
....................          unsigned int :1; 
....................          unsigned int ILR:4; 
....................       }; 
.................... } INTTREGBITS; 
.................... INTTREGBITS INTTREGbits; 
.................... #word INTTREGbits = 0x0E0 
.................... #word INTTREG = 0x0E0 
....................  
.................... #word TMR1 = 0x100 
....................  
.................... #word PR1 = 0x102 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int TCS:1; 
....................          unsigned int TSYNC:1; 
....................          unsigned int :1; 
....................          unsigned int TCKPS0:2; 
....................          unsigned int TGATE:1; 
....................          unsigned int :6; 
....................          unsigned int TSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int TON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int TCKPS:2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } T1CONBITS; 
.................... T1CONBITS T1CONbits; 
.................... #word T1CONbits = 0x104 
.................... #word T1CON = 0x104 
....................  
.................... #word TMR2 = 0x106 
....................  
.................... #word TMR3HLD = 0x108 
....................  
.................... #word TMR3 = 0x10A 
....................  
.................... #word PR2 = 0x10C 
....................  
.................... #word PR3 = 0x10E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int TCS:1; 
....................          unsigned int :1; 
....................          unsigned int T32:1; 
....................          unsigned int TCKPS0:2; 
....................          unsigned int TGATE:1; 
....................          unsigned int :6; 
....................          unsigned int TSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int TON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int TCKPS:2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } T2CONBITS; 
.................... T2CONBITS T2CONbits; 
.................... #word T2CONbits = 0x110 
.................... #word T2CON = 0x110 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int TCS:1; 
....................          unsigned int :2; 
....................          unsigned int TCKPS0:2; 
....................          unsigned int TGATE:1; 
....................          unsigned int :6; 
....................          unsigned int TSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int TON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :2; 
....................          unsigned int TCKPS:2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } T3CONBITS; 
.................... T3CONBITS T3CONbits; 
.................... #word T3CONbits = 0x112 
.................... #word T3CON = 0x112 
....................  
.................... #word TMR4 = 0x114 
....................  
.................... #word TMR5HLD = 0x116 
....................  
.................... #word TMR5 = 0x118 
....................  
.................... #word PR4 = 0x11A 
....................  
.................... #word PR5 = 0x11C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int TCS:1; 
....................          unsigned int :1; 
....................          unsigned int T45:1; 
....................          unsigned int TCKPS0:2; 
....................          unsigned int TGATE:1; 
....................          unsigned int :6; 
....................          unsigned int TSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int TON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int TCKPS:2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } T4CONBITS; 
.................... T4CONBITS T4CONbits; 
.................... #word T4CONbits = 0x11E 
.................... #word T4CON = 0x11E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int TCS:1; 
....................          unsigned int :2; 
....................          unsigned int TCKPS0:2; 
....................          unsigned int TGATE:1; 
....................          unsigned int :6; 
....................          unsigned int TSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int TON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :2; 
....................          unsigned int TCKPS:2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } T5CONBITS; 
.................... T5CONBITS T5CONbits; 
.................... #word T5CONbits = 0x120 
.................... #word T5CON = 0x120 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC1CON1BITS; 
.................... IC1CON1BITS IC1CON1bits; 
.................... #word IC1CON1bits = 0x140 
.................... #word IC1CON1 = 0x140 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC1CON2BITS; 
.................... IC1CON2BITS IC1CON2bits; 
.................... #word IC1CON2bits = 0x142 
.................... #word IC1CON2 = 0x142 
....................  
.................... #word IC1BUF = 0x144 
....................  
.................... #word IC1TMR = 0x146 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC2CON1BITS; 
.................... IC2CON1BITS IC2CON1bits; 
.................... #word IC2CON1bits = 0x148 
.................... #word IC2CON1 = 0x148 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC2CON2BITS; 
.................... IC2CON2BITS IC2CON2bits; 
.................... #word IC2CON2bits = 0x14A 
.................... #word IC2CON2 = 0x14A 
....................  
.................... #word IC2BUF = 0x14C 
....................  
.................... #word IC2TMR = 0x14E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC3CON1BITS; 
.................... IC3CON1BITS IC3CON1bits; 
.................... #word IC3CON1bits = 0x150 
.................... #word IC3CON1 = 0x150 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC3CON2BITS; 
.................... IC3CON2BITS IC3CON2bits; 
.................... #word IC3CON2bits = 0x152 
.................... #word IC3CON2 = 0x152 
....................  
.................... #word IC3BUF = 0x154 
....................  
.................... #word IC3TMR = 0x156 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC4CON1BITS; 
.................... IC4CON1BITS IC4CON1bits; 
.................... #word IC4CON1bits = 0x158 
.................... #word IC4CON1 = 0x158 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC4CON2BITS; 
.................... IC4CON2BITS IC4CON2bits; 
.................... #word IC4CON2bits = 0x15A 
.................... #word IC4CON2 = 0x15A 
....................  
.................... #word IC4BUF = 0x15C 
....................  
.................... #word IC4TMR = 0x15E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC5CON1BITS; 
.................... IC5CON1BITS IC5CON1bits; 
.................... #word IC5CON1bits = 0x160 
.................... #word IC5CON1 = 0x160 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC5CON2BITS; 
.................... IC5CON2BITS IC5CON2bits; 
.................... #word IC5CON2bits = 0x162 
.................... #word IC5CON2 = 0x162 
....................  
.................... #word IC5BUF = 0x164 
....................  
.................... #word IC5TMR = 0x166 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC6CON1BITS; 
.................... IC6CON1BITS IC6CON1bits; 
.................... #word IC6CON1bits = 0x168 
.................... #word IC6CON1 = 0x168 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC6CON2BITS; 
.................... IC6CON2BITS IC6CON2bits; 
.................... #word IC6CON2bits = 0x16A 
.................... #word IC6CON2 = 0x16A 
....................  
.................... #word IC6BUF = 0x16C 
....................  
.................... #word IC6TMR = 0x16E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC7CON1BITS; 
.................... IC7CON1BITS IC7CON1bits; 
.................... #word IC7CON1bits = 0x170 
.................... #word IC7CON1 = 0x170 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC7CON2BITS; 
.................... IC7CON2BITS IC7CON2bits; 
.................... #word IC7CON2bits = 0x172 
.................... #word IC7CON2 = 0x172 
....................  
.................... #word IC7BUF = 0x174 
....................  
.................... #word IC7TMR = 0x176 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC8CON1BITS; 
.................... IC8CON1BITS IC8CON1bits; 
.................... #word IC8CON1bits = 0x178 
.................... #word IC8CON1 = 0x178 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC8CON2BITS; 
.................... IC8CON2BITS IC8CON2bits; 
.................... #word IC8CON2bits = 0x17A 
.................... #word IC8CON2 = 0x17A 
....................  
.................... #word IC8BUF = 0x17C 
....................  
.................... #word IC8TMR = 0x17E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ICM0:3; 
....................          unsigned int ICBNE:1; 
....................          unsigned int ICOV:1; 
....................          unsigned int ICI0:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL0:3; 
....................          unsigned int ICSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int ICM:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ICI:2; 
....................          unsigned int :3; 
....................          unsigned int ICTSEL:3; 
....................       }; 
.................... } IC9CON1BITS; 
.................... IC9CON1BITS IC9CON1bits; 
.................... #word IC9CON1bits = 0x180 
.................... #word IC9CON1 = 0x180 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int :1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int ICTRIG:1; 
....................          unsigned int IC32:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................       }; 
.................... } IC9CON2BITS; 
.................... IC9CON2BITS IC9CON2bits; 
.................... #word IC9CON2bits = 0x182 
.................... #word IC9CON2 = 0x182 
....................  
.................... #word IC9BUF = 0x184 
....................  
.................... #word IC9TMR = 0x186 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC1CON1BITS; 
.................... OC1CON1BITS OC1CON1bits; 
.................... #word OC1CON1bits = 0x190 
.................... #word OC1CON1 = 0x190 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC1CON2BITS; 
.................... OC1CON2BITS OC1CON2bits; 
.................... #word OC1CON2bits = 0x192 
.................... #word OC1CON2 = 0x192 
....................  
.................... #word OC1RS = 0x194 
....................  
.................... #word OC1R = 0x196 
....................  
.................... #word OC1TMR = 0x198 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC2CON1BITS; 
.................... OC2CON1BITS OC2CON1bits; 
.................... #word OC2CON1bits = 0x19A 
.................... #word OC2CON1 = 0x19A 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC2CON2BITS; 
.................... OC2CON2BITS OC2CON2bits; 
.................... #word OC2CON2bits = 0x19C 
.................... #word OC2CON2 = 0x19C 
....................  
.................... #word OC2RS = 0x19E 
....................  
.................... #word OC2R = 0x1A0 
....................  
.................... #word OC2TMR = 0x1A2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC3CON1BITS; 
.................... OC3CON1BITS OC3CON1bits; 
.................... #word OC3CON1bits = 0x1A4 
.................... #word OC3CON1 = 0x1A4 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC3CON2BITS; 
.................... OC3CON2BITS OC3CON2bits; 
.................... #word OC3CON2bits = 0x1A6 
.................... #word OC3CON2 = 0x1A6 
....................  
.................... #word OC3RS = 0x1A8 
....................  
.................... #word OC3R = 0x1AA 
....................  
.................... #word OC3TMR = 0x1AC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC4CON1BITS; 
.................... OC4CON1BITS OC4CON1bits; 
.................... #word OC4CON1bits = 0x1AE 
.................... #word OC4CON1 = 0x1AE 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC4CON2BITS; 
.................... OC4CON2BITS OC4CON2bits; 
.................... #word OC4CON2bits = 0x1B0 
.................... #word OC4CON2 = 0x1B0 
....................  
.................... #word OC4RS = 0x1B2 
....................  
.................... #word OC4R = 0x1B4 
....................  
.................... #word OC4TMR = 0x1B6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC5CON1BITS; 
.................... OC5CON1BITS OC5CON1bits; 
.................... #word OC5CON1bits = 0x1B8 
.................... #word OC5CON1 = 0x1B8 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC5CON2BITS; 
.................... OC5CON2BITS OC5CON2bits; 
.................... #word OC5CON2bits = 0x1BA 
.................... #word OC5CON2 = 0x1BA 
....................  
.................... #word OC5RS = 0x1BC 
....................  
.................... #word OC5R = 0x1BE 
....................  
.................... #word OC5TMR = 0x1C0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC6CON1BITS; 
.................... OC6CON1BITS OC6CON1bits; 
.................... #word OC6CON1bits = 0x1C2 
.................... #word OC6CON1 = 0x1C2 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC6CON2BITS; 
.................... OC6CON2BITS OC6CON2bits; 
.................... #word OC6CON2bits = 0x1C4 
.................... #word OC6CON2 = 0x1C4 
....................  
.................... #word OC6RS = 0x1C6 
....................  
.................... #word OC6R = 0x1C8 
....................  
.................... #word OC6TMR = 0x1CA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC7CON1BITS; 
.................... OC7CON1BITS OC7CON1bits; 
.................... #word OC7CON1bits = 0x1CC 
.................... #word OC7CON1 = 0x1CC 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC7CON2BITS; 
.................... OC7CON2BITS OC7CON2bits; 
.................... #word OC7CON2bits = 0x1CE 
.................... #word OC7CON2 = 0x1CE 
....................  
.................... #word OC7RS = 0x1D0 
....................  
.................... #word OC7R = 0x1D2 
....................  
.................... #word OC7TMR = 0x1D4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC8CON1BITS; 
.................... OC8CON1BITS OC8CON1bits; 
.................... #word OC8CON1bits = 0x1D6 
.................... #word OC8CON1 = 0x1D6 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC8CON2BITS; 
.................... OC8CON2BITS OC8CON2bits; 
.................... #word OC8CON2bits = 0x1D8 
.................... #word OC8CON2 = 0x1D8 
....................  
.................... #word OC8RS = 0x1DA 
....................  
.................... #word OC8R = 0x1DC 
....................  
.................... #word OC8TMR = 0x1DE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCM0:3; 
....................          unsigned int TRIGMODE:1; 
....................          unsigned int OCFLT0:3; 
....................          unsigned int ENFLT0:3; 
....................          unsigned int OCTSEL0:3; 
....................          unsigned int OCSIDL:1; 
....................       }; 
....................       struct { 
....................          unsigned int OCM:3; 
....................          unsigned int :1; 
....................          unsigned int OCFLT:3; 
....................          unsigned int ENFLT:3; 
....................          unsigned int OCTSEL:3; 
....................       }; 
.................... } OC9CON1BITS; 
.................... OC9CON1BITS OC9CON1bits; 
.................... #word OC9CON1bits = 0x1E0 
.................... #word OC9CON1 = 0x1E0 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SYNCSEL0:5; 
....................          unsigned int OCTRIS:1; 
....................          unsigned int TRIGSTAT:1; 
....................          unsigned int OCTRIG:1; 
....................          unsigned int OC32:1; 
....................          unsigned int DCB0:2; 
....................          unsigned int :1; 
....................          unsigned int OCINV:1; 
....................          unsigned int FLTTRIEN:1; 
....................          unsigned int FLTOUT:1; 
....................          unsigned int FLTMD:1; 
....................       }; 
....................       struct { 
....................          unsigned int SYNCSEL:5; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int DCB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int FLTMODE:1; 
....................       }; 
....................    }; 
.................... } OC9CON2BITS; 
.................... OC9CON2BITS OC9CON2bits; 
.................... #word OC9CON2bits = 0x1E2 
.................... #word OC9CON2 = 0x1E2 
....................  
.................... #word OC9RS = 0x1E4 
....................  
.................... #word OC9R = 0x1E6 
....................  
.................... #word OC9TMR = 0x1E8 
....................  
.................... #word I2C1RCV = 0x200 
....................  
.................... #word I2C1TRN = 0x202 
....................  
.................... #word I2C1BRG = 0x204 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int STREN:1; 
....................    unsigned int GCEN:1; 
....................    unsigned int SMEN:1; 
....................    unsigned int DISSLW:1; 
....................    unsigned int A10M:1; 
....................    unsigned int IPMIEN:1; 
....................    unsigned int SCLREL:1; 
....................    unsigned int I2CSIDL:1; 
....................    unsigned int :1; 
....................    unsigned int I2CEN:1; 
.................... } I2C1CONBITS; 
.................... I2C1CONBITS I2C1CONbits; 
.................... #word I2C1CONbits = 0x206 
.................... #word I2C1CON = 0x206 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int TBF:1; 
....................          unsigned int RBF:1; 
....................          unsigned int R:1; 
....................          unsigned int S:1; 
....................          unsigned int P:1; 
....................          unsigned int D:1; 
....................          unsigned int I2COV:1; 
....................          unsigned int IWCOL:1; 
....................          unsigned int ADD10:1; 
....................          unsigned int GCSTAT:1; 
....................          unsigned int BCL:1; 
....................          unsigned int :3; 
....................          unsigned int TRSTAT:1; 
....................          unsigned int ACKSTAT:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int R_W:1; 
....................          unsigned int :2; 
....................          unsigned int D_A:1; 
....................       }; 
....................    }; 
.................... } I2C1STATBITS; 
.................... I2C1STATBITS I2C1STATbits; 
.................... #word I2C1STATbits = 0x208 
.................... #word I2C1STAT = 0x208 
....................  
.................... #word I2C1ADD = 0x20A 
....................  
.................... #word I2C1MSK = 0x20C 
....................  
.................... #word I2C2RCV = 0x210 
....................  
.................... #word I2C2TRN = 0x212 
....................  
.................... #word I2C2BRG = 0x214 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int STREN:1; 
....................    unsigned int GCEN:1; 
....................    unsigned int SMEN:1; 
....................    unsigned int DISSLW:1; 
....................    unsigned int A10M:1; 
....................    unsigned int IPMIEN:1; 
....................    unsigned int SCLREL:1; 
....................    unsigned int I2CSIDL:1; 
....................    unsigned int :1; 
....................    unsigned int I2CEN:1; 
.................... } I2C2CONBITS; 
.................... I2C2CONBITS I2C2CONbits; 
.................... #word I2C2CONbits = 0x216 
.................... #word I2C2CON = 0x216 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int TBF:1; 
....................          unsigned int RBF:1; 
....................          unsigned int R:1; 
....................          unsigned int S:1; 
....................          unsigned int P:1; 
....................          unsigned int D:1; 
....................          unsigned int I2COV:1; 
....................          unsigned int IWCOL:1; 
....................          unsigned int ADD10:1; 
....................          unsigned int GCSTAT:1; 
....................          unsigned int BCL:1; 
....................          unsigned int :3; 
....................          unsigned int TRSTAT:1; 
....................          unsigned int ACKSTAT:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int R_W:1; 
....................          unsigned int :2; 
....................          unsigned int D_A:1; 
....................       }; 
....................    }; 
.................... } I2C2STATBITS; 
.................... I2C2STATBITS I2C2STATbits; 
.................... #word I2C2STATbits = 0x218 
.................... #word I2C2STAT = 0x218 
....................  
.................... #word I2C2ADD = 0x21A 
....................  
.................... #word I2C2MSK = 0x21C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int STSEL:1; 
....................          unsigned int PDSEL0:2; 
....................          unsigned int BRGH:1; 
....................          unsigned int RXINV:1; 
....................          unsigned int ABAUD:1; 
....................          unsigned int LPBACK:1; 
....................          unsigned int WAKE:1; 
....................          unsigned int UEN0:2; 
....................          unsigned int :1; 
....................          unsigned int RTSMD:1; 
....................          unsigned int IREN:1; 
....................          unsigned int USIDL:1; 
....................          unsigned int :1; 
....................          unsigned int UARTEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int PDSEL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int UEN:2; 
....................       }; 
.................... } U1MODEBITS; 
.................... U1MODEBITS U1MODEbits; 
.................... #word U1MODEbits = 0x220 
.................... #word U1MODE = 0x220 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXDA:1; 
....................          unsigned int OERR:1; 
....................          unsigned int FERR:1; 
....................          unsigned int PERR:1; 
....................          unsigned int RIDLE:1; 
....................          unsigned int ADDEN:1; 
....................          unsigned int URXISEL0:2; 
....................          unsigned int TRMT:1; 
....................          unsigned int UTXBF:1; 
....................          unsigned int UTXEN:1; 
....................          unsigned int UTXBRK:1; 
....................          unsigned int :1; 
....................          unsigned int UTXISEL0:1; 
....................          unsigned int UTXINV:1; 
....................          unsigned int UTXISEL1:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int URXISEL:2; 
....................       }; 
.................... } U1STABITS; 
.................... U1STABITS U1STAbits; 
.................... #word U1STAbits = 0x222 
.................... #word U1STA = 0x222 
....................  
.................... #word U1TXREG = 0x224 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int UTXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int UTXREG:9; 
....................       }; 
.................... } U1TXREGBITS; 
.................... U1TXREGBITS U1TXREGbits; 
.................... #word U1TXREGbits = 0x224 
.................... #word U1TXREG = 0x224 
....................  
.................... #word U1RXREG = 0x226 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int URXREG:9; 
....................       }; 
.................... } U1RXREGBITS; 
.................... U1RXREGBITS U1RXREGbits; 
.................... #word U1RXREGbits = 0x226 
.................... #word U1RXREG = 0x226 
....................  
.................... #word U1BRG = 0x228 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int STSEL:1; 
....................          unsigned int PDSEL0:2; 
....................          unsigned int BRGH:1; 
....................          unsigned int RXINV:1; 
....................          unsigned int ABAUD:1; 
....................          unsigned int LPBACK:1; 
....................          unsigned int WAKE:1; 
....................          unsigned int UEN0:2; 
....................          unsigned int :1; 
....................          unsigned int RTSMD:1; 
....................          unsigned int IREN:1; 
....................          unsigned int USIDL:1; 
....................          unsigned int :1; 
....................          unsigned int UARTEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int PDSEL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int UEN:2; 
....................       }; 
.................... } U2MODEBITS; 
.................... U2MODEBITS U2MODEbits; 
.................... #word U2MODEbits = 0x230 
.................... #word U2MODE = 0x230 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXDA:1; 
....................          unsigned int OERR:1; 
....................          unsigned int FERR:1; 
....................          unsigned int PERR:1; 
....................          unsigned int RIDLE:1; 
....................          unsigned int ADDEN:1; 
....................          unsigned int URXISEL0:2; 
....................          unsigned int TRMT:1; 
....................          unsigned int UTXBF:1; 
....................          unsigned int UTXEN:1; 
....................          unsigned int UTXBRK:1; 
....................          unsigned int :1; 
....................          unsigned int UTXISEL0:1; 
....................          unsigned int UTXINV:1; 
....................          unsigned int UTXISEL1:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int URXISEL:2; 
....................       }; 
.................... } U2STABITS; 
.................... U2STABITS U2STAbits; 
.................... #word U2STAbits = 0x232 
.................... #word U2STA = 0x232 
....................  
.................... #word U2TXREG = 0x234 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int UTXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int UTXREG:9; 
....................       }; 
.................... } U2TXREGBITS; 
.................... U2TXREGBITS U2TXREGbits; 
.................... #word U2TXREGbits = 0x234 
.................... #word U2TXREG = 0x234 
....................  
.................... #word U2RXREG = 0x236 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int URXREG:9; 
....................       }; 
.................... } U2RXREGBITS; 
.................... U2RXREGBITS U2RXREGbits; 
.................... #word U2RXREGbits = 0x236 
.................... #word U2RXREG = 0x236 
....................  
.................... #word U2BRG = 0x238 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SPIRBF:1; 
....................          unsigned int SPITBF:1; 
....................          unsigned int SISEL0:3; 
....................          unsigned int SRXMPT:1; 
....................          unsigned int SPIROV:1; 
....................          unsigned int SRMPT:1; 
....................          unsigned int SPIBEC0:3; 
....................          unsigned int :2; 
....................          unsigned int SPISIDL:1; 
....................          unsigned int :1; 
....................          unsigned int SPIEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SISEL:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SPIBEC:3; 
....................          unsigned int :2; 
....................       }; 
.................... } SPI1STATBITS; 
.................... SPI1STATBITS SPI1STATbits; 
.................... #word SPI1STATbits = 0x240 
.................... #word SPI1STAT = 0x240 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PPRE0:2; 
....................          unsigned int SPRE0:3; 
....................          unsigned int MSTEN:1; 
....................          unsigned int CKP:1; 
....................          unsigned int SSEN:1; 
....................          unsigned int CKE:1; 
....................          unsigned int SMP:1; 
....................          unsigned int MODE16:1; 
....................          unsigned int DISSDO:1; 
....................          unsigned int DISSCK:1; 
....................       }; 
....................       struct { 
....................          unsigned int PPRE:2; 
....................          unsigned int SPRE:3; 
....................       }; 
.................... } SPI1CON1BITS; 
.................... SPI1CON1BITS SPI1CON1bits; 
.................... #word SPI1CON1bits = 0x242 
.................... #word SPI1CON1 = 0x242 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPIBEN:1; 
....................    unsigned int SPIFE:1; 
....................    unsigned int :11; 
....................    unsigned int SPIFPOL:1; 
....................    unsigned int SPIFSD:1; 
....................    unsigned int FRMEN:1; 
.................... } SPI1CON2BITS; 
.................... SPI1CON2BITS SPI1CON2bits; 
.................... #word SPI1CON2bits = 0x244 
.................... #word SPI1CON2 = 0x244 
....................  
.................... #word SPI1BUF = 0x248 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int STSEL:1; 
....................          unsigned int PDSEL0:2; 
....................          unsigned int BRGH:1; 
....................          unsigned int RXINV:1; 
....................          unsigned int ABAUD:1; 
....................          unsigned int LPBACK:1; 
....................          unsigned int WAKE:1; 
....................          unsigned int UEN0:2; 
....................          unsigned int :1; 
....................          unsigned int RTSMD:1; 
....................          unsigned int IREN:1; 
....................          unsigned int USIDL:1; 
....................          unsigned int :1; 
....................          unsigned int UARTEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int PDSEL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int UEN:2; 
....................       }; 
.................... } U3MODEBITS; 
.................... U3MODEBITS U3MODEbits; 
.................... #word U3MODEbits = 0x250 
.................... #word U3MODE = 0x250 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXDA:1; 
....................          unsigned int OERR:1; 
....................          unsigned int FERR:1; 
....................          unsigned int PERR:1; 
....................          unsigned int RIDLE:1; 
....................          unsigned int ADDEN:1; 
....................          unsigned int URXISEL0:2; 
....................          unsigned int TRMT:1; 
....................          unsigned int UTXBF:1; 
....................          unsigned int UTXEN:1; 
....................          unsigned int UTXBRK:1; 
....................          unsigned int :1; 
....................          unsigned int UTXISEL0:1; 
....................          unsigned int UTXINV:1; 
....................          unsigned int UTXISEL1:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int URXISEL:2; 
....................       }; 
.................... } U3STABITS; 
.................... U3STABITS U3STAbits; 
.................... #word U3STAbits = 0x252 
.................... #word U3STA = 0x252 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int UTXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int UTXREG:9; 
....................       }; 
.................... } U3TXREGBITS; 
.................... U3TXREGBITS U3TXREGbits; 
.................... #word U3TXREGbits = 0x254 
.................... #word U3TXREG = 0x254 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int URXREG:9; 
....................       }; 
.................... } U3RXREGBITS; 
.................... U3RXREGBITS U3RXREGbits; 
.................... #word U3RXREGbits = 0x256 
.................... #word U3RXREG = 0x256 
....................  
.................... #word U3BRG = 0x258 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SPIRBF:1; 
....................          unsigned int SPITBF:1; 
....................          unsigned int SISEL0:3; 
....................          unsigned int SRXMPT:1; 
....................          unsigned int SPIROV:1; 
....................          unsigned int SRMPT:1; 
....................          unsigned int SPIBEC0:3; 
....................          unsigned int :2; 
....................          unsigned int SPISIDL:1; 
....................          unsigned int :1; 
....................          unsigned int SPIEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SISEL:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SPIBEC:3; 
....................          unsigned int :2; 
....................       }; 
.................... } SPI2STATBITS; 
.................... SPI2STATBITS SPI2STATbits; 
.................... #word SPI2STATbits = 0x260 
.................... #word SPI2STAT = 0x260 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PPRE0:2; 
....................          unsigned int SPRE0:3; 
....................          unsigned int MSTEN:1; 
....................          unsigned int CKP:1; 
....................          unsigned int SSEN:1; 
....................          unsigned int CKE:1; 
....................          unsigned int SMP:1; 
....................          unsigned int MODE16:1; 
....................          unsigned int DISSDO:1; 
....................          unsigned int DISSCK:1; 
....................       }; 
....................       struct { 
....................          unsigned int PPRE:2; 
....................          unsigned int SPRE:3; 
....................       }; 
.................... } SPI2CON1BITS; 
.................... SPI2CON1BITS SPI2CON1bits; 
.................... #word SPI2CON1bits = 0x262 
.................... #word SPI2CON1 = 0x262 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPIBEN:1; 
....................    unsigned int SPIFE:1; 
....................    unsigned int :11; 
....................    unsigned int SPIFPOL:1; 
....................    unsigned int SPIFSD:1; 
....................    unsigned int FRMEN:1; 
.................... } SPI2CON2BITS; 
.................... SPI2CON2BITS SPI2CON2bits; 
.................... #word SPI2CON2bits = 0x264 
.................... #word SPI2CON2 = 0x264 
....................  
.................... #word SPI2BUF = 0x268 
....................  
.................... #word I2C3RCV = 0x270 
....................  
.................... #word I2C3TRN = 0x272 
....................  
.................... #word I2C3BRG = 0x274 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int STREN:1; 
....................    unsigned int GCEN:1; 
....................    unsigned int SMEN:1; 
....................    unsigned int DISSLW:1; 
....................    unsigned int A10M:1; 
....................    unsigned int IPMIEN:1; 
....................    unsigned int SCLREL:1; 
....................    unsigned int I2CSIDL:1; 
....................    unsigned int :1; 
....................    unsigned int I2CEN:1; 
.................... } I2C3CONBITS; 
.................... I2C3CONBITS I2C3CONbits; 
.................... #word I2C3CONbits = 0x276 
.................... #word I2C3CON = 0x276 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int TBF:1; 
....................          unsigned int RBF:1; 
....................          unsigned int R:1; 
....................          unsigned int S:1; 
....................          unsigned int P:1; 
....................          unsigned int D:1; 
....................          unsigned int I2COV:1; 
....................          unsigned int IWCOL:1; 
....................          unsigned int ADD10:1; 
....................          unsigned int GCSTAT:1; 
....................          unsigned int BCL:1; 
....................          unsigned int :3; 
....................          unsigned int TRSTAT:1; 
....................          unsigned int ACKSTAT:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int R_W:1; 
....................          unsigned int :2; 
....................          unsigned int D_A:1; 
....................       }; 
....................    }; 
.................... } I2C3STATBITS; 
.................... I2C3STATBITS I2C3STATbits; 
.................... #word I2C3STATbits = 0x278 
.................... #word I2C3STAT = 0x278 
....................  
.................... #word I2C3ADD = 0x27A 
....................  
.................... #word I2C3MSK = 0x27C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SPIRBF:1; 
....................          unsigned int SPITBF:1; 
....................          unsigned int SISEL0:3; 
....................          unsigned int SRXMPT:1; 
....................          unsigned int SPIROV:1; 
....................          unsigned int SRMPT:1; 
....................          unsigned int SPIBEC0:3; 
....................          unsigned int :2; 
....................          unsigned int SPISIDL:1; 
....................          unsigned int :1; 
....................          unsigned int SPIEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SISEL:3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SPIBEC:3; 
....................          unsigned int :2; 
....................       }; 
.................... } SPI3STATBITS; 
.................... SPI3STATBITS SPI3STATbits; 
.................... #word SPI3STATbits = 0x280 
.................... #word SPI3STAT = 0x280 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PPRE0:2; 
....................          unsigned int SPRE0:3; 
....................          unsigned int MSTEN:1; 
....................          unsigned int CKP:1; 
....................          unsigned int SSEN:1; 
....................          unsigned int CKE:1; 
....................          unsigned int SMP:1; 
....................          unsigned int MODE16:1; 
....................          unsigned int DISSDO:1; 
....................          unsigned int DISSCK:1; 
....................       }; 
....................       struct { 
....................          unsigned int PPRE:2; 
....................          unsigned int SPRE:3; 
....................       }; 
.................... } SPI3CON1BITS; 
.................... SPI3CON1BITS SPI3CON1bits; 
.................... #word SPI3CON1bits = 0x282 
.................... #word SPI3CON1 = 0x282 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPIBEN:1; 
....................    unsigned int SPIFE:1; 
....................    unsigned int :11; 
....................    unsigned int SPIFPOL:1; 
....................    unsigned int SPIFSD:1; 
....................    unsigned int FRMEN:1; 
.................... } SPI3CON2BITS; 
.................... SPI3CON2BITS SPI3CON2bits; 
.................... #word SPI3CON2bits = 0x284 
.................... #word SPI3CON2 = 0x284 
....................  
.................... #word SPI3BUF = 0x288 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int STSEL:1; 
....................          unsigned int PDSEL0:2; 
....................          unsigned int BRGH:1; 
....................          unsigned int RXINV:1; 
....................          unsigned int ABAUD:1; 
....................          unsigned int LPBACK:1; 
....................          unsigned int WAKE:1; 
....................          unsigned int UEN0:2; 
....................          unsigned int :1; 
....................          unsigned int RTSMD:1; 
....................          unsigned int IREN:1; 
....................          unsigned int USIDL:1; 
....................          unsigned int :1; 
....................          unsigned int UARTEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int PDSEL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int UEN:2; 
....................       }; 
.................... } U4MODEBITS; 
.................... U4MODEBITS U4MODEbits; 
.................... #word U4MODEbits = 0x2B0 
.................... #word U4MODE = 0x2B0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXDA:1; 
....................          unsigned int OERR:1; 
....................          unsigned int FERR:1; 
....................          unsigned int PERR:1; 
....................          unsigned int RIDLE:1; 
....................          unsigned int ADDEN:1; 
....................          unsigned int URXISEL0:2; 
....................          unsigned int TRMT:1; 
....................          unsigned int UTXBF:1; 
....................          unsigned int UTXEN:1; 
....................          unsigned int UTXBRK:1; 
....................          unsigned int :1; 
....................          unsigned int UTXISEL0:1; 
....................          unsigned int UTXINV:1; 
....................          unsigned int UTXISEL1:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int URXISEL:2; 
....................       }; 
.................... } U4STABITS; 
.................... U4STABITS U4STAbits; 
.................... #word U4STAbits = 0x2B2 
.................... #word U4STA = 0x2B2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int UTXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int UTXREG:9; 
....................       }; 
.................... } U4TXREGBITS; 
.................... U4TXREGBITS U4TXREGbits; 
.................... #word U4TXREGbits = 0x2B4 
.................... #word U4TXREG = 0x2B4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int URXREG0:9; 
....................       }; 
....................       struct { 
....................          unsigned int URXREG:9; 
....................       }; 
.................... } U4RXREGBITS; 
.................... U4RXREGBITS U4RXREGbits; 
.................... #word U4RXREGbits = 0x2B6 
.................... #word U4RXREG = 0x2B6 
....................  
.................... #word U4BRG = 0x2B8 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
....................    unsigned int TRISB8:1; 
....................    unsigned int TRISB9:1; 
....................    unsigned int TRISB10:1; 
....................    unsigned int TRISB11:1; 
....................    unsigned int TRISB12:1; 
....................    unsigned int TRISB13:1; 
....................    unsigned int TRISB14:1; 
....................    unsigned int TRISB15:1; 
.................... } TRISBBITS; 
.................... TRISBBITS TRISBbits; 
.................... #word TRISBbits = 0x2C8 
.................... #word TRISB = 0x2C8 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
....................    unsigned int RB8:1; 
....................    unsigned int RB9:1; 
....................    unsigned int RB10:1; 
....................    unsigned int RB11:1; 
....................    unsigned int RB12:1; 
....................    unsigned int RB13:1; 
....................    unsigned int RB14:1; 
....................    unsigned int RB15:1; 
.................... } PORTBBITS; 
.................... PORTBBITS PORTBbits; 
.................... #word PORTBbits = 0x2CA 
.................... #word PORTB = 0x2CA 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
....................    unsigned int LATB8:1; 
....................    unsigned int LATB9:1; 
....................    unsigned int LATB10:1; 
....................    unsigned int LATB11:1; 
....................    unsigned int LATB12:1; 
....................    unsigned int LATB13:1; 
....................    unsigned int LATB14:1; 
....................    unsigned int LATB15:1; 
.................... } LATBBITS; 
.................... LATBBITS LATBbits; 
.................... #word LATBbits = 0x2CC 
.................... #word LATB = 0x2CC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ODB0:16; 
....................       }; 
....................       struct { 
....................          unsigned int ODB:16; 
....................       }; 
.................... } ODCBBITS; 
.................... ODCBBITS ODCBbits; 
.................... #word ODCBbits = 0x2CE 
.................... #word ODCB = 0x2CE 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
....................    unsigned int TRISC8:1; 
....................    unsigned int TRISC9:1; 
....................    unsigned int TRISC10:1; 
....................    unsigned int TRISC11:1; 
....................    unsigned int TRISC12:1; 
....................    unsigned int TRISC13:1; 
....................    unsigned int TRISC14:1; 
....................    unsigned int TRISC15:1; 
.................... } TRISCBITS; 
.................... TRISCBITS TRISCbits; 
.................... #word TRISCbits = 0x2D0 
.................... #word TRISC = 0x2D0 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
....................    unsigned int RC8:1; 
....................    unsigned int RC9:1; 
....................    unsigned int RC10:1; 
....................    unsigned int RC11:1; 
....................    unsigned int RC12:1; 
....................    unsigned int RC13:1; 
....................    unsigned int RC14:1; 
....................    unsigned int RC15:1; 
.................... } PORTCBITS; 
.................... PORTCBITS PORTCbits; 
.................... #word PORTCbits = 0x2D2 
.................... #word PORTC = 0x2D2 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
....................    unsigned int LATC8:1; 
....................    unsigned int LATC9:1; 
....................    unsigned int LATC10:1; 
....................    unsigned int LATC11:1; 
....................    unsigned int LATC12:1; 
....................    unsigned int LATC13:1; 
....................    unsigned int LATC14:1; 
....................    unsigned int LATC15:1; 
.................... } LATCBITS; 
.................... LATCBITS LATCbits; 
.................... #word LATCbits = 0x2D4 
.................... #word LATC = 0x2D4 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :12; 
....................    unsigned int ODC12:4; 
.................... } ODCCBITS; 
.................... ODCCBITS ODCCbits; 
.................... #word ODCCbits = 0x2D6 
.................... #word ODCC = 0x2D6 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
....................    unsigned int TRISD8:1; 
....................    unsigned int TRISD9:1; 
....................    unsigned int TRISD10:1; 
....................    unsigned int TRISD11:1; 
....................    unsigned int TRISD12:1; 
....................    unsigned int TRISD13:1; 
....................    unsigned int TRISD14:1; 
....................    unsigned int TRISD15:1; 
.................... } TRISDBITS; 
.................... TRISDBITS TRISDbits; 
.................... #word TRISDbits = 0x2D8 
.................... #word TRISD = 0x2D8 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
....................    unsigned int RD8:1; 
....................    unsigned int RD9:1; 
....................    unsigned int RD10:1; 
....................    unsigned int RD11:1; 
....................    unsigned int RD12:1; 
....................    unsigned int RD13:1; 
....................    unsigned int RD14:1; 
....................    unsigned int RD15:1; 
.................... } PORTDBITS; 
.................... PORTDBITS PORTDbits; 
.................... #word PORTDbits = 0x2DA 
.................... #word PORTD = 0x2DA 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
....................    unsigned int LATD8:1; 
....................    unsigned int LATD9:1; 
....................    unsigned int LATD10:1; 
....................    unsigned int LATD11:1; 
....................    unsigned int LATD12:1; 
....................    unsigned int LATD13:1; 
....................    unsigned int LATD14:1; 
....................    unsigned int LATD15:1; 
.................... } LATDBITS; 
.................... LATDBITS LATDbits; 
.................... #word LATDbits = 0x2DC 
.................... #word LATD = 0x2DC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ODD0:12; 
....................       }; 
....................       struct { 
....................          unsigned int ODD:12; 
....................       }; 
.................... } ODCDBITS; 
.................... ODCDBITS ODCDbits; 
.................... #word ODCDbits = 0x2DE 
.................... #word ODCD = 0x2DE 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int TRISE3:1; 
....................    unsigned int TRISE4:1; 
....................    unsigned int TRISE5:1; 
....................    unsigned int TRISE6:1; 
....................    unsigned int TRISE7:1; 
....................    unsigned int TRISE8:1; 
....................    unsigned int TRISE9:1; 
....................    unsigned int TRISE10:1; 
....................    unsigned int TRISE11:1; 
....................    unsigned int TRISE12:1; 
....................    unsigned int TRISE13:1; 
....................    unsigned int TRISE14:1; 
....................    unsigned int TRISE15:1; 
.................... } TRISEBITS; 
.................... TRISEBITS TRISEbits; 
.................... #word TRISEbits = 0x2E0 
.................... #word TRISE = 0x2E0 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RE0:1; 
....................    unsigned int RE1:1; 
....................    unsigned int RE2:1; 
....................    unsigned int RE3:1; 
....................    unsigned int RE4:1; 
....................    unsigned int RE5:1; 
....................    unsigned int RE6:1; 
....................    unsigned int RE7:1; 
....................    unsigned int RE8:1; 
....................    unsigned int RE9:1; 
....................    unsigned int RE10:1; 
....................    unsigned int RE11:1; 
....................    unsigned int RE12:1; 
....................    unsigned int RE13:1; 
....................    unsigned int RE14:1; 
....................    unsigned int RE15:1; 
.................... } PORTEBITS; 
.................... PORTEBITS PORTEbits; 
.................... #word PORTEbits = 0x2E2 
.................... #word PORTE = 0x2E2 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
....................    unsigned int LATE8:1; 
....................    unsigned int LATE9:1; 
....................    unsigned int LATE10:1; 
....................    unsigned int LATE11:1; 
....................    unsigned int LATE12:1; 
....................    unsigned int LATE13:1; 
....................    unsigned int LATE14:1; 
....................    unsigned int LATE15:1; 
.................... } LATEBITS; 
.................... LATEBITS LATEbits; 
.................... #word LATEbits = 0x2E4 
.................... #word LATE = 0x2E4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ODE0:8; 
....................       }; 
....................       struct { 
....................          unsigned int ODE:8; 
....................       }; 
.................... } ODCEBITS; 
.................... ODCEBITS ODCEbits; 
.................... #word ODCEbits = 0x2E6 
.................... #word ODCE = 0x2E6 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISF0:1; 
....................    unsigned int TRISF1:1; 
....................    unsigned int TRISF2:1; 
....................    unsigned int TRISF3:1; 
....................    unsigned int TRISF4:1; 
....................    unsigned int TRISF5:1; 
....................    unsigned int TRISF6:1; 
....................    unsigned int TRISF7:1; 
....................    unsigned int TRISF8:1; 
....................    unsigned int TRISF9:1; 
....................    unsigned int TRISF10:1; 
....................    unsigned int TRISF11:1; 
....................    unsigned int TRISF12:1; 
....................    unsigned int TRISF13:1; 
....................    unsigned int TRISF14:1; 
....................    unsigned int TRISF15:1; 
.................... } TRISFBITS; 
.................... TRISFBITS TRISFbits; 
.................... #word TRISFbits = 0x2E8 
.................... #word TRISF = 0x2E8 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RF0:1; 
....................    unsigned int RF1:1; 
....................    unsigned int RF2:1; 
....................    unsigned int RF3:1; 
....................    unsigned int RF4:1; 
....................    unsigned int RF5:1; 
....................    unsigned int RF6:1; 
....................    unsigned int RF7:1; 
....................    unsigned int RF8:1; 
....................    unsigned int RF9:1; 
....................    unsigned int RF10:1; 
....................    unsigned int RF11:1; 
....................    unsigned int RF12:1; 
....................    unsigned int RF13:1; 
....................    unsigned int RF14:1; 
....................    unsigned int RF15:1; 
.................... } PORTFBITS; 
.................... PORTFBITS PORTFbits; 
.................... #word PORTFbits = 0x2EA 
.................... #word PORTF = 0x2EA 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATF0:1; 
....................    unsigned int LATF1:1; 
....................    unsigned int LATF2:1; 
....................    unsigned int LATF3:1; 
....................    unsigned int LATF4:1; 
....................    unsigned int LATF5:1; 
....................    unsigned int LATF6:1; 
....................    unsigned int LATF7:1; 
....................    unsigned int LATF8:1; 
....................    unsigned int LATF9:1; 
....................    unsigned int LATF10:1; 
....................    unsigned int LATF11:1; 
....................    unsigned int LATF12:1; 
....................    unsigned int LATF13:1; 
....................    unsigned int LATF14:1; 
....................    unsigned int LATF15:1; 
.................... } LATFBITS; 
.................... LATFBITS LATFbits; 
.................... #word LATFbits = 0x2EC 
.................... #word LATF = 0x2EC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ODF0:2; 
....................          unsigned int :1; 
....................          unsigned int ODF3:3; 
....................          unsigned int :1; 
....................          unsigned int ODF7:1; 
....................       }; 
....................       struct { 
....................          unsigned int ODF00:2; 
....................          unsigned int :1; 
....................          unsigned int ODF03:3; 
....................       }; 
.................... } ODCFBITS; 
.................... ODCFBITS ODCFbits; 
.................... #word ODCFbits = 0x2EE 
.................... #word ODCF = 0x2EE 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISG0:1; 
....................    unsigned int TRISG1:1; 
....................    unsigned int TRISG2:1; 
....................    unsigned int TRISG3:1; 
....................    unsigned int TRISG4:1; 
....................    unsigned int TRISG5:1; 
....................    unsigned int TRISG6:1; 
....................    unsigned int TRISG7:1; 
....................    unsigned int TRISG8:1; 
....................    unsigned int TRISG9:1; 
....................    unsigned int TRISG10:1; 
....................    unsigned int TRISG11:1; 
....................    unsigned int TRISG12:1; 
....................    unsigned int TRISG13:1; 
....................    unsigned int TRISG14:1; 
....................    unsigned int TRISG15:1; 
.................... } TRISGBITS; 
.................... TRISGBITS TRISGbits; 
.................... #word TRISGbits = 0x2F0 
.................... #word TRISG = 0x2F0 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RG0:1; 
....................    unsigned int RG1:1; 
....................    unsigned int RG2:1; 
....................    unsigned int RG3:1; 
....................    unsigned int RG4:1; 
....................    unsigned int RG5:1; 
....................    unsigned int RG6:1; 
....................    unsigned int RG7:1; 
....................    unsigned int RG8:1; 
....................    unsigned int RG9:1;   
....................    unsigned int RG10:1; 
....................    unsigned int RG11:1; 
....................    unsigned int RG12:1; 
....................    unsigned int RG13:1; 
....................    unsigned int RG14:1; 
....................    unsigned int RG15:1; 
.................... } PORTGBITS; 
.................... PORTGBITS PORTGbits; 
.................... #word PORTGbits = 0x2F2 
.................... #word PORTG = 0x2F2 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATG0:1; 
....................    unsigned int LATG1:1; 
....................    unsigned int LATG2:1; 
....................    unsigned int LATG3:1; 
....................    unsigned int LATG4:1; 
....................    unsigned int LATG5:1; 
....................    unsigned int LATG6:1; 
....................    unsigned int LATG7:1; 
....................    unsigned int LATG8:1; 
....................    unsigned int LATG9:1; 
....................    unsigned int LATG10:1; 
....................    unsigned int LATG11:1; 
....................    unsigned int LATG12:1; 
....................    unsigned int LATG13:1; 
....................    unsigned int LATG14:1; 
....................    unsigned int LATG15:1; 
.................... } LATGBITS; 
.................... LATGBITS LATGbits; 
.................... #word LATGbits = 0x2F4 
.................... #word LATG = 0x2F4 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :2; 
....................    unsigned int ODG2:2; 
....................    unsigned int :2; 
....................    unsigned int ODG6:4; 
.................... } ODCGBITS; 
.................... ODCGBITS ODCGbits; 
.................... #word ODCGbits = 0x2F6 
.................... #word ODCG = 0x2F6 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int PMPTTL:1; 
....................          unsigned int RTSECSEL:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int RTSECSEL0:1; 
....................       }; 
....................    }; 
.................... } PADCFG1BITS; 
.................... PADCFG1BITS PADCFG1bits; 
.................... #word PADCFG1bits = 0x2FC 
.................... #word PADCFG1 = 0x2FC 
....................  
.................... #word ADC1BUF0 = 0x300 
....................  
.................... #word ADC1BUF1 = 0x302 
....................  
.................... #word ADC1BUF2 = 0x304 
....................  
.................... #word ADC1BUF3 = 0x306 
....................  
.................... #word ADC1BUF4 = 0x308 
....................  
.................... #word ADC1BUF5 = 0x30A 
....................  
.................... #word ADC1BUF6 = 0x30C 
....................  
.................... #word ADC1BUF7 = 0x30E 
....................  
.................... #word ADC1BUF8 = 0x310 
....................  
.................... #word ADC1BUF9 = 0x312 
....................  
.................... #word ADC1BUFA = 0x314 
....................  
.................... #word ADC1BUFB = 0x316 
....................  
.................... #word ADC1BUFC = 0x318 
....................  
.................... #word ADC1BUFD = 0x31A 
....................  
.................... #word ADC1BUFE = 0x31C 
....................  
.................... #word ADC1BUFF = 0x31E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int DONE:1; 
....................          unsigned int SAMP:1; 
....................          unsigned int ASAM:1; 
....................          unsigned int :2; 
....................          unsigned int SSRC0:3; 
....................          unsigned int FORM0:2; 
....................          unsigned int :3; 
....................          unsigned int ADSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int ADON:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :2; 
....................          unsigned int SSRC:3; 
....................          unsigned int FORM:2; 
....................          unsigned int :3; 
....................       }; 
.................... } AD1CON1BITS; 
.................... AD1CON1BITS AD1CON1bits; 
.................... #word AD1CON1bits = 0x320 
.................... #word AD1CON1 = 0x320 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ALTS:1; 
....................          unsigned int BUFM:1; 
....................          unsigned int SMPI0:5; 
....................          unsigned int BUFS:1; 
....................          unsigned int :2; 
....................          unsigned int CSCNA:1; 
....................          unsigned int :2; 
....................          unsigned int VCFG0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SMPI:5; 
....................          unsigned int :1; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :2; 
....................          unsigned int VCFG:3; 
....................       }; 
.................... } AD1CON2BITS; 
.................... AD1CON2BITS AD1CON2bits; 
.................... #word AD1CON2bits = 0x322 
.................... #word AD1CON2 = 0x322 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ADCS0:8; 
....................          unsigned int SAMC0:5; 
....................          unsigned int :2; 
....................          unsigned int ADRC:1; 
....................       }; 
....................       struct { 
....................          unsigned int ADCS:8; 
....................          unsigned int SAMC:5; 
....................          unsigned int :2; 
....................       }; 
.................... } AD1CON3BITS; 
.................... AD1CON3BITS AD1CON3bits; 
.................... #word AD1CON3bits = 0x324 
.................... #word AD1CON3 = 0x324 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CH0SA0:5; 
....................          unsigned int :2; 
....................          unsigned int CH0NA:1; 
....................          unsigned int CH0SB0:5; 
....................          unsigned int :2; 
....................          unsigned int CH0NB:1; 
....................       }; 
....................       struct { 
....................          unsigned int CH0SA:5; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int CH0SB:5; 
....................          unsigned int :2; 
....................       }; 
.................... } AD1CHSBITS; 
.................... AD1CHSBITS AD1CHSbits; 
.................... #word AD1CHSbits = 0x328 
.................... #word AD1CHS = 0x328 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :8; 
....................    unsigned int CSSL24:4; 
.................... } AD1CSSHBITS; 
.................... AD1CSSHBITS AD1CSSHbits; 
.................... #word AD1CSSHbits = 0x32E 
.................... #word AD1CSSH = 0x32E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CSSL0:16; 
....................       }; 
....................       struct { 
....................          unsigned int CSSL:16; 
....................       }; 
.................... } AD1CSSLBITS; 
.................... AD1CSSLBITS AD1CSSLbits; 
.................... #word AD1CSSLbits = 0x330 
.................... #word AD1CSSL = 0x330 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EDG1STAT:1; 
....................          unsigned int EDG2STAT:1; 
....................          unsigned int EDG1SEL0:2; 
....................          unsigned int EDG1POL:1; 
....................          unsigned int EDG2SEL0:2; 
....................          unsigned int EDG2POL:1; 
....................          unsigned int CTTRIG:1; 
....................          unsigned int IDISSEN:1; 
....................          unsigned int EDGSEQEN:1; 
....................          unsigned int EDGEN:1; 
....................          unsigned int TGEN:1; 
....................          unsigned int CTMUSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int CTMUEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int EDG1SEL:2; 
....................          unsigned int :1; 
....................          unsigned int EDG2SEL:2; 
....................       }; 
.................... } CTMUCONBITS; 
.................... CTMUCONBITS CTMUCONbits; 
.................... #word CTMUCONbits = 0x33C 
.................... #word CTMUCON = 0x33C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int IRNG0:2; 
....................          unsigned int ITRIM0:6; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int IRNG:2; 
....................          unsigned int ITRIM:6; 
....................       }; 
.................... } CTMUICONBITS; 
.................... CTMUICONBITS CTMUICONbits; 
.................... #word CTMUICONbits = 0x33E 
.................... #word CTMUICON = 0x33E 
....................  
.................... #word ADC1BUF10 = 0x340 
....................  
.................... #word ADC1BUF11 = 0x342 
....................  
.................... #word ADC1BUF12 = 0x344 
....................  
.................... #word ADC1BUF13 = 0x346 
....................  
.................... #word ADC1BUF14 = 0x348 
....................  
.................... #word ADC1BUF15 = 0x34A 
....................  
.................... #word ADC1BUF16 = 0x34C 
....................  
.................... #word ADC1BUF17 = 0x34E 
....................  
.................... #word ADC1BUF18 = 0x350 
....................  
.................... #word ADC1BUF19 = 0x352 
....................  
.................... #word ADC1BUF1A = 0x354 
....................  
.................... #word ADC1BUF1B = 0x356 
....................  
.................... #word ADC1BUF1C = 0x358 
....................  
.................... #word ADC1BUF1D = 0x35A 
....................  
.................... #word ADC1BUF1E = 0x35C 
....................  
.................... #word ADC1BUF1F = 0x35E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int VBUSVDIF:1; 
....................    unsigned int :1; 
....................    unsigned int SESENDIF:1; 
....................    unsigned int SESVDIF:1; 
....................    unsigned int ACTVIF:1; 
....................    unsigned int LSTATEIF:1; 
....................    unsigned int T1MSECIF:1; 
....................    unsigned int IDIF:1; 
.................... } U1OTGIRBITS; 
.................... U1OTGIRBITS U1OTGIRbits; 
.................... #word U1OTGIRbits = 0x480 
.................... #word U1OTGIR = 0x480 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int VBUSVDIE:1; 
....................    unsigned int :1; 
....................    unsigned int SESENDIE:1; 
....................    unsigned int SESVDIE:1; 
....................    unsigned int ACTVIE:1; 
....................    unsigned int LSTATEIE:1; 
....................    unsigned int T1MSECIE:1; 
....................    unsigned int IDIE:1; 
.................... } U1OTGIEBITS; 
.................... U1OTGIEBITS U1OTGIEbits; 
.................... #word U1OTGIEbits = 0x482 
.................... #word U1OTGIE = 0x482 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int VBUSVD:1; 
....................    unsigned int :1; 
....................    unsigned int SESEND:1; 
....................    unsigned int SESVD:1; 
....................    unsigned int :1; 
....................    unsigned int LSTATE:1; 
....................    unsigned int :1; 
....................    unsigned int ID:1; 
.................... } U1OTGSTATBITS; 
.................... U1OTGSTATBITS U1OTGSTATbits; 
.................... #word U1OTGSTATbits = 0x484 
.................... #word U1OTGSTAT = 0x484 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int VBUSDIS:1; 
....................    unsigned int VBUSCHG:1; 
....................    unsigned int OTGEN:1; 
....................    unsigned int VBUSON:1; 
....................    unsigned int DMPULDWN:1; 
....................    unsigned int DPPULDWN:1; 
....................    unsigned int DMPULUP:1; 
....................    unsigned int DPPULUP:1; 
.................... } U1OTGCONBITS; 
.................... U1OTGCONBITS U1OTGCONbits; 
.................... #word U1OTGCONbits = 0x486 
.................... #word U1OTGCON = 0x486 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int USBPWR:1; 
....................          unsigned int USUSPND:1; 
....................          unsigned int :2; 
....................          unsigned int USLPGRD:1; 
....................          unsigned int :2; 
....................          unsigned int UACTPND:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int USUSPEND:1; 
....................       }; 
....................    }; 
.................... } U1PWRCBITS; 
.................... U1PWRCBITS U1PWRCbits; 
.................... #word U1PWRCbits = 0x488 
.................... #word U1PWRC = 0x488 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int URSTIF:1; 
....................          unsigned int UERRIF:1; 
....................          unsigned int SOFIF:1; 
....................          unsigned int TRNIF:1; 
....................          unsigned int IDLEIF:1; 
....................          unsigned int RESUMEIF:1; 
....................          unsigned int ATTACHIF:1; 
....................          unsigned int STALLIF:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int DETACHIF:1; 
....................       }; 
....................    }; 
.................... } U1IRBITS; 
.................... U1IRBITS U1IRbits; 
.................... #word U1IRbits = 0x48A 
.................... #word U1IR = 0x48A 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int URSTIE:1; 
....................          unsigned int UERRIE:1; 
....................          unsigned int SOFIE:1; 
....................          unsigned int TRNIE:1; 
....................          unsigned int IDLEIE:1; 
....................          unsigned int RESUMEIE:1; 
....................          unsigned int ATTACHIE:1; 
....................          unsigned int STALLIE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int DETACHIE:1; 
....................       }; 
....................    }; 
.................... } U1IEBITS; 
.................... U1IEBITS U1IEbits; 
.................... #word U1IEbits = 0x48C 
.................... #word U1IE = 0x48C 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int PIDEF:1; 
....................          unsigned int CRC5EF:1; 
....................          unsigned int CRC16EF:1; 
....................          unsigned int DFN8EF:1; 
....................          unsigned int BTOEF:1; 
....................          unsigned int DMAEF:1; 
....................          unsigned int :1; 
....................          unsigned int BTSEF:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int EOFEF:1; 
....................       }; 
....................    }; 
.................... } U1EIRBITS; 
.................... U1EIRBITS U1EIRbits; 
.................... #word U1EIRbits = 0x48E 
.................... #word U1EIR = 0x48E 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int PIDEE:1; 
....................          unsigned int CRC5EE:1; 
....................          unsigned int CRC16EE:1; 
....................          unsigned int DFN8EE:1; 
....................          unsigned int BTOEE:1; 
....................          unsigned int DMAEE:1; 
....................          unsigned int :1; 
....................          unsigned int BTSEE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int EOFEE:1; 
....................       }; 
....................    }; 
.................... } U1EIEBITS; 
.................... U1EIEBITS U1EIEbits; 
.................... #word U1EIEbits = 0x490 
.................... #word U1EIE = 0x490 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int PPBI:1; 
....................          unsigned int DIR:1; 
....................          unsigned int ENDPT0:4; 
....................       }; 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int ENDPT:4; 
....................       }; 
.................... } U1STATBITS; 
.................... U1STATBITS U1STATbits; 
.................... #word U1STATbits = 0x492 
.................... #word U1STAT = 0x492 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int USBEN:1; 
....................          unsigned int PPBRST:1; 
....................          unsigned int RESUME:1; 
....................          unsigned int HOSTEN:1; 
....................          unsigned int USBRST:1; 
....................          unsigned int PKTDIS:1; 
....................          unsigned int SE0:1; 
....................          unsigned int JSTATE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int SOFEN:1; 
....................          unsigned int :3; 
....................          unsigned int RESET:1; 
....................          unsigned int TOKBUSY:1; 
....................       }; 
....................    }; 
.................... } U1CONBITS; 
.................... U1CONBITS U1CONbits; 
.................... #word U1CONbits = 0x494 
.................... #word U1CON = 0x494 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int DEVADDR0:7; 
....................          unsigned int LOWSPDEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int DEVADDR:7; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :7; 
....................          unsigned int LSPDEN:1; 
....................       }; 
....................    }; 
.................... } U1ADDRBITS; 
.................... U1ADDRBITS U1ADDRbits; 
.................... #word U1ADDRbits = 0x496 
.................... #word U1ADDR = 0x496 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int BDTPTRL0:7; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int BDTPTRL:7; 
....................       }; 
.................... } U1BDTP1BITS; 
.................... U1BDTP1BITS U1BDTP1bits; 
.................... #word U1BDTP1bits = 0x498 
.................... #word U1BDTP1 = 0x498 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int FRM0:8; 
....................       }; 
....................       struct { 
....................          unsigned int FRM:8; 
....................       }; 
.................... } U1FRMLBITS; 
.................... U1FRMLBITS U1FRMLbits; 
.................... #word U1FRMLbits = 0x49A 
.................... #word U1FRML = 0x49A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int FRM8:3; 
.................... } U1FRMHBITS; 
.................... U1FRMHBITS U1FRMHbits; 
.................... #word U1FRMHbits = 0x49C 
.................... #word U1FRMH = 0x49C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EP0:4; 
....................          unsigned int PID0:4; 
....................       }; 
....................       struct { 
....................          unsigned int EP:4; 
....................          unsigned int PID:4; 
....................       }; 
.................... } U1TOKBITS; 
.................... U1TOKBITS U1TOKbits; 
.................... #word U1TOKbits = 0x49E 
.................... #word U1TOK = 0x49E 
....................  
.................... #word U1SOF = 0x4A0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CNT0:8; 
....................       }; 
....................       struct { 
....................          unsigned int CNT:8; 
....................       }; 
.................... } U1SOFBITS; 
.................... U1SOFBITS U1SOFbits; 
.................... #word U1SOFbits = 0x4A0 
.................... #word U1SOF = 0x4A0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PPB0:2; 
....................          unsigned int :2; 
....................          unsigned int USBSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int UOEMON:1; 
....................          unsigned int UTEYE:1; 
....................       }; 
....................       struct { 
....................          unsigned int PPB:2; 
....................          unsigned int :2; 
....................       }; 
.................... } U1CNFG1BITS; 
.................... U1CNFG1BITS U1CNFG1bits; 
.................... #word U1CNFG1bits = 0x4A6 
.................... #word U1CNFG1 = 0x4A6 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int UTRDIS:1; 
....................    unsigned int UVCMPDIS:1; 
....................    unsigned int UVBUSDIS:1; 
....................    unsigned int EXTI2CEN:1; 
....................    unsigned int PUVBUS:1; 
....................    unsigned int UVCMPSEL:1; 
.................... } U1CNFG2BITS; 
.................... U1CNFG2BITS U1CNFG2bits; 
.................... #word U1CNFG2bits = 0x4A8 
.................... #word U1CNFG2 = 0x4A8 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................          unsigned int :1; 
....................          unsigned int RETRYDIS:1; 
....................          unsigned int LSPD:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................          unsigned int :3; 
....................          unsigned int LOWSPD:1; 
....................       }; 
....................    }; 
.................... } U1EP0BITS; 
.................... U1EP0BITS U1EP0bits; 
.................... #word U1EP0bits = 0x4AA 
.................... #word U1EP0 = 0x4AA 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP1BITS; 
.................... U1EP1BITS U1EP1bits; 
.................... #word U1EP1bits = 0x4AC 
.................... #word U1EP1 = 0x4AC 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP2BITS; 
.................... U1EP2BITS U1EP2bits; 
.................... #word U1EP2bits = 0x4AE 
.................... #word U1EP2 = 0x4AE 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP3BITS; 
.................... U1EP3BITS U1EP3bits; 
.................... #word U1EP3bits = 0x4B0 
.................... #word U1EP3 = 0x4B0 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP4BITS; 
.................... U1EP4BITS U1EP4bits; 
.................... #word U1EP4bits = 0x4B2 
.................... #word U1EP4 = 0x4B2 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP5BITS; 
.................... U1EP5BITS U1EP5bits; 
.................... #word U1EP5bits = 0x4B4 
.................... #word U1EP5 = 0x4B4 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP6BITS; 
.................... U1EP6BITS U1EP6bits; 
.................... #word U1EP6bits = 0x4B6 
.................... #word U1EP6 = 0x4B6 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP7BITS; 
.................... U1EP7BITS U1EP7bits; 
.................... #word U1EP7bits = 0x4B8 
.................... #word U1EP7 = 0x4B8 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP8BITS; 
.................... U1EP8BITS U1EP8bits; 
.................... #word U1EP8bits = 0x4BA 
.................... #word U1EP8 = 0x4BA 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP9BITS; 
.................... U1EP9BITS U1EP9bits; 
.................... #word U1EP9bits = 0x4BC 
.................... #word U1EP9 = 0x4BC 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP10BITS; 
.................... U1EP10BITS U1EP10bits; 
.................... #word U1EP10bits = 0x4BE 
.................... #word U1EP10 = 0x4BE 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP11BITS; 
.................... U1EP11BITS U1EP11bits; 
.................... #word U1EP11bits = 0x4C0 
.................... #word U1EP11 = 0x4C0 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP12BITS; 
.................... U1EP12BITS U1EP12bits; 
.................... #word U1EP12bits = 0x4C2 
.................... #word U1EP12 = 0x4C2 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP13BITS; 
.................... U1EP13BITS U1EP13bits; 
.................... #word U1EP13bits = 0x4C4 
.................... #word U1EP13 = 0x4C4 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP14BITS; 
.................... U1EP14BITS U1EP14bits; 
.................... #word U1EP14bits = 0x4C6 
.................... #word U1EP14 = 0x4C6 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EPHSHK:1; 
....................          unsigned int EPSTALL:1; 
....................          unsigned int EPTXEN:1; 
....................          unsigned int EPRXEN:1; 
....................          unsigned int EPCONDIS:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int EPINEN:1; 
....................          unsigned int EPOUTEN:1; 
....................       }; 
....................    }; 
.................... } U1EP15BITS; 
.................... U1EP15BITS U1EP15bits; 
.................... #word U1EP15bits = 0x4C8 
.................... #word U1EP15 = 0x4C8 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int PER0:8; 
....................          unsigned int DC0:8; 
....................       }; 
....................       struct { 
....................          unsigned int PER:8; 
....................          unsigned int DC:8; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int USBRS0:8; 
....................          unsigned int USBR0:8; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int USBRS:8; 
....................          unsigned int USBR:8; 
....................       }; 
.................... } U1PWMRRSBITS; 
.................... U1PWMRRSBITS U1PWMRRSbits; 
.................... #word U1PWMRRSbits = 0x4CC 
.................... #word U1PWMRRS = 0x4CC 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :8; 
....................    unsigned int CNTEN:1; 
....................    unsigned int PWMPOL:1; 
....................    unsigned int :5; 
....................    unsigned int PWMEN:1; 
.................... } U1PWMCONBITS; 
.................... U1PWMCONBITS U1PWMCONbits; 
.................... #word U1PWMCONbits = 0x4CE 
.................... #word U1PWMCON = 0x4CE 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int VBGEN:1; 
....................    unsigned int VBG2EN:1; 
....................    unsigned int VBG6EN:1; 
.................... } ANCFGBITS; 
.................... ANCFGBITS ANCFGbits; 
.................... #word ANCFGbits = 0x4DE 
.................... #word ANCFG = 0x4DE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ANSB0:16; 
....................       }; 
....................       struct { 
....................          unsigned int ANSB:16; 
....................       }; 
.................... } ANSBBITS; 
.................... ANSBBITS ANSBbits; 
.................... #word ANSBbits = 0x4E2 
.................... #word ANSB = 0x4E2 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :13; 
....................    unsigned int ANSC13:2; 
.................... } ANSCBITS; 
.................... ANSCBITS ANSCbits; 
.................... #word ANSCbits = 0x4E4 
.................... #word ANSC = 0x4E4 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :6; 
....................    unsigned int ANSD6:2; 
.................... } ANSDBITS; 
.................... ANSDBITS ANSDbits; 
.................... #word ANSDbits = 0x4E6 
.................... #word ANSD = 0x4E6 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int ANSF0:1; 
.................... } ANSFBITS; 
.................... ANSFBITS ANSFbits; 
.................... #word ANSFbits = 0x4EA 
.................... #word ANSF = 0x4EA 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :6; 
....................    unsigned int ANSG6:4; 
.................... } ANSGBITS; 
.................... ANSGBITS ANSGbits; 
.................... #word ANSGbits = 0x4EC 
.................... #word ANSG = 0x4EC 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IRQM0:2; 
....................          unsigned int BUSKEEP:1; 
....................          unsigned int :1; 
....................          unsigned int ALMODE:1; 
....................          unsigned int ALP:1; 
....................          unsigned int CSF0:2; 
....................          unsigned int MODE0:2; 
....................          unsigned int :1; 
....................          unsigned int ADRMUX0:2; 
....................          unsigned int PSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int PMPEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int IRQM:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int CSF:2; 
....................          unsigned int MODE:2; 
....................          unsigned int :1; 
....................          unsigned int ADRMUX:2; 
....................       }; 
.................... } PMCON1BITS; 
.................... PMCON1BITS PMCON1bits; 
.................... #word PMCON1bits = 0x600 
.................... #word PMCON1 = 0x600 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int RADDR0:8; 
....................          unsigned int :4; 
....................          unsigned int TIMEOUT:1; 
....................          unsigned int ERROR:1; 
....................          unsigned int :1; 
....................          unsigned int BUSY:1; 
....................       }; 
....................       struct { 
....................          unsigned int RADDR:8; 
....................          unsigned int :4; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int RADDR16:4; 
....................          unsigned int RADDR20:4; 
....................       }; 
....................    }; 
.................... } PMCON2BITS; 
.................... PMCON2BITS PMCON2bits; 
.................... #word PMCON2bits = 0x602 
.................... #word PMCON2 = 0x602 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RES0:7; 
....................          unsigned int :1; 
....................          unsigned int AWAITE:1; 
....................          unsigned int AWAITM0:2; 
....................          unsigned int :1; 
....................          unsigned int PTBE0EN:1; 
....................          unsigned int PTBE1EN:1; 
....................          unsigned int PTRDEN:1; 
....................          unsigned int PTWREN:1; 
....................       }; 
....................       struct { 
....................          unsigned int RES:7; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int AWAITM:2; 
....................       }; 
.................... } PMCON3BITS; 
.................... PMCON3BITS PMCON3bits; 
.................... #word PMCON3bits = 0x604 
.................... #word PMCON3 = 0x604 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PTEN0:16; 
....................       }; 
....................       struct { 
....................          unsigned int PTEN:16; 
....................       }; 
.................... } PMCON4BITS; 
.................... PMCON4BITS PMCON4bits; 
.................... #word PMCON4bits = 0x606 
.................... #word PMCON4 = 0x606 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int PTSZ0:2; 
....................          unsigned int ACKP:1; 
....................          unsigned int SM:1; 
....................          unsigned int RDSP:1; 
....................          unsigned int WRSP:1; 
....................          unsigned int :1; 
....................          unsigned int BEP:1; 
....................          unsigned int CSPTEN:1; 
....................          unsigned int CSP:1; 
....................          unsigned int CSDIS:1; 
....................       }; 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int PTSZ:2; 
....................       }; 
.................... } PMCS1CFBITS; 
.................... PMCS1CFBITS PMCS1CFbits; 
.................... #word PMCS1CFbits = 0x608 
.................... #word PMCS1CF = 0x608 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :3; 
....................    unsigned int BASE11:1; 
....................    unsigned int :3; 
....................    unsigned int BASE15:5; 
....................    unsigned int BASE20:4; 
.................... } PMCS1BSBITS; 
.................... PMCS1BSBITS PMCS1BSbits; 
.................... #word PMCS1BSbits = 0x60A 
.................... #word PMCS1BS = 0x60A 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int DWAITE0:2; 
....................          unsigned int DWAITM0:4; 
....................          unsigned int DWAITB0:2; 
....................          unsigned int :6; 
....................          unsigned int ACKM0:2; 
....................       }; 
....................       struct { 
....................          unsigned int DWAITE:2; 
....................          unsigned int DWAITM:4; 
....................          unsigned int DWAITB:2; 
....................          unsigned int :6; 
....................          unsigned int ACKM:2; 
....................       }; 
.................... } PMCS1MDBITS; 
.................... PMCS1MDBITS PMCS1MDbits; 
.................... #word PMCS1MDbits = 0x60C 
.................... #word PMCS1MD = 0x60C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int PTSZ0:2; 
....................          unsigned int ACKP:1; 
....................          unsigned int SM:1; 
....................          unsigned int RDSP:1; 
....................          unsigned int WRSP:1; 
....................          unsigned int :1; 
....................          unsigned int BEP:1; 
....................          unsigned int CSPTEN:1; 
....................          unsigned int CSP:1; 
....................          unsigned int CSDIS:1; 
....................       }; 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int PTSZ:2; 
....................       }; 
.................... } PMCS2CFBITS; 
.................... PMCS2CFBITS PMCS2CFbits; 
.................... #word PMCS2CFbits = 0x60E 
.................... #word PMCS2CF = 0x60E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :3; 
....................    unsigned int BASE11:1; 
....................    unsigned int :3; 
....................    unsigned int BASE15:5; 
....................    unsigned int BASE20:4; 
.................... } PMCS2BSBITS; 
.................... PMCS2BSBITS PMCS2BSbits; 
.................... #word PMCS2BSbits = 0x610 
.................... #word PMCS2BS = 0x610 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int DWAITE0:2; 
....................          unsigned int DWAITM0:4; 
....................          unsigned int DWAITB0:2; 
....................          unsigned int :6; 
....................          unsigned int ACKM0:2; 
....................       }; 
....................       struct { 
....................          unsigned int DWAITE:2; 
....................          unsigned int DWAITM:4; 
....................          unsigned int DWAITB:2; 
....................          unsigned int :6; 
....................          unsigned int ACKM:2; 
....................       }; 
.................... } PMCS2MDBITS; 
.................... PMCS2MDBITS PMCS2MDbits; 
.................... #word PMCS2MDbits = 0x612 
.................... #word PMCS2MD = 0x612 
....................  
.................... #word PMDOUT1 = 0x614 
....................  
.................... #word PMDOUT2 = 0x616 
....................  
.................... #word PMDIN1 = 0x618 
....................  
.................... #word PMDIN2 = 0x61A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int OB0E:1; 
....................    unsigned int OB1E:1; 
....................    unsigned int OB2E:1; 
....................    unsigned int OB3E:1; 
....................    unsigned int :2; 
....................    unsigned int OBUF:1; 
....................    unsigned int OBE:1; 
....................    unsigned int IB0F:1; 
....................    unsigned int IB1F:1; 
....................    unsigned int IB2F:1; 
....................    unsigned int IB3F:1; 
....................    unsigned int :2; 
....................    unsigned int IBOV:1; 
....................    unsigned int IBF:1; 
.................... } PMSTATBITS; 
.................... PMSTATBITS PMSTATbits; 
.................... #word PMSTATbits = 0x61C 
.................... #word PMSTAT = 0x61C 
....................  
.................... #word ALRMVAL = 0x620 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ARPT0:8; 
....................          unsigned int ALRMPTR0:2; 
....................          unsigned int AMASK0:4; 
....................          unsigned int CHIME:1; 
....................          unsigned int ALRMEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int ARPT:8; 
....................          unsigned int ALRMPTR:2; 
....................          unsigned int AMASK:4; 
....................       }; 
.................... } ALCFGRPTBITS; 
.................... ALCFGRPTBITS ALCFGRPTbits; 
.................... #word ALCFGRPTbits = 0x622 
.................... #word ALCFGRPT = 0x622 
....................  
.................... #word RTCVAL = 0x624 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CAL0:1; 
....................          unsigned int CAL1:1; 
....................          unsigned int CAL2:1; 
....................          unsigned int CAL3:1; 
....................          unsigned int CAL4:1; 
....................          unsigned int CAL5:1; 
....................          unsigned int CAL6:1; 
....................          unsigned int CAL7:1; 
....................          unsigned int RTCPTR0:1; 
....................          unsigned int RTCPTR1:1; 
....................          unsigned int RTCOE:1; 
....................          unsigned int HALFSEC:1; 
....................          unsigned int RTCSYNC:1; 
....................          unsigned int RTCWREN:1; 
....................          unsigned int :1; 
....................          unsigned int RTCEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int CAL:8; 
....................          unsigned int RTCPTR:2; 
....................       }; 
.................... } RCFGCALBITS; 
.................... RCFGCALBITS RCFGCALbits; 
.................... #word RCFGCALbits = 0x626 
.................... #word RCFGCAL = 0x626 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int C1OUT:1; 
....................    unsigned int C2OUT:1; 
....................    unsigned int C3OUT:1; 
....................    unsigned int :5; 
....................    unsigned int C1EVT:1; 
....................    unsigned int C2EVT:1; 
....................    unsigned int C3EVT:1; 
....................    unsigned int :4; 
....................    unsigned int CMIDL:1; 
.................... } CMSTATBITS; 
.................... CMSTATBITS CMSTATbits; 
.................... #word CMSTATbits = 0x630 
.................... #word CMSTAT = 0x630 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CVR0:4; 
....................          unsigned int CVRSS:1; 
....................          unsigned int CVRR:1; 
....................          unsigned int CVROE:1; 
....................          unsigned int CVREN:1; 
....................          unsigned int CVREFM0:2; 
....................          unsigned int CVREFP:1; 
....................       }; 
....................       struct { 
....................          unsigned int CVR:4; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int CVREFM:2; 
....................       }; 
.................... } CVRCONBITS; 
.................... CVRCONBITS CVRCONbits; 
.................... #word CVRCONbits = 0x632 
.................... #word CVRCON = 0x632 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int CCH0:2; 
....................          unsigned int :2; 
....................          unsigned int CREF:1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL0:2; 
....................          unsigned int COUT:1; 
....................          unsigned int CEVT:1; 
....................          unsigned int :3; 
....................          unsigned int CPOL:1; 
....................          unsigned int COE:1; 
....................          unsigned int CON:1; 
....................       }; 
....................       struct { 
....................          unsigned int CCH:2; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int CEN:1; 
....................       }; 
....................    }; 
.................... } CM1CONBITS; 
.................... CM1CONBITS CM1CONbits; 
.................... #word CM1CONbits = 0x634 
.................... #word CM1CON = 0x634 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int CCH0:2; 
....................          unsigned int :2; 
....................          unsigned int CREF:1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL0:2; 
....................          unsigned int COUT:1; 
....................          unsigned int CEVT:1; 
....................          unsigned int :3; 
....................          unsigned int CPOL:1; 
....................          unsigned int COE:1; 
....................          unsigned int CON:1; 
....................       }; 
....................       struct { 
....................          unsigned int CCH:2; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int CEN:1; 
....................       }; 
....................    }; 
.................... } CM2CONBITS; 
.................... CM2CONBITS CM2CONbits; 
.................... #word CM2CONbits = 0x636 
.................... #word CM2CON = 0x636 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int CCH0:2; 
....................          unsigned int :2; 
....................          unsigned int CREF:1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL0:2; 
....................          unsigned int COUT:1; 
....................          unsigned int CEVT:1; 
....................          unsigned int :3; 
....................          unsigned int CPOL:1; 
....................          unsigned int COE:1; 
....................          unsigned int CON:1; 
....................       }; 
....................       struct { 
....................          unsigned int CCH:2; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int EVPOL:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int CEN:1; 
....................       }; 
....................    }; 
.................... } CM3CONBITS; 
.................... CM3CONBITS CM3CONbits; 
.................... #word CM3CONbits = 0x638 
.................... #word CM3CON = 0x638 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int LENDIAN:1; 
....................          unsigned int CRCGO:1; 
....................          unsigned int CRCISEL:1; 
....................          unsigned int CRCMPT:1; 
....................          unsigned int CRCFUL:1; 
....................          unsigned int VWORD0:5; 
....................          unsigned int CSIDL:1; 
....................          unsigned int :1; 
....................          unsigned int CRCEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int VWORD:5; 
....................       }; 
.................... } CRCCON1BITS; 
.................... CRCCON1BITS CRCCON1bits; 
.................... #word CRCCON1bits = 0x640 
.................... #word CRCCON1 = 0x640 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PLEN0:5; 
....................          unsigned int :3; 
....................          unsigned int DWIDTH0:5; 
....................       }; 
....................       struct { 
....................          unsigned int PLEN:5; 
....................          unsigned int :3; 
....................          unsigned int DWIDTH:5; 
....................       }; 
.................... } CRCCON2BITS; 
.................... CRCCON2BITS CRCCON2bits; 
.................... #word CRCCON2bits = 0x642 
.................... #word CRCCON2 = 0x642 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :1; 
....................    unsigned int X1:15; 
.................... } CRCXORLBITS; 
.................... CRCXORLBITS CRCXORLbits; 
.................... #word CRCXORLbits = 0x644 
.................... #word CRCXORL = 0x644 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int X16:4; 
....................    unsigned int X20:10; 
....................    unsigned int X30:2; 
.................... } CRCXORHBITS; 
.................... CRCXORHBITS CRCXORHbits; 
.................... #word CRCXORHbits = 0x646 
.................... #word CRCXORH = 0x646 
....................  
.................... #word CRCDAT = 0x648 
....................  
.................... #word CRCWDAT = 0x64C 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int INT1R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int INT1R:6; 
....................       }; 
.................... } RPINR0BITS; 
.................... RPINR0BITS RPINR0bits; 
.................... #word RPINR0bits = 0x680 
.................... #word RPINR0 = 0x680 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int INT2R0:6; 
....................          unsigned int :2; 
....................          unsigned int INT3R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int INT2R:6; 
....................          unsigned int :2; 
....................          unsigned int INT3R:6; 
....................       }; 
.................... } RPINR1BITS; 
.................... RPINR1BITS RPINR1bits; 
.................... #word RPINR1bits = 0x682 
.................... #word RPINR1 = 0x682 
....................  
.................... #word RPINR2 = 0x684 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int T2CKR0:6; 
....................          unsigned int :2; 
....................          unsigned int T3CKR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int T2CKR:6; 
....................          unsigned int :2; 
....................          unsigned int T3CKR:6; 
....................       }; 
.................... } RPINR3BITS; 
.................... RPINR3BITS RPINR3bits; 
.................... #word RPINR3bits = 0x686 
.................... #word RPINR3 = 0x686 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int T4CKR0:6; 
....................          unsigned int :2; 
....................          unsigned int T5CKR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int T4CKR:6; 
....................          unsigned int :2; 
....................          unsigned int T5CKR:6; 
....................       }; 
.................... } RPINR4BITS; 
.................... RPINR4BITS RPINR4bits; 
.................... #word RPINR4bits = 0x688 
.................... #word RPINR4 = 0x688 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IC1R0:6; 
....................          unsigned int :2; 
....................          unsigned int IC2R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int IC1R:6; 
....................          unsigned int :2; 
....................          unsigned int IC2R:6; 
....................       }; 
.................... } RPINR7BITS; 
.................... RPINR7BITS RPINR7bits; 
.................... #word RPINR7bits = 0x68E 
.................... #word RPINR7 = 0x68E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IC3R0:6; 
....................          unsigned int :2; 
....................          unsigned int IC4R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int IC3R:6; 
....................          unsigned int :2; 
....................          unsigned int IC4R:6; 
....................       }; 
.................... } RPINR8BITS; 
.................... RPINR8BITS RPINR8bits; 
.................... #word RPINR8bits = 0x690 
.................... #word RPINR8 = 0x690 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IC5R0:6; 
....................          unsigned int :2; 
....................          unsigned int IC6R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int IC5R:6; 
....................          unsigned int :2; 
....................          unsigned int IC6R:6; 
....................       }; 
.................... } RPINR9BITS; 
.................... RPINR9BITS RPINR9bits; 
.................... #word RPINR9bits = 0x692 
.................... #word RPINR9 = 0x692 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int IC7R0:6; 
....................          unsigned int :2; 
....................          unsigned int IC8R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int IC7R:6; 
....................          unsigned int :2; 
....................          unsigned int IC8R:6; 
....................       }; 
.................... } RPINR10BITS; 
.................... RPINR10BITS RPINR10bits; 
.................... #word RPINR10bits = 0x694 
.................... #word RPINR10 = 0x694 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int OCFAR0:6; 
....................          unsigned int :2; 
....................          unsigned int OCFBR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int OCFAR:6; 
....................          unsigned int :2; 
....................          unsigned int OCFBR:6; 
....................       }; 
.................... } RPINR11BITS; 
.................... RPINR11BITS RPINR11bits; 
.................... #word RPINR11bits = 0x696 
.................... #word RPINR11 = 0x696 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int IC9R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int IC9R:6; 
....................       }; 
.................... } RPINR15BITS; 
.................... RPINR15BITS RPINR15bits; 
.................... #word RPINR15bits = 0x69E 
.................... #word RPINR15 = 0x69E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int U3RXR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int U3RXR:6; 
....................       }; 
.................... } RPINR17BITS; 
.................... RPINR17BITS RPINR17bits; 
.................... #word RPINR17bits = 0x6A2 
.................... #word RPINR17 = 0x6A2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int U1RXR0:6; 
....................          unsigned int :2; 
....................          unsigned int U1CTSR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int U1RXR:6; 
....................          unsigned int :2; 
....................          unsigned int U1CTSR:6; 
....................       }; 
.................... } RPINR18BITS; 
.................... RPINR18BITS RPINR18bits; 
.................... #word RPINR18bits = 0x6A4 
.................... #word RPINR18 = 0x6A4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int U2RXR0:6; 
....................          unsigned int :2; 
....................          unsigned int U2CTSR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int U2RXR:6; 
....................          unsigned int :2; 
....................          unsigned int U2CTSR:6; 
....................       }; 
.................... } RPINR19BITS; 
.................... RPINR19BITS RPINR19bits; 
.................... #word RPINR19bits = 0x6A6 
.................... #word RPINR19 = 0x6A6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SDI1R0:6; 
....................          unsigned int :2; 
....................          unsigned int SCK1R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int SDI1R:6; 
....................          unsigned int :2; 
....................          unsigned int SCK1R:6; 
....................       }; 
.................... } RPINR20BITS; 
.................... RPINR20BITS RPINR20bits; 
.................... #word RPINR20bits = 0x6A8 
.................... #word RPINR20 = 0x6A8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SS1R0:6; 
....................          unsigned int :2; 
....................          unsigned int U3CTSR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int SS1R:6; 
....................          unsigned int :2; 
....................          unsigned int U3CTSR:6; 
....................       }; 
.................... } RPINR21BITS; 
.................... RPINR21BITS RPINR21bits; 
.................... #word RPINR21bits = 0x6AA 
.................... #word RPINR21 = 0x6AA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SDI2R0:6; 
....................          unsigned int :2; 
....................          unsigned int SCK2R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int SDI2R:6; 
....................          unsigned int :2; 
....................          unsigned int SCK2R:6; 
....................       }; 
.................... } RPINR22BITS; 
.................... RPINR22BITS RPINR22bits; 
.................... #word RPINR22bits = 0x6AC 
.................... #word RPINR22 = 0x6AC 
....................  
.................... #word RPINR23 = 0x6AE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int U4RXR0:6; 
....................          unsigned int :2; 
....................          unsigned int U4CTSR0:6; 
....................       }; 
....................       struct { 
....................          unsigned int U4RXR:6; 
....................          unsigned int :2; 
....................          unsigned int U4CTSR:6; 
....................       }; 
.................... } RPINR27BITS; 
.................... RPINR27BITS RPINR27bits; 
.................... #word RPINR27bits = 0x6B6 
.................... #word RPINR27 = 0x6B6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SDI3R0:6; 
....................          unsigned int :2; 
....................          unsigned int SCK3R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int SDI3R:6; 
....................          unsigned int :2; 
....................          unsigned int SCK3R:6; 
....................       }; 
.................... } RPINR28BITS; 
.................... RPINR28BITS RPINR28bits; 
.................... #word RPINR28bits = 0x6B8 
.................... #word RPINR28 = 0x6B8 
....................  
.................... #word RPINR29 = 0x6BA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP0R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP1R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP0R:6; 
....................          unsigned int :2; 
....................          unsigned int RP1R:6; 
....................       }; 
.................... } RPOR0BITS; 
.................... RPOR0BITS RPOR0bits; 
.................... #word RPOR0bits = 0x6C0 
.................... #word RPOR0 = 0x6C0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP2R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP3R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP2R:6; 
....................          unsigned int :2; 
....................          unsigned int RP3R:6; 
....................       }; 
.................... } RPOR1BITS; 
.................... RPOR1BITS RPOR1bits; 
.................... #word RPOR1bits = 0x6C2 
.................... #word RPOR1 = 0x6C2 
....................  
.................... #word RPOR2 = 0x6C4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP6R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP7R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP6R:6; 
....................          unsigned int :2; 
....................          unsigned int RP7R:6; 
....................       }; 
.................... } RPOR3BITS; 
.................... RPOR3BITS RPOR3bits; 
.................... #word RPOR3bits = 0x6C6 
.................... #word RPOR3 = 0x6C6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP8R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP9R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP8R:6; 
....................          unsigned int :2; 
....................          unsigned int RP9R:6; 
....................       }; 
.................... } RPOR4BITS; 
.................... RPOR4BITS RPOR4bits; 
.................... #word RPOR4bits = 0x6C8 
.................... #word RPOR4 = 0x6C8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP10R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP11R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP10R:6; 
....................          unsigned int :2; 
....................          unsigned int RP11R:6; 
....................       }; 
.................... } RPOR5BITS; 
.................... RPOR5BITS RPOR5bits; 
.................... #word RPOR5bits = 0x6CA 
.................... #word RPOR5 = 0x6CA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP12R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP13R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP12R:6; 
....................          unsigned int :2; 
....................          unsigned int RP13R:6; 
....................       }; 
.................... } RPOR6BITS; 
.................... RPOR6BITS RPOR6bits; 
.................... #word RPOR6bits = 0x6CC 
.................... #word RPOR6 = 0x6CC 
....................  
.................... #word RPOR7 = 0x6CE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP16R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP17R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP16R:6; 
....................          unsigned int :2; 
....................          unsigned int RP17R:6; 
....................       }; 
.................... } RPOR8BITS; 
.................... RPOR8BITS RPOR8bits; 
.................... #word RPOR8bits = 0x6D0 
.................... #word RPOR8 = 0x6D0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP18R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP19R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP18R:6; 
....................          unsigned int :2; 
....................          unsigned int RP19R:6; 
....................       }; 
.................... } RPOR9BITS; 
.................... RPOR9BITS RPOR9bits; 
.................... #word RPOR9bits = 0x6D2 
.................... #word RPOR9 = 0x6D2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP20R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP21R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP20R:6; 
....................          unsigned int :2; 
....................          unsigned int RP21R:6; 
....................       }; 
.................... } RPOR10BITS; 
.................... RPOR10BITS RPOR10bits; 
.................... #word RPOR10bits = 0x6D4 
.................... #word RPOR10 = 0x6D4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP22R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP23R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP22R:6; 
....................          unsigned int :2; 
....................          unsigned int RP23R:6; 
....................       }; 
.................... } RPOR11BITS; 
.................... RPOR11BITS RPOR11bits; 
.................... #word RPOR11bits = 0x6D6 
.................... #word RPOR11 = 0x6D6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP24R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP25R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP24R:6; 
....................          unsigned int :2; 
....................          unsigned int RP25R:6; 
....................       }; 
.................... } RPOR12BITS; 
.................... RPOR12BITS RPOR12bits; 
.................... #word RPOR12bits = 0x6D8 
.................... #word RPOR12 = 0x6D8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP26R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP27R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP26R:6; 
....................          unsigned int :2; 
....................          unsigned int RP27R:6; 
....................       }; 
.................... } RPOR13BITS; 
.................... RPOR13BITS RPOR13bits; 
.................... #word RPOR13bits = 0x6DA 
.................... #word RPOR13 = 0x6DA 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int RP28R0:6; 
....................          unsigned int :2; 
....................          unsigned int RP29R0:6; 
....................       }; 
....................       struct { 
....................          unsigned int RP28R:6; 
....................          unsigned int :2; 
....................          unsigned int RP29R:6; 
....................       }; 
.................... } RPOR14BITS; 
.................... RPOR14BITS RPOR14bits; 
.................... #word RPOR14bits = 0x6DC 
.................... #word RPOR14 = 0x6DC 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int POR:1; 
....................          unsigned int BOR:1; 
....................          unsigned int IDLE:1; 
....................          unsigned int SLEEP:1; 
....................          unsigned int WDTO:1; 
....................          unsigned int SWDTEN:1; 
....................          unsigned int SWR:1; 
....................          unsigned int EXTR:1; 
....................          unsigned int VREGS:1; 
....................          unsigned int CM:1; 
....................          unsigned int :4; 
....................          unsigned int IOPUWR:1; 
....................          unsigned int TRAPR:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int PMSLP:1; 
....................       }; 
....................    }; 
.................... } RCONBITS; 
.................... RCONBITS RCONbits; 
.................... #word RCONbits = 0x740 
.................... #word RCON = 0x740 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int OSWEN:1; 
....................          unsigned int SOSCEN:1; 
....................          unsigned int POSCEN:1; 
....................          unsigned int CF:1; 
....................          unsigned int :1; 
....................          unsigned int LOCK:1; 
....................          unsigned int IOLOCK:1; 
....................          unsigned int CLKLOCK:1; 
....................          unsigned int NOSC0:3; 
....................          unsigned int :1; 
....................          unsigned int COSC0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int NOSC:3; 
....................          unsigned int :1; 
....................          unsigned int COSC:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int LPOSCEN:1; 
....................       }; 
....................    }; 
.................... } OSCCONBITS; 
.................... OSCCONBITS OSCCONbits; 
.................... #word OSCCONbits = 0x742 
.................... #word OSCCON = 0x742 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int PLLEN:1; 
....................          unsigned int CPDIV0:2; 
....................          unsigned int RCDIV0:3; 
....................          unsigned int DOZEN:1; 
....................          unsigned int DOZE0:3; 
....................          unsigned int ROI:1; 
....................       }; 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int :1; 
....................          unsigned int CPDIV:2; 
....................          unsigned int RCDIV:3; 
....................          unsigned int :1; 
....................          unsigned int DOZE:3; 
....................       }; 
.................... } CLKDIVBITS; 
.................... CLKDIVBITS CLKDIVbits; 
.................... #word CLKDIVbits = 0x744 
.................... #word CLKDIV = 0x744 
....................  
.................... #word OSCTUN = 0x748 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int RODIV0:4; 
....................          unsigned int ROSEL:1; 
....................          unsigned int ROSSLP:1; 
....................          unsigned int :1; 
....................          unsigned int ROEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int :8; 
....................          unsigned int RODIV:4; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :15; 
....................          unsigned int ROON:1; 
....................       }; 
....................    }; 
.................... } REFOCONBITS; 
.................... REFOCONBITS REFOCONbits; 
.................... #word REFOCONbits = 0x74E 
.................... #word REFOCON = 0x74E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int NVMOP0:4; 
....................          unsigned int :2; 
....................          unsigned int ERASE:1; 
....................          unsigned int :6; 
....................          unsigned int WRERR:1; 
....................          unsigned int WREN:1; 
....................          unsigned int WR:1; 
....................       }; 
....................       struct { 
....................          unsigned int NVMOP:4; 
....................          unsigned int :2; 
....................          unsigned int :1; 
....................          unsigned int :6; 
....................       }; 
.................... } NVMCONBITS; 
.................... NVMCONBITS NVMCONbits; 
.................... #word NVMCONbits = 0x760 
.................... #word NVMCON = 0x760 
....................  
.................... #word NVMKEY = 0x766 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int ADC1MD:1; 
....................    unsigned int :2; 
....................    unsigned int SPI1MD:1; 
....................    unsigned int SPI2MD:1; 
....................    unsigned int U1MD:1; 
....................    unsigned int U2MD:1; 
....................    unsigned int I2C1MD:1; 
....................    unsigned int :3; 
....................    unsigned int T1MD:1; 
....................    unsigned int T2MD:1; 
....................    unsigned int T3MD:1; 
....................    unsigned int T4MD:1; 
....................    unsigned int T5MD:1; 
.................... } PMD1BITS; 
.................... PMD1BITS PMD1bits; 
.................... #word PMD1bits = 0x770 
.................... #word PMD1 = 0x770 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int OC1MD:1; 
....................    unsigned int OC2MD:1; 
....................    unsigned int OC3MD:1; 
....................    unsigned int OC4MD:1; 
....................    unsigned int OC5MD:1; 
....................    unsigned int OC6MD:1; 
....................    unsigned int OC7MD:1; 
....................    unsigned int OC8MD:1; 
....................    unsigned int IC1MD:1; 
....................    unsigned int IC2MD:1; 
....................    unsigned int IC3MD:1; 
....................    unsigned int IC4MD:1; 
....................    unsigned int IC5MD:1; 
....................    unsigned int IC6MD:1; 
....................    unsigned int IC7MD:1; 
....................    unsigned int IC8MD:1; 
.................... } PMD2BITS; 
.................... PMD2BITS PMD2bits; 
.................... #word PMD2bits = 0x772 
.................... #word PMD2 = 0x772 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int I2C2MD:1; 
....................          unsigned int I2C3MD:1; 
....................          unsigned int U3MD:1; 
....................          unsigned int :3; 
....................          unsigned int CRCMD:1; 
....................          unsigned int PMPMD:1; 
....................          unsigned int RTCCMD:1; 
....................          unsigned int CMPMD:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :7; 
....................          unsigned int CRCPMD:1; 
....................       }; 
....................    }; 
.................... } PMD3BITS; 
.................... PMD3BITS PMD3bits; 
.................... #word PMD3bits = 0x774 
.................... #word PMD3 = 0x774 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int USB1MD:1; 
....................    unsigned int LVDMD:1; 
....................    unsigned int CTMUMD:1; 
....................    unsigned int REFOMD:1; 
....................    unsigned int :1; 
....................    unsigned int U4MD:1; 
....................    unsigned int UPWMMD:1; 
.................... } PMD4BITS; 
.................... PMD4BITS PMD4bits; 
.................... #word PMD4bits = 0x776 
.................... #word PMD4 = 0x776 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int OC9MD:1; 
....................    unsigned int :7; 
....................    unsigned int IC9MD:1; 
.................... } PMD5BITS; 
.................... PMD5BITS PMD5bits; 
.................... #word PMD5bits = 0x778 
.................... #word PMD5 = 0x778 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SPI3MD:1; 
.................... } PMD6BITS; 
.................... PMD6BITS PMD6bits; 
.................... #word PMD6bits = 0x77A 
.................... #word PMD6 = 0x77A 
....................  
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GA108__) || (getenv("DEVICE")=="PIC24FJ256GA108") 
....................     #if !defined(__PIC24FJ256GA108__) 
....................         #define __PIC24FJ256GA108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GA108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GA108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GA110__) || (getenv("DEVICE")=="PIC24FJ256GA110") 
....................     #if !defined(__PIC24FJ256GA110__) 
....................         #define __PIC24FJ256GA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GB106__) || (getenv("DEVICE")=="PIC24FJ256GB106") 
....................     #if !defined(__PIC24FJ256GB106__) 
....................         #define __PIC24FJ256GB106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GB106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GB106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GB108__) || (getenv("DEVICE")=="PIC24FJ256GB108") 
....................     #if !defined(__PIC24FJ256GB108__) 
....................         #define __PIC24FJ256GB108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GB108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GB108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GB110__) || (getenv("DEVICE")=="PIC24FJ256GB110") 
....................     #if !defined(__PIC24FJ256GB110__) 
....................         #define __PIC24FJ256GB110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GB110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GB110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GB206__) || (getenv("DEVICE")=="PIC24FJ256GB206") 
....................     #if !defined(__PIC24FJ256GB206__) 
....................         #define __PIC24FJ256GB206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GB206.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GB206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ256GB210__) || (getenv("DEVICE")=="PIC24FJ256GB210") 
....................     #if !defined(__PIC24FJ256GB210__) 
....................         #define __PIC24FJ256GB210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ256GB210.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ256GB210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GA002__) || (getenv("DEVICE")=="PIC24FJ32GA002") 
....................     #if !defined(__PIC24FJ32GA002__) 
....................         #define __PIC24FJ32GA002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GA002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GA002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GA004__) || (getenv("DEVICE")=="PIC24FJ32GA004") 
....................     #if !defined(__PIC24FJ32GA004__) 
....................         #define __PIC24FJ32GA004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GA004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GA004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GA102__) || (getenv("DEVICE")=="PIC24FJ32GA102") 
....................     #if !defined(__PIC24FJ32GA102__) 
....................         #define __PIC24FJ32GA102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GA102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GA102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GA104__) || (getenv("DEVICE")=="PIC24FJ32GA104") 
....................     #if !defined(__PIC24FJ32GA104__) 
....................         #define __PIC24FJ32GA104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GA104.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GA104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GB002__) || (getenv("DEVICE")=="PIC24FJ32GB002") 
....................     #if !defined(__PIC24FJ32GB002__) 
....................         #define __PIC24FJ32GB002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GB002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GB002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ32GB004__) || (getenv("DEVICE")=="PIC24FJ32GB004") 
....................     #if !defined(__PIC24FJ32GB004__) 
....................         #define __PIC24FJ32GB004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ32GB004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ32GB004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ48GA002__) || (getenv("DEVICE")=="PIC24FJ48GA002") 
....................     #if !defined(__PIC24FJ48GA002__) 
....................         #define __PIC24FJ48GA002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ48GA002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ48GA002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ48GA004__) || (getenv("DEVICE")=="PIC24FJ48GA004") 
....................     #if !defined(__PIC24FJ48GA004__) 
....................         #define __PIC24FJ48GA004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ48GA004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ48GA004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA002__) || (getenv("DEVICE")=="PIC24FJ64GA002") 
....................     #if !defined(__PIC24FJ64GA002__) 
....................         #define __PIC24FJ64GA002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA004__) || (getenv("DEVICE")=="PIC24FJ64GA004") 
....................     #if !defined(__PIC24FJ64GA004__) 
....................         #define __PIC24FJ64GA004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA006__) || (getenv("DEVICE")=="PIC24FJ64GA006") 
....................     #if !defined(__PIC24FJ64GA006__) 
....................         #define __PIC24FJ64GA006__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA006.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA006_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA008__) || (getenv("DEVICE")=="PIC24FJ64GA008") 
....................     #if !defined(__PIC24FJ64GA008__) 
....................         #define __PIC24FJ64GA008__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA008.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA008_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA010__) || (getenv("DEVICE")=="PIC24FJ64GA010") 
....................     #if !defined(__PIC24FJ64GA010__) 
....................         #define __PIC24FJ64GA010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA010.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA102__) || (getenv("DEVICE")=="PIC24FJ64GA102") 
....................     #if !defined(__PIC24FJ64GA102__) 
....................         #define __PIC24FJ64GA102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA104__) || (getenv("DEVICE")=="PIC24FJ64GA104") 
....................     #if !defined(__PIC24FJ64GA104__) 
....................         #define __PIC24FJ64GA104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA104.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA106__) || (getenv("DEVICE")=="PIC24FJ64GA106") 
....................     #if !defined(__PIC24FJ64GA106__) 
....................         #define __PIC24FJ64GA106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA108__) || (getenv("DEVICE")=="PIC24FJ64GA108") 
....................     #if !defined(__PIC24FJ64GA108__) 
....................         #define __PIC24FJ64GA108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA110__) || (getenv("DEVICE")=="PIC24FJ64GA110") 
....................     #if !defined(__PIC24FJ64GA110__) 
....................         #define __PIC24FJ64GA110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA306__) || (getenv("DEVICE")=="PIC24FJ64GA306") 
....................     #if !defined(__PIC24FJ64GA306__) 
....................         #define __PIC24FJ64GA306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA306.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA308__) || (getenv("DEVICE")=="PIC24FJ64GA308") 
....................     #if !defined(__PIC24FJ64GA308__) 
....................         #define __PIC24FJ64GA308__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA308.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA308_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GA310__) || (getenv("DEVICE")=="PIC24FJ64GA310") 
....................     #if !defined(__PIC24FJ64GA310__) 
....................         #define __PIC24FJ64GA310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GA310.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GA310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GB002__) || (getenv("DEVICE")=="PIC24FJ64GB002") 
....................     #if !defined(__PIC24FJ64GB002__) 
....................         #define __PIC24FJ64GB002__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GB002.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GB002_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GB004__) || (getenv("DEVICE")=="PIC24FJ64GB004") 
....................     #if !defined(__PIC24FJ64GB004__) 
....................         #define __PIC24FJ64GB004__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GB004.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GB004_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GB106__) || (getenv("DEVICE")=="PIC24FJ64GB106") 
....................     #if !defined(__PIC24FJ64GB106__) 
....................         #define __PIC24FJ64GB106__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GB106.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GB106_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GB108__) || (getenv("DEVICE")=="PIC24FJ64GB108") 
....................     #if !defined(__PIC24FJ64GB108__) 
....................         #define __PIC24FJ64GB108__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GB108.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GB108_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ64GB110__) || (getenv("DEVICE")=="PIC24FJ64GB110") 
....................     #if !defined(__PIC24FJ64GB110__) 
....................         #define __PIC24FJ64GB110__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ64GB110.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ64GB110_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ96GA006__) || (getenv("DEVICE")=="PIC24FJ96GA006") 
....................     #if !defined(__PIC24FJ96GA006__) 
....................         #define __PIC24FJ96GA006__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ96GA006.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ96GA006_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ96GA008__) || (getenv("DEVICE")=="PIC24FJ96GA008") 
....................     #if !defined(__PIC24FJ96GA008__) 
....................         #define __PIC24FJ96GA008__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ96GA008.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ96GA008_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FJ96GA010__) || (getenv("DEVICE")=="PIC24FJ96GA010") 
....................     #if !defined(__PIC24FJ96GA010__) 
....................         #define __PIC24FJ96GA010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FJ96GA010.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FJ96GA010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV08KM101__) || (getenv("DEVICE")=="PIC24FV08KM101") 
....................     #if !defined(__PIC24FV08KM101__) 
....................         #define __PIC24FV08KM101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV08KM101.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV08KM101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV08KM102__) || (getenv("DEVICE")=="PIC24FV08KM102") 
....................     #if !defined(__PIC24FV08KM102__) 
....................         #define __PIC24FV08KM102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV08KM102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV08KM102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV08KM202__) || (getenv("DEVICE")=="PIC24FV08KM202") 
....................     #if !defined(__PIC24FV08KM202__) 
....................         #define __PIC24FV08KM202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV08KM202.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV08KM202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV08KM204__) || (getenv("DEVICE")=="PIC24FV08KM204") 
....................     #if !defined(__PIC24FV08KM204__) 
....................         #define __PIC24FV08KM204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV08KM204.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV08KM204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KA301__) || (getenv("DEVICE")=="PIC24FV16KA301") 
....................     #if !defined(__PIC24FV16KA301__) 
....................         #define __PIC24FV16KA301__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KA301.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV16KA301_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KA302__) || (getenv("DEVICE")=="PIC24FV16KA302") 
....................     #if !defined(__PIC24FV16KA302__) 
....................         #define __PIC24FV16KA302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KA302.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV16KA302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KA304__) || (getenv("DEVICE")=="PIC24FV16KA304") 
....................     #if !defined(__PIC24FV16KA304__) 
....................         #define __PIC24FV16KA304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KA304.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV16KA304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KM102__) || (getenv("DEVICE")=="PIC24FV16KM102") 
....................     #if !defined(__PIC24FV16KM102__) 
....................         #define __PIC24FV16KM102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KM102.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV16KM102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KM104__) || (getenv("DEVICE")=="PIC24FV16KM104") 
....................     #if !defined(__PIC24FV16KM104__) 
....................         #define __PIC24FV16KM104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KM104.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV16KM104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KM202__) || (getenv("DEVICE")=="PIC24FV16KM202") 
....................     #if !defined(__PIC24FV16KM202__) 
....................         #define __PIC24FV16KM202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KM202.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV16KM202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV16KM204__) || (getenv("DEVICE")=="PIC24FV16KM204") 
....................     #if !defined(__PIC24FV16KM204__) 
....................         #define __PIC24FV16KM204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV16KM204.h> 
....................     #endif 
....................     #if !defined(__PIC24F__) 
....................         #define __PIC24F__ 
....................     #endif 
....................     #include "24FV16KM204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV32KA301__) || (getenv("DEVICE")=="PIC24FV32KA301") 
....................     #if !defined(__PIC24FV32KA301__) 
....................         #define __PIC24FV32KA301__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV32KA301.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV32KA301_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV32KA302__) || (getenv("DEVICE")=="PIC24FV32KA302") 
....................     #if !defined(__PIC24FV32KA302__) 
....................         #define __PIC24FV32KA302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV32KA302.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV32KA302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24FV32KA304__) || (getenv("DEVICE")=="PIC24FV32KA304") 
....................     #if !defined(__PIC24FV32KA304__) 
....................         #define __PIC24FV32KA304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24FV32KA304.h> 
....................     #endif 
....................     #if !defined(__PIC24FK__) 
....................         #define __PIC24FK__ 
....................     #endif 
....................     #include "24FV32KA304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP202__) || (getenv("DEVICE")=="PIC24HJ128GP202") 
....................     #if !defined(__PIC24HJ128GP202__) 
....................         #define __PIC24HJ128GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP204__) || (getenv("DEVICE")=="PIC24HJ128GP204") 
....................     #if !defined(__PIC24HJ128GP204__) 
....................         #define __PIC24HJ128GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP206__) || (getenv("DEVICE")=="PIC24HJ128GP206") 
....................     #if !defined(__PIC24HJ128GP206__) 
....................         #define __PIC24HJ128GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP206A__) || (getenv("DEVICE")=="PIC24HJ128GP206A") 
....................     #if !defined(__PIC24HJ128GP206A__) 
....................         #define __PIC24HJ128GP206A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP206A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP206A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP210__) || (getenv("DEVICE")=="PIC24HJ128GP210") 
....................     #if !defined(__PIC24HJ128GP210__) 
....................         #define __PIC24HJ128GP210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP210.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP210A__) || (getenv("DEVICE")=="PIC24HJ128GP210A") 
....................     #if !defined(__PIC24HJ128GP210A__) 
....................         #define __PIC24HJ128GP210A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP210A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP210A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP306__) || (getenv("DEVICE")=="PIC24HJ128GP306") 
....................     #if !defined(__PIC24HJ128GP306__) 
....................         #define __PIC24HJ128GP306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP306.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP306A__) || (getenv("DEVICE")=="PIC24HJ128GP306A") 
....................     #if !defined(__PIC24HJ128GP306A__) 
....................         #define __PIC24HJ128GP306A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP306A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP306A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP310__) || (getenv("DEVICE")=="PIC24HJ128GP310") 
....................     #if !defined(__PIC24HJ128GP310__) 
....................         #define __PIC24HJ128GP310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP310.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP310A__) || (getenv("DEVICE")=="PIC24HJ128GP310A") 
....................     #if !defined(__PIC24HJ128GP310A__) 
....................         #define __PIC24HJ128GP310A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP310A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP310A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP502__) || (getenv("DEVICE")=="PIC24HJ128GP502") 
....................     #if !defined(__PIC24HJ128GP502__) 
....................         #define __PIC24HJ128GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP502.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP504__) || (getenv("DEVICE")=="PIC24HJ128GP504") 
....................     #if !defined(__PIC24HJ128GP504__) 
....................         #define __PIC24HJ128GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP504.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP506__) || (getenv("DEVICE")=="PIC24HJ128GP506") 
....................     #if !defined(__PIC24HJ128GP506__) 
....................         #define __PIC24HJ128GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP506.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP506A__) || (getenv("DEVICE")=="PIC24HJ128GP506A") 
....................     #if !defined(__PIC24HJ128GP506A__) 
....................         #define __PIC24HJ128GP506A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP506A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP506A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP510__) || (getenv("DEVICE")=="PIC24HJ128GP510") 
....................     #if !defined(__PIC24HJ128GP510__) 
....................         #define __PIC24HJ128GP510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP510.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ128GP510A__) || (getenv("DEVICE")=="PIC24HJ128GP510A") 
....................     #if !defined(__PIC24HJ128GP510A__) 
....................         #define __PIC24HJ128GP510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ128GP510A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ128GP510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ12GP201__) || (getenv("DEVICE")=="PIC24HJ12GP201") 
....................     #if !defined(__PIC24HJ12GP201__) 
....................         #define __PIC24HJ12GP201__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ12GP201.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ12GP201_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ12GP202__) || (getenv("DEVICE")=="PIC24HJ12GP202") 
....................     #if !defined(__PIC24HJ12GP202__) 
....................         #define __PIC24HJ12GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ12GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ12GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ16GP304__) || (getenv("DEVICE")=="PIC24HJ16GP304") 
....................     #if !defined(__PIC24HJ16GP304__) 
....................         #define __PIC24HJ16GP304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ16GP304.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ16GP304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP206__) || (getenv("DEVICE")=="PIC24HJ256GP206") 
....................     #if !defined(__PIC24HJ256GP206__) 
....................         #define __PIC24HJ256GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP206A__) || (getenv("DEVICE")=="PIC24HJ256GP206A") 
....................     #if !defined(__PIC24HJ256GP206A__) 
....................         #define __PIC24HJ256GP206A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP206A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP206A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP210__) || (getenv("DEVICE")=="PIC24HJ256GP210") 
....................     #if !defined(__PIC24HJ256GP210__) 
....................         #define __PIC24HJ256GP210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP210.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP210A__) || (getenv("DEVICE")=="PIC24HJ256GP210A") 
....................     #if !defined(__PIC24HJ256GP210A__) 
....................         #define __PIC24HJ256GP210A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP210A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP210A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP610__) || (getenv("DEVICE")=="PIC24HJ256GP610") 
....................     #if !defined(__PIC24HJ256GP610__) 
....................         #define __PIC24HJ256GP610__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP610.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP610_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ256GP610A__) || (getenv("DEVICE")=="PIC24HJ256GP610A") 
....................     #if !defined(__PIC24HJ256GP610A__) 
....................         #define __PIC24HJ256GP610A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ256GP610A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ256GP610A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ32GP202__) || (getenv("DEVICE")=="PIC24HJ32GP202") 
....................     #if !defined(__PIC24HJ32GP202__) 
....................         #define __PIC24HJ32GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ32GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ32GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ32GP204__) || (getenv("DEVICE")=="PIC24HJ32GP204") 
....................     #if !defined(__PIC24HJ32GP204__) 
....................         #define __PIC24HJ32GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ32GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ32GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ32GP302__) || (getenv("DEVICE")=="PIC24HJ32GP302") 
....................     #if !defined(__PIC24HJ32GP302__) 
....................         #define __PIC24HJ32GP302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ32GP302.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ32GP302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ32GP304__) || (getenv("DEVICE")=="PIC24HJ32GP304") 
....................     #if !defined(__PIC24HJ32GP304__) 
....................         #define __PIC24HJ32GP304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ32GP304.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ32GP304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP202__) || (getenv("DEVICE")=="PIC24HJ64GP202") 
....................     #if !defined(__PIC24HJ64GP202__) 
....................         #define __PIC24HJ64GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP202.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP204__) || (getenv("DEVICE")=="PIC24HJ64GP204") 
....................     #if !defined(__PIC24HJ64GP204__) 
....................         #define __PIC24HJ64GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP204.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP206__) || (getenv("DEVICE")=="PIC24HJ64GP206") 
....................     #if !defined(__PIC24HJ64GP206__) 
....................         #define __PIC24HJ64GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP206.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP206A__) || (getenv("DEVICE")=="PIC24HJ64GP206A") 
....................     #if !defined(__PIC24HJ64GP206A__) 
....................         #define __PIC24HJ64GP206A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP206A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP206A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP210__) || (getenv("DEVICE")=="PIC24HJ64GP210") 
....................     #if !defined(__PIC24HJ64GP210__) 
....................         #define __PIC24HJ64GP210__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP210.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP210_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP210A__) || (getenv("DEVICE")=="PIC24HJ64GP210A") 
....................     #if !defined(__PIC24HJ64GP210A__) 
....................         #define __PIC24HJ64GP210A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP210A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP210A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP502__) || (getenv("DEVICE")=="PIC24HJ64GP502") 
....................     #if !defined(__PIC24HJ64GP502__) 
....................         #define __PIC24HJ64GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP502.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP504__) || (getenv("DEVICE")=="PIC24HJ64GP504") 
....................     #if !defined(__PIC24HJ64GP504__) 
....................         #define __PIC24HJ64GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP504.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP506__) || (getenv("DEVICE")=="PIC24HJ64GP506") 
....................     #if !defined(__PIC24HJ64GP506__) 
....................         #define __PIC24HJ64GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP506.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP506A__) || (getenv("DEVICE")=="PIC24HJ64GP506A") 
....................     #if !defined(__PIC24HJ64GP506A__) 
....................         #define __PIC24HJ64GP506A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP506A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP506A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP510__) || (getenv("DEVICE")=="PIC24HJ64GP510") 
....................     #if !defined(__PIC24HJ64GP510__) 
....................         #define __PIC24HJ64GP510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP510.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__PIC24HJ64GP510A__) || (getenv("DEVICE")=="PIC24HJ64GP510A") 
....................     #if !defined(__PIC24HJ64GP510A__) 
....................         #define __PIC24HJ64GP510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <24HJ64GP510A.h> 
....................     #endif 
....................     #if !defined(__PIC24H__) 
....................         #define __PIC24H__ 
....................     #endif 
....................     #include "24HJ64GP510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F1010__) || (getenv("DEVICE")=="DSPIC30F1010") 
....................     #if !defined(__dsPIC30F1010__) 
....................         #define __dsPIC30F1010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F1010.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F1010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F2010__) || (getenv("DEVICE")=="DSPIC30F2010") 
....................     #if !defined(__dsPIC30F2010__) 
....................         #define __dsPIC30F2010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F2010.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F2010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F2011__) || (getenv("DEVICE")=="DSPIC30F2011") 
....................     #if !defined(__dsPIC30F2011__) 
....................         #define __dsPIC30F2011__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F2011.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F2011_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F2012__) || (getenv("DEVICE")=="DSPIC30F2012") 
....................     #if !defined(__dsPIC30F2012__) 
....................         #define __dsPIC30F2012__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F2012.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F2012_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F2020__) || (getenv("DEVICE")=="DSPIC30F2020") 
....................     #if !defined(__dsPIC30F2020__) 
....................         #define __dsPIC30F2020__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F2020.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F2020_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F2023__) || (getenv("DEVICE")=="DSPIC30F2023") 
....................     #if !defined(__dsPIC30F2023__) 
....................         #define __dsPIC30F2023__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F2023.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F2023_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F3010__) || (getenv("DEVICE")=="DSPIC30F3010") 
....................     #if !defined(__dsPIC30F3010__) 
....................         #define __dsPIC30F3010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F3010.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F3010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F3011__) || (getenv("DEVICE")=="DSPIC30F3011") 
....................     #if !defined(__dsPIC30F3011__) 
....................         #define __dsPIC30F3011__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F3011.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F3011_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F3012__) || (getenv("DEVICE")=="DSPIC30F3012") 
....................     #if !defined(__dsPIC30F3012__) 
....................         #define __dsPIC30F3012__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F3012.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F3012_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F3013__) || (getenv("DEVICE")=="DSPIC30F3013") 
....................     #if !defined(__dsPIC30F3013__) 
....................         #define __dsPIC30F3013__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F3013.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F3013_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F3014__) || (getenv("DEVICE")=="DSPIC30F3014") 
....................     #if !defined(__dsPIC30F3014__) 
....................         #define __dsPIC30F3014__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F3014.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F3014_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F4011__) || (getenv("DEVICE")=="DSPIC30F4011") 
....................     #if !defined(__dsPIC30F4011__) 
....................         #define __dsPIC30F4011__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F4011.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F4011_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F4012__) || (getenv("DEVICE")=="DSPIC30F4012") 
....................     #if !defined(__dsPIC30F4012__) 
....................         #define __dsPIC30F4012__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F4012.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F4012_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F4013__) || (getenv("DEVICE")=="DSPIC30F4013") 
....................     #if !defined(__dsPIC30F4013__) 
....................         #define __dsPIC30F4013__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F4013.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F4013_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F5011__) || (getenv("DEVICE")=="DSPIC30F5011") 
....................     #if !defined(__dsPIC30F5011__) 
....................         #define __dsPIC30F5011__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F5011.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F5011_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F5013__) || (getenv("DEVICE")=="DSPIC30F5013") 
....................     #if !defined(__dsPIC30F5013__) 
....................         #define __dsPIC30F5013__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F5013.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F5013_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F5015__) || (getenv("DEVICE")=="DSPIC30F5015") 
....................     #if !defined(__dsPIC30F5015__) 
....................         #define __dsPIC30F5015__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F5015.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F5015_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F5016__) || (getenv("DEVICE")=="DSPIC30F5016") 
....................     #if !defined(__dsPIC30F5016__) 
....................         #define __dsPIC30F5016__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F5016.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F5016_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6010__) || (getenv("DEVICE")=="DSPIC30F6010") 
....................     #if !defined(__dsPIC30F6010__) 
....................         #define __dsPIC30F6010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6010.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6010_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6010A__) || (getenv("DEVICE")=="DSPIC30F6010A") 
....................     #if !defined(__dsPIC30F6010A__) 
....................         #define __dsPIC30F6010A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6010A.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6010A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6011__) || (getenv("DEVICE")=="DSPIC30F6011") 
....................     #if !defined(__dsPIC30F6011__) 
....................         #define __dsPIC30F6011__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6011.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6011_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6011A__) || (getenv("DEVICE")=="DSPIC30F6011A") 
....................     #if !defined(__dsPIC30F6011A__) 
....................         #define __dsPIC30F6011A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6011A.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6011A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6012__) || (getenv("DEVICE")=="DSPIC30F6012") 
....................     #if !defined(__dsPIC30F6012__) 
....................         #define __dsPIC30F6012__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6012.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6012_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6012A__) || (getenv("DEVICE")=="DSPIC30F6012A") 
....................     #if !defined(__dsPIC30F6012A__) 
....................         #define __dsPIC30F6012A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6012A.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6012A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6013__) || (getenv("DEVICE")=="DSPIC30F6013") 
....................     #if !defined(__dsPIC30F6013__) 
....................         #define __dsPIC30F6013__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6013.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6013_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6013A__) || (getenv("DEVICE")=="DSPIC30F6013A") 
....................     #if !defined(__dsPIC30F6013A__) 
....................         #define __dsPIC30F6013A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6013A.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6013A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6014__) || (getenv("DEVICE")=="DSPIC30F6014") 
....................     #if !defined(__dsPIC30F6014__) 
....................         #define __dsPIC30F6014__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6014.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6014_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6014A__) || (getenv("DEVICE")=="DSPIC30F6014A") 
....................     #if !defined(__dsPIC30F6014A__) 
....................         #define __dsPIC30F6014A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6014A.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6014A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC30F6015__) || (getenv("DEVICE")=="DSPIC30F6015") 
....................     #if !defined(__dsPIC30F6015__) 
....................         #define __dsPIC30F6015__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <30F6015.h> 
....................     #endif 
....................     #if !defined(__dsPIC30F__) 
....................         #define __dsPIC30F__ 
....................     #endif 
....................     #include "30F6015_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM304__) || (getenv("DEVICE")=="DSPIC33EP128GM304") 
....................     #if !defined(__dsPIC33EP128GM304__) 
....................         #define __dsPIC33EP128GM304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM306__) || (getenv("DEVICE")=="DSPIC33EP128GM306") 
....................     #if !defined(__dsPIC33EP128GM306__) 
....................         #define __dsPIC33EP128GM306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM306.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM310__) || (getenv("DEVICE")=="DSPIC33EP128GM310") 
....................     #if !defined(__dsPIC33EP128GM310__) 
....................         #define __dsPIC33EP128GM310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM310.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM604__) || (getenv("DEVICE")=="DSPIC33EP128GM604") 
....................     #if !defined(__dsPIC33EP128GM604__) 
....................         #define __dsPIC33EP128GM604__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM604.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM604_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM706__) || (getenv("DEVICE")=="DSPIC33EP128GM706") 
....................     #if !defined(__dsPIC33EP128GM706__) 
....................         #define __dsPIC33EP128GM706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GM710__) || (getenv("DEVICE")=="DSPIC33EP128GM710") 
....................     #if !defined(__dsPIC33EP128GM710__) 
....................         #define __dsPIC33EP128GM710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GM710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GM710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GP502__) || (getenv("DEVICE")=="DSPIC33EP128GP502") 
....................     #if !defined(__dsPIC33EP128GP502__) 
....................         #define __dsPIC33EP128GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GP502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GP504__) || (getenv("DEVICE")=="DSPIC33EP128GP504") 
....................     #if !defined(__dsPIC33EP128GP504__) 
....................         #define __dsPIC33EP128GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GP504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128GP506__) || (getenv("DEVICE")=="DSPIC33EP128GP506") 
....................     #if !defined(__dsPIC33EP128GP506__) 
....................         #define __dsPIC33EP128GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128GP506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC202__) || (getenv("DEVICE")=="DSPIC33EP128MC202") 
....................     #if !defined(__dsPIC33EP128MC202__) 
....................         #define __dsPIC33EP128MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC204__) || (getenv("DEVICE")=="DSPIC33EP128MC204") 
....................     #if !defined(__dsPIC33EP128MC204__) 
....................         #define __dsPIC33EP128MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC206__) || (getenv("DEVICE")=="DSPIC33EP128MC206") 
....................     #if !defined(__dsPIC33EP128MC206__) 
....................         #define __dsPIC33EP128MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC206.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC502__) || (getenv("DEVICE")=="DSPIC33EP128MC502") 
....................     #if !defined(__dsPIC33EP128MC502__) 
....................         #define __dsPIC33EP128MC502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC504__) || (getenv("DEVICE")=="DSPIC33EP128MC504") 
....................     #if !defined(__dsPIC33EP128MC504__) 
....................         #define __dsPIC33EP128MC504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP128MC506__) || (getenv("DEVICE")=="DSPIC33EP128MC506") 
....................     #if !defined(__dsPIC33EP128MC506__) 
....................         #define __dsPIC33EP128MC506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP128MC506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP128MC506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM304__) || (getenv("DEVICE")=="DSPIC33EP256GM304") 
....................     #if !defined(__dsPIC33EP256GM304__) 
....................         #define __dsPIC33EP256GM304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM306__) || (getenv("DEVICE")=="DSPIC33EP256GM306") 
....................     #if !defined(__dsPIC33EP256GM306__) 
....................         #define __dsPIC33EP256GM306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM306.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM310__) || (getenv("DEVICE")=="DSPIC33EP256GM310") 
....................     #if !defined(__dsPIC33EP256GM310__) 
....................         #define __dsPIC33EP256GM310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM310.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM604__) || (getenv("DEVICE")=="DSPIC33EP256GM604") 
....................     #if !defined(__dsPIC33EP256GM604__) 
....................         #define __dsPIC33EP256GM604__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM604.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM604_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM706__) || (getenv("DEVICE")=="DSPIC33EP256GM706") 
....................     #if !defined(__dsPIC33EP256GM706__) 
....................         #define __dsPIC33EP256GM706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GM710__) || (getenv("DEVICE")=="DSPIC33EP256GM710") 
....................     #if !defined(__dsPIC33EP256GM710__) 
....................         #define __dsPIC33EP256GM710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GM710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GM710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GP502__) || (getenv("DEVICE")=="DSPIC33EP256GP502") 
....................     #if !defined(__dsPIC33EP256GP502__) 
....................         #define __dsPIC33EP256GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GP502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GP504__) || (getenv("DEVICE")=="DSPIC33EP256GP504") 
....................     #if !defined(__dsPIC33EP256GP504__) 
....................         #define __dsPIC33EP256GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GP504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256GP506__) || (getenv("DEVICE")=="DSPIC33EP256GP506") 
....................     #if !defined(__dsPIC33EP256GP506__) 
....................         #define __dsPIC33EP256GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256GP506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC202__) || (getenv("DEVICE")=="DSPIC33EP256MC202") 
....................     #if !defined(__dsPIC33EP256MC202__) 
....................         #define __dsPIC33EP256MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC204__) || (getenv("DEVICE")=="DSPIC33EP256MC204") 
....................     #if !defined(__dsPIC33EP256MC204__) 
....................         #define __dsPIC33EP256MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC206__) || (getenv("DEVICE")=="DSPIC33EP256MC206") 
....................     #if !defined(__dsPIC33EP256MC206__) 
....................         #define __dsPIC33EP256MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC206.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC502__) || (getenv("DEVICE")=="DSPIC33EP256MC502") 
....................     #if !defined(__dsPIC33EP256MC502__) 
....................         #define __dsPIC33EP256MC502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC504__) || (getenv("DEVICE")=="DSPIC33EP256MC504") 
....................     #if !defined(__dsPIC33EP256MC504__) 
....................         #define __dsPIC33EP256MC504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MC506__) || (getenv("DEVICE")=="DSPIC33EP256MC506") 
....................     #if !defined(__dsPIC33EP256MC506__) 
....................         #define __dsPIC33EP256MC506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MC506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MC506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MU806__) || (getenv("DEVICE")=="DSPIC33EP256MU806") 
....................     #if !defined(__dsPIC33EP256MU806__) 
....................         #define __dsPIC33EP256MU806__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MU806.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MU806_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MU810__) || (getenv("DEVICE")=="DSPIC33EP256MU810") 
....................     #if !defined(__dsPIC33EP256MU810__) 
....................         #define __dsPIC33EP256MU810__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MU810.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MU810_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP256MU814__) || (getenv("DEVICE")=="DSPIC33EP256MU814") 
....................     #if !defined(__dsPIC33EP256MU814__) 
....................         #define __dsPIC33EP256MU814__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP256MU814.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP256MU814_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32GP502__) || (getenv("DEVICE")=="DSPIC33EP32GP502") 
....................     #if !defined(__dsPIC33EP32GP502__) 
....................         #define __dsPIC33EP32GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32GP502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32GP503__) || (getenv("DEVICE")=="DSPIC33EP32GP503") 
....................     #if !defined(__dsPIC33EP32GP503__) 
....................         #define __dsPIC33EP32GP503__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32GP503.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32GP503_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32GP504__) || (getenv("DEVICE")=="DSPIC33EP32GP504") 
....................     #if !defined(__dsPIC33EP32GP504__) 
....................         #define __dsPIC33EP32GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32GP504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC202__) || (getenv("DEVICE")=="DSPIC33EP32MC202") 
....................     #if !defined(__dsPIC33EP32MC202__) 
....................         #define __dsPIC33EP32MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC203__) || (getenv("DEVICE")=="DSPIC33EP32MC203") 
....................     #if !defined(__dsPIC33EP32MC203__) 
....................         #define __dsPIC33EP32MC203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC203.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC204__) || (getenv("DEVICE")=="DSPIC33EP32MC204") 
....................     #if !defined(__dsPIC33EP32MC204__) 
....................         #define __dsPIC33EP32MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC502__) || (getenv("DEVICE")=="DSPIC33EP32MC502") 
....................     #if !defined(__dsPIC33EP32MC502__) 
....................         #define __dsPIC33EP32MC502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC503__) || (getenv("DEVICE")=="DSPIC33EP32MC503") 
....................     #if !defined(__dsPIC33EP32MC503__) 
....................         #define __dsPIC33EP32MC503__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC503.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC503_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP32MC504__) || (getenv("DEVICE")=="DSPIC33EP32MC504") 
....................     #if !defined(__dsPIC33EP32MC504__) 
....................         #define __dsPIC33EP32MC504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP32MC504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP32MC504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM304__) || (getenv("DEVICE")=="DSPIC33EP512GM304") 
....................     #if !defined(__dsPIC33EP512GM304__) 
....................         #define __dsPIC33EP512GM304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM306__) || (getenv("DEVICE")=="DSPIC33EP512GM306") 
....................     #if !defined(__dsPIC33EP512GM306__) 
....................         #define __dsPIC33EP512GM306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM306.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM310__) || (getenv("DEVICE")=="DSPIC33EP512GM310") 
....................     #if !defined(__dsPIC33EP512GM310__) 
....................         #define __dsPIC33EP512GM310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM310.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM604__) || (getenv("DEVICE")=="DSPIC33EP512GM604") 
....................     #if !defined(__dsPIC33EP512GM604__) 
....................         #define __dsPIC33EP512GM604__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM604.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM604_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM706__) || (getenv("DEVICE")=="DSPIC33EP512GM706") 
....................     #if !defined(__dsPIC33EP512GM706__) 
....................         #define __dsPIC33EP512GM706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GM710__) || (getenv("DEVICE")=="DSPIC33EP512GM710") 
....................     #if !defined(__dsPIC33EP512GM710__) 
....................         #define __dsPIC33EP512GM710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GM710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GM710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512GP806__) || (getenv("DEVICE")=="DSPIC33EP512GP806") 
....................     #if !defined(__dsPIC33EP512GP806__) 
....................         #define __dsPIC33EP512GP806__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512GP806.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512GP806_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512MC806__) || (getenv("DEVICE")=="DSPIC33EP512MC806") 
....................     #if !defined(__dsPIC33EP512MC806__) 
....................         #define __dsPIC33EP512MC806__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512MC806.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512MC806_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512MU810__) || (getenv("DEVICE")=="DSPIC33EP512MU810") 
....................     #if !defined(__dsPIC33EP512MU810__) 
....................         #define __dsPIC33EP512MU810__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512MU810.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512MU810_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP512MU814__) || (getenv("DEVICE")=="DSPIC33EP512MU814") 
....................     #if !defined(__dsPIC33EP512MU814__) 
....................         #define __dsPIC33EP512MU814__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP512MU814.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP512MU814_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64GP502__) || (getenv("DEVICE")=="DSPIC33EP64GP502") 
....................     #if !defined(__dsPIC33EP64GP502__) 
....................         #define __dsPIC33EP64GP502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64GP502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64GP502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64GP503__) || (getenv("DEVICE")=="DSPIC33EP64GP503") 
....................     #if !defined(__dsPIC33EP64GP503__) 
....................         #define __dsPIC33EP64GP503__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64GP503.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64GP503_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64GP504__) || (getenv("DEVICE")=="DSPIC33EP64GP504") 
....................     #if !defined(__dsPIC33EP64GP504__) 
....................         #define __dsPIC33EP64GP504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64GP504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64GP504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64GP506__) || (getenv("DEVICE")=="DSPIC33EP64GP506") 
....................     #if !defined(__dsPIC33EP64GP506__) 
....................         #define __dsPIC33EP64GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64GP506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC202__) || (getenv("DEVICE")=="DSPIC33EP64MC202") 
....................     #if !defined(__dsPIC33EP64MC202__) 
....................         #define __dsPIC33EP64MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC203__) || (getenv("DEVICE")=="DSPIC33EP64MC203") 
....................     #if !defined(__dsPIC33EP64MC203__) 
....................         #define __dsPIC33EP64MC203__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC203.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC203_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC204__) || (getenv("DEVICE")=="DSPIC33EP64MC204") 
....................     #if !defined(__dsPIC33EP64MC204__) 
....................         #define __dsPIC33EP64MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC206__) || (getenv("DEVICE")=="DSPIC33EP64MC206") 
....................     #if !defined(__dsPIC33EP64MC206__) 
....................         #define __dsPIC33EP64MC206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC206.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC502__) || (getenv("DEVICE")=="DSPIC33EP64MC502") 
....................     #if !defined(__dsPIC33EP64MC502__) 
....................         #define __dsPIC33EP64MC502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC503__) || (getenv("DEVICE")=="DSPIC33EP64MC503") 
....................     #if !defined(__dsPIC33EP64MC503__) 
....................         #define __dsPIC33EP64MC503__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC503.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC503_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC504__) || (getenv("DEVICE")=="DSPIC33EP64MC504") 
....................     #if !defined(__dsPIC33EP64MC504__) 
....................         #define __dsPIC33EP64MC504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33EP64MC506__) || (getenv("DEVICE")=="DSPIC33EP64MC506") 
....................     #if !defined(__dsPIC33EP64MC506__) 
....................         #define __dsPIC33EP64MC506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33EP64MC506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33E__) 
....................         #define __dsPIC33E__ 
....................     #endif 
....................     #include "33EP64MC506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS001__) || (getenv("DEVICE")=="DSPIC33FJ06GS001") 
....................     #if !defined(__dsPIC33FJ06GS001__) 
....................         #define __dsPIC33FJ06GS001__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS001.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS001_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS101__) || (getenv("DEVICE")=="DSPIC33FJ06GS101") 
....................     #if !defined(__dsPIC33FJ06GS101__) 
....................         #define __dsPIC33FJ06GS101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS101.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS101A__) || (getenv("DEVICE")=="DSPIC33FJ06GS101A") 
....................     #if !defined(__dsPIC33FJ06GS101A__) 
....................         #define __dsPIC33FJ06GS101A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS101A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS101A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS102__) || (getenv("DEVICE")=="DSPIC33FJ06GS102") 
....................     #if !defined(__dsPIC33FJ06GS102__) 
....................         #define __dsPIC33FJ06GS102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS102.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS102A__) || (getenv("DEVICE")=="DSPIC33FJ06GS102A") 
....................     #if !defined(__dsPIC33FJ06GS102A__) 
....................         #define __dsPIC33FJ06GS102A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS102A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS102A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS202__) || (getenv("DEVICE")=="DSPIC33FJ06GS202") 
....................     #if !defined(__dsPIC33FJ06GS202__) 
....................         #define __dsPIC33FJ06GS202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ06GS202A__) || (getenv("DEVICE")=="DSPIC33FJ06GS202A") 
....................     #if !defined(__dsPIC33FJ06GS202A__) 
....................         #define __dsPIC33FJ06GS202A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ06GS202A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ06GS202A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ09GS302__) || (getenv("DEVICE")=="DSPIC33FJ09GS302") 
....................     #if !defined(__dsPIC33FJ09GS302__) 
....................         #define __dsPIC33FJ09GS302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ09GS302.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ09GS302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP202__) || (getenv("DEVICE")=="DSPIC33FJ128GP202") 
....................     #if !defined(__dsPIC33FJ128GP202__) 
....................         #define __dsPIC33FJ128GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP204__) || (getenv("DEVICE")=="DSPIC33FJ128GP204") 
....................     #if !defined(__dsPIC33FJ128GP204__) 
....................         #define __dsPIC33FJ128GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP206__) || (getenv("DEVICE")=="DSPIC33FJ128GP206") 
....................     #if !defined(__dsPIC33FJ128GP206__) 
....................         #define __dsPIC33FJ128GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP206.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP206A__) || (getenv("DEVICE")=="DSPIC33FJ128GP206A") 
....................     #if !defined(__dsPIC33FJ128GP206A__) 
....................         #define __dsPIC33FJ128GP206A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP206A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP206A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP306__) || (getenv("DEVICE")=="DSPIC33FJ128GP306") 
....................     #if !defined(__dsPIC33FJ128GP306__) 
....................         #define __dsPIC33FJ128GP306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP306.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP306A__) || (getenv("DEVICE")=="DSPIC33FJ128GP306A") 
....................     #if !defined(__dsPIC33FJ128GP306A__) 
....................         #define __dsPIC33FJ128GP306A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP306A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP306A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP310__) || (getenv("DEVICE")=="DSPIC33FJ128GP310") 
....................     #if !defined(__dsPIC33FJ128GP310__) 
....................         #define __dsPIC33FJ128GP310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP310.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP310A__) || (getenv("DEVICE")=="DSPIC33FJ128GP310A") 
....................     #if !defined(__dsPIC33FJ128GP310A__) 
....................         #define __dsPIC33FJ128GP310A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP310A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP310A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP706__) || (getenv("DEVICE")=="DSPIC33FJ128GP706") 
....................     #if !defined(__dsPIC33FJ128GP706__) 
....................         #define __dsPIC33FJ128GP706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP706A__) || (getenv("DEVICE")=="DSPIC33FJ128GP706A") 
....................     #if !defined(__dsPIC33FJ128GP706A__) 
....................         #define __dsPIC33FJ128GP706A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP706A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP706A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP708__) || (getenv("DEVICE")=="DSPIC33FJ128GP708") 
....................     #if !defined(__dsPIC33FJ128GP708__) 
....................         #define __dsPIC33FJ128GP708__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP708.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP708_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP708A__) || (getenv("DEVICE")=="DSPIC33FJ128GP708A") 
....................     #if !defined(__dsPIC33FJ128GP708A__) 
....................         #define __dsPIC33FJ128GP708A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP708A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP708A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP710__) || (getenv("DEVICE")=="DSPIC33FJ128GP710") 
....................     #if !defined(__dsPIC33FJ128GP710__) 
....................         #define __dsPIC33FJ128GP710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP710A__) || (getenv("DEVICE")=="DSPIC33FJ128GP710A") 
....................     #if !defined(__dsPIC33FJ128GP710A__) 
....................         #define __dsPIC33FJ128GP710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP802__) || (getenv("DEVICE")=="DSPIC33FJ128GP802") 
....................     #if !defined(__dsPIC33FJ128GP802__) 
....................         #define __dsPIC33FJ128GP802__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP802.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP802_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128GP804__) || (getenv("DEVICE")=="DSPIC33FJ128GP804") 
....................     #if !defined(__dsPIC33FJ128GP804__) 
....................         #define __dsPIC33FJ128GP804__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128GP804.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128GP804_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC202__) || (getenv("DEVICE")=="DSPIC33FJ128MC202") 
....................     #if !defined(__dsPIC33FJ128MC202__) 
....................         #define __dsPIC33FJ128MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC204__) || (getenv("DEVICE")=="DSPIC33FJ128MC204") 
....................     #if !defined(__dsPIC33FJ128MC204__) 
....................         #define __dsPIC33FJ128MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC506__) || (getenv("DEVICE")=="DSPIC33FJ128MC506") 
....................     #if !defined(__dsPIC33FJ128MC506__) 
....................         #define __dsPIC33FJ128MC506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC506A__) || (getenv("DEVICE")=="DSPIC33FJ128MC506A") 
....................     #if !defined(__dsPIC33FJ128MC506A__) 
....................         #define __dsPIC33FJ128MC506A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC506A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC506A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC510__) || (getenv("DEVICE")=="DSPIC33FJ128MC510") 
....................     #if !defined(__dsPIC33FJ128MC510__) 
....................         #define __dsPIC33FJ128MC510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC510.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC510A__) || (getenv("DEVICE")=="DSPIC33FJ128MC510A") 
....................     #if !defined(__dsPIC33FJ128MC510A__) 
....................         #define __dsPIC33FJ128MC510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC510A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC706__) || (getenv("DEVICE")=="DSPIC33FJ128MC706") 
....................     #if !defined(__dsPIC33FJ128MC706__) 
....................         #define __dsPIC33FJ128MC706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC706A__) || (getenv("DEVICE")=="DSPIC33FJ128MC706A") 
....................     #if !defined(__dsPIC33FJ128MC706A__) 
....................         #define __dsPIC33FJ128MC706A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC706A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC706A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC708__) || (getenv("DEVICE")=="DSPIC33FJ128MC708") 
....................     #if !defined(__dsPIC33FJ128MC708__) 
....................         #define __dsPIC33FJ128MC708__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC708.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC708_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC708A__) || (getenv("DEVICE")=="DSPIC33FJ128MC708A") 
....................     #if !defined(__dsPIC33FJ128MC708A__) 
....................         #define __dsPIC33FJ128MC708A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC708A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC708A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC710__) || (getenv("DEVICE")=="DSPIC33FJ128MC710") 
....................     #if !defined(__dsPIC33FJ128MC710__) 
....................         #define __dsPIC33FJ128MC710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC710A__) || (getenv("DEVICE")=="DSPIC33FJ128MC710A") 
....................     #if !defined(__dsPIC33FJ128MC710A__) 
....................         #define __dsPIC33FJ128MC710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC802__) || (getenv("DEVICE")=="DSPIC33FJ128MC802") 
....................     #if !defined(__dsPIC33FJ128MC802__) 
....................         #define __dsPIC33FJ128MC802__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC802.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC802_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ128MC804__) || (getenv("DEVICE")=="DSPIC33FJ128MC804") 
....................     #if !defined(__dsPIC33FJ128MC804__) 
....................         #define __dsPIC33FJ128MC804__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ128MC804.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ128MC804_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ12GP201__) || (getenv("DEVICE")=="DSPIC33FJ12GP201") 
....................     #if !defined(__dsPIC33FJ12GP201__) 
....................         #define __dsPIC33FJ12GP201__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ12GP201.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ12GP201_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ12GP202__) || (getenv("DEVICE")=="DSPIC33FJ12GP202") 
....................     #if !defined(__dsPIC33FJ12GP202__) 
....................         #define __dsPIC33FJ12GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ12GP202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ12GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ12MC201__) || (getenv("DEVICE")=="DSPIC33FJ12MC201") 
....................     #if !defined(__dsPIC33FJ12MC201__) 
....................         #define __dsPIC33FJ12MC201__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ12MC201.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ12MC201_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ12MC202__) || (getenv("DEVICE")=="DSPIC33FJ12MC202") 
....................     #if !defined(__dsPIC33FJ12MC202__) 
....................         #define __dsPIC33FJ12MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ12MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ12MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GP101__) || (getenv("DEVICE")=="DSPIC33FJ16GP101") 
....................     #if !defined(__dsPIC33FJ16GP101__) 
....................         #define __dsPIC33FJ16GP101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GP101.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GP101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GP102__) || (getenv("DEVICE")=="DSPIC33FJ16GP102") 
....................     #if !defined(__dsPIC33FJ16GP102__) 
....................         #define __dsPIC33FJ16GP102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GP102.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GP102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GP304__) || (getenv("DEVICE")=="DSPIC33FJ16GP304") 
....................     #if !defined(__dsPIC33FJ16GP304__) 
....................         #define __dsPIC33FJ16GP304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GP304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GP304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GS402__) || (getenv("DEVICE")=="DSPIC33FJ16GS402") 
....................     #if !defined(__dsPIC33FJ16GS402__) 
....................         #define __dsPIC33FJ16GS402__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GS402.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GS402_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GS404__) || (getenv("DEVICE")=="DSPIC33FJ16GS404") 
....................     #if !defined(__dsPIC33FJ16GS404__) 
....................         #define __dsPIC33FJ16GS404__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GS404.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GS404_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GS502__) || (getenv("DEVICE")=="DSPIC33FJ16GS502") 
....................     #if !defined(__dsPIC33FJ16GS502__) 
....................         #define __dsPIC33FJ16GS502__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GS502.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GS502_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16GS504__) || (getenv("DEVICE")=="DSPIC33FJ16GS504") 
....................     #if !defined(__dsPIC33FJ16GS504__) 
....................         #define __dsPIC33FJ16GS504__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16GS504.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16GS504_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16MC101__) || (getenv("DEVICE")=="DSPIC33FJ16MC101") 
....................     #if !defined(__dsPIC33FJ16MC101__) 
....................         #define __dsPIC33FJ16MC101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16MC101.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16MC101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16MC102__) || (getenv("DEVICE")=="DSPIC33FJ16MC102") 
....................     #if !defined(__dsPIC33FJ16MC102__) 
....................         #define __dsPIC33FJ16MC102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16MC102.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16MC102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ16MC304__) || (getenv("DEVICE")=="DSPIC33FJ16MC304") 
....................     #if !defined(__dsPIC33FJ16MC304__) 
....................         #define __dsPIC33FJ16MC304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ16MC304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ16MC304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP506__) || (getenv("DEVICE")=="DSPIC33FJ256GP506") 
....................     #if !defined(__dsPIC33FJ256GP506__) 
....................         #define __dsPIC33FJ256GP506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP506A__) || (getenv("DEVICE")=="DSPIC33FJ256GP506A") 
....................     #if !defined(__dsPIC33FJ256GP506A__) 
....................         #define __dsPIC33FJ256GP506A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP506A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP506A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP510__) || (getenv("DEVICE")=="DSPIC33FJ256GP510") 
....................     #if !defined(__dsPIC33FJ256GP510__) 
....................         #define __dsPIC33FJ256GP510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP510.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP510A__) || (getenv("DEVICE")=="DSPIC33FJ256GP510A") 
....................     #if !defined(__dsPIC33FJ256GP510A__) 
....................         #define __dsPIC33FJ256GP510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP510A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP710__) || (getenv("DEVICE")=="DSPIC33FJ256GP710") 
....................     #if !defined(__dsPIC33FJ256GP710__) 
....................         #define __dsPIC33FJ256GP710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256GP710A__) || (getenv("DEVICE")=="DSPIC33FJ256GP710A") 
....................     #if !defined(__dsPIC33FJ256GP710A__) 
....................         #define __dsPIC33FJ256GP710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256GP710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256GP710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256MC510__) || (getenv("DEVICE")=="DSPIC33FJ256MC510") 
....................     #if !defined(__dsPIC33FJ256MC510__) 
....................         #define __dsPIC33FJ256MC510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256MC510.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256MC510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256MC510A__) || (getenv("DEVICE")=="DSPIC33FJ256MC510A") 
....................     #if !defined(__dsPIC33FJ256MC510A__) 
....................         #define __dsPIC33FJ256MC510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256MC510A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256MC510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256MC710__) || (getenv("DEVICE")=="DSPIC33FJ256MC710") 
....................     #if !defined(__dsPIC33FJ256MC710__) 
....................         #define __dsPIC33FJ256MC710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256MC710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256MC710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ256MC710A__) || (getenv("DEVICE")=="DSPIC33FJ256MC710A") 
....................     #if !defined(__dsPIC33FJ256MC710A__) 
....................         #define __dsPIC33FJ256MC710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ256MC710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ256MC710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP101__) || (getenv("DEVICE")=="DSPIC33FJ32GP101") 
....................     #if !defined(__dsPIC33FJ32GP101__) 
....................         #define __dsPIC33FJ32GP101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP101.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP102__) || (getenv("DEVICE")=="DSPIC33FJ32GP102") 
....................     #if !defined(__dsPIC33FJ32GP102__) 
....................         #define __dsPIC33FJ32GP102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP102.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP104__) || (getenv("DEVICE")=="DSPIC33FJ32GP104") 
....................     #if !defined(__dsPIC33FJ32GP104__) 
....................         #define __dsPIC33FJ32GP104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP104.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP202__) || (getenv("DEVICE")=="DSPIC33FJ32GP202") 
....................     #if !defined(__dsPIC33FJ32GP202__) 
....................         #define __dsPIC33FJ32GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP204__) || (getenv("DEVICE")=="DSPIC33FJ32GP204") 
....................     #if !defined(__dsPIC33FJ32GP204__) 
....................         #define __dsPIC33FJ32GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP302__) || (getenv("DEVICE")=="DSPIC33FJ32GP302") 
....................     #if !defined(__dsPIC33FJ32GP302__) 
....................         #define __dsPIC33FJ32GP302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP302.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GP304__) || (getenv("DEVICE")=="DSPIC33FJ32GP304") 
....................     #if !defined(__dsPIC33FJ32GP304__) 
....................         #define __dsPIC33FJ32GP304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GP304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GP304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GS406__) || (getenv("DEVICE")=="DSPIC33FJ32GS406") 
....................     #if !defined(__dsPIC33FJ32GS406__) 
....................         #define __dsPIC33FJ32GS406__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GS406.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GS406_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GS606__) || (getenv("DEVICE")=="DSPIC33FJ32GS606") 
....................     #if !defined(__dsPIC33FJ32GS606__) 
....................         #define __dsPIC33FJ32GS606__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GS606.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GS606_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GS608__) || (getenv("DEVICE")=="DSPIC33FJ32GS608") 
....................     #if !defined(__dsPIC33FJ32GS608__) 
....................         #define __dsPIC33FJ32GS608__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GS608.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GS608_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32GS610__) || (getenv("DEVICE")=="DSPIC33FJ32GS610") 
....................     #if !defined(__dsPIC33FJ32GS610__) 
....................         #define __dsPIC33FJ32GS610__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32GS610.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32GS610_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC101__) || (getenv("DEVICE")=="DSPIC33FJ32MC101") 
....................     #if !defined(__dsPIC33FJ32MC101__) 
....................         #define __dsPIC33FJ32MC101__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC101.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC101_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC102__) || (getenv("DEVICE")=="DSPIC33FJ32MC102") 
....................     #if !defined(__dsPIC33FJ32MC102__) 
....................         #define __dsPIC33FJ32MC102__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC102.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC102_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC104__) || (getenv("DEVICE")=="DSPIC33FJ32MC104") 
....................     #if !defined(__dsPIC33FJ32MC104__) 
....................         #define __dsPIC33FJ32MC104__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC104.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC104_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC202__) || (getenv("DEVICE")=="DSPIC33FJ32MC202") 
....................     #if !defined(__dsPIC33FJ32MC202__) 
....................         #define __dsPIC33FJ32MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC204__) || (getenv("DEVICE")=="DSPIC33FJ32MC204") 
....................     #if !defined(__dsPIC33FJ32MC204__) 
....................         #define __dsPIC33FJ32MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC302__) || (getenv("DEVICE")=="DSPIC33FJ32MC302") 
....................     #if !defined(__dsPIC33FJ32MC302__) 
....................         #define __dsPIC33FJ32MC302__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC302.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC302_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ32MC304__) || (getenv("DEVICE")=="DSPIC33FJ32MC304") 
....................     #if !defined(__dsPIC33FJ32MC304__) 
....................         #define __dsPIC33FJ32MC304__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ32MC304.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ32MC304_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP202__) || (getenv("DEVICE")=="DSPIC33FJ64GP202") 
....................     #if !defined(__dsPIC33FJ64GP202__) 
....................         #define __dsPIC33FJ64GP202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP204__) || (getenv("DEVICE")=="DSPIC33FJ64GP204") 
....................     #if !defined(__dsPIC33FJ64GP204__) 
....................         #define __dsPIC33FJ64GP204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP206__) || (getenv("DEVICE")=="DSPIC33FJ64GP206") 
....................     #if !defined(__dsPIC33FJ64GP206__) 
....................         #define __dsPIC33FJ64GP206__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP206.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP206_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP206A__) || (getenv("DEVICE")=="DSPIC33FJ64GP206A") 
....................     #if !defined(__dsPIC33FJ64GP206A__) 
....................         #define __dsPIC33FJ64GP206A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP206A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP206A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP306__) || (getenv("DEVICE")=="DSPIC33FJ64GP306") 
....................     #if !defined(__dsPIC33FJ64GP306__) 
....................         #define __dsPIC33FJ64GP306__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP306.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP306_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP306A__) || (getenv("DEVICE")=="DSPIC33FJ64GP306A") 
....................     #if !defined(__dsPIC33FJ64GP306A__) 
....................         #define __dsPIC33FJ64GP306A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP306A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP306A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP310__) || (getenv("DEVICE")=="DSPIC33FJ64GP310") 
....................     #if !defined(__dsPIC33FJ64GP310__) 
....................         #define __dsPIC33FJ64GP310__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP310.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP310_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP310A__) || (getenv("DEVICE")=="DSPIC33FJ64GP310A") 
....................     #if !defined(__dsPIC33FJ64GP310A__) 
....................         #define __dsPIC33FJ64GP310A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP310A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP310A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP706__) || (getenv("DEVICE")=="DSPIC33FJ64GP706") 
....................     #if !defined(__dsPIC33FJ64GP706__) 
....................         #define __dsPIC33FJ64GP706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP706A__) || (getenv("DEVICE")=="DSPIC33FJ64GP706A") 
....................     #if !defined(__dsPIC33FJ64GP706A__) 
....................         #define __dsPIC33FJ64GP706A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP706A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP706A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP708__) || (getenv("DEVICE")=="DSPIC33FJ64GP708") 
....................     #if !defined(__dsPIC33FJ64GP708__) 
....................         #define __dsPIC33FJ64GP708__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP708.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP708_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP708A__) || (getenv("DEVICE")=="DSPIC33FJ64GP708A") 
....................     #if !defined(__dsPIC33FJ64GP708A__) 
....................         #define __dsPIC33FJ64GP708A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP708A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP708A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP710__) || (getenv("DEVICE")=="DSPIC33FJ64GP710") 
....................     #if !defined(__dsPIC33FJ64GP710__) 
....................         #define __dsPIC33FJ64GP710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP710A__) || (getenv("DEVICE")=="DSPIC33FJ64GP710A") 
....................     #if !defined(__dsPIC33FJ64GP710A__) 
....................         #define __dsPIC33FJ64GP710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP802__) || (getenv("DEVICE")=="DSPIC33FJ64GP802") 
....................     #if !defined(__dsPIC33FJ64GP802__) 
....................         #define __dsPIC33FJ64GP802__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP802.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP802_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GP804__) || (getenv("DEVICE")=="DSPIC33FJ64GP804") 
....................     #if !defined(__dsPIC33FJ64GP804__) 
....................         #define __dsPIC33FJ64GP804__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GP804.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GP804_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GS406__) || (getenv("DEVICE")=="DSPIC33FJ64GS406") 
....................     #if !defined(__dsPIC33FJ64GS406__) 
....................         #define __dsPIC33FJ64GS406__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GS406.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GS406_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GS606__) || (getenv("DEVICE")=="DSPIC33FJ64GS606") 
....................     #if !defined(__dsPIC33FJ64GS606__) 
....................         #define __dsPIC33FJ64GS606__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GS606.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GS606_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GS608__) || (getenv("DEVICE")=="DSPIC33FJ64GS608") 
....................     #if !defined(__dsPIC33FJ64GS608__) 
....................         #define __dsPIC33FJ64GS608__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GS608.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GS608_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64GS610__) || (getenv("DEVICE")=="DSPIC33FJ64GS610") 
....................     #if !defined(__dsPIC33FJ64GS610__) 
....................         #define __dsPIC33FJ64GS610__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64GS610.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64GS610_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC202__) || (getenv("DEVICE")=="DSPIC33FJ64MC202") 
....................     #if !defined(__dsPIC33FJ64MC202__) 
....................         #define __dsPIC33FJ64MC202__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC202.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC202_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC204__) || (getenv("DEVICE")=="DSPIC33FJ64MC204") 
....................     #if !defined(__dsPIC33FJ64MC204__) 
....................         #define __dsPIC33FJ64MC204__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC204.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC204_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC506__) || (getenv("DEVICE")=="DSPIC33FJ64MC506") 
....................     #if !defined(__dsPIC33FJ64MC506__) 
....................         #define __dsPIC33FJ64MC506__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC506.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC506_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC506A__) || (getenv("DEVICE")=="DSPIC33FJ64MC506A") 
....................     #if !defined(__dsPIC33FJ64MC506A__) 
....................         #define __dsPIC33FJ64MC506A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC506A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC506A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC508__) || (getenv("DEVICE")=="DSPIC33FJ64MC508") 
....................     #if !defined(__dsPIC33FJ64MC508__) 
....................         #define __dsPIC33FJ64MC508__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC508.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC508_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC508A__) || (getenv("DEVICE")=="DSPIC33FJ64MC508A") 
....................     #if !defined(__dsPIC33FJ64MC508A__) 
....................         #define __dsPIC33FJ64MC508A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC508A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC508A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC510__) || (getenv("DEVICE")=="DSPIC33FJ64MC510") 
....................     #if !defined(__dsPIC33FJ64MC510__) 
....................         #define __dsPIC33FJ64MC510__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC510.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC510_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC510A__) || (getenv("DEVICE")=="DSPIC33FJ64MC510A") 
....................     #if !defined(__dsPIC33FJ64MC510A__) 
....................         #define __dsPIC33FJ64MC510A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC510A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC510A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC706__) || (getenv("DEVICE")=="DSPIC33FJ64MC706") 
....................     #if !defined(__dsPIC33FJ64MC706__) 
....................         #define __dsPIC33FJ64MC706__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC706.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC706_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC706A__) || (getenv("DEVICE")=="DSPIC33FJ64MC706A") 
....................     #if !defined(__dsPIC33FJ64MC706A__) 
....................         #define __dsPIC33FJ64MC706A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC706A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC706A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC710__) || (getenv("DEVICE")=="DSPIC33FJ64MC710") 
....................     #if !defined(__dsPIC33FJ64MC710__) 
....................         #define __dsPIC33FJ64MC710__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC710.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC710_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC710A__) || (getenv("DEVICE")=="DSPIC33FJ64MC710A") 
....................     #if !defined(__dsPIC33FJ64MC710A__) 
....................         #define __dsPIC33FJ64MC710A__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC710A.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC710A_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC802__) || (getenv("DEVICE")=="DSPIC33FJ64MC802") 
....................     #if !defined(__dsPIC33FJ64MC802__) 
....................         #define __dsPIC33FJ64MC802__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC802.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC802_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC33FJ64MC804__) || (getenv("DEVICE")=="DSPIC33FJ64MC804") 
....................     #if !defined(__dsPIC33FJ64MC804__) 
....................         #define __dsPIC33FJ64MC804__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <33FJ64MC804.h> 
....................     #endif 
....................     #if !defined(__dsPIC33F__) 
....................         #define __dsPIC33F__ 
....................     #endif 
....................     #include "33FJ64MC804_registers.h" 
.................... #endif 
....................  
.................... #if defined(__dsPIC81010__) || (getenv("DEVICE")=="DSPIC81010") 
....................     #if !defined(__dsPIC81010__) 
....................         #define __dsPIC81010__ 
....................     #endif 
....................     #if !defined(INTR_GLOBAL) 
....................         #include <81010.h> 
....................     #endif 
....................     #if !defined(__dsPIC810100__) 
....................         #define __dsPIC810100__ 
....................     #endif 
....................     #include "81010_registers.h" 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //#device PSV=16 
....................  
.................... //#if defined(__CONST_IS_READONLY__) 
.................... //   #device CONST=READ_ONLY 
.................... //#else 
.................... //   //this is normally how C30 operates 
.................... //   #device CONST=ROM 
.................... //#endif 
....................  
.................... //#device PASS_STRINGS=IN_RAM 
....................  
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #zero_ram 
.................... #zero_local_ram 
....................  
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
.................... #undef BYTE 
.................... #endif 
....................  
.................... #if defined(BOOLEAN) 
.................... #undef BOOLEAN 
.................... #endif 
....................  
.................... #define GetSystemClock()       getenv("CLOCK") 
.................... #define GetInstructionClock()  (GetSystemClock()/2) 
.................... #define GetPeripheralClock()   (GetSystemClock()/2) 
....................  
.................... //#define Reset()            reset_cpu()   //not needed, this is defined in Microchip's Compiler.h 
.................... //#define FAR                        //not needed, this is defined in Microchip's Compiler.h 
....................  
.................... #define ClrWdt()         restart_wdt() 
....................  
.................... #define Nop()            delay_cycles(1) 
....................  
.................... //#warning need eds support 
.................... #define __eds__ 
....................  
.................... #define __prog__  rom 
....................  
.................... #define __C30__ 
....................  
.................... #define __CCS_STDLIB_DYNAMIC_MEMORY__ 
....................  
.................... #endif 
....................  
.................... #else 
....................    #error PIC18 or dsPIC/PIC24 support ONLY 
.................... #endif 
....................  
.................... #include "HardwareProfile.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        HardwareProfile.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _MDD_HARDWAREPROFILE_H_ 
.................... #define _MDD_HARDWAREPROFILE_H_ 
....................  
.................... /*********************************************************************/ 
.................... /******************* Pin and Register Definitions ********************/ 
.................... /*********************************************************************/ 
....................  
.................... /* SD Card definitions: Change these to fit your application when using 
....................    an SD-card-based physical layer                                   */ 
.................... /* 
.................... #if (defined(HW_CCS_3V_ETHERNET)||defined(HW_CCS_46K20)) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)) 
.................... //CCS 18F67J60 3.3V Ethernet development kit with SD card 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................          
....................         // Chip Select Signal 
....................         #define SD_CS               PORTCbits.RC2 
....................         #define SD_CS_TRIS          TRISCbits.TRISC2 
....................          
....................         // Card detect signal 
....................         #define SD_CD               PORTEbits.RE5 
....................         #define SD_CD_TRIS          TRISEbits.TRISE5 
....................          
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................          
....................         // Defines for the HPC Explorer board 
....................         #define SPICLOCK            TRISCbits.TRISC3 
....................         #define SPIIN               TRISCbits.TRISC4 
....................         #define SPIOUT              TRISCbits.TRISC5 
....................      
....................         // Latch pins for SCK/SDI/SDO lines 
....................         #define SPICLOCKLAT         LATCbits.LATC3 
....................         #define SPIINLAT            LATCbits.LATC4 
....................         #define SPIOUTLAT           LATCbits.LATC5 
....................      
....................         // Port pins for SCK/SDI/SDO lines 
....................         #define SPICLOCKPORT        PORTCbits.RC3 
....................         #define SPIINPORT           PORTCbits.RC4 
....................         #define SPIOUTPORT          PORTCbits.RC5 
....................  
....................         // Registers for the SPI module you want to use 
....................         #define SPICON1             SSP1CON1 
....................         #define SPISTAT             SSP1STAT 
....................         #define SPIBUF              SSP1BUF 
....................         #define SPICON1bits         SSP1CON1bits 
....................         #define SPISTATbits         SSP1STATbits 
....................          
....................         #define PIR1_LOC   getenv("SFR:PIR1") 
....................         //#define SPI_INTERRUPT_FLAG_ASM PIR1_LOC,3 
....................         #define SPI_INTERRUPT_FLAG_ASM PIR1,3 
....................  
....................        //set SPI_INTERRUPT_FLAG to SPI1 interrupt flag. 
....................        //some PICs this bit is defined as SSP1IF and some PICs this is defined 
....................        //as SSPIF. 
....................         #if getenv("BIT_VALID:SSP1IF") 
....................          #bit SPI_INTERRUPT_FLAG=getenv("BIT:SSP1IF") 
....................         #else 
....................          #bit SPI_INTERRUPT_FLAG=getenv("BIT:SSPIF") 
....................         #endif 
....................      
....................         #define SPIENABLE           SPICON1bits.SSPEN 
.................... #endif   //HW_CCS_3V_ETHERNET 
....................  
.................... // ccs dsp analog board with (33hj) sd connector 
.................... #if defined(HW_CCS_DSP_AUDIO) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATDbits.LATD8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISDbits.TRISD8 
....................                  
....................          //NO SD_CD or SD_CD_TRIS 
....................          #define MEDIA_SOFT_DETECT 
....................  
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI2CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI2STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI2BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI2STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI2STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI2CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI2STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISFbits.TRISF4 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISFbits.TRISF5 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISBbits.TRISB15 
.................... #endif 
....................  
.................... // ccs dsp analog board (33ep) with sd connector 
.................... #if defined(HW_CCS_DSP_AUDIO2) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATDbits.LATD8 //PIN_D8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISDbits.TRISD8 
....................         #define SD_CS_ANSEL         ANSELEbits.ANSE8 
....................          
....................          //NO SD_CD or SD_CD_TRIS   //PIN_E1 
....................          #define SD_CD              PORTEbits.RE1 
....................          #define SD_CD_TRIS              TRISEbits.TRISE1 
....................  
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................  
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI1CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI1STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI1BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI1STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI1STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI1CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI1STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISGbits.TRISG6 
....................         #define SD_SCK_ANSEL        ANSELGbits.ANSG6 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISGbits.TRISG7 
....................         #define SD_SDI_ANSEL        ANSELGbits.ANSG7 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISGbits.TRISG8 
....................         #define SD_SDO_ANSEL        ANSELGbits.ANSG8 
.................... #endif 
....................  
.................... #if defined(HW_CCS_DSP_AUDIO) && defined(USE_SST25_INTERFACE) 
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................          
....................         //chip select pin of SST25 
....................         #define FLASH_SELECT_PIN PIN_F1 
....................          
....................         //configure sst25 library spi stream 
....................         #use spi(SPI2, MODE=0, BITS=8, baud=1000000, STREAM=SPI_SST25, FORCE_HW) 
....................         #define FLASH_STREAM SPI_SST25 
.................... #endif 
....................  
.................... */ 
.................... #if defined(HW_CCS_PIC24USB) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
.................... // ccs dsp analog board with sd connector 
....................  
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
.................... //        #define GetSystemClock() getenv("CLOCK") 
....................  //       #define GetPeripheralClock()    GetSystemClock() 
....................   //      #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATGbits.LATG8      //pin_G8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISGbits.TRISG8 
....................  
.................... //This is the old setup  December 30, 2014 
....................         // Description: SD-SPI Chip Select Output bit 
....................         //#define SD_CS            LATBbits.LATB14      //pin_b14 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         //#define SD_CS_TRIS          TRISBbits.TRISB14 
....................  
....................         #define SD_CD            PORTBbits.RB12      //pin_b12 
....................         #define SD_CD_TRIS          TRISBbits.TRISB12 
....................  
....................          //NO SD_WE_TRIS         
....................          int1 SD_WE_TRIS; 
....................          int1 SD_WE=0; 
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI1CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI1STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI1BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI1STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI1STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI1CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI1STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The main SPI control register 
....................         //#define SPICON1             SPI2CON1 
....................         // Description: The SPI status register 
....................         //#define SPISTAT             SPI2STAT 
....................         // Description: The SPI Buffer 
....................         //#define SPIBUF              SPI2BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         //#define SPISTAT_RBF         SPI2STATbits.SPIRBF 
....................         //#define SPISTAT_TBF         SPI2STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         //#define SPICON1bits         SPI2CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         //#define SPISTATbits         SPI2STATbits 
....................         // Description: The enable bit for the SPI module 
....................         //#define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................  
....................        // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISFbits.TRISF3 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISFbits.TRISF6 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISFbits.TRISF2 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         //#define SPICLOCK            TRISGbits.TRISG6 
....................         // Description: The TRIS bit for the SDI pin 
....................         //#define SPIIN               TRISGbits.TRISG7 
....................         // Description: The TRIS bit for the SDO pin 
....................         //#define SPIOUT              TRISGbits.TRISG8 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #include "FSConfig.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSconfig.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Dependencies:    None 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _FS_DEF_ 
.................... #define _FS_DEF_ 
....................  
.................... //#include "Compiler.h" 
.................... #include "HardwareProfile.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        HardwareProfile.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _MDD_HARDWAREPROFILE_H_ 
.................... #define _MDD_HARDWAREPROFILE_H_ 
....................  
.................... /*********************************************************************/ 
.................... /******************* Pin and Register Definitions ********************/ 
.................... /*********************************************************************/ 
....................  
.................... /* SD Card definitions: Change these to fit your application when using 
....................    an SD-card-based physical layer                                   */ 
.................... /* 
.................... #if (defined(HW_CCS_3V_ETHERNET)||defined(HW_CCS_46K20)) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)) 
.................... //CCS 18F67J60 3.3V Ethernet development kit with SD card 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................          
....................         // Chip Select Signal 
....................         #define SD_CS               PORTCbits.RC2 
....................         #define SD_CS_TRIS          TRISCbits.TRISC2 
....................          
....................         // Card detect signal 
....................         #define SD_CD               PORTEbits.RE5 
....................         #define SD_CD_TRIS          TRISEbits.TRISE5 
....................          
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................          
....................         // Defines for the HPC Explorer board 
....................         #define SPICLOCK            TRISCbits.TRISC3 
....................         #define SPIIN               TRISCbits.TRISC4 
....................         #define SPIOUT              TRISCbits.TRISC5 
....................      
....................         // Latch pins for SCK/SDI/SDO lines 
....................         #define SPICLOCKLAT         LATCbits.LATC3 
....................         #define SPIINLAT            LATCbits.LATC4 
....................         #define SPIOUTLAT           LATCbits.LATC5 
....................      
....................         // Port pins for SCK/SDI/SDO lines 
....................         #define SPICLOCKPORT        PORTCbits.RC3 
....................         #define SPIINPORT           PORTCbits.RC4 
....................         #define SPIOUTPORT          PORTCbits.RC5 
....................  
....................         // Registers for the SPI module you want to use 
....................         #define SPICON1             SSP1CON1 
....................         #define SPISTAT             SSP1STAT 
....................         #define SPIBUF              SSP1BUF 
....................         #define SPICON1bits         SSP1CON1bits 
....................         #define SPISTATbits         SSP1STATbits 
....................          
....................         #define PIR1_LOC   getenv("SFR:PIR1") 
....................         //#define SPI_INTERRUPT_FLAG_ASM PIR1_LOC,3 
....................         #define SPI_INTERRUPT_FLAG_ASM PIR1,3 
....................  
....................        //set SPI_INTERRUPT_FLAG to SPI1 interrupt flag. 
....................        //some PICs this bit is defined as SSP1IF and some PICs this is defined 
....................        //as SSPIF. 
....................         #if getenv("BIT_VALID:SSP1IF") 
....................          #bit SPI_INTERRUPT_FLAG=getenv("BIT:SSP1IF") 
....................         #else 
....................          #bit SPI_INTERRUPT_FLAG=getenv("BIT:SSPIF") 
....................         #endif 
....................      
....................         #define SPIENABLE           SPICON1bits.SSPEN 
.................... #endif   //HW_CCS_3V_ETHERNET 
....................  
.................... // ccs dsp analog board with (33hj) sd connector 
.................... #if defined(HW_CCS_DSP_AUDIO) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATDbits.LATD8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISDbits.TRISD8 
....................                  
....................          //NO SD_CD or SD_CD_TRIS 
....................          #define MEDIA_SOFT_DETECT 
....................  
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI2CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI2STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI2BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI2STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI2STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI2CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI2STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISFbits.TRISF4 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISFbits.TRISF5 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISBbits.TRISB15 
.................... #endif 
....................  
.................... // ccs dsp analog board (33ep) with sd connector 
.................... #if defined(HW_CCS_DSP_AUDIO2) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATDbits.LATD8 //PIN_D8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISDbits.TRISD8 
....................         #define SD_CS_ANSEL         ANSELEbits.ANSE8 
....................          
....................          //NO SD_CD or SD_CD_TRIS   //PIN_E1 
....................          #define SD_CD              PORTEbits.RE1 
....................          #define SD_CD_TRIS              TRISEbits.TRISE1 
....................  
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................  
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI1CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI1STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI1BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI1STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI1STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI1CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI1STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISGbits.TRISG6 
....................         #define SD_SCK_ANSEL        ANSELGbits.ANSG6 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISGbits.TRISG7 
....................         #define SD_SDI_ANSEL        ANSELGbits.ANSG7 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISGbits.TRISG8 
....................         #define SD_SDO_ANSEL        ANSELGbits.ANSG8 
.................... #endif 
....................  
.................... #if defined(HW_CCS_DSP_AUDIO) && defined(USE_SST25_INTERFACE) 
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................          
....................         //chip select pin of SST25 
....................         #define FLASH_SELECT_PIN PIN_F1 
....................          
....................         //configure sst25 library spi stream 
....................         #use spi(SPI2, MODE=0, BITS=8, baud=1000000, STREAM=SPI_SST25, FORCE_HW) 
....................         #define FLASH_STREAM SPI_SST25 
.................... #endif 
....................  
.................... */ 
.................... #if defined(HW_CCS_PIC24USB) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
.................... // ccs dsp analog board with sd connector 
....................  
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
.................... //        #define GetSystemClock() getenv("CLOCK") 
....................  //       #define GetPeripheralClock()    GetSystemClock() 
....................   //      #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATGbits.LATG8      //pin_G8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISGbits.TRISG8 
....................  
.................... //This is the old setup  December 30, 2014 
....................         // Description: SD-SPI Chip Select Output bit 
....................         //#define SD_CS            LATBbits.LATB14      //pin_b14 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         //#define SD_CS_TRIS          TRISBbits.TRISB14 
....................  
....................         #define SD_CD            PORTBbits.RB12      //pin_b12 
....................         #define SD_CD_TRIS          TRISBbits.TRISB12 
....................  
....................          //NO SD_WE_TRIS         
....................          int1 SD_WE_TRIS; 
....................          int1 SD_WE=0; 
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI1CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI1STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI1BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI1STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI1STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI1CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI1STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The main SPI control register 
....................         //#define SPICON1             SPI2CON1 
....................         // Description: The SPI status register 
....................         //#define SPISTAT             SPI2STAT 
....................         // Description: The SPI Buffer 
....................         //#define SPIBUF              SPI2BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         //#define SPISTAT_RBF         SPI2STATbits.SPIRBF 
....................         //#define SPISTAT_TBF         SPI2STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         //#define SPICON1bits         SPI2CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         //#define SPISTATbits         SPI2STATbits 
....................         // Description: The enable bit for the SPI module 
....................         //#define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................  
....................        // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISFbits.TRISF3 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISFbits.TRISF6 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISFbits.TRISF2 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         //#define SPICLOCK            TRISGbits.TRISG6 
....................         // Description: The TRIS bit for the SDI pin 
....................         //#define SPIIN               TRISGbits.TRISG7 
....................         // Description: The TRIS bit for the SDO pin 
....................         //#define SPIOUT              TRISGbits.TRISG8 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // something to do with long filenames. 
.................... //#define SUPPORT_LFN 
....................  
.................... // Summary: A macro indicating the maximum number of concurrently open files 
.................... // Description: The FS_MAX_FILES_OPEN #define is only applicable when dynamic memory allocation is not used (FS_DYNAMIC_MEM is not defined). 
.................... //              This macro defines the maximum number of open files at any given time.  The amount of RAM used by FSFILE objects will 
.................... //              be equal to the size of an FSFILE object multipled by this macro value.  This value should be kept as small as possible 
.................... //              as dictated by the application.  This will reduce memory usage. 
.................... #define FS_MAX_FILES_OPEN    1 
....................  
....................  
.................... // if defined, MDD will be configured to use SST25 flash device. this definition 
.................... // should also define the size of the SST25 flash device. 
.................... // if not defined, will use SD card. 
.................... // #define  USE_SST25_INTERFACE  ((unsigned int32)2*1024*1024) 
....................  
.................... // Summary: A macro defining the size of a sector 
.................... // Description: The MEDIA_SECTOR_SIZE macro will define the size of a sector on the FAT file system.  This value must equal 512 bytes, 
.................... //              1024 bytes, 2048 bytes, or 4096 bytes.  The value of a sector will usually be 512 bytes. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define MEDIA_SECTOR_SIZE       4096   //erase size of SST25 flash device 
.................... #else 
.................... #define MEDIA_SECTOR_SIZE       512 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* *******************************************************************************************************/ 
.................... /************** Compiler options to enable/Disable Features based on user's application ******************/ 
.................... /* *******************************************************************************************************/ 
....................  
....................  
.................... // Summary: A macro to enable/disable file search functions. 
.................... // Description: The ALLOW_FILESEARCH definition can be commented out to disable file search functions in the library.  This will 
.................... //              prevent the use of the FindFirst and FindNext functions and reduce code size. 
.................... #define ALLOW_FILESEARCH 
....................  
.................... // Summary: A macro to enable/disable write functionality 
.................... // Description: The ALLOW_WRITES definition can be commented out to disable all operations that write to the device.  This will 
.................... //              greatly reduce code size. 
.................... #define ALLOW_WRITES 
....................  
....................  
.................... // Summary: A macro to enable/disable format functionality 
.................... // Description: The ALLOW_FORMATS definition can be commented out to disable formatting functionality.  This will prevent the use of 
.................... //              the FSformat function.  If formats are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define ALLOW_FORMATS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable directory operations. 
.................... // Description: The ALLOW_DIRS definition can be commented out to disable all directory functionality.  This will reduce code size. 
.................... //              If directories are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES in order to use 
.................... //              the FSmkdir or FSrmdir functions. 
.................... #define ALLOW_DIRS 
....................  
.................... // Summary: A macro to enable/disable PIC18 ROM functions. 
.................... // Description: The ALLOW_PGMFUNCTIONS definition can be commented out to disable all PIC18 functions that allow the user to pass string 
.................... //              arguments in ROM (denoted by the suffix -pgm).  Note that this functionality must be disabled when not using PIC18. 
.................... #if !defined(__CCS__) 
.................... #define ALLOW_PGMFUNCTIONS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable the FSfprintf function. 
.................... // Description: The ALLOW_FSFPRINTF definition can be commented out to disable the FSfprintf function.  This will save code space.  Note that 
.................... //              if FSfprintf is enabled and the PIC18 architecture is used, integer promotions must be enabled in the Project->Build Options 
.................... //              menu.  Write operations must be enabled to use FSfprintf. 
.................... //#define ALLOW_FSFPRINTF 
....................  
.................... // CCS added this config option to disable FAT12 to prevent recursion. 
.................... //__CCS__ added by ccs 
.................... //#define SUPPORT_FAT12 
....................  
.................... // Summary: A macro to enable/disable FAT32 support. 
.................... // Description: The SUPPORT_FAT32 definition can be commented out to disable support for FAT32 functionality.  This will save a small amount 
.................... //              of code space. 
.................... #define SUPPORT_FAT32 
....................  
....................  
....................  
.................... /**************************************************************************************************/ 
.................... // Select a method for updating file timestamps 
.................... /**************************************************************************************************/ 
....................  
.................... // Summary: A macro to enable RTCC based timestamp generation 
.................... // Description: The USEREALTIMECLOCK macro will configure the code to automatically 
.................... //              generate timestamp information for files from the RTCC module. The user 
.................... //              must enable and configure the RTCC module before creating or modifying 
.................... //              files.                                                                  
.................... //#define USEREALTIMECLOCK 
....................  
.................... // Summary: A macro to enable manual timestamp generation 
.................... // Description: The USERDEFINEDCLOCK macro will allow the user to manually set 
.................... //              timestamp information using the SetClockVars function. The user will 
.................... //              need to set the time variables immediately before creating or closing a 
.................... //              file or directory.                                                     
.................... #define USERDEFINEDCLOCK 
....................  
.................... // Summary: A macro to enable don't-care timestamp generation 
.................... // Description: The INCREMENTTIMESTAMP macro will set the create time of a file to a 
.................... //              static value and increment it when a file is updated. This timestamp 
.................... //              generation method should only be used in applications where file times 
.................... //              are not necessary.                                                     
.................... //#define INCREMENTTIMESTAMP 
....................  
....................  
.................... #ifdef __18CXX 
....................    #ifdef USEREALTIMECLOCK 
....................       #error Not all PIC18 devices have a Real-time clock and calander module 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    #ifndef __18CXX 
....................       #error The pgm functions are unneccessary when not using PIC18 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef USEREALTIMECLOCK 
....................     #ifndef USERDEFINEDCLOCK 
....................         #ifndef INCREMENTTIMESTAMP 
....................             #error Please enable USEREALTIMECLOCK, USERDEFINEDCLOCK, or INCREMENTTIMESTAMP 
....................         #endif 
....................     #endif 
.................... #endif 
....................  
.................... /************************************************************************/ 
.................... // Set this preprocessor option to '1' to use dynamic FSFILE object allocation.  It will 
.................... // be necessary to allocate a heap when dynamically allocating FSFILE objects. 
.................... // Set this option to '0' to use static FSFILE object allocation. 
.................... /************************************************************************/ 
....................  
.................... //#if 1  //from mirochip 
.................... #if defined(__PCH__) //__CCS__ 
....................     // Summary: A macro indicating that FSFILE objects will be allocated dynamically 
....................     // Description: The FS_DYNAMIC_MEM macro will cause FSFILE objects to be allocated from a dynamic heap.  If it is undefined, 
....................     //              the file objects will be allocated using a static array. 
....................    //#define FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................         // Description: Function pointer to a dynamic memory allocation function 
....................       #define FS_malloc   SRAMalloc 
....................         // Description: Function pointer to a dynamic memory free function 
....................       #define FS_free      SRAMfree 
....................    #else 
....................       #define FS_malloc   malloc 
....................       #define FS_free      free 
....................    #endif 
.................... #elif defined(__CCS__) 
....................    #error/warning Not using FS_DYNAMIC_MEM for PCD compiler 
.................... #endif 
....................  
....................  
.................... #ifdef __18CXX 
....................     /* Define the locations for the dataBuffer and FATbuffer; PLEASE CHECK THE LINKER FILE */ 
....................     #define DATA_BUFFER_ADDRESS      0x700 
....................     #define FAT_BUFFER_ADDRESS       0x900 
.................... #endif 
....................  
....................  
.................... // Function definitions 
.................... // Associate the physical layer functions with the correct physical layer 
.................... #ifdef USE_SD_INTERFACE_WITH_SPI       // SD-SPI.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_SDSPI_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_SDSPI_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_SDSPI_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_SDSPI_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_SDSPI_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_SDSPI_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_SDSPI_WriteProtectState 
....................  
....................     // Description: Function pointer to the Read Capacity Physical Layer function 
....................     #define MDD_ReadCapacity        MDD_SDSPI_ReadCapacity 
....................  
....................     // Description: Function pointer to the Read Sector Size Physical Layer Function 
....................     #define MDD_ReadSectorSize      MDD_SDSPI_ReadSectorSize 
....................  
.................... #elif defined USE_CF_INTERFACE_WITH_PMP       // CF-PMP.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFPMP_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFPMP_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFPMP_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFPMP_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFPMP_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFPMP_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFPMP_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFPMP_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFPMP_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFPMP_CFread 
....................  
.................... #elif defined USE_MANUAL_CF_INTERFACE         // CF-Bit transaction.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFBT_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFBT_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFBT_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFBT_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFBT_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFBT_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFBT_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFBT_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFBT_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFBT_CFread 
....................  
.................... #elif defined USE_USB_INTERFACE               // USB host MSD library 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     USBHostMSDSCSIMediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         USBHostMSDSCSIMediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          USBHostMSDSCSISectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         USBHostMSDSCSISectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO();               
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       USBHostMSDSCSIMediaReset 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   USBHostMSDSCSIWriteProtectState 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #include "MDD File System\FSIO.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSIO.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  *                  FSconfig.h 
....................  *                  FSDefs.h 
....................  *                  stddef.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.4.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  FS_DOT_H 
.................... #define  FS_DOT_H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "../FSconfig.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSconfig.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Dependencies:    None 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _FS_DEF_ 
.................... #define _FS_DEF_ 
....................  
.................... //#include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // something to do with long filenames. 
.................... //#define SUPPORT_LFN 
....................  
.................... // Summary: A macro indicating the maximum number of concurrently open files 
.................... // Description: The FS_MAX_FILES_OPEN #define is only applicable when dynamic memory allocation is not used (FS_DYNAMIC_MEM is not defined). 
.................... //              This macro defines the maximum number of open files at any given time.  The amount of RAM used by FSFILE objects will 
.................... //              be equal to the size of an FSFILE object multipled by this macro value.  This value should be kept as small as possible 
.................... //              as dictated by the application.  This will reduce memory usage. 
.................... #define FS_MAX_FILES_OPEN    1 
....................  
....................  
.................... // if defined, MDD will be configured to use SST25 flash device. this definition 
.................... // should also define the size of the SST25 flash device. 
.................... // if not defined, will use SD card. 
.................... // #define  USE_SST25_INTERFACE  ((unsigned int32)2*1024*1024) 
....................  
.................... // Summary: A macro defining the size of a sector 
.................... // Description: The MEDIA_SECTOR_SIZE macro will define the size of a sector on the FAT file system.  This value must equal 512 bytes, 
.................... //              1024 bytes, 2048 bytes, or 4096 bytes.  The value of a sector will usually be 512 bytes. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define MEDIA_SECTOR_SIZE       4096   //erase size of SST25 flash device 
.................... #else 
.................... #define MEDIA_SECTOR_SIZE       512 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* *******************************************************************************************************/ 
.................... /************** Compiler options to enable/Disable Features based on user's application ******************/ 
.................... /* *******************************************************************************************************/ 
....................  
....................  
.................... // Summary: A macro to enable/disable file search functions. 
.................... // Description: The ALLOW_FILESEARCH definition can be commented out to disable file search functions in the library.  This will 
.................... //              prevent the use of the FindFirst and FindNext functions and reduce code size. 
.................... #define ALLOW_FILESEARCH 
....................  
.................... // Summary: A macro to enable/disable write functionality 
.................... // Description: The ALLOW_WRITES definition can be commented out to disable all operations that write to the device.  This will 
.................... //              greatly reduce code size. 
.................... #define ALLOW_WRITES 
....................  
....................  
.................... // Summary: A macro to enable/disable format functionality 
.................... // Description: The ALLOW_FORMATS definition can be commented out to disable formatting functionality.  This will prevent the use of 
.................... //              the FSformat function.  If formats are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define ALLOW_FORMATS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable directory operations. 
.................... // Description: The ALLOW_DIRS definition can be commented out to disable all directory functionality.  This will reduce code size. 
.................... //              If directories are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES in order to use 
.................... //              the FSmkdir or FSrmdir functions. 
.................... #define ALLOW_DIRS 
....................  
.................... // Summary: A macro to enable/disable PIC18 ROM functions. 
.................... // Description: The ALLOW_PGMFUNCTIONS definition can be commented out to disable all PIC18 functions that allow the user to pass string 
.................... //              arguments in ROM (denoted by the suffix -pgm).  Note that this functionality must be disabled when not using PIC18. 
.................... #if !defined(__CCS__) 
.................... #define ALLOW_PGMFUNCTIONS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable the FSfprintf function. 
.................... // Description: The ALLOW_FSFPRINTF definition can be commented out to disable the FSfprintf function.  This will save code space.  Note that 
.................... //              if FSfprintf is enabled and the PIC18 architecture is used, integer promotions must be enabled in the Project->Build Options 
.................... //              menu.  Write operations must be enabled to use FSfprintf. 
.................... //#define ALLOW_FSFPRINTF 
....................  
.................... // CCS added this config option to disable FAT12 to prevent recursion. 
.................... //__CCS__ added by ccs 
.................... //#define SUPPORT_FAT12 
....................  
.................... // Summary: A macro to enable/disable FAT32 support. 
.................... // Description: The SUPPORT_FAT32 definition can be commented out to disable support for FAT32 functionality.  This will save a small amount 
.................... //              of code space. 
.................... #define SUPPORT_FAT32 
....................  
....................  
....................  
.................... /**************************************************************************************************/ 
.................... // Select a method for updating file timestamps 
.................... /**************************************************************************************************/ 
....................  
.................... // Summary: A macro to enable RTCC based timestamp generation 
.................... // Description: The USEREALTIMECLOCK macro will configure the code to automatically 
.................... //              generate timestamp information for files from the RTCC module. The user 
.................... //              must enable and configure the RTCC module before creating or modifying 
.................... //              files.                                                                  
.................... //#define USEREALTIMECLOCK 
....................  
.................... // Summary: A macro to enable manual timestamp generation 
.................... // Description: The USERDEFINEDCLOCK macro will allow the user to manually set 
.................... //              timestamp information using the SetClockVars function. The user will 
.................... //              need to set the time variables immediately before creating or closing a 
.................... //              file or directory.                                                     
.................... #define USERDEFINEDCLOCK 
....................  
.................... // Summary: A macro to enable don't-care timestamp generation 
.................... // Description: The INCREMENTTIMESTAMP macro will set the create time of a file to a 
.................... //              static value and increment it when a file is updated. This timestamp 
.................... //              generation method should only be used in applications where file times 
.................... //              are not necessary.                                                     
.................... //#define INCREMENTTIMESTAMP 
....................  
....................  
.................... #ifdef __18CXX 
....................    #ifdef USEREALTIMECLOCK 
....................       #error Not all PIC18 devices have a Real-time clock and calander module 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    #ifndef __18CXX 
....................       #error The pgm functions are unneccessary when not using PIC18 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef USEREALTIMECLOCK 
....................     #ifndef USERDEFINEDCLOCK 
....................         #ifndef INCREMENTTIMESTAMP 
....................             #error Please enable USEREALTIMECLOCK, USERDEFINEDCLOCK, or INCREMENTTIMESTAMP 
....................         #endif 
....................     #endif 
.................... #endif 
....................  
.................... /************************************************************************/ 
.................... // Set this preprocessor option to '1' to use dynamic FSFILE object allocation.  It will 
.................... // be necessary to allocate a heap when dynamically allocating FSFILE objects. 
.................... // Set this option to '0' to use static FSFILE object allocation. 
.................... /************************************************************************/ 
....................  
.................... //#if 1  //from mirochip 
.................... #if defined(__PCH__) //__CCS__ 
....................     // Summary: A macro indicating that FSFILE objects will be allocated dynamically 
....................     // Description: The FS_DYNAMIC_MEM macro will cause FSFILE objects to be allocated from a dynamic heap.  If it is undefined, 
....................     //              the file objects will be allocated using a static array. 
....................    //#define FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................         // Description: Function pointer to a dynamic memory allocation function 
....................       #define FS_malloc   SRAMalloc 
....................         // Description: Function pointer to a dynamic memory free function 
....................       #define FS_free      SRAMfree 
....................    #else 
....................       #define FS_malloc   malloc 
....................       #define FS_free      free 
....................    #endif 
.................... #elif defined(__CCS__) 
....................    #error/warning Not using FS_DYNAMIC_MEM for PCD compiler 
.................... #endif 
....................  
....................  
.................... #ifdef __18CXX 
....................     /* Define the locations for the dataBuffer and FATbuffer; PLEASE CHECK THE LINKER FILE */ 
....................     #define DATA_BUFFER_ADDRESS      0x700 
....................     #define FAT_BUFFER_ADDRESS       0x900 
.................... #endif 
....................  
....................  
.................... // Function definitions 
.................... // Associate the physical layer functions with the correct physical layer 
.................... #ifdef USE_SD_INTERFACE_WITH_SPI       // SD-SPI.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_SDSPI_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_SDSPI_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_SDSPI_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_SDSPI_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_SDSPI_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_SDSPI_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_SDSPI_WriteProtectState 
....................  
....................     // Description: Function pointer to the Read Capacity Physical Layer function 
....................     #define MDD_ReadCapacity        MDD_SDSPI_ReadCapacity 
....................  
....................     // Description: Function pointer to the Read Sector Size Physical Layer Function 
....................     #define MDD_ReadSectorSize      MDD_SDSPI_ReadSectorSize 
....................  
.................... #elif defined USE_CF_INTERFACE_WITH_PMP       // CF-PMP.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFPMP_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFPMP_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFPMP_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFPMP_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFPMP_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFPMP_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFPMP_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFPMP_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFPMP_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFPMP_CFread 
....................  
.................... #elif defined USE_MANUAL_CF_INTERFACE         // CF-Bit transaction.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFBT_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFBT_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFBT_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFBT_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFBT_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFBT_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFBT_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFBT_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFBT_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFBT_CFread 
....................  
.................... #elif defined USE_USB_INTERFACE               // USB host MSD library 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     USBHostMSDSCSIMediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         USBHostMSDSCSIMediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          USBHostMSDSCSISectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         USBHostMSDSCSISectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO();               
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       USBHostMSDSCSIMediaReset 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   USBHostMSDSCSIWriteProtectState 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "FSDefs.h"  
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSDefs.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.2.4 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  _FSDEF__H 
.................... #define  _FSDEF__H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
....................  
.................... // Summary: An enumeration used for various error codes. 
.................... // Description: The CETYPE enumeration is used to indicate different error conditions during device operation. 
.................... typedef enum _CETYPE 
.................... { 
....................     CE_GOOD = 0,                    // No error 
....................     CE_ERASE_FAIL,                  // An erase failed 
....................     CE_NOT_PRESENT,                 // No device was present 
....................     CE_NOT_FORMATTED,               // The disk is of an unsupported format 
....................     CE_BAD_PARTITION,               // The boot record is bad 
....................     CE_UNSUPPORTED_FS,              // The file system type is unsupported 
....................     CE_INIT_ERROR,                  // An initialization error has occured 
....................     CE_NOT_INIT,                    // An operation was performed on an uninitialized device 
....................     CE_BAD_SECTOR_READ,             // A bad read of a sector occured 
....................     CE_WRITE_ERROR,                 // Could not write to a sector 
....................     CE_INVALID_CLUSTER,             // Invalid cluster value > maxcls 
....................     CE_FILE_NOT_FOUND,              // Could not find the file on the device 
....................     CE_DIR_NOT_FOUND,               // Could not find the directory 
....................     CE_BAD_FILE,                    // File is corrupted 
....................     CE_DONE,                        // No more files in this directory 
....................     CE_COULD_NOT_GET_CLUSTER,       // Could not load/allocate next cluster in file 
....................     CE_FILENAME_2_LONG,             // A specified file name is too long to use 
....................     CE_FILENAME_EXISTS,             // A specified filename already exists on the device 
....................     CE_INVALID_FILENAME,            // Invalid file name 
....................     CE_DELETE_DIR,                  // The user tried to delete a directory with FSremove 
....................     CE_DIR_FULL,                    // All root dir entry are taken 
....................     CE_DISK_FULL,                   // All clusters in partition are taken 
....................     CE_DIR_NOT_EMPTY,               // This directory is not empty yet, remove files before deleting 
....................     CE_NONSUPPORTED_SIZE,           // The disk is too big to format as FAT16 
....................     CE_WRITE_PROTECTED,             // Card is write protected 
....................     CE_FILENOTOPENED,               // File not opened for the write 
....................     CE_SEEK_ERROR,                  // File location could not be changed successfully 
....................     CE_BADCACHEREAD,                // Bad cache read 
....................     CE_CARDFAT32,                   // FAT 32 - card not supported 
....................     CE_READONLY,                    // The file is read-only 
....................     CE_WRITEONLY,                   // The file is write-only 
....................     CE_INVALID_ARGUMENT,            // Invalid argument 
....................     CE_TOO_MANY_FILES_OPEN,         // Too many files are already open 
....................     CE_UNSUPPORTED_SECTOR_SIZE,     // Unsupported sector size 
....................     CE_EOF = 61 
.................... } CETYPE; 
....................  
....................  
.................... // Summary: A macro indicating a dir entry was found 
.................... // Description: The FOUND macro indicates that a directory entry was found in the specified position 
.................... #define FOUND       0 
....................  
.................... // Summary: A macro indicating no dir entry was found 
.................... // Description: The NOT_FOUND macro indicates that the specified directory entry to load was deleted 
.................... #define NOT_FOUND   1 
....................  
.................... // Summary: A macro indicating that no more files were found 
.................... // Description: The NO_MORE macro indicates that there are no more directory entries to search for 
.................... #define NO_MORE     2 
....................  
....................  
....................  
.................... // Summary: A macro indicating the device is formatted with FAT12 
.................... // Description: The FAT12 macro is used to indicate that the file system on the device being accessed is a FAT12 file system. 
.................... #define FAT12       1 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT16 
.................... // Description: The FAT16 macro is used to indicate that the file system on the device being accessed is a FAT16 file system. 
.................... #define FAT16       2 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT32 
.................... // Description: The FAT32 macro is used to indicate that the file system on the device being accessed is a FAT32 file system. 
.................... #define FAT32       3 
....................  
....................  
....................  
.................... // Summary: A read-only attribute macro 
.................... // Description: A macro for the read-only attribute.  A file with this attribute should not be written to.  Note that this 
.................... //              attribute will not actually prevent a write to the file; that functionality is operating-system dependant.  The 
.................... //              user should take care not to write to a read-only file. 
.................... #define ATTR_READ_ONLY      0x01 
....................  
.................... // Summary: A hidden attribute macro 
.................... // Description: A macro for the hidden attribute.  A file with this attribute may be hidden from the user, depending on the 
.................... //              implementation of the operating system. 
.................... #define ATTR_HIDDEN         0x02 
....................  
.................... // Summary: A system attribute macro 
.................... // Description: A macro for the system attribute.  A file with this attribute is used by the operating system, and should not be 
.................... //              modified.  Note that this attribute will not actually prevent a write to the file. 
.................... #define ATTR_SYSTEM         0x04 
....................  
.................... // Summary: A volume attribute macro 
.................... // Description: A macro for the volume attribute.  If the first directory entry in the root directory has the volume attribute set, 
.................... //              the device will use the name in that directory entry as the volume name. 
.................... #define ATTR_VOLUME         0x08 
....................  
.................... // Summary: A macro for the attributes for a long-file name entry 
.................... // Description: A macro for the long-name attributes.  If a directory entry is used in a long-file name implementation, it will have 
.................... //              all four lower bits set.  This indicates that any software that does not support long file names should ignore that 
.................... //              entry. 
.................... #define ATTR_LONG_NAME      0x0f 
....................  
.................... // Summary: A directory attribute macro 
.................... // Description: A macro for the directory attribute.  If a directory entry has this attribute set, the file it points to is a directory- 
.................... //              type file, and will contain directory entries that point to additional directories or files. 
.................... #define ATTR_DIRECTORY      0x10 
....................  
.................... // Summary: An archive attribute macro 
.................... // Description: A macro for the archive attribute.  This attribute will indicate to some archiving programs that the file with this 
.................... //              attribute needs to be backed up.  Most operating systems create files with the archive attribute set. 
.................... #define ATTR_ARCHIVE        0x20 
....................  
.................... // Summary: A macro for all attributes 
.................... // Description: A macro for all attributes.  The search functions in this library require an argument that determines which attributes 
.................... //              a file is allowed to have in order to be found.  If ATTR_MASK is specified as this argument, any file may be found, regardless 
.................... //              of its attributes. 
.................... #define ATTR_MASK           0x3f 
....................  
....................  
....................  
.................... // Summary: A macro to indicate an empty FAT entry 
.................... // Description: The CLUSTER_EMPTY value is used to indicate that a FAT entry and it's corresponding cluster are available. 
.................... #define CLUSTER_EMPTY               0x0000  
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT12 
.................... // Description: The LAST_CLUSTER_FAT12 macro is used when reading the FAT to indicate that the next FAT12 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT12          0xff8 
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT16 
.................... // Description: The LAST_CLUSTER_FAT16 macro is used when reading the FAT to indicate that the next FAT16 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT16          0xfff8 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT12 
.................... // Description: The END_CLUSTER_FAT12 value is used as a comparison in FAT12 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT12           0xFF7 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT16 
.................... // Description: The END_CLUSTER_FAT16 value is used as a comparison in FAT16 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT16           0xFFF7 
....................  
.................... // Summary: A macro to indicate the failure of the ReadFAT function 
.................... // Description: The CLUSTER_FAIL_FAT16 macro is used by the ReadFAT function to indicate that an error occured reading a FAT12 or FAT16 
.................... //              file allocation table.  Note that since '0xFFF8' is used for the last cluster return value in the FAT16 implementation 
.................... //              the end-of-file value '0xFFFF' can be used to indicate an error condition. 
.................... #define CLUSTER_FAIL_FAT16          0xFFFF 
....................  
....................  
....................  
.................... #ifdef SUPPORT_FAT32 
....................     // Summary: A macro to indicate the last cluster value for FAT32 
....................     // Description: The LAST_CLUSTER_FAT32 macro is used when reading the FAT to indicate that the next FAT32 entry for a file contains 
....................     //              the end-of-file value. 
....................     #define LAST_CLUSTER_FAT32      0x0FFFFFF8 
....................  
....................     // Summary: A macro to indicate the last allocatable cluster for FAT32 
....................     // Description: The END_CLUSTER_FAT32 value is used as a comparison in FAT32 to determine that the firmware has reached the end of 
....................     //              the range of allowed allocatable clusters. 
....................     #define END_CLUSTER_FAT32       0x0FFFFFF7 
....................  
....................     // Summary: A macro to indicate the failure of the ReadFAT function 
....................     // Description: The CLUSTER_FAIL_FAT32 macro is used by the ReadFAT function to indicate that an error occured reading a FAT32 
....................     //              file allocation able. 
....................     #define CLUSTER_FAIL_FAT32      0x0FFFFFFF 
....................  
.................... #endif 
....................  
.................... // Summary: A macro indicating the number of bytes in a directory entry. 
.................... // Description: The NUMBER_OF_BYTES_IN_DIR_ENTRY macro represents the number of bytes in one directory entry.  It is used to calculate 
.................... //              the number of sectors in the root directory based on information in the boot sector. 
.................... #define NUMBER_OF_BYTES_IN_DIR_ENTRY    32 
....................  
....................  
....................  
.................... // Summary: A macro for a deleted dir entry marker. 
.................... // Description: The DIR_DEL macro is used to mark a directory entry as deleted.  When a file is deleted, this value will replace the 
.................... //              first character in the file name, and will indicate that the file the entry points to was deleted. 
.................... #define DIR_DEL             0xE5 
....................  
.................... // Summary: A macro for the last dir entry marker. 
.................... // Description: The DIR_EMPTY macro is used to indicate the last entry in a directory.  Since entries in use cannot start with a 0 and 
.................... //              deleted entries start with the DIR_DEL character, a 0 will mark the end of the in-use or previously used group of 
.................... //              entries in a directory 
.................... #define DIR_EMPTY           0 
....................  
....................  
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name 
.................... // Description: The DIR_NAMESIZE macro is used when validing the name portion of 8.3 filenames 
.................... #define DIR_NAMESIZE        8 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file extension 
.................... // Description: The DIR_EXTENSION macro is used when validating the extension portion of 8.3 filenames 
.................... #define DIR_EXTENSION       3 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name and extension 
.................... // Description: The DIR_NAMECOMP macro is used when validating 8.3 filenames 
.................... #define DIR_NAMECOMP        (DIR_NAMESIZE+DIR_EXTENSION) 
....................  
....................  
....................  
.................... // Summary: A macro to write a byte to RAM 
.................... // Description: The RAMwrite macro is used to write a byte of data to a RAM array 
.................... #define RAMwrite( a, f, d) *(a+f) = d 
....................  
.................... // Summary: A macro to read a byte from RAM 
.................... // Description: The RAMread macro is used to read a byte of data from a RAM array 
.................... #define RAMread( a, f)  *(a+f) 
....................  
.................... // Summary: A macro to read a 16-bit word from RAM 
.................... // Description: The RAMreadW macro is used to read two bytes of data from a RAM array 
.................... #define RAMreadW( a, f) *(WORD *)(a+f) 
....................  
.................... // Summary: A macro to read a 32-bit word from RAM 
.................... // Description: The RAMreadD macro is used to read four bytes of data from a RAM array 
.................... #define RAMreadD( a, f) *(DWORD *)(a+f) 
....................  
....................  
....................  
.................... #ifndef EOF 
....................     // Summary: Indicates error conditions or end-of-file conditions 
....................     // Description: The EOF macro is used to indicate error conditions in some function calls.  It is also used to indicate 
....................     //              that the end-of-file has been reached. 
....................     #define EOF             ((int)-1) 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing information about the device. 
.................... // Description: The DISK structure contains information about the device being accessed. 
.................... typedef struct 
.................... {  
....................     BYTE    *   buffer;         // Address of the global data buffer used to read and write file information 
....................     DWORD       firsts;         // Logical block address of the first sector of the FAT partition on the device 
....................     DWORD       fat;            // Logical block address of the FAT 
....................     DWORD       root;           // Logical block address of the root directory 
....................     DWORD       data;           // Logical block address of the data section of the device. 
....................     WORD        maxroot;        // The maximum number of entries in the root directory. 
....................     DWORD       maxcls;         // The maximum number of clusters in the partition. 
....................     DWORD       sectorSize;     // The size of a sector in bytes 
....................     DWORD       fatsize;        // The number of sectors in the FAT 
....................     BYTE        fatcopy;        // The number of copies of the FAT in the partition 
....................     BYTE        SecPerClus;     // The number of sectors per cluster in the data region 
....................     BYTE        type;           // The file system type of the partition (FAT12, FAT16 or FAT32) 
....................     BYTE        mount;          // Device mount flag (TRUE if disk was mounted successfully, FALSE otherwise) 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... } __attribute__ ((packed)) DISK; 
.................... #else 
.................... } DISK; 
.................... #endif 
....................  
....................  
.................... #if defined(__18CXX) && !defined(__CCS__) 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef unsigned short long SWORD; 
.................... #else 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef struct 
....................     { 
....................         unsigned char array[3]; 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) SWORD; 
.................... #else 
....................     } SWORD; 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT12 file system (in the boot sector) 
.................... // Description: The _BPB_FAT12 structure provides a layout of the "bios parameter block" in the boot sector of a FAT12 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BPS;               // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD BootSec_ResrvSec;          // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD BootSec_RootDirEnts;       // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD BootSec_SPF;               // Number of sectors per FAT 
....................     WORD BootSec_SPT;               // Number of sectors per track 
....................     WORD BootSec_HeadCnt;           // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD  BootSec_Reserved;        // Reserved space 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved2;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination    
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT12; 
.................... #else 
....................     } _BPB_FAT12; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT16 file system (in the boot sector) 
.................... // Description: The _BPB_FAT16 structure provides a layout of the "bios parameter block" in the boot sector of a FAT16 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD  BootSec_BPS;              // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD  BootSec_ResrvSec;         // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD  BootSec_RootDirEnts;      // Number of root directory entries 
....................     WORD  BootSec_TotSec16;         // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD  BootSec_SPF;              // Number of sectors per FAT 
....................     WORD  BootSec_SPT;              // Number of sectors per track 
....................     WORD  BootSec_HeadCnt;          // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved;         // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination      
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT16; 
.................... #else 
....................     } _BPB_FAT16; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT32 file system (in the boot sector) 
.................... // Description: The _BPB_FAT32 structure provides a layout of the "bios parameter block" in the boot sector of a FAT32 partition. 
.................... typedef struct { 
....................     SWORD BootSec_jmpBoot;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BytsPerSec;        // Number of bytes per sector 
....................     BYTE  BootSec_SecPerClus;       // Number of sectors per cluster 
....................     WORD BootSec_RsvdSecCnt;        // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_NumFATs;          // Number of FATs on the partition 
....................     WORD BootSec_RootEntCnt;        // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_Media;            // Media descriptor 
....................     WORD BootSec_FATSz16;           // Number of sectors per FAT 
....................     WORD BootSec_SecPerTrk;         // Number of sectors per track 
....................     WORD BootSec_NumHeads;          // Number of heads 
....................     DWORD BootSec_HiddSec;          // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     DWORD BootSec_FATSz32;          // Sectors per FAT (32 bits) 
....................     WORD BootSec_ExtFlags;          // Presently active FAT. Defined by bits 0-3 if bit 7 is 1. 
....................     WORD BootSec_FSVers;            // FAT32 filesystem version.  Should be 0:0 
....................     DWORD BootSec_RootClus;         // Start cluster of the root directory (should be 2) 
....................     WORD BootSec_FSInfo;            // File system information 
....................     WORD BootSec_BkBootSec;         // Backup boot sector address. 
....................     BYTE  BootSec_Reserved[12];     // Reserved space 
....................     BYTE  BootSec_DrvNum;           // Drive number 
....................     BYTE  BootSec_Reserved1;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLab[11];       // Volume Label 
....................     BYTE  BootSec_FilSysType[8];    // File system type in ASCII.  Not used for determination   
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT32; 
.................... #else 
....................     } _BPB_FAT32; 
.................... #endif 
....................  
....................  
.................... // Description: A macro for the boot sector bytes per sector value offset 
.................... #define BSI_BPS            11 
....................  
.................... // Description: A macro for the boot sector sector per cluster value offset 
.................... #define BSI_SPC            13 
....................  
.................... // Description: A macro for the boot sector reserved sector count value offset 
.................... #define BSI_RESRVSEC       14 
....................  
.................... // Description: A macro for the boot sector FAT count value offset 
.................... #define BSI_FATCOUNT       16 
....................  
.................... // Description: A macro for the boot sector root directory entry count value offset 
.................... #define BSI_ROOTDIRENTS    17 
....................  
.................... // Description: A macro for the boot sector 16-bit total sector count value offset 
.................... #define BSI_TOTSEC16       19 
....................  
.................... // Description: A macro for the boot sector sectors per FAT value offset 
.................... #define BSI_SPF            22 
....................  
.................... // Description: A macro for the boot sector 32-bit total sector count value offset 
.................... #define BSI_TOTSEC32       32 
....................  
.................... // Description: A macro for the boot sector boot signature offset 
.................... #define BSI_BOOTSIG        38 
....................  
.................... // Description: A macro for the boot sector file system type string offset 
.................... #define BSI_FSTYPE         54 
....................  
.................... // Description: A macro for the boot sector 32-bit sector per FAT value offset 
.................... #define  BSI_FATSZ32       36 
....................  
.................... // Description: A macro for the boot sector start cluster of root directory value offset 
.................... #define  BSI_ROOTCLUS      44 
....................  
.................... // Description: A macro for the FAT32 boot sector boot signature offset 
.................... #define  BSI_FAT32_BOOTSIG 66 
....................  
.................... // Description: A macro for the FAT32 boot sector file system type string offset 
.................... #define  BSI_FAT32_FSTYPE  82 
....................  
....................  
....................  
.................... // Summary: A partition table entry structure. 
.................... // Description: The PTE_MBR structure contains values found in a partition table entry in the MBR of a device. 
.................... typedef struct 
.................... { 
....................     BYTE      PTE_BootDes;            // The boot descriptor (should be 0x00 in a non-bootable device) 
....................     SWORD     PTE_FrstPartSect;       // The cylinder-head-sector address of the first sector of the partition 
....................     BYTE      PTE_FSDesc;             // The file system descriptor 
....................     SWORD     PTE_LstPartSect;        // The cylinder-head-sector address of the last sector of the partition 
....................     DWORD     PTE_FrstSect;           // The logical block address of the first sector of the partition 
....................     DWORD     PTE_NumSect;            // The number of sectors in a partition 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) PTE_MBR; 
.................... #else 
....................     } PTE_MBR; 
.................... #endif 
....................  
....................  
.................... // Summary: A structure of the organization of a master boot record. 
.................... // Description: The _PT_MBR structure has the same form as a master boot record.  When the MBR is loaded from the device, it will 
.................... //              be cast as a _PT_MBR structure so the MBR elements can be accessed. 
.................... typedef struct 
.................... { 
....................     BYTE        ConsChkRtn[446];        // Boot code 
....................     PTE_MBR     Partition0;             // The first partition table entry 
....................     PTE_MBR     Partition1;             // The second partition table entry 
....................     PTE_MBR     Partition2;             // The third partition table entry 
....................     PTE_MBR     Partition3;             // The fourth partition table entry 
....................     BYTE        Signature0;             // MBR signature code - equal to 0x55 
....................     BYTE        Signature1;             // MBR signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... }__attribute__((packed)) _PT_MBR; 
.................... #else 
.................... }_PT_MBR; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _PT_MBR structure 
.................... // Description: The PT_MBR pointer points to a _PT_MBR structure. 
.................... typedef _PT_MBR *  PT_MBR; 
....................  
....................  
....................  
.................... // Summary: A structure of the organization of a boot sector. 
.................... // Description: The _BootSec structure has the same form as a boot sector.  When the boot sector is loaded from the device, it will 
.................... //              be cast as a _BootSec structure so the boot sector elements can be accessed. 
.................... typedef struct 
.................... { 
....................     // A union of different bios parameter blocks 
....................     union 
....................     { 
....................         _BPB_FAT32  FAT_32; 
....................         _BPB_FAT16  FAT_16; 
....................         _BPB_FAT12  FAT_12; 
....................     }FAT; 
....................     BYTE    Reserved[512-sizeof(_BPB_FAT32)-2]; // Reserved space 
....................     BYTE    Signature0;         // Boot sector signature code - equal to 0x55 
....................     BYTE    Signature1;         // Boot sector signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BootSec; 
.................... #else 
....................     } _BootSec; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _BootSec structure 
.................... // Description: The BootSec pointer points to a _BootSec structure. 
.................... typedef _BootSec * BootSec; 
....................  
....................  
....................  
.................... // Summary: A macro indicating the offset for the master boot record 
.................... // Description: FO_MBR is a macro that indicates the addresss of the master boot record on the device.  When the device is initialized 
.................... //              this sector will be read 
.................... #define FO_MBR          0L 
....................  
....................  
....................  
.................... // Summary: A macro for the first boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_0 macro is used to determine that the first byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_0     0x55 
....................  
.................... // Summary: A macro for the second boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_1 macro is used to determine that the second byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_1     0xAA 
....................  
....................  
.................... typedef struct  
.................... { 
....................     BYTE    errorCode; 
....................     union  
....................     { 
....................         BYTE    value; 
....................         struct  
....................         { 
....................             BYTE    sectorSize  : 1; 
....................             BYTE    maxLUN      : 1; 
....................         }   bits; 
....................     } validityFlags; 
....................      
....................     WORD    sectorSize; 
....................     BYTE    maxLUN; 
.................... } MEDIA_INFORMATION; 
....................  
.................... typedef enum 
.................... { 
....................     MEDIA_NO_ERROR,                     // No errors 
....................     MEDIA_DEVICE_NOT_PRESENT,           // The requested device is not present 
....................     MEDIA_CANNOT_INITIALIZE             // Cannot initialize media 
.................... } MEDIA_ERRORS;                 
....................  
....................  
.................... #endif 
....................  
.................... #include "stddef.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... #ifdef USE_SD_INTERFACE_WITH_SPI 
....................     #include    "SD-SPI.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        SD-SPI.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  *                  FSconfig.h 
....................  *                  FSDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the "Company") for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef SDMMC_H 
.................... #define SDMMC_H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "../FSconfig.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSconfig.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Dependencies:    None 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _FS_DEF_ 
.................... #define _FS_DEF_ 
....................  
.................... //#include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // something to do with long filenames. 
.................... //#define SUPPORT_LFN 
....................  
.................... // Summary: A macro indicating the maximum number of concurrently open files 
.................... // Description: The FS_MAX_FILES_OPEN #define is only applicable when dynamic memory allocation is not used (FS_DYNAMIC_MEM is not defined). 
.................... //              This macro defines the maximum number of open files at any given time.  The amount of RAM used by FSFILE objects will 
.................... //              be equal to the size of an FSFILE object multipled by this macro value.  This value should be kept as small as possible 
.................... //              as dictated by the application.  This will reduce memory usage. 
.................... #define FS_MAX_FILES_OPEN    1 
....................  
....................  
.................... // if defined, MDD will be configured to use SST25 flash device. this definition 
.................... // should also define the size of the SST25 flash device. 
.................... // if not defined, will use SD card. 
.................... // #define  USE_SST25_INTERFACE  ((unsigned int32)2*1024*1024) 
....................  
.................... // Summary: A macro defining the size of a sector 
.................... // Description: The MEDIA_SECTOR_SIZE macro will define the size of a sector on the FAT file system.  This value must equal 512 bytes, 
.................... //              1024 bytes, 2048 bytes, or 4096 bytes.  The value of a sector will usually be 512 bytes. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define MEDIA_SECTOR_SIZE       4096   //erase size of SST25 flash device 
.................... #else 
.................... #define MEDIA_SECTOR_SIZE       512 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* *******************************************************************************************************/ 
.................... /************** Compiler options to enable/Disable Features based on user's application ******************/ 
.................... /* *******************************************************************************************************/ 
....................  
....................  
.................... // Summary: A macro to enable/disable file search functions. 
.................... // Description: The ALLOW_FILESEARCH definition can be commented out to disable file search functions in the library.  This will 
.................... //              prevent the use of the FindFirst and FindNext functions and reduce code size. 
.................... #define ALLOW_FILESEARCH 
....................  
.................... // Summary: A macro to enable/disable write functionality 
.................... // Description: The ALLOW_WRITES definition can be commented out to disable all operations that write to the device.  This will 
.................... //              greatly reduce code size. 
.................... #define ALLOW_WRITES 
....................  
....................  
.................... // Summary: A macro to enable/disable format functionality 
.................... // Description: The ALLOW_FORMATS definition can be commented out to disable formatting functionality.  This will prevent the use of 
.................... //              the FSformat function.  If formats are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define ALLOW_FORMATS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable directory operations. 
.................... // Description: The ALLOW_DIRS definition can be commented out to disable all directory functionality.  This will reduce code size. 
.................... //              If directories are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES in order to use 
.................... //              the FSmkdir or FSrmdir functions. 
.................... #define ALLOW_DIRS 
....................  
.................... // Summary: A macro to enable/disable PIC18 ROM functions. 
.................... // Description: The ALLOW_PGMFUNCTIONS definition can be commented out to disable all PIC18 functions that allow the user to pass string 
.................... //              arguments in ROM (denoted by the suffix -pgm).  Note that this functionality must be disabled when not using PIC18. 
.................... #if !defined(__CCS__) 
.................... #define ALLOW_PGMFUNCTIONS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable the FSfprintf function. 
.................... // Description: The ALLOW_FSFPRINTF definition can be commented out to disable the FSfprintf function.  This will save code space.  Note that 
.................... //              if FSfprintf is enabled and the PIC18 architecture is used, integer promotions must be enabled in the Project->Build Options 
.................... //              menu.  Write operations must be enabled to use FSfprintf. 
.................... //#define ALLOW_FSFPRINTF 
....................  
.................... // CCS added this config option to disable FAT12 to prevent recursion. 
.................... //__CCS__ added by ccs 
.................... //#define SUPPORT_FAT12 
....................  
.................... // Summary: A macro to enable/disable FAT32 support. 
.................... // Description: The SUPPORT_FAT32 definition can be commented out to disable support for FAT32 functionality.  This will save a small amount 
.................... //              of code space. 
.................... #define SUPPORT_FAT32 
....................  
....................  
....................  
.................... /**************************************************************************************************/ 
.................... // Select a method for updating file timestamps 
.................... /**************************************************************************************************/ 
....................  
.................... // Summary: A macro to enable RTCC based timestamp generation 
.................... // Description: The USEREALTIMECLOCK macro will configure the code to automatically 
.................... //              generate timestamp information for files from the RTCC module. The user 
.................... //              must enable and configure the RTCC module before creating or modifying 
.................... //              files.                                                                  
.................... //#define USEREALTIMECLOCK 
....................  
.................... // Summary: A macro to enable manual timestamp generation 
.................... // Description: The USERDEFINEDCLOCK macro will allow the user to manually set 
.................... //              timestamp information using the SetClockVars function. The user will 
.................... //              need to set the time variables immediately before creating or closing a 
.................... //              file or directory.                                                     
.................... #define USERDEFINEDCLOCK 
....................  
.................... // Summary: A macro to enable don't-care timestamp generation 
.................... // Description: The INCREMENTTIMESTAMP macro will set the create time of a file to a 
.................... //              static value and increment it when a file is updated. This timestamp 
.................... //              generation method should only be used in applications where file times 
.................... //              are not necessary.                                                     
.................... //#define INCREMENTTIMESTAMP 
....................  
....................  
.................... #ifdef __18CXX 
....................    #ifdef USEREALTIMECLOCK 
....................       #error Not all PIC18 devices have a Real-time clock and calander module 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    #ifndef __18CXX 
....................       #error The pgm functions are unneccessary when not using PIC18 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef USEREALTIMECLOCK 
....................     #ifndef USERDEFINEDCLOCK 
....................         #ifndef INCREMENTTIMESTAMP 
....................             #error Please enable USEREALTIMECLOCK, USERDEFINEDCLOCK, or INCREMENTTIMESTAMP 
....................         #endif 
....................     #endif 
.................... #endif 
....................  
.................... /************************************************************************/ 
.................... // Set this preprocessor option to '1' to use dynamic FSFILE object allocation.  It will 
.................... // be necessary to allocate a heap when dynamically allocating FSFILE objects. 
.................... // Set this option to '0' to use static FSFILE object allocation. 
.................... /************************************************************************/ 
....................  
.................... //#if 1  //from mirochip 
.................... #if defined(__PCH__) //__CCS__ 
....................     // Summary: A macro indicating that FSFILE objects will be allocated dynamically 
....................     // Description: The FS_DYNAMIC_MEM macro will cause FSFILE objects to be allocated from a dynamic heap.  If it is undefined, 
....................     //              the file objects will be allocated using a static array. 
....................    //#define FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................         // Description: Function pointer to a dynamic memory allocation function 
....................       #define FS_malloc   SRAMalloc 
....................         // Description: Function pointer to a dynamic memory free function 
....................       #define FS_free      SRAMfree 
....................    #else 
....................       #define FS_malloc   malloc 
....................       #define FS_free      free 
....................    #endif 
.................... #elif defined(__CCS__) 
....................    #error/warning Not using FS_DYNAMIC_MEM for PCD compiler 
.................... #endif 
....................  
....................  
.................... #ifdef __18CXX 
....................     /* Define the locations for the dataBuffer and FATbuffer; PLEASE CHECK THE LINKER FILE */ 
....................     #define DATA_BUFFER_ADDRESS      0x700 
....................     #define FAT_BUFFER_ADDRESS       0x900 
.................... #endif 
....................  
....................  
.................... // Function definitions 
.................... // Associate the physical layer functions with the correct physical layer 
.................... #ifdef USE_SD_INTERFACE_WITH_SPI       // SD-SPI.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_SDSPI_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_SDSPI_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_SDSPI_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_SDSPI_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_SDSPI_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_SDSPI_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_SDSPI_WriteProtectState 
....................  
....................     // Description: Function pointer to the Read Capacity Physical Layer function 
....................     #define MDD_ReadCapacity        MDD_SDSPI_ReadCapacity 
....................  
....................     // Description: Function pointer to the Read Sector Size Physical Layer Function 
....................     #define MDD_ReadSectorSize      MDD_SDSPI_ReadSectorSize 
....................  
.................... #elif defined USE_CF_INTERFACE_WITH_PMP       // CF-PMP.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFPMP_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFPMP_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFPMP_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFPMP_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFPMP_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFPMP_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFPMP_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFPMP_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFPMP_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFPMP_CFread 
....................  
.................... #elif defined USE_MANUAL_CF_INTERFACE         // CF-Bit transaction.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFBT_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFBT_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFBT_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFBT_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFBT_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFBT_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFBT_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFBT_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFBT_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFBT_CFread 
....................  
.................... #elif defined USE_USB_INTERFACE               // USB host MSD library 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     USBHostMSDSCSIMediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         USBHostMSDSCSIMediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          USBHostMSDSCSISectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         USBHostMSDSCSISectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO();               
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       USBHostMSDSCSIMediaReset 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   USBHostMSDSCSIWriteProtectState 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "FSDefs.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSDefs.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.2.4 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  _FSDEF__H 
.................... #define  _FSDEF__H 
....................  
.................... #include "../GenericTypeDefs.h" 
....................  
.................... // Summary: An enumeration used for various error codes. 
.................... // Description: The CETYPE enumeration is used to indicate different error conditions during device operation. 
.................... typedef enum _CETYPE 
.................... { 
....................     CE_GOOD = 0,                    // No error 
....................     CE_ERASE_FAIL,                  // An erase failed 
....................     CE_NOT_PRESENT,                 // No device was present 
....................     CE_NOT_FORMATTED,               // The disk is of an unsupported format 
....................     CE_BAD_PARTITION,               // The boot record is bad 
....................     CE_UNSUPPORTED_FS,              // The file system type is unsupported 
....................     CE_INIT_ERROR,                  // An initialization error has occured 
....................     CE_NOT_INIT,                    // An operation was performed on an uninitialized device 
....................     CE_BAD_SECTOR_READ,             // A bad read of a sector occured 
....................     CE_WRITE_ERROR,                 // Could not write to a sector 
....................     CE_INVALID_CLUSTER,             // Invalid cluster value > maxcls 
....................     CE_FILE_NOT_FOUND,              // Could not find the file on the device 
....................     CE_DIR_NOT_FOUND,               // Could not find the directory 
....................     CE_BAD_FILE,                    // File is corrupted 
....................     CE_DONE,                        // No more files in this directory 
....................     CE_COULD_NOT_GET_CLUSTER,       // Could not load/allocate next cluster in file 
....................     CE_FILENAME_2_LONG,             // A specified file name is too long to use 
....................     CE_FILENAME_EXISTS,             // A specified filename already exists on the device 
....................     CE_INVALID_FILENAME,            // Invalid file name 
....................     CE_DELETE_DIR,                  // The user tried to delete a directory with FSremove 
....................     CE_DIR_FULL,                    // All root dir entry are taken 
....................     CE_DISK_FULL,                   // All clusters in partition are taken 
....................     CE_DIR_NOT_EMPTY,               // This directory is not empty yet, remove files before deleting 
....................     CE_NONSUPPORTED_SIZE,           // The disk is too big to format as FAT16 
....................     CE_WRITE_PROTECTED,             // Card is write protected 
....................     CE_FILENOTOPENED,               // File not opened for the write 
....................     CE_SEEK_ERROR,                  // File location could not be changed successfully 
....................     CE_BADCACHEREAD,                // Bad cache read 
....................     CE_CARDFAT32,                   // FAT 32 - card not supported 
....................     CE_READONLY,                    // The file is read-only 
....................     CE_WRITEONLY,                   // The file is write-only 
....................     CE_INVALID_ARGUMENT,            // Invalid argument 
....................     CE_TOO_MANY_FILES_OPEN,         // Too many files are already open 
....................     CE_UNSUPPORTED_SECTOR_SIZE,     // Unsupported sector size 
....................     CE_EOF = 61 
.................... } CETYPE; 
....................  
....................  
.................... // Summary: A macro indicating a dir entry was found 
.................... // Description: The FOUND macro indicates that a directory entry was found in the specified position 
.................... #define FOUND       0 
....................  
.................... // Summary: A macro indicating no dir entry was found 
.................... // Description: The NOT_FOUND macro indicates that the specified directory entry to load was deleted 
.................... #define NOT_FOUND   1 
....................  
.................... // Summary: A macro indicating that no more files were found 
.................... // Description: The NO_MORE macro indicates that there are no more directory entries to search for 
.................... #define NO_MORE     2 
....................  
....................  
....................  
.................... // Summary: A macro indicating the device is formatted with FAT12 
.................... // Description: The FAT12 macro is used to indicate that the file system on the device being accessed is a FAT12 file system. 
.................... #define FAT12       1 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT16 
.................... // Description: The FAT16 macro is used to indicate that the file system on the device being accessed is a FAT16 file system. 
.................... #define FAT16       2 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT32 
.................... // Description: The FAT32 macro is used to indicate that the file system on the device being accessed is a FAT32 file system. 
.................... #define FAT32       3 
....................  
....................  
....................  
.................... // Summary: A read-only attribute macro 
.................... // Description: A macro for the read-only attribute.  A file with this attribute should not be written to.  Note that this 
.................... //              attribute will not actually prevent a write to the file; that functionality is operating-system dependant.  The 
.................... //              user should take care not to write to a read-only file. 
.................... #define ATTR_READ_ONLY      0x01 
....................  
.................... // Summary: A hidden attribute macro 
.................... // Description: A macro for the hidden attribute.  A file with this attribute may be hidden from the user, depending on the 
.................... //              implementation of the operating system. 
.................... #define ATTR_HIDDEN         0x02 
....................  
.................... // Summary: A system attribute macro 
.................... // Description: A macro for the system attribute.  A file with this attribute is used by the operating system, and should not be 
.................... //              modified.  Note that this attribute will not actually prevent a write to the file. 
.................... #define ATTR_SYSTEM         0x04 
....................  
.................... // Summary: A volume attribute macro 
.................... // Description: A macro for the volume attribute.  If the first directory entry in the root directory has the volume attribute set, 
.................... //              the device will use the name in that directory entry as the volume name. 
.................... #define ATTR_VOLUME         0x08 
....................  
.................... // Summary: A macro for the attributes for a long-file name entry 
.................... // Description: A macro for the long-name attributes.  If a directory entry is used in a long-file name implementation, it will have 
.................... //              all four lower bits set.  This indicates that any software that does not support long file names should ignore that 
.................... //              entry. 
.................... #define ATTR_LONG_NAME      0x0f 
....................  
.................... // Summary: A directory attribute macro 
.................... // Description: A macro for the directory attribute.  If a directory entry has this attribute set, the file it points to is a directory- 
.................... //              type file, and will contain directory entries that point to additional directories or files. 
.................... #define ATTR_DIRECTORY      0x10 
....................  
.................... // Summary: An archive attribute macro 
.................... // Description: A macro for the archive attribute.  This attribute will indicate to some archiving programs that the file with this 
.................... //              attribute needs to be backed up.  Most operating systems create files with the archive attribute set. 
.................... #define ATTR_ARCHIVE        0x20 
....................  
.................... // Summary: A macro for all attributes 
.................... // Description: A macro for all attributes.  The search functions in this library require an argument that determines which attributes 
.................... //              a file is allowed to have in order to be found.  If ATTR_MASK is specified as this argument, any file may be found, regardless 
.................... //              of its attributes. 
.................... #define ATTR_MASK           0x3f 
....................  
....................  
....................  
.................... // Summary: A macro to indicate an empty FAT entry 
.................... // Description: The CLUSTER_EMPTY value is used to indicate that a FAT entry and it's corresponding cluster are available. 
.................... #define CLUSTER_EMPTY               0x0000  
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT12 
.................... // Description: The LAST_CLUSTER_FAT12 macro is used when reading the FAT to indicate that the next FAT12 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT12          0xff8 
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT16 
.................... // Description: The LAST_CLUSTER_FAT16 macro is used when reading the FAT to indicate that the next FAT16 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT16          0xfff8 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT12 
.................... // Description: The END_CLUSTER_FAT12 value is used as a comparison in FAT12 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT12           0xFF7 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT16 
.................... // Description: The END_CLUSTER_FAT16 value is used as a comparison in FAT16 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT16           0xFFF7 
....................  
.................... // Summary: A macro to indicate the failure of the ReadFAT function 
.................... // Description: The CLUSTER_FAIL_FAT16 macro is used by the ReadFAT function to indicate that an error occured reading a FAT12 or FAT16 
.................... //              file allocation table.  Note that since '0xFFF8' is used for the last cluster return value in the FAT16 implementation 
.................... //              the end-of-file value '0xFFFF' can be used to indicate an error condition. 
.................... #define CLUSTER_FAIL_FAT16          0xFFFF 
....................  
....................  
....................  
.................... #ifdef SUPPORT_FAT32 
....................     // Summary: A macro to indicate the last cluster value for FAT32 
....................     // Description: The LAST_CLUSTER_FAT32 macro is used when reading the FAT to indicate that the next FAT32 entry for a file contains 
....................     //              the end-of-file value. 
....................     #define LAST_CLUSTER_FAT32      0x0FFFFFF8 
....................  
....................     // Summary: A macro to indicate the last allocatable cluster for FAT32 
....................     // Description: The END_CLUSTER_FAT32 value is used as a comparison in FAT32 to determine that the firmware has reached the end of 
....................     //              the range of allowed allocatable clusters. 
....................     #define END_CLUSTER_FAT32       0x0FFFFFF7 
....................  
....................     // Summary: A macro to indicate the failure of the ReadFAT function 
....................     // Description: The CLUSTER_FAIL_FAT32 macro is used by the ReadFAT function to indicate that an error occured reading a FAT32 
....................     //              file allocation able. 
....................     #define CLUSTER_FAIL_FAT32      0x0FFFFFFF 
....................  
.................... #endif 
....................  
.................... // Summary: A macro indicating the number of bytes in a directory entry. 
.................... // Description: The NUMBER_OF_BYTES_IN_DIR_ENTRY macro represents the number of bytes in one directory entry.  It is used to calculate 
.................... //              the number of sectors in the root directory based on information in the boot sector. 
.................... #define NUMBER_OF_BYTES_IN_DIR_ENTRY    32 
....................  
....................  
....................  
.................... // Summary: A macro for a deleted dir entry marker. 
.................... // Description: The DIR_DEL macro is used to mark a directory entry as deleted.  When a file is deleted, this value will replace the 
.................... //              first character in the file name, and will indicate that the file the entry points to was deleted. 
.................... #define DIR_DEL             0xE5 
....................  
.................... // Summary: A macro for the last dir entry marker. 
.................... // Description: The DIR_EMPTY macro is used to indicate the last entry in a directory.  Since entries in use cannot start with a 0 and 
.................... //              deleted entries start with the DIR_DEL character, a 0 will mark the end of the in-use or previously used group of 
.................... //              entries in a directory 
.................... #define DIR_EMPTY           0 
....................  
....................  
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name 
.................... // Description: The DIR_NAMESIZE macro is used when validing the name portion of 8.3 filenames 
.................... #define DIR_NAMESIZE        8 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file extension 
.................... // Description: The DIR_EXTENSION macro is used when validating the extension portion of 8.3 filenames 
.................... #define DIR_EXTENSION       3 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name and extension 
.................... // Description: The DIR_NAMECOMP macro is used when validating 8.3 filenames 
.................... #define DIR_NAMECOMP        (DIR_NAMESIZE+DIR_EXTENSION) 
....................  
....................  
....................  
.................... // Summary: A macro to write a byte to RAM 
.................... // Description: The RAMwrite macro is used to write a byte of data to a RAM array 
.................... #define RAMwrite( a, f, d) *(a+f) = d 
....................  
.................... // Summary: A macro to read a byte from RAM 
.................... // Description: The RAMread macro is used to read a byte of data from a RAM array 
.................... #define RAMread( a, f)  *(a+f) 
....................  
.................... // Summary: A macro to read a 16-bit word from RAM 
.................... // Description: The RAMreadW macro is used to read two bytes of data from a RAM array 
.................... #define RAMreadW( a, f) *(WORD *)(a+f) 
....................  
.................... // Summary: A macro to read a 32-bit word from RAM 
.................... // Description: The RAMreadD macro is used to read four bytes of data from a RAM array 
.................... #define RAMreadD( a, f) *(DWORD *)(a+f) 
....................  
....................  
....................  
.................... #ifndef EOF 
....................     // Summary: Indicates error conditions or end-of-file conditions 
....................     // Description: The EOF macro is used to indicate error conditions in some function calls.  It is also used to indicate 
....................     //              that the end-of-file has been reached. 
....................     #define EOF             ((int)-1) 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing information about the device. 
.................... // Description: The DISK structure contains information about the device being accessed. 
.................... typedef struct 
.................... {  
....................     BYTE    *   buffer;         // Address of the global data buffer used to read and write file information 
....................     DWORD       firsts;         // Logical block address of the first sector of the FAT partition on the device 
....................     DWORD       fat;            // Logical block address of the FAT 
....................     DWORD       root;           // Logical block address of the root directory 
....................     DWORD       data;           // Logical block address of the data section of the device. 
....................     WORD        maxroot;        // The maximum number of entries in the root directory. 
....................     DWORD       maxcls;         // The maximum number of clusters in the partition. 
....................     DWORD       sectorSize;     // The size of a sector in bytes 
....................     DWORD       fatsize;        // The number of sectors in the FAT 
....................     BYTE        fatcopy;        // The number of copies of the FAT in the partition 
....................     BYTE        SecPerClus;     // The number of sectors per cluster in the data region 
....................     BYTE        type;           // The file system type of the partition (FAT12, FAT16 or FAT32) 
....................     BYTE        mount;          // Device mount flag (TRUE if disk was mounted successfully, FALSE otherwise) 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... } __attribute__ ((packed)) DISK; 
.................... #else 
.................... } DISK; 
.................... #endif 
....................  
....................  
.................... #if defined(__18CXX) && !defined(__CCS__) 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef unsigned short long SWORD; 
.................... #else 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef struct 
....................     { 
....................         unsigned char array[3]; 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) SWORD; 
.................... #else 
....................     } SWORD; 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT12 file system (in the boot sector) 
.................... // Description: The _BPB_FAT12 structure provides a layout of the "bios parameter block" in the boot sector of a FAT12 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BPS;               // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD BootSec_ResrvSec;          // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD BootSec_RootDirEnts;       // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD BootSec_SPF;               // Number of sectors per FAT 
....................     WORD BootSec_SPT;               // Number of sectors per track 
....................     WORD BootSec_HeadCnt;           // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD  BootSec_Reserved;        // Reserved space 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved2;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination    
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT12; 
.................... #else 
....................     } _BPB_FAT12; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT16 file system (in the boot sector) 
.................... // Description: The _BPB_FAT16 structure provides a layout of the "bios parameter block" in the boot sector of a FAT16 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD  BootSec_BPS;              // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD  BootSec_ResrvSec;         // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD  BootSec_RootDirEnts;      // Number of root directory entries 
....................     WORD  BootSec_TotSec16;         // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD  BootSec_SPF;              // Number of sectors per FAT 
....................     WORD  BootSec_SPT;              // Number of sectors per track 
....................     WORD  BootSec_HeadCnt;          // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved;         // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination      
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT16; 
.................... #else 
....................     } _BPB_FAT16; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT32 file system (in the boot sector) 
.................... // Description: The _BPB_FAT32 structure provides a layout of the "bios parameter block" in the boot sector of a FAT32 partition. 
.................... typedef struct { 
....................     SWORD BootSec_jmpBoot;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BytsPerSec;        // Number of bytes per sector 
....................     BYTE  BootSec_SecPerClus;       // Number of sectors per cluster 
....................     WORD BootSec_RsvdSecCnt;        // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_NumFATs;          // Number of FATs on the partition 
....................     WORD BootSec_RootEntCnt;        // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_Media;            // Media descriptor 
....................     WORD BootSec_FATSz16;           // Number of sectors per FAT 
....................     WORD BootSec_SecPerTrk;         // Number of sectors per track 
....................     WORD BootSec_NumHeads;          // Number of heads 
....................     DWORD BootSec_HiddSec;          // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     DWORD BootSec_FATSz32;          // Sectors per FAT (32 bits) 
....................     WORD BootSec_ExtFlags;          // Presently active FAT. Defined by bits 0-3 if bit 7 is 1. 
....................     WORD BootSec_FSVers;            // FAT32 filesystem version.  Should be 0:0 
....................     DWORD BootSec_RootClus;         // Start cluster of the root directory (should be 2) 
....................     WORD BootSec_FSInfo;            // File system information 
....................     WORD BootSec_BkBootSec;         // Backup boot sector address. 
....................     BYTE  BootSec_Reserved[12];     // Reserved space 
....................     BYTE  BootSec_DrvNum;           // Drive number 
....................     BYTE  BootSec_Reserved1;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLab[11];       // Volume Label 
....................     BYTE  BootSec_FilSysType[8];    // File system type in ASCII.  Not used for determination   
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT32; 
.................... #else 
....................     } _BPB_FAT32; 
.................... #endif 
....................  
....................  
.................... // Description: A macro for the boot sector bytes per sector value offset 
.................... #define BSI_BPS            11 
....................  
.................... // Description: A macro for the boot sector sector per cluster value offset 
.................... #define BSI_SPC            13 
....................  
.................... // Description: A macro for the boot sector reserved sector count value offset 
.................... #define BSI_RESRVSEC       14 
....................  
.................... // Description: A macro for the boot sector FAT count value offset 
.................... #define BSI_FATCOUNT       16 
....................  
.................... // Description: A macro for the boot sector root directory entry count value offset 
.................... #define BSI_ROOTDIRENTS    17 
....................  
.................... // Description: A macro for the boot sector 16-bit total sector count value offset 
.................... #define BSI_TOTSEC16       19 
....................  
.................... // Description: A macro for the boot sector sectors per FAT value offset 
.................... #define BSI_SPF            22 
....................  
.................... // Description: A macro for the boot sector 32-bit total sector count value offset 
.................... #define BSI_TOTSEC32       32 
....................  
.................... // Description: A macro for the boot sector boot signature offset 
.................... #define BSI_BOOTSIG        38 
....................  
.................... // Description: A macro for the boot sector file system type string offset 
.................... #define BSI_FSTYPE         54 
....................  
.................... // Description: A macro for the boot sector 32-bit sector per FAT value offset 
.................... #define  BSI_FATSZ32       36 
....................  
.................... // Description: A macro for the boot sector start cluster of root directory value offset 
.................... #define  BSI_ROOTCLUS      44 
....................  
.................... // Description: A macro for the FAT32 boot sector boot signature offset 
.................... #define  BSI_FAT32_BOOTSIG 66 
....................  
.................... // Description: A macro for the FAT32 boot sector file system type string offset 
.................... #define  BSI_FAT32_FSTYPE  82 
....................  
....................  
....................  
.................... // Summary: A partition table entry structure. 
.................... // Description: The PTE_MBR structure contains values found in a partition table entry in the MBR of a device. 
.................... typedef struct 
.................... { 
....................     BYTE      PTE_BootDes;            // The boot descriptor (should be 0x00 in a non-bootable device) 
....................     SWORD     PTE_FrstPartSect;       // The cylinder-head-sector address of the first sector of the partition 
....................     BYTE      PTE_FSDesc;             // The file system descriptor 
....................     SWORD     PTE_LstPartSect;        // The cylinder-head-sector address of the last sector of the partition 
....................     DWORD     PTE_FrstSect;           // The logical block address of the first sector of the partition 
....................     DWORD     PTE_NumSect;            // The number of sectors in a partition 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) PTE_MBR; 
.................... #else 
....................     } PTE_MBR; 
.................... #endif 
....................  
....................  
.................... // Summary: A structure of the organization of a master boot record. 
.................... // Description: The _PT_MBR structure has the same form as a master boot record.  When the MBR is loaded from the device, it will 
.................... //              be cast as a _PT_MBR structure so the MBR elements can be accessed. 
.................... typedef struct 
.................... { 
....................     BYTE        ConsChkRtn[446];        // Boot code 
....................     PTE_MBR     Partition0;             // The first partition table entry 
....................     PTE_MBR     Partition1;             // The second partition table entry 
....................     PTE_MBR     Partition2;             // The third partition table entry 
....................     PTE_MBR     Partition3;             // The fourth partition table entry 
....................     BYTE        Signature0;             // MBR signature code - equal to 0x55 
....................     BYTE        Signature1;             // MBR signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... }__attribute__((packed)) _PT_MBR; 
.................... #else 
.................... }_PT_MBR; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _PT_MBR structure 
.................... // Description: The PT_MBR pointer points to a _PT_MBR structure. 
.................... typedef _PT_MBR *  PT_MBR; 
....................  
....................  
....................  
.................... // Summary: A structure of the organization of a boot sector. 
.................... // Description: The _BootSec structure has the same form as a boot sector.  When the boot sector is loaded from the device, it will 
.................... //              be cast as a _BootSec structure so the boot sector elements can be accessed. 
.................... typedef struct 
.................... { 
....................     // A union of different bios parameter blocks 
....................     union 
....................     { 
....................         _BPB_FAT32  FAT_32; 
....................         _BPB_FAT16  FAT_16; 
....................         _BPB_FAT12  FAT_12; 
....................     }FAT; 
....................     BYTE    Reserved[512-sizeof(_BPB_FAT32)-2]; // Reserved space 
....................     BYTE    Signature0;         // Boot sector signature code - equal to 0x55 
....................     BYTE    Signature1;         // Boot sector signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BootSec; 
.................... #else 
....................     } _BootSec; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _BootSec structure 
.................... // Description: The BootSec pointer points to a _BootSec structure. 
.................... typedef _BootSec * BootSec; 
....................  
....................  
....................  
.................... // Summary: A macro indicating the offset for the master boot record 
.................... // Description: FO_MBR is a macro that indicates the addresss of the master boot record on the device.  When the device is initialized 
.................... //              this sector will be read 
.................... #define FO_MBR          0L 
....................  
....................  
....................  
.................... // Summary: A macro for the first boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_0 macro is used to determine that the first byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_0     0x55 
....................  
.................... // Summary: A macro for the second boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_1 macro is used to determine that the second byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_1     0xAA 
....................  
....................  
.................... typedef struct  
.................... { 
....................     BYTE    errorCode; 
....................     union  
....................     { 
....................         BYTE    value; 
....................         struct  
....................         { 
....................             BYTE    sectorSize  : 1; 
....................             BYTE    maxLUN      : 1; 
....................         }   bits; 
....................     } validityFlags; 
....................      
....................     WORD    sectorSize; 
....................     BYTE    maxLUN; 
.................... } MEDIA_INFORMATION; 
....................  
.................... typedef enum 
.................... { 
....................     MEDIA_NO_ERROR,                     // No errors 
....................     MEDIA_DEVICE_NOT_PRESENT,           // The requested device is not present 
....................     MEDIA_CANNOT_INITIALIZE             // Cannot initialize media 
.................... } MEDIA_ERRORS;                 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #ifdef __18CXX 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 4x prescale divider 
....................     #define   SYNC_MODE_FAST    0x00 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 16x prescale divider 
....................     #define   SYNC_MODE_MED     0x01 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 64x prescale divider 
....................     #define   SYNC_MODE_SLOW    0x02 
.................... #elif defined __PIC32MX__ 
....................     // Description: This macro is used to initialize a PIC32 SPI module 
....................     #define   SYNC_MODE_FAST    0x3E 
....................     // Description: This macro is used to initialize a PIC32 SPI module 
....................     #define   SYNC_MODE_SLOW    0x3C 
.................... #else 
....................     // Description: This macro indicates the SPI enable bit for 16-bit PICs 
....................     #ifndef MASTER_ENABLE_ON 
....................         #define  MASTER_ENABLE_ON       0x0020 
....................     #endif 
....................  
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module 
....................     #ifndef SYNC_MODE_FAST 
....................         #define   SYNC_MODE_FAST    0x3E 
....................     #endif 
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module 
....................     #ifndef SYNC_MODE_SLOW 
....................         #define   SYNC_MODE_SLOW    0x3C 
....................     #endif 
....................  
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module secondary prescaler 
....................     #ifndef SEC_PRESCAL_1_1 
....................         #define  SEC_PRESCAL_1_1        0x001c 
....................     #endif 
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module primary prescaler 
....................     #ifndef PRI_PRESCAL_1_1 
....................         #define  PRI_PRESCAL_1_1        0x0003 
....................     #endif 
.................... #endif 
....................  
....................  
....................  
.................... /*****************************************************************/ 
.................... /*                  Strcutures and defines                       */ 
.................... /*****************************************************************/ 
....................  
....................  
.................... // Description: This macro represents an SD card start single data block token (used for single block writes) 
.................... #define DATA_START_TOKEN            0xFE 
....................  
.................... // Description: This macro represents an SD card start multi-block data token (used for multi-block writes) 
.................... #define DATA_START_MULTI_BLOCK_TOKEN    0xFC 
....................  
.................... // Description: This macro represents an SD card stop transmission token.  This is used when finishing a multi block write sequence. 
.................... #define DATA_STOP_TRAN_TOKEN        0xFD 
....................  
.................... // Description: This macro represents an SD card data accepted token 
.................... #define DATA_ACCEPTED               0x05 
....................  
.................... // Description: This macro indicates that the SD card expects to transmit or receive more data 
.................... #define MOREDATA    !0 
....................  
.................... // Description: This macro indicates that the SD card does not expect to transmit or receive more data 
.................... #define NODATA      0 
....................  
.................... // Description: This macro represents a floating SPI bus condition 
.................... #define MMC_FLOATING_BUS    0xFF 
....................  
.................... // Description: This macro represents a bad SD card response byte 
.................... #define MMC_BAD_RESPONSE    MMC_FLOATING_BUS 
....................  
.................... // The SDMMC Commands 
....................  
.................... // Description: This macro defines the command code to reset the SD card 
.................... #define     cmdGO_IDLE_STATE        0 
.................... // Description: This macro defines the command code to initialize the SD card 
.................... #define     cmdSEND_OP_COND         1         
.................... // Description: This macro defined the command code to check for sector addressing 
.................... #define     cmdSEND_IF_COND         8 
.................... // Description: This macro defines the command code to get the Card Specific Data 
.................... #define     cmdSEND_CSD             9 
.................... // Description: This macro defines the command code to get the Card Information 
.................... #define     cmdSEND_CID             10 
.................... // Description: This macro defines the command code to stop transmission during a multi-block read 
.................... #define     cmdSTOP_TRANSMISSION    12 
.................... // Description: This macro defines the command code to get the card status information 
.................... #define     cmdSEND_STATUS          13 
.................... // Description: This macro defines the command code to set the block length of the card 
.................... #define     cmdSET_BLOCKLEN         16 
.................... // Description: This macro defines the command code to read one block from the card 
.................... #define     cmdREAD_SINGLE_BLOCK    17 
.................... // Description: This macro defines the command code to read multiple blocks from the card 
.................... #define     cmdREAD_MULTI_BLOCK     18 
.................... // Description: This macro defines the command code to tell the media how many blocks to pre-erase (for faster multi-block writes to follow) 
.................... //Note: This is an "application specific" command.  This tells the media how many blocks to pre-erase for the subsequent WRITE_MULTI_BLOCK 
.................... #define     cmdSET_WR_BLK_ERASE_COUNT   23 
.................... // Description: This macro defines the command code to write one block to the card 
.................... #define     cmdWRITE_SINGLE_BLOCK   24     
.................... // Description: This macro defines the command code to write multiple blocks to the card 
.................... #define     cmdWRITE_MULTI_BLOCK    25 
.................... // Description: This macro defines the command code to set the address of the start of an erase operation 
.................... #define     cmdTAG_SECTOR_START     32 
.................... // Description: This macro defines the command code to set the address of the end of an erase operation 
.................... #define     cmdTAG_SECTOR_END       33 
.................... // Description: This macro defines the command code to erase all previously selected blocks 
.................... #define     cmdERASE                38 
.................... //Description: This macro defines the command code to intitialize an SD card and provide the CSD register value. 
.................... //Note: this is an "application specific" command (specific to SD cards) and must be preceded by cmdAPP_CMD. 
.................... #define     cmdSD_SEND_OP_COND      41 
.................... // Description: This macro defines the command code to begin application specific command inputs 
.................... #define     cmdAPP_CMD              55 
.................... // Description: This macro defines the command code to get the OCR register information from the card 
.................... #define     cmdREAD_OCR             58 
.................... // Description: This macro defines the command code to disable CRC checking 
.................... #define     cmdCRC_ON_OFF           59 
....................  
....................  
.................... // Description: Enumeration of different SD response types 
.................... typedef enum 
.................... { 
....................     R1,     // R1 type response 
....................     R1b,    // R1b type response 
....................     R2,     // R2 type response 
....................     R3,     // R3 type response  
....................     R7      // R7 type response  
.................... }RESP; 
....................  
.................... // Summary: SD card command data structure 
.................... // Description: The typMMC_CMD structure is used to create a command table of information needed for each relevant SD command 
.................... typedef struct 
.................... { 
....................     BYTE      CmdCode;          // The command code 
....................     BYTE      CRC;              // The CRC value for that command 
....................     RESP    responsetype;       // The response type 
....................     BYTE    moredataexpected;   // Set to MOREDATA or NODATA, depending on whether more data is expected or not 
.................... } typMMC_CMD; 
....................  
....................  
.................... // Summary: An SD command packet 
.................... // Description: This union represents different ways to access an SD card command packet 
.................... typedef union 
.................... { 
....................     // This structure allows array-style access of command bytes 
....................     struct 
....................     { 
....................         #ifdef __18CXX 
....................             BYTE field[6];      // BYTE array 
....................         #else 
....................             BYTE field[7]; 
....................         #endif 
....................     }; 
....................     // This structure allows byte-wise access of packet command bytes 
....................     struct 
....................     { 
....................         BYTE crc;               // The CRC byte 
....................         #if defined __C30__ 
....................             BYTE c30filler;     // Filler space (since bitwise declarations can't cross a WORD boundary) 
....................         #elif defined __C32__ 
....................             BYTE c32filler[3];  // Filler space (since bitwise declarations can't cross a DWORD boundary) 
....................         #endif 
....................          
....................         BYTE addr0;             // Address byte 0 
....................         BYTE addr1;             // Address byte 1 
....................         BYTE addr2;             // Address byte 2 
....................         BYTE addr3;             // Address byte 3 
....................         BYTE cmd;               // Command code byte 
....................     }; 
....................     // This structure allows bitwise access to elements of the command bytes 
....................     struct 
....................     { 
....................         BYTE  END_BIT:1;        // Packet end bit 
....................         BYTE  CRC7:7;           // CRC value 
....................         DWORD     address;      // Address 
....................         BYTE  CMD_INDEX:6;      // Command code 
....................         BYTE  TRANSMIT_BIT:1;   // Transmit bit 
....................         BYTE  START_BIT:1;      // Packet start bit 
....................     }; 
.................... } CMD_PACKET; 
....................  
....................  
.................... // Summary: The format of an R1 type response 
.................... // Description: This union represents different ways to access an SD card R1 type response packet. 
.................... typedef union 
.................... { 
....................     BYTE _byte;                         // Byte-wise access 
....................     // This structure allows bitwise access of the response 
....................     struct 
....................     { 
....................         unsigned IN_IDLE_STATE:1;       // Card is in idle state 
....................         unsigned ERASE_RESET:1;         // Erase reset flag 
....................         unsigned ILLEGAL_CMD:1;         // Illegal command flag 
....................         unsigned CRC_ERR:1;             // CRC error flag 
....................         unsigned ERASE_SEQ_ERR:1;       // Erase sequence error flag 
....................         unsigned ADDRESS_ERR:1;         // Address error flag 
....................         unsigned PARAM_ERR:1;           // Parameter flag    
....................         unsigned B7:1;                  // Unused bit 7 
....................     }; 
.................... } RESPONSE_1; 
....................  
.................... // Summary: The format of an R2 type response 
.................... // Description: This union represents different ways to access an SD card R2 type response packet 
.................... typedef union 
.................... { 
....................     WORD _word; 
....................     struct 
....................     { 
....................         BYTE      _byte0; 
....................         BYTE      _byte1; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned IN_IDLE_STATE:1; 
....................         unsigned ERASE_RESET:1; 
....................         unsigned ILLEGAL_CMD:1; 
....................         unsigned CRC_ERR:1; 
....................         unsigned ERASE_SEQ_ERR:1; 
....................         unsigned ADDRESS_ERR:1; 
....................         unsigned PARAM_ERR:1; 
....................         unsigned B7:1; 
....................         unsigned CARD_IS_LOCKED:1; 
....................         unsigned WP_ERASE_SKIP_LK_FAIL:1; 
....................         unsigned ERROR:1; 
....................         unsigned CC_ERROR:1; 
....................         unsigned CARD_ECC_FAIL:1; 
....................         unsigned WP_VIOLATION:1; 
....................         unsigned ERASE_PARAM:1; 
....................         unsigned OUTRANGE_CSD_OVERWRITE:1; 
....................     }; 
.................... } RESPONSE_2; 
....................  
.................... // Summary: The format of an R7 or R3 type response 
.................... // Description: This union represents different ways to access an SD card R7 type response packet. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         BYTE _byte;                         // Byte-wise access 
....................         union 
....................         { 
....................             //Note: The SD card argument response field is 32-bit, big endian format. 
....................             //However, the C compiler stores 32-bit values in little endian in RAM. 
....................             //When writing to the _returnVal/argument bytes, make sure to byte 
....................             //swap the order from which it arrived over the SPI from the SD card. 
....................             DWORD _returnVal; 
....................             struct 
....................             { 
....................                 BYTE _byte0; 
....................                 BYTE _byte1; 
....................                 BYTE _byte2; 
....................                 BYTE _byte3; 
....................             };     
....................         }argument;     
....................     } bytewise; 
....................     // This structure allows bitwise access of the response 
....................     struct 
....................     { 
....................         struct 
....................         { 
....................             unsigned IN_IDLE_STATE:1;       // Card is in idle state 
....................             unsigned ERASE_RESET:1;         // Erase reset flag 
....................             unsigned ILLEGAL_CMD:1;         // Illegal command flag 
....................             unsigned CRC_ERR:1;             // CRC error flag 
....................             unsigned ERASE_SEQ_ERR:1;       // Erase sequence error flag 
....................             unsigned ADDRESS_ERR:1;         // Address error flag 
....................             unsigned PARAM_ERR:1;           // Parameter flag    
....................             unsigned B7:1;                  // Unused bit 7 
....................         }bits; 
....................         DWORD _returnVal; 
....................     } bitwise; 
.................... } RESPONSE_7; 
....................  
.................... // Summary: A union of responses from an SD card 
.................... // Description: The MMC_RESPONSE union represents any of the possible responses that an SD card can return after 
.................... //              being issued a command. 
.................... typedef union 
.................... { 
....................     RESPONSE_1  r1;   
....................     RESPONSE_2  r2; 
....................     RESPONSE_7  r7; 
.................... }MMC_RESPONSE; 
....................  
....................  
.................... // Summary: A description of the card specific data register 
.................... // Description: This union represents different ways to access information in a packet with SD card CSD informaiton.  For more 
.................... //              information on the CSD register, consult an SD card user's manual. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         DWORD _u320; 
....................         DWORD _u321; 
....................         DWORD _u322; 
....................         DWORD _u323; 
....................     }; 
....................     struct 
....................     { 
....................         BYTE _byte[16]; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned NOT_USED           :1; 
....................         unsigned CRC                :7; 
....................         unsigned ECC                :2; 
....................         unsigned FILE_FORMAT        :2; 
....................         unsigned TMP_WRITE_PROTECT  :1; 
....................         unsigned PERM_WRITE_PROTECT :1; 
....................         unsigned COPY               :1; 
....................         unsigned FILE_FORMAT_GRP    :1; 
....................         unsigned RESERVED_1         :5; 
....................         unsigned WRITE_BL_PARTIAL   :1; 
....................         unsigned WRITE_BL_LEN_L     :2; 
....................         unsigned WRITE_BL_LEN_H     :2; 
....................         unsigned R2W_FACTOR         :3; 
....................         unsigned DEFAULT_ECC        :2; 
....................         unsigned WP_GRP_ENABLE      :1; 
....................         unsigned WP_GRP_SIZE        :5; 
....................         unsigned ERASE_GRP_SIZE_L   :3; 
....................         unsigned ERASE_GRP_SIZE_H   :2; 
....................         unsigned SECTOR_SIZE        :5; 
....................         unsigned C_SIZE_MULT_L      :1; 
....................         unsigned C_SIZE_MULT_H      :2; 
....................         unsigned VDD_W_CURR_MAX     :3; 
....................         unsigned VDD_W_CUR_MIN      :3; 
....................         unsigned VDD_R_CURR_MAX     :3; 
....................         unsigned VDD_R_CURR_MIN     :3; 
....................         unsigned C_SIZE_L           :2; 
....................         unsigned C_SIZE_H           :8; 
....................         unsigned C_SIZE_U           :2; 
....................         unsigned RESERVED_2         :2; 
....................         unsigned DSR_IMP            :1; 
....................         unsigned READ_BLK_MISALIGN  :1; 
....................         unsigned WRITE_BLK_MISALIGN :1; 
....................         unsigned READ_BL_PARTIAL    :1; 
....................         unsigned READ_BL_LEN        :4; 
....................         unsigned CCC_L              :4; 
....................         unsigned CCC_H              :8; 
....................         unsigned TRAN_SPEED         :8; 
....................         unsigned NSAC               :8; 
....................         unsigned TAAC               :8; 
....................         unsigned RESERVED_3         :2; 
....................         unsigned SPEC_VERS          :4; 
....................         unsigned CSD_STRUCTURE      :2; 
....................     }; 
.................... } CSD; 
....................  
....................  
.................... // Summary: A description of the card information register 
.................... // Description: This union represents different ways to access information in a packet with SD card CID register informaiton.  For more 
.................... //              information on the CID register, consult an SD card user's manual. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         DWORD _u320; 
....................         DWORD _u321; 
....................         DWORD _u322; 
....................         DWORD _u323; 
....................     }; 
....................     struct 
....................     { 
....................         BYTE _byte[16]; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned    NOT_USED            :1; 
....................         unsigned    CRC                 :7; 
....................         unsigned    MDT                 :8; 
....................         DWORD       PSN; 
....................         unsigned    PRV                 :8; 
....................         char        PNM[6]; 
....................         WORD        OID; 
....................         unsigned    MID                 :8; 
....................     }; 
.................... } CID; 
....................  
.................... #ifndef FALSE 
....................     #define FALSE   0 
.................... #endif 
.................... #ifndef TRUE 
....................     #define TRUE    !FALSE 
.................... #endif 
....................  
.................... #define INPUT   1 
.................... #define OUTPUT  0 
....................  
....................  
.................... // Description: A delay prescaler 
.................... #define DELAY_PRESCALER   (BYTE)      8 
....................  
.................... // Description: An approximation of the number of cycles per delay loop of overhead 
.................... #define DELAY_OVERHEAD    (BYTE)      5 
....................  
.................... // Description: An approximate calculation of how many times to loop to delay 1 ms in the Delayms function 
.................... #define MILLISECDELAY   (WORD)      ((GetInstructionClock()/DELAY_PRESCALER/(WORD)1000) - DELAY_OVERHEAD) 
....................  
....................  
.................... // Desription: Media Response Delay Timeouts  
.................... #define NCR_TIMEOUT     (WORD)20        //Byte times before command response is expected (must be at least 8) 
.................... #define NAC_TIMEOUT     (DWORD)0x40000  //SPI byte times we should wait when performing read operations (should be at least 100ms for SD cards) 
.................... #define WRITE_TIMEOUT   (DWORD)0xA0000  //SPI byte times to wait before timing out when the media is performing a write operation (should be at least 250ms for SD cards). 
....................  
.................... // Summary: An enumeration of SD commands 
.................... // Description: This enumeration corresponds to the position of each command in the sdmmc_cmdtable array 
.................... //              These macros indicate to the SendMMCCmd function which element of the sdmmc_cmdtable array 
.................... //              to retrieve command code information from. 
.................... typedef enum 
.................... { 
....................     GO_IDLE_STATE, 
....................     SEND_OP_COND, 
....................     SEND_IF_COND, 
....................     SEND_CSD, 
....................     SEND_CID, 
....................     STOP_TRANSMISSION, 
....................     SEND_STATUS, 
....................     SET_BLOCKLEN, 
....................     READ_SINGLE_BLOCK, 
....................     READ_MULTI_BLOCK, 
....................     WRITE_SINGLE_BLOCK, 
....................     WRITE_MULTI_BLOCK, 
....................     TAG_SECTOR_START, 
....................     TAG_SECTOR_END, 
....................     ERASE, 
....................     APP_CMD, 
....................     READ_OCR, 
....................     CRC_ON_OFF, 
....................     SD_SEND_OP_COND, 
....................     SET_WR_BLK_ERASE_COUNT 
.................... }sdmmc_cmd; 
....................  
....................  
.................... #define SD_MODE_NORMAL  0 
.................... #define SD_MODE_HC      1 
....................  
....................  
.................... //Definition for a structure used when calling either MDD_SDSPI_AsyncReadTasks()  
.................... //function, or the MDD_SDSPI_AsyncWriteTasks() function. 
.................... typedef struct 
.................... { 
....................     WORD wNumBytes;         //Number of bytes to attempt to read or write in the next call to MDD_SDSPI_AsyncReadTasks() or MDD_SDSPI_AsyncWriteTasks.  May be updated between calls to the handler. 
....................     DWORD dwBytesRemaining; //Should be initialized to the total number of bytes that you wish to read or write.  This value is allowed to be greater than a single block size of the media. 
....................     BYTE* pBuffer;          //Pointer to where the read/written bytes should be copied to/from.  May be updated between calls to the handler function. 
....................     DWORD dwAddress;        //Starting block address to read or to write to on the media.  Should only get initialized, do not modify after that. 
....................     BYTE bStateVariable;    //State machine variable.  Should get initialized to ASYNC_READ_QUEUED or ASYNC_WRITE_QUEUED to start an operation.  After that, do not modify until the read or write is complete. 
.................... }ASYNC_IO;    
....................  
....................  
.................... //Response codes for the MDD_SDSPI_AsyncReadTasks() function. 
.................... #define ASYNC_READ_COMPLETE             0x00 
.................... #define ASYNC_READ_BUSY                 0x01 
.................... #define ASYNC_READ_NEW_PACKET_READY     0x02 
.................... #define ASYNC_READ_ERROR                0xFF 
....................  
.................... //MDD_SDSPI_AsyncReadTasks() state machine variable values.  These are used internally to SD-SPI.c. 
.................... //#define ASYNC_READ_COMPLETE             0x00 
.................... #define ASYNC_READ_QUEUED               0x01    //Initialize to this to start a read sequence 
.................... #define ASYNC_READ_WAIT_START_TOKEN     0x03 
.................... //#define ASYNC_READ_NEW_PACKET_READY     0x02 
.................... #define ASYNC_READ_ABORT                0xFE 
.................... //#define ASYNC_READ_ERROR                0xFF 
....................  
.................... //Possible return values when calling MDD_SDSPI_AsyncWriteTasks() 
.................... #define ASYNC_WRITE_COMPLETE        0x00 
.................... #define ASYNC_WRITE_SEND_PACKET     0x02 
.................... #define ASYNC_WRITE_BUSY            0x03 
.................... #define ASYNC_WRITE_ERROR           0xFF 
....................  
.................... //MDD_SDSPI_AsyncWriteTasks() state machine variable values.  These are used internally to SD-SPI.c. 
.................... //#define ASYNC_WRITE_COMPLETE            0x00 
.................... #define ASYNC_WRITE_QUEUED              0x01    //Initialize to this to start a write sequence 
.................... #define ASYNC_WRITE_TRANSMIT_PACKET     0x02 
.................... #define ASYNC_WRITE_MEDIA_BUSY          0x03 
.................... #define ASYNC_STOP_TOKEN_SENT_WAIT_BUSY 0x04 
.................... #define ASYNC_WRITE_ABORT               0xFE 
.................... //#define ASYNC_WRITE_ERROR               0xFF 
....................  
....................  
.................... //Constants 
.................... #define MEDIA_BLOCK_SIZE            512u  //Should always be 512 for v1 and v2 devices. 
.................... #define WRITE_RESPONSE_TOKEN_MASK   0x1F  //Bit mask to AND with the write token response byte from the media, to clear the don't care bits. 
....................  
....................  
....................  
.................... /***************************************************************************/ 
.................... /*                               Macros                                    */ 
.................... /***************************************************************************/ 
....................  
.................... // Description: A macro to send clock cycles to dummy-read the CRC 
.................... #define mReadCRC()              WriteSPIM(0xFF);WriteSPIM(0xFF); 
....................  
.................... // Description: A macro to send clock cycles to dummy-write the CRC 
.................... #define mSendCRC()              WriteSPIM(0xFF);WriteSPIM(0xFF); 
....................  
.................... // Description: A macro to send 8 clock cycles for SD timing requirements 
.................... #define mSend8ClkCycles()       WriteSPIM(0xFF); 
....................  
.................... /*****************************************************************************/ 
.................... /*                                 Public Prototypes                         */ 
.................... /*****************************************************************************/ 
....................  
.................... //These are the public API functions provided by SD-SPI.c 
.................... BYTE MDD_SDSPI_MediaDetect(void); 
.................... MEDIA_INFORMATION * MDD_SDSPI_MediaInitialize(void); 
.................... DWORD MDD_SDSPI_ReadCapacity(void); 
.................... WORD MDD_SDSPI_ReadSectorSize(void); 
.................... void MDD_SDSPI_InitIO(void); 
.................... BYTE MDD_SDSPI_SectorRead(DWORD sector_addr, BYTE* buffer); 
.................... BYTE MDD_SDSPI_SectorWrite(DWORD sector_addr, BYTE* buffer, BYTE allowWriteToZero); 
.................... BYTE MDD_SDSPI_AsyncReadTasks(ASYNC_IO*); 
.................... BYTE MDD_SDSPI_AsyncWriteTasks(ASYNC_IO*); 
.................... BYTE MDD_SDSPI_WriteProtectState(void); 
.................... BYTE MDD_SDSPI_ShutdownMedia(void); 
....................  
....................  
.................... #if defined __C30__ || defined __C32__ 
....................     extern BYTE ReadByte( BYTE* pBuffer, WORD index ); 
....................     extern WORD ReadWord( BYTE* pBuffer, WORD index ); 
....................     extern DWORD ReadDWord( BYTE* pBuffer, WORD index ); 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #endif 
.................... #ifdef USE_CF_INTERFACE_WITH_PMP 
....................     #include    "CF-PMP.h" 
.................... #endif 
.................... #ifdef USE_MANUAL_CF_INTERFACE 
....................     #include    "CF- Bit transaction.h" 
.................... #endif 
.................... #ifdef USE_USB_INTERFACE 
....................     #include    "usb_host_msd_scsi.h" 
.................... #endif 
.................... #ifdef USE_INTERNAL_FLASH 
....................     #include    "Internal Flash.h" 
.................... #endif 
....................  
....................  
.................... /*******************************************************************/ 
.................... /*                     Strunctures and defines                     */ 
.................... /*******************************************************************/ 
....................  
.................... #ifndef FALSE 
....................     // Summary: False value 
....................     // Description:  This macro will indicate that a condition is false. 
....................     #define FALSE   0 
.................... #endif 
.................... #ifndef TRUE 
....................     // Summary: True value 
....................     // Description: This macro will indicate that a condition is true. 
....................     #define TRUE    !FALSE  // True value 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #ifndef SEEK_SET 
....................     // Summary: Macro for the FSfseek SEEK_SET base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed  
....................     //              relative to the beginning of the file. 
....................     #define SEEK_SET 0 
....................  
.................... #endif 
.................... #ifndef SEEK_CUR 
....................  
....................     // Summary: Macro for the FSfseek SEEK_CUR base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the current location of the file 
....................     #define SEEK_CUR 1 
....................  
.................... #endif 
.................... #ifndef SEEK_END 
....................  
....................     // Summary: Macro for the FSfseek SEEK_END base location 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the end of the file.  For this macro, the offset value will be subtracted from 
....................     //              the end location of the file by default. 
....................     #define SEEK_END 2 
....................  
.................... #endif 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file. 
.................... #define FS_APPEND   "a" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file. 
.................... #define FS_WRITE    "w" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file. 
.................... #define FS_READ "r" 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file 
.................... //              or read from the file. 
.................... #define FS_APPENDPLUS   "a+" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file or read from the file. 
.................... #define FS_WRITEPLUS    "w+" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file or write to the file. 
.................... #define FS_READPLUS     "r+" 
....................  
.................... #ifndef intmax_t 
....................     #ifdef __PIC24F__ 
....................         // Summary: A data type indicating the maximum integer size in an architecture 
....................         // Description: The intmax_t data type refers to the maximum-sized data type on any given architecture.  This 
....................         //              data type can be specified as a format specifier size specification for the FSfprintf function. 
....................         #define intmax_t long long 
....................     #elif defined __PIC24H__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC30F__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC33F__ 
....................         #define intmax_t long long 
....................     #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary:  Indicates flag conditions for a file object 
.................... // Description: The FILEFLAGS structure is used to indicate conditions in a file.  It contains three flags: 'write' indicates 
.................... //              that the file was opened in a mode that allows writes, 'read' indicates that the file was opened in a mode 
.................... //              that allows reads, and 'FileWriteEOF' indicates that additional data that is written to the file will increase 
.................... //              the file size. 
.................... typedef struct 
.................... { 
....................     unsigned    write :1;           // Indicates a file was opened in a mode that allows writes 
....................     unsigned    read :1;            // Indicates a file was opened in a mode that allows reads 
....................     unsigned    FileWriteEOF :1;    // Indicates the current position in a file is at the end of the file 
.................... }FILEFLAGS; 
....................  
....................  
....................  
.................... // Summary: Indicates how to search for file entries in the FILEfind function 
.................... // Description: The values in the SEARCH_TYPE enumeration are used internally by the library to indicate how the FILEfind function 
.................... //              how to perform a search.  The 'LOOK_FOR_EMPTY_ENTRY' value indicates that FILEfind should search for an empty file entry. 
.................... //              The 'LOOK_FOR_MATCHING_ENTRY' value indicates that FILEfind should search for an entry that matches the FSFILE object 
.................... //              that was passed into the FILEfind function. 
.................... typedef enum{ 
....................     LOOK_FOR_EMPTY_ENTRY = 0, 
....................     LOOK_FOR_MATCHING_ENTRY 
.................... } SEARCH_TYPE; 
....................  
....................  
....................  
.................... // Summary: Macro indicating the length of a 8.3 file name 
.................... // Description: The TOTAL_FILE_SIZE_8P3 macro indicates the maximum number of characters in an 8.3 file name.  This value includes 
.................... //              8 characters for the name, three for the extentsion, and 1 for the radix ('.') 
.................... #define TOTAL_FILE_SIZE_8P3             (8+3+1) 
.................... #define TOTAL_FILE_SIZE                 TOTAL_FILE_SIZE_8P3 
....................  
.................... // Summary: Macro indicating the max length of a LFN file name 
.................... // Description: The MAX_FILE_NAME_LENGTH_LFN macro indicates the maximum number of characters in an LFN file name. 
.................... #define MAX_FILE_NAME_LENGTH_LFN             256 
....................  
.................... // Summary: A mask that indicates the limit of directory entries in a sector 
.................... // Description: The MASK_MAX_FILE_ENTRY_LIMIT_BITS is used to indicate to the Cache_File_Entry function that a new sector needs to 
.................... //              be loaded. 
.................... #define MASK_MAX_FILE_ENTRY_LIMIT_BITS          0x0f 
....................  
.................... // Summary: Value used for shift operations to calculate the sector offset in a directory 
.................... // Description: The VALUE_BASED_ON_ENTRIES_PER_CLUSTER macro is used to calculate sector offsets for directories.  The position of the 
.................... //              entry is shifted by 4 bits (divided by 16, since there are 16 entries in a sector) to calculate how many sectors a 
.................... //              specified entry is offset from the beginning of the directory. 
.................... #define VALUE_BASED_ON_ENTRIES_PER_CLUSTER      4 
....................  
.................... // Summary: A value that will indicate that a dotdot directory entry points to the root. 
.................... // Description: The VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT macro is used as an absolute address when writing information to a dotdot entry 
.................... //              in a newly created directory.  If a dotdot entry points to the root directory, it's cluster value must be set to 0, 
.................... //              regardless of the actual cluster number of the root directory. 
.................... #define VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT     0 
....................  
.................... // Summary: MAcro indicating the length of an 8.3 file name in a directory entry 
.................... // Description: The FILE_NAME_SIZE_8P3 macro indicates the number of characters that an 8.3 file name will take up when packed in 
.................... //              a directory entry.  This value includes 8 characters for the name and 3 for the extension.  Note that the radix is not 
.................... //              stored in the directory entry. 
.................... #define FILE_NAME_SIZE_8P3           11 
.................... #define FILE_NAME_SIZE               FILE_NAME_SIZE_8P3 
....................  
....................  
.................... // Summary: Contains file information and is used to indicate which file to access. 
.................... // Description: The FSFILE structure is used to hold file information for an open file as it's being modified or accessed.  A pointer to  
.................... //              an open file's FSFILE structure will be passeed to any library function that will modify that file. 
.................... typedef struct 
.................... { 
....................     DISK    *       dsk;            // Pointer to a DISK structure 
....................     DWORD           cluster;        // The first cluster of the file 
....................     DWORD           ccls;           // The current cluster of the file 
....................     WORD            sec;            // The current sector in the current cluster of the file 
....................     WORD            pos;            // The position in the current sector 
....................     DWORD           seek;           // The absolute position in the file 
....................     DWORD           size;           // The size of the file 
....................     FILEFLAGS       flags;          // A structure containing file flags 
....................     WORD            time;           // The file's last update time 
....................     WORD            date;           // The file's last update date 
....................     char            name[FILE_NAME_SIZE_8P3];       // The short name of the file 
....................    #ifdef SUPPORT_LFN 
....................        BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNptr;           // Pointer to long file name in UTF16 format 
....................       unsigned short int utf16LFNlength;          // LFN length in terms of words excluding the NULL word at the last. 
....................    #endif 
....................     WORD            entry;          // The position of the file's directory entry in it's directory 
....................     WORD            chk;            // File structure checksum 
....................     WORD            attributes;     // The file attributes 
....................     DWORD           dirclus;        // The base cluster of the file's directory 
....................     DWORD           dirccls;        // The current cluster of the file's directory 
.................... } FSFILE; 
....................  
.................... /* Summary: Possible results of the FSGetDiskProperties() function. 
.................... ** Description: See the FSGetDiskProperties() function for more information. 
.................... */ 
.................... typedef enum 
.................... { 
....................     FS_GET_PROPERTIES_NO_ERRORS = 0, 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED, 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE, 
....................     FS_GET_PROPERTIES_STILL_WORKING = 0xFF 
.................... } FS_DISK_ERRORS; 
....................  
....................  
.................... /* Summary: Contains the disk search information, intermediate values, and results 
.................... ** Description: This structure is used in conjunction with the FSGetDiskProperties() 
.................... **              function.  See that function for more information about the usage. 
.................... */ 
.................... typedef struct 
.................... { 
....................     DISK *  disk;           /* pointer to the disk we are searching */ 
....................     BOOL    new_request;    /* is this a new request or a continued request */ 
....................     FS_DISK_ERRORS properties_status;  /* status of the last call of the function */ 
....................  
....................     struct 
....................     { 
....................         BYTE disk_format;           /* disk format: FAT12, FAT16, FAT32 */ 
....................         WORD sector_size;           /* sector size of the drive */ 
....................         BYTE sectors_per_cluster;   /* number of sectors per cluster */ 
....................         DWORD total_clusters;       /* the number of total clusters on the drive */ 
....................         DWORD free_clusters;        /* the number of free (unused) clusters on drive */ 
....................     } results;                      /* the results of the current search */ 
....................  
....................     struct 
....................     { 
....................         DWORD   c;      
....................         DWORD   curcls; 
....................         DWORD   EndClusterLimit; 
....................         DWORD   ClusterFailValue; 
....................     } private;      /* intermediate values used to continue searches.  This 
....................                          member should be used only by the FSGetDiskProperties() 
....................                          function */ 
....................  
.................... } FS_DISK_PROPERTIES; 
....................  
.................... // Summary: A structure used for searching for files on a device. 
.................... // Description: The SearchRec structure is used when searching for file on a device.  It contains parameters that will be loaded with 
.................... //              file information when a file is found.  It also contains the parameters that the user searched for, allowing further 
.................... //              searches to be perfomed in the same directory for additional files that meet the specified criteria. 
.................... typedef struct 
.................... { 
....................     char            filename[FILE_NAME_SIZE_8P3 + 2];   // The name of the file that has been found 
....................     unsigned char   attributes;                     // The attributes of the file that has been found 
....................     unsigned long   filesize;                       // The size of the file that has been found 
....................     unsigned long   timestamp;                      // The last modified time of the file that has been found (create time for directories) 
....................    #ifdef SUPPORT_LFN 
....................       BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNfound;          // Pointer to long file name found in UTF16 format 
....................       unsigned short int utf16LFNfoundLength;     // LFN Found length in terms of words including the NULL word at the last. 
....................    #endif 
....................     unsigned int    entry;                          // The directory entry of the last file found that matches the specified attributes. (Internal use only) 
....................     char            searchname[FILE_NAME_SIZE_8P3 + 2]; // The 8.3 format name specified when the user began the search. (Internal use only) 
....................     unsigned char   searchattr;                     // The attributes specified when the user began the search. (Internal use only) 
....................     unsigned long   cwdclus;                        // The directory that this search was performed in. (Internal use only) 
....................     unsigned char   initialized;                    // Check to determine if the structure was initialized by FindFirst (Internal use only) 
.................... } SearchRec; 
....................  
....................  
.................... /*************************************************************************** 
.................... * Prototypes                                                               * 
.................... ***************************************************************************/ 
....................  
....................  
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     int FSInit(void) 
....................   Summary: 
....................     Function to initialize the device. 
....................   Conditions: 
....................     The physical device should be connected to the microcontroller. 
....................   Input: 
....................     None 
....................   Return Values: 
....................     TRUE -  Initialization successful 
....................     FALSE - Initialization unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function initializes the file system stack & the interfacing device. 
....................     Initializes the static or dynamic memory slots for holding file 
....................     structures. Initializes the device with the DISKmount function. Loads  
....................     MBR and boot sector information. Initializes the current working 
....................     directory to the root directory for the device if directory support 
....................     is enabled. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... int FSInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * FSfopen (const char * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with ascii input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will open a ascii name file or directory on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * FSfopen(const char * fileName, const char *mode); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * wFSfopen (const unsigned short int * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * wFSfopen(const unsigned short int * fileName, const char *mode); 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................  
.................... /****************************************************************************** 
....................   Function: 
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode) 
....................   Summary: 
....................     Opens a file on PIC18 Microcontrollers where 'fileName' ROM string is given 
....................     in Ascii format. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to be opened (ROM) 
....................     mode -      The mode the file will be opened in (ROM) 
....................   Return Values: 
....................     FSFILE * - A pointer to the file object 
....................     NULL -     File could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file on PIC18 Microcontrollers where 'fileName' ROM string 
....................     is given in Ascii format.The FSfopenpgm function will copy a PIC18 ROM fileName and 
....................     mode argument into RAM arrays, and then pass those arrays to the FSfopen function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   ******************************************************************************/ 
....................  
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode); 
....................  
....................  
.................... /************************************************************************************** 
....................   Function: 
....................     int FindFirstpgm (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Find a file named with a ROM string on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName -  The name of the file to be found (ROM) 
....................     attr -      The attributes of the file to be found 
....................     rec -       Pointer to a search record to store the file info in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the given parameters was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirstpgm call on passed SearchRec object 
....................     will be lost.The FSerrno variable will be changed. 
....................   Description: 
....................     This function finds a file named with 'fileName' on PIC18. The FindFirstpgm 
....................     function will copy a PIC18 ROM fileName argument into a RAM array, and then 
....................     pass that array to the FindFirst function. 
....................   Remarks: 
....................     Call FindFirstpgm or FindFirst before calling FindNext. 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************************/ 
....................  
....................     int FindFirstpgm (const rom char * fileName, unsigned int attr, SearchRec * rec); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdirpgm (const rom char * path) 
....................   Summary: 
....................     Changes the CWD to the input path on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to (ROM) 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the CWD to the input path on PIC18.The FSchdirpgm function 
....................     passes a PIC18 ROM path pointer to the chdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM 
....................   **************************************************************************/ 
....................  
....................     int FSchdirpgm (const rom char * path); 
....................  
....................     #ifdef ALLOW_WRITES 
....................  
....................  
.................... /************************************************************* 
....................   Function: 
....................     int FSremovepgm (const rom char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC18 device 
....................   Conditions: 
....................     File not opened; file exists 
....................   Input: 
....................     fileName -  The name of the file to be deleted (ROM) 
....................   Return Values: 
....................     0 -  File was removed successfully 
....................     -1 - File could not be removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC18 device.The FSremovepgm function will copy a 
....................     PIC18 ROM fileName argument into a RAM array, and then pass that array 
....................     to the FSremove function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   *************************************************************/ 
....................  
....................         int FSremovepgm (const rom char * fileName); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdirpgm (const rom char * path) 
....................   Summary: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create (ROM) 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices.'FSmkdirpgm' creates the directories as per the input 
....................     string path.This function doesn't move the current working 
....................     directory setting. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arugments in ROM 
....................   **************************************************************************/ 
....................  
....................         int FSmkdirpgm (const rom char * path); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdirpgm (const rom char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     path -      The path of the directory to remove (ROM) 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................     This function deletes the directory as specified in the path. 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************/ 
....................  
....................         int FSrmdirpgm (const rom char * path, unsigned char rmsubdirs); 
....................  
....................  
.................... /***************************************************************** 
....................   Function: 
....................     int FSrenamepgm(const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the file with the ascii ROM string(PIC18) 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file (in ROM) 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -  File renamed successfully 
....................     -1 - File could not be renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the file with the ascii ROM string(PIC18).The Fsrenamepgm 
....................     function will copy the rom fileName specified by the user into a  
....................     RAM array and pass that array into the FSrename function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM.                        
....................   *****************************************************************/ 
....................  
....................         int FSrenamepgm (const rom char * fileName, FSFILE * fo); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************ 
....................   Function: 
....................     int FSfclose(FSFILE *fo) 
....................   Summary: 
....................     Update file information and free FSFILE objects 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to the file to close 
....................   Return Values: 
....................     0 -   File closed successfully  
....................     EOF - Error closing the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will update the directory entry for the  
....................     file pointed to by 'fo' with the information contained 
....................     in 'fo,' including the new file size and attributes. 
....................     Timestamp information will also be loaded based on the 
....................     method selected by the user and written to the entry 
....................     as the last modified time and date.  The file entry will 
....................     then be written to the device.  Finally, the memory 
....................     used for the specified file object will be freed from 
....................     the dynamic heap or the array of FSFILE objects. 
....................   Remarks: 
....................     A function to flush data to the device without closing the 
....................     file can be created by removing the portion of this 
....................     function that frees the memory and the line that clears 
....................     the write flag. 
....................   ************************************************************/ 
....................  
.................... int FSfclose(FSFILE *fo); 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     void FSrewind (FSFILE * fo) 
....................   Summary: 
....................     Set the current position in a file to the beginning 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The FSrewind funciton will reset the position of the 
....................     specified file to the beginning of the file.  This 
....................     functionality is faster than using FSfseek to reset 
....................     the position in the file. 
....................   Remarks: 
....................     None. 
....................   *********************************************************/ 
....................  
.................... void FSrewind (FSFILE *fo); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Read data from a file 
....................   Conditions: 
....................     File is opened in a read mode 
....................   Input: 
....................     ptr -     Destination buffer for read bytes 
....................     size -    Size of units in bytes 
....................     n -       Number of units to be read 
....................     stream -  File to be read from 
....................   Return: 
....................     size_t - number of units read 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfread function will read data from the specified file.  First, 
....................     the appropriate sector of the file is loaded.  Then, data is read into 
....................     the specified buffer until the specified number of bytes have been read. 
....................     When a cluster boundary is reached, a new cluster will be loaded.  The 
....................     parameters 'size' and 'n' indicate how much data to read.  'Size' 
....................     refers to the size of one object to read (in bytes), and 'n' will refer  
....................     to the number of these objects to read.  The value returned will be equal  
....................     to 'n' unless an error occured or the user tried to read beyond the end 
....................     of the file. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream); 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FSfseek(FSFILE *stream, long offset, int whence) 
....................   Summary: 
....................     Change the current position in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     stream -    Pointer to file structure 
....................     offset -    Offset from base location 
....................     whence -     
....................            - SEEK_SET -  Seek from start of file 
....................            - SEEK_CUR -  Seek from current location 
....................            - SEEK_END -  Seek from end of file (subtract offset) 
....................   Return Values: 
....................     0 -  Operation successful  
....................     -1 - Operation unsuccesful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfseek function will change the current position in the file to 
....................     one specified by the user.  First, an absolute offset is calculated 
....................     using the offset and base location passed in by the user.  Then, the 
....................     position variables are updated, and the sector number that corresponds 
....................     to the new location.  That sector is then loaded.  If the offset 
....................     falls exactly on a cluster boundary, a new cluster will be allocated 
....................     to the file and the position will be set to the first byte of that 
....................     cluster. 
....................   Remarks: 
....................     None                                                                
....................   **********************************************************************/ 
....................  
.................... int FSfseek(FSFILE *stream, long offset, int whence); 
....................  
....................  
.................... /******************************************************************* 
....................   Function: 
....................     long FSftell (FSFILE * fo) 
....................   Summary: 
....................     Determine the current location in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return: Current location in the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     The FSftell function will return the current position in the 
....................     file pointed to by 'fo' by returning the 'seek' variable in the 
....................     FSFILE object, which is used to keep track of the absolute 
....................     location of the current position in the file. 
....................   Remarks: 
....................     None                                                             
....................   *******************************************************************/ 
....................  
.................... long FSftell(FSFILE *fo); 
....................  
....................  
.................... /**************************************************** 
....................   Function: 
....................     int FSfeof( FSFILE * stream ) 
....................   Summary: 
....................     Indicate whether the current file position is at the end 
....................   Conditions: 
....................     File is open in a read mode 
....................   Input: 
....................     stream -  Pointer to the target file 
....................   Return Values: 
....................     Non-Zero - EOF reached  
....................     0 - Not at end of File 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfeof function will indicate that the end-of- 
....................     file has been reached for the specified file by 
....................     comparing the absolute location in the file to the 
....................     size of the file. 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... int FSfeof( FSFILE * stream ); 
....................  
....................  
.................... #ifdef ALLOW_FORMATS 
.................... /******************************************************************* 
....................   Function: 
....................     int FSformat (char mode, long int serialNumber, char * volumeID) 
....................   Summary: 
....................     Formats a device 
....................   Conditions: 
....................     The device must possess a valid master boot record. 
....................   Input: 
....................     mode -          - 0 - Just erase the FAT and root 
....................                     - 1 - Create a new boot sector 
....................     serialNumber -  Serial number to write to the card 
....................     volumeID -      Name of the card 
....................   Return Values: 
....................     0 -    Format was successful 
....................     EOF -  Format was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSformat function can be used to create a new boot sector 
....................     on a device, based on the information in the master boot record. 
....................     This function will first initialize the I/O pins and the device, 
....................     and then attempts to read the master boot record.  If the MBR 
....................     cannot be loaded successfully, the function will fail.  Next, if 
....................     the 'mode' argument is specified as '0' the existing boot sector 
....................     information will be loaded.  If the 'mode' argument is '1' an 
....................     entirely new boot sector will be constructed using the disk 
....................     values from the master boot record.  Once the boot sector has 
....................     been successfully loaded/created, the locations of the FAT and 
....................     root will be loaded from it, and they will be completely 
....................     erased.  If the user has specified a volumeID parameter, a  
....................     VOLUME attribute entry will be created in the root directory 
....................     to name the device. 
....................  
....................     FAT12, FAT16 and FAT32 formatting are supported. 
....................  
....................     Based on the number of sectors, the format function automatically 
....................     compute the smallest possible value for the cluster size in order to 
....................     accommodate the physical size of the media. In this case, if a media  
....................     with a big capacity is formatted, the format function may take a very 
....................     long time to write all the FAT tables.  
....................  
....................     Therefore, the FORMAT_SECTORS_PER_CLUSTER macro may be used to  
....................     specify the exact cluster size (in multiples of sector size). This  
....................     macro can be defined in FSconfig.h 
....................  
....................   Remarks: 
....................     Only devices with a sector size of 512 bytes are supported by the  
....................     format function                       
....................   *******************************************************************/ 
....................  
.................... int FSformat (char mode, long int serialNumber, char * volumeID); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_WRITES 
.................... /*************************************************************************** 
....................   Function: 
....................     int FSattrib (FSFILE * file, unsigned char attributes) 
....................   Summary: 
....................     Change the attributes of a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     file -        Pointer to file structure 
....................     attributes -  The attributes to set for the file 
....................                -  Attribute -      Value - Indications  
....................                -  ATTR_READ_ONLY - 0x01  - The read-only attribute 
....................                -  ATTR_HIDDEN -    0x02  - The hidden attribute  
....................                -  ATTR_SYSTEM -    0x04  - The system attribute  
....................                -  ATTR_ARCHIVE -   0x20  - The archive attribute 
....................   Return Values: 
....................     0 -  Attribute change was successful  
....................     -1 - Attribute change was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSattrib funciton will set the attributes of the specified file 
....................     to the attributes passed in by the user.  This function will load the 
....................     file entry, replace the attributes with the ones specified, and write 
....................     the attributes back.  If the specified file is a directory, the 
....................     directory attribute will be preserved. 
....................   Remarks: 
....................     None                                                                 
....................   ***************************************************************************/ 
....................  
.................... int FSattrib (FSFILE * file, unsigned char attributes); 
....................  
....................  
.................... /*************************************************************** 
....................   Function: 
....................     int FSrename (const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices. 
....................     First, it will search through the current working directory to ensure the 
....................     specified new filename is not already in use. If it isn't, the new filename 
....................     will be written to the file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None                                                         
....................   ***************************************************************/ 
....................  
.................... int FSrename (const char * fileName, FSFILE * fo); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*************************************************************** 
....................   Function: 
....................     int wFSrename (const rom unsigned short int * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices. First, it will search through the current 
....................     working directory to ensure the specified new UTF16 filename is not 
....................     already in use.  If it isn't, the new filename will be written to the 
....................     file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None 
....................   ***************************************************************/ 
....................  
.................... int wFSrename (const unsigned short int * fileName, FSFILE * fo); 
.................... #endif 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     int FSremove (const char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed  
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................     The FSremove function will attempt to find the specified file with the FILEfind 
....................     function.  If the file is found, it will be erased using the FILEerase function. 
....................     The user can also provide ascii alias name of the ascii long file name as the 
....................     input to this function to get it erased from the memory. 
....................   Remarks: 
....................     None                                        
....................   **********************************************************************/ 
....................  
.................... int FSremove (const char * fileName); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     int wFSremove (const unsigned short int * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed 
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................     The wFSremove function will attempt to find the specified UTF16 file 
....................     name with the FILEfind function. If the file is found, it will be erased 
....................     using the FILEerase function. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int wFSremove (const unsigned short int * fileName); 
.................... #endif 
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Write data to a file 
....................   Conditions: 
....................     File opened in FS_WRITE, FS_APPEND, FS_WRITE+, FS_APPEND+, FS_READ+ mode 
....................   Input: 
....................     data_to_write -     Pointer to source buffer 
....................     size -              Size of units in bytes 
....................     n -                 Number of units to transfer 
....................     stream -            Pointer to file structure 
....................   Return: 
....................     size_t - number of units written 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfwrite function will write data to a file.  First, the sector that 
....................     corresponds to the current position in the file will be loaded (if it hasn't 
....................     already been cached in the global data buffer).  Data will then be written to 
....................     the device from the specified buffer until the specified amount has been written. 
....................     If the end of a cluster is reached, the next cluster will be loaded, unless 
....................     the end-of-file flag for the specified file has been set.  If it has, a new 
....................     cluster will be allocated to the file.  Finally, the new position and filesize 
....................     will be stored in the FSFILE object.  The parameters 'size' and 'n' indicate how  
....................     much data to write.  'Size' refers to the size of one object to write (in bytes),  
....................     and 'n' will refer to the number of these objects to write.  The value returned  
....................     will be equal  to 'n' unless an error occured. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************************/ 
....................  
.................... size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream); 
....................  
.................... #endif 
....................  
.................... #ifdef ALLOW_DIRS 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdir (char * path) 
....................   Summary: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC). 
....................     The FSchdir function passes a RAM pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSchdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSchdir (unsigned short int * path) 
....................   Summary: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC).The FSchdir function passes a RAM 
....................     pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSchdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************** 
....................   Function: 
....................     char * FSgetcwd (char * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in Ascii format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in Ascii format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * FSgetcwd (char * path, int numbchars); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************** 
....................   Function: 
....................     char * wFSgetcwd (unsigned short int * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in UTF16 format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in UTF16 format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * wFSgetcwd (unsigned short int * path, int numbchars); 
.................... #endif 
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdir (char * path) 
....................   Summary: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSmkdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSmkdir (unsigned short int * path) 
....................   Summary: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSmkdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdir (char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int FSrmdir (char * path, unsigned char rmsubdirs); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs) 
....................   Summary: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs); 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................  
....................  
.................... /*********************************************************************************************************** 
....................   Function: 
....................     int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second) 
....................   Summary: 
....................     Manually set timestamp variables 
....................   Conditions: 
....................     USERDEFINEDCLOCK macro defined in FSconfig.h. 
....................   Input: 
....................     year -     The year (1980\-2107) 
....................     month -   The month (1\-12) 
....................     day -     The day of the month (1\-31) 
....................     hour -    The hour (0\-23) 
....................     minute -  The minute (0\-59) 
....................     second -  The second (0\-59) 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     Modifies global timing variables 
....................   Description: 
....................     Lets the user manually set the timing variables.  The values passed in will be converted to the format 
....................     used by the FAT timestamps. 
....................   Remarks: 
....................     Call this before creating a file or directory (set create time) and 
....................     before closing a file (set last access time, last modified time)                                         
....................   ***********************************************************************************************************/ 
....................  
.................... int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_FILESEARCH 
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................     The FindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*********************************************************************************** 
....................   Function: 
....................     int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous wFindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent wFindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................     The wFindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec); 
.................... #endif 
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FindNext (SearchRec * rec) 
....................   Summary: 
....................     Sequential search function 
....................   Conditions: 
....................     None 
....................   Input: 
....................     rec -  The structure to store the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No additional files matching the specified criteria were found 
....................   Side Effects: 
....................     Search criteria from previous FindNext call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     The FindNext function performs the same function as the FindFirst 
....................     funciton, except it does not copy any search parameters into the 
....................     SearchRec structure (only info about found files) and it begins 
....................     searching at the last directory entry offset at which a file was 
....................     found, rather than at the beginning of the current working 
....................     directory.If the return value of the function is 0 then "utf16LFNfoundLength" 
....................     indicates whether the file found was long file name or short file 
....................     name(8P3 format). The "utf16LFNfoundLength" is non-zero for long file name 
....................     and is zero for 8P3 format."utf16LFNfound" points to the address of long  
....................     file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling this function 
....................   **********************************************************************/ 
....................  
.................... int FindNext (SearchRec * rec);  
.................... #endif 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int FSfprintf (FSFILE * fptr, const char * fmt, ...) 
....................     // PIC18 
....................     int FSfpritnf (FSFILE * fptr, const rom char * fmt, ...) 
....................   Summary: 
....................     Function to write formatted strings to a file 
....................   Conditions: 
....................     For PIC18, integer promotion must be enabled in the project build 
....................     options menu.  File opened in a write mode. 
....................   Input: 
....................     fptr - A pointer to the file to write to. 
....................     fmt -  A string of characters and format specifiers to write to 
....................            the file 
....................     ... -  Additional arguments inserted in the string by format 
....................            specifiers 
....................   Returns: 
....................     The number of characters written to the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Writes a specially formatted string to a file. 
....................   Remarks: 
....................     Consult AN1045 for a full description of how to use format 
....................     specifiers.         
....................   **********************************************************************/ 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................     #ifdef __18CXX 
....................         int FSfprintf (FSFILE *fptr, const rom char *fmt, ...); 
....................     #else 
....................         int FSfprintf (FSFILE *fptr, const char * fmt, ...); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSerror (void) 
....................   Summary: 
....................     Return an error code for the last function call 
....................   Conditions: 
....................     The return value depends on the last function called. 
....................   Input: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Return Values: 
....................     FSInit       -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The physical media could not be initialized 
....................                  - CE_BAD_SECTOR_READ        The MBR or the boot sector could not be 
....................                                               read correctly 
....................                  - CE_BAD_PARITION           The MBR signature code was incorrect. 
....................                  - CE_NOT_FORMATTED          The boot sector signature code was incorrect or 
....................                                               indicates an invalid number of bytes per sector.  
....................                  - CE_CARDFAT32              The physical media is FAT32 type (only an error  
....................                                               when FAT32 support is disabled).  
....................                  - CE_UNSUPPORTED_FS         The device is formatted with an unsupported file  
....................                                               system (not FAT12 or 16). 
....................     FSfopen      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The device has not been initialized.  
....................                  - CE_TOO_MANY_FILES_OPEN    The function could not allocate any  
....................                                               additional file information to the array  
....................                                               of FSFILE structures or the heap.  
....................                  - CE_INVALID_FILENAME       The file name argument was invalid. 
....................                  - CE_INVALID_ARGUMENT       The user attempted to open a directory in a  
....................                                               write mode or specified an invalid mode argument.  
....................                  - CE_FILE_NOT_FOUND         The specified file (which was to be opened in read  
....................                                               mode) does not exist on the device.  
....................                  - CE_BADCACHEREAD           A read from the device failed. 
....................                  - CE_ERASE_FAIL             The existing file could not be erased (when opening  
....................                                               a file in FS_WRITE mode).  
....................                  - CE_DIR_FULL               The directory is full.  
....................                  - CE_DISK_FULL              The data memory section is full.  
....................                  - CE_WRITE_ERROR            A write to the device failed.  
....................                  - CE_SEEK_ERROR             The current position in the file could not be set to  
....................                                               the end (when the file was opened in FS_APPEND mode). 
....................     FSfclose     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer or the new file 
....................                                               entry information could not be written to the device. 
....................                  - CE_BADCACHEREAD           The file entry information could not be cached 
....................     FSfread      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITEONLY              The file was opened in a write-only mode. 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device.  
....................                  - CE_BAD_SECTOR_READ        The data sector could not be read.  
....................                  - CE_EOF                    The end of the file was reached. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be loaded. 
....................     FSfwrite     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_READONLY               The file was opened in a read-only mode.  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected. 
....................                  - CE_WRITE_ERROR            There was an error writing data to the device. 
....................                  - CE_BADCACHEREAD           The data sector to be modified could not be read from 
....................                                               the device.  
....................                  - CE_DISK_FULL              All data clusters on the device are in use. 
....................     FSfseek      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device.  
....................                  - CE_INVALID_ARGUMENT       The specified offset exceeds the size of the file.  
....................                  - CE_BADCACHEREAD           The sector that contains the new current position  
....................                                               could not be loaded. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be  
....................                                               loaded/allocated. 
....................     FSftell      -  
....................                  - CE_GOOD                   No Error 
....................     FSattrib     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The attribute argument was invalid.  
....................                  - CE_BADCACHEREAD           The existing file entry information could not be  
....................                                               loaded.  
....................                  - CE_WRITE_ERROR            The file entry information could not be written to  
....................                                               the device. 
....................     FSrename     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_FILENOTOPENED          A null file pointer was passed into the function.  
....................                  - CE_INVALID_FILENAME       The file name passed into the function was invalid.  
....................                  - CE_BADCACHEREAD           A read from the device failed.  
....................                  - CE_FILENAME_EXISTS        A file with the specified name already exists.  
....................                  - CE_WRITE_ERROR            The new file entry data could not be written to the  
....................                                               device. 
....................     FSfeof       - 
....................                  - CE_GOOD                   No Error 
....................     FSformat     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The device could not be initialized.  
....................                  - CE_BADCACHEREAD           The master boot record or boot sector could not be  
....................                                               loaded successfully.  
....................                  - CE_INVALID_ARGUMENT       The user selected to create their own boot sector on  
....................                                               a device that has no master boot record, or the mode  
....................                                               argument was invalid.  
....................                  - CE_WRITE_ERROR            The updated MBR/Boot sector could not be written to  
....................                                               the device. 
....................                  - CE_BAD_PARTITION          The calculated number of sectors per clusters was  
....................                                               invalid.  
....................                  - CE_NONSUPPORTED_SIZE      The card has too many sectors to be formatted as  
....................                                               FAT12 or FAT16. 
....................     FSremove     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         The specified file could not be found. 
....................                  - CE_ERASE_FAIL             The file could not be erased. 
....................     FSchdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed or the user tried to  
....................                                               change to a non-directory file. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_FOUND          Could not find a directory in the path. 
....................     FSgetcwd     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The user passed a 0-length buffer into the function. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the current working directory. 
....................     FSmkdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed. 
....................                  - CE_BADCACHEREAD           Could not successfully change to a recently created  
....................                                               directory to store its dir entry information, or  
....................                                               could not cache directory entry information.  
....................                  - CE_INVALID_FILENAME       One or more of the directory names has an invalid  
....................                                               format.  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device or the dot/dotdot entries could  
....................                                               not be written to a newly created directory. 
....................                  - CE_DIR_FULL               There are no available dir entries in the CWD. 
....................                  - CE_DISK_FULL              There are no available clusters in the data region of  
....................                                               the device.     
....................     FSrmdir      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_DIR_NOT_FOUND          The directory specified could not be found or the  
....................                                               function could not change to a subdirectory within  
....................                                               the directory to be deleted (when recursive delete is  
....................                                               enabled). 
....................                  - CE_INVALID_ARGUMENT       The user tried to remove the CWD or root directory.  
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_EMPTY          The directory to be deleted was not empty and  
....................                                               recursive subdirectory removal was disabled.  
....................                  - CE_ERASE_FAIL             The directory or one of the directories or files  
....................                                               within it could not be deleted.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the CWD. 
....................     SetClockVars - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The time values passed into the function were  
....................                                               invalid.     
....................     FindFirst    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found.  
....................                  - CE_BADCACHEREAD           The file information for the file that was found  
....................                                               could not be cached. 
....................     FindNext     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The SearchRec object was not initialized by a call to  
....................                                               FindFirst.  
....................                  - CE_INVALID_ARGUMENT       The SearchRec object was initialized in a different  
....................                                               directory from the CWD. 
....................                  - CE_INVALID_FILENAME       The filename is invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found. 
....................     FSfprintf    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            Characters could not be written to the file.                                                    
....................   Description: 
....................     The FSerror function will return the FSerrno variable.  This global 
....................     variable will have been set to an error value during the last call of a 
....................     library function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... int FSerror (void); 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     int FSCreateMBR (unsigned long firstSector, unsigned long numSectors) 
....................   Summary: 
....................     Creates a master boot record 
....................   Conditions: 
....................     The I/O pins for the device have been initialized by the InitIO function. 
....................   Input: 
....................     firstSector -  The first sector of the partition on the device (cannot 
....................                    be 0; that's the MBR) 
....................     numSectors -   The number of sectors available in memory (including the 
....................                    MBR) 
....................   Return Values: 
....................     0 -   MBR was created successfully 
....................     EOF - MBR could not be created 
....................   Side Effects: 
....................     None 
....................   Description:   
....................     This function can be used to create a master boot record for a device.  Note 
....................     that this function should not be used on a device that is already formatted 
....................     with a master boot record (i.e. most SD cards, CF cards, USB keys).  This 
....................     function will fill the global data buffer with appropriate partition information 
....................     for a FAT partition with a type determined by the number of sectors available 
....................     to the partition.  It will then write the MBR information to the first sector 
....................     on the device.  This function should be followed by a call to FSformat, which 
....................     will create a boot sector, root dir, and FAT appropriate the the information 
....................     contained in the new master boot record.  Note that FSformat only supports 
....................     FAT12 and FAT16 formatting at this time, and so cannot be used to format a 
....................     device with more than 0x3FFD5F sectors. 
....................   Remarks: 
....................     This function can damage the device being used, and should not be called 
....................     unless the user is sure about the size of the device and the first sector value. 
....................   *********************************************************************************/ 
....................  
.................... int FSCreateMBR (unsigned long firstSector, unsigned long numSectors); 
....................  
....................  
.................... #ifdef ALLOW_GET_DISK_PROPERTIES 
.................... /********************************************************************************* 
....................   Function: 
....................     void FSGetDiskProperties(FS_DISK_PROPERTIES* properties) 
....................   Summary: 
....................     Allows user to get the disk properties (size of disk, free space, etc) 
....................   Conditions: 
....................     1) ALLOW_GET_DISK_PROPERTIES must be defined in FSconfig.h 
....................     2) a FS_DISK_PROPERTIES object must be created before the function is called 
....................     3) the new_request member of the FS_DISK_PROPERTIES object must be set before 
....................         calling the function for the first time.  This will start a new search. 
....................     4) this function should not be called while there is a file open.  Close all 
....................         files before calling this function. 
....................   Input: 
....................     properties - a pointer to a FS_DISK_PROPERTIES object where the results should 
....................       be stored. 
....................   Return Values: 
....................     This function returns void.  The properties_status of the previous call of  
....................       this function is located in the properties.status field.  This field has  
....................       the following possible values: 
....................  
....................     FS_GET_PROPERTIES_NO_ERRORS - operation completed without error.  Results 
....................       are in the properties object passed into the function. 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED - there is no mounted disk.  Results in 
....................       properties object is not valid 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE - there was a failure trying to read a  
....................       cluster from the drive.  The results in the properties object is a partial 
....................       result up until the point of the failure. 
....................     FS_GET_PROPERTIES_STILL_WORKING - the search for free sectors is still in 
....................       process.  Continue calling this function with the same properties pointer  
....................       until either the function completes or until the partial results meets the 
....................       application needs.  The properties object contains the partial results of 
....................       the search and can be used by the application.   
....................   Side Effects: 
....................     Can cause errors if called when files are open.  Close all files before 
....................     calling this function. 
....................  
....................     Calling this function without setting the new_request member on the first 
....................     call can result in undefined behavior and results. 
....................  
....................     Calling this function after a result is returned other than 
....................     FS_GET_PROPERTIES_STILL_WORKING can result in undefined behavior and results. 
....................   Description:   
....................     This function returns the information about the mounted drive.  The results  
....................     member of the properties object passed into the function is populated with  
....................     the information about the drive.     
....................  
....................     Before starting a new request, the new_request member of the properties 
....................     input parameter should be set to TRUE.  This will initiate a new search 
....................     request. 
....................  
....................     This function will return before the search is complete with partial results. 
....................     All of the results except the free_clusters will be correct after the first 
....................     call.  The free_clusters will contain the number of free clusters found up 
....................     until that point, thus the free_clusters result will continue to grow until 
....................     the entire drive is searched.  If an application only needs to know that a  
....................     certain number of bytes is available and doesn't need to know the total free  
....................     size, then this function can be called until the required free size is 
....................     verified.  To continue a search, pass a pointer to the same FS_DISK_PROPERTIES 
....................     object that was passed in to create the search. 
....................  
....................     A new search request sould be made once this function has returned a value  
....................     other than FS_GET_PROPERTIES_STILL_WORKING.  Continuing a completed search 
....................     can result in undefined behavior or results. 
....................  
....................     Typical Usage: 
....................     <code> 
....................     FS_DISK_PROPERTIES disk_properties; 
....................  
....................     disk_properties.new_request = TRUE; 
....................  
....................     do 
....................     { 
....................         FSGetDiskProperties(&disk_properties); 
....................     } while (disk_properties.properties_status == FS_GET_PROPERTIES_STILL_WORKING); 
....................     </code> 
....................  
....................     results.disk_format - contains the format of the drive.  Valid results are  
....................       FAT12(1), FAT16(2), or FAT32(3). 
....................  
....................     results.sector_size - the sector size of the mounted drive.  Valid values are 
....................       512, 1024, 2048, and 4096. 
....................  
....................     results.sectors_per_cluster - the number sectors per cluster. 
....................  
....................     results.total_clusters - the number of total clusters on the drive.  This  
....................       can be used to calculate the total disk size (total_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................     results.free_clusters - the number of free (unallocated) clusters on the drive. 
....................       This can be used to calculate the total free disk size (free_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................   Remarks: 
....................     PIC24F size estimates: 
....................       Flash - 400 bytes (-Os setting) 
....................  
....................     PIC24F speed estimates: 
....................       Search takes approximately 7 seconds per Gigabyte of drive space.  Speed 
....................         will vary based on the number of sectors per cluster and the sector size. 
....................   *********************************************************************************/ 
.................... void FSGetDiskProperties(FS_DISK_PROPERTIES* properties); 
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE FILEget_next_cluster(FSFILE *fo, DWORD n) 
....................   Summary: 
....................     Step through a chain of clusters 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fo - The file to get the next cluster of 
....................     n -  Number of links in the FAT cluster chain to jump through 
....................   Return Values: 
....................     CE_GOOD - Operation successful 
....................     CE_BAD_SECTOR_READ - A bad read occured of a sector 
....................     CE_INVALID_CLUSTER - Invalid cluster value \> maxcls 
....................     CE_FAT_EOF - Fat attempt to read beyond EOF 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will load 'n' proximate clusters for a file from 
....................     the FAT on the device.  It will stop checking for clusters if the 
....................     ReadFAT function returns an error, if it reaches the last cluster in 
....................     a file, or if the device tries to read beyond the last cluster used 
....................     by the device. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... BYTE FILEget_next_cluster(FSFILE *fo, DWORD n); 
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //   #use fast_io(ALL) 
....................  
....................  //  #use delay(clock=32M) 
.................... //#use delay( crystal=8mhz, clock=32mhz ) 
....................  
....................  //  #pin_select U1TX = PIN_D5 
.................... //   #pin_select U1RX = PIN_D4 
....................     
....................    //hardwareprofile.h is using spi2 for sd card, so pin select those 
....................   // #pin_select SDI2 = PIN_F5 
....................   // #pin_select SDO2 = PIN_B15 
....................   // #pin_select SCK2OUT = PIN_F4 
....................  
....................    #pin_select SDI1 = PIN_F6 
....................    #pin_select SDO1 = PIN_F2 
....................    #pin_select SCK1OUT = PIN_F3 
....................  
....................  
....................  
.................... //   #pin_select SDI2 = PIN_F6 
.................... //   #pin_select SDO2 = PIN_F2 
.................... //   #pin_select SCK2OUT = PIN_F3 
....................  
....................    #define AN_HOST_VOLTAGE 2 
....................    #define AN_POT          0 
....................  
.................... //   #define MY_ANALOG_PORTS (sAN2 | sAN0) 
....................     
.................... //   #define MY_ADC_SETUP    (ADC_CLOCK_INTERNAL|ADC_TAD_MUL_2) 
....................     
....................    #use rs232(UART1, baud=9600, stream=STREAM_USER_UART) 
....................    #define PIN_SDPOWER  PIN_G9 
....................    #define PIN_LED1  PIN_B11 
....................    #define PIN_LED2  PIN_B10 
....................    #define PIN_LED3  PIN_B9 
....................  
....................    #define GREEN_LED    PIN_B11 
....................    #define YELLOW_LED   PIN_B10 
....................    #define RED_LED      PIN_B9 
....................     
....................    #define LED_ON(x)    output_high(x) 
....................    #define LED_OFF(x)   output_low(x) 
....................     
....................    #define BUTTON_PRESSED()   !input(PIN_F0) 
.................... #endif 
....................  
.................... #if defined(__DEBUG_UART) 
....................    // these are microchip's style debugs 
....................    #define InitUART() 
....................    #define PrintROMASCIIStringUART(s)  fprintf(STREAM_USER_UART, s) 
....................    void PrintRAMBytesUART(char *p, unsigned int16 n)  
....................    { 
....................       while(n--) 
....................       { 
....................          fprintf(STREAM_USER_UART, "%X ", *p++); 
....................       } 
....................    } 
....................    #define UARTSendLineFeedCarriageReturn() fprintf(STREAM_USER_UART, "\r\n") 
.................... #endif 
....................  
.................... #if 0 
....................    #warning CCS Debugs Enabled 
....................     
....................   #if defined(__PCH__)  //uart1 
....................    #bit UART_TBE=getenv("BIT:TX1IF") 
....................    //#define WAIT_FOR_TX()   while(!UART_TBE) 
....................    #define WAIT_FOR_TX() 
....................   #else  //uart2 
....................    #word U2STA=getenv("SFR:U2STA") 
....................    #bit U2STA_TRMT=U2STA.8 
....................    #define UART_TBE  U2STA_TRMT 
....................    #define WAIT_FOR_TX()   while(!UART_TBE) 
....................   #endif 
....................        
....................    // application level debugs 
....................    #define DEBUG_STR(str, x) printf("\r\n"); printf("%s", str); printf(" 0x%LX", x); WAIT_FOR_TX() 
....................    #define DEBUG_STR2(str1, str2) printf("\r\n%s '%s'", str1, str2); WAIT_FOR_TX() 
....................     
....................    // library level debugs 
....................    #define DEBUG_FS_STR(str, x) printf("\r\n"); printf("%s", str); printf(" 0x%LX", x); WAIT_FOR_TX() 
....................    #define DEBUG_FS_STR2(str1, str2) printf("\r\n%s '%s'", str1, str2); WAIT_FOR_TX() 
....................     
....................    void DEBUG_FS_ARRAY(unsigned int8 *p, unsigned int16 len) 
....................    { 
....................       unsigned int16 i=0; 
....................       while(i < len) 
....................       { 
....................          if ((i%32) == 0) 
....................             printf("\r\n0x%LX: ", i); 
....................          printf("%02X", *p++); 
....................          i++; 
....................       } 
....................    } 
.................... #endif 
....................  
.................... #if defined(DEBUG_STR) 
.................... #include <pcd_traps.c> 
.................... #endif 
....................  
.................... #ifndef HW_INIT 
.................... #define HW_INIT() 
.................... #endif 
....................  
.................... //#if defined(__PCD__) 
.................... #if 0 
....................    #define DEBUG_SPI()  printf("\r\n0x260=%LX 0x262=%LX 0x264=%LX\r\n", (unsigned int16*)*0x260, (unsigned int16*)*0x262, (unsigned int16*)*0x264); 
.................... #else 
....................    #define DEBUG_SPI() 
.................... #endif 
....................  
.................... // disable application level debug macros if not defined 
.................... #ifndef DEBUG_STR 
....................  #define DEBUG_STR(str, x) 
....................  #define DEBUG_STR2(str1, str2) 
.................... #endif 
....................  
.................... // disable library level debug macros if not defined 
.................... #ifndef DEBUG_FS_STR 
....................  #define DEBUG_FS_STR(str, x) 
....................  #define DEBUG_FS_STR2(str1, str2) 
....................  #define DEBUG_FS_ARRAY(p, len) 
.................... #endif 
....................  
.................... #if defined(__USE_MDD_BOOTLOADER__) 
.................... #include "ex_mdd_boot.h" 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "filesystem\filesystem.c" 
.................... //see about.txt in filesystem/ for information 
....................  
.................... #ifndef __FILESYSTEM_C__ 
.................... #define __FILESYSTEM_C__ 
....................  
.................... #include "FSConfig.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSconfig.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Dependencies:    None 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _FS_DEF_ 
.................... #define _FS_DEF_ 
....................  
.................... //#include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // something to do with long filenames. 
.................... //#define SUPPORT_LFN 
....................  
.................... // Summary: A macro indicating the maximum number of concurrently open files 
.................... // Description: The FS_MAX_FILES_OPEN #define is only applicable when dynamic memory allocation is not used (FS_DYNAMIC_MEM is not defined). 
.................... //              This macro defines the maximum number of open files at any given time.  The amount of RAM used by FSFILE objects will 
.................... //              be equal to the size of an FSFILE object multipled by this macro value.  This value should be kept as small as possible 
.................... //              as dictated by the application.  This will reduce memory usage. 
.................... #define FS_MAX_FILES_OPEN    1 
....................  
....................  
.................... // if defined, MDD will be configured to use SST25 flash device. this definition 
.................... // should also define the size of the SST25 flash device. 
.................... // if not defined, will use SD card. 
.................... // #define  USE_SST25_INTERFACE  ((unsigned int32)2*1024*1024) 
....................  
.................... // Summary: A macro defining the size of a sector 
.................... // Description: The MEDIA_SECTOR_SIZE macro will define the size of a sector on the FAT file system.  This value must equal 512 bytes, 
.................... //              1024 bytes, 2048 bytes, or 4096 bytes.  The value of a sector will usually be 512 bytes. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define MEDIA_SECTOR_SIZE       4096   //erase size of SST25 flash device 
.................... #else 
.................... #define MEDIA_SECTOR_SIZE       512 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* *******************************************************************************************************/ 
.................... /************** Compiler options to enable/Disable Features based on user's application ******************/ 
.................... /* *******************************************************************************************************/ 
....................  
....................  
.................... // Summary: A macro to enable/disable file search functions. 
.................... // Description: The ALLOW_FILESEARCH definition can be commented out to disable file search functions in the library.  This will 
.................... //              prevent the use of the FindFirst and FindNext functions and reduce code size. 
.................... #define ALLOW_FILESEARCH 
....................  
.................... // Summary: A macro to enable/disable write functionality 
.................... // Description: The ALLOW_WRITES definition can be commented out to disable all operations that write to the device.  This will 
.................... //              greatly reduce code size. 
.................... #define ALLOW_WRITES 
....................  
....................  
.................... // Summary: A macro to enable/disable format functionality 
.................... // Description: The ALLOW_FORMATS definition can be commented out to disable formatting functionality.  This will prevent the use of 
.................... //              the FSformat function.  If formats are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define ALLOW_FORMATS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable directory operations. 
.................... // Description: The ALLOW_DIRS definition can be commented out to disable all directory functionality.  This will reduce code size. 
.................... //              If directories are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES in order to use 
.................... //              the FSmkdir or FSrmdir functions. 
.................... #define ALLOW_DIRS 
....................  
.................... // Summary: A macro to enable/disable PIC18 ROM functions. 
.................... // Description: The ALLOW_PGMFUNCTIONS definition can be commented out to disable all PIC18 functions that allow the user to pass string 
.................... //              arguments in ROM (denoted by the suffix -pgm).  Note that this functionality must be disabled when not using PIC18. 
.................... #if !defined(__CCS__) 
.................... #define ALLOW_PGMFUNCTIONS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable the FSfprintf function. 
.................... // Description: The ALLOW_FSFPRINTF definition can be commented out to disable the FSfprintf function.  This will save code space.  Note that 
.................... //              if FSfprintf is enabled and the PIC18 architecture is used, integer promotions must be enabled in the Project->Build Options 
.................... //              menu.  Write operations must be enabled to use FSfprintf. 
.................... //#define ALLOW_FSFPRINTF 
....................  
.................... // CCS added this config option to disable FAT12 to prevent recursion. 
.................... //__CCS__ added by ccs 
.................... //#define SUPPORT_FAT12 
....................  
.................... // Summary: A macro to enable/disable FAT32 support. 
.................... // Description: The SUPPORT_FAT32 definition can be commented out to disable support for FAT32 functionality.  This will save a small amount 
.................... //              of code space. 
.................... #define SUPPORT_FAT32 
....................  
....................  
....................  
.................... /**************************************************************************************************/ 
.................... // Select a method for updating file timestamps 
.................... /**************************************************************************************************/ 
....................  
.................... // Summary: A macro to enable RTCC based timestamp generation 
.................... // Description: The USEREALTIMECLOCK macro will configure the code to automatically 
.................... //              generate timestamp information for files from the RTCC module. The user 
.................... //              must enable and configure the RTCC module before creating or modifying 
.................... //              files.                                                                  
.................... //#define USEREALTIMECLOCK 
....................  
.................... // Summary: A macro to enable manual timestamp generation 
.................... // Description: The USERDEFINEDCLOCK macro will allow the user to manually set 
.................... //              timestamp information using the SetClockVars function. The user will 
.................... //              need to set the time variables immediately before creating or closing a 
.................... //              file or directory.                                                     
.................... #define USERDEFINEDCLOCK 
....................  
.................... // Summary: A macro to enable don't-care timestamp generation 
.................... // Description: The INCREMENTTIMESTAMP macro will set the create time of a file to a 
.................... //              static value and increment it when a file is updated. This timestamp 
.................... //              generation method should only be used in applications where file times 
.................... //              are not necessary.                                                     
.................... //#define INCREMENTTIMESTAMP 
....................  
....................  
.................... #ifdef __18CXX 
....................    #ifdef USEREALTIMECLOCK 
....................       #error Not all PIC18 devices have a Real-time clock and calander module 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    #ifndef __18CXX 
....................       #error The pgm functions are unneccessary when not using PIC18 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef USEREALTIMECLOCK 
....................     #ifndef USERDEFINEDCLOCK 
....................         #ifndef INCREMENTTIMESTAMP 
....................             #error Please enable USEREALTIMECLOCK, USERDEFINEDCLOCK, or INCREMENTTIMESTAMP 
....................         #endif 
....................     #endif 
.................... #endif 
....................  
.................... /************************************************************************/ 
.................... // Set this preprocessor option to '1' to use dynamic FSFILE object allocation.  It will 
.................... // be necessary to allocate a heap when dynamically allocating FSFILE objects. 
.................... // Set this option to '0' to use static FSFILE object allocation. 
.................... /************************************************************************/ 
....................  
.................... //#if 1  //from mirochip 
.................... #if defined(__PCH__) //__CCS__ 
....................     // Summary: A macro indicating that FSFILE objects will be allocated dynamically 
....................     // Description: The FS_DYNAMIC_MEM macro will cause FSFILE objects to be allocated from a dynamic heap.  If it is undefined, 
....................     //              the file objects will be allocated using a static array. 
....................    //#define FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................         // Description: Function pointer to a dynamic memory allocation function 
....................       #define FS_malloc   SRAMalloc 
....................         // Description: Function pointer to a dynamic memory free function 
....................       #define FS_free      SRAMfree 
....................    #else 
....................       #define FS_malloc   malloc 
....................       #define FS_free      free 
....................    #endif 
.................... #elif defined(__CCS__) 
....................    #error/warning Not using FS_DYNAMIC_MEM for PCD compiler 
.................... #endif 
....................  
....................  
.................... #ifdef __18CXX 
....................     /* Define the locations for the dataBuffer and FATbuffer; PLEASE CHECK THE LINKER FILE */ 
....................     #define DATA_BUFFER_ADDRESS      0x700 
....................     #define FAT_BUFFER_ADDRESS       0x900 
.................... #endif 
....................  
....................  
.................... // Function definitions 
.................... // Associate the physical layer functions with the correct physical layer 
.................... #ifdef USE_SD_INTERFACE_WITH_SPI       // SD-SPI.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_SDSPI_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_SDSPI_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_SDSPI_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_SDSPI_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_SDSPI_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_SDSPI_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_SDSPI_WriteProtectState 
....................  
....................     // Description: Function pointer to the Read Capacity Physical Layer function 
....................     #define MDD_ReadCapacity        MDD_SDSPI_ReadCapacity 
....................  
....................     // Description: Function pointer to the Read Sector Size Physical Layer Function 
....................     #define MDD_ReadSectorSize      MDD_SDSPI_ReadSectorSize 
....................  
.................... #elif defined USE_CF_INTERFACE_WITH_PMP       // CF-PMP.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFPMP_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFPMP_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFPMP_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFPMP_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFPMP_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFPMP_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFPMP_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFPMP_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFPMP_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFPMP_CFread 
....................  
.................... #elif defined USE_MANUAL_CF_INTERFACE         // CF-Bit transaction.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFBT_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFBT_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFBT_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFBT_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFBT_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFBT_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFBT_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFBT_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFBT_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFBT_CFread 
....................  
.................... #elif defined USE_USB_INTERFACE               // USB host MSD library 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     USBHostMSDSCSIMediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         USBHostMSDSCSIMediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          USBHostMSDSCSISectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         USBHostMSDSCSISectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO();               
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       USBHostMSDSCSIMediaReset 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   USBHostMSDSCSIWriteProtectState 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #if defined(USE_SST25_INTERFACE) 
.................... #include "sst25vf_mdd.c" 
.................... #endif 
....................  
.................... #if defined(FS_DYNAMIC_MEM) 
....................  #if defined(__PCH__) 
....................   #include "salloc.c" 
....................  #else 
....................   #include <stdlibm.h> 
....................  #endif 
.................... #endif 
....................  
.................... #include "fsio.c" 
.................... /****************************************************************************** 
.................... * 
.................... *               Microchip Memory Disk Drive File System 
.................... * 
.................... ****************************************************************************** 
.................... * FileName:           FSIO.c 
.................... * Dependencies:       GenericTypeDefs.h 
.................... *                     FSIO.h 
.................... *                     Physical interface include file (SD-SPI.h, CF-PMP.h, ...) 
.................... *                     string.h 
.................... *                     stdlib.h 
.................... *                     FSDefs.h 
.................... *                     ctype.h 
.................... *                     salloc.h 
.................... * Processor:          PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
.................... * Compiler:           C18/C30/C32 
.................... * Company:            Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * The software supplied herewith by Microchip Technology Incorporated 
.................... * (the Company) for its PICmicro Microcontroller is intended and 
.................... * supplied to you, the Companys customer, for use solely and 
.................... * exclusively on Microchip PICmicro Microcontroller products. The 
.................... * software is owned by the Company and/or its supplier, and is 
.................... * protected under applicable copyright laws. All rights are reserved. 
.................... * Any use in violation of the foregoing restrictions may subject the 
.................... * user to criminal sanctions under applicable laws, as well as to 
.................... * civil liability for the breach of the terms and conditions of this 
.................... * license. 
.................... * 
.................... * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
.................... * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
.................... * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
.................... * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
.................... * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
.................... * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
.................... * 
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev     Description 
....................   -----   ----------- 
....................   1.2.5   Fixed bug that prevented writes to alternate FAT tables 
....................           Fixed bug that prevented FAT being updated when media is re-inserted 
....................  
....................   1.2.6   Fixed bug that resulted in a bus error when attempts to read a invalid memory region 
....................           Fixed bug that prevented the Windows Explorer to show the Date Creation field for directories 
....................  
....................   x.x.x   Fixed issue on some USB drives where the information written 
....................             to the drive is cached in a RAM for 500ms before it is 
....................             written to the flash unless the sector is accessed again. 
....................           Add some error recovery for FAT32 systems when there is 
....................             corruption in the boot sector. 
....................  
....................   1.3.0   Modified to support Long File Name(LFN) format 
....................   1.3.4   1) Initialized some of the local variables to default values 
....................              to remove non-critical compiler warnings for code sanitation. 
....................           2) The sector size of the media device is obtained from the MBR of media.So, 
....................              instead of using the hard coded macro "DIRENTRIES_PER_SECTOR", the variables 
....................              "dirEntriesPerSector" & "disk->sectorSize" are used in the code. Refer 
....................              "Cache_File_Entry","EraseCluster" & "writeDotEntries" fucntions to see 
....................              the change. 
....................   1.3.6   1) The function "FILEget_next_cluster" is made public. 
....................           2) Modified "FILEfind" function such that when using 8.3 format 
....................              the file searches are not considered as case sensitive. 
....................           3) In function 'CacheTime', the variables 'ptr1' & 'ptr0' are not used 
....................              when compiled for PIC32. So there definitions were removed for PIC32. 
....................           4) Modified "rmdirhelper", "FormatDirName" & "writeDotEntries" functions 
....................              to remove non-critical warnings during compilation. 
....................           5) Updated comments in most of the function header blocks. 
....................   1.4.0   1) While creating files in LFN format with file name length as 13,26,39,52...etc(multiples of 13), 
....................              MDD library was creating incorrect directory entries. To fix this issue, 
....................              functions "FILEfind", "CreateFileEntry", "Alias_LFN_Object", "FormatFileName", 
....................              "FormatDirName", "FSgetcwd", "GetPreviousEntry" & "rmdirhelper" were modified. 
....................              Now "utf16LFNlength" variable part of "FSFILE" structure, indicates LFN length 
....................              excluding the NULL word at the last. 
....................           2) When creating large number of files in LFN format, some files were not getting created in disk. 
....................              To fix this issue,function "FILEfind" was modified. 
....................           3) Modified "FSformat" function to initialize "disk->sectorSize" to default value. 
....................           4) Modified "CreateFileEntry" & "FindEmptyEntries" functions to remove unnecessary 
....................              assignments & optimize the code. 
....................           5) Modified "FSfopen" function to prevent creating an empty file in the directory, when SD card 
....................              is write protected. 
....................           6) Variable "entry" in "writeDotEntries" function is made volatile & properly typecasted 
....................              in it's usage. 
....................           7) Modified "FSFopen" function so that when you try to open a file that doesn't exist on the disk, 
....................              variable "FSerrno" is assigned to CE_FILE_NOT_FOUND. 
....................   1.4.2   1) Minor Modification in "CreateFileEntry" function to fix a bug for file name lengths of 
....................              26,39....characters (multiples of 13) 
....................           2) Fixed the LoadMBR() function to scan all of the MBR entries and return success on the first 
....................              supported drive or fail after the 4 table entries. 
.................... ********************************************************************/ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *					dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *					Microchip C30 v3.01 or higher 
....................  *					Microchip C18 v3.13 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006	Original, copied from old Compiler.h 
....................  * 11/07/2007	Reorganized and simplified 
....................  * 03/31/2010	Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__PCH__) 
....................    #include <p18cxxx.h> 
.................... #elif defined(__PCD__) 
....................    #include <..\CCSIncludes\PCDxxxx.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... // pcdxxxx.h 
.................... // 
.................... // Microchip C30 to CCS conversion library. 
....................  
.................... #ifndef __PCDXXXX_H__ 
.................... #define __PCDXXXX_H__ 
....................  
.................... #case 
....................  
.................... #include "ccspics.h" 
....................  
.................... //#device PSV=16 
....................  
.................... //#if defined(__CONST_IS_READONLY__) 
.................... //   #device CONST=READ_ONLY 
.................... //#else 
.................... //   //this is normally how C30 operates 
.................... //   #device CONST=ROM 
.................... //#endif 
....................  
.................... //#device PASS_STRINGS=IN_RAM 
....................  
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #zero_ram 
.................... #zero_local_ram 
....................  
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
.................... #undef BYTE 
.................... #endif 
....................  
.................... #if defined(BOOLEAN) 
.................... #undef BOOLEAN 
.................... #endif 
....................  
.................... #define GetSystemClock()       getenv("CLOCK") 
.................... #define GetInstructionClock()  (GetSystemClock()/2) 
.................... #define GetPeripheralClock()   (GetSystemClock()/2) 
....................  
.................... //#define Reset()            reset_cpu()   //not needed, this is defined in Microchip's Compiler.h 
.................... //#define FAR                        //not needed, this is defined in Microchip's Compiler.h 
....................  
.................... #define ClrWdt()         restart_wdt() 
....................  
.................... #define Nop()            delay_cycles(1) 
....................  
.................... //#warning need eds support 
.................... #define __eds__ 
....................  
.................... #define __prog__  rom 
....................  
.................... #define __C30__ 
....................  
.................... #define __CCS_STDLIB_DYNAMIC_MEMORY__ 
....................  
.................... #endif 
....................  
.................... #elif defined(__18CXX) && !defined(HI_TECH_C)	 
.................... 	// PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)	 
.................... 	// PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
.................... 	#if !defined(__18CXX) 
.................... 		#define __18CXX 
.................... 	#endif 
....................     #define COMPILER_HITECH_PICC18 
.................... 	#include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p30fxxxx.h> 
.................... #elif defined(__C30__)		// Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p30sim.h> 
.................... 	// Define some useful inline assembly functions which are normally in the  
.................... 	// processor header files, but absent from the generic p30sim.h file. 
.................... 	#if !defined(Nop) 
.................... 		#define Nop()    __builtin_nop() 
.................... 		#define ClrWdt() {__asm__ volatile ("clrwdt");} 
.................... 		#define Sleep()  {__asm__ volatile ("pwrsav #0");} 
.................... 		#define Idle()   {__asm__ volatile ("pwrsav #1");} 
.................... 	#endif 
.................... #elif defined(__PIC32MX__)	// Microchip C32 compiler 
.................... 	#if !defined(__C32__) 
.................... 		#define __C32__ 
.................... 	#endif 
....................     #define COMPILER_MPLAB_C32 
.................... 	#include <p32xxxx.h> 
.................... 	#include <plib.h> 
.................... #else 
.................... 	#error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = beg; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PIC32MX__) 
.................... 	#define PTR_BASE		unsigned long 
.................... 	#define ROM_PTR_BASE	unsigned long 
.................... #elif defined(__C30__) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
.................... 	#define memcmppgm2ram(a,b,c)	memcmp(a,b,c) 
.................... 	#define strcmppgm2ram(a,b)		strcmp(a,b) 
.................... 	#define memcpypgm2ram(a,b,c)	memcpy(a,b,c) 
.................... 	#define strcpypgm2ram(a,b)		strcpy(a,b) 
.................... 	#define strncpypgm2ram(a,b,c)	strncpy(a,b,c) 
.................... 	#define strstrrampgm(a,b)		strstr(a,b) 
.................... 	#define	strlenpgm(a)			strlen(a) 
.................... 	#define strchrpgm(a,b)			strchr(a,b) 
.................... 	#define strcatpgm2ram(a,b)		strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
.................... 	#define	__attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
.................... 	// Microchip C18 specific defines 
.................... 	#if defined(COMPILER_MPLAB_C18) 
.................... 	    #define ROM                 	rom 
.................... 	#endif 
.................... 	 
.................... 	// HI TECH PICC-18 specific defines 
.................... 	#if defined(COMPILER_HITECH_PICC18) 
.................... 	    #define ROM                 	const 
.................... 		#define rom 
.................... 	    #define Nop()               	asm("NOP"); 
.................... 		#define ClrWdt()				asm("CLRWDT"); 
.................... 	    #define Reset()					asm("RESET"); 
.................... 	#endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
.................... 	#define	ROM						const 
....................  
.................... 	// 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
.................... 	#if defined(__C30__) 
.................... 		#define Reset()				asm("reset") 
....................         #define FAR                 __attribute__((far)) 
.................... 	#endif 
....................  
.................... 	// 32-bit specific defines (PIC32) 
.................... 	#if defined(__PIC32MX__) 
.................... 		#define persistent 
.................... 		#define far 
....................         #define FAR 
.................... 		#define Reset()				SoftReset() 
.................... 		#define ClrWdt()			(WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
.................... 		// MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
.................... 		// Nop() function. However, version 1.05 has Nop() declared as _nop(). 
.................... 		#if !defined(Nop) && (__C32_VERSION__ <= 104) 
.................... 			#define Nop()				asm("nop") 
.................... 		#endif 
.................... 	#endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "MDD File System/FSIO.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSIO.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  *                  FSconfig.h 
....................  *                  FSDefs.h 
....................  *                  stddef.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.4.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  FS_DOT_H 
.................... #define  FS_DOT_H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... #include "../FSconfig.h" 
.................... #include "FSDefs.h"  
.................... #include "stddef.h" 
....................  
.................... #ifdef USE_SD_INTERFACE_WITH_SPI 
....................     #include    "SD-SPI.h" 
.................... #endif 
.................... #ifdef USE_CF_INTERFACE_WITH_PMP 
....................     #include    "CF-PMP.h" 
.................... #endif 
.................... #ifdef USE_MANUAL_CF_INTERFACE 
....................     #include    "CF- Bit transaction.h" 
.................... #endif 
.................... #ifdef USE_USB_INTERFACE 
....................     #include    "usb_host_msd_scsi.h" 
.................... #endif 
.................... #ifdef USE_INTERNAL_FLASH 
....................     #include    "Internal Flash.h" 
.................... #endif 
....................  
....................  
.................... /*******************************************************************/ 
.................... /*                     Strunctures and defines                     */ 
.................... /*******************************************************************/ 
....................  
.................... #ifndef FALSE 
....................     // Summary: False value 
....................     // Description:  This macro will indicate that a condition is false. 
....................     #define FALSE   0 
.................... #endif 
.................... #ifndef TRUE 
....................     // Summary: True value 
....................     // Description: This macro will indicate that a condition is true. 
....................     #define TRUE    !FALSE  // True value 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #ifndef SEEK_SET 
....................     // Summary: Macro for the FSfseek SEEK_SET base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed  
....................     //              relative to the beginning of the file. 
....................     #define SEEK_SET 0 
....................  
.................... #endif 
.................... #ifndef SEEK_CUR 
....................  
....................     // Summary: Macro for the FSfseek SEEK_CUR base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the current location of the file 
....................     #define SEEK_CUR 1 
....................  
.................... #endif 
.................... #ifndef SEEK_END 
....................  
....................     // Summary: Macro for the FSfseek SEEK_END base location 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the end of the file.  For this macro, the offset value will be subtracted from 
....................     //              the end location of the file by default. 
....................     #define SEEK_END 2 
....................  
.................... #endif 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file. 
.................... #define FS_APPEND   "a" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file. 
.................... #define FS_WRITE    "w" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file. 
.................... #define FS_READ "r" 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file 
.................... //              or read from the file. 
.................... #define FS_APPENDPLUS   "a+" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file or read from the file. 
.................... #define FS_WRITEPLUS    "w+" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file or write to the file. 
.................... #define FS_READPLUS     "r+" 
....................  
.................... #ifndef intmax_t 
....................     #ifdef __PIC24F__ 
....................         // Summary: A data type indicating the maximum integer size in an architecture 
....................         // Description: The intmax_t data type refers to the maximum-sized data type on any given architecture.  This 
....................         //              data type can be specified as a format specifier size specification for the FSfprintf function. 
....................         #define intmax_t long long 
....................     #elif defined __PIC24H__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC30F__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC33F__ 
....................         #define intmax_t long long 
....................     #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary:  Indicates flag conditions for a file object 
.................... // Description: The FILEFLAGS structure is used to indicate conditions in a file.  It contains three flags: 'write' indicates 
.................... //              that the file was opened in a mode that allows writes, 'read' indicates that the file was opened in a mode 
.................... //              that allows reads, and 'FileWriteEOF' indicates that additional data that is written to the file will increase 
.................... //              the file size. 
.................... typedef struct 
.................... { 
....................     unsigned    write :1;           // Indicates a file was opened in a mode that allows writes 
....................     unsigned    read :1;            // Indicates a file was opened in a mode that allows reads 
....................     unsigned    FileWriteEOF :1;    // Indicates the current position in a file is at the end of the file 
.................... }FILEFLAGS; 
....................  
....................  
....................  
.................... // Summary: Indicates how to search for file entries in the FILEfind function 
.................... // Description: The values in the SEARCH_TYPE enumeration are used internally by the library to indicate how the FILEfind function 
.................... //              how to perform a search.  The 'LOOK_FOR_EMPTY_ENTRY' value indicates that FILEfind should search for an empty file entry. 
.................... //              The 'LOOK_FOR_MATCHING_ENTRY' value indicates that FILEfind should search for an entry that matches the FSFILE object 
.................... //              that was passed into the FILEfind function. 
.................... typedef enum{ 
....................     LOOK_FOR_EMPTY_ENTRY = 0, 
....................     LOOK_FOR_MATCHING_ENTRY 
.................... } SEARCH_TYPE; 
....................  
....................  
....................  
.................... // Summary: Macro indicating the length of a 8.3 file name 
.................... // Description: The TOTAL_FILE_SIZE_8P3 macro indicates the maximum number of characters in an 8.3 file name.  This value includes 
.................... //              8 characters for the name, three for the extentsion, and 1 for the radix ('.') 
.................... #define TOTAL_FILE_SIZE_8P3             (8+3+1) 
.................... #define TOTAL_FILE_SIZE                 TOTAL_FILE_SIZE_8P3 
....................  
.................... // Summary: Macro indicating the max length of a LFN file name 
.................... // Description: The MAX_FILE_NAME_LENGTH_LFN macro indicates the maximum number of characters in an LFN file name. 
.................... #define MAX_FILE_NAME_LENGTH_LFN             256 
....................  
.................... // Summary: A mask that indicates the limit of directory entries in a sector 
.................... // Description: The MASK_MAX_FILE_ENTRY_LIMIT_BITS is used to indicate to the Cache_File_Entry function that a new sector needs to 
.................... //              be loaded. 
.................... #define MASK_MAX_FILE_ENTRY_LIMIT_BITS          0x0f 
....................  
.................... // Summary: Value used for shift operations to calculate the sector offset in a directory 
.................... // Description: The VALUE_BASED_ON_ENTRIES_PER_CLUSTER macro is used to calculate sector offsets for directories.  The position of the 
.................... //              entry is shifted by 4 bits (divided by 16, since there are 16 entries in a sector) to calculate how many sectors a 
.................... //              specified entry is offset from the beginning of the directory. 
.................... #define VALUE_BASED_ON_ENTRIES_PER_CLUSTER      4 
....................  
.................... // Summary: A value that will indicate that a dotdot directory entry points to the root. 
.................... // Description: The VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT macro is used as an absolute address when writing information to a dotdot entry 
.................... //              in a newly created directory.  If a dotdot entry points to the root directory, it's cluster value must be set to 0, 
.................... //              regardless of the actual cluster number of the root directory. 
.................... #define VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT     0 
....................  
.................... // Summary: MAcro indicating the length of an 8.3 file name in a directory entry 
.................... // Description: The FILE_NAME_SIZE_8P3 macro indicates the number of characters that an 8.3 file name will take up when packed in 
.................... //              a directory entry.  This value includes 8 characters for the name and 3 for the extension.  Note that the radix is not 
.................... //              stored in the directory entry. 
.................... #define FILE_NAME_SIZE_8P3           11 
.................... #define FILE_NAME_SIZE               FILE_NAME_SIZE_8P3 
....................  
....................  
.................... // Summary: Contains file information and is used to indicate which file to access. 
.................... // Description: The FSFILE structure is used to hold file information for an open file as it's being modified or accessed.  A pointer to  
.................... //              an open file's FSFILE structure will be passeed to any library function that will modify that file. 
.................... typedef struct 
.................... { 
....................     DISK    *       dsk;            // Pointer to a DISK structure 
....................     DWORD           cluster;        // The first cluster of the file 
....................     DWORD           ccls;           // The current cluster of the file 
....................     WORD            sec;            // The current sector in the current cluster of the file 
....................     WORD            pos;            // The position in the current sector 
....................     DWORD           seek;           // The absolute position in the file 
....................     DWORD           size;           // The size of the file 
....................     FILEFLAGS       flags;          // A structure containing file flags 
....................     WORD            time;           // The file's last update time 
....................     WORD            date;           // The file's last update date 
....................     char            name[FILE_NAME_SIZE_8P3];       // The short name of the file 
....................    #ifdef SUPPORT_LFN 
....................        BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNptr;           // Pointer to long file name in UTF16 format 
....................       unsigned short int utf16LFNlength;          // LFN length in terms of words excluding the NULL word at the last. 
....................    #endif 
....................     WORD            entry;          // The position of the file's directory entry in it's directory 
....................     WORD            chk;            // File structure checksum 
....................     WORD            attributes;     // The file attributes 
....................     DWORD           dirclus;        // The base cluster of the file's directory 
....................     DWORD           dirccls;        // The current cluster of the file's directory 
.................... } FSFILE; 
....................  
.................... /* Summary: Possible results of the FSGetDiskProperties() function. 
.................... ** Description: See the FSGetDiskProperties() function for more information. 
.................... */ 
.................... typedef enum 
.................... { 
....................     FS_GET_PROPERTIES_NO_ERRORS = 0, 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED, 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE, 
....................     FS_GET_PROPERTIES_STILL_WORKING = 0xFF 
.................... } FS_DISK_ERRORS; 
....................  
....................  
.................... /* Summary: Contains the disk search information, intermediate values, and results 
.................... ** Description: This structure is used in conjunction with the FSGetDiskProperties() 
.................... **              function.  See that function for more information about the usage. 
.................... */ 
.................... typedef struct 
.................... { 
....................     DISK *  disk;           /* pointer to the disk we are searching */ 
....................     BOOL    new_request;    /* is this a new request or a continued request */ 
....................     FS_DISK_ERRORS properties_status;  /* status of the last call of the function */ 
....................  
....................     struct 
....................     { 
....................         BYTE disk_format;           /* disk format: FAT12, FAT16, FAT32 */ 
....................         WORD sector_size;           /* sector size of the drive */ 
....................         BYTE sectors_per_cluster;   /* number of sectors per cluster */ 
....................         DWORD total_clusters;       /* the number of total clusters on the drive */ 
....................         DWORD free_clusters;        /* the number of free (unused) clusters on drive */ 
....................     } results;                      /* the results of the current search */ 
....................  
....................     struct 
....................     { 
....................         DWORD   c;      
....................         DWORD   curcls; 
....................         DWORD   EndClusterLimit; 
....................         DWORD   ClusterFailValue; 
....................     } private;      /* intermediate values used to continue searches.  This 
....................                          member should be used only by the FSGetDiskProperties() 
....................                          function */ 
....................  
.................... } FS_DISK_PROPERTIES; 
....................  
.................... // Summary: A structure used for searching for files on a device. 
.................... // Description: The SearchRec structure is used when searching for file on a device.  It contains parameters that will be loaded with 
.................... //              file information when a file is found.  It also contains the parameters that the user searched for, allowing further 
.................... //              searches to be perfomed in the same directory for additional files that meet the specified criteria. 
.................... typedef struct 
.................... { 
....................     char            filename[FILE_NAME_SIZE_8P3 + 2];   // The name of the file that has been found 
....................     unsigned char   attributes;                     // The attributes of the file that has been found 
....................     unsigned long   filesize;                       // The size of the file that has been found 
....................     unsigned long   timestamp;                      // The last modified time of the file that has been found (create time for directories) 
....................    #ifdef SUPPORT_LFN 
....................       BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNfound;          // Pointer to long file name found in UTF16 format 
....................       unsigned short int utf16LFNfoundLength;     // LFN Found length in terms of words including the NULL word at the last. 
....................    #endif 
....................     unsigned int    entry;                          // The directory entry of the last file found that matches the specified attributes. (Internal use only) 
....................     char            searchname[FILE_NAME_SIZE_8P3 + 2]; // The 8.3 format name specified when the user began the search. (Internal use only) 
....................     unsigned char   searchattr;                     // The attributes specified when the user began the search. (Internal use only) 
....................     unsigned long   cwdclus;                        // The directory that this search was performed in. (Internal use only) 
....................     unsigned char   initialized;                    // Check to determine if the structure was initialized by FindFirst (Internal use only) 
.................... } SearchRec; 
....................  
....................  
.................... /*************************************************************************** 
.................... * Prototypes                                                               * 
.................... ***************************************************************************/ 
....................  
....................  
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     int FSInit(void) 
....................   Summary: 
....................     Function to initialize the device. 
....................   Conditions: 
....................     The physical device should be connected to the microcontroller. 
....................   Input: 
....................     None 
....................   Return Values: 
....................     TRUE -  Initialization successful 
....................     FALSE - Initialization unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function initializes the file system stack & the interfacing device. 
....................     Initializes the static or dynamic memory slots for holding file 
....................     structures. Initializes the device with the DISKmount function. Loads  
....................     MBR and boot sector information. Initializes the current working 
....................     directory to the root directory for the device if directory support 
....................     is enabled. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... int FSInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * FSfopen (const char * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with ascii input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will open a ascii name file or directory on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * FSfopen(const char * fileName, const char *mode); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * wFSfopen (const unsigned short int * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * wFSfopen(const unsigned short int * fileName, const char *mode); 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................  
.................... /****************************************************************************** 
....................   Function: 
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode) 
....................   Summary: 
....................     Opens a file on PIC18 Microcontrollers where 'fileName' ROM string is given 
....................     in Ascii format. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to be opened (ROM) 
....................     mode -      The mode the file will be opened in (ROM) 
....................   Return Values: 
....................     FSFILE * - A pointer to the file object 
....................     NULL -     File could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file on PIC18 Microcontrollers where 'fileName' ROM string 
....................     is given in Ascii format.The FSfopenpgm function will copy a PIC18 ROM fileName and 
....................     mode argument into RAM arrays, and then pass those arrays to the FSfopen function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   ******************************************************************************/ 
....................  
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode); 
....................  
....................  
.................... /************************************************************************************** 
....................   Function: 
....................     int FindFirstpgm (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Find a file named with a ROM string on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName -  The name of the file to be found (ROM) 
....................     attr -      The attributes of the file to be found 
....................     rec -       Pointer to a search record to store the file info in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the given parameters was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirstpgm call on passed SearchRec object 
....................     will be lost.The FSerrno variable will be changed. 
....................   Description: 
....................     This function finds a file named with 'fileName' on PIC18. The FindFirstpgm 
....................     function will copy a PIC18 ROM fileName argument into a RAM array, and then 
....................     pass that array to the FindFirst function. 
....................   Remarks: 
....................     Call FindFirstpgm or FindFirst before calling FindNext. 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************************/ 
....................  
....................     int FindFirstpgm (const rom char * fileName, unsigned int attr, SearchRec * rec); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdirpgm (const rom char * path) 
....................   Summary: 
....................     Changes the CWD to the input path on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to (ROM) 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the CWD to the input path on PIC18.The FSchdirpgm function 
....................     passes a PIC18 ROM path pointer to the chdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM 
....................   **************************************************************************/ 
....................  
....................     int FSchdirpgm (const rom char * path); 
....................  
....................     #ifdef ALLOW_WRITES 
....................  
....................  
.................... /************************************************************* 
....................   Function: 
....................     int FSremovepgm (const rom char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC18 device 
....................   Conditions: 
....................     File not opened; file exists 
....................   Input: 
....................     fileName -  The name of the file to be deleted (ROM) 
....................   Return Values: 
....................     0 -  File was removed successfully 
....................     -1 - File could not be removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC18 device.The FSremovepgm function will copy a 
....................     PIC18 ROM fileName argument into a RAM array, and then pass that array 
....................     to the FSremove function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   *************************************************************/ 
....................  
....................         int FSremovepgm (const rom char * fileName); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdirpgm (const rom char * path) 
....................   Summary: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create (ROM) 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices.'FSmkdirpgm' creates the directories as per the input 
....................     string path.This function doesn't move the current working 
....................     directory setting. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arugments in ROM 
....................   **************************************************************************/ 
....................  
....................         int FSmkdirpgm (const rom char * path); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdirpgm (const rom char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     path -      The path of the directory to remove (ROM) 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................     This function deletes the directory as specified in the path. 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************/ 
....................  
....................         int FSrmdirpgm (const rom char * path, unsigned char rmsubdirs); 
....................  
....................  
.................... /***************************************************************** 
....................   Function: 
....................     int FSrenamepgm(const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the file with the ascii ROM string(PIC18) 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file (in ROM) 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -  File renamed successfully 
....................     -1 - File could not be renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the file with the ascii ROM string(PIC18).The Fsrenamepgm 
....................     function will copy the rom fileName specified by the user into a  
....................     RAM array and pass that array into the FSrename function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM.                        
....................   *****************************************************************/ 
....................  
....................         int FSrenamepgm (const rom char * fileName, FSFILE * fo); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************ 
....................   Function: 
....................     int FSfclose(FSFILE *fo) 
....................   Summary: 
....................     Update file information and free FSFILE objects 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to the file to close 
....................   Return Values: 
....................     0 -   File closed successfully  
....................     EOF - Error closing the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will update the directory entry for the  
....................     file pointed to by 'fo' with the information contained 
....................     in 'fo,' including the new file size and attributes. 
....................     Timestamp information will also be loaded based on the 
....................     method selected by the user and written to the entry 
....................     as the last modified time and date.  The file entry will 
....................     then be written to the device.  Finally, the memory 
....................     used for the specified file object will be freed from 
....................     the dynamic heap or the array of FSFILE objects. 
....................   Remarks: 
....................     A function to flush data to the device without closing the 
....................     file can be created by removing the portion of this 
....................     function that frees the memory and the line that clears 
....................     the write flag. 
....................   ************************************************************/ 
....................  
.................... int FSfclose(FSFILE *fo); 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     void FSrewind (FSFILE * fo) 
....................   Summary: 
....................     Set the current position in a file to the beginning 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The FSrewind funciton will reset the position of the 
....................     specified file to the beginning of the file.  This 
....................     functionality is faster than using FSfseek to reset 
....................     the position in the file. 
....................   Remarks: 
....................     None. 
....................   *********************************************************/ 
....................  
.................... void FSrewind (FSFILE *fo); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Read data from a file 
....................   Conditions: 
....................     File is opened in a read mode 
....................   Input: 
....................     ptr -     Destination buffer for read bytes 
....................     size -    Size of units in bytes 
....................     n -       Number of units to be read 
....................     stream -  File to be read from 
....................   Return: 
....................     size_t - number of units read 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfread function will read data from the specified file.  First, 
....................     the appropriate sector of the file is loaded.  Then, data is read into 
....................     the specified buffer until the specified number of bytes have been read. 
....................     When a cluster boundary is reached, a new cluster will be loaded.  The 
....................     parameters 'size' and 'n' indicate how much data to read.  'Size' 
....................     refers to the size of one object to read (in bytes), and 'n' will refer  
....................     to the number of these objects to read.  The value returned will be equal  
....................     to 'n' unless an error occured or the user tried to read beyond the end 
....................     of the file. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream); 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FSfseek(FSFILE *stream, long offset, int whence) 
....................   Summary: 
....................     Change the current position in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     stream -    Pointer to file structure 
....................     offset -    Offset from base location 
....................     whence -     
....................            - SEEK_SET -  Seek from start of file 
....................            - SEEK_CUR -  Seek from current location 
....................            - SEEK_END -  Seek from end of file (subtract offset) 
....................   Return Values: 
....................     0 -  Operation successful  
....................     -1 - Operation unsuccesful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfseek function will change the current position in the file to 
....................     one specified by the user.  First, an absolute offset is calculated 
....................     using the offset and base location passed in by the user.  Then, the 
....................     position variables are updated, and the sector number that corresponds 
....................     to the new location.  That sector is then loaded.  If the offset 
....................     falls exactly on a cluster boundary, a new cluster will be allocated 
....................     to the file and the position will be set to the first byte of that 
....................     cluster. 
....................   Remarks: 
....................     None                                                                
....................   **********************************************************************/ 
....................  
.................... int FSfseek(FSFILE *stream, long offset, int whence); 
....................  
....................  
.................... /******************************************************************* 
....................   Function: 
....................     long FSftell (FSFILE * fo) 
....................   Summary: 
....................     Determine the current location in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return: Current location in the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     The FSftell function will return the current position in the 
....................     file pointed to by 'fo' by returning the 'seek' variable in the 
....................     FSFILE object, which is used to keep track of the absolute 
....................     location of the current position in the file. 
....................   Remarks: 
....................     None                                                             
....................   *******************************************************************/ 
....................  
.................... long FSftell(FSFILE *fo); 
....................  
....................  
.................... /**************************************************** 
....................   Function: 
....................     int FSfeof( FSFILE * stream ) 
....................   Summary: 
....................     Indicate whether the current file position is at the end 
....................   Conditions: 
....................     File is open in a read mode 
....................   Input: 
....................     stream -  Pointer to the target file 
....................   Return Values: 
....................     Non-Zero - EOF reached  
....................     0 - Not at end of File 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfeof function will indicate that the end-of- 
....................     file has been reached for the specified file by 
....................     comparing the absolute location in the file to the 
....................     size of the file. 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... int FSfeof( FSFILE * stream ); 
....................  
....................  
.................... #ifdef ALLOW_FORMATS 
.................... /******************************************************************* 
....................   Function: 
....................     int FSformat (char mode, long int serialNumber, char * volumeID) 
....................   Summary: 
....................     Formats a device 
....................   Conditions: 
....................     The device must possess a valid master boot record. 
....................   Input: 
....................     mode -          - 0 - Just erase the FAT and root 
....................                     - 1 - Create a new boot sector 
....................     serialNumber -  Serial number to write to the card 
....................     volumeID -      Name of the card 
....................   Return Values: 
....................     0 -    Format was successful 
....................     EOF -  Format was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSformat function can be used to create a new boot sector 
....................     on a device, based on the information in the master boot record. 
....................     This function will first initialize the I/O pins and the device, 
....................     and then attempts to read the master boot record.  If the MBR 
....................     cannot be loaded successfully, the function will fail.  Next, if 
....................     the 'mode' argument is specified as '0' the existing boot sector 
....................     information will be loaded.  If the 'mode' argument is '1' an 
....................     entirely new boot sector will be constructed using the disk 
....................     values from the master boot record.  Once the boot sector has 
....................     been successfully loaded/created, the locations of the FAT and 
....................     root will be loaded from it, and they will be completely 
....................     erased.  If the user has specified a volumeID parameter, a  
....................     VOLUME attribute entry will be created in the root directory 
....................     to name the device. 
....................  
....................     FAT12, FAT16 and FAT32 formatting are supported. 
....................  
....................     Based on the number of sectors, the format function automatically 
....................     compute the smallest possible value for the cluster size in order to 
....................     accommodate the physical size of the media. In this case, if a media  
....................     with a big capacity is formatted, the format function may take a very 
....................     long time to write all the FAT tables.  
....................  
....................     Therefore, the FORMAT_SECTORS_PER_CLUSTER macro may be used to  
....................     specify the exact cluster size (in multiples of sector size). This  
....................     macro can be defined in FSconfig.h 
....................  
....................   Remarks: 
....................     Only devices with a sector size of 512 bytes are supported by the  
....................     format function                       
....................   *******************************************************************/ 
....................  
.................... int FSformat (char mode, long int serialNumber, char * volumeID); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_WRITES 
.................... /*************************************************************************** 
....................   Function: 
....................     int FSattrib (FSFILE * file, unsigned char attributes) 
....................   Summary: 
....................     Change the attributes of a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     file -        Pointer to file structure 
....................     attributes -  The attributes to set for the file 
....................                -  Attribute -      Value - Indications  
....................                -  ATTR_READ_ONLY - 0x01  - The read-only attribute 
....................                -  ATTR_HIDDEN -    0x02  - The hidden attribute  
....................                -  ATTR_SYSTEM -    0x04  - The system attribute  
....................                -  ATTR_ARCHIVE -   0x20  - The archive attribute 
....................   Return Values: 
....................     0 -  Attribute change was successful  
....................     -1 - Attribute change was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSattrib funciton will set the attributes of the specified file 
....................     to the attributes passed in by the user.  This function will load the 
....................     file entry, replace the attributes with the ones specified, and write 
....................     the attributes back.  If the specified file is a directory, the 
....................     directory attribute will be preserved. 
....................   Remarks: 
....................     None                                                                 
....................   ***************************************************************************/ 
....................  
.................... int FSattrib (FSFILE * file, unsigned char attributes); 
....................  
....................  
.................... /*************************************************************** 
....................   Function: 
....................     int FSrename (const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices. 
....................     First, it will search through the current working directory to ensure the 
....................     specified new filename is not already in use. If it isn't, the new filename 
....................     will be written to the file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None                                                         
....................   ***************************************************************/ 
....................  
.................... int FSrename (const char * fileName, FSFILE * fo); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*************************************************************** 
....................   Function: 
....................     int wFSrename (const rom unsigned short int * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices. First, it will search through the current 
....................     working directory to ensure the specified new UTF16 filename is not 
....................     already in use.  If it isn't, the new filename will be written to the 
....................     file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None 
....................   ***************************************************************/ 
....................  
.................... int wFSrename (const unsigned short int * fileName, FSFILE * fo); 
.................... #endif 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     int FSremove (const char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed  
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................     The FSremove function will attempt to find the specified file with the FILEfind 
....................     function.  If the file is found, it will be erased using the FILEerase function. 
....................     The user can also provide ascii alias name of the ascii long file name as the 
....................     input to this function to get it erased from the memory. 
....................   Remarks: 
....................     None                                        
....................   **********************************************************************/ 
....................  
.................... int FSremove (const char * fileName); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     int wFSremove (const unsigned short int * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed 
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................     The wFSremove function will attempt to find the specified UTF16 file 
....................     name with the FILEfind function. If the file is found, it will be erased 
....................     using the FILEerase function. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int wFSremove (const unsigned short int * fileName); 
.................... #endif 
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Write data to a file 
....................   Conditions: 
....................     File opened in FS_WRITE, FS_APPEND, FS_WRITE+, FS_APPEND+, FS_READ+ mode 
....................   Input: 
....................     data_to_write -     Pointer to source buffer 
....................     size -              Size of units in bytes 
....................     n -                 Number of units to transfer 
....................     stream -            Pointer to file structure 
....................   Return: 
....................     size_t - number of units written 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfwrite function will write data to a file.  First, the sector that 
....................     corresponds to the current position in the file will be loaded (if it hasn't 
....................     already been cached in the global data buffer).  Data will then be written to 
....................     the device from the specified buffer until the specified amount has been written. 
....................     If the end of a cluster is reached, the next cluster will be loaded, unless 
....................     the end-of-file flag for the specified file has been set.  If it has, a new 
....................     cluster will be allocated to the file.  Finally, the new position and filesize 
....................     will be stored in the FSFILE object.  The parameters 'size' and 'n' indicate how  
....................     much data to write.  'Size' refers to the size of one object to write (in bytes),  
....................     and 'n' will refer to the number of these objects to write.  The value returned  
....................     will be equal  to 'n' unless an error occured. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************************/ 
....................  
.................... size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream); 
....................  
.................... #endif 
....................  
.................... #ifdef ALLOW_DIRS 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdir (char * path) 
....................   Summary: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC). 
....................     The FSchdir function passes a RAM pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSchdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSchdir (unsigned short int * path) 
....................   Summary: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC).The FSchdir function passes a RAM 
....................     pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSchdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************** 
....................   Function: 
....................     char * FSgetcwd (char * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in Ascii format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in Ascii format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * FSgetcwd (char * path, int numbchars); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************** 
....................   Function: 
....................     char * wFSgetcwd (unsigned short int * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in UTF16 format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in UTF16 format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * wFSgetcwd (unsigned short int * path, int numbchars); 
.................... #endif 
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdir (char * path) 
....................   Summary: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSmkdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSmkdir (unsigned short int * path) 
....................   Summary: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSmkdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdir (char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int FSrmdir (char * path, unsigned char rmsubdirs); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs) 
....................   Summary: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs); 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................  
....................  
.................... /*********************************************************************************************************** 
....................   Function: 
....................     int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second) 
....................   Summary: 
....................     Manually set timestamp variables 
....................   Conditions: 
....................     USERDEFINEDCLOCK macro defined in FSconfig.h. 
....................   Input: 
....................     year -     The year (1980\-2107) 
....................     month -   The month (1\-12) 
....................     day -     The day of the month (1\-31) 
....................     hour -    The hour (0\-23) 
....................     minute -  The minute (0\-59) 
....................     second -  The second (0\-59) 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     Modifies global timing variables 
....................   Description: 
....................     Lets the user manually set the timing variables.  The values passed in will be converted to the format 
....................     used by the FAT timestamps. 
....................   Remarks: 
....................     Call this before creating a file or directory (set create time) and 
....................     before closing a file (set last access time, last modified time)                                         
....................   ***********************************************************************************************************/ 
....................  
.................... int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_FILESEARCH 
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................     The FindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*********************************************************************************** 
....................   Function: 
....................     int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous wFindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent wFindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................     The wFindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec); 
.................... #endif 
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FindNext (SearchRec * rec) 
....................   Summary: 
....................     Sequential search function 
....................   Conditions: 
....................     None 
....................   Input: 
....................     rec -  The structure to store the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No additional files matching the specified criteria were found 
....................   Side Effects: 
....................     Search criteria from previous FindNext call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     The FindNext function performs the same function as the FindFirst 
....................     funciton, except it does not copy any search parameters into the 
....................     SearchRec structure (only info about found files) and it begins 
....................     searching at the last directory entry offset at which a file was 
....................     found, rather than at the beginning of the current working 
....................     directory.If the return value of the function is 0 then "utf16LFNfoundLength" 
....................     indicates whether the file found was long file name or short file 
....................     name(8P3 format). The "utf16LFNfoundLength" is non-zero for long file name 
....................     and is zero for 8P3 format."utf16LFNfound" points to the address of long  
....................     file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling this function 
....................   **********************************************************************/ 
....................  
.................... int FindNext (SearchRec * rec);  
.................... #endif 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int FSfprintf (FSFILE * fptr, const char * fmt, ...) 
....................     // PIC18 
....................     int FSfpritnf (FSFILE * fptr, const rom char * fmt, ...) 
....................   Summary: 
....................     Function to write formatted strings to a file 
....................   Conditions: 
....................     For PIC18, integer promotion must be enabled in the project build 
....................     options menu.  File opened in a write mode. 
....................   Input: 
....................     fptr - A pointer to the file to write to. 
....................     fmt -  A string of characters and format specifiers to write to 
....................            the file 
....................     ... -  Additional arguments inserted in the string by format 
....................            specifiers 
....................   Returns: 
....................     The number of characters written to the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Writes a specially formatted string to a file. 
....................   Remarks: 
....................     Consult AN1045 for a full description of how to use format 
....................     specifiers.         
....................   **********************************************************************/ 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................     #ifdef __18CXX 
....................         int FSfprintf (FSFILE *fptr, const rom char *fmt, ...); 
....................     #else 
....................         int FSfprintf (FSFILE *fptr, const char * fmt, ...); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSerror (void) 
....................   Summary: 
....................     Return an error code for the last function call 
....................   Conditions: 
....................     The return value depends on the last function called. 
....................   Input: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Return Values: 
....................     FSInit       -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The physical media could not be initialized 
....................                  - CE_BAD_SECTOR_READ        The MBR or the boot sector could not be 
....................                                               read correctly 
....................                  - CE_BAD_PARITION           The MBR signature code was incorrect. 
....................                  - CE_NOT_FORMATTED          The boot sector signature code was incorrect or 
....................                                               indicates an invalid number of bytes per sector.  
....................                  - CE_CARDFAT32              The physical media is FAT32 type (only an error  
....................                                               when FAT32 support is disabled).  
....................                  - CE_UNSUPPORTED_FS         The device is formatted with an unsupported file  
....................                                               system (not FAT12 or 16). 
....................     FSfopen      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The device has not been initialized.  
....................                  - CE_TOO_MANY_FILES_OPEN    The function could not allocate any  
....................                                               additional file information to the array  
....................                                               of FSFILE structures or the heap.  
....................                  - CE_INVALID_FILENAME       The file name argument was invalid. 
....................                  - CE_INVALID_ARGUMENT       The user attempted to open a directory in a  
....................                                               write mode or specified an invalid mode argument.  
....................                  - CE_FILE_NOT_FOUND         The specified file (which was to be opened in read  
....................                                               mode) does not exist on the device.  
....................                  - CE_BADCACHEREAD           A read from the device failed. 
....................                  - CE_ERASE_FAIL             The existing file could not be erased (when opening  
....................                                               a file in FS_WRITE mode).  
....................                  - CE_DIR_FULL               The directory is full.  
....................                  - CE_DISK_FULL              The data memory section is full.  
....................                  - CE_WRITE_ERROR            A write to the device failed.  
....................                  - CE_SEEK_ERROR             The current position in the file could not be set to  
....................                                               the end (when the file was opened in FS_APPEND mode). 
....................     FSfclose     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer or the new file 
....................                                               entry information could not be written to the device. 
....................                  - CE_BADCACHEREAD           The file entry information could not be cached 
....................     FSfread      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITEONLY              The file was opened in a write-only mode. 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device.  
....................                  - CE_BAD_SECTOR_READ        The data sector could not be read.  
....................                  - CE_EOF                    The end of the file was reached. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be loaded. 
....................     FSfwrite     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_READONLY               The file was opened in a read-only mode.  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected. 
....................                  - CE_WRITE_ERROR            There was an error writing data to the device. 
....................                  - CE_BADCACHEREAD           The data sector to be modified could not be read from 
....................                                               the device.  
....................                  - CE_DISK_FULL              All data clusters on the device are in use. 
....................     FSfseek      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device.  
....................                  - CE_INVALID_ARGUMENT       The specified offset exceeds the size of the file.  
....................                  - CE_BADCACHEREAD           The sector that contains the new current position  
....................                                               could not be loaded. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be  
....................                                               loaded/allocated. 
....................     FSftell      -  
....................                  - CE_GOOD                   No Error 
....................     FSattrib     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The attribute argument was invalid.  
....................                  - CE_BADCACHEREAD           The existing file entry information could not be  
....................                                               loaded.  
....................                  - CE_WRITE_ERROR            The file entry information could not be written to  
....................                                               the device. 
....................     FSrename     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_FILENOTOPENED          A null file pointer was passed into the function.  
....................                  - CE_INVALID_FILENAME       The file name passed into the function was invalid.  
....................                  - CE_BADCACHEREAD           A read from the device failed.  
....................                  - CE_FILENAME_EXISTS        A file with the specified name already exists.  
....................                  - CE_WRITE_ERROR            The new file entry data could not be written to the  
....................                                               device. 
....................     FSfeof       - 
....................                  - CE_GOOD                   No Error 
....................     FSformat     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The device could not be initialized.  
....................                  - CE_BADCACHEREAD           The master boot record or boot sector could not be  
....................                                               loaded successfully.  
....................                  - CE_INVALID_ARGUMENT       The user selected to create their own boot sector on  
....................                                               a device that has no master boot record, or the mode  
....................                                               argument was invalid.  
....................                  - CE_WRITE_ERROR            The updated MBR/Boot sector could not be written to  
....................                                               the device. 
....................                  - CE_BAD_PARTITION          The calculated number of sectors per clusters was  
....................                                               invalid.  
....................                  - CE_NONSUPPORTED_SIZE      The card has too many sectors to be formatted as  
....................                                               FAT12 or FAT16. 
....................     FSremove     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         The specified file could not be found. 
....................                  - CE_ERASE_FAIL             The file could not be erased. 
....................     FSchdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed or the user tried to  
....................                                               change to a non-directory file. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_FOUND          Could not find a directory in the path. 
....................     FSgetcwd     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The user passed a 0-length buffer into the function. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the current working directory. 
....................     FSmkdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed. 
....................                  - CE_BADCACHEREAD           Could not successfully change to a recently created  
....................                                               directory to store its dir entry information, or  
....................                                               could not cache directory entry information.  
....................                  - CE_INVALID_FILENAME       One or more of the directory names has an invalid  
....................                                               format.  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device or the dot/dotdot entries could  
....................                                               not be written to a newly created directory. 
....................                  - CE_DIR_FULL               There are no available dir entries in the CWD. 
....................                  - CE_DISK_FULL              There are no available clusters in the data region of  
....................                                               the device.     
....................     FSrmdir      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_DIR_NOT_FOUND          The directory specified could not be found or the  
....................                                               function could not change to a subdirectory within  
....................                                               the directory to be deleted (when recursive delete is  
....................                                               enabled). 
....................                  - CE_INVALID_ARGUMENT       The user tried to remove the CWD or root directory.  
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_EMPTY          The directory to be deleted was not empty and  
....................                                               recursive subdirectory removal was disabled.  
....................                  - CE_ERASE_FAIL             The directory or one of the directories or files  
....................                                               within it could not be deleted.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the CWD. 
....................     SetClockVars - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The time values passed into the function were  
....................                                               invalid.     
....................     FindFirst    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found.  
....................                  - CE_BADCACHEREAD           The file information for the file that was found  
....................                                               could not be cached. 
....................     FindNext     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The SearchRec object was not initialized by a call to  
....................                                               FindFirst.  
....................                  - CE_INVALID_ARGUMENT       The SearchRec object was initialized in a different  
....................                                               directory from the CWD. 
....................                  - CE_INVALID_FILENAME       The filename is invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found. 
....................     FSfprintf    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            Characters could not be written to the file.                                                    
....................   Description: 
....................     The FSerror function will return the FSerrno variable.  This global 
....................     variable will have been set to an error value during the last call of a 
....................     library function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... int FSerror (void); 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     int FSCreateMBR (unsigned long firstSector, unsigned long numSectors) 
....................   Summary: 
....................     Creates a master boot record 
....................   Conditions: 
....................     The I/O pins for the device have been initialized by the InitIO function. 
....................   Input: 
....................     firstSector -  The first sector of the partition on the device (cannot 
....................                    be 0; that's the MBR) 
....................     numSectors -   The number of sectors available in memory (including the 
....................                    MBR) 
....................   Return Values: 
....................     0 -   MBR was created successfully 
....................     EOF - MBR could not be created 
....................   Side Effects: 
....................     None 
....................   Description:   
....................     This function can be used to create a master boot record for a device.  Note 
....................     that this function should not be used on a device that is already formatted 
....................     with a master boot record (i.e. most SD cards, CF cards, USB keys).  This 
....................     function will fill the global data buffer with appropriate partition information 
....................     for a FAT partition with a type determined by the number of sectors available 
....................     to the partition.  It will then write the MBR information to the first sector 
....................     on the device.  This function should be followed by a call to FSformat, which 
....................     will create a boot sector, root dir, and FAT appropriate the the information 
....................     contained in the new master boot record.  Note that FSformat only supports 
....................     FAT12 and FAT16 formatting at this time, and so cannot be used to format a 
....................     device with more than 0x3FFD5F sectors. 
....................   Remarks: 
....................     This function can damage the device being used, and should not be called 
....................     unless the user is sure about the size of the device and the first sector value. 
....................   *********************************************************************************/ 
....................  
.................... int FSCreateMBR (unsigned long firstSector, unsigned long numSectors); 
....................  
....................  
.................... #ifdef ALLOW_GET_DISK_PROPERTIES 
.................... /********************************************************************************* 
....................   Function: 
....................     void FSGetDiskProperties(FS_DISK_PROPERTIES* properties) 
....................   Summary: 
....................     Allows user to get the disk properties (size of disk, free space, etc) 
....................   Conditions: 
....................     1) ALLOW_GET_DISK_PROPERTIES must be defined in FSconfig.h 
....................     2) a FS_DISK_PROPERTIES object must be created before the function is called 
....................     3) the new_request member of the FS_DISK_PROPERTIES object must be set before 
....................         calling the function for the first time.  This will start a new search. 
....................     4) this function should not be called while there is a file open.  Close all 
....................         files before calling this function. 
....................   Input: 
....................     properties - a pointer to a FS_DISK_PROPERTIES object where the results should 
....................       be stored. 
....................   Return Values: 
....................     This function returns void.  The properties_status of the previous call of  
....................       this function is located in the properties.status field.  This field has  
....................       the following possible values: 
....................  
....................     FS_GET_PROPERTIES_NO_ERRORS - operation completed without error.  Results 
....................       are in the properties object passed into the function. 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED - there is no mounted disk.  Results in 
....................       properties object is not valid 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE - there was a failure trying to read a  
....................       cluster from the drive.  The results in the properties object is a partial 
....................       result up until the point of the failure. 
....................     FS_GET_PROPERTIES_STILL_WORKING - the search for free sectors is still in 
....................       process.  Continue calling this function with the same properties pointer  
....................       until either the function completes or until the partial results meets the 
....................       application needs.  The properties object contains the partial results of 
....................       the search and can be used by the application.   
....................   Side Effects: 
....................     Can cause errors if called when files are open.  Close all files before 
....................     calling this function. 
....................  
....................     Calling this function without setting the new_request member on the first 
....................     call can result in undefined behavior and results. 
....................  
....................     Calling this function after a result is returned other than 
....................     FS_GET_PROPERTIES_STILL_WORKING can result in undefined behavior and results. 
....................   Description:   
....................     This function returns the information about the mounted drive.  The results  
....................     member of the properties object passed into the function is populated with  
....................     the information about the drive.     
....................  
....................     Before starting a new request, the new_request member of the properties 
....................     input parameter should be set to TRUE.  This will initiate a new search 
....................     request. 
....................  
....................     This function will return before the search is complete with partial results. 
....................     All of the results except the free_clusters will be correct after the first 
....................     call.  The free_clusters will contain the number of free clusters found up 
....................     until that point, thus the free_clusters result will continue to grow until 
....................     the entire drive is searched.  If an application only needs to know that a  
....................     certain number of bytes is available and doesn't need to know the total free  
....................     size, then this function can be called until the required free size is 
....................     verified.  To continue a search, pass a pointer to the same FS_DISK_PROPERTIES 
....................     object that was passed in to create the search. 
....................  
....................     A new search request sould be made once this function has returned a value  
....................     other than FS_GET_PROPERTIES_STILL_WORKING.  Continuing a completed search 
....................     can result in undefined behavior or results. 
....................  
....................     Typical Usage: 
....................     <code> 
....................     FS_DISK_PROPERTIES disk_properties; 
....................  
....................     disk_properties.new_request = TRUE; 
....................  
....................     do 
....................     { 
....................         FSGetDiskProperties(&disk_properties); 
....................     } while (disk_properties.properties_status == FS_GET_PROPERTIES_STILL_WORKING); 
....................     </code> 
....................  
....................     results.disk_format - contains the format of the drive.  Valid results are  
....................       FAT12(1), FAT16(2), or FAT32(3). 
....................  
....................     results.sector_size - the sector size of the mounted drive.  Valid values are 
....................       512, 1024, 2048, and 4096. 
....................  
....................     results.sectors_per_cluster - the number sectors per cluster. 
....................  
....................     results.total_clusters - the number of total clusters on the drive.  This  
....................       can be used to calculate the total disk size (total_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................     results.free_clusters - the number of free (unallocated) clusters on the drive. 
....................       This can be used to calculate the total free disk size (free_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................   Remarks: 
....................     PIC24F size estimates: 
....................       Flash - 400 bytes (-Os setting) 
....................  
....................     PIC24F speed estimates: 
....................       Search takes approximately 7 seconds per Gigabyte of drive space.  Speed 
....................         will vary based on the number of sectors per cluster and the sector size. 
....................   *********************************************************************************/ 
.................... void FSGetDiskProperties(FS_DISK_PROPERTIES* properties); 
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE FILEget_next_cluster(FSFILE *fo, DWORD n) 
....................   Summary: 
....................     Step through a chain of clusters 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fo - The file to get the next cluster of 
....................     n -  Number of links in the FAT cluster chain to jump through 
....................   Return Values: 
....................     CE_GOOD - Operation successful 
....................     CE_BAD_SECTOR_READ - A bad read occured of a sector 
....................     CE_INVALID_CLUSTER - Invalid cluster value \> maxcls 
....................     CE_FAT_EOF - Fat attempt to read beyond EOF 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will load 'n' proximate clusters for a file from 
....................     the FAT on the device.  It will stop checking for clusters if the 
....................     ReadFAT function returns an error, if it reaches the last cluster in 
....................     a file, or if the device tries to read beyond the last cluster used 
....................     by the device. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... BYTE FILEget_next_cluster(FSFILE *fo, DWORD n); 
....................  
.................... #endif 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "string.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "ctype.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
.................... #include "MDD File System/FSDefs.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSDefs.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.2.4 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  _FSDEF__H 
.................... #define  _FSDEF__H 
....................  
.................... #include "../GenericTypeDefs.h" 
....................  
.................... // Summary: An enumeration used for various error codes. 
.................... // Description: The CETYPE enumeration is used to indicate different error conditions during device operation. 
.................... typedef enum _CETYPE 
.................... { 
....................     CE_GOOD = 0,                    // No error 
....................     CE_ERASE_FAIL,                  // An erase failed 
....................     CE_NOT_PRESENT,                 // No device was present 
....................     CE_NOT_FORMATTED,               // The disk is of an unsupported format 
....................     CE_BAD_PARTITION,               // The boot record is bad 
....................     CE_UNSUPPORTED_FS,              // The file system type is unsupported 
....................     CE_INIT_ERROR,                  // An initialization error has occured 
....................     CE_NOT_INIT,                    // An operation was performed on an uninitialized device 
....................     CE_BAD_SECTOR_READ,             // A bad read of a sector occured 
....................     CE_WRITE_ERROR,                 // Could not write to a sector 
....................     CE_INVALID_CLUSTER,             // Invalid cluster value > maxcls 
....................     CE_FILE_NOT_FOUND,              // Could not find the file on the device 
....................     CE_DIR_NOT_FOUND,               // Could not find the directory 
....................     CE_BAD_FILE,                    // File is corrupted 
....................     CE_DONE,                        // No more files in this directory 
....................     CE_COULD_NOT_GET_CLUSTER,       // Could not load/allocate next cluster in file 
....................     CE_FILENAME_2_LONG,             // A specified file name is too long to use 
....................     CE_FILENAME_EXISTS,             // A specified filename already exists on the device 
....................     CE_INVALID_FILENAME,            // Invalid file name 
....................     CE_DELETE_DIR,                  // The user tried to delete a directory with FSremove 
....................     CE_DIR_FULL,                    // All root dir entry are taken 
....................     CE_DISK_FULL,                   // All clusters in partition are taken 
....................     CE_DIR_NOT_EMPTY,               // This directory is not empty yet, remove files before deleting 
....................     CE_NONSUPPORTED_SIZE,           // The disk is too big to format as FAT16 
....................     CE_WRITE_PROTECTED,             // Card is write protected 
....................     CE_FILENOTOPENED,               // File not opened for the write 
....................     CE_SEEK_ERROR,                  // File location could not be changed successfully 
....................     CE_BADCACHEREAD,                // Bad cache read 
....................     CE_CARDFAT32,                   // FAT 32 - card not supported 
....................     CE_READONLY,                    // The file is read-only 
....................     CE_WRITEONLY,                   // The file is write-only 
....................     CE_INVALID_ARGUMENT,            // Invalid argument 
....................     CE_TOO_MANY_FILES_OPEN,         // Too many files are already open 
....................     CE_UNSUPPORTED_SECTOR_SIZE,     // Unsupported sector size 
....................     CE_EOF = 61 
.................... } CETYPE; 
....................  
....................  
.................... // Summary: A macro indicating a dir entry was found 
.................... // Description: The FOUND macro indicates that a directory entry was found in the specified position 
.................... #define FOUND       0 
....................  
.................... // Summary: A macro indicating no dir entry was found 
.................... // Description: The NOT_FOUND macro indicates that the specified directory entry to load was deleted 
.................... #define NOT_FOUND   1 
....................  
.................... // Summary: A macro indicating that no more files were found 
.................... // Description: The NO_MORE macro indicates that there are no more directory entries to search for 
.................... #define NO_MORE     2 
....................  
....................  
....................  
.................... // Summary: A macro indicating the device is formatted with FAT12 
.................... // Description: The FAT12 macro is used to indicate that the file system on the device being accessed is a FAT12 file system. 
.................... #define FAT12       1 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT16 
.................... // Description: The FAT16 macro is used to indicate that the file system on the device being accessed is a FAT16 file system. 
.................... #define FAT16       2 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT32 
.................... // Description: The FAT32 macro is used to indicate that the file system on the device being accessed is a FAT32 file system. 
.................... #define FAT32       3 
....................  
....................  
....................  
.................... // Summary: A read-only attribute macro 
.................... // Description: A macro for the read-only attribute.  A file with this attribute should not be written to.  Note that this 
.................... //              attribute will not actually prevent a write to the file; that functionality is operating-system dependant.  The 
.................... //              user should take care not to write to a read-only file. 
.................... #define ATTR_READ_ONLY      0x01 
....................  
.................... // Summary: A hidden attribute macro 
.................... // Description: A macro for the hidden attribute.  A file with this attribute may be hidden from the user, depending on the 
.................... //              implementation of the operating system. 
.................... #define ATTR_HIDDEN         0x02 
....................  
.................... // Summary: A system attribute macro 
.................... // Description: A macro for the system attribute.  A file with this attribute is used by the operating system, and should not be 
.................... //              modified.  Note that this attribute will not actually prevent a write to the file. 
.................... #define ATTR_SYSTEM         0x04 
....................  
.................... // Summary: A volume attribute macro 
.................... // Description: A macro for the volume attribute.  If the first directory entry in the root directory has the volume attribute set, 
.................... //              the device will use the name in that directory entry as the volume name. 
.................... #define ATTR_VOLUME         0x08 
....................  
.................... // Summary: A macro for the attributes for a long-file name entry 
.................... // Description: A macro for the long-name attributes.  If a directory entry is used in a long-file name implementation, it will have 
.................... //              all four lower bits set.  This indicates that any software that does not support long file names should ignore that 
.................... //              entry. 
.................... #define ATTR_LONG_NAME      0x0f 
....................  
.................... // Summary: A directory attribute macro 
.................... // Description: A macro for the directory attribute.  If a directory entry has this attribute set, the file it points to is a directory- 
.................... //              type file, and will contain directory entries that point to additional directories or files. 
.................... #define ATTR_DIRECTORY      0x10 
....................  
.................... // Summary: An archive attribute macro 
.................... // Description: A macro for the archive attribute.  This attribute will indicate to some archiving programs that the file with this 
.................... //              attribute needs to be backed up.  Most operating systems create files with the archive attribute set. 
.................... #define ATTR_ARCHIVE        0x20 
....................  
.................... // Summary: A macro for all attributes 
.................... // Description: A macro for all attributes.  The search functions in this library require an argument that determines which attributes 
.................... //              a file is allowed to have in order to be found.  If ATTR_MASK is specified as this argument, any file may be found, regardless 
.................... //              of its attributes. 
.................... #define ATTR_MASK           0x3f 
....................  
....................  
....................  
.................... // Summary: A macro to indicate an empty FAT entry 
.................... // Description: The CLUSTER_EMPTY value is used to indicate that a FAT entry and it's corresponding cluster are available. 
.................... #define CLUSTER_EMPTY               0x0000  
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT12 
.................... // Description: The LAST_CLUSTER_FAT12 macro is used when reading the FAT to indicate that the next FAT12 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT12          0xff8 
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT16 
.................... // Description: The LAST_CLUSTER_FAT16 macro is used when reading the FAT to indicate that the next FAT16 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT16          0xfff8 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT12 
.................... // Description: The END_CLUSTER_FAT12 value is used as a comparison in FAT12 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT12           0xFF7 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT16 
.................... // Description: The END_CLUSTER_FAT16 value is used as a comparison in FAT16 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT16           0xFFF7 
....................  
.................... // Summary: A macro to indicate the failure of the ReadFAT function 
.................... // Description: The CLUSTER_FAIL_FAT16 macro is used by the ReadFAT function to indicate that an error occured reading a FAT12 or FAT16 
.................... //              file allocation table.  Note that since '0xFFF8' is used for the last cluster return value in the FAT16 implementation 
.................... //              the end-of-file value '0xFFFF' can be used to indicate an error condition. 
.................... #define CLUSTER_FAIL_FAT16          0xFFFF 
....................  
....................  
....................  
.................... #ifdef SUPPORT_FAT32 
....................     // Summary: A macro to indicate the last cluster value for FAT32 
....................     // Description: The LAST_CLUSTER_FAT32 macro is used when reading the FAT to indicate that the next FAT32 entry for a file contains 
....................     //              the end-of-file value. 
....................     #define LAST_CLUSTER_FAT32      0x0FFFFFF8 
....................  
....................     // Summary: A macro to indicate the last allocatable cluster for FAT32 
....................     // Description: The END_CLUSTER_FAT32 value is used as a comparison in FAT32 to determine that the firmware has reached the end of 
....................     //              the range of allowed allocatable clusters. 
....................     #define END_CLUSTER_FAT32       0x0FFFFFF7 
....................  
....................     // Summary: A macro to indicate the failure of the ReadFAT function 
....................     // Description: The CLUSTER_FAIL_FAT32 macro is used by the ReadFAT function to indicate that an error occured reading a FAT32 
....................     //              file allocation able. 
....................     #define CLUSTER_FAIL_FAT32      0x0FFFFFFF 
....................  
.................... #endif 
....................  
.................... // Summary: A macro indicating the number of bytes in a directory entry. 
.................... // Description: The NUMBER_OF_BYTES_IN_DIR_ENTRY macro represents the number of bytes in one directory entry.  It is used to calculate 
.................... //              the number of sectors in the root directory based on information in the boot sector. 
.................... #define NUMBER_OF_BYTES_IN_DIR_ENTRY    32 
....................  
....................  
....................  
.................... // Summary: A macro for a deleted dir entry marker. 
.................... // Description: The DIR_DEL macro is used to mark a directory entry as deleted.  When a file is deleted, this value will replace the 
.................... //              first character in the file name, and will indicate that the file the entry points to was deleted. 
.................... #define DIR_DEL             0xE5 
....................  
.................... // Summary: A macro for the last dir entry marker. 
.................... // Description: The DIR_EMPTY macro is used to indicate the last entry in a directory.  Since entries in use cannot start with a 0 and 
.................... //              deleted entries start with the DIR_DEL character, a 0 will mark the end of the in-use or previously used group of 
.................... //              entries in a directory 
.................... #define DIR_EMPTY           0 
....................  
....................  
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name 
.................... // Description: The DIR_NAMESIZE macro is used when validing the name portion of 8.3 filenames 
.................... #define DIR_NAMESIZE        8 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file extension 
.................... // Description: The DIR_EXTENSION macro is used when validating the extension portion of 8.3 filenames 
.................... #define DIR_EXTENSION       3 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name and extension 
.................... // Description: The DIR_NAMECOMP macro is used when validating 8.3 filenames 
.................... #define DIR_NAMECOMP        (DIR_NAMESIZE+DIR_EXTENSION) 
....................  
....................  
....................  
.................... // Summary: A macro to write a byte to RAM 
.................... // Description: The RAMwrite macro is used to write a byte of data to a RAM array 
.................... #define RAMwrite( a, f, d) *(a+f) = d 
....................  
.................... // Summary: A macro to read a byte from RAM 
.................... // Description: The RAMread macro is used to read a byte of data from a RAM array 
.................... #define RAMread( a, f)  *(a+f) 
....................  
.................... // Summary: A macro to read a 16-bit word from RAM 
.................... // Description: The RAMreadW macro is used to read two bytes of data from a RAM array 
.................... #define RAMreadW( a, f) *(WORD *)(a+f) 
....................  
.................... // Summary: A macro to read a 32-bit word from RAM 
.................... // Description: The RAMreadD macro is used to read four bytes of data from a RAM array 
.................... #define RAMreadD( a, f) *(DWORD *)(a+f) 
....................  
....................  
....................  
.................... #ifndef EOF 
....................     // Summary: Indicates error conditions or end-of-file conditions 
....................     // Description: The EOF macro is used to indicate error conditions in some function calls.  It is also used to indicate 
....................     //              that the end-of-file has been reached. 
....................     #define EOF             ((int)-1) 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing information about the device. 
.................... // Description: The DISK structure contains information about the device being accessed. 
.................... typedef struct 
.................... {  
....................     BYTE    *   buffer;         // Address of the global data buffer used to read and write file information 
....................     DWORD       firsts;         // Logical block address of the first sector of the FAT partition on the device 
....................     DWORD       fat;            // Logical block address of the FAT 
....................     DWORD       root;           // Logical block address of the root directory 
....................     DWORD       data;           // Logical block address of the data section of the device. 
....................     WORD        maxroot;        // The maximum number of entries in the root directory. 
....................     DWORD       maxcls;         // The maximum number of clusters in the partition. 
....................     DWORD       sectorSize;     // The size of a sector in bytes 
....................     DWORD       fatsize;        // The number of sectors in the FAT 
....................     BYTE        fatcopy;        // The number of copies of the FAT in the partition 
....................     BYTE        SecPerClus;     // The number of sectors per cluster in the data region 
....................     BYTE        type;           // The file system type of the partition (FAT12, FAT16 or FAT32) 
....................     BYTE        mount;          // Device mount flag (TRUE if disk was mounted successfully, FALSE otherwise) 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... } __attribute__ ((packed)) DISK; 
.................... #else 
.................... } DISK; 
.................... #endif 
....................  
....................  
.................... #if defined(__18CXX) && !defined(__CCS__) 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef unsigned short long SWORD; 
.................... #else 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef struct 
....................     { 
....................         unsigned char array[3]; 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) SWORD; 
.................... #else 
....................     } SWORD; 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT12 file system (in the boot sector) 
.................... // Description: The _BPB_FAT12 structure provides a layout of the "bios parameter block" in the boot sector of a FAT12 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BPS;               // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD BootSec_ResrvSec;          // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD BootSec_RootDirEnts;       // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD BootSec_SPF;               // Number of sectors per FAT 
....................     WORD BootSec_SPT;               // Number of sectors per track 
....................     WORD BootSec_HeadCnt;           // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD  BootSec_Reserved;        // Reserved space 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved2;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination    
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT12; 
.................... #else 
....................     } _BPB_FAT12; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT16 file system (in the boot sector) 
.................... // Description: The _BPB_FAT16 structure provides a layout of the "bios parameter block" in the boot sector of a FAT16 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD  BootSec_BPS;              // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD  BootSec_ResrvSec;         // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD  BootSec_RootDirEnts;      // Number of root directory entries 
....................     WORD  BootSec_TotSec16;         // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD  BootSec_SPF;              // Number of sectors per FAT 
....................     WORD  BootSec_SPT;              // Number of sectors per track 
....................     WORD  BootSec_HeadCnt;          // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved;         // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination      
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT16; 
.................... #else 
....................     } _BPB_FAT16; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT32 file system (in the boot sector) 
.................... // Description: The _BPB_FAT32 structure provides a layout of the "bios parameter block" in the boot sector of a FAT32 partition. 
.................... typedef struct { 
....................     SWORD BootSec_jmpBoot;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BytsPerSec;        // Number of bytes per sector 
....................     BYTE  BootSec_SecPerClus;       // Number of sectors per cluster 
....................     WORD BootSec_RsvdSecCnt;        // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_NumFATs;          // Number of FATs on the partition 
....................     WORD BootSec_RootEntCnt;        // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_Media;            // Media descriptor 
....................     WORD BootSec_FATSz16;           // Number of sectors per FAT 
....................     WORD BootSec_SecPerTrk;         // Number of sectors per track 
....................     WORD BootSec_NumHeads;          // Number of heads 
....................     DWORD BootSec_HiddSec;          // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     DWORD BootSec_FATSz32;          // Sectors per FAT (32 bits) 
....................     WORD BootSec_ExtFlags;          // Presently active FAT. Defined by bits 0-3 if bit 7 is 1. 
....................     WORD BootSec_FSVers;            // FAT32 filesystem version.  Should be 0:0 
....................     DWORD BootSec_RootClus;         // Start cluster of the root directory (should be 2) 
....................     WORD BootSec_FSInfo;            // File system information 
....................     WORD BootSec_BkBootSec;         // Backup boot sector address. 
....................     BYTE  BootSec_Reserved[12];     // Reserved space 
....................     BYTE  BootSec_DrvNum;           // Drive number 
....................     BYTE  BootSec_Reserved1;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLab[11];       // Volume Label 
....................     BYTE  BootSec_FilSysType[8];    // File system type in ASCII.  Not used for determination   
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT32; 
.................... #else 
....................     } _BPB_FAT32; 
.................... #endif 
....................  
....................  
.................... // Description: A macro for the boot sector bytes per sector value offset 
.................... #define BSI_BPS            11 
....................  
.................... // Description: A macro for the boot sector sector per cluster value offset 
.................... #define BSI_SPC            13 
....................  
.................... // Description: A macro for the boot sector reserved sector count value offset 
.................... #define BSI_RESRVSEC       14 
....................  
.................... // Description: A macro for the boot sector FAT count value offset 
.................... #define BSI_FATCOUNT       16 
....................  
.................... // Description: A macro for the boot sector root directory entry count value offset 
.................... #define BSI_ROOTDIRENTS    17 
....................  
.................... // Description: A macro for the boot sector 16-bit total sector count value offset 
.................... #define BSI_TOTSEC16       19 
....................  
.................... // Description: A macro for the boot sector sectors per FAT value offset 
.................... #define BSI_SPF            22 
....................  
.................... // Description: A macro for the boot sector 32-bit total sector count value offset 
.................... #define BSI_TOTSEC32       32 
....................  
.................... // Description: A macro for the boot sector boot signature offset 
.................... #define BSI_BOOTSIG        38 
....................  
.................... // Description: A macro for the boot sector file system type string offset 
.................... #define BSI_FSTYPE         54 
....................  
.................... // Description: A macro for the boot sector 32-bit sector per FAT value offset 
.................... #define  BSI_FATSZ32       36 
....................  
.................... // Description: A macro for the boot sector start cluster of root directory value offset 
.................... #define  BSI_ROOTCLUS      44 
....................  
.................... // Description: A macro for the FAT32 boot sector boot signature offset 
.................... #define  BSI_FAT32_BOOTSIG 66 
....................  
.................... // Description: A macro for the FAT32 boot sector file system type string offset 
.................... #define  BSI_FAT32_FSTYPE  82 
....................  
....................  
....................  
.................... // Summary: A partition table entry structure. 
.................... // Description: The PTE_MBR structure contains values found in a partition table entry in the MBR of a device. 
.................... typedef struct 
.................... { 
....................     BYTE      PTE_BootDes;            // The boot descriptor (should be 0x00 in a non-bootable device) 
....................     SWORD     PTE_FrstPartSect;       // The cylinder-head-sector address of the first sector of the partition 
....................     BYTE      PTE_FSDesc;             // The file system descriptor 
....................     SWORD     PTE_LstPartSect;        // The cylinder-head-sector address of the last sector of the partition 
....................     DWORD     PTE_FrstSect;           // The logical block address of the first sector of the partition 
....................     DWORD     PTE_NumSect;            // The number of sectors in a partition 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) PTE_MBR; 
.................... #else 
....................     } PTE_MBR; 
.................... #endif 
....................  
....................  
.................... // Summary: A structure of the organization of a master boot record. 
.................... // Description: The _PT_MBR structure has the same form as a master boot record.  When the MBR is loaded from the device, it will 
.................... //              be cast as a _PT_MBR structure so the MBR elements can be accessed. 
.................... typedef struct 
.................... { 
....................     BYTE        ConsChkRtn[446];        // Boot code 
....................     PTE_MBR     Partition0;             // The first partition table entry 
....................     PTE_MBR     Partition1;             // The second partition table entry 
....................     PTE_MBR     Partition2;             // The third partition table entry 
....................     PTE_MBR     Partition3;             // The fourth partition table entry 
....................     BYTE        Signature0;             // MBR signature code - equal to 0x55 
....................     BYTE        Signature1;             // MBR signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... }__attribute__((packed)) _PT_MBR; 
.................... #else 
.................... }_PT_MBR; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _PT_MBR structure 
.................... // Description: The PT_MBR pointer points to a _PT_MBR structure. 
.................... typedef _PT_MBR *  PT_MBR; 
....................  
....................  
....................  
.................... // Summary: A structure of the organization of a boot sector. 
.................... // Description: The _BootSec structure has the same form as a boot sector.  When the boot sector is loaded from the device, it will 
.................... //              be cast as a _BootSec structure so the boot sector elements can be accessed. 
.................... typedef struct 
.................... { 
....................     // A union of different bios parameter blocks 
....................     union 
....................     { 
....................         _BPB_FAT32  FAT_32; 
....................         _BPB_FAT16  FAT_16; 
....................         _BPB_FAT12  FAT_12; 
....................     }FAT; 
....................     BYTE    Reserved[512-sizeof(_BPB_FAT32)-2]; // Reserved space 
....................     BYTE    Signature0;         // Boot sector signature code - equal to 0x55 
....................     BYTE    Signature1;         // Boot sector signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BootSec; 
.................... #else 
....................     } _BootSec; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _BootSec structure 
.................... // Description: The BootSec pointer points to a _BootSec structure. 
.................... typedef _BootSec * BootSec; 
....................  
....................  
....................  
.................... // Summary: A macro indicating the offset for the master boot record 
.................... // Description: FO_MBR is a macro that indicates the addresss of the master boot record on the device.  When the device is initialized 
.................... //              this sector will be read 
.................... #define FO_MBR          0L 
....................  
....................  
....................  
.................... // Summary: A macro for the first boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_0 macro is used to determine that the first byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_0     0x55 
....................  
.................... // Summary: A macro for the second boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_1 macro is used to determine that the second byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_1     0xAA 
....................  
....................  
.................... typedef struct  
.................... { 
....................     BYTE    errorCode; 
....................     union  
....................     { 
....................         BYTE    value; 
....................         struct  
....................         { 
....................             BYTE    sectorSize  : 1; 
....................             BYTE    maxLUN      : 1; 
....................         }   bits; 
....................     } validityFlags; 
....................      
....................     WORD    sectorSize; 
....................     BYTE    maxLUN; 
.................... } MEDIA_INFORMATION; 
....................  
.................... typedef enum 
.................... { 
....................     MEDIA_NO_ERROR,                     // No errors 
....................     MEDIA_DEVICE_NOT_PRESENT,           // The requested device is not present 
....................     MEDIA_CANNOT_INITIALIZE             // Cannot initialize media 
.................... } MEDIA_ERRORS;                 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_FSFPRINTF 
.................... #include "stdarg.h" 
.................... #endif 
....................  
.................... #ifdef FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................       #include "salloc.h" 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef ALLOW_WRITES 
....................    #ifdef ALLOW_FORMATS 
....................       #error Write functions must be enabled to use the format function 
....................    #endif 
....................    #ifdef ALLOW_FSFPRINTF 
....................       #error Write functions must be enabled to use the FSfprintf function 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef USEREALTIMECLOCK 
....................     #ifdef USERDEFINEDCLOCK 
....................         #error Please select only one timestamp clocking mode in FSconfig.h 
....................     #endif 
....................     #ifdef INCREMENTTIMESTAMP 
....................         #error Please select only one timestamp clocking mode in FSconfig.h 
....................     #endif 
.................... #elif defined USERDEFINEDCLOCK 
....................     #ifdef INCREMENTTIMESTAMP 
....................         #error Please select only one timestamp clocking mode in FSconfig.h 
....................     #endif 
.................... #endif 
.................... /*****************************************************************************/ 
.................... /*                         Global Variables                                  */ 
.................... /*****************************************************************************/ 
....................  
.................... #ifndef FS_DYNAMIC_MEM 
....................     FSFILE  gFileArray[FS_MAX_FILES_OPEN];      // Array that contains file information (static allocation) 
....................     BYTE    gFileSlotOpen[FS_MAX_FILES_OPEN];   // Array that indicates which elements of gFileArray are available for use 
....................    #ifdef SUPPORT_LFN 
....................       // Array that stores long file name (static allocation) 
....................       unsigned short int lfnData[FS_MAX_FILES_OPEN][257]; 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef SUPPORT_LFN 
....................    #ifdef ALLOW_FILESEARCH 
....................       // Array that stores long file name for File Search operation (static allocation) 
....................       unsigned short int recordSearchName[257]; 
....................       unsigned short int recordFoundName[257]; 
....................       unsigned short int recordSearchLength; 
....................    #endif 
....................    unsigned short int fileFoundString[261]; 
.................... #endif 
....................  
.................... #if defined(USEREALTIMECLOCK) || defined(USERDEFINEDCLOCK) 
.................... // Timing variables 
.................... BYTE    gTimeCrtMS;     // Global time variable (for timestamps) used to indicate create time (milliseconds) 
.................... WORD    gTimeCrtTime;   // Global time variable (for timestamps) used to indicate create time 
.................... WORD    gTimeCrtDate;   // Global time variable (for timestamps) used to indicate create date 
.................... WORD    gTimeAccDate;   // Global time variable (for timestamps) used to indicate last access date 
.................... WORD    gTimeWrtTime;   // Global time variable (for timestamps) used to indicate last update time 
.................... WORD    gTimeWrtDate;   // Global time variable (for timestamps) used to indicate last update date 
.................... #endif 
....................  
.................... DWORD       gLastFATSectorRead = 0xFFFFFFFF;    // Global variable indicating which FAT sector was read last 
.................... BYTE        gNeedFATWrite = FALSE;              // Global variable indicating that there is information that needs to be written to the FAT 
.................... FSFILE  *   gBufferOwner = NULL;                // Global variable indicating which file is using the data buffer 
.................... DWORD       gLastDataSectorRead = 0xFFFFFFFF;   // Global variable indicating which data sector was read last 
.................... BYTE        gNeedDataWrite = FALSE;             // Global variable indicating that there is information that needs to be written to the data section 
.................... BYTE        nextClusterIsLast = FALSE;          // Global variable indicating that the entries in a directory align with a cluster boundary 
....................  
.................... BYTE    gBufferZeroed = FALSE;      // Global variable indicating that the data buffer contains all zeros 
....................  
.................... DWORD   FatRootDirClusterValue;     // Global variable containing the cluster number of the root dir (0 for FAT12/16) 
....................  
.................... BYTE    FSerrno;                    // Global error variable.  Set to one of many error codes after each function call. 
....................  
.................... DWORD   TempClusterCalc;            // Global variable used to store the calculated value of the cluster of a specified sector. 
.................... BYTE    dirCleared;                 // Global variable used by the "recursive" FSrmdir function to indicate that all subdirectories and files have been deleted from the target directory. 
.................... BYTE    recache = FALSE;            // Global variable used by the "recursive" FSrmdir function to indicate that additional cache reads are needed. 
.................... FSFILE  tempCWDobj;                 // Global variable used to preserve the current working directory information. 
.................... FSFILE  gFileTemp;                  // Global variable used for file operations. 
....................  
.................... FSFILE   cwd;               // Global current working directory 
.................... FSFILE * cwdptr = &cwd;     // Pointer to the current working directory 
....................  
.................... #ifdef __18CXX 
....................     #pragma udata dataBuffer = DATA_BUFFER_ADDRESS 
....................     BYTE gDataBuffer[MEDIA_SECTOR_SIZE];    // The global data sector buffer 
....................     #pragma udata FATBuffer = FAT_BUFFER_ADDRESS 
....................     BYTE gFATBuffer[MEDIA_SECTOR_SIZE];     // The global FAT sector buffer 
....................     #pragma udata 
.................... #endif 
....................  
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................     BYTE __attribute__ ((aligned(4)))   gDataBuffer[MEDIA_SECTOR_SIZE];     // The global data sector buffer 
....................     BYTE __attribute__ ((aligned(4)))   gFATBuffer[MEDIA_SECTOR_SIZE];      // The global FAT sector buffer 
.................... #endif 
....................  
.................... DISK gDiskData;         // Global structure containing device information. 
....................  
.................... /* Global Variables to handle ASCII & UTF16 file operations */ 
.................... char *asciiFilename; 
.................... unsigned short int fileNameLength; 
.................... #ifdef SUPPORT_LFN 
....................    unsigned short int *utf16Filename; 
....................    BOOL   utfModeFileName = FALSE; 
....................    BOOL   twoByteMode = FALSE; 
.................... #endif 
.................... /************************************************************************/ 
.................... /*                        Structures and defines                        */ 
.................... /************************************************************************/ 
....................  
.................... // Directory entry structure 
.................... typedef struct 
.................... { 
....................     char      DIR_Name[DIR_NAMESIZE];           // File name 
....................     char      DIR_Extension[DIR_EXTENSION];     // File extension 
....................     BYTE      DIR_Attr;                         // File attributes 
....................     BYTE      DIR_NTRes;                        // Reserved byte 
....................     BYTE      DIR_CrtTimeTenth;                 // Create time (millisecond field) 
....................     WORD      DIR_CrtTime;                      // Create time (second, minute, hour field) 
....................     WORD      DIR_CrtDate;                      // Create date 
....................     WORD      DIR_LstAccDate;                   // Last access date 
....................     WORD      DIR_FstClusHI;                    // High word of the entry's first cluster number 
....................     WORD      DIR_WrtTime;                      // Last update time 
....................     WORD      DIR_WrtDate;                      // Last update date 
....................     WORD      DIR_FstClusLO;                    // Low word of the entry's first cluster number 
....................     DWORD     DIR_FileSize;                     // The 32-bit file size 
.................... }_DIRENTRY; 
....................  
.................... typedef _DIRENTRY * DIRENTRY;                   // A pointer to a directory entry structure 
....................  
.................... #define DIRECTORY 0x12          // Value indicating that the CreateFileEntry function will be creating a directory 
....................  
.................... #define DIRENTRIES_PER_SECTOR   (MEDIA_SECTOR_SIZE / 32)        // The number of directory entries in a sector 
....................  
.................... // Maximum number of UTF16 words in single Root directory entry 
.................... #define MAX_UTF16_CHARS_IN_LFN_ENTRY      (BYTE)13 
....................  
.................... // Long File Name Entry 
.................... typedef struct 
.................... { 
....................    BYTE LFN_SequenceNo;   // Sequence number, 
....................    BYTE LFN_Part1[10];    // File name part 1 
....................    BYTE LFN_Attribute;    // File attribute 
....................    BYTE LFN_Type;      // LFN Type 
....................    BYTE LFN_Checksum;     // Checksum 
....................    unsigned short int LFN_Part2[6];    // File name part 2 
....................    unsigned short int LFN_Reserved2;   // Reserved for future use 
....................    unsigned short int LFN_Part3[2];     // File name part 3 
.................... }LFN_ENTRY; 
....................  
.................... /* Summary: Possible type of file or directory name. 
.................... ** Description: See the FormatFileName() & FormatDirName() function for more information. 
.................... */ 
.................... typedef enum 
.................... { 
....................     NAME_8P3_ASCII_CAPS_TYPE, 
....................     NAME_8P3_ASCII_MIXED_TYPE, 
....................     NAME_8P3_UTF16_TYPE, // SUBTYPES OF 8P3 UTF16 TYPE 
....................        NAME_8P3_UTF16_ASCII_CAPS_TYPE, 
....................        NAME_8P3_UTF16_ASCII_MIXED_TYPE, 
....................        NAME_8P3_UTF16_NONASCII_TYPE, 
....................     NAME_LFN_TYPE, 
....................     NAME_ERROR 
.................... } FILE_DIR_NAME_TYPE; 
....................  
.................... // internal errors 
.................... #define CE_FAT_EOF            60   // Error that indicates an attempt to read FAT entries beyond the end of the file 
.................... //#define CE_EOF                61   // Error that indicates that the end of the file has been reached 
....................  
.................... typedef FSFILE   * FILEOBJ;         // Pointer to an FSFILE object 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................  
.................... #define _FLAG_MINUS 0x1             // FSfprintf minus flag indicator 
.................... #define _FLAG_PLUS  0x2             // FSfprintf plus flag indicator 
.................... #define _FLAG_SPACE 0x4             // FSfprintf space flag indicator 
.................... #define _FLAG_OCTO  0x8             // FSfprintf octothorpe (hash mark) flag indicator 
.................... #define _FLAG_ZERO  0x10            // FSfprintf zero flag indicator 
.................... #define _FLAG_SIGNED 0x80           // FSfprintf signed flag indicator 
....................  
.................... #ifdef __18CXX 
....................     #define _FMT_UNSPECIFIED 0      // FSfprintf unspecified argument size flag 
....................     #define _FMT_LONG 1             // FSfprintf 32-bit argument size flag 
....................     #define _FMT_SHRTLONG 2         // FSfprintf 24-bit argument size flag 
....................     #define _FMT_BYTE   3           // FSfprintf 8-bit argument size flag 
.................... #else 
....................     #define _FMT_UNSPECIFIED 0      // FSfprintf unspecified argument size flag 
....................     #define _FMT_LONGLONG 1         // FSfprintf 64-bit argument size flag 
....................     #define _FMT_LONG 2             // FSfprintf 32-bit argument size flag 
....................     #define _FMT_BYTE 3             // FSfprintf 8-bit argument size flag 
.................... #endif 
....................  
.................... #ifdef __18CXX 
....................     static const rom char s_digits[] = "0123456789abcdef";      // FSfprintf table of conversion digits 
.................... #else 
....................     static const char s_digits[] = "0123456789abcdef";          // FSfprintf table of conversion digits 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /************************************************************************************/ 
.................... /*                               Prototypes                                         */ 
.................... /************************************************************************************/ 
....................  
.................... DWORD ReadFAT (DISK *dsk, DWORD ccls); 
.................... DIRENTRY Cache_File_Entry( FILEOBJ fo, WORD * curEntry, BYTE ForceRead); 
.................... BYTE Fill_File_Object(FILEOBJ fo, WORD *fHandle); 
.................... DWORD Cluster2Sector(DISK * disk, DWORD cluster); 
.................... DIRENTRY LoadDirAttrib(FILEOBJ fo, WORD *fHandle); 
.................... #ifdef INCREMENTTIMESTAMP 
....................     void IncrementTimeStamp(DIRENTRY dir); 
.................... #elif defined USEREALTIMECLOCK 
....................     void CacheTime (void); 
.................... #endif 
....................  
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................     BYTE ReadByte( BYTE* pBuffer, WORD index ); 
....................     WORD ReadWord( BYTE* pBuffer, WORD index ); 
....................     DWORD ReadDWord( BYTE* pBuffer, WORD index ); 
.................... #endif 
....................  
.................... void FileObjectCopy(FILEOBJ foDest,FILEOBJ foSource); 
.................... FILE_DIR_NAME_TYPE ValidateChars(BYTE mode); 
.................... BYTE FormatFileName( const char* fileName, FILEOBJ fptr, BYTE mode); 
.................... CETYPE FILEfind( FILEOBJ foDest, FILEOBJ foCompareTo, BYTE cmd, BYTE mode); 
.................... CETYPE FILEopen (FILEOBJ fo, WORD *fHandle, char type); 
.................... #if defined(SUPPORT_LFN) 
.................... BOOL Alias_LFN_Object(FILEOBJ fo); 
.................... BYTE Fill_LFN_Object(FILEOBJ fo, LFN_ENTRY *lfno, WORD *fHandle); 
.................... #endif 
....................  
.................... // Write functions 
.................... #ifdef ALLOW_WRITES 
....................     BYTE Write_File_Entry( FILEOBJ fo, WORD * curEntry); 
....................     BYTE flushData (void); 
....................     CETYPE FILEerase( FILEOBJ fo, WORD *fHandle, BYTE EraseClusters); 
....................     BYTE FILEallocate_new_cluster( FILEOBJ fo, BYTE mode); 
....................     BYTE FAT_erase_cluster_chain (DWORD cluster, DISK * dsk); 
....................     DWORD FATfindEmptyCluster(FILEOBJ fo); 
....................     BYTE FindEmptyEntries(FILEOBJ fo, WORD *fHandle); 
....................     BYTE PopulateEntries(FILEOBJ fo, WORD *fHandle, BYTE mode); 
....................     CETYPE FILECreateHeadCluster( FILEOBJ fo, DWORD *cluster); 
....................     BYTE EraseCluster(DISK *disk, DWORD cluster); 
....................     CETYPE CreateFirstCluster(FILEOBJ fo); 
....................     DWORD WriteFAT (DISK *dsk, DWORD ccls, DWORD value, BYTE forceWrite); 
....................     CETYPE CreateFileEntry(FILEOBJ fo, WORD *fHandle, BYTE mode, BOOL createFirstCluster); 
.................... #endif 
....................  
.................... // Directory functions 
.................... #ifdef ALLOW_DIRS 
....................     BYTE GetPreviousEntry (FSFILE * fo); 
....................     BYTE FormatDirName (char * string,FILEOBJ fptr, BYTE mode); 
....................     int CreateDIR (char * path); 
....................     BYTE writeDotEntries (DISK * dsk, DWORD dotAddress, DWORD dotdotAddress); 
....................     int eraseDir (char * path); 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     #ifdef ALLOW_WRITES 
....................         int mkdirhelper (BYTE mode, char * ramptr, const rom char * romptr); 
....................         int rmdirhelper (BYTE mode, char * ramptr, const rom char * romptr, unsigned char rmsubdirs); 
....................     #endif 
.................... int chdirhelper (BYTE mode, char * ramptr, const rom char * romptr); 
.................... #else 
....................     #ifdef ALLOW_WRITES 
....................         int mkdirhelper (BYTE mode, char * ramptr, char * romptr); 
....................         int rmdirhelper (BYTE mode, char * ramptr, char * romptr, unsigned char rmsubdirs); 
....................     #endif 
....................     int chdirhelper (BYTE mode, char * ramptr, char * romptr); 
.................... #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................     #ifdef __18CXX 
....................         int FSvfprintf (auto FSFILE *handle, auto const rom char *formatString, auto va_list ap); 
....................     #else 
....................         int FSvfprintf (FSFILE *handle, const char *formatString, va_list ap); 
....................     #endif 
....................     int FSputc (char c, FSFILE * file); 
....................     unsigned char str_put_n_chars (FSFILE * handle, unsigned char n, char c); 
.................... #endif 
....................  
.................... BYTE DISKmount( DISK *dsk); 
.................... BYTE LoadMBR(DISK *dsk); 
.................... BYTE LoadBootSector(DISK *dsk); 
.................... DWORD GetFullClusterNumber(DIRENTRY entry); 
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     int FSInit(void) 
....................   Summary: 
....................     Function to initialize the device. 
....................   Conditions: 
....................     The physical device should be connected to the microcontroller. 
....................   Input: 
....................     None 
....................   Return Values: 
....................     TRUE -  Initialization successful 
....................     FALSE - Initialization unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function initializes the file system stack & the interfacing device. 
....................     Initializes the static or dynamic memory slots for holding file 
....................     structures. Initializes the device with the DISKmount function. Loads 
....................     MBR and boot sector information. Initializes the current working 
....................     directory to the root directory for the device if directory support 
....................     is enabled. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... int FSInit(void) 
.................... { 
....................     int fIndex; 
.................... #ifndef FS_DYNAMIC_MEM 
....................     for( fIndex = 0; fIndex < FS_MAX_FILES_OPEN; fIndex++ ) 
....................         gFileSlotOpen[fIndex] = TRUE; 
.................... #else 
....................     #ifdef __18CXX 
....................         SRAMInitHeap(); 
....................     #endif 
.................... #endif 
....................  
....................     gBufferZeroed = FALSE; 
....................     gNeedFATWrite = FALSE; 
....................     gLastFATSectorRead = 0xFFFFFFFF; 
....................     gLastDataSectorRead = 0xFFFFFFFF; 
....................  
....................     MDD_InitIO(); 
....................  
....................     if(DISKmount(&gDiskData) == CE_GOOD) 
....................     { 
....................     // Initialize the current working directory to the root 
.................... #ifdef ALLOW_DIRS 
....................         cwdptr->dsk = &gDiskData; 
....................         cwdptr->sec = 0; 
....................         cwdptr->pos = 0; 
....................         cwdptr->seek = 0; 
....................         cwdptr->size = 0; 
....................         cwdptr->name[0] = '\\'; 
....................         for (fIndex = 1; fIndex < 11; fIndex++) 
....................         { 
....................             cwdptr->name[fIndex] = 0x20; 
....................         } 
....................         cwdptr->entry = 0; 
....................         cwdptr->attributes = ATTR_DIRECTORY; 
....................         // "FatRootDirClusterValue" indicates the root 
....................         cwdptr->dirclus = FatRootDirClusterValue; 
....................         cwdptr->dirccls = FatRootDirClusterValue; 
....................    #if defined(SUPPORT_LFN) 
....................       // Initialize default values for LFN support 
....................         cwdptr->AsciiEncodingType = TRUE; 
....................         cwdptr->utf16LFNlength = 0x0000; 
....................    #endif 
.................... #endif 
....................  
....................         FSerrno = 0; 
....................         return TRUE; 
....................     } 
....................  
....................     return FALSE; 
.................... } 
....................  
....................  
.................... /******************************************************************************** 
....................   Function: 
....................     CETYPE FILEfind (FILEOBJ foDest, FILEOBJ foCompareTo, BYTE cmd, BYTE mode) 
....................   Summary 
....................     Finds a file on the device 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     foDest -       FSFILE object containing information of the file found 
....................     foCompareTo -  FSFILE object containing the name/attr of the file to be 
....................                    found 
....................     cmd - 
....................         -          LOOK_FOR_EMPTY_ENTRY: Search for empty entry. 
....................         -          LOOK_FOR_MATCHING_ENTRY: Search for matching entry. 
....................     mode - 
....................          -         0: Match file exactly with default attributes. 
....................          -         1: Match file to user-specified attributes. 
....................   Return Values: 
....................     CE_GOOD -            File found. 
....................     CE_FILE_NOT_FOUND -  File not found. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The FILEfind function will sequentially cache directory entries within 
....................     the current working directory into the foDest FSFILE object.  If the cmd 
....................     parameter is specified as LOOK_FOR_EMPTY_ENTRY the search will continue 
....................     until an empty directory entry is found. If the cmd parameter is specified 
....................     as LOOK_FOR_MATCHING_ENTRY these entries will be compared to the foCompareTo 
....................     object until a match is found or there are no more entries in the current 
....................     working directory. If the mode is specified a '0' the attributes of the FSFILE 
....................     entries are irrelevant. If the mode is specified as '1' the attributes of the 
....................     foDest entry must match the attributes specified in the foCompareTo file and 
....................     partial string search characters may bypass portions of the comparison. 
....................   Remarks: 
....................     None 
....................   ********************************************************************************/ 
....................  
.................... CETYPE FILEfind( FILEOBJ foDest, FILEOBJ foCompareTo, BYTE cmd, BYTE mode) 
.................... { 
....................     WORD   attrib, compareAttrib; 
....................     WORD   fHandle = foDest->entry;                  // current entry counter 
....................     CETYPE   statusB = CE_FILE_NOT_FOUND; 
....................     BYTE   character,test,state,index; 
....................  
....................    #if defined(SUPPORT_LFN) 
....................  
....................     LFN_ENTRY lfnObject;   // Long File Name Object 
....................    unsigned char *dst = (unsigned char *)&fileFoundString[0]; 
....................    unsigned short int *templfnPtr = (unsigned short int *)foCompareTo -> utf16LFNptr; 
....................    UINT16_VAL tempShift; 
....................    short int   fileCompareLfnIndex,fileFoundLfnIndex = 0,fileFoundMaxLfnIndex = 0,lfnCountIndex,fileFoundLength = 0; 
....................    BOOL  lfnFirstCheck = FALSE,foundSFN,foundLFN,fileFoundDotPosition = FALSE,fileCompareDotPosition; 
....................    BYTE  lfnCompareMaxSequenceNum = 0,lfnFoundMaxSequenceNum,reminder = 0; 
....................    char  tempDst[13]; 
....................    fileNameLength = foCompareTo->utf16LFNlength; 
....................  
....................    // If 'fileNameLength' is non zero then it means that file name is of LFN format. 
....................    // If 'fileNameLength' is zero then it means that file name is of 8.3 format 
....................    if(fileNameLength) 
....................    { 
....................       // Find out the number of root entries for the given LFN 
....................       reminder = fileNameLength % MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................       index = fileNameLength/MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................       if(reminder || (fileNameLength < MAX_UTF16_CHARS_IN_LFN_ENTRY)) 
....................       { 
....................          index++; 
....................       } 
....................  
....................       // The maximum sequence number of the LFN 
....................       lfnCompareMaxSequenceNum = index; 
....................    } 
....................    #endif 
....................  
....................                                               #ifdef __DEBUG_UART   
....................                                                 PrintROMASCIIStringUART("FILEfind foCompareTo="); 
....................                                                 PrintRAMBytesUART(((unsigned char*)foCompareTo->name), 13); 
....................                                                #endif  
....................  
....................     // reset the cluster 
....................     foDest->dirccls = foDest->dirclus; 
....................    // Attribute to be compared as per application layer request 
....................     compareAttrib = 0xFFFF ^ foCompareTo->attributes; 
....................  
....................     if (fHandle == 0) 
....................     { 
....................         if (Cache_File_Entry(foDest, &fHandle, TRUE) == NULL) 
....................         { 
....................             statusB = CE_BADCACHEREAD; 
....................         } 
....................     } 
....................     else 
....................     { 
....................       // Maximum 16 entries possible 
....................         if ((fHandle & MASK_MAX_FILE_ENTRY_LIMIT_BITS) != 0) 
....................         { 
....................             if (Cache_File_Entry (foDest, &fHandle, TRUE) == NULL) 
....................             { 
....................                 statusB = CE_BADCACHEREAD; 
....................             } 
....................         } 
....................     } 
....................  
....................     if (statusB != CE_BADCACHEREAD) 
....................     { 
....................         // Loop until you reach the end or find the file 
....................         while(1) 
....................         { 
....................             if(statusB != CE_GOOD) //First time entry always here 
....................             { 
....................             #if defined(SUPPORT_LFN) 
....................                foundSFN = FALSE; 
....................                foundLFN = FALSE; 
....................  
....................                    state = Fill_LFN_Object(foDest,&lfnObject,&fHandle); 
....................             #else 
....................                    state = Fill_File_Object(foDest, &fHandle); 
....................             #endif 
....................  
....................                 if(state == NO_MORE) // Reached the end of available files. Comparision over and file not found so quit. 
....................                 { 
....................                     break; 
....................                 } 
....................             } 
....................             else // statusB == CE_GOOD then exit 
....................             { 
....................                 break; // Code below intializes"statusB = CE_GOOD;" so, if no problem in the filled file, Exit the while loop. 
....................             } 
....................  
....................             if(state == FOUND) // Validate the correct matching of filled file data with the required(to be found) one. 
....................             { 
....................             #if defined(SUPPORT_LFN) 
....................  
....................             if(lfnObject.LFN_Attribute != ATTR_LONG_NAME) 
....................             { 
....................                lfnFirstCheck = FALSE; 
....................  
....................                *dst = lfnObject.LFN_SequenceNo; 
....................                for(index = 0;index < 10;index++) 
....................                   dst[index + 1] = lfnObject.LFN_Part1[index]; 
....................                foundSFN = TRUE; 
....................             } 
....................             else 
....................             { 
....................                if(lfnObject.LFN_SequenceNo & 0x40) 
....................                { 
....................                   lfnFoundMaxSequenceNum = lfnObject.LFN_SequenceNo & 0x1F; 
....................  
....................                   if((mode == 0x00) && ((fileNameLength && (lfnFoundMaxSequenceNum != lfnCompareMaxSequenceNum)) || 
....................                      (!fileNameLength && (lfnFoundMaxSequenceNum != 0x01)))) 
....................                   { 
.................... //                     fHandle = fHandle + lfnFoundMaxSequenceNum + 1; 
....................                      fHandle++; 
....................                      continue; 
....................                   } 
....................  
....................                   fileFoundLfnIndex = (lfnObject.LFN_SequenceNo & 0xBF) * MAX_UTF16_CHARS_IN_LFN_ENTRY - 1; 
....................                   fileCompareLfnIndex = fileFoundLfnIndex; 
....................  
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part3[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part3[0]; 
....................  
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[5]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[4]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[3]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[2]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[0]; 
....................  
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[8]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[9]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[6]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[7]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[4]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[5]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[2]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[3]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[0]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................  
....................  
....................                   fileFoundLength = fileCompareLfnIndex + 1; 
....................                   for(index = 1;index <= MAX_UTF16_CHARS_IN_LFN_ENTRY;index++) 
....................                   { 
....................                      if(fileFoundString[fileFoundLfnIndex + index] == 0x0000) 
....................                         fileFoundLength = fileFoundLfnIndex + index; 
....................                   } 
....................  
....................                   if(mode == 0x00) 
....................                   { 
....................                      if((fileNameLength != fileFoundLength) && fileNameLength) 
....................                      { 
.................... //                        fHandle = fHandle + lfnFoundMaxSequenceNum + 1; 
....................                         fHandle++; 
....................                         continue; 
....................                      } 
....................                   } 
....................  
....................                   fileFoundMaxLfnIndex = fileFoundLength - 1; 
....................                   lfnFirstCheck = TRUE; 
....................                } 
....................                else if(lfnFirstCheck == TRUE) 
....................                { 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part3[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part3[0]; 
....................  
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[5]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[4]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[3]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[2]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = lfnObject.LFN_Part2[0]; 
....................  
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[8]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[9]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[6]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[7]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[4]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[5]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[2]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[3]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                   tempShift.byte.LB = lfnObject.LFN_Part1[0]; 
....................                   tempShift.byte.HB = lfnObject.LFN_Part1[1]; 
....................                   fileFoundString[fileFoundLfnIndex--] = tempShift.Val; 
....................                } 
....................                else 
....................                   { 
....................                      fHandle++; 
....................                   continue; 
....................                } 
....................  
....................                   if(fileFoundLfnIndex > 0) 
....................                   { 
....................                      fHandle++; 
....................                   continue; 
....................                } 
....................  
....................                foundLFN = TRUE; 
....................             } 
....................  
....................             lfnFirstCheck = FALSE; 
....................             statusB = CE_GOOD; 
....................                  switch (mode) 
....................                  { 
....................                      case 0: 
....................  
....................                      // Copy the contents of any SFN found to temporary string 
....................                      // for future comparision tests 
....................                      for(index = 0;index < FILE_NAME_SIZE_8P3;index++) 
....................                         tempDst[index] = dst[index]; 
....................  
....................                      // Try to deduce the original name from the found SFN 
....................                      if(dst[8] != ' ') 
....................                      { 
....................                         for(index = 0;index < 8;index++) 
....................                         { 
....................                            if(dst[index] == ' ') 
....................                               break; 
....................                         } 
....................                         tempDst[index++] = '.'; 
....................                         tempDst[index++] = dst[8]; 
....................  
....................                         if(dst[9] != ' ') 
....................                            tempDst[index++] = dst[9]; 
....................                         else 
....................                            tempDst[index++] = 0x00; 
....................  
....................                         if(dst[10] != ' ') 
....................                            tempDst[index++] = dst[10]; 
....................                         else 
....................                            tempDst[index++] = 0x00; 
....................                      } 
....................                            else 
....................                      { 
....................                               for(index = 0;index < 8;index++) 
....................                         { 
....................                            if(tempDst[index] == ' ') 
....................                               break; 
....................                         } 
....................                      } 
....................  
....................                      // Terminate the string using the NULL value 
....................                      tempDst[index] = 0x00; 
....................  
....................                             if(fileNameLength) 
....................                             { 
....................                               if(foundLFN) 
....................                               { 
....................                                  // see if we are a volume id or hidden, ignore 
....................                                  // search for one. if status = TRUE we found one 
....................                                  for(fileCompareLfnIndex = 0;fileCompareLfnIndex < fileNameLength;fileCompareLfnIndex++) 
....................                                  { 
....................                                 if(foCompareTo -> AsciiEncodingType) 
....................                                 { 
....................                                            // get the source character 
....................                                            character = (BYTE)templfnPtr[fileCompareLfnIndex]; 
....................                                            // get the destination character 
....................                                            test = (BYTE)fileFoundString[fileCompareLfnIndex]; 
....................                                            if((fileFoundString[fileCompareLfnIndex] > 0xFF) || (tolower(character) != tolower(test))) 
....................                                            { 
....................                                              statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                              break; 
....................                                            } 
....................                                 } 
....................                                 else 
....................                                 { 
....................                                    if(templfnPtr[fileCompareLfnIndex] != fileFoundString[fileCompareLfnIndex]) 
....................                                    { 
....................                                            statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                                    } 
....................                                 } 
....................                                  }// for loop 
....................                         } 
....................                         else if(foundSFN && foCompareTo -> AsciiEncodingType) 
....................                         { 
....................                                  if(strlen(tempDst) != fileNameLength) 
....................                                     statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                  else 
....................                                  { 
....................                                     for(fileCompareLfnIndex = 0;fileCompareLfnIndex < fileNameLength;fileCompareLfnIndex++) 
....................                                     { 
....................                                        // get the source character 
....................                                        character = (BYTE)templfnPtr[fileCompareLfnIndex]; 
....................                                        // get the destination character 
....................                                        test = tempDst[fileCompareLfnIndex]; 
....................                                        if(tolower(character) != tolower(test)) 
....................                                        { 
....................                                           statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                           break; 
....................                                        } 
....................                                     }// for loop 
....................                            } 
....................                         } 
....................                         else 
....................                         { 
....................                                  statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                         } 
....................                      } 
....................                      else 
....................                             { 
....................                              if(foundLFN) 
....................                              { 
....................                                  if(strlen(tempDst) != fileFoundLength) 
....................                                     statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                  else 
....................                                  { 
....................                                     for(fileCompareLfnIndex = 0;fileCompareLfnIndex < fileFoundLength;fileCompareLfnIndex++) 
....................                                     { 
....................                                        // get the source character 
....................                                        character = (BYTE)fileFoundString[fileCompareLfnIndex]; 
....................                                        // get the destination character 
....................                                        test = tempDst[fileCompareLfnIndex]; 
....................                                        if((fileFoundString[fileCompareLfnIndex] > 0xFF) || (tolower(character) != tolower(test))) 
....................                                        { 
....................                                           statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                           break; 
....................                                        } 
....................                                     }// for loop 
....................                            } 
....................                              } 
....................                              else 
....................                              { 
....................                                  // search for one. if status = TRUE we found one 
....................                                  for(index = 0; index < DIR_NAMECOMP; index++) 
....................                                  { 
....................                                      // get the source character 
....................                                      character = dst[index]; 
....................                                      // get the destination character 
....................                                      test = foCompareTo->name[index]; 
....................                                      if(tolower(character) != tolower(test)) 
....................                                      { 
....................                                          statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                          break; 
....................                                      } 
....................                                  }// for loop 
....................                         } 
....................                      } 
....................                            break; 
....................  
....................                      case 1: 
....................                      if(fileNameLength) 
....................                             { 
....................                         fileFoundDotPosition = FALSE; 
....................                         if(foundLFN) 
....................                         { 
....................                            lfnCountIndex = fileFoundMaxLfnIndex; 
....................                            while(lfnCountIndex > 0) 
....................                            { 
....................                               if(fileFoundString[lfnCountIndex] == '.') 
....................                               { 
....................                                  fileFoundDotPosition = TRUE; 
....................                                  lfnCountIndex--; 
....................                                  break; 
....................                               } 
....................                               lfnCountIndex--; 
....................                            } 
....................  
....................                            if(fileFoundDotPosition == FALSE) 
....................                               lfnCountIndex = fileFoundMaxLfnIndex; 
....................                         } 
....................                         else 
....................                         { 
....................                            if(dst[DIR_NAMESIZE] != ' ') 
....................                               fileFoundDotPosition = TRUE; 
....................                            lfnCountIndex = DIR_NAMESIZE - 1; 
....................                         } 
....................  
....................                         fileFoundLfnIndex = fileNameLength - 1; 
....................                         fileCompareDotPosition = FALSE; 
....................                         while(fileFoundLfnIndex > 0) 
....................                         { 
....................                            if(templfnPtr[fileFoundLfnIndex] == '.') 
....................                            { 
....................                               fileCompareDotPosition = TRUE; 
....................                               fileFoundLfnIndex--; 
....................                               break; 
....................                            } 
....................                            fileFoundLfnIndex--; 
....................                         } 
....................                         if(fileCompareDotPosition == FALSE) 
....................                            fileFoundLfnIndex = fileNameLength - 1; 
....................  
....................                                // Check for attribute match 
....................                                for(fileCompareLfnIndex = 0;;) 
....................                                { 
....................                                   if (templfnPtr[fileCompareLfnIndex] == '*') 
....................                                      break; 
....................  
....................                            if(fileCompareLfnIndex > lfnCountIndex) 
....................                                    { 
....................                                       statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                                    } 
....................  
....................                                   if (templfnPtr[fileCompareLfnIndex] != '?') 
....................                                   { 
....................                                 if(foCompareTo -> AsciiEncodingType) 
....................                                 { 
....................                                          // get the source character 
....................                                          character = (BYTE)templfnPtr[fileCompareLfnIndex]; 
....................                                          // get the destination character 
....................                                          if(foundLFN) 
....................                                             test = (BYTE)fileFoundString[fileCompareLfnIndex]; 
....................                                  else 
....................                                             test = dst[fileCompareLfnIndex]; 
....................  
....................                                  if((foundLFN && (fileFoundString[fileCompareLfnIndex] > 0xFF)) || 
....................                                             (tolower(character) != tolower(test))) 
....................                                          { 
....................                                             statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                             break; 
....................                                          } 
....................                                 } 
....................                                 else 
....................                                 { 
....................                                    if((templfnPtr[fileCompareLfnIndex] != fileFoundString[fileCompareLfnIndex]) || foundSFN) 
....................                                    { 
....................                                             statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                                    } 
....................                                 } 
....................                                   } 
....................  
....................                                    fileCompareLfnIndex++; 
....................                                    if(fileCompareLfnIndex > fileFoundLfnIndex) 
....................                                     { 
....................                                         if(fileCompareLfnIndex <= lfnCountIndex) 
....................                                         { 
....................                                          statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                               } 
....................                                         break; 
....................                            } 
....................                                }// for loop 
....................  
....................                         if(fileCompareDotPosition == FALSE) 
....................                         { 
....................                            if(fileFoundDotPosition == TRUE) 
....................                                    { 
....................                                       statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                    } 
....................                            break; 
....................                         } 
....................                         else 
....................                         { 
....................                            if(fileFoundDotPosition == FALSE) 
....................                                    { 
....................                                       statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                                    } 
....................  
....................                            if(foundLFN) 
....................                               lfnCountIndex = lfnCountIndex + 2; 
....................                            else 
....................                               lfnCountIndex = DIR_NAMESIZE; 
....................                         } 
....................  
....................                                // Check for attribute match 
....................                                for(fileCompareLfnIndex = fileFoundLfnIndex + 2;;) 
....................                                { 
....................                                   if (templfnPtr[fileCompareLfnIndex] == '*') 
....................                                      break; 
....................  
....................                            if((foundLFN && (lfnCountIndex > fileFoundMaxLfnIndex)) || (foundSFN && (lfnCountIndex == 11))) 
....................                            { 
....................                                       statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                            } 
....................  
....................                                   if (templfnPtr[fileCompareLfnIndex] != '?') 
....................                                   { 
....................                                 if(foCompareTo -> AsciiEncodingType) 
....................                                 { 
....................                                           // get the source character 
....................                                           character = (BYTE)templfnPtr[fileCompareLfnIndex]; 
....................                                           // get the destination character 
....................                                          if(foundLFN) 
....................                                             test = (BYTE)fileFoundString[lfnCountIndex]; 
....................                                  else 
....................                                             test = dst[lfnCountIndex]; 
....................                                  if((foundLFN && (fileFoundString[lfnCountIndex] > 0xFF)) || 
....................                                             (tolower(character) != tolower(test))) 
....................                                          { 
....................                                             statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                             break; 
....................                                          } 
....................                                 } 
....................                                 else 
....................                                 { 
....................                                    if((templfnPtr[fileCompareLfnIndex] != fileFoundString[lfnCountIndex]) || foundSFN) 
....................                                    { 
....................                                             statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                       break; 
....................                                    } 
....................                                 } 
....................                                   } 
....................                                    lfnCountIndex++; 
....................                                    fileCompareLfnIndex++; 
....................                                    if(fileCompareLfnIndex == fileNameLength) 
....................                                     { 
....................                                         if((foundLFN && (lfnCountIndex <= fileFoundMaxLfnIndex)) || (foundSFN && (lfnCountIndex < 11) && (dst[lfnCountIndex] != ' '))) 
....................                                         { 
....................                                          statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                               } 
....................                                         break; 
....................                            } 
....................                                }// for loop 
....................                      } 
....................                      else 
....................                      { 
....................                              /* We got something */ 
....................                                if(foundLFN) 
....................                                { 
....................                            fileCompareLfnIndex = fileFoundMaxLfnIndex; 
....................                            fileFoundDotPosition = FALSE; 
....................                            while(fileCompareLfnIndex > 0) 
....................                            { 
....................                               if(fileFoundString[fileCompareLfnIndex] == '.') 
....................                               { 
....................                                  fileFoundDotPosition = TRUE; 
....................                                  fileCompareLfnIndex--; 
....................                                  break; 
....................                               } 
....................                               fileCompareLfnIndex--; 
....................                            } 
....................  
....................                            if(fileFoundDotPosition == FALSE) 
....................                               fileCompareLfnIndex = fileFoundMaxLfnIndex; 
....................                         } 
....................                         else 
....................                            fileCompareLfnIndex = DIR_NAMESIZE - 1;   // Short File name last char position 
....................  
....................                                 if (foCompareTo->name[0] != '*')   //If "*" is passed for comparion as 1st char then don't proceed. Go back, file alreay found. 
....................                                 { 
....................                                     for (index = 0;;) 
....................                                     { 
....................                                         if(foundLFN) 
....................                                         { 
....................                                            if((fileFoundString[index] > 0xFF) || (index > fileCompareLfnIndex)) 
....................                                            { 
....................                                                statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                                break; 
....................                                  } 
....................                               } 
....................  
....................                                         // Get the source character 
....................                                      if(foundLFN) 
....................                                         character = (BYTE)fileFoundString[index]; 
....................                               else 
....................                                         character = dst[index]; 
....................  
....................                                         // Get the destination character 
....................                                         test = foCompareTo->name[index]; 
....................                                         if (test == '*') 
....................                                             break; 
....................                                         if (test != '?') 
....................                                         { 
....................                                             if(tolower(character) != tolower(test)) 
....................                                             { 
....................                                                 statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                                 break; 
....................                                             } 
....................                                         } 
....................  
....................                                       index++; 
....................                                       if(index == DIR_NAMESIZE) 
....................                                        { 
....................                                            if(foundLFN && (index <= fileCompareLfnIndex)) 
....................                                            { 
....................                                                statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                  } 
....................                                             break; 
....................                               } 
....................                                     } 
....................                                 } 
....................  
....................                                 // Before calling this "FILEfind" fn, "formatfilename" must be called. Hence, extn always starts from position "8". 
....................                                 if ((foCompareTo->name[8] != '*') && (statusB == CE_GOOD)) 
....................                                 { 
....................                                     if(foundLFN) 
....................                                     { 
....................                               if(foCompareTo->name[8] == ' ') 
....................                               { 
....................                                  if(fileFoundDotPosition == TRUE) 
....................                                            { 
....................                                                statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                  } 
....................                                  break; 
....................                               } 
....................                               else 
....................                               { 
....................                                  if(fileFoundDotPosition == FALSE) 
....................                                  { 
....................                                                statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                     break; 
....................                                  } 
....................                               } 
....................                               fileCompareLfnIndex = fileCompareLfnIndex + 2; 
....................                            } 
....................                            else 
....................                               fileCompareLfnIndex = DIR_NAMESIZE; 
....................  
....................                                     for (index = 8;;) 
....................                                     { 
....................                                         if(foundLFN) 
....................                                         { 
....................                                            if((fileFoundString[fileCompareLfnIndex] > 0xFF) || (fileCompareLfnIndex > fileFoundMaxLfnIndex)) 
....................                                            { 
....................                                                statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                                break; 
....................                                  } 
....................                               } 
....................                                         // Get the destination character 
....................                                         test = foCompareTo->name[index]; 
....................                                         // Get the source character 
....................                                      if(foundLFN) 
....................                                         character = (BYTE)fileFoundString[fileCompareLfnIndex++]; 
....................                               else 
....................                                         character = dst[fileCompareLfnIndex++]; 
....................  
....................                                         if (test == '*') 
....................                                             break; 
....................                                         if (test != '?') 
....................                                         { 
....................                                             if(tolower(character) != tolower(test)) 
....................                                             { 
....................                                                 statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                                 break; 
....................                                             } 
....................                                         } 
....................  
....................                               index++; 
....................                               if(index == DIR_NAMECOMP) 
....................                               { 
....................                                  if(foundLFN && (fileCompareLfnIndex <= fileFoundMaxLfnIndex)) 
....................                                     statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                  break; 
....................                               } 
....................                                     } 
....................                                 } 
....................                      } 
....................                             break; 
....................               } 
....................  
....................             // If the comparision of each character in LFN is completed 
....................             if(statusB == CE_GOOD) 
....................             { 
....................                if(foundLFN) 
....................                   fHandle++; 
....................  
....................                    state = Fill_File_Object(foDest, &fHandle); 
....................  
....................                if(foundLFN) 
....................                   fHandle--; 
....................  
....................                      /* We got something get the attributes */ 
....................                      attrib = foDest->attributes; 
....................  
....................                      attrib &= ATTR_MASK; 
....................  
....................                      switch (mode) 
....................                      { 
....................                          case 0: 
....................                              // see if we are a volume id or hidden, ignore 
....................                              if(attrib == ATTR_VOLUME) 
....................                                  statusB = CE_FILE_NOT_FOUND; 
....................                              break; 
....................  
....................                          case 1: 
....................                              // Check for attribute match 
....................                              if ((attrib & compareAttrib) != 0) 
....................                                  statusB = CE_FILE_NOT_FOUND; // Indicate the already filled file data is correct and go back 
....................                              if(foundLFN) 
....................                                 foDest->utf16LFNlength = fileFoundLength; 
....................                              else 
....................                         foDest->utf16LFNlength = 0; 
....................                              break; 
....................                      } 
....................             } 
....................             #else 
....................             { 
....................                       /* We got something */ 
....................                       // get the attributes 
....................                       attrib = foDest->attributes; 
....................  
....................                       attrib &= ATTR_MASK; 
....................                       switch (mode) 
....................                       { 
....................                           case 0: 
....................                               // see if we are a volume id or hidden, ignore 
....................                               if(attrib != ATTR_VOLUME) 
....................                               { 
....................                                   statusB = CE_GOOD; 
....................                                   character = (BYTE)'m'; // random value 
....................  
....................                                   // search for one. if status = TRUE we found one 
....................                                   for(index = 0; index < DIR_NAMECOMP; index++) 
....................                                   { 
....................                                       // get the source character 
....................                                       character = foDest->name[index]; 
....................                                       // get the destination character 
....................                                       test = foCompareTo->name[index]; 
....................                                       if(tolower(character) != tolower(test)) 
....................                                       { 
....................                                           statusB = CE_FILE_NOT_FOUND; // Nope its not a match 
....................                                           break; 
....................                                       } 
....................                                   }// for loop 
....................                               } // not dir nor vol 
....................                               break; 
....................  
....................                           case 1: 
....................                               // Check for attribute match 
....................                               if (((attrib & compareAttrib) == 0) && (attrib != ATTR_LONG_NAME)) 
....................                               { 
....................                                               #ifdef __DEBUG_UART   
....................                                                 PrintROMASCIIStringUART(" CHK_foCompareTo="); 
....................                                                 PrintRAMBytesUART(((unsigned char*)foCompareTo->name), 13); 
....................                                                 PrintROMASCIIStringUART(" foGot="); 
....................                                                 PrintRAMBytesUART(((unsigned char*)foDest->name), 13); 
....................                                                #endif   
....................                                                 
....................                                   statusB = CE_GOOD;                 // Indicate the already filled file data is correct and go back 
....................                                   character = (BYTE)'m';             // random value 
....................                                   if (foCompareTo->name[0] != '*')   //If "*" is passed for comparion as 1st char then don't proceed. Go back, file alreay found. 
....................                                   { 
....................                                       for (index = 0; index < DIR_NAMESIZE; index++) 
....................                                       { 
....................                                           // Get the source character 
....................                                           character = foDest->name[index]; 
....................                                           // Get the destination character 
....................                                           test = foCompareTo->name[index]; 
....................                                           if (test == '*') 
....................                                               break; 
....................                                           if (test != '?') 
....................                                           { 
....................                                               if(tolower(character) != tolower(test)) 
....................                                               { 
....................                                               #ifdef __DEBUG_UART   
....................                                                 PrintROMASCIIStringUART(" !NAMEMATCH!"); 
....................                                                #endif 
....................                                                   statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                                   break; 
....................                                               } 
....................                                           } 
....................                                       } 
....................                                   } 
....................  
....................                                   // Before calling this "FILEfind" fn, "formatfilename" must be called. Hence, extn always starts from position "8".                                  
....................                                   if ((foCompareTo->name[8] != '*') && (statusB == CE_GOOD)) 
....................                                   { 
....................                                       for (index = 8; index < DIR_NAMECOMP; index++) 
....................                                       { 
....................                                           // Get the source character 
....................                                           character = foDest->name[index]; 
....................                                           // Get the destination character 
....................                                           test = foCompareTo->name[index]; 
....................                                           if (test == '*') 
....................                                               break; 
....................                                           if (test != '?') 
....................                                           { 
....................                                               if(tolower(character) != tolower(test)) 
....................                                               { 
....................                                               #ifdef __DEBUG_UART   
....................                                                 PrintROMASCIIStringUART(" !EXTMATCH!"); 
....................                                                #endif                                               
....................                                                   statusB = CE_FILE_NOT_FOUND; // it's not a match 
....................                                                   break; 
....................                                               } 
....................                                           } 
....................                                       } 
....................                                   } 
....................  
....................                               } // Attribute match 
....................  
....................                               break; 
....................                       } 
....................                } 
....................               #endif 
....................             } // not found 
....................             else 
....................             { 
....................             #if defined(SUPPORT_LFN) 
....................                lfnFirstCheck = FALSE; 
....................             #endif 
....................                 /*** looking for an empty/re-usable entry ***/ 
....................                 if ( cmd == LOOK_FOR_EMPTY_ENTRY) 
....................                     statusB = CE_GOOD; 
....................             } // found or not 
....................  
....................          #if defined(SUPPORT_LFN) 
.................... //            if(foundLFN) 
.................... //            fHandle = fHandle + 2; 
.................... //             fHandle++; 
.................... //         else 
....................          #endif 
....................                // increment it no matter what happened 
....................                fHandle++; 
....................  
....................         }// while 
....................     } 
....................      
....................                                               #ifdef __DEBUG_UART   
....................                                                 PrintROMASCIIStringUART("FILEfind2 foCompareTo="); 
....................                                                 PrintRAMBytesUART(((unsigned char*)foCompareTo->name), 13); 
....................                                                #endif  
....................      
....................  
....................     return(statusB); 
.................... } // FILEFind 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     CETYPE FILEopen (FILEOBJ fo, WORD *fHandle, char type) 
....................   Summary: 
....................     Loads file information from the device 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -       File to be opened 
....................     fHandle -  Location of file 
....................     type - 
....................          -     FS_WRITE -  Create a new file or replace an existing file 
....................          -     FS_READ -   Read data from an existing file 
....................          -     FS_APPEND - Append data to an existing file 
....................   Return Values: 
....................     CE_GOOD -            FILEopen successful 
....................     CE_NOT_INIT -        Device is not yet initialized 
....................     CE_FILE_NOT_FOUND -  Could not find the file on the device 
....................     CE_BAD_SECTOR_READ - A bad read of a sector occured 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache a directory entry in the directory specified 
....................     by the dirclus parameter of hte FSFILE object 'fo.'  The offset of the 
....................     entry in the directory is specified by fHandle.  Once the directory entry 
....................     has been loaded, the first sector of the file can be loaded using the 
....................     cluster value specified in the directory entry. The type argument will 
....................     specify the mode the files will be opened in.  This will allow this 
....................     function to set the correct read/write flags for the file. 
....................   Remarks: 
....................     If the mode the file is being opened in is a plus mode (e.g. FS_READ+) the 
....................     flags will be modified further in the FSfopen function. 
....................   **************************************************************************/ 
....................  
.................... CETYPE FILEopen (FILEOBJ fo, WORD *fHandle, char type) 
.................... { 
....................     DISK   *dsk;      //Disk structure 
....................     BYTE    r;               //Result of search for file 
....................     DWORD    l;               //lba of first sector of first cluster 
....................     CETYPE    error = CE_GOOD; 
....................  
....................     dsk = (DISK *)(fo->dsk); 
....................     if (dsk->mount == FALSE) 
....................     { 
....................         error = CE_NOT_INIT; 
....................     } 
....................     else 
....................     { 
....................         // load the sector 
....................         fo->dirccls = fo->dirclus; 
....................         // Cache no matter what if it's the first entry 
....................         if (*fHandle == 0) 
....................         { 
....................             if (Cache_File_Entry(fo, fHandle, TRUE) == NULL) 
....................             { 
....................                 error = CE_BADCACHEREAD; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             // If it's not the first, only cache it if it's 
....................             // not divisible by the number of entries per sector 
....................             // If it is, Fill_File_Object will cache it 
....................             if ((*fHandle & 0xf) != 0) 
....................             { 
....................                 if (Cache_File_Entry (fo, fHandle, TRUE) == NULL) 
....................                 { 
....................                     error = CE_BADCACHEREAD; 
....................                 } 
....................             } 
....................         } 
....................  
....................         // Fill up the File Object with the information pointed to by fHandle 
....................         r = Fill_File_Object(fo, fHandle); 
....................         if (r != FOUND) 
....................             error = CE_FILE_NOT_FOUND; 
....................         else 
....................         { 
....................             fo->seek = 0;               // first byte in file 
....................             fo->ccls = fo->cluster;     // first cluster 
....................             fo->sec = 0;                // first sector in the cluster 
....................             fo->pos = 0;                // first byte in sector/cluster 
....................  
....................             if  ( r == NOT_FOUND) 
....................             { 
....................                 error = CE_FILE_NOT_FOUND; 
....................             } 
....................             else 
....................             { 
....................                 // Determine the lba of the selected sector and load 
....................                 l = Cluster2Sector(dsk,fo->ccls); 
.................... #ifdef ALLOW_WRITES 
....................                 if (gNeedDataWrite) 
....................                     if (flushData()) 
....................                         return CE_WRITE_ERROR; 
.................... #endif 
....................                 gBufferOwner = fo; 
....................                 if (gLastDataSectorRead != l) 
....................                 { 
....................                     gBufferZeroed = FALSE; 
....................                     if ( !MDD_SectorRead( l, dsk->buffer)) 
....................                         error = CE_BAD_SECTOR_READ; 
....................                     gLastDataSectorRead = l; 
....................                 } 
....................             } // -- found 
....................  
....................             fo->flags.FileWriteEOF = FALSE; 
....................             // Set flag for operation type 
.................... #ifdef ALLOW_WRITES 
....................             if ((type == 'w') || (type == 'a')) 
....................             { 
....................                 fo->flags.write = 1;   //write or append 
....................                 fo->flags.read = 0; 
....................             } 
....................             else 
....................             { 
.................... #endif 
....................                 fo->flags.write = 0;   //read 
....................                 fo->flags.read = 1; 
.................... #ifdef ALLOW_WRITES 
....................             } // -- flags 
.................... #endif 
....................         } // -- r = Found 
....................     } // -- Mounted 
....................     return (error); 
.................... } // -- FILEopen 
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE FILEget_next_cluster(FSFILE *fo, DWORD n) 
....................   Summary: 
....................     Step through a chain of clusters 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fo - The file to get the next cluster of 
....................     n -  Number of links in the FAT cluster chain to jump through 
....................   Return Values: 
....................     CE_GOOD - Operation successful 
....................     CE_BAD_SECTOR_READ - A bad read occured of a sector 
....................     CE_INVALID_CLUSTER - Invalid cluster value \> maxcls 
....................     CE_FAT_EOF - Fat attempt to read beyond EOF 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will load 'n' proximate clusters for a file from 
....................     the FAT on the device.  It will stop checking for clusters if the 
....................     ReadFAT function returns an error, if it reaches the last cluster in 
....................     a file, or if the device tries to read beyond the last cluster used 
....................     by the device. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... BYTE FILEget_next_cluster(FSFILE *fo, DWORD n) 
.................... { 
....................     DWORD         c, c2, ClusterFailValue, LastClustervalue; 
....................     BYTE          error = CE_GOOD; 
....................     DISK *      disk; 
....................  
....................     disk = fo->dsk; 
....................  
....................     /* Settings based on FAT type */ 
....................     switch (disk->type) 
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             LastClustervalue = LAST_CLUSTER_FAT32; 
....................             ClusterFailValue  = CLUSTER_FAIL_FAT32; 
....................             break; 
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
....................             LastClustervalue = LAST_CLUSTER_FAT12; 
....................             ClusterFailValue  = CLUSTER_FAIL_FAT16; 
....................             break; 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             LastClustervalue = LAST_CLUSTER_FAT16; 
....................             ClusterFailValue  = CLUSTER_FAIL_FAT16; 
....................             break; 
....................     } 
....................  
....................     // loop n times 
....................     do 
....................     { 
....................         // get the next cluster link from FAT 
....................         c2 = fo->ccls; 
....................         if ( (c = ReadFAT( disk, c2)) == ClusterFailValue) 
....................             error = CE_BAD_SECTOR_READ; 
....................         else 
....................         { 
....................             // check if cluster value is valid 
....................             if ( c >= disk->maxcls) 
....................             { 
....................                 error = CE_INVALID_CLUSTER; 
....................             } 
....................  
....................             // compare against max value of a cluster in FAT 
....................             // return if eof 
....................             if ( c >= LastClustervalue)    // check against eof 
....................             { 
....................                 error = CE_FAT_EOF; 
....................             } 
....................         } 
....................  
....................         // update the FSFILE structure 
....................         fo->ccls = c; 
....................  
....................     } while ((--n > 0) && (error == CE_GOOD));// loop end 
....................  
....................     return(error); 
.................... } // get next cluster 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     BYTE DISKmount ( DISK *dsk) 
....................   Summary: 
....................     Initialies the device and loads MBR and boot sector information 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -  The disk structure to be initialized. 
....................   Return Values: 
....................     CE_GOOD -       Disk mounted 
....................     CE_INIT_ERROR - Initialization error has occured 
....................     CE_UNSUPPORTED_SECTOR_SIZE - Media sector size bigger than 
....................                 MEDIA_SECTOR_SIZE as defined in FSconfig.h. 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will use the function pointed to by the MDD_MediaInitialize 
....................     function pointer to initialize the device (if any initialization is 
....................     required).  It then attempts to load the master boot record with the 
....................     LoadMBR function and the boot sector with the LoadBootSector function. 
....................     These two functions will be used to initialize a global DISK structure 
....................     that will be used when accessing file information in the future. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... BYTE DISKmount( DISK *dsk) 
.................... { 
....................     BYTE                error = CE_GOOD; 
....................     MEDIA_INFORMATION   *mediaInformation; 
....................  
....................     dsk->mount = FALSE; // default invalid 
....................     dsk->buffer = gDataBuffer;    // assign buffer 
....................  
....................     // Initialize the device 
....................     mediaInformation = MDD_MediaInitialize(); 
....................     if (mediaInformation->errorCode != MEDIA_NO_ERROR) 
....................     { 
....................         error = CE_INIT_ERROR; 
....................         FSerrno = CE_INIT_ERROR; 
....................     } 
....................     else 
....................     { 
....................         // If the media initialization routine determined the sector size, 
....................         // check it and make sure we can support it. 
....................         if (mediaInformation->validityFlags.bits.sectorSize) 
....................         { 
....................          dsk->sectorSize = mediaInformation->sectorSize; 
....................             if (mediaInformation->sectorSize > MEDIA_SECTOR_SIZE) 
....................             { 
....................                 error = CE_UNSUPPORTED_SECTOR_SIZE; 
....................                 FSerrno = CE_UNSUPPORTED_SECTOR_SIZE; 
....................                 return error; 
....................             } 
....................         } 
....................  
....................         // Load the Master Boot Record (partition) 
....................         if((error = LoadMBR(dsk)) == CE_GOOD) 
....................         { 
....................             // Now the boot sector 
....................             if((error = LoadBootSector(dsk)) == CE_GOOD) 
....................                 dsk->mount = TRUE; // Mark that the DISK mounted successfully 
....................         } 
....................     } // -- Load file parameters 
....................  
....................     return(error); 
.................... } // -- mount 
....................  
....................  
....................  
.................... /******************************************************************** 
....................   Function: 
....................     CETYPE LoadMBR ( DISK *dsk) 
....................   Summary: 
....................     Loads the MBR and extracts necessary information 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -  The disk containing the master boot record to be loaded 
....................   Return Values: 
....................     CE_GOOD -            MBR loaded successfully 
....................     CE_BAD_SECTOR_READ - A bad read occured of a sector 
....................     CE_BAD_PARTITION -   The boot record is bad 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The LoadMBR function will use the function pointed to by the 
....................     MDD_SectorRead function pointer to read the 0 sector from the 
....................     device.  If a valid boot signature is obtained, this function 
....................     will compare fields in that cached sector to the values that 
....................     would be present if that sector was a boot sector.  If all of 
....................     those values match, it will be assumed that the device does not 
....................     have a master boot record and the 0 sector is actually the boot 
....................     sector.  Otherwise, data about the partition and the actual 
....................     location of the boot sector will be loaded from the MBR into 
....................     the DISK structure pointed to by 'dsk.' 
....................   Remarks: 
....................     None 
....................   ********************************************************************/ 
....................  
.................... BYTE LoadMBR(DISK *dsk) 
.................... { 
....................     PT_MBR  Partition; 
....................     BYTE error = CE_GOOD; 
....................     BYTE type; 
....................     BootSec BSec; 
....................  
....................     // Get the partition table from the MBR 
....................     if ( MDD_SectorRead( FO_MBR, dsk->buffer) != TRUE) 
....................     { 
....................         #ifdef __DEBUG_UART 
....................         PrintROMASCIIStringUART("Error reading MBR block"); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................  
....................         error = CE_BAD_SECTOR_READ; 
....................         FSerrno = CE_BAD_SECTOR_READ; 
....................     } 
....................     else 
....................     { 
....................         #ifdef __DEBUG_UART 
....................         PrintROMASCIIStringUART("MBR:"); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         PrintRAMBytesUART(((unsigned char*)dsk->buffer), 512); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................  
....................         // Check if the card has no MBR 
....................         BSec = (BootSec) dsk->buffer; 
....................  
....................         #ifdef __DEBUG_UART 
....................         PrintROMASCIIStringUART("MBR Sig0="); 
....................         PrintRAMBytesUART(((unsigned char*)&BSec->Signature0), 1); 
....................         PrintROMASCIIStringUART(" Sig1="); 
....................         PrintRAMBytesUART(((unsigned char*)&BSec->Signature1), 1); 
....................         PrintROMASCIIStringUART(" FAT1* type="); 
....................         PrintRAMBytesUART(((unsigned char*)BSec->FAT.FAT_16.BootSec_FSType), 4); 
....................         PrintROMASCIIStringUART(" sig="); 
....................         PrintRAMBytesUART(((unsigned char*)&BSec->FAT.FAT_16.BootSec_BootSig), 1); 
....................         PrintROMASCIIStringUART(" FAT32 type="); 
....................         PrintRAMBytesUART(((unsigned char*)BSec->FAT.FAT_32.BootSec_FilSysType), 4); 
....................         PrintROMASCIIStringUART(" sig="); 
....................         PrintRAMBytesUART(((unsigned char*)&BSec->FAT.FAT_32.BootSec_BootSig), 1); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................  
....................         if((BSec->Signature0 == FAT_GOOD_SIGN_0) && (BSec->Signature1 == FAT_GOOD_SIGN_1)) 
....................         { 
....................          // Technically, the OEM name is not for indication 
....................          // The alternative is to read the CIS from attribute 
....................          // memory.  See the PCMCIA metaformat for more details 
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................             if ((ReadByte( dsk->buffer, BSI_FSTYPE ) == 'F') && \ 
....................             (ReadByte( dsk->buffer, BSI_FSTYPE + 1 ) == 'A') && \ 
....................             (ReadByte( dsk->buffer, BSI_FSTYPE + 2 ) == 'T') && \ 
....................             (ReadByte( dsk->buffer, BSI_FSTYPE + 3 ) == '1') && \ 
....................             (ReadByte( dsk->buffer, BSI_BOOTSIG) == 0x29)) 
.................... #else 
....................             if ((BSec->FAT.FAT_16.BootSec_FSType[0] == 'F') && \ 
....................                 (BSec->FAT.FAT_16.BootSec_FSType[1] == 'A') && \ 
....................                 (BSec->FAT.FAT_16.BootSec_FSType[2] == 'T') && \ 
....................                 (BSec->FAT.FAT_16.BootSec_FSType[3] == '1') && \ 
....................                 (BSec->FAT.FAT_16.BootSec_BootSig == 0x29)) 
.................... #endif 
....................              { 
....................                 dsk->firsts = 0; 
....................                 dsk->type = FAT16; 
....................                 return CE_GOOD; 
....................              } 
....................              else 
....................              { 
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................                 if ((ReadByte( dsk->buffer, BSI_FAT32_FSTYPE ) == 'F') && \ 
....................                     (ReadByte( dsk->buffer, BSI_FAT32_FSTYPE + 1 ) == 'A') && \ 
....................                     (ReadByte( dsk->buffer, BSI_FAT32_FSTYPE + 2 ) == 'T') && \ 
....................                     (ReadByte( dsk->buffer, BSI_FAT32_FSTYPE + 3 ) == '3') && \ 
....................                     (ReadByte( dsk->buffer, BSI_FAT32_BOOTSIG) == 0x29)) 
.................... #else 
....................                 if ((BSec->FAT.FAT_32.BootSec_FilSysType[0] == 'F') && \ 
....................                     (BSec->FAT.FAT_32.BootSec_FilSysType[1] == 'A') && \ 
....................                     (BSec->FAT.FAT_32.BootSec_FilSysType[2] == 'T') && \ 
....................                     (BSec->FAT.FAT_32.BootSec_FilSysType[3] == '3') && \ 
....................                     (BSec->FAT.FAT_32.BootSec_BootSig == 0x29)) 
.................... #endif 
....................                 { 
....................                     dsk->firsts = 0; 
....................                     dsk->type = FAT32; 
....................                     return CE_GOOD; 
....................                 } 
....................             } 
....................         } 
....................         // assign it the partition table strucutre 
....................         Partition = (PT_MBR)dsk->buffer; 
....................  
....................         #ifdef __DEBUG_UART 
....................         PrintROMASCIIStringUART("Partition Sig0="); 
....................         PrintRAMBytesUART(((unsigned char*)&Partition->Signature0), 1); 
....................         PrintROMASCIIStringUART(" Sig1="); 
....................         PrintRAMBytesUART(((unsigned char*)&Partition->Signature1), 1); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................  
....................         // Ensure its good 
....................         if((Partition->Signature0 != FAT_GOOD_SIGN_0) || (Partition->Signature1 != FAT_GOOD_SIGN_1)) 
....................         { 
....................             FSerrno = CE_BAD_PARTITION; 
....................             error = CE_BAD_PARTITION; 
....................         } 
....................         else 
....................         { 
....................             BYTE i; 
....................             PTE_MBR* partitionEntry = &Partition->Partition0; 
....................  
....................             for(i=0; i<4; i++) 
....................             { 
....................                 /*    Valid Master Boot Record Loaded   */ 
....................  
....................                 // Get the 32 bit offset to the first partition 
....................                 dsk->firsts = partitionEntry->PTE_FrstSect; 
....................  
....................                 // check if the partition type is acceptable 
....................                   type = partitionEntry->PTE_FSDesc; 
....................  
....................                 switch (type) 
....................                 { 
....................                 #ifdef SUPPORT_FAT12 
....................                     case 0x01: 
....................                         dsk->type = FAT12; 
....................                         break; 
....................                         #endif 
....................  
....................                 case 0x04: 
....................                     case 0x06: 
....................                     case 0x0E: 
....................                         dsk->type = FAT16; 
....................                         return(error); 
....................  
....................                     case 0x0B: 
....................                     case 0x0C: 
....................                         #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................                             dsk->type = FAT32;    // FAT32 is supported too 
....................                             return(error); 
....................                         #endif 
....................                 } // switch 
....................  
....................                 /* If we are here, we didn't find a matching partition.  We 
....................                    should increment to the next partition table entry */ 
....................                 partitionEntry++; 
....................             } 
....................  
....................             FSerrno = CE_UNSUPPORTED_FS; 
....................             error = CE_UNSUPPORTED_FS; 
....................         } 
....................     } 
....................  
....................     return(error); 
.................... }// -- LoadMBR 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     BYTE LoadBootSector (DISK *dsk) 
....................   Summary: 
....................     Load the boot sector and extract the necessary information 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -  The disk containing the boot sector 
....................   Return Values: 
....................     CE_GOOD -                    Boot sector loaded 
....................     CE_BAD_SECTOR_READ -         A bad read occured of a sector 
....................     CE_NOT_FORMATTED -           The disk is of an unsupported format 
....................     CE_CARDFAT32 -               FAT 32 device not supported 
....................     CE_UNSUPPORTED_SECTOR_SIZE - The sector size is not supported 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     LoadBootSector will use the function pointed to by the MDD_SectorWrite 
....................     function pointer to load the boot sector, whose location was obtained 
....................     by a previous call of LoadMBR.  If the boot sector is loaded successfully, 
....................     partition information will be calcualted from it and copied into the DISK 
....................     structure pointed to by 'dsk.' 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
....................  
.................... BYTE LoadBootSector(DISK *dsk) 
.................... { 
....................     DWORD       RootDirSectors; 
....................     DWORD       TotSec,DataSec; 
....................     BYTE        error = CE_GOOD; 
....................     BootSec     BSec; 
....................     WORD        BytesPerSec; 
....................     WORD        ReservedSectorCount; 
....................  
....................     #if defined(SUPPORT_FAT32) 
....................     BOOL        TriedSpecifiedBackupBootSec = FALSE; 
....................     BOOL        TriedBackupBootSecAtAddress6 = FALSE; 
....................     #endif 
....................     // Get the Boot sector 
....................     if ( MDD_SectorRead( dsk->firsts, dsk->buffer) != TRUE) 
....................     { 
....................         error = CE_BAD_SECTOR_READ; 
....................     } 
....................     else 
....................     { 
....................         BSec = (BootSec)dsk->buffer; 
....................  
....................         do      //test each possible boot sector (FAT32 can have backup boot sectors) 
....................         { 
....................  
....................             //Verify the Boot Sector has a valid signature 
....................             if(    (BSec->Signature0 != FAT_GOOD_SIGN_0) 
....................                 || (BSec->Signature1 != FAT_GOOD_SIGN_1) 
....................               ) 
....................             { 
....................                 error = CE_NOT_FORMATTED; 
....................             } 
....................             else 
....................             { 
....................  
....................                 do      //loop just to allow a break to jump out of this section of code 
....................                 { 
....................                     #ifdef __18CXX 
....................                     // Load count of sectors per cluster 
....................                     dsk->SecPerClus = BSec->FAT.FAT_16.BootSec_SPC; 
....................                     // Load the sector number of the first FAT sector 
....................                     dsk->fat        = dsk->firsts + BSec->FAT.FAT_16.BootSec_ResrvSec; 
....................                     // Load the count of FAT tables 
....................                     dsk->fatcopy    = BSec->FAT.FAT_16.BootSec_FATCount; 
....................                     // Load the size of the FATs 
....................                     dsk->fatsize = BSec->FAT.FAT_16.BootSec_SPF; 
....................                     if(dsk->fatsize == 0) 
....................                         dsk->fatsize  = BSec->FAT.FAT_32.BootSec_FATSz32; 
....................                     // Calculate the location of the root sector (for FAT12/16) 
....................                     dsk->root = dsk->fat + (DWORD)(dsk->fatcopy * (DWORD)dsk->fatsize); 
....................                     // Determine the max size of the root (will be 0 for FAT32) 
....................                     dsk->maxroot    = BSec->FAT.FAT_16.BootSec_RootDirEnts; 
....................  
....................                     // Determine the total number of sectors in the partition 
....................                     if(BSec->FAT.FAT_16.BootSec_TotSec16 != 0) 
....................                     { 
....................                         TotSec = BSec->FAT.FAT_16.BootSec_TotSec16; 
....................                     } 
....................                     else 
....................                     { 
....................                         TotSec = BSec->FAT.FAT_16.BootSec_TotSec32; 
....................                     } 
....................  
....................                     // Calculate the number of bytes in each sector 
....................                     BytesPerSec = BSec->FAT.FAT_16.BootSec_BPS; 
....................                     if( (BytesPerSec == 0) || ((BytesPerSec & 1) == 1) ) 
....................                     { 
....................                         error = CE_UNSUPPORTED_SECTOR_SIZE; 
....................                         break;  //break out of the do while loop 
....................                     } 
....................  
....................                     // Calculate the number of sectors in the root (will be 0 for FAT32) 
....................                     RootDirSectors = ((BSec->FAT.FAT_16.BootSec_RootDirEnts * 32) + (BSec->FAT.FAT_16.BootSec_BPS - 1)) / BSec->FAT.FAT_16.BootSec_BPS; 
....................                     // Calculate the number of data sectors on the card 
....................                     DataSec = TotSec - (dsk->root + RootDirSectors); 
....................                     // Calculate the maximum number of clusters on the card 
....................                     dsk->maxcls = DataSec / dsk->SecPerClus; 
....................  
....................                     #else // PIC24/30/33 
....................  
....................                     // Read the count of reserved sectors 
....................                     ReservedSectorCount = ReadWord( dsk->buffer, BSI_RESRVSEC ); 
....................                     // Load the count of sectors per cluster 
....................                     dsk->SecPerClus = ReadByte( dsk->buffer, BSI_SPC ); 
....................                     // Load the sector number of the first FAT sector 
....................                     dsk->fat = dsk->firsts + ReservedSectorCount; 
....................                     // Load the count of FAT tables 
....................                     dsk->fatcopy    = ReadByte( dsk->buffer, BSI_FATCOUNT ); 
....................                     // Load the size of the FATs 
....................                     dsk->fatsize = ReadWord( dsk->buffer, BSI_SPF ); 
....................                     if(dsk->fatsize == 0) 
....................                         dsk->fatsize  = ReadDWord( dsk->buffer, BSI_FATSZ32 ); 
....................                     // Calculate the location of the root sector (for FAT12/16) 
....................                     dsk->root = dsk->fat + (DWORD)(dsk->fatcopy * (DWORD)dsk->fatsize); 
....................                     // Determine the max size of the root (will be 0 for FAT32) 
....................                     dsk->maxroot = ReadWord( dsk->buffer, BSI_ROOTDIRENTS ); 
....................  
....................                     // Determine the total number of sectors in the partition 
....................                     TotSec = ReadWord( dsk->buffer, BSI_TOTSEC16 ); 
....................                     if( TotSec == 0 ) 
....................                         TotSec = ReadDWord( dsk->buffer, BSI_TOTSEC32 ); 
....................  
....................                     // Calculate the number of bytes in each sector 
....................                     BytesPerSec = ReadWord( dsk->buffer, BSI_BPS ); 
....................                     if( (BytesPerSec == 0) || ((BytesPerSec & 1) == 1) ) 
....................                     { 
....................                         error = CE_UNSUPPORTED_SECTOR_SIZE; 
....................                         break; 
....................                     } 
....................  
....................                     // Calculate the number of sectors in the root (will be 0 for FAT32) 
....................                     RootDirSectors = ((dsk->maxroot * NUMBER_OF_BYTES_IN_DIR_ENTRY) + (BytesPerSec - 1)) / BytesPerSec; 
....................                     // Calculate the number of data sectors on the card 
....................                     DataSec = TotSec - (ReservedSectorCount + (dsk->fatcopy * dsk->fatsize )  + RootDirSectors); 
....................                     // Calculate the maximum number of clusters on the card 
....................                     dsk->maxcls = DataSec / dsk->SecPerClus; 
....................  
....................                     #endif 
....................  
....................                     // Determine the file system type based on the number of clusters used 
....................                     #ifdef SUPPORT_FAT12 
....................                     if(dsk->maxcls < 4085) 
....................                     { 
....................                         dsk->type = FAT12; 
....................                     } 
....................                     else 
....................                     #endif 
....................                     { 
....................                         if(dsk->maxcls < 65525) 
....................                         { 
....................                             dsk->type = FAT16; 
....................                         } 
....................                         else 
....................                         { 
....................                             #ifdef SUPPORT_FAT32 
....................                                 dsk->type = FAT32; 
....................                             #else 
....................                                 error = CE_CARDFAT32; 
....................                             #endif 
....................                         } 
....................                     } 
....................  
....................                     #ifdef SUPPORT_FAT32 
....................                         if (dsk->type == FAT32) 
....................                         { 
....................                             #ifdef __18CXX 
....................                                 FatRootDirClusterValue =  BSec->FAT.FAT_32.BootSec_RootClus; 
....................                             #else 
....................                                 FatRootDirClusterValue = ReadDWord( dsk->buffer, BSI_ROOTCLUS ); 
....................                             #endif 
....................                             dsk->data = dsk->root + RootDirSectors; 
....................                         } 
....................                         else 
....................                     #endif 
....................                     { 
....................                         FatRootDirClusterValue = 0; 
....................                         dsk->data = dsk->root + ( dsk->maxroot >> 4); 
....................                     } 
....................  
....................                 #ifdef __18CXX 
....................                     if(BSec->FAT.FAT_16.BootSec_BPS > MEDIA_SECTOR_SIZE) 
....................                 #else 
....................                     if(BytesPerSec > MEDIA_SECTOR_SIZE) 
....................                 #endif 
....................                     { 
....................                         error = CE_UNSUPPORTED_SECTOR_SIZE; 
....................                     } 
....................  
....................                 }while(0);  // do/while loop designed to allow to break out if 
....................                             //   there is an error detected without returning 
....................                             //   from the function. 
....................  
....................             } 
....................  
....................             #if defined(SUPPORT_FAT32) 
....................             if ((dsk->type == FAT32) || ((error != CE_GOOD) && ((BSec->FAT.FAT_32.BootSec_BootSig == 0x29) || (BSec->FAT.FAT_32.BootSec_BootSig == 0x28)))) 
....................             { 
....................                 //Check for possible errors in the formatting 
....................                 if(    (BSec->FAT.FAT_32.BootSec_TotSec16 != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[0] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[1] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[2] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[3] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[4] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[5] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[6] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[7] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[8] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[9] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[10] != 0) 
....................                     || (BSec->FAT.FAT_32.BootSec_Reserved[11] != 0) 
....................                     || ((BSec->FAT.FAT_32.BootSec_BootSig != 0x29) && (BSec->FAT.FAT_32.BootSec_BootSig != 0x28)) 
....................                   ) 
....................                 { 
....................                     error = CE_NOT_FORMATTED; 
....................                 } 
....................  
....................                 //If there were formatting errors then in FAT32 we can try to use 
....................                 //  the backup boot sector 
....................                 if((error != CE_GOOD) && (TriedSpecifiedBackupBootSec == FALSE)) 
....................                 { 
....................                     TriedSpecifiedBackupBootSec = TRUE; 
....................  
....................                     if ( MDD_SectorRead( dsk->firsts + BSec->FAT.FAT_32.BootSec_BkBootSec, dsk->buffer) != TRUE) 
....................                     { 
....................                         FSerrno = CE_BAD_SECTOR_READ; 
....................                         return CE_BAD_SECTOR_READ; 
....................                     } 
....................                     else 
....................                     { 
....................                         error = CE_GOOD; 
....................                         continue; 
....................                     } 
....................                 } 
....................  
....................                 if((error != CE_GOOD) && (TriedBackupBootSecAtAddress6 == FALSE)) 
....................                 { 
....................                     TriedBackupBootSecAtAddress6 = TRUE; 
....................  
....................                     //Here we are using the magic number 6 because the FAT32 specification 
....................                     //  recommends that "No value other than 6 is recommended."  We've 
....................                     //  already tried using the value specified in the BPB_BkBootSec 
....................                     //  field and it must have failed 
....................                     if ( MDD_SectorRead( dsk->firsts + 6, dsk->buffer) != TRUE) 
....................                     { 
....................                         FSerrno = CE_BAD_SECTOR_READ; 
....................                         return CE_BAD_SECTOR_READ; 
....................                     } 
....................                     else 
....................                     { 
....................                         error = CE_GOOD; 
....................                         continue; 
....................                     } 
....................                 } 
....................  
....................             }   //type == FAT32 
....................             #endif  //SUPPORT_FAT32 
....................             break; 
....................         } 
....................         while(1); 
....................     } 
....................  
....................     if(error != CE_GOOD) 
....................     { 
....................         FSerrno = error; 
....................     } 
....................  
....................     return(error); 
.................... } 
....................  
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     DWORD GetFullClusterNumber (DIRENTRY entry) 
....................   Summary: 
....................     Gets the cluster number from a directory entry 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     entry - The cached directory entry to get the cluster number from 
....................   Returns: 
....................     The cluster value from the passed directory entry 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     This function will load both the high and low 16-bit first cluster 
....................     values of a file from a directory entry and copy them into a 32-bit 
....................     cluster number variable, which will be returned. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... DWORD GetFullClusterNumber(DIRENTRY entry) 
.................... { 
....................  
....................     DWORD TempFullClusterCalc = 0; 
....................  
.................... #ifndef SUPPORT_FAT32 // If FAT32 Not supported. 
....................     entry->DIR_FstClusHI = 0; // If FAT32 is not supported then Higher Word of the address is "0" 
.................... #endif 
....................  
....................     // Get the cluster 
....................     TempFullClusterCalc = (entry->DIR_FstClusHI); 
....................     TempFullClusterCalc = TempFullClusterCalc << 16; 
....................     TempFullClusterCalc |= entry->DIR_FstClusLO; 
....................  
....................     return TempFullClusterCalc; 
.................... } 
....................  
....................  
.................... #ifdef ALLOW_FORMATS 
.................... #ifdef ALLOW_WRITES 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     int FSCreateMBR (unsigned long firstSector, unsigned long numSectors) 
....................   Summary: 
....................     Creates a master boot record 
....................   Conditions: 
....................     The I/O pins for the device have been initialized by the InitIO function. 
....................   Input: 
....................     firstSector -  The first sector of the partition on the device (cannot 
....................                    be 0; that's the MBR) 
....................     numSectors -   The number of sectors available in memory (including the 
....................                    MBR) 
....................   Return Values: 
....................     0 -   MBR was created successfully 
....................     EOF - MBR could not be created 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function can be used to create a master boot record for a device.  Note 
....................     that this function should not be used on a device that is already formatted 
....................     with a master boot record (i.e. most SD cards, CF cards, USB keys).  This 
....................     function will fill the global data buffer with appropriate partition information 
....................     for a FAT partition with a type determined by the number of sectors available 
....................     to the partition.  It will then write the MBR information to the first sector 
....................     on the device.  This function should be followed by a call to FSformat, which 
....................     will create a boot sector, root dir, and FAT appropriate the the information 
....................     contained in the new master boot record.  Note that FSformat only supports 
....................     FAT12 and FAT16 formatting at this time, and so cannot be used to format a 
....................     device with more than 0x3FFD5F sectors. 
....................   Remarks: 
....................     This function can damage the device being used, and should not be called 
....................     unless the user is sure about the size of the device and the first sector value. 
....................   *********************************************************************************/ 
....................  
.................... int FSCreateMBR (unsigned long firstSector, unsigned long numSectors) 
.................... { 
....................     PT_MBR  Partition; 
....................     DWORD CyHdSc = 0x00000000; 
....................     DWORD tempSector; 
....................  
....................     if ((firstSector == 0) || (numSectors <= 1)) 
....................         return EOF; 
....................  
....................     if (firstSector > (numSectors - 1)) 
....................         return EOF; 
....................  
....................     if (gNeedDataWrite) 
....................         if (flushData()) 
....................             return EOF; 
....................  
....................     memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE); 
....................  
....................     Partition = (PT_MBR) gDataBuffer; 
....................  
....................     // Set Cylinder-head-sector address of the first sector 
....................     tempSector = firstSector; 
....................     CyHdSc = (tempSector / (unsigned int)16065 ) << 14; 
....................     tempSector %= 16065; 
....................     CyHdSc |= (tempSector / 63) << 6; 
....................     tempSector %= 63; 
....................     CyHdSc |= tempSector + 1; 
....................     gDataBuffer[447] = (BYTE)((CyHdSc >> 16) & 0xFF); 
....................     gDataBuffer[448] = (BYTE)((CyHdSc >> 8) & 0xFF); 
....................     gDataBuffer[449] = (BYTE)((CyHdSc) & 0xFF); 
....................  
....................     // Set the count of sectors 
....................     Partition->Partition0.PTE_NumSect = numSectors - firstSector; 
....................  
....................     // Set the partition type 
....................     // We only support creating FAT12 and FAT16 MBRs at this time 
....................     if (Partition->Partition0.PTE_NumSect < 0x1039) 
....................     { 
....................         // FAT12 
....................         Partition->Partition0.PTE_FSDesc = 0x01; 
....................     } 
....................     else if (Partition->Partition0.PTE_NumSect <= 0x3FFD5F) 
....................     { 
....................         // FAT16 
....................         Partition->Partition0.PTE_FSDesc = 0x06; 
....................     } 
....................     else 
....................         return EOF; 
....................  
....................     // Set the LBA of the first sector 
....................     Partition->Partition0.PTE_FrstSect = firstSector; 
....................  
....................     // Set the Cylinder-head-sector address of the last sector 
....................     tempSector = firstSector + numSectors - 1; 
....................     CyHdSc = (tempSector / (unsigned int)16065 ) << 14; 
....................     tempSector %= 16065; 
....................     CyHdSc |= (tempSector / 63) << 6; 
....................     tempSector %= 63; 
....................     CyHdSc |= tempSector + 1; 
....................     gDataBuffer[451] = (BYTE)((CyHdSc >> 16) & 0xFF); 
....................     gDataBuffer[452] = (BYTE)((CyHdSc >> 8) & 0xFF); 
....................     gDataBuffer[453] = (BYTE)((CyHdSc) & 0xFF); 
....................  
....................     // Set the boot descriptor.  This will be 0, since we won't 
....................     // be booting anything from our device probably 
....................     Partition->Partition0.PTE_BootDes = 0x00; 
....................  
....................     // Set the signature codes 
....................     Partition->Signature0 = 0x55; 
....................     Partition->Signature1 = 0xAA; 
....................  
....................     if (MDD_SectorWrite (0x00, gDataBuffer, TRUE) != TRUE) 
....................         return EOF; 
....................     else 
....................         return 0; 
....................  
.................... } 
....................  
....................  
.................... /******************************************************************* 
....................   Function: 
....................     int FSformat (char mode, long int serialNumber, char * volumeID) 
....................   Summary: 
....................     Formats a device 
....................   Conditions: 
....................     The device must possess a valid master boot record. 
....................   Input: 
....................     mode -          - 0 - Just erase the FAT and root 
....................                     - 1 - Create a new boot sector 
....................     serialNumber -  Serial number to write to the card 
....................     volumeID -      Name of the card 
....................   Return Values: 
....................     0 -    Format was successful 
....................     EOF -  Format was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSformat function can be used to create a new boot sector 
....................     on a device, based on the information in the master boot record. 
....................     This function will first initialize the I/O pins and the device, 
....................     and then attempts to read the master boot record.  If the MBR 
....................     cannot be loaded successfully, the function will fail.  Next, if 
....................     the 'mode' argument is specified as '0' the existing boot sector 
....................     information will be loaded.  If the 'mode' argument is '1' an 
....................     entirely new boot sector will be constructed using the disk 
....................     values from the master boot record.  Once the boot sector has 
....................     been successfully loaded/created, the locations of the FAT and 
....................     root will be loaded from it, and they will be completely 
....................     erased.  If the user has specified a volumeID parameter, a 
....................     VOLUME attribute entry will be created in the root directory 
....................     to name the device. 
....................  
....................     FAT12, FAT16 and FAT32 formatting are supported. 
....................  
....................     Based on the number of sectors, the format function automatically 
....................     compute the smallest possible value for the cluster size in order to 
....................     accommodate the physical size of the media. In this case, if a media 
....................     with a big capacity is formatted, the format function may take a very 
....................     long time to write all the FAT tables. 
....................  
....................     Therefore, the FORMAT_SECTORS_PER_CLUSTER macro may be used to 
....................     specify the exact cluster size (in multiples of sector size). This 
....................     macro can be defined in FSconfig.h 
....................  
....................   Remarks: 
....................     Only devices with a sector size of 512 bytes are supported by the 
....................     format function 
....................   *******************************************************************/ 
....................  
.................... int FSformat (char mode, long int serialNumber, char * volumeID) 
.................... { 
....................     PT_MBR   masterBootRecord; 
....................     DWORD    secCount, DataClusters, RootDirSectors; 
....................     BootSec   BSec; 
....................     DISK   d; 
....................     DISK * disk = &d; 
....................     WORD    j; 
....................     DWORD   fatsize, test; 
....................     DWORD Index; 
....................     MEDIA_INFORMATION * mediaInfo; 
.................... #ifdef __18CXX 
....................     // This is here because of a C18 compiler feature 
....................     BYTE *  dataBufferPointer = gDataBuffer; 
.................... #endif 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................     gBufferZeroed = FALSE; 
....................     gNeedFATWrite = FALSE; 
....................     gLastFATSectorRead = 0xFFFFFFFF; 
....................     gLastDataSectorRead = 0xFFFFFFFF; 
....................  
....................     disk->buffer = gDataBuffer; 
....................  
....................     MDD_InitIO(); 
....................  
....................     mediaInfo = MDD_MediaInitialize(); 
....................     if (mediaInfo->errorCode != MEDIA_NO_ERROR) 
....................     { 
....................         FSerrno = CE_INIT_ERROR; 
....................         return EOF; 
....................     } 
....................  
....................     if (MDD_SectorRead (0x00, gDataBuffer) == FALSE) 
....................     { 
....................         FSerrno = CE_BADCACHEREAD; 
....................         return EOF; 
....................     } 
....................  
....................     // Check if the card has no MBR 
....................     BSec = (BootSec) disk->buffer; 
....................     if((BSec->Signature0 == FAT_GOOD_SIGN_0) && (BSec->Signature1 == FAT_GOOD_SIGN_1)) 
....................     { 
....................         // Technically, the OEM name is not for indication 
....................         // The alternative is to read the CIS from attribute 
....................         // memory.  See the PCMCIA metaformat for more details 
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................         if ((ReadByte( disk->buffer, BSI_FSTYPE ) == 'F') && \ 
....................             (ReadByte( disk->buffer, BSI_FSTYPE + 1 ) == 'A') && \ 
....................             (ReadByte( disk->buffer, BSI_FSTYPE + 2 ) == 'T') && \ 
....................             (ReadByte( disk->buffer, BSI_FSTYPE + 3 ) == '1') && \ 
....................             (ReadByte( disk->buffer, BSI_BOOTSIG) == 0x29)) 
.................... #else 
....................         if ((BSec->FAT.FAT_16.BootSec_FSType[0] == 'F') && \ 
....................             (BSec->FAT.FAT_16.BootSec_FSType[1] == 'A') && \ 
....................             (BSec->FAT.FAT_16.BootSec_FSType[2] == 'T') && \ 
....................             (BSec->FAT.FAT_16.BootSec_FSType[3] == '1') && \ 
....................             (BSec->FAT.FAT_16.BootSec_BootSig == 0x29)) 
.................... #endif 
....................         { 
....................             /* Mark that we do not have a MBR; 
....................                 this is not actualy used - is here only to remove a compilation warning */ 
....................             masterBootRecord = (PT_MBR) NULL; 
....................             switch (mode) 
....................             { 
....................                 case 1: 
....................                     // not enough info to construct our own boot sector 
....................                     FSerrno = CE_INVALID_ARGUMENT; 
....................                     return EOF; 
....................                 case 0: 
....................                     // We have to determine the operating system, and the 
....................                     // locations and sizes of the root dir and FAT, and the 
....................                     // count of FATs 
....................                     disk->firsts = 0; 
....................                     if (LoadBootSector (disk) != CE_GOOD) 
....................                     { 
....................                         FSerrno = CE_BADCACHEREAD; 
....................                         return EOF; 
....................                     } 
....................                 default: 
....................                     break; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             masterBootRecord = (PT_MBR) &gDataBuffer; 
....................             disk->firsts = masterBootRecord->Partition0.PTE_FrstSect; 
....................         } 
....................     } 
....................     else 
....................     { 
....................         /* If the signature is not correct, this is neither a MBR, nor a VBR */ 
....................         FSerrno = CE_BAD_PARTITION; 
....................         return EOF; 
....................     } 
....................  
....................     switch (mode) 
....................     { 
....................         // True: Rewrite the whole boot sector 
....................         case 1: 
....................             secCount = masterBootRecord->Partition0.PTE_NumSect; 
....................  
....................            #ifdef SUPPORT_FAT12 
....................             if (secCount < 0x1039) 
....................             { 
....................                 disk->type = FAT12; 
....................                 // Format to FAT12 only if there are too few sectors to format 
....................                 // as FAT16 
....................                 masterBootRecord->Partition0.PTE_FSDesc = 0x01; 
....................                 if (MDD_SectorWrite (0x00, gDataBuffer, TRUE) == FALSE) 
....................                 { 
....................                     FSerrno = CE_WRITE_ERROR; 
....................                     return EOF; 
....................                 } 
....................  
....................                 if (secCount >= 0x1028) 
....................                 { 
....................                     // More than 0x18 sectors for FATs, 0x20 for root dir, 
....................                     // 0x8 reserved, and 0xFED for data 
....................                     // So double the number of sectors in a cluster to reduce 
....................                     // the number of data clusters used 
....................                     disk->SecPerClus = 2; 
....................                 } 
....................                 else 
....................                 { 
....................                     // One sector per cluster 
....................                     disk->SecPerClus = 1; 
....................                 } 
....................  
....................                 // Prepare a boot sector 
....................                 memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE); 
....................  
....................                 // Last digit of file system name (FAT12   ) 
....................                 gDataBuffer[58] = '2'; 
....................  
....................                 // Calculate the size of the FAT 
....................                 fatsize = (secCount - 0x21  + (2*disk->SecPerClus)); 
....................                 test =   (341 * disk->SecPerClus) + 2; 
....................                 fatsize = (fatsize + (test-1)) / test; 
....................  
....................                 disk->fatcopy = 0x02; 
....................                 disk->maxroot = 0x200; 
....................  
....................                 disk->fatsize = fatsize; 
....................  
....................             } 
....................             else 
....................            #endif 
....................             if (secCount <= 0x3FFD5F) 
....................             { 
....................                 disk->type = FAT16; 
....................                 // Format to FAT16 
....................                 masterBootRecord->Partition0.PTE_FSDesc = 0x06; 
....................                 if (MDD_SectorWrite (0x00, gDataBuffer, TRUE) == FALSE) 
....................                 { 
....................                     FSerrno = CE_WRITE_ERROR; 
....................                     return EOF; 
....................                 } 
....................  
....................                 DataClusters = secCount - 0x218; 
....................                 // Figure out how many sectors per cluster we need 
....................                 disk->SecPerClus = 1; 
....................                 while (DataClusters > 0xFFED) 
....................                 { 
....................                     disk->SecPerClus *= 2; 
....................                     DataClusters /= 2; 
....................                 } 
....................                 // This shouldnt happen 
....................                 if (disk->SecPerClus > 128) 
....................                 { 
....................                     FSerrno = CE_BAD_PARTITION; 
....................                     return EOF; 
....................                 } 
....................  
....................                 // Prepare a boot sector 
....................                 memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE); 
....................  
....................                 // Last digit of file system name (FAT16   ) 
....................                 gDataBuffer[58] = '6'; 
....................  
....................                 // Calculate the size of the FAT 
....................                 fatsize = (secCount - 0x21  + (2*disk->SecPerClus)); 
....................                 test =    (256  * disk->SecPerClus) + 2; 
....................                 fatsize = (fatsize + (test-1)) / test; 
....................  
....................                 disk->fatcopy = 0x02; 
....................                 disk->maxroot = 0x200; 
....................  
....................                 disk->fatsize = fatsize; 
....................             } 
....................             else 
....................             { 
....................                 disk->type = FAT32; 
....................                 // Format to FAT32 
....................                 masterBootRecord->Partition0.PTE_FSDesc = 0x0B; 
....................                 if (MDD_SectorWrite (0x00, gDataBuffer, TRUE) == FALSE) 
....................                 { 
....................                     FSerrno = CE_WRITE_ERROR; 
....................                     return EOF; 
....................                 } 
....................  
....................                 #ifdef FORMAT_SECTORS_PER_CLUSTER 
....................                     disk->SecPerClus = FORMAT_SECTORS_PER_CLUSTER; 
....................                     DataClusters = secCount / disk->SecPerClus; 
....................  
....................                     /* FAT32: 65526 < Number of clusters < 4177918 */ 
....................                     if ((DataClusters <= 65526) || (DataClusters >= 4177918)) 
....................                     { 
....................                         FSerrno = CE_BAD_PARTITION; 
....................                         return EOF; 
....................                     } 
....................                 #else 
....................                     /*  FAT32: 65526 < Number of clusters < 4177918 */ 
....................                     DataClusters = secCount; 
....................                     // Figure out how many sectors per cluster we need 
....................                     disk->SecPerClus = 1; 
....................                     while (DataClusters > 0x3FBFFE) 
....................                     { 
....................                         disk->SecPerClus *= 2; 
....................                         DataClusters /= 2; 
....................                     } 
....................                 #endif 
....................                 // Check the cluster size: FAT32 supports 512, 1024, 2048, 4096, 8192, 16K, 32K, 64K 
....................                 if (disk->SecPerClus > 128) 
....................                 { 
....................                     FSerrno = CE_BAD_PARTITION; 
....................                     return EOF; 
....................                 } 
....................  
....................                 // Prepare a boot sector 
....................                 memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE); 
....................  
....................                // Calculate the size of the FAT 
....................                 fatsize = (secCount - 0x20); 
....................                 test =    (128  * disk->SecPerClus) + 1; 
....................                 fatsize = (fatsize + (test-1)) / test; 
....................  
....................                 disk->fatcopy = 0x02; 
....................                 disk->maxroot = 0x200; 
....................  
....................                 disk->fatsize = fatsize; 
....................             } 
....................  
....................             // Non-file system specific values 
....................             gDataBuffer[0] = 0xEB;         //Jump instruction 
....................             gDataBuffer[1] = 0x3C; 
....................             gDataBuffer[2] = 0x90; 
....................             gDataBuffer[3] =  'M';         //OEM Name "MCHP FAT" 
....................             gDataBuffer[4] =  'C'; 
....................             gDataBuffer[5] =  'H'; 
....................             gDataBuffer[6] =  'P'; 
....................             gDataBuffer[7] =  ' '; 
....................             gDataBuffer[8] =  'F'; 
....................             gDataBuffer[9] =  'A'; 
....................             gDataBuffer[10] = 'T'; 
....................  
....................             gDataBuffer[11] = 0x00;             //Sector size 
....................             gDataBuffer[12] = 0x02; 
....................  
....................             gDataBuffer[13] = disk->SecPerClus;   //Sectors per cluster 
....................  
....................             if ((disk->type == FAT12) || (disk->type == FAT16)) 
....................             { 
....................                 gDataBuffer[14] = 0x08;         //Reserved sector count 
....................                 gDataBuffer[15] = 0x00; 
....................                 disk->fat = 0x08 + disk->firsts; 
....................  
....................                 gDataBuffer[16] = 0x02;         //number of FATs 
....................  
....................                 gDataBuffer[17] = 0x00;          //Max number of root directory entries - 512 files allowed 
....................                 gDataBuffer[18] = 0x02; 
....................  
....................                 gDataBuffer[19] = 0x00;         //total sectors 
....................                 gDataBuffer[20] = 0x00; 
....................  
....................                 gDataBuffer[21] = 0xF8;         //Media Descriptor 
....................  
....................                 gDataBuffer[22] = fatsize & 0xFF;         //Sectors per FAT 
....................                 gDataBuffer[23] = (fatsize >> 8) & 0xFF; 
....................  
....................                 gDataBuffer[24] = 0x3F;           //Sectors per track 
....................                 gDataBuffer[25] = 0x00; 
....................  
....................                 gDataBuffer[26] = 0xFF;         //Number of heads 
....................                 gDataBuffer[27] = 0x00; 
....................  
....................                 // Hidden sectors = sectors between the MBR and the boot sector 
....................                 gDataBuffer[28] = (BYTE)(disk->firsts & 0xFF); 
....................                 gDataBuffer[29] = (BYTE)((disk->firsts / 0x100) & 0xFF); 
....................                 gDataBuffer[30] = (BYTE)((disk->firsts / 0x10000) & 0xFF); 
....................                 gDataBuffer[31] = (BYTE)((disk->firsts / 0x1000000) & 0xFF); 
....................  
....................                 // Total Sectors = same as sectors in the partition from MBR 
....................                 gDataBuffer[32] = (BYTE)(secCount & 0xFF); 
....................                 gDataBuffer[33] = (BYTE)((secCount / 0x100) & 0xFF); 
....................                 gDataBuffer[34] = (BYTE)((secCount / 0x10000) & 0xFF); 
....................                 gDataBuffer[35] = (BYTE)((secCount / 0x1000000) & 0xFF); 
....................  
....................                 gDataBuffer[36] = 0x00;         // Physical drive number 
....................  
....................                 gDataBuffer[37] = 0x00;         // Reserved (current head) 
....................  
....................                 gDataBuffer[38] = 0x29;         // Signature code 
....................  
....................                 gDataBuffer[39] = (BYTE)(serialNumber & 0xFF); 
....................                 gDataBuffer[40] = (BYTE)((serialNumber / 0x100) & 0xFF); 
....................                 gDataBuffer[41] = (BYTE)((serialNumber / 0x10000) & 0xFF); 
....................                 gDataBuffer[42] = (BYTE)((serialNumber / 0x1000000) & 0xFF); 
....................  
....................                 // Volume ID 
....................                 if (volumeID != NULL) 
....................                 { 
....................                     for (Index = 0; (*(volumeID + Index) != 0) && (Index < 11); Index++) 
....................                     { 
....................                         gDataBuffer[Index + 43] = *(volumeID + Index); 
....................                     } 
....................                     while (Index < 11) 
....................                     { 
....................                         gDataBuffer[43 + Index++] = 0x20; 
....................                     } 
....................                 } 
....................                 else 
....................                 { 
....................                     for (Index = 0; Index < 11; Index++) 
....................                     { 
....................                         gDataBuffer[Index+43] = 0; 
....................                     } 
....................                 } 
....................  
....................                 gDataBuffer[54] = 'F'; 
....................                 gDataBuffer[55] = 'A'; 
....................                 gDataBuffer[56] = 'T'; 
....................                 gDataBuffer[57] = '1'; 
....................                 gDataBuffer[59] = ' '; 
....................                 gDataBuffer[60] = ' '; 
....................                 gDataBuffer[61] = ' '; 
....................  
....................             } 
....................             else //FAT32 
....................             { 
....................                 gDataBuffer[14] = 0x20;         //Reserved sector count 
....................                 gDataBuffer[15] = 0x00; 
....................                 disk->fat = 0x20 + disk->firsts; 
....................  
....................                 gDataBuffer[16] = 0x02;         //number of FATs 
....................  
....................                 gDataBuffer[17] = 0x00;          //Max number of root directory entries - 512 files allowed 
....................                 gDataBuffer[18] = 0x00; 
....................  
....................                 gDataBuffer[19] = 0x00;         //total sectors 
....................                 gDataBuffer[20] = 0x00; 
....................  
....................                 gDataBuffer[21] = 0xF8;         //Media Descriptor 
....................  
....................                 gDataBuffer[22] = 0x00;         //Sectors per FAT 
....................                 gDataBuffer[23] = 0x00; 
....................  
....................                 gDataBuffer[24] = 0x3F;         //Sectors per track 
....................                 gDataBuffer[25] = 0x00; 
....................  
....................                 gDataBuffer[26] = 0xFF;         //Number of heads 
....................                 gDataBuffer[27] = 0x00; 
....................  
....................                 // Hidden sectors = sectors between the MBR and the boot sector 
....................                 gDataBuffer[28] = (BYTE)(disk->firsts & 0xFF); 
....................                 gDataBuffer[29] = (BYTE)((disk->firsts / 0x100) & 0xFF); 
....................                 gDataBuffer[30] = (BYTE)((disk->firsts / 0x10000) & 0xFF); 
....................                 gDataBuffer[31] = (BYTE)((disk->firsts / 0x1000000) & 0xFF); 
....................  
....................                 // Total Sectors = same as sectors in the partition from MBR 
....................                 gDataBuffer[32] = (BYTE)(secCount & 0xFF); 
....................                 gDataBuffer[33] = (BYTE)((secCount / 0x100) & 0xFF); 
....................                 gDataBuffer[34] = (BYTE)((secCount / 0x10000) & 0xFF); 
....................                 gDataBuffer[35] = (BYTE)((secCount / 0x1000000) & 0xFF); 
....................  
....................                 gDataBuffer[36] = fatsize & 0xFF;         //Sectors per FAT 
....................                 gDataBuffer[37] = (fatsize >>  8) & 0xFF; 
....................                 gDataBuffer[38] = (fatsize >> 16) & 0xFF; 
....................                 gDataBuffer[39] = (fatsize >> 24) & 0xFF; 
....................  
....................                 gDataBuffer[40] = 0x00;         //Active FAT 
....................                 gDataBuffer[41] = 0x00; 
....................  
....................                 gDataBuffer[42] = 0x00;         //File System version 
....................                 gDataBuffer[43] = 0x00; 
....................  
....................                 gDataBuffer[44] = 0x02;         //First cluster of the root directory 
....................                 gDataBuffer[45] = 0x00; 
....................                 gDataBuffer[46] = 0x00; 
....................                 gDataBuffer[47] = 0x00; 
....................  
....................                 gDataBuffer[48] = 0x01;         //FSInfo 
....................                 gDataBuffer[49] = 0x00; 
....................  
....................                 gDataBuffer[50] = 0x00;         //Backup Boot Sector 
....................                 gDataBuffer[51] = 0x00; 
....................  
....................                 gDataBuffer[52] = 0x00;         //Reserved for future expansion 
....................                 gDataBuffer[53] = 0x00; 
....................                 gDataBuffer[54] = 0x00; 
....................                 gDataBuffer[55] = 0x00; 
....................                 gDataBuffer[56] = 0x00; 
....................                 gDataBuffer[57] = 0x00; 
....................                 gDataBuffer[58] = 0x00; 
....................                 gDataBuffer[59] = 0x00; 
....................                 gDataBuffer[60] = 0x00; 
....................                 gDataBuffer[61] = 0x00; 
....................                 gDataBuffer[62] = 0x00; 
....................                 gDataBuffer[63] = 0x00; 
....................  
....................                 gDataBuffer[64] = 0x00;         // Physical drive number 
....................  
....................                 gDataBuffer[65] = 0x00;         // Reserved (current head) 
....................  
....................                 gDataBuffer[66] = 0x29;         // Signature code 
....................  
....................                 gDataBuffer[67] = (BYTE)(serialNumber & 0xFF); 
....................                 gDataBuffer[68] = (BYTE)((serialNumber / 0x100) & 0xFF); 
....................                 gDataBuffer[69] = (BYTE)((serialNumber / 0x10000) & 0xFF); 
....................                 gDataBuffer[70] = (BYTE)((serialNumber / 0x1000000) & 0xFF); 
....................  
....................                 // Volume ID 
....................                 if (volumeID != NULL) 
....................                 { 
....................                     for (Index = 0; (*(volumeID + Index) != 0) && (Index < 11); Index++) 
....................                     { 
....................                         gDataBuffer[Index + 71] = *(volumeID + Index); 
....................                     } 
....................                     while (Index < 11) 
....................                     { 
....................                         gDataBuffer[71 + Index++] = 0x20; 
....................                     } 
....................                 } 
....................                 else 
....................                 { 
....................                     for (Index = 0; Index < 11; Index++) 
....................                     { 
....................                         gDataBuffer[Index+71] = 0; 
....................                     } 
....................                 } 
....................  
....................                 gDataBuffer[82] = 'F'; 
....................                 gDataBuffer[83] = 'A'; 
....................                 gDataBuffer[84] = 'T'; 
....................                 gDataBuffer[85] = '3'; 
....................                 gDataBuffer[86] = '2'; 
....................                 gDataBuffer[87] = ' '; 
....................                 gDataBuffer[88] = ' '; 
....................                 gDataBuffer[89] = ' '; 
....................  
....................  
....................             } 
....................  
.................... #ifdef __18CXX 
....................             // C18 can't reference a value greater than 256 
....................             // using an array name pointer 
....................             *(dataBufferPointer + 510) = 0x55; 
....................             *(dataBufferPointer + 511) = 0xAA; 
.................... #else 
....................             gDataBuffer[510] = 0x55; 
....................             gDataBuffer[511] = 0xAA; 
.................... #endif 
....................  
....................             disk->root = disk->fat + (disk->fatcopy * disk->fatsize); 
....................  
....................             if (MDD_SectorWrite (disk->firsts, gDataBuffer, FALSE) == FALSE) 
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
....................                 return EOF; 
....................             } 
....................  
....................             break; 
....................         case 0: 
....................             if (LoadBootSector (disk) != CE_GOOD) 
....................             { 
....................                 FSerrno = CE_BADCACHEREAD; 
....................                 return EOF; 
....................             } 
....................             break; 
....................         default: 
....................             FSerrno = CE_INVALID_ARGUMENT; 
....................             return EOF; 
....................     } 
....................  
....................     // Erase the FAT 
....................     memset (gDataBuffer, 0x00, MEDIA_SECTOR_SIZE); 
....................  
....................     if (disk->type == FAT32) 
....................     { 
....................         gDataBuffer[0] = 0xF8;          //BPB_Media byte value in its low 8 bits, and all other bits are set to 1 
....................         gDataBuffer[1] = 0xFF; 
....................         gDataBuffer[2] = 0xFF; 
....................         gDataBuffer[3] = 0xFF; 
....................  
....................         gDataBuffer[4] = 0x00;          //Disk is clean and no read/write errors were encountered 
....................         gDataBuffer[5] = 0x00; 
....................         gDataBuffer[6] = 0x00; 
....................         gDataBuffer[7] = 0x0C; 
....................  
....................         gDataBuffer[8]  = 0xFF;         //Root Directory EOF 
....................         gDataBuffer[9]  = 0xFF; 
....................         gDataBuffer[10] = 0xFF; 
....................         gDataBuffer[11] = 0xFF; 
....................  
....................         for (j = disk->fatcopy - 1; j != 0xFFFF; j--) 
....................         { 
....................             if (MDD_SectorWrite (disk->fat + (j * disk->fatsize), gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         memset (gDataBuffer, 0x00, 12); 
....................  
....................         for (Index = disk->fat + 1; Index < (disk->fat + disk->fatsize); Index++) 
....................         { 
....................             for (j = disk->fatcopy - 1; j != 0xFFFF; j--) 
....................             { 
....................                 if (MDD_SectorWrite (Index + (j * disk->fatsize), gDataBuffer, FALSE) == FALSE) 
....................                     return EOF; 
....................             } 
....................         } 
....................  
....................         // Erase the root directory 
....................         for (Index = 1; Index < disk->SecPerClus; Index++) 
....................         { 
....................             if (MDD_SectorWrite (disk->root + Index, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         if (volumeID != NULL) 
....................         { 
....................             // Create a drive name entry in the root dir 
....................             Index = 0; 
....................             while ((*(volumeID + Index) != 0) && (Index < 11)) 
....................             { 
....................                 gDataBuffer[Index] = *(volumeID + Index); 
....................                 Index++; 
....................             } 
....................             while (Index < 11) 
....................             { 
....................                 gDataBuffer[Index++] = ' '; 
....................             } 
....................             gDataBuffer[11] = 0x08; 
....................             gDataBuffer[17] = 0x11; 
....................             gDataBuffer[19] = 0x11; 
....................             gDataBuffer[23] = 0x11; 
....................  
....................             if (MDD_SectorWrite (disk->root, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................         else 
....................         { 
....................             if (MDD_SectorWrite (disk->root, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         return 0; 
....................     } 
....................     else 
....................     { 
....................         gDataBuffer[0] = 0xF8; 
....................         gDataBuffer[1] = 0xFF; 
....................         gDataBuffer[2] = 0xFF; 
....................         if (disk->type == FAT16) 
....................             gDataBuffer[3] = 0xFF; 
....................  
....................         for (j = disk->fatcopy - 1; j != 0xFFFF; j--) 
....................         { 
....................             if (MDD_SectorWrite (disk->fat + (j * disk->fatsize), gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         memset (gDataBuffer, 0x00, 4); 
....................  
....................         for (Index = disk->fat + 1; Index < (disk->fat + disk->fatsize); Index++) 
....................         { 
....................             for (j = disk->fatcopy - 1; j != 0xFFFF; j--) 
....................             { 
....................                 if (MDD_SectorWrite (Index + (j * disk->fatsize), gDataBuffer, FALSE) == FALSE) 
....................                     return EOF; 
....................             } 
....................         } 
....................  
....................       // Initialize the sector size 
....................         disk->sectorSize = MEDIA_SECTOR_SIZE; 
....................  
....................         // Erase the root directory 
....................         RootDirSectors = ((disk->maxroot * 32) + (disk->sectorSize - 1)) / disk->sectorSize; 
....................  
....................         for (Index = 1; Index < RootDirSectors; Index++) 
....................         { 
....................             if (MDD_SectorWrite (disk->root + Index, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         if (volumeID != NULL) 
....................         { 
....................             // Create a drive name entry in the root dir 
....................             Index = 0; 
....................             while ((*(volumeID + Index) != 0) && (Index < 11)) 
....................             { 
....................                 gDataBuffer[Index] = *(volumeID + Index); 
....................                 Index++; 
....................             } 
....................             while (Index < 11) 
....................             { 
....................                 gDataBuffer[Index++] = ' '; 
....................             } 
....................             gDataBuffer[11] = 0x08; 
....................             gDataBuffer[17] = 0x11; 
....................             gDataBuffer[19] = 0x11; 
....................             gDataBuffer[23] = 0x11; 
....................  
....................             if (MDD_SectorWrite (disk->root, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................         else 
....................         { 
....................             if (MDD_SectorWrite (disk->root, gDataBuffer, FALSE) == FALSE) 
....................                 return EOF; 
....................         } 
....................  
....................         return 0; 
....................     } 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /******************************************************* 
....................   Function: 
....................     BYTE Write_File_Entry( FILEOBJ fo, WORD * curEntry) 
....................   Summary: 
....................     Write dir entry info into a specified entry 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -        \File structure 
....................     curEntry -  Write destination 
....................   Return Values: 
....................     TRUE - Operation successful 
....................     FALSE - Operation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will calculate the sector of the 
....................     directory (whose base sector is pointed to by the 
....................     dirccls value in the FSFILE object 'fo') that contains 
....................     a directory entry whose offset is indicated by the 
....................     curEntry parameter.  It will then write the data 
....................     in the global data buffer (which should already 
....................     contain the entries for that sector) to the device. 
....................   Remarks: 
....................     None 
....................   *******************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE Write_File_Entry( FILEOBJ fo, WORD * curEntry) 
.................... { 
....................     DISK   *dsk; 
....................     BYTE   status; 
....................     BYTE   offset2; 
....................     DWORD   sector; 
....................     DWORD   ccls; 
....................  
....................     dsk = fo->dsk; 
....................  
....................     // get the cluster of this entry 
....................     ccls = fo->dirccls; 
....................  
....................      // figure out the offset from the base sector 
....................     offset2  = (*curEntry / (dsk->sectorSize/32)); 
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             // Root is always cluster-based in FAT32 
....................             offset2 = offset2 % (dsk->SecPerClus); 
....................             break; 
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
.................... #endif 
....................         case FAT16: 
....................             if(ccls != FatRootDirClusterValue) 
....................                 offset2 = offset2 % (dsk->SecPerClus); 
....................             break; 
....................     } 
....................  
....................     sector = Cluster2Sector(dsk,ccls); 
....................  
....................     // Now write it 
....................     // "Offset" ensures writing of data belonging to a file entry only. Hence it doesn't change other file entries. 
....................     if ( !MDD_SectorWrite( sector + offset2, dsk->buffer, FALSE)) 
....................         status = FALSE; 
....................     else 
....................         status = TRUE; 
....................  
....................     return(status); 
.................... } // Write_File_Entry 
.................... #endif 
....................  
....................  
.................... /********************************************************** 
....................   Function: 
....................     BYTE FAT_erase_cluster_chain (WORD cluster, DISK * dsk) 
....................   Summary: 
....................     Erase a chain of clusters 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     cluster -  The cluster number 
....................     dsk -      The disk structure 
....................   Return Values: 
....................     TRUE -  Operation successful 
....................     FALSE - Operation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will parse through a cluster chain 
....................     starting with the cluster pointed to by 'cluster' and 
....................     mark all of the FAT entries as empty until the end of 
....................     the chain has been reached or an error occurs. 
....................   Remarks: 
....................     None 
....................   **********************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE FAT_erase_cluster_chain (DWORD cluster, DISK * dsk) 
.................... { 
....................     DWORD     c,c2,ClusterFailValue; 
....................     enum    _status {Good, Fail, Exit}status; 
....................  
....................     status = Good; 
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
....................     { 
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             ClusterFailValue = CLUSTER_FAIL_FAT32; 
....................             c2 =  LAST_CLUSTER_FAT32; 
....................             break; 
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; // FAT16 value itself 
....................             c2 =  LAST_CLUSTER_FAT12; 
....................             break; 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
....................             c2 =  LAST_CLUSTER_FAT16; 
....................             break; 
....................     } 
....................  
....................     // Make sure there is actually a cluster assigned 
....................     if((cluster == 0) || (cluster == 1))  // Cluster assigned can't be "0" and "1" 
....................     { 
....................         status = Exit; 
....................     } 
....................     else 
....................     { 
....................         while(status == Good) 
....................         { 
....................             // Get the FAT entry 
....................             if((c = ReadFAT( dsk, cluster)) == ClusterFailValue) 
....................                 status = Fail; 
....................             else 
....................             { 
....................                 if((c == 0) || (c == 1))  // Cluster assigned can't be "0" and "1" 
....................                 { 
....................                     status = Exit; 
....................                 } 
....................                 else 
....................                 { 
....................                     // compare against max value of a cluster in FATxx 
....................                     // look for the last cluster in the chain 
....................                     if ( c >= c2) 
....................                         status = Exit; 
....................  
....................                     // Now erase this FAT entry 
....................                     if(WriteFAT(dsk, cluster, CLUSTER_EMPTY, FALSE) == ClusterFailValue) 
....................                         status = Fail; 
....................  
....................                     // now update what the current cluster is 
....................                     cluster = c; 
....................                 } 
....................             } 
....................         }// while status 
....................     }// cluster == 0 
....................  
....................     WriteFAT (dsk, 0, 0, TRUE); 
....................  
....................     if(status == Exit) 
....................         return(TRUE); 
....................     else 
....................         return(FALSE); 
.................... } // Erase cluster 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     DIRENTRY Cache_File_Entry( FILEOBJ fo, WORD * curEntry, BYTE ForceRead) 
....................   Summary: 
....................     Load a file entry 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -         File information 
....................     curEntry -   Offset of the directory entry to load. 
....................     ForceRead -  Forces loading of a new sector of the directory. 
....................   Return: 
....................     DIRENTRY - Pointer to the directory entry that was loaded. 
....................   Side Effects: 
....................     Any unwritten data in the data buffer will be written to the device. 
....................   Description: 
....................     Load the sector containing the file entry pointed to by 'curEntry' 
....................     from the directory pointed to by the variables in 'fo.' 
....................   Remarks: 
....................     Any modification of this function is extremely likely to 
....................     break something. 
....................   **************************************************************************/ 
....................  
.................... DIRENTRY Cache_File_Entry( FILEOBJ fo, WORD * curEntry, BYTE ForceRead) 
.................... { 
....................     DIRENTRY dir; 
....................     DISK *dsk; 
....................     DWORD sector; 
....................     DWORD cluster, LastClusterLimit; 
....................     DWORD ccls; 
....................     BYTE offset2; 
....................     BYTE numofclus; 
....................    BYTE dirEntriesPerSector; 
....................  
....................     dsk = fo->dsk; 
....................  
....................     // get the base sector of this directory 
....................     cluster = fo->dirclus; 
....................     ccls = fo->dirccls; 
....................  
....................    dirEntriesPerSector = dsk->sectorSize/32; 
....................  
....................      // figure out the offset from the base sector 
....................     offset2  = (*curEntry / dirEntriesPerSector); 
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             // the ROOT is always cluster based in FAT32 
....................             /* In FAT32: There is no ROOT region. Root etries are made in DATA region only. 
....................             Every cluster of DATA which is accupied by ROOT is tracked by FAT table/entry so the ROOT can grow 
....................             to an amount which is restricted only by available free DATA region. */ 
....................             offset2  = offset2 % (dsk->SecPerClus);   // figure out the offset 
....................             LastClusterLimit = LAST_CLUSTER_FAT32; 
....................             break; 
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             // if its the root its not cluster based 
....................             if(cluster != 0) 
....................                 offset2  = offset2 % (dsk->SecPerClus);   // figure out the offset 
....................             LastClusterLimit = LAST_CLUSTER_FAT16; 
....................             break; 
....................     } 
....................  
....................    //#ifdef __DEBUG_UART   
....................    #if 0 
....................    PrintROMASCIIStringUART("Cache_File_Entry"); 
....................     
....................    PrintROMASCIIStringUART(" cluster="); 
....................    PrintRAMBytesUART(((unsigned char*)&cluster), sizeof(cluster)); 
....................  
....................    PrintROMASCIIStringUART(" ccls="); 
....................    PrintRAMBytesUART(((unsigned char*)&ccls), sizeof(ccls)); 
....................  
....................    PrintROMASCIIStringUART(" dirEntriesPerSector="); 
....................    PrintRAMBytesUART(((unsigned char*)&dirEntriesPerSector), sizeof(dirEntriesPerSector)); 
....................  
....................    PrintROMASCIIStringUART(" LastClusterLimit="); 
....................    PrintRAMBytesUART(((unsigned char*)&LastClusterLimit), sizeof(LastClusterLimit)); 
....................  
....................    PrintROMASCIIStringUART(" offset2="); 
....................    PrintRAMBytesUART(((unsigned char*)&offset2), sizeof(offset2)); 
....................  
....................    PrintROMASCIIStringUART(" curEntry="); 
....................    PrintRAMBytesUART(((unsigned char*)curEntry), sizeof(WORD)); 
....................    #endif 
....................  
....................     // check if a new sector of the root must be loaded 
....................     if (ForceRead || ((*curEntry & MASK_MAX_FILE_ENTRY_LIMIT_BITS) == 0))     // only 16 entries per sector 
....................     { 
....................         // see if we have to load a new cluster 
....................         if(((offset2 == 0) && (*curEntry >= dirEntriesPerSector)) || ForceRead) 
....................         { 
....................             if(cluster == 0) 
....................             { 
....................                 ccls = 0; 
....................             } 
....................             else 
....................             { 
....................                 // If ForceRead, read the number of sectors from 0 
....................                 if(ForceRead) 
....................                     numofclus = ((WORD)(*curEntry) / (WORD)(((WORD)dirEntriesPerSector) * (WORD)dsk->SecPerClus)); 
....................                 // Otherwise just read the next sector 
....................                 else 
....................                     numofclus = 1; 
....................  
....................                 // move to the correct cluster 
....................                 while(numofclus) 
....................                 { 
....................                     ccls = ReadFAT(dsk, ccls); 
....................  
....................                     if(ccls >= LastClusterLimit) 
....................                         break; 
....................                     else 
....................                         numofclus--; 
....................                 } 
....................             } 
....................         } 
....................  
....................    //#ifdef __DEBUG_UART   
....................    #if 0 
....................    PrintROMASCIIStringUART(" numofclus="); 
....................    PrintRAMBytesUART(((unsigned char*)&numofclus), sizeof(numofclus)); 
....................  
....................    PrintROMASCIIStringUART(" ccls="); 
....................    PrintRAMBytesUART(((unsigned char*)&ccls), sizeof(ccls)); 
....................    #endif 
....................  
....................         // see if that we have a valid cluster number 
....................         if(ccls < LastClusterLimit) 
....................         { 
....................             fo->dirccls = ccls; // write it back 
....................  
....................             sector = Cluster2Sector(dsk,ccls); 
....................  
....................             //#ifdef __DEBUG_UART   
....................             #if 0 
....................             PrintROMASCIIStringUART(" sector="); 
....................             PrintRAMBytesUART(((unsigned char*)&sector), sizeof(sector)); 
....................             #endif 
....................  
....................  
....................             /* see if we are root and about to go pass our boundaries 
....................             FAT32 stores the root directory in the Data Region along with files and other directories, 
....................             allowing it to grow without such a restraint */ 
....................             if((ccls == FatRootDirClusterValue) && ((sector + offset2) >= dsk->data) && (FAT32 != dsk->type)) 
....................             { 
....................                 dir = ((DIRENTRY)NULL);   // reached the end of the root 
....................             } 
....................             else 
....................             { 
.................... #ifdef ALLOW_WRITES 
....................                 if (gNeedDataWrite) 
....................                     if (flushData()) 
....................                         return NULL; 
.................... #endif 
....................                 gBufferOwner = NULL; 
....................                 gBufferZeroed = FALSE; 
....................  
....................                 if ( MDD_SectorRead( sector + offset2, dsk->buffer) != TRUE) // if FALSE: sector could not be read. 
....................                 { 
....................                     dir = ((DIRENTRY)NULL); 
....................                 } 
....................                 else // Sector has been read properly, Copy the root entry info of the file searched. 
....................                 { 
....................                     if(ForceRead)    // Buffer holds all 16 root entry info. Point to the one required. 
....................                         dir = (DIRENTRY)((DIRENTRY)dsk->buffer) + ((*curEntry)%dirEntriesPerSector); 
....................                     else 
....................                         dir = (DIRENTRY)dsk->buffer; 
....................                 } 
....................                //#ifdef __DEBUG_UART   
....................                #if 0 
....................                PrintROMASCIIStringUART(" dirread="); 
....................                PrintRAMBytesUART(((unsigned char*)&dir), sizeof(dir)); 
....................                #endif                 
....................                 gLastDataSectorRead = 0xFFFFFFFF; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             nextClusterIsLast = TRUE; 
....................             dir = ((DIRENTRY)NULL); 
....................         } 
....................     } 
....................     else 
....................     { 
....................         dir = (DIRENTRY)((DIRENTRY)dsk->buffer) + ((*curEntry)%dirEntriesPerSector); 
....................                //#ifdef __DEBUG_UART   
....................                #if 0 
....................                PrintROMASCIIStringUART(" dirmath="); 
....................                PrintRAMBytesUART(((unsigned char*)&dir), sizeof(dir)); 
....................                #endif                 
....................     } 
....................  
....................     return(dir); 
.................... } // Cache_File_Entry 
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     CETYPE CreateFileEntry(FILEOBJ fo, WORD *fHandle, BYTE mode, BOOL createFirstCluster) 
....................   Summary: 
....................     Create a new file entry 
....................   Conditions: 
....................     Should not be called by the user. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................     fHandle -  Location to create file 
....................     mode - DIRECTORY mode or ARCHIVE mode 
....................     createFirstCluster - If set to TRUE, first cluster is created 
....................   Return Values: 
....................     CE_GOOD -        File Creation successful 
....................     CE_DIR_FULL -    All root directory entries are taken 
....................     CE_WRITE_ERROR - The head cluster of the file could not be created. 
....................   Side Effects: 
....................     Modifies the FSerrno variable. 
....................   Description: 
....................     With the data passed within fo, create a new file entry in the current 
....................     directory.  This function will first search for empty file entries. 
....................     Once an empty entry is found, the entry will be populated with data 
....................     for a file or directory entry.  Finally, the first cluster of the 
....................     new file will be located and allocated, and its value will be 
....................     written into the file entry. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... CETYPE CreateFileEntry(FILEOBJ fo, WORD *fHandle, BYTE mode, BOOL createFirstCluster) 
.................... { 
....................     CETYPE  error = CE_GOOD; 
....................  
....................    #if defined(SUPPORT_LFN) 
....................    LFN_ENTRY *lfno; 
....................    unsigned short int   *templfnPtr = (unsigned short int *)fo -> utf16LFNptr,*dest; 
....................    unsigned short int   tempString[MAX_UTF16_CHARS_IN_LFN_ENTRY]; 
....................    UINT16_VAL tempShift; 
....................     BOOL    firstTime = TRUE; 
....................    BYTE   checksum,sequenceNumber,reminder,tempCalc1,numberOfFileEntries; 
....................     char    index; 
....................    char    *src; 
....................    #endif 
....................  
....................    FSerrno = CE_GOOD; 
....................  
....................    *fHandle = 0; 
....................  
....................     // figure out where to put this file in the directory stucture 
....................     if(FindEmptyEntries(fo, fHandle) == FOUND) 
....................     { 
....................       #if defined(SUPPORT_LFN) 
....................       // If LFN entry 
....................       if(fo->utf16LFNlength) 
....................       { 
....................          // Alias the LFN to short file name 
....................          if(!Alias_LFN_Object(fo)) 
....................          { 
....................             // If Aliasing of LFN is unsucessful 
....................             error = FSerrno = CE_FILENAME_EXISTS; 
....................             return(error); 
....................          } 
....................  
....................          src = fo -> name; 
....................  
....................            // Find the checksum for Short file name of LFN 
....................            checksum = 0; 
....................            for (index = 11; index != 0; index--) 
....................            { 
....................             checksum = ((checksum & 1) ? 0x80 : 0) + (checksum >> 1) + *src++; 
....................          } 
....................  
....................          // File Name + NULL character is file name length in LFN 
....................          fileNameLength = fo->utf16LFNlength; 
....................  
....................          // Determine the number of entries for LFN 
....................          reminder = tempCalc1 = fileNameLength % MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................          numberOfFileEntries = fileNameLength/MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................          if(tempCalc1 || (fileNameLength < MAX_UTF16_CHARS_IN_LFN_ENTRY)) 
....................          { 
....................             numberOfFileEntries++; 
....................          } 
....................  
....................          // Max sequence number for LFN root entry 
....................          sequenceNumber = numberOfFileEntries | 0x40; 
....................  
....................          // Store the max sequence number entries in tempString 
....................          if(tempCalc1) 
....................          { 
....................             index = 0; 
....................             while(tempCalc1) 
....................             { 
....................                tempString[(BYTE)index++] = templfnPtr[fileNameLength - tempCalc1]; 
....................                tempCalc1--; 
....................             } 
....................  
....................             tempString[(BYTE)index++] = 0x0000; 
....................  
....................             // Store the remaining bytes of max sequence number entries with 0xFF 
....................             for(;index < MAX_UTF16_CHARS_IN_LFN_ENTRY;index++) 
....................             { 
....................                tempString[(BYTE)index] = 0xFFFF; 
....................             } 
....................          } 
....................          else 
....................          { 
....................             // Store the remaining bytes of max sequence number entries with 0xFF 
....................             for(index = MAX_UTF16_CHARS_IN_LFN_ENTRY;index > 0;index--) 
....................             { 
....................                tempString[MAX_UTF16_CHARS_IN_LFN_ENTRY - (BYTE)index] = templfnPtr[fileNameLength - (BYTE)index]; 
....................             } 
....................          } 
....................  
....................          dest = &tempString[12]; 
....................  
....................          while(numberOfFileEntries) 
....................          { 
....................             fo->dirccls = fo->dirclus; 
....................              lfno = (LFN_ENTRY *)Cache_File_Entry( fo, fHandle, TRUE); 
....................  
....................              if (lfno == NULL) 
....................             { 
....................                  return CE_BADCACHEREAD; 
....................             } 
....................  
....................             // Write the 32 byte LFN Object as per FAT specification 
....................             lfno->LFN_SequenceNo = sequenceNumber--;   // Sequence number, 
....................  
....................             lfno->LFN_Part3[1] = *dest--; 
....................             lfno->LFN_Part3[0] = *dest--; 
....................  
....................             lfno->LFN_Part2[5] = *dest--; 
....................             lfno->LFN_Part2[4] = *dest--; 
....................             lfno->LFN_Part2[3] = *dest--; 
....................             lfno->LFN_Part2[2] = *dest--; 
....................             lfno->LFN_Part2[1] = *dest--; 
....................             lfno->LFN_Part2[0] = *dest--; 
....................  
....................             tempShift.Val = *dest--; 
....................             lfno->LFN_Part1[9] = tempShift.byte.HB; 
....................             lfno->LFN_Part1[8] = tempShift.byte.LB; 
....................             tempShift.Val = *dest--; 
....................             lfno->LFN_Part1[7] = tempShift.byte.HB; 
....................             lfno->LFN_Part1[6] = tempShift.byte.LB; 
....................             tempShift.Val = *dest--; 
....................             lfno->LFN_Part1[5] = tempShift.byte.HB; 
....................             lfno->LFN_Part1[4] = tempShift.byte.LB; 
....................             tempShift.Val = *dest--; 
....................             lfno->LFN_Part1[3] = tempShift.byte.HB; 
....................             lfno->LFN_Part1[2] = tempShift.byte.LB; 
....................             tempShift.Val = *dest--; 
....................             lfno->LFN_Part1[1] = tempShift.byte.HB; 
....................             lfno->LFN_Part1[0] = tempShift.byte.LB; 
....................  
....................             lfno->LFN_Attribute = ATTR_LONG_NAME; 
....................             lfno->LFN_Type = 0; 
....................             lfno->LFN_Checksum = checksum; 
....................             lfno->LFN_Reserved2 = 0; 
....................  
....................              // just write the last entry in 
....................              if (Write_File_Entry(fo,fHandle) != TRUE) 
....................                  error = CE_WRITE_ERROR; 
....................  
....................                // 0x40 should be ORed with only max sequence number & in 
....................             // all other cases it should not be present 
....................                sequenceNumber &= (~0x40); 
....................                *fHandle = *fHandle + 1; 
....................             numberOfFileEntries--; 
....................  
....................             // Load the destination address only once and during first time, 
....................             if(firstTime) 
....................             { 
....................                if(reminder) 
....................                   dest = (unsigned short int *)(fo -> utf16LFNptr + fileNameLength - reminder - 1); 
....................                else 
....................                   dest = (unsigned short int *)(fo -> utf16LFNptr + fileNameLength - MAX_UTF16_CHARS_IN_LFN_ENTRY - 1); 
....................                firstTime = FALSE; 
....................             } 
....................          } 
....................       } 
....................       #endif 
....................  
....................         // found the entry, now populate it 
....................         if((error = PopulateEntries(fo, fHandle, mode)) == CE_GOOD) 
....................         { 
....................          if(createFirstCluster) 
....................                // if everything is ok, create a first cluster 
....................                error = CreateFirstCluster(fo); 
....................          else 
....................          { 
....................  
....................          } 
....................         } 
....................     } 
....................     else 
....................     { 
....................         error = CE_DIR_FULL; 
....................     } 
....................  
....................     FSerrno = error; 
....................  
....................     return(error); 
.................... } 
.................... #endif 
....................  
.................... /****************************************************** 
....................   Function: 
....................     CETYPE CreateFirstCluster(FILEOBJ fo) 
....................   Summary: 
....................     Create the first cluster for a file 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -  The file that contains the first cluster 
....................   Return Values: 
....................     CE_GOOD -        First cluster created successfully 
....................     CE_WRITE_ERROR - Cluster creation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will find an unused cluster, link it to 
....................     a file's directory entry, and write the entry back 
....................     to the device. 
....................   Remarks: 
....................     None. 
....................   ******************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... CETYPE CreateFirstCluster(FILEOBJ fo) 
.................... { 
....................     CETYPE       error; 
....................     DWORD      cluster,TempMsbCluster; 
....................     WORD        fHandle; 
....................     DIRENTRY   dir; 
....................     fHandle = fo->entry; 
....................  
....................     // Now create the first cluster (head cluster) 
....................     if((error = FILECreateHeadCluster(fo,&cluster)) == CE_GOOD) 
....................     { 
....................         // load the file entry so the new cluster can be linked to it 
....................         dir = LoadDirAttrib(fo, &fHandle); 
....................  
....................         // Now update the new cluster 
....................         dir->DIR_FstClusLO = (cluster & 0x0000FFFF); 
....................  
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         // Get the higher part of cluster and store it in directory entry. 
....................        TempMsbCluster = (cluster & 0x0FFF0000);    // Since only 28 bits usedin FAT32. Mask the higher MSB nibble. 
....................        TempMsbCluster = TempMsbCluster >> 16;      // Get the date into Lsb place. 
....................        dir->DIR_FstClusHI = TempMsbCluster; 
.................... #else // If FAT32 support not enabled 
....................        TempMsbCluster = 0;                         // Just to avoid compiler warnigng. 
....................        dir->DIR_FstClusHI = 0; 
.................... #endif 
....................  
....................         // now write it 
....................         if(Write_File_Entry(fo, &fHandle) != TRUE) 
....................             error = CE_WRITE_ERROR; 
....................     } // Create Cluster 
....................  
....................     return(error); 
.................... }// End of CreateFirstCluster 
.................... #endif 
....................  
.................... /********************************************************** 
....................   Function: 
....................     BYTE FindEmptyEntries(FILEOBJ fo, WORD *fHandle) 
....................   Summary: 
....................     Find an empty dir entry 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................     fHandle -  Start of entries 
....................   Return Values: 
....................     TRUE - One found 
....................     FALSE - None found 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache directory entries, starting 
....................     with the one pointed to by the fHandle argument.  It will 
....................     then search through the entries until an unused one 
....................     is found.  If the end of the cluster chain for the 
....................     directory is reached, a new cluster will be allocated 
....................     to the directory (unless it's a FAT12 or FAT16 root) 
....................     and the first entry of the new cluster will be used. 
....................   Remarks: 
....................     None. 
....................   **********************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE FindEmptyEntries(FILEOBJ fo, WORD *fHandle) 
.................... { 
....................     BYTE   status = NOT_FOUND; 
....................     BYTE   amountfound,numberOfFileEntries; 
....................     BYTE   a = 0; 
....................     WORD   bHandle = *fHandle; 
....................     DWORD b; 
....................     DIRENTRY    dir; 
....................  
....................     fo->dirccls = fo->dirclus; 
....................     if((dir = Cache_File_Entry( fo, fHandle, TRUE)) != NULL) 
....................     { 
....................       #if defined(SUPPORT_LFN) 
....................       // If LFN entry 
....................       if(fo->utf16LFNlength) 
....................       { 
....................          // File Name + NULL character is file name length in LFN 
....................          fileNameLength = fo->utf16LFNlength; 
....................  
....................          // Determine the number of entries for LFN 
....................          a = fileNameLength % MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................          numberOfFileEntries = fileNameLength/MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................          if(a || (fileNameLength < MAX_UTF16_CHARS_IN_LFN_ENTRY)) 
....................          { 
....................             numberOfFileEntries++; 
....................          } 
....................  
....................             // Increment by 1 so that you have space to store for assosciated short file name 
....................             numberOfFileEntries = numberOfFileEntries + 1; 
....................       } 
....................       else 
....................       #endif 
....................             numberOfFileEntries = 1; 
....................  
....................         // while its still not found 
....................         while(status == NOT_FOUND) 
....................         { 
....................             amountfound = 0; 
....................             bHandle = *fHandle; 
....................  
....................             // find (number) continuous entries 
....................             do 
....................             { 
....................                 // Get the entry 
....................                 dir = Cache_File_Entry( fo, fHandle, FALSE); 
....................  
....................                 // Read the first char of the file name 
....................                 if(dir != NULL) // Last entry of the cluster 
....................                 { 
....................                     a = dir->DIR_Name[0]; 
....................                 } 
....................                 // increase number 
....................                 (*fHandle)++; 
....................             }while((dir != (DIRENTRY)NULL) && ((a == DIR_DEL) || (a == DIR_EMPTY)) && (++amountfound < numberOfFileEntries)); 
....................  
....................             // --- now why did we exit? 
....................             if(dir == NULL) // Last entry of the cluster 
....................             { 
....................                 //setup the current cluster 
....................                 b = fo->dirccls; // write it back 
....................  
....................                 // make sure we are not the root directory 
....................                 if(b == FatRootDirClusterValue) 
....................                 { 
....................                     if (fo->dsk->type != FAT32) 
....................                         status = NO_MORE; 
....................                     else 
....................                     { 
....................                         fo->ccls = b; 
....................  
....................                         if(FILEallocate_new_cluster(fo, 1) == CE_DISK_FULL) 
....................                             status = NO_MORE; 
....................                         else 
....................                             status = FOUND;     // a new cluster will surely hold a new file name 
....................                     } 
....................                 } 
....................                 else 
....................                 { 
....................                     fo->ccls = b; 
....................  
....................                     if(FILEallocate_new_cluster(fo, 1) == CE_DISK_FULL) 
....................                         status = NO_MORE; 
....................                     else 
....................                     { 
....................                         status = FOUND;     // a new cluster will surely hold a new file name 
....................                     } 
....................                 } 
....................             } 
....................             else 
....................             { 
....................                 if(amountfound == numberOfFileEntries) 
....................                     status = FOUND; 
....................             } 
....................         }// while 
....................     } 
....................  
....................     // copy the base handle over 
....................    *fHandle = bHandle; 
....................  
....................    return(status); 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     BYTE PopulateEntries(FILEOBJ fo, WORD *fHandle, BYTE mode) 
....................   Summary: 
....................     Populate a dir entry with data 
....................   Conditions: 
....................     Should not be called by the user. 
....................   Input: 
....................     fo -      Pointer to file structure 
....................     fHandle - Location of the file 
....................     mode - DIRECTORY mode or ARCHIVE mode 
....................   Return Values: 
....................     CE_GOOD - Population successful 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will write data into a new file entry.  It will also 
....................     load timestamp data (based on the method selected by the user) and 
....................     update the timestamp variables. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE PopulateEntries(FILEOBJ fo, WORD *fHandle, BYTE mode) 
.................... { 
....................     BYTE error = CE_GOOD; 
....................     DIRENTRY    dir; 
....................  
....................     fo->dirccls = fo->dirclus; 
....................     dir = Cache_File_Entry( fo, fHandle, TRUE); 
....................  
....................     if (dir == NULL) 
....................         return CE_BADCACHEREAD; 
....................  
....................     // copy the contents over 
....................     strncpy(dir->DIR_Name,fo->name,DIR_NAMECOMP); 
....................  
....................     // setup no attributes 
....................     if (mode == DIRECTORY) 
....................         dir->DIR_Attr = ATTR_DIRECTORY; 
....................     else 
....................         dir->DIR_Attr   = ATTR_ARCHIVE; 
....................  
....................     dir->DIR_NTRes  = 0x00;              // nt reserved 
....................     dir->DIR_FstClusHI =    0x0000;      // high word of this enty's first cluster number 
....................     dir->DIR_FstClusLO =    0x0000;      // low word of this entry's first cluster number 
....................     dir->DIR_FileSize =     0x0;         // file size in DWORD 
....................  
....................    // Timing information for uncontrolled clock mode 
.................... #ifdef INCREMENTTIMESTAMP 
....................     dir->DIR_CrtTimeTenth = 0xB2;        // millisecond stamp 
....................     dir->DIR_CrtTime =      0x7278;      // time created 
....................     dir->DIR_CrtDate =      0x32B0;      // date created 
....................     dir->DIR_LstAccDate =   0x32B0;      // Last Access date 
....................     dir->DIR_WrtTime =      0x7279;      // last update time 
....................     dir->DIR_WrtDate =      0x32B0;      // last update date 
.................... #endif 
....................  
.................... #ifdef USEREALTIMECLOCK 
....................     CacheTime(); 
....................     dir->DIR_CrtTimeTenth = gTimeCrtMS;        // millisecond stamp 
....................     dir->DIR_CrtTime =      gTimeCrtTime;      // time created // 
....................     dir->DIR_CrtDate =      gTimeCrtDate;      // date created (1/1/2004) 
....................     dir->DIR_LstAccDate =   gTimeAccDate;      // Last Access date 
....................     dir->DIR_WrtTime =      gTimeWrtTime;      // last update time 
....................     dir->DIR_WrtDate =      gTimeWrtDate;      // last update date 
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................     // The user will have set the time before this funciton is called 
....................     dir->DIR_CrtTimeTenth = gTimeCrtMS; 
....................     dir->DIR_CrtTime =      gTimeCrtTime; 
....................     dir->DIR_CrtDate =       gTimeCrtDate; 
....................     dir->DIR_LstAccDate =   gTimeAccDate; 
....................     dir->DIR_WrtTime =       gTimeWrtTime; 
....................     dir->DIR_WrtDate =      gTimeWrtDate; 
.................... #endif 
....................  
....................     fo->size        = dir->DIR_FileSize; 
....................     fo->time        = dir->DIR_CrtTime; 
....................     fo->date        = dir->DIR_CrtDate; 
....................     fo->attributes  = dir->DIR_Attr; 
....................     fo->entry       = *fHandle; 
....................  
....................     // just write the last entry in 
....................     if (Write_File_Entry(fo,fHandle) != TRUE) 
....................         error = CE_WRITE_ERROR; 
....................  
....................     return(error); 
.................... } 
....................  
.................... /***************************************************************** 
....................   Function: 
....................     BOOL Alias_LFN_Object(FILEOBJ fo) 
....................   Summary: 
....................     Find the Short file name of the LFN entry 
....................   Conditions: 
....................     Long file name should be present. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................   Return Values: 
....................     FOUND -     Operation successful 
....................     NOT_FOUND - Operation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will find the short file name 
....................     of the long file name as mentioned in the FAT 
....................     specs. 
....................   Remarks: 
....................     None. 
....................   *****************************************************************/ 
.................... #if defined(SUPPORT_LFN) 
.................... BOOL Alias_LFN_Object(FILEOBJ fo) 
.................... { 
....................    FSFILE      filePtr1; 
....................    FSFILE      filePtr2; 
....................    unsigned long int index4; 
....................    short int   lfnIndex,index1,index2; 
....................     BYTE  tempVariable,index; 
....................    char  tempString[8]; 
....................    char  *lfnAliasPtr; 
....................    unsigned short int  *templfnPtr; 
....................    BOOL result = FALSE; 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&filePtr1, fo); 
....................  
....................    lfnAliasPtr = (char *)&filePtr1.name[0]; 
....................  
....................    templfnPtr = (unsigned short int *)filePtr1.utf16LFNptr; 
....................  
....................    fileNameLength = fo->utf16LFNlength; 
....................  
....................    // Initially fill the alias name with space characters 
....................    for(index1 = 0;index1 < FILE_NAME_SIZE_8P3;index1++) 
....................    { 
....................       lfnAliasPtr[index1] = ' '; 
....................    } 
....................  
....................    // find the location where '.' is present 
....................    for(lfnIndex = fileNameLength - 1;lfnIndex > 0;lfnIndex--) 
....................    { 
....................       if (templfnPtr[lfnIndex] == '.') 
....................       { 
....................           break; 
....................       } 
....................    } 
....................  
....................    index1 = lfnIndex + 1; 
....................  
....................    tempVariable = 0; 
....................    if(lfnIndex) 
....................    { 
....................       index2 = 8; 
....................       // Complete the extension part as per the FAT specifications 
....................       for(;((index1 < fileNameLength) && (tempVariable < 3));index1++) 
....................       { 
....................          // Convert lower-case to upper-case 
....................          index = (BYTE)templfnPtr[index1]; 
....................          if ((index >= 0x61) && (index <= 0x7A)) 
....................          { 
....................              lfnAliasPtr[index2++] = index - 0x20; 
....................          } 
....................          else if(index == ' ') 
....................          { 
....................             continue; 
....................          } 
....................          else if ((index == 0x2B) || (index == 0x2C) || (index == 0x3B) || 
....................                (index == 0x3D) || (index == 0x5B) || (index == 0x5D) || 
....................                (templfnPtr[index1] > 0xFF)) 
....................          { 
....................              lfnAliasPtr[index2++] = '_'; 
....................          } 
....................          else 
....................          { 
....................              lfnAliasPtr[index2++] = index; 
....................          } 
....................  
....................          tempVariable++; 
....................       } 
....................  
....................       index2 = lfnIndex; 
....................       tempVariable = 0; 
....................    } 
....................    else 
....................    { 
....................       index2 = fileNameLength; 
....................    } 
....................  
....................    // Fill the base part as per the FAT specifications 
....................    for(index1 = 0;((index1 < index2) && (tempVariable < 6));index1++) 
....................    { 
....................       // Convert lower-case to upper-case 
....................       index = (BYTE)templfnPtr[index1]; 
....................       if ((index >= 0x61) && (index <= 0x7A)) 
....................       { 
....................           lfnAliasPtr[tempVariable] = index - 0x20; 
....................       } 
....................       else if(index == ' ') 
....................       { 
....................          continue; 
....................       } 
....................       else if ((index == 0x2B) || (index == 0x2C) || (index == 0x3B) || 
....................             (index == 0x3D) || (index == 0x5B) || (index == 0x5D) || 
....................             (templfnPtr[index1] > 0xFF)) 
....................       { 
....................           lfnAliasPtr[tempVariable] = '_'; 
....................       } 
....................       else 
....................       { 
....................           lfnAliasPtr[tempVariable] = index; 
....................       } 
....................       tempVariable++; 
....................    } 
....................  
....................    // Aliasing of the predicted name should append ~1 
....................    lfnAliasPtr[tempVariable] = '~'; 
....................    lfnAliasPtr[tempVariable + 1] = '1'; 
....................  
....................     filePtr1.attributes = ATTR_ARCHIVE; 
....................  
....................    filePtr1.utf16LFNlength = 0; 
....................  
....................    // Try for 9999999 combinations before telling error to the user 
....................    for(index4 = 1;index4 < (unsigned long int)10000000;index4++) 
....................    { 
....................        filePtr1.cluster = 0; 
....................        filePtr1.ccls    = 0; 
....................        filePtr1.entry = 0; 
....................  
....................           // start at the current directory 
....................       #ifdef ALLOW_DIRS 
....................           filePtr1.dirclus    = cwdptr->dirclus; 
....................           filePtr1.dirccls    = cwdptr->dirccls; 
....................       #else 
....................           filePtr1.dirclus = FatRootDirClusterValue; 
....................           filePtr1.dirccls = FatRootDirClusterValue; 
....................       #endif 
....................  
....................        // copy file object over 
....................        FileObjectCopy(&filePtr2, &filePtr1); 
....................  
....................        // See if the file is found 
....................        if(FILEfind (&filePtr2, &filePtr1, LOOK_FOR_MATCHING_ENTRY, 0) == CE_GOOD) 
....................       { 
....................          tempString[7] = index4 % (BYTE)10 + '0'; 
....................          tempString[6] = (index4 % (BYTE)100)/10 + '0'; 
....................          tempString[5] = (index4 % 1000)/100 + '0'; 
....................          tempString[4] = (index4 % 10000)/1000 + '0'; 
....................          tempString[3] = (index4 % 100000)/10000 + '0'; 
....................          tempString[2] = (index4 % 1000000)/100000 + '0'; 
....................          if((tempString[1] = ((index4 % 10000000)/1000000 + '0')) != '0') 
....................          { 
....................                tempString[index = 0] = '~'; 
....................          } 
....................          else 
....................          { 
....................             for(index = 6;index > 0;index--) 
....................             { 
....................                if((tempString[index] == '0') && (tempString[index - 1] == '0')) 
....................                { 
....................                   tempString[index] = '~'; 
....................                   if(!filePtr1.AsciiEncodingType) 
....................                   { 
....................                      if(index % 2) 
....................                      { 
....................                         for(index2 = index - 1;index2 < 7;index2++) 
....................                         { 
....................                            tempString[index2] = tempString[index2 + 1]; 
....................                         } 
....................                         tempString[7] = ' '; 
....................                         index--; 
....................                      } 
....................                   } 
....................                   break; 
....................                } 
....................             } 
....................          } 
....................  
....................          if(index >= tempVariable) 
....................          { 
....................             index1 = tempVariable; 
....................          } 
....................          else 
....................          { 
....................             index1 = index; 
....................          } 
....................  
....................          while(index < 8) 
....................          { 
....................             filePtr1.name[index1++] = tempString[index++]; 
....................          } 
....................  
....................          // Store the remaining bytes with leading spaces 
....................          while(index1 < 8) 
....................          { 
....................             filePtr1.name[index1++] = ' '; 
....................          } 
....................  
....................       } 
....................       else 
....................       { 
....................          // short file name is found.Store it & quit 
....................          lfnAliasPtr = &fo->name[0]; 
....................  
....................          for(index = 0;index < FILE_NAME_SIZE_8P3;index++) 
....................          { 
....................             lfnAliasPtr[index] = filePtr1.name[index]; 
....................          } 
....................  
....................          result = TRUE; 
....................          break; 
....................       } 
....................    } 
....................  
....................    return(result); 
....................  
.................... } // Alias_LFN_Object 
.................... #endif 
....................  
.................... #ifdef USEREALTIMECLOCK 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     void CacheTime (void) 
....................   Summary: 
....................     Automatically store timestamp information from the RTCC 
....................   Conditions: 
....................     RTCC module enabled.  Should not be called by the user. 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     Modifies global timing variables 
....................   Description: 
....................     This function will automatically load information from an RTCC 
....................     module and use it to update the global timing variables.  These can 
....................     then be used to update file timestamps. 
....................   Remarks: 
....................     None. 
....................   *************************************************************************/ 
....................  
.................... void CacheTime (void) 
.................... { 
....................     WORD    year, monthday, weekhour, minsec, c, result; 
....................  
.................... #if defined (__PIC32MX__)   // Added support for PIC32. -Bud (3/4/2008) 
....................  
....................    unsigned int   t0, t1; 
....................    unsigned int   d0, d1; 
....................  
....................    do  // Get the time 
....................    { 
....................       t0=RTCTIME; 
....................       t1=RTCTIME; 
....................    }while(t0!=t1); 
....................  
....................    do  // Get the date 
....................    { 
....................       d0=RTCDATE; 
....................       d1=RTCDATE; 
....................    }while(d0!=d1); 
....................  
....................     // Put them in place. 
....................     year        = (WORD)(d0 >> 24); 
....................     monthday    = (WORD)(d0 >> 8); 
....................     weekhour    = (WORD)((d0 & 0x0F) << 8); 
....................     weekhour   |= (WORD)(t0 >> 24); 
....................     minsec      = (WORD)(t0 >> 8); 
....................  
.................... #else 
....................     BYTE    ptr1, ptr0; 
....................     if(RCFGCALbits.RTCPTR0) 
....................         ptr0 = 1; 
....................     else 
....................         ptr0 = 0; 
....................     if (RCFGCALbits.RTCPTR1) 
....................         ptr1 = 1; 
....................     else 
....................         ptr1 = 0; 
....................  
....................     RCFGCALbits.RTCPTR0 = 1; 
....................     RCFGCALbits.RTCPTR1 = 1; 
....................     year = RTCVAL; 
....................     monthday = RTCVAL; 
....................     weekhour = RTCVAL; 
....................     minsec = RTCVAL; 
....................  
....................     if (ptr0 == 1) 
....................         RCFGCALbits.RTCPTR0 = 1; 
....................  
....................     if (ptr1 == 1) 
....................         RCFGCALbits.RTCPTR1 = 1; 
....................  
.................... #endif 
....................  
....................     c = 0; 
....................     c += (year & 0x0F); 
....................     c += ((year & 0xF0) >> 4) * 10; 
....................     // c equals the last 2 digits of the year from 2000 to 2099 
....................     // Add 20 to adjust it to FAT time (from 1980 to 2107) 
....................     c += 20; 
....................     // shift the result to bits 
....................     result = c << 9; 
....................  
....................     if ((monthday & 0x1000) == 0x1000) 
....................     { 
....................         c = 10; 
....................     } 
....................     else 
....................     { 
....................         c = 0; 
....................     } 
....................     c += ((monthday & 0x0F00) >> 8); 
....................     c <<= 5; 
....................     result |= c; 
....................  
....................     c = (monthday & 0x00F0) >> 4; 
....................     c *= 10; 
....................     c += (monthday & 0x000F); 
....................  
....................     result |= c; 
....................  
....................     gTimeCrtDate = result; 
....................     gTimeWrtDate = result; 
....................     gTimeAccDate = result; 
....................  
....................     c = ((weekhour & 0x00F0) >> 4) * 10; 
....................     c += (weekhour & 0x000F); 
....................     result = c << 11; 
....................     c = ((minsec & 0xF000) >> 12) * 10; 
....................     c += (minsec & 0x0F00) >> 8; 
....................     result |= (c << 5); 
....................     c = ((minsec & 0x00F0) >> 4) * 10; 
....................     c += (minsec & 0x000F); 
....................  
....................     // If seconds mod 2 is 1, add 1000 ms 
....................     if (c % 2) 
....................         gTimeCrtMS = 100; 
....................     else 
....................         gTimeCrtMS = 0; 
....................  
....................     c >>= 1; 
....................     result |= c; 
....................  
....................     gTimeCrtTime = result; 
....................     gTimeWrtTime = result; 
.................... } 
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................  
.................... /*********************************************************************************************************** 
....................   Function: 
....................     int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second) 
....................   Summary: 
....................     Manually set timestamp variables 
....................   Conditions: 
....................     USERDEFINEDCLOCK macro defined in FSconfig.h. 
....................   Input: 
....................     year -     The year (1980\-2107) 
....................     month -   The month (1\-12) 
....................     day -     The day of the month (1\-31) 
....................     hour -    The hour (0\-23) 
....................     minute -  The minute (0\-59) 
....................     second -  The second (0\-59) 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     Modifies global timing variables 
....................   Description: 
....................     Lets the user manually set the timing variables.  The values passed in will be converted to the format 
....................     used by the FAT timestamps. 
....................   Remarks: 
....................     Call this before creating a file or directory (set create time) and 
....................     before closing a file (set last access time, last modified time) 
....................   ***********************************************************************************************************/ 
....................  
.................... int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second) 
.................... { 
....................     unsigned int result; 
....................  
....................     if ((year < 1980) || (year > 2107) || (month < 1) || (month > 12) || 
....................         (day < 1) || (day > 31) || (hour > 23) || (minute > 59) || (second > 59)) 
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
....................         return -1; 
....................     } 
....................  
....................     result = (year - 1980) << 9; 
....................     result |= (unsigned int)((unsigned int)month << 5); 
....................     result |= (day); 
....................  
....................     gTimeAccDate = result; 
....................     gTimeCrtDate = result; 
....................     gTimeWrtDate = result; 
....................  
....................     result = ((unsigned int)hour << 11); 
....................     result |= (unsigned int)((unsigned int)minute << 5); 
....................     result |= (second/2); 
....................  
....................     gTimeCrtTime = result; 
....................     gTimeWrtTime = result; 
....................  
....................     if (second % 2) 
....................         gTimeCrtMS = 100; 
....................     else 
....................         gTimeCrtMS = 0; 
....................  
....................     FSerrno = CE_GOOD; 
....................     return 0; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /*********************************************************************** 
....................   Function: 
....................     BYTE FILEallocate_new_cluster( FILEOBJ fo, BYTE mode) 
....................   Summary; 
....................     Allocate a new cluster to a file 
....................   Conditions: 
....................     Should not be called by the user. 
....................   Input: 
....................     fo -    Pointer to file structure 
....................     mode - 
....................          - 0 - Allocate a cluster to a file 
....................          - 1 - Allocate a cluster to a directory 
....................   Return Values: 
....................     CE_GOOD -      Cluster allocated 
....................     CE_DISK_FULL - No clusters available 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will find an empty cluster on the device using the 
....................     FATfindEmptyCluster function.  It will then mark it as the last 
....................     cluster in the file in the FAT chain, and link the current last 
....................     cluster of the passed file to the new cluster.  If the new 
....................     cluster is a directory cluster, it will be erased (so there are no 
....................     extraneous directory entries).  If it's allocated to a non-directory 
....................     file, it doesn't need to be erased; extraneous data in the cluster 
....................     will be unviewable because of the file size parameter. 
....................   Remarks: 
....................     None. 
....................   ***********************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE FILEallocate_new_cluster( FILEOBJ fo, BYTE mode) 
.................... { 
....................     DISK *      dsk; 
....................     DWORD c,curcls; 
....................  
....................     dsk = fo->dsk; 
....................     c = fo->ccls; 
....................  
....................     // find the next empty cluster 
....................     c = FATfindEmptyCluster(fo); 
....................     if (c == 0)      // "0" is just an indication as Disk full in the fn "FATfindEmptyCluster()" 
....................         return CE_DISK_FULL; 
....................  
....................  
....................     // mark the cluster as taken, and last in chain 
.................... #ifdef SUPPORT_FAT12 
....................     if(dsk->type == FAT12) 
....................         WriteFAT( dsk, c, LAST_CLUSTER_FAT12, FALSE); 
....................     else 
.................... #endif 
....................     if (dsk->type == FAT16) 
....................         WriteFAT( dsk, c, LAST_CLUSTER_FAT16, FALSE); 
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................     else 
....................         WriteFAT( dsk, c, LAST_CLUSTER_FAT32, FALSE); 
.................... #endif 
....................  
....................     // link current cluster to the new one 
....................     curcls = fo->ccls; 
....................  
....................     WriteFAT( dsk, curcls, c, FALSE); 
....................  
....................     // update the FILE structure 
....................     fo->ccls = c; 
....................  
....................     // IF this is a dir, we need to erase the cluster 
....................     // If it's a file, we can leave it- the file size 
....................     // will limit the data we see to the data that's been 
....................     // written 
....................     if (mode == 1) 
....................         return (EraseCluster(dsk, c)); 
....................     else 
....................         return CE_GOOD; 
....................  
.................... } // allocate new cluster 
.................... #endif 
....................  
.................... /*********************************************** 
....................   Function: 
....................     DWORD FATfindEmptyCluster(FILEOBJ fo) 
....................   Summary: 
....................     Find the next available cluster on the device 
....................   Conditions: 
....................     This function should not be called by the 
....................     user. 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return Values: 
....................     DWORD - Address of empty cluster 
....................     0 -     Could not find empty cluster 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will search through the FAT to 
....................     find the next available cluster on the device. 
....................   Remarks: 
....................     Should not be called by user 
....................   ***********************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... DWORD FATfindEmptyCluster(FILEOBJ fo) 
.................... { 
....................     DISK *   disk; 
....................     DWORD    value = 0x0; 
....................     DWORD    c,curcls, EndClusterLimit, ClusterFailValue; 
....................  
....................     disk = fo->dsk; 
....................     c = fo->ccls; 
....................  
....................     /* Settings based on FAT type */ 
....................     switch (disk->type) 
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             EndClusterLimit = END_CLUSTER_FAT32; 
....................             ClusterFailValue = CLUSTER_FAIL_FAT32; 
....................             break; 
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
....................             EndClusterLimit = END_CLUSTER_FAT12; 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
....................             break; 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             EndClusterLimit = END_CLUSTER_FAT16; 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
....................             break; 
....................     } 
....................  
....................     // just in case 
....................     if(c < 2) 
....................         c = 2; 
....................  
....................     curcls = c; 
....................     ReadFAT(disk, c); 
....................  
....................     // sequentially scan through the FAT looking for an empty cluster 
....................     while(c) 
....................     { 
....................         // look at its value 
....................         if ( (value = ReadFAT(disk, c)) == ClusterFailValue) 
....................         { 
....................             c = 0; 
....................             break; 
....................         } 
....................  
....................         // check if empty cluster found 
....................         if (value == CLUSTER_EMPTY) 
....................             break; 
....................  
....................         c++;    // check next cluster in FAT 
....................         // check if reached last cluster in FAT, re-start from top 
....................         if ((value == EndClusterLimit) || (c >= (disk->maxcls+2))) 
....................             c = 2; 
....................  
....................         // check if full circle done, disk full 
....................         if ( c == curcls) 
....................         { 
....................             c = 0; 
....................             break; 
....................         } 
....................     }  // scanning for an empty cluster 
....................  
....................     return(c); 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     void FSGetDiskProperties(FS_DISK_PROPERTIES* properties) 
....................   Summary: 
....................     Allows user to get the disk properties (size of disk, free space, etc) 
....................   Conditions: 
....................     1) ALLOW_GET_DISK_PROPERTIES must be defined in FSconfig.h 
....................     2) a FS_DISK_PROPERTIES object must be created before the function is called 
....................     3) the new_request member of the FS_DISK_PROPERTIES object must be set before 
....................         calling the function for the first time.  This will start a new search. 
....................     4) this function should not be called while there is a file open.  Close all 
....................         files before calling this function. 
....................   Input: 
....................     properties - a pointer to a FS_DISK_PROPERTIES object where the results should 
....................       be stored. 
....................   Return Values: 
....................     This function returns void.  The properties_status of the previous call of this 
....................       function is located in the properties.status field.  This field has the 
....................       following possible values: 
....................  
....................     FS_GET_PROPERTIES_NO_ERRORS - operation completed without error.  Results 
....................       are in the properties object passed into the function. 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED - there is no mounted disk.  Results in 
....................       properties object is not valid 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE - there was a failure trying to read a 
....................       cluster from the drive.  The results in the properties object is a partial 
....................       result up until the point of the failure. 
....................     FS_GET_PROPERTIES_STILL_WORKING - the search for free sectors is still in 
....................       process.  Continue calling this function with the same properties pointer 
....................       until either the function completes or until the partial results meets the 
....................       application needs.  The properties object contains the partial results of 
....................       the search and can be used by the application. 
....................   Side Effects: 
....................     Can cause errors if called when files are open.  Close all files before 
....................     calling this function. 
....................  
....................     Calling this function without setting the new_request member on the first 
....................     call can result in undefined behavior and results. 
....................  
....................     Calling this function after a result is returned other than 
....................     FS_GET_PROPERTIES_STILL_WORKING can result in undefined behavior and results. 
....................   Description: 
....................     This function returns the information about the mounted drive.  The results 
....................     member of the properties object passed into the function is populated with 
....................     the information about the drive. 
....................  
....................     Before starting a new request, the new_request member of the properties 
....................     input parameter should be set to TRUE.  This will initiate a new search 
....................     request. 
....................  
....................     This function will return before the search is complete with partial results. 
....................     All of the results except the free_clusters will be correct after the first 
....................     call.  The free_clusters will contain the number of free clusters found up 
....................     until that point, thus the free_clusters result will continue to grow until 
....................     the entire drive is searched.  If an application only needs to know that a 
....................     certain number of bytes is available and doesn't need to know the total free 
....................     size, then this function can be called until the required free size is 
....................     verified.  To continue a search, pass a pointer to the same FS_DISK_PROPERTIES 
....................     object that was passed in to create the search. 
....................  
....................     A new search request sould be made once this function has returned a value 
....................     other than FS_GET_PROPERTIES_STILL_WORKING.  Continuing a completed search 
....................     can result in undefined behavior or results. 
....................  
....................     Typical Usage: 
....................     <code> 
....................     FS_DISK_PROPERTIES disk_properties; 
....................  
....................     disk_properties.new_request = TRUE; 
....................  
....................     do 
....................     { 
....................         FSGetDiskProperties(&disk_properties); 
....................     } while (disk_properties.properties_status == FS_GET_PROPERTIES_STILL_WORKING); 
....................     </code> 
....................  
....................     results.disk_format - contains the format of the drive.  Valid results are 
....................       FAT12(1), FAT16(2), or FAT32(3). 
....................  
....................     results.sector_size - the sector size of the mounted drive.  Valid values are 
....................       512, 1024, 2048, and 4096. 
....................  
....................     results.sectors_per_cluster - the number sectors per cluster. 
....................  
....................     results.total_clusters - the number of total clusters on the drive.  This 
....................       can be used to calculate the total disk size (total_clusters * 
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................     results.free_clusters - the number of free (unallocated) clusters on the drive. 
....................       This can be used to calculate the total free disk size (free_clusters * 
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................   Remarks: 
....................     PIC24F size estimates: 
....................       Flash - 400 bytes (-Os setting) 
....................  
....................     PIC24F speed estimates: 
....................       Search takes approximately 7 seconds per Gigabyte of drive space.  Speed 
....................         will vary based on the number of sectors per cluster and the sector size. 
....................   *********************************************************************************/ 
.................... #if defined(ALLOW_GET_DISK_PROPERTIES) 
.................... void FSGetDiskProperties(FS_DISK_PROPERTIES* properties) 
.................... { 
....................     BYTE    i; 
....................     DWORD   value = 0x0; 
....................  
....................     if(properties->new_request == TRUE) 
....................     { 
....................         properties->disk = &gDiskData; 
....................         properties->results.free_clusters = 0; 
....................         properties->new_request = FALSE; 
....................  
....................         if(properties->disk->mount != TRUE) 
....................         { 
....................             properties->properties_status = FS_GET_PROPERTIES_DISK_NOT_MOUNTED; 
....................             return; 
....................         } 
....................  
....................         properties->properties_status = FS_GET_PROPERTIES_STILL_WORKING; 
....................  
....................         properties->results.disk_format = properties->disk->type; 
....................         properties->results.sector_size = properties->disk->sectorSize; 
....................         properties->results.sectors_per_cluster = properties->disk->SecPerClus; 
....................         properties->results.total_clusters = properties->disk->maxcls; 
....................  
....................         /* Settings based on FAT type */ 
....................         switch (properties->disk->type) 
....................         { 
....................     #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................             case FAT32: 
....................                 properties->private.EndClusterLimit = END_CLUSTER_FAT32; 
....................                 properties->private.ClusterFailValue = CLUSTER_FAIL_FAT32; 
....................                 break; 
....................     #endif 
....................             case FAT16: 
....................                 properties->private.EndClusterLimit = END_CLUSTER_FAT16; 
....................                 properties->private.ClusterFailValue = CLUSTER_FAIL_FAT16; 
....................                 break; 
.................... #ifdef SUPPORT_FAT12 
....................             case FAT12: 
....................                 properties->private.EndClusterLimit = END_CLUSTER_FAT12; 
....................                 properties->private.ClusterFailValue = CLUSTER_FAIL_FAT16; 
....................                 break; 
.................... #endif 
....................         } 
....................  
....................         properties->private.c = 2; 
....................  
....................         properties->private.curcls = properties->private.c; 
....................         ReadFAT(properties->disk, properties->private.c); 
....................     } 
....................  
....................     if(properties->disk == NULL) 
....................     { 
....................         properties->properties_status = FS_GET_PROPERTIES_DISK_NOT_MOUNTED; 
....................         return; 
....................     } 
....................  
....................     if(properties->properties_status != FS_GET_PROPERTIES_STILL_WORKING) 
....................     { 
....................         return; 
....................     } 
....................  
....................     // sequentially scan through the FAT looking for an empty cluster 
....................     for(i=0;i<255;i++) 
....................     { 
....................         // look at its value 
....................         if ( (value = ReadFAT(properties->disk, properties->private.c)) == properties->private.ClusterFailValue) 
....................         { 
....................             properties->properties_status = FS_GET_PROPERTIES_CLUSTER_FAILURE; 
....................             return; 
....................         } 
....................  
....................         // check if empty cluster found 
....................         if (value == CLUSTER_EMPTY) 
....................         { 
....................             properties->results.free_clusters++; 
....................         } 
....................  
....................         properties->private.c++;    // check next cluster in FAT 
....................         // check if reached last cluster in FAT, re-start from top 
....................         if ((value == properties->private.EndClusterLimit) || (properties->private.c >= (properties->results.total_clusters + 2))) 
....................             properties->private.c = 2; 
....................  
....................         // check if full circle done, disk full 
....................         if ( properties->private.c == properties->private.curcls) 
....................         { 
....................             properties->properties_status = FS_GET_PROPERTIES_NO_ERRORS; 
....................             return; 
....................         } 
....................     }  // scanning for an empty cluster 
....................  
....................     properties->properties_status = FS_GET_PROPERTIES_STILL_WORKING; 
....................     return; 
.................... } 
.................... #endif 
....................  
.................... /************************************************************ 
....................   Function: 
....................     int FSfclose(FSFILE *fo) 
....................   Summary: 
....................     Update file information and free FSFILE objects 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to the file to close 
....................   Return Values: 
....................     0 -   File closed successfully 
....................     EOF - Error closing the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will update the directory entry for the 
....................     file pointed to by 'fo' with the information contained 
....................     in 'fo,' including the new file size and attributes. 
....................     Timestamp information will also be loaded based on the 
....................     method selected by the user and written to the entry 
....................     as the last modified time and date.  The file entry will 
....................     then be written to the device.  Finally, the memory 
....................     used for the specified file object will be freed from 
....................     the dynamic heap or the array of FSFILE objects. 
....................   Remarks: 
....................     A function to flush data to the device without closing the 
....................     file can be created by removing the portion of this 
....................     function that frees the memory and the line that clears 
....................     the write flag. 
....................   ************************************************************/ 
....................  
.................... int FSfclose(FSFILE   *fo) 
.................... { 
....................     WORD        fHandle; 
.................... #ifndef FS_DYNAMIC_MEM 
....................     WORD        fIndex; 
.................... #endif 
....................     int        error = 72; 
.................... #ifdef ALLOW_WRITES 
....................     DIRENTRY    dir; 
.................... #endif 
....................  
....................     FSerrno = CE_GOOD; 
....................     fHandle = fo->entry; 
....................  
.................... #ifdef ALLOW_WRITES 
....................     if(fo->flags.write) 
....................     { 
....................         if (gNeedDataWrite) 
....................         { 
....................             if (flushData()) 
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
....................                 return EOF; 
....................             } 
....................         } 
....................  
....................         // Write the current FAT sector to the disk 
....................         WriteFAT (fo->dsk, 0, 0, TRUE); 
....................  
....................         // Invalidate the currently cached FAT entry so that the next read will 
....................         //   result in an acutal read from the physical media instead of a read 
....................         //   from the RAM cache. 
....................         gLastFATSectorRead = 0; 
....................  
....................         // Read the FAT entry from the physical media.  This is required because 
....................         //   some physical media cache the entries in RAM and only write them 
....................         //   after a time expires for until the sector is accessed again. 
....................         ReadFAT (fo->dsk, fo->ccls); 
....................  
....................         // Get the file entry 
....................         dir = LoadDirAttrib(fo, &fHandle); 
....................  
....................         if (dir == NULL) 
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
....................             error = EOF; 
....................             return error; 
....................         } 
....................  
....................       // update the time 
.................... #ifdef INCREMENTTIMESTAMP 
....................         IncrementTimeStamp(dir); 
.................... #elif defined USERDEFINEDCLOCK 
....................         dir->DIR_WrtTime = gTimeWrtTime; 
....................         dir->DIR_WrtDate = gTimeWrtDate; 
.................... #elif defined USEREALTIMECLOCK 
....................         CacheTime(); 
....................         dir->DIR_WrtTime = gTimeWrtTime; 
....................         dir->DIR_WrtDate = gTimeWrtDate; 
.................... #endif 
....................  
....................         dir->DIR_FileSize = fo->size; 
....................  
....................         dir->DIR_Attr = fo->attributes; 
....................  
....................         // just write the last entry in 
....................         if(Write_File_Entry(fo,&fHandle)) 
....................         { 
....................             // Read the folder entry from the physical media.  This is required because 
....................             //   some physical media cache the entries in RAM and only write them 
....................             //   after a time expires for until the sector is accessed again. 
....................             dir = LoadDirAttrib(fo, &fHandle); 
....................             error = 0; 
....................         } 
....................         else 
....................         { 
....................             FSerrno = CE_WRITE_ERROR; 
....................             error = EOF; 
....................         } 
....................  
....................         // it's now closed 
....................         fo->flags.write = FALSE; 
....................     } 
.................... #endif 
....................  
.................... #ifdef FS_DYNAMIC_MEM 
....................     #ifdef   SUPPORT_LFN 
....................       FS_free((unsigned char *)fo->utf16LFNptr); 
....................    #endif 
....................    FS_free((unsigned char *)fo); 
.................... #else 
....................  
....................     for( fIndex = 0; fIndex < FS_MAX_FILES_OPEN; fIndex++ ) 
....................     { 
....................         if( fo == &gFileArray[fIndex] ) 
....................         { 
....................             gFileSlotOpen[fIndex] = TRUE; 
....................             break; 
....................         } 
....................     } 
.................... #endif 
....................  
....................     // File opened in read mode 
....................     if (error == 72) 
....................         error = 0; 
....................  
....................     return(error); 
.................... } // FSfclose 
....................  
....................  
.................... /******************************************************* 
....................   Function: 
....................     void IncrementTimeStamp(DIRENTRY dir) 
....................   Summary: 
....................     Automatically set the timestamp to "don't care" data 
....................   Conditions: 
....................     Should not be called by the user. 
....................   Input: 
....................     dir -  Pointer to directory structure 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will increment the timestamp variable in 
....................     the 'dir' directory entry.  This is used for the 
....................     don't-care timing method. 
....................   Remarks: 
....................     None 
....................   *******************************************************/ 
.................... #ifdef INCREMENTTIMESTAMP 
.................... void IncrementTimeStamp(DIRENTRY dir) 
.................... { 
....................     BYTE          seconds; 
....................     BYTE          minutes; 
....................     BYTE          hours; 
....................  
....................     BYTE          day; 
....................     BYTE          month; 
....................     BYTE          year; 
....................  
....................     seconds = (dir->DIR_WrtTime & 0x1f); 
....................     minutes = ((dir->DIR_WrtTime & 0x07E0) >> 5); 
....................     hours   = ((dir->DIR_WrtTime & 0xF800) >> 11); 
....................  
....................     day     = (dir->DIR_WrtDate & 0x1f); 
....................     month   = ((dir->DIR_WrtDate & 0x01E0) >> 5); 
....................     year    = ((dir->DIR_WrtDate & 0xFE00) >> 9); 
....................  
....................     if(seconds < 29) 
....................     { 
....................         // Increment number of seconds by 2 
....................         // This clock method isn't intended to be accurate anyway 
....................         seconds++; 
....................     } 
....................     else 
....................     { 
....................         seconds = 0x00; 
....................  
....................         if(minutes < 59) 
....................         { 
....................             minutes++; 
....................         } 
....................         else 
....................         { 
....................             minutes = 0; 
....................  
....................             if(hours < 23) 
....................             { 
....................                 hours++; 
....................             } 
....................             else 
....................             { 
....................                 hours = 0; 
....................                 if(day < 30) 
....................                 { 
....................                     day++; 
....................                 } 
....................                 else 
....................                 { 
....................                     day = 1; 
....................  
....................                     if(month < 12) 
....................                     { 
....................                         month++; 
....................                     } 
....................                     else 
....................                     { 
....................                         month = 1; 
....................                         // new year 
....................                         year++; 
....................                         // This is only valid until 2107 
....................                     } 
....................                 } 
....................             } 
....................         } 
....................     } 
....................  
....................     dir->DIR_WrtTime = (WORD)(seconds); 
....................     dir->DIR_WrtTime |= ((WORD)(minutes) << 5); 
....................     dir->DIR_WrtTime |= ((WORD)(hours) << 11); 
....................  
....................     dir->DIR_WrtDate = (WORD)(day); 
....................     dir->DIR_WrtDate |= ((WORD)(month) << 5); 
....................     dir->DIR_WrtDate |= ((WORD)(year) << 9); 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************** 
....................   Function: 
....................     BYTE Fill_File_Object(FILEOBJ fo, WORD *fHandle) 
....................   Summary: 
....................     Fill a file object with specified dir entry data 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................     fHandle -  Passed member's location 
....................   Return Values: 
....................     FOUND -     Operation successful 
....................     NOT_FOUND - Operation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache the sector of directory entries 
....................     in the directory pointed to by the dirclus value in 
....................     the FSFILE object 'fo' that contains the entry that 
....................     corresponds to the fHandle offset.  It will then copy 
....................     the file information for that entry into the 'fo' FSFILE 
....................     object. 
....................   Remarks: 
....................     None. 
....................   *****************************************************************/ 
....................  
.................... BYTE Fill_File_Object(FILEOBJ fo, WORD *fHandle) 
.................... { 
....................     DIRENTRY    dir; 
....................     BYTE        index, a; 
....................     BYTE        character; 
....................     BYTE        status; 
....................     BYTE        test = 0; 
....................  
.................... #ifdef __DEBUG_UART   
.................... PrintROMASCIIStringUART("Fill_File_Object"); 
.................... #endif 
....................  
....................  
....................     // Get the entry 
....................     if (((*fHandle & MASK_MAX_FILE_ENTRY_LIMIT_BITS) == 0) && (*fHandle != 0)) // 4-bit mask because 16-root entries max per sector 
....................     { 
....................         fo->dirccls = fo->dirclus; 
....................          
....................          #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" Cache_File_Entry FORCE dirccls="); 
....................          PrintRAMBytesUART(((unsigned char*)&fo->dirccls), 4); 
....................          #endif     
....................      
....................         dir = Cache_File_Entry(fo, fHandle, TRUE); 
....................     } 
....................     else 
....................     { 
....................          #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" Cache_File_Entry dirccls="); 
....................          PrintRAMBytesUART(((unsigned char*)&fo->dirccls), 4); 
....................          PrintROMASCIIStringUART(" dirclus="); 
....................          PrintRAMBytesUART(((unsigned char*)&fo->dirclus), 4);                   
....................          #endif     
....................           
....................         dir = Cache_File_Entry (fo, fHandle, FALSE); 
....................     } 
....................  
....................    #ifdef __DEBUG_UART 
....................    PrintROMASCIIStringUART(" dir="); 
....................    PrintRAMBytesUART(((unsigned char*)&dir), sizeof(dir));          
....................    #endif 
....................  
....................  
....................     // Make sure there is a directory left 
....................     if(dir == (DIRENTRY)NULL) 
....................     { 
....................         status = NO_MORE; 
....................     } 
....................     else 
....................     { 
....................         // Read the first char of the file name 
....................         a = dir->DIR_Name[0]; 
....................  
....................    #ifdef __DEBUG_UART 
....................    PrintROMASCIIStringUART(" a="); 
....................    PrintRAMBytesUART(((unsigned char*)&a), sizeof(a));          
....................    #endif 
....................  
....................         // Check for empty or deleted directory 
....................         if ( a == DIR_DEL) 
....................       { 
....................             status = NOT_FOUND; 
....................       } 
....................       else if ( a == DIR_EMPTY) 
....................       { 
....................          status = NO_MORE; 
....................       } 
....................         else 
....................         { 
....................             // Get the attributes 
....................             a = dir->DIR_Attr; 
....................  
....................             // print the file name and extension 
....................             for (index=0; index < DIR_NAMESIZE; index++) 
....................             { 
....................                 character = dir->DIR_Name[index]; 
....................                 character = (BYTE)toupper(character); 
....................                 fo->name[test++] = character; 
....................             } 
....................  
....................             // Get the attributes 
....................             a = dir->DIR_Attr; 
....................  
....................             // its possible to have an extension in a directory 
....................             character = dir->DIR_Extension[0]; 
....................  
....................             // Get the file extension if its there 
....................             for (index=0; index < DIR_EXTENSION; index++) 
....................             { 
....................                 character = dir->DIR_Extension[index]; 
....................                 character = (BYTE)toupper(character); 
....................                 fo->name[test++] = character; 
....................             } 
....................  
....................    #ifdef __DEBUG_UART 
....................    PrintROMASCIIStringUART(" name="); 
....................    PrintRAMBytesUART(((unsigned char*)fo->name), test);          
....................    #endif 
....................  
....................             // done and done with the name 
....................             //         fo->name[++test] = (BYTE)'\0'; 
....................  
....................             // Now store the identifier 
....................             fo->entry = *fHandle; 
....................  
....................             // see if we are still a good file 
....................             a = dir->DIR_Name[0]; 
....................  
....................             if(a == DIR_DEL) 
....................                 status = NOT_FOUND; 
....................             else 
....................                 status = FOUND; 
....................  
....................             // Now store the size 
....................             fo->size = (dir->DIR_FileSize); 
....................  
....................             fo->cluster = GetFullClusterNumber(dir); // Get Complete Cluster number. 
....................  
....................    #ifdef __DEBUG_UART 
....................    PrintROMASCIIStringUART(" cluster="); 
....................    PrintRAMBytesUART(((unsigned char*)&fo->cluster), 4);          
....................    #endif 
....................  
....................             /// -Get and store the attributes 
....................             a = dir->DIR_Attr; 
....................             fo->attributes = a; 
....................  
....................             // get the date and time 
....................             if ((a & ATTR_DIRECTORY) != 0) 
....................             { 
....................                 fo->time = dir->DIR_CrtTime; 
....................                 fo->date = dir->DIR_CrtDate; 
....................             } 
....................             else 
....................             { 
....................                 fo->time = dir->DIR_WrtTime; 
....................                 fo->date = dir->DIR_WrtDate; 
....................             } 
....................  
....................         }// deleted directory 
....................     }// Ensure we are still good 
....................  
.................... #ifdef __DEBUG_UART   
.................... UARTSendLineFeedCarriageReturn(); 
.................... #endif 
....................     return(status); 
.................... } // Fill_File_Object 
....................  
.................... /***************************************************************** 
....................   Function: 
....................     BYTE Fill_LFN_Object(FILEOBJ fo, LFN_ENTRY *lfno, WORD *fHandle) 
....................   Summary: 
....................     Fill a LFN object with specified entry data 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -   Pointer to file structure 
....................     lfno - Pointer to Long File Name Object 
....................     fHandle -  Passed member's location 
....................   Return Values: 
....................     FOUND -     Operation successful 
....................     NOT_FOUND - Operation failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache the sector of LFN entries 
....................     in the directory pointed to by the dirclus value in 
....................     the FSFILE object 'fo' that contains the entry that 
....................     corresponds to the fHandle offset.  It will then copy 
....................     the file information for that entry into the 'fo' FSFILE 
....................     object. 
....................   Remarks: 
....................     None. 
....................   *****************************************************************/ 
.................... #if defined(SUPPORT_LFN) 
.................... BYTE Fill_LFN_Object(FILEOBJ fo, LFN_ENTRY *lfno, WORD *fHandle) 
.................... { 
....................     DIRENTRY    dir; 
....................     BYTE        tempVariable; 
....................     BYTE        *src,*dst; 
....................     BYTE        status; 
....................  
....................     // Get the entry 
....................     if (((*fHandle & MASK_MAX_FILE_ENTRY_LIMIT_BITS) == 0) && (*fHandle != 0)) // 4-bit mask because 16-root entries max per sector 
....................     { 
....................         fo->dirccls = fo->dirclus; 
....................         dir = Cache_File_Entry(fo, fHandle, TRUE); 
....................     } 
....................     else 
....................     { 
....................         dir = Cache_File_Entry (fo, fHandle, FALSE); 
....................     } 
....................  
....................  
....................     // Make sure there is a directory left 
....................     if(dir == (DIRENTRY)NULL) 
....................     { 
....................         status = NO_MORE; 
....................     } 
....................     else 
....................     { 
....................         // Read the first char of the file name 
....................         tempVariable = dir->DIR_Name[0]; 
....................  
....................         // Check for empty or deleted directory 
....................         if ( tempVariable == DIR_DEL) 
....................       { 
....................             status = NOT_FOUND; 
....................       } 
....................       else if ( tempVariable == DIR_EMPTY) 
....................       { 
....................          status = NO_MORE; 
....................       } 
....................         else 
....................         { 
....................             status = FOUND; 
....................  
....................          dst = (BYTE *)lfno; 
....................          src = (BYTE *)dir; 
....................  
....................          // Copy the entry in the lfno object 
....................          for(tempVariable = 0;tempVariable < 32;tempVariable++) 
....................          { 
....................             *dst++ = *src++; 
....................          } 
....................         }// deleted directory 
....................     }// Ensure we are still good 
....................     return(status); 
.................... } // Fill_File_Object 
.................... #endif 
.................... /************************************************************************ 
....................   Function: 
....................     DIRENTRY LoadDirAttrib(FILEOBJ fo, WORD *fHandle) 
....................   Summary: 
....................     Load file information from a directory entry and cache the entry 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................     fHandle -  Information location 
....................   Return Values: 
....................     DIRENTRY - Pointer to the directory entry 
....................     NULL -     Directory entry could not be loaded 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache the sector of directory entries 
....................     in the directory pointed to by the dirclus value in 
....................     the FSFILE object 'fo' that contains the entry that 
....................     corresponds to the fHandle offset.  It will then return a pointer 
....................     to the directory entry in the global data buffer. 
....................   Remarks: 
....................     None. 
....................   ************************************************************************/ 
....................  
.................... DIRENTRY LoadDirAttrib(FILEOBJ fo, WORD *fHandle) 
.................... { 
....................     DIRENTRY    dir; 
....................     BYTE      a; 
....................  
....................     fo->dirccls = fo->dirclus; 
....................     // Get the entry 
....................     dir = Cache_File_Entry( fo, fHandle, TRUE); 
....................     if (dir == NULL) 
....................         return NULL; 
....................  
....................     // Read the first char of the file name 
....................     a = dir->DIR_Name[0]; 
....................  
....................     // Make sure there is a directory left 
....................     if(a == DIR_EMPTY) 
....................         dir = (DIRENTRY)NULL; 
....................  
....................     if(dir != (DIRENTRY)NULL) 
....................     { 
....................         // Check for empty or deleted directory 
....................         if ( a == DIR_DEL) 
....................             dir = (DIRENTRY)NULL; 
....................         else 
....................         { 
....................             // Get the attributes 
....................             a = dir->DIR_Attr; 
....................  
....................             // scan through all the long dir entries 
....................             while(a == ATTR_LONG_NAME) 
....................             { 
....................                 (*fHandle)++; 
....................                 dir = Cache_File_Entry( fo, fHandle, FALSE); 
....................                 if (dir == NULL) 
....................                     return NULL; 
....................                 a = dir->DIR_Attr; 
....................             } // long file name while loop 
....................         } // deleted dir 
....................     }// Ensure we are still good 
....................  
....................     return(dir); 
.................... } // LoadDirAttrib 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     CETYPE FILEerase( FILEOBJ fo, WORD *fHandle, BYTE EraseClusters) 
....................   Summary: 
....................     Erase a file 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -            Pointer to file structure 
....................     fHandle -       Location of file information 
....................     EraseClusters - If set to TRUE, delete the corresponding cluster of file 
....................   Return Values: 
....................     CE_GOOD - File erased successfully 
....................     CE_FILE_NOT_FOUND - Could not find the file on the card 
....................     CE_ERASE_FAIL - Internal Card erase failed 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will cache the sector of directory entries in the directory 
....................     pointed to by the dirclus value in the FSFILE object 'fo' that contains 
....................     the entry that corresponds to the fHandle offset.  It will then mark that 
....................     entry as deleted.  If the EraseClusters argument is TRUE, the chain of 
....................     clusters for that file will be marked as unused in the FAT by the 
....................     FAT_erase_cluster_chain function. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... CETYPE FILEerase( FILEOBJ fo, WORD *fHandle, BYTE EraseClusters) 
.................... { 
....................     DIRENTRY    dir; 
....................     BYTE        a; 
....................     CETYPE      status = CE_GOOD; 
....................     DWORD       clus = 0; 
....................     DISK *      disk; 
....................  
....................     BYTE   numberOfFileEntries; 
....................    BOOL   forFirstTime = TRUE; 
....................    #if defined(SUPPORT_LFN) 
....................       BYTE   tempCalc1; 
....................    #endif 
....................  
....................     disk = fo->dsk; 
....................  
....................    #if defined(SUPPORT_LFN) 
....................  
....................    fileNameLength = fo->utf16LFNlength; 
....................  
....................    // Find the number of entries of LFN in the root directory 
....................    if(fileNameLength) 
....................    { 
....................       tempCalc1 = fileNameLength % 13; 
....................  
....................       numberOfFileEntries = fileNameLength/13; 
....................  
....................       if(tempCalc1 || (fileNameLength < 13)) 
....................       { 
....................          numberOfFileEntries = numberOfFileEntries + 2; 
....................       } 
....................       else 
....................       { 
....................          numberOfFileEntries++; 
....................       } 
....................    } 
....................    else 
....................    #endif 
....................    { 
....................       numberOfFileEntries = 1; 
....................    } 
....................  
....................    FSerrno = CE_ERASE_FAIL; 
....................  
....................    // delete all the entries of LFN in root directory 
....................    while(numberOfFileEntries--) 
....................    { 
....................        // reset the cluster 
....................        fo->dirccls = fo->dirclus; 
....................  
....................        // load the sector 
....................        dir = Cache_File_Entry(fo, fHandle, TRUE); 
....................  
....................        if (dir == NULL) 
....................        { 
....................            return CE_BADCACHEREAD; 
....................        } 
....................  
....................        // Fill up the File Object with the information pointed to by fHandle 
....................        a = dir->DIR_Name[0]; 
....................  
....................        // see if there is something in the dir 
....................        if((dir == (DIRENTRY)NULL) || (a == DIR_EMPTY) || (a == DIR_DEL)) 
....................        { 
....................            status = CE_FILE_NOT_FOUND; 
....................          break; 
....................        } 
....................       else 
....................       { 
....................             /* 8.3 File Name - entry*/ 
....................             dir->DIR_Name[0] = DIR_DEL; // mark as deleted 
....................  
....................          if(!(Write_File_Entry( fo, fHandle))) 
....................            { 
....................                status = CE_ERASE_FAIL; 
....................             break; 
....................            } 
....................       } 
....................  
....................       if(forFirstTime) 
....................       { 
....................          // Get the starting cluster 
....................          clus = GetFullClusterNumber(dir); // Get Complete Cluster number. 
....................          forFirstTime = FALSE; 
....................       } 
....................  
....................       *fHandle = *fHandle - 1; 
....................    } 
....................  
....................    if(status == CE_GOOD) 
....................    { 
....................       if (clus != FatRootDirClusterValue) // 
....................       { 
....................          // If 'EraseClusters' is set to TRUE, erase the cluster chain corresponding to file 
....................           if(EraseClusters) 
....................           { 
....................               /* Now remove the cluster allocation from the FAT */ 
....................               status = ((FAT_erase_cluster_chain(clus, disk)) ? CE_GOOD : CE_ERASE_FAIL); 
....................           } 
....................       } 
....................  
....................       FSerrno = status; 
....................    } 
....................  
....................     return (status); 
.................... } 
.................... #endif 
....................  
.................... /*************************************************************** 
....................   Function: 
....................     int FSrename (const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices. 
....................     First, it will search through the current working directory to ensure the 
....................     specified new filename is not already in use. If it isn't, the new filename 
....................     will be written to the file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None 
....................   ***************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... int FSrename (const char * fileName, FSFILE * fo) 
.................... { 
....................     WORD fHandle; 
....................    FSFILE   tempFo1,tempFo2; 
....................     DIRENTRY dir; 
....................     #ifdef SUPPORT_LFN 
....................     DWORD  TempMsbCluster; 
....................     #else 
....................     BYTE j; 
....................     #endif 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................     if (MDD_WriteProtectState()) 
....................     { 
....................         FSerrno = CE_WRITE_PROTECTED; 
....................         return (-1); 
....................     } 
....................  
....................      // copy file object over 
....................     FileObjectCopy(&tempFo1, fo); 
....................  
....................     //Format the source string 
....................     if(!FormatFileName(fileName, &tempFo1, 0) ) 
....................     { 
....................         FSerrno = CE_INVALID_FILENAME; 
....................         return -1; 
....................     } 
....................  
....................    tempFo1.entry  = 0; 
....................  
....................    // start at the current directory 
....................    tempFo1.dirclus  = cwdptr->dirclus; 
....................    tempFo1.dirccls  = cwdptr->dirccls; 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&tempFo2, &tempFo1); 
....................  
....................     // See if the file is found 
....................     if(FILEfind (&tempFo2, &tempFo1, LOOK_FOR_MATCHING_ENTRY, 0) == CE_FILE_NOT_FOUND) 
....................    { 
....................       fHandle = fo->entry; 
....................  
....................       #ifdef SUPPORT_LFN 
....................  
....................       if(CE_GOOD != FILEerase(fo, &fHandle, FALSE)) 
....................       { 
....................          FSerrno = CE_ERASE_FAIL; 
....................          return -1; 
....................       } 
....................  
....................          // Create the new entry as per the user requested name 
....................          FSerrno = CreateFileEntry (&tempFo1, &fHandle, tempFo1.attributes, FALSE); 
....................  
....................          // load the file entry so the new cluster can be linked to it 
....................          dir = LoadDirAttrib(&tempFo1, &fHandle); 
....................  
....................          // Now update the new cluster 
....................          dir->DIR_FstClusLO = (fo->cluster & 0x0000FFFF); 
....................  
....................          #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................          // Get the higher part of cluster and store it in directory entry. 
....................          TempMsbCluster = (fo->cluster & 0x0FFF0000);    // Since only 28 bits usedin FAT32. Mask the higher MSB nibble. 
....................          TempMsbCluster = TempMsbCluster >> 16;      // Get the date into Lsb place. 
....................          dir->DIR_FstClusHI = TempMsbCluster; 
....................          #else // If FAT32 support not enabled 
....................          TempMsbCluster = 0;                         // Just to avoid compiler warnigng. 
....................          dir->DIR_FstClusHI = 0; 
....................          #endif 
....................  
....................       // Update the file size 
....................         dir->DIR_FileSize = fo->size; 
....................  
....................          // now write it 
....................          if(Write_File_Entry(&tempFo1, &fHandle) != TRUE) 
....................       { 
....................           FSerrno = CE_WRITE_ERROR; 
....................           return -1; 
....................       } 
....................  
....................          tempFo1.size = fo->size; 
....................  
....................       // copy file object over 
....................       FileObjectCopy(fo, &tempFo1); 
....................  
....................       #else 
....................  
....................         // Get the file entry 
....................         dir = LoadDirAttrib(fo, &fHandle); 
....................  
....................         for (j = 0; j < 11; j++) 
....................         { 
....................             fo->name[j] = tempFo1.name[j]; 
....................             dir->DIR_Name[j] = tempFo1.name[j]; 
....................         } 
....................  
....................         // just write the last entry in 
....................         if(!Write_File_Entry(fo,&fHandle)) 
....................         { 
....................             FSerrno = CE_WRITE_ERROR; 
....................             return -1; 
....................         } 
....................  
....................       #endif 
....................    } 
....................    else 
....................    { 
....................         FSerrno = CE_FILENAME_EXISTS; 
....................         return -1; 
....................    } 
....................  
....................     return 0; 
.................... } 
....................  
.................... /*************************************************************** 
....................   Function: 
....................     int wFSrename (const rom unsigned short int * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices. First, it will search through the current 
....................     working directory to ensure the specified new UTF16 filename is not 
....................     already in use.  If it isn't, the new filename will be written to the 
....................     file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None 
....................   ***************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSrename (const unsigned short int * fileName, FSFILE * fo) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................    result = FSrename ((const char *)fileName,fo); 
....................    utfModeFileName = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... #endif // Allow writes 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * wFSfopen (const unsigned short int * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... FSFILE * wFSfopen( const unsigned short int * fileName, const char *mode ) 
.................... { 
....................    FSFILE *result; 
....................    utfModeFileName = TRUE; 
....................    result = FSfopen((const char *)fileName,mode); 
....................    utfModeFileName = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * FSfopen (const char * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with ascii input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will open a ascii name file or directory on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * FSfopen( const char * fileName, const char *mode ) 
.................... { 
....................     FILEOBJ    filePtr; 
.................... #ifndef FS_DYNAMIC_MEM 
....................     int      fIndex; 
.................... #endif 
....................     BYTE   ModeC; 
....................     WORD    fHandle; 
....................     CETYPE   final; 
....................  
....................     //Read the mode character 
....................     ModeC = mode[0]; 
....................  
....................     if(MDD_WriteProtectState() && (ModeC != 'r') && (ModeC != 'R')) 
....................     { 
....................         FSerrno = CE_WRITE_PROTECTED; 
....................         return NULL; 
....................     } 
....................  
.................... #ifdef FS_DYNAMIC_MEM 
....................     filePtr = (FILEOBJ) FS_malloc(sizeof(FSFILE)); 
.................... #else 
....................  
....................     filePtr = NULL; 
....................  
....................     //Pick available file structure 
....................     for( fIndex = 0; fIndex < FS_MAX_FILES_OPEN; fIndex++ ) 
....................     { 
....................         if( gFileSlotOpen[fIndex] )   //this slot is available 
....................         { 
....................             gFileSlotOpen[fIndex] = FALSE; 
....................             filePtr = &gFileArray[fIndex]; 
....................          break; 
....................         } 
....................     } 
....................  
....................     if( filePtr == NULL ) 
....................     { 
....................         FSerrno = CE_TOO_MANY_FILES_OPEN; 
....................         return NULL;      //no file structure slot available 
....................     } 
.................... #endif 
....................  
....................    #if defined(SUPPORT_LFN) 
....................       #if defined(FS_DYNAMIC_MEM) 
....................          filePtr -> utf16LFNptr = (unsigned short int *)FS_malloc(514); 
....................       #else 
....................          filePtr->utf16LFNptr = &lfnData[fIndex][0]; 
....................       #endif 
....................     #endif 
....................  
....................     //Format the source string. 
....................     if( !FormatFileName(fileName, filePtr, 0) ) 
....................     { 
....................       #ifdef FS_DYNAMIC_MEM 
....................          #if defined(SUPPORT_LFN) 
....................             FS_free((unsigned char *)filePtr->utf16LFNptr); 
....................          #endif 
....................            FS_free( (unsigned char *)filePtr ); 
....................       #else 
....................            gFileSlotOpen[fIndex] = TRUE;   //put this slot back to the pool 
....................       #endif 
....................  
....................       FSerrno = CE_INVALID_FILENAME; 
....................         return NULL;   //bad filename 
....................     } 
....................  
....................     filePtr->dsk = &gDiskData; 
....................     filePtr->cluster = 0; 
....................     filePtr->ccls    = 0; 
....................     filePtr->entry = 0; 
....................     filePtr->attributes = ATTR_ARCHIVE; 
....................  
....................     // start at the current directory 
.................... #ifdef ALLOW_DIRS 
....................     filePtr->dirclus    = cwdptr->dirclus; 
....................     filePtr->dirccls    = cwdptr->dirccls; 
.................... #else 
....................     filePtr->dirclus = FatRootDirClusterValue; 
....................     filePtr->dirccls = FatRootDirClusterValue; 
.................... #endif 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&gFileTemp, filePtr); 
....................  
....................     // See if the file is found 
....................     if(FILEfind (filePtr, &gFileTemp, LOOK_FOR_MATCHING_ENTRY, 0) == CE_GOOD) 
....................     { 
....................         // File is Found 
....................         switch(ModeC) 
....................         { 
.................... #ifdef ALLOW_WRITES 
....................             case 'w': 
....................             case 'W': 
....................             { 
....................                 // File exists, we want to create a new one, remove it first 
....................                 fHandle = filePtr->entry; 
....................                 final = FILEerase(filePtr, &fHandle, TRUE); 
....................  
....................                 if (final == CE_GOOD) 
....................                 { 
....................                     // now create a new one 
....................                     final = CreateFileEntry (filePtr, &fHandle, 0, TRUE); 
....................  
....................                     if (final == CE_GOOD) 
....................                     { 
....................                         final = FILEopen (filePtr, &fHandle, 'w'); 
....................  
....................                         if (filePtr->attributes & ATTR_DIRECTORY) 
....................                         { 
....................                             FSerrno = CE_INVALID_ARGUMENT; 
....................                             final = 0xFF; 
....................                         } 
....................  
....................                         if (final == CE_GOOD) 
....................                         { 
....................                             final = FSfseek (filePtr, 0, SEEK_END); 
....................                             if (mode[1] == '+') 
....................                                 filePtr->flags.read = 1; 
....................                         } 
....................                     } 
....................                 } 
....................                 break; 
....................             } 
....................  
....................             case 'A': 
....................             case 'a': 
....................             { 
....................                 if(filePtr->size != 0) 
....................                 { 
....................                     fHandle = filePtr->entry; 
....................  
....................                     final = FILEopen (filePtr, &fHandle, 'w'); 
....................  
....................                     if (filePtr->attributes & ATTR_DIRECTORY) 
....................                     { 
....................                         FSerrno = CE_INVALID_ARGUMENT; 
....................                         final = 0xFF; 
....................                     } 
....................  
....................                     if (final == CE_GOOD) 
....................                     { 
....................                         final = FSfseek (filePtr, 0, SEEK_END); 
....................                         if (final != CE_GOOD) 
....................                             FSerrno = CE_SEEK_ERROR; 
....................                         else 
....................                             ReadFAT (&gDiskData, filePtr->ccls); 
....................                         if (mode[1] == '+') 
....................                             filePtr->flags.read = 1; 
....................                     } 
....................                 } 
....................                 else 
....................                 { 
....................                     fHandle = filePtr->entry; 
....................                     final = FILEerase(filePtr, &fHandle, TRUE); 
....................  
....................                     if (final == CE_GOOD) 
....................                     { 
....................                         // now create a new one 
....................                         final = CreateFileEntry (filePtr, &fHandle, 0, TRUE); 
....................  
....................                         if (final == CE_GOOD) 
....................                         { 
....................                             final = FILEopen (filePtr, &fHandle, 'w'); 
....................  
....................                             if (filePtr->attributes & ATTR_DIRECTORY) 
....................                             { 
....................                                 FSerrno = CE_INVALID_ARGUMENT; 
....................                                 final = 0xFF; 
....................                             } 
....................  
....................                             if (final == CE_GOOD) 
....................                             { 
....................                                 final = FSfseek (filePtr, 0, SEEK_END); 
....................                                 if (final != CE_GOOD) 
....................                                     FSerrno = CE_SEEK_ERROR; 
....................                                 if (mode[1] == '+') 
....................                                     filePtr->flags.read = 1; 
....................                             } 
....................                         } 
....................                     } 
....................                 } 
....................                 break; 
....................             } 
.................... #endif 
....................             case 'R': 
....................             case 'r': 
....................             { 
....................                 fHandle = filePtr->entry; 
....................  
....................                 final = FILEopen (filePtr, &fHandle, 'r'); 
.................... #ifdef ALLOW_WRITES 
....................                 if ((mode[1] == '+') && !(filePtr->attributes & ATTR_DIRECTORY)) 
....................                     filePtr->flags.write = 1; 
.................... #endif 
....................                 break; 
....................             } 
....................  
....................             default: 
....................                 FSerrno = CE_INVALID_ARGUMENT; 
....................                 final = 0xFF;;  //indicate error condition 
....................                 break; 
....................         } 
....................     } 
....................     else 
....................     { 
.................... #ifdef ALLOW_WRITES 
....................         // the file was not found, reset to the default asked 
....................         FileObjectCopy(filePtr, &gFileTemp); 
....................  
....................         // File is not Found 
....................         if((ModeC == 'w') || (ModeC == 'W') || (ModeC == 'a') || (ModeC == 'A')) 
....................         { 
....................             // use the user requested name 
....................             fHandle = 0; 
....................             final = CreateFileEntry (filePtr, &fHandle, 0, TRUE); 
....................  
....................             if (final == CE_GOOD) 
....................             { 
....................                 final = FILEopen (filePtr, &fHandle, 'w'); 
....................                 if (filePtr->attributes & ATTR_DIRECTORY) 
....................                 { 
....................                     FSerrno = CE_INVALID_ARGUMENT; 
....................                     final = 0xFF; 
....................                 } 
....................  
....................                 if (final == CE_GOOD) 
....................                 { 
....................                     final = FSfseek (filePtr, 0, SEEK_END); 
....................                     if (final != CE_GOOD) 
....................                         FSerrno = CE_SEEK_ERROR; 
....................                     if (mode[1] == '+') 
....................                         filePtr->flags.read = 1; 
....................                 } 
....................             } 
....................         } 
....................         else 
.................... #endif 
....................       { 
....................             final = CE_FILE_NOT_FOUND; 
....................            FSerrno = CE_FILE_NOT_FOUND; 
....................        } 
....................     } 
....................  
....................     if (MDD_WriteProtectState()) 
....................     { 
....................         filePtr->flags.write = 0;; 
....................     } 
....................  
.................... #ifdef FS_DYNAMIC_MEM 
....................     if( final != CE_GOOD ) 
....................     { 
....................         #ifdef   SUPPORT_LFN 
....................          FS_free((unsigned char *)filePtr->utf16LFNptr); 
....................       #endif 
....................       FS_free( (unsigned char *)filePtr ); 
....................         filePtr = NULL; 
....................     } 
.................... #else 
....................     if( final != CE_GOOD ) 
....................     { 
....................         gFileSlotOpen[fIndex] = TRUE;   //put this slot back to the pool 
....................         filePtr = NULL; 
....................     } 
.................... #endif 
....................     else 
....................     { 
....................         FSerrno = CE_GOOD; 
....................     } 
....................  
....................     return filePtr; 
.................... } 
....................  
.................... /******************************************************************* 
....................   Function: 
....................     long FSftell (FSFILE * fo) 
....................   Summary: 
....................     Determine the current location in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return: Current location in the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     The FSftell function will return the current position in the 
....................     file pointed to by 'fo' by returning the 'seek' variable in the 
....................     FSFILE object, which is used to keep track of the absolute 
....................     location of the current position in the file. 
....................   Remarks: 
....................     None 
....................   *******************************************************************/ 
....................  
.................... long FSftell (FSFILE * fo) 
.................... { 
....................     FSerrno = CE_GOOD; 
....................     return (fo->seek); 
.................... } 
....................  
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     int FSremove (const char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed 
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................     The FSremove function will attempt to find the specified file with the FILEfind 
....................     function.  If the file is found, it will be erased using the FILEerase function. 
....................     The user can also provide ascii alias name of the ascii long file name as the 
....................     input to this function to get it erased from the memory. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int FSremove (const char * fileName) 
.................... { 
....................     FILEOBJ fo = &tempCWDobj; 
....................  
....................    #ifdef SUPPORT_LFN 
....................       FSFILE cwdTemp; 
....................       char tempArray[514]; 
....................       LFN_ENTRY *lfno; 
....................       WORD prevHandle; 
....................       unsigned short int i = 0; 
....................    #endif 
....................     FSerrno = CE_GOOD; 
....................  
....................     if (MDD_WriteProtectState()) 
....................     { 
....................         FSerrno = CE_WRITE_PROTECTED; 
....................         return (-1); 
....................     } 
....................  
....................     //Format the source string 
....................    #if defined(SUPPORT_LFN) 
....................       fo->utf16LFNptr = (unsigned short int *)&tempArray[0]; 
....................    #endif 
....................  
....................     if( !FormatFileName(fileName, fo, 0) ) 
....................     { 
....................         FSerrno = CE_INVALID_FILENAME; 
....................         return -1; 
....................     } 
....................  
....................     fo->dsk = &gDiskData; 
....................     fo->cluster = 0; 
....................     fo->ccls    = 0; 
....................     fo->entry = 0; 
....................     fo->attributes = ATTR_ARCHIVE; 
....................  
.................... #ifndef ALLOW_DIRS 
....................     // start at the root directory 
....................     fo->dirclus    = FatRootDirClusterValue; 
....................     fo->dirccls    = FatRootDirClusterValue; 
.................... #else 
....................     fo->dirclus = cwdptr->dirclus; 
....................     fo->dirccls = cwdptr->dirccls; 
.................... #endif 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&gFileTemp, fo); 
....................  
....................     // See if the file is found 
....................     if (FILEfind (fo, &gFileTemp, LOOK_FOR_MATCHING_ENTRY, 0) != CE_GOOD) 
....................     { 
....................         FSerrno = CE_FILE_NOT_FOUND; 
....................         return -1; 
....................     } 
....................  
....................     if (fo->attributes & ATTR_DIRECTORY) 
....................     { 
....................         FSerrno = CE_DELETE_DIR; 
....................         return -1; 
....................     } 
....................  
....................    // Find the long file name assosciated with the short file name if present 
....................    #ifdef SUPPORT_LFN 
....................    if(!fo->utf16LFNlength) 
....................    { 
....................       FileObjectCopy (&cwdTemp, fo); 
....................       prevHandle = fo->entry - 1; 
....................  
....................       lfno = (LFN_ENTRY *)Cache_File_Entry (fo, &prevHandle, FALSE); 
....................  
....................  
....................          while((lfno->LFN_Attribute == ATTR_LONG_NAME) && (lfno->LFN_SequenceNo != DIR_DEL) 
....................  
....................                && (lfno->LFN_SequenceNo != DIR_EMPTY)) 
....................  
....................          { 
....................  
....................  
....................          i = i + MAX_UTF16_CHARS_IN_LFN_ENTRY; 
....................  
....................             prevHandle = prevHandle - 1; 
....................  
....................             lfno = (LFN_ENTRY *)Cache_File_Entry (fo, &prevHandle, FALSE); 
....................  
....................          } 
....................  
....................  
....................  
....................          FileObjectCopy (fo, &cwdTemp); 
....................  
....................       // Find the length of LFN file 
....................       fo->utf16LFNlength = i; 
....................  
....................    } 
....................    #endif 
....................  
....................    // Erase the file 
....................     if( FILEerase(fo, &fo->entry, TRUE) == CE_GOOD ) 
....................         return 0; 
....................     else 
....................     { 
....................         FSerrno = CE_ERASE_FAIL; 
....................         return -1; 
....................     } 
.................... } 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     int wFSremove (const unsigned short int * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed 
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................     The wFSremove function will attempt to find the specified UTF16 file 
....................     name with the FILEfind function. If the file is found, it will be erased 
....................     using the FILEerase function. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSremove (const unsigned short int * fileName) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................    result = FSremove ((const char *)fileName); 
....................    utfModeFileName = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /********************************************************* 
....................   Function: 
....................     void FSrewind (FSFILE * fo) 
....................   Summary: 
....................     Set the current position in a file to the beginning 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The FSrewind funciton will reset the position of the 
....................     specified file to the beginning of the file.  This 
....................     functionality is faster than using FSfseek to reset 
....................     the position in the file. 
....................   Remarks: 
....................     None. 
....................   *********************************************************/ 
....................  
.................... void FSrewind (FSFILE * fo) 
.................... { 
.................... #ifdef ALLOW_WRITES 
....................     if (gNeedDataWrite) 
....................         flushData(); 
.................... #endif 
....................     fo->seek = 0; 
....................     fo->pos = 0; 
....................     fo->sec = 0; 
....................     fo->ccls = fo->cluster; 
....................     gBufferOwner = NULL; 
....................     return; 
.................... } 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSerror (void) 
....................   Summary: 
....................     Return an error code for the last function call 
....................   Conditions: 
....................     The return value depends on the last function called. 
....................   Input: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Return Values: 
....................     FSInit       - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INIT_ERROR             The physical media could not be initialized 
....................                  - CE_BAD_SECTOR_READ        The MBR or the boot sector could not be 
....................                                               read correctly 
....................                  - CE_BAD_PARITION           The MBR signature code was incorrect. 
....................                  - CE_NOT_FORMATTED          The boot sector signature code was incorrect or 
....................                                               indicates an invalid number of bytes per sector. 
....................                  - CE_UNSUPPORTED_SECTOR_SIZE - The number of bytes per sector is unsupported 
....................                  - CE_CARDFAT32              The physical media is FAT32 type (only an error 
....................                                               when FAT32 support is disabled). 
....................                  - CE_UNSUPPORTED_FS         The device is formatted with an unsupported file 
....................                                               system (not FAT12 or 16). 
....................     FSfopen      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_NOT_INIT               The device has not been initialized. 
....................                  - CE_TOO_MANY_FILES_OPEN    The function could not allocate any 
....................                                               additional file information to the array 
....................                                               of FSFILE structures or the heap. 
....................                  - CE_INVALID_FILENAME       The file name argument was invalid. 
....................                  - CE_INVALID_ARGUMENT       The user attempted to open a directory in a 
....................                                               write mode or specified an invalid mode argument. 
....................                  - CE_FILE_NOT_FOUND         The specified file (which was to be opened in read 
....................                                               mode) does not exist on the device. 
....................                  - CE_BADCACHEREAD           A read from the device failed. 
....................                  - CE_ERASE_FAIL             The existing file could not be erased (when opening 
....................                                               a file in FS_WRITE mode). 
....................                  - CE_DIR_FULL               The directory is full. 
....................                  - CE_DISK_FULL              The data memory section is full. 
....................                  - CE_WRITE_ERROR            A write to the device failed. 
....................                  - CE_SEEK_ERROR             The current position in the file could not be set to 
....................                                               the end (when the file was opened in FS_APPEND mode). 
....................     FSfclose     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer or the new file 
....................                                               entry information could not be written to the device. 
....................                  - CE_BADCACHEREAD           The file entry information could not be cached 
....................     FSfread      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITEONLY              The file was opened in a write-only mode. 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device. 
....................                  - CE_BAD_SECTOR_READ        The data sector could not be read. 
....................                  - CE_EOF                    The end of the file was reached. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be loaded. 
....................     FSfwrite     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_READONLY               The file was opened in a read-only mode. 
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated 
....................                                               that the device has been write-protected. 
....................                  - CE_WRITE_ERROR            There was an error writing data to the device. 
....................                  - CE_BADCACHEREAD           The data sector to be modified could not be read from 
....................                                               the device. 
....................                  - CE_DISK_FULL              All data clusters on the device are in use. 
....................     FSfseek      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device. 
....................                  - CE_INVALID_ARGUMENT       The specified offset exceeds the size of the file. 
....................                  - CE_BADCACHEREAD           The sector that contains the new current position 
....................                                               could not be loaded. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be 
....................                                               loaded/allocated. 
....................     FSftell      - 
....................                  - CE_GOOD                   No Error 
....................     FSattrib     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INVALID_ARGUMENT       The attribute argument was invalid. 
....................                  - CE_BADCACHEREAD           The existing file entry information could not be 
....................                                               loaded. 
....................                  - CE_WRITE_ERROR            The file entry information could not be written to 
....................                                               the device. 
....................     FSrename     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_FILENOTOPENED          A null file pointer was passed into the function. 
....................                  - CE_INVALID_FILENAME       The file name passed into the function was invalid. 
....................                  - CE_BADCACHEREAD           A read from the device failed. 
....................                  - CE_FILENAME_EXISTS        A file with the specified name already exists. 
....................                  - CE_WRITE_ERROR            The new file entry data could not be written to the 
....................                                               device. 
....................     FSfeof       - 
....................                  - CE_GOOD                   No Error 
....................     FSformat     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INIT_ERROR             The device could not be initialized. 
....................                  - CE_BADCACHEREAD           The master boot record or boot sector could not be 
....................                                               loaded successfully. 
....................                  - CE_INVALID_ARGUMENT       The user selected to create their own boot sector on 
....................                                               a device that has no master boot record, or the mode 
....................                                               argument was invalid. 
....................                  - CE_WRITE_ERROR            The updated MBR/Boot sector could not be written to 
....................                                               the device. 
....................                  - CE_BAD_PARTITION          The calculated number of sectors per clusters was 
....................                                               invalid. 
....................                  - CE_NONSUPPORTED_SIZE      The card has too many sectors to be formatted as 
....................                                               FAT12 or FAT16. 
....................     FSremove     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated 
....................                                               that the device has been write-protected. 
....................                  - CE_INVALID_FILENAME       The specified filename was invalid. 
....................                  - CE_FILE_NOT_FOUND         The specified file could not be found. 
....................                  - CE_ERASE_FAIL             The file could not be erased. 
....................     FSchdir      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed or the user tried to 
....................                                               change to a non-directory file. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_FOUND          Could not find a directory in the path. 
....................     FSgetcwd     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INVALID_ARGUMENT       The user passed a 0-length buffer into the function. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory 
....................                                               of the current working directory. 
....................     FSmkdir      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated 
....................                                               that the device has been write-protected. 
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed. 
....................                  - CE_BADCACHEREAD           Could not successfully change to a recently created 
....................                                               directory to store its dir entry information, or 
....................                                               could not cache directory entry information. 
....................                  - CE_INVALID_FILENAME       One or more of the directory names has an invalid 
....................                                               format. 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device or the dot/dotdot entries could 
....................                                               not be written to a newly created directory. 
....................                  - CE_DIR_FULL               There are no available dir entries in the CWD. 
....................                  - CE_DISK_FULL              There are no available clusters in the data region of 
....................                                               the device. 
....................     FSrmdir      - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_DIR_NOT_FOUND          The directory specified could not be found or the 
....................                                               function could not change to a subdirectory within 
....................                                               the directory to be deleted (when recursive delete is 
....................                                               enabled). 
....................                  - CE_INVALID_ARGUMENT       The user tried to remove the CWD or root directory. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_EMPTY          The directory to be deleted was not empty and 
....................                                               recursive subdirectory removal was disabled. 
....................                  - CE_ERASE_FAIL             The directory or one of the directories or files 
....................                                               within it could not be deleted. 
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory 
....................                                               of the CWD. 
....................     SetClockVars - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INVALID_ARGUMENT       The time values passed into the function were 
....................                                               invalid. 
....................     FindFirst    - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_INVALID_FILENAME       The specified filename was invalid. 
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found. 
....................                  - CE_BADCACHEREAD           The file information for the file that was found 
....................                                               could not be cached. 
....................     FindNext     - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_NOT_INIT               The SearchRec object was not initialized by a call to 
....................                                               FindFirst. 
....................                  - CE_INVALID_ARGUMENT       The SearchRec object was initialized in a different 
....................                                               directory from the CWD. 
....................                  - CE_INVALID_FILENAME       The filename is invalid. 
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found. 
....................     FSfprintf    - 
....................                  - CE_GOOD                   No Error 
....................                  - CE_WRITE_ERROR            Characters could not be written to the file. 
....................   Description: 
....................     The FSerror function will return the FSerrno variable.  This global 
....................     variable will have been set to an error value during the last call of a 
....................     library function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... int FSerror (void) 
.................... { 
....................     return FSerrno; 
.................... } 
....................  
....................  
.................... /************************************************************** 
....................   Function: 
....................     void FileObjectCopy(FILEOBJ foDest,FILEOBJ foSource) 
....................   Summary: 
....................     Copy a file object 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     foDest -    The destination 
....................     foSource -  the source 
....................   Return: 
....................     None 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The FileObjectCopy function will make an exacy copy of 
....................     a specified FSFILE object. 
....................   Remarks: 
....................     None 
....................   **************************************************************/ 
....................  
.................... void FileObjectCopy(FILEOBJ foDest,FILEOBJ foSource) 
.................... { 
....................     int size; 
....................     BYTE *dest; 
....................     BYTE *source; 
....................     int Index; 
....................  
....................     dest = (BYTE *)foDest; 
....................     source = (BYTE *)foSource; 
....................  
....................     size = sizeof(FSFILE); 
....................  
....................     for(Index=0;Index< size; Index++) 
....................     { 
....................         dest[Index] = source[Index]; 
....................     } 
.................... } 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     CETYPE FILECreateHeadCluster( FILEOBJ fo, DWORD *cluster) 
....................   Summary: 
....................     Create the first cluster of a file 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fo -       Pointer to file structure 
....................     cluster -  Cluster location 
....................   Return Values: 
....................     CE_GOOD - File closed successfully 
....................     CE_WRITE_ERROR - Could not write to the sector 
....................     CE_DISK_FULL - All clusters in partition are taken 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The FILECreateHeadCluster function will create the first cluster 
....................     of a file.  First, it will find an empty cluster with the 
....................     FATfindEmptyCluster function and mark it as the last cluster in the 
....................     file.  It will then erase the cluster using the EraseCluster function. 
....................   Remarks: 
....................     None. 
....................   *************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... CETYPE FILECreateHeadCluster( FILEOBJ fo, DWORD *cluster) 
.................... { 
....................     DISK *      disk; 
....................     CETYPE        error = CE_GOOD; 
....................  
....................     disk = fo->dsk; 
....................  
....................     // find the next empty cluster 
....................     *cluster = FATfindEmptyCluster(fo); 
....................  
....................     if(*cluster == 0)  // "0" is just an indication as Disk full in the fn "FATfindEmptyCluster()" 
....................     { 
....................         error = CE_DISK_FULL; 
....................     } 
....................     else 
....................     { 
....................         // mark the cluster as taken, and last in chain 
....................        #ifdef SUPPORT_FAT12 
....................         if(disk->type == FAT12) 
....................         { 
....................             if(WriteFAT( disk, *cluster, LAST_CLUSTER_FAT12, FALSE) == CLUSTER_FAIL_FAT16) 
....................             { 
....................                 error = CE_WRITE_ERROR; 
....................             } 
....................         } 
....................         else 
....................        #endif 
....................         if(disk->type == FAT16) 
....................         { 
....................             if(WriteFAT( disk, *cluster, LAST_CLUSTER_FAT16, FALSE) == CLUSTER_FAIL_FAT16) 
....................             { 
....................                 error = CE_WRITE_ERROR; 
....................             } 
....................         } 
....................  
....................  #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         else 
....................         { 
....................             if(WriteFAT( disk, *cluster, LAST_CLUSTER_FAT32, FALSE) == CLUSTER_FAIL_FAT32) 
....................             { 
....................                 error = CE_WRITE_ERROR; 
....................             } 
....................         } 
.................... #endif 
....................  
....................         // lets erase this cluster 
....................         if(error == CE_GOOD) 
....................         { 
....................             error = EraseCluster(disk,*cluster); 
....................         } 
....................     } 
....................  
....................     return(error); 
.................... } // allocate head cluster 
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE EraseCluster(DISK *disk, DWORD cluster) 
....................   Summary: 
....................     Erase a cluster 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -      Disk structure 
....................     cluster -  Cluster to be erased 
....................   Return Values: 
....................     CE_GOOD - File closed successfully 
....................     CE_WRITE_ERROR - Could not write to the sector 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The EraseCluster function will write a 0 value into every byte of 
....................     the specified cluster. 
....................   Remarks: 
....................     None. 
....................   *************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE EraseCluster(DISK *disk, DWORD cluster) 
.................... { 
....................     BYTE index; 
....................     DWORD SectorAddress; 
....................     BYTE error = CE_GOOD; 
....................  
....................     SectorAddress = Cluster2Sector(disk,cluster); 
....................     if (gNeedDataWrite) 
....................         if (flushData()) 
....................             return CE_WRITE_ERROR; 
....................  
....................     gBufferOwner = NULL; 
....................  
....................     if (gBufferZeroed == FALSE) 
....................     { 
....................         // clear out the memory first 
....................         memset(disk->buffer, 0x00, disk->sectorSize); 
....................         gBufferZeroed = TRUE; 
....................     } 
....................  
....................     // Now clear them out 
....................     for(index = 0; (index < disk->SecPerClus) && (error == CE_GOOD); index++) 
....................     { 
....................         if (MDD_SectorWrite( SectorAddress++, disk->buffer, FALSE) != TRUE) 
....................             error = CE_WRITE_ERROR; 
....................     } 
....................  
....................     return(error); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined (__C30__) || defined (__PIC32MX__) 
....................  
.................... /*************************************************** 
....................   Function: 
....................     BYTE ReadByte(BYTE * pBuffer, WORD index) 
....................   Summary: 
....................     Read a byte from a buffer 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     pBuffer -  pointer to a buffer to read from 
....................     index -    index in the buffer to read to 
....................   Return: 
....................     BYTE - the byte read 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     Reads a byte from a buffer 
....................   Remarks: 
....................     None. 
....................   ***************************************************/ 
....................  
.................... BYTE ReadByte( BYTE* pBuffer, WORD index ) 
.................... { 
....................     return( pBuffer[index] ); 
.................... } 
....................  
....................  
.................... /*************************************************** 
....................   Function: 
....................     BYTE ReadWord(BYTE * pBuffer, WORD index) 
....................   Summary: 
....................     Read a 16-bit word from a buffer 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     pBuffer -  pointer to a buffer to read from 
....................     index -    index in the buffer to read to 
....................   Return: 
....................     WORD - the word read 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     Reads a 16-bit word from a buffer 
....................   Remarks: 
....................     None. 
....................   ***************************************************/ 
....................  
.................... WORD ReadWord( BYTE* pBuffer, WORD index ) 
.................... { 
....................     BYTE loByte, hiByte; 
....................     WORD res; 
....................  
....................     loByte = pBuffer[index]; 
....................     hiByte = pBuffer[index+1]; 
....................     res = hiByte; 
....................     res *= 0x100; 
....................     res |= loByte; 
....................     return( res ); 
.................... } 
....................  
....................  
.................... /**************************************************** 
....................   Function: 
....................     BYTE ReadDWord(BYTE * pBuffer, WORD index) 
....................   Summary: 
....................     Read a 32-bit double word from a buffer 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     pBuffer -  pointer to a buffer to read from 
....................     index -    index in the buffer to read to 
....................   Return: 
....................     DWORD - the double word read 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     Reads a 32-bit double word from a buffer 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... DWORD ReadDWord( BYTE* pBuffer, WORD index ) 
.................... { 
....................     WORD loWord, hiWord; 
....................     DWORD result; 
....................  
....................     loWord = ReadWord( pBuffer, index ); 
....................     hiWord = ReadWord( pBuffer, index+2 ); 
....................  
....................     result = hiWord; 
....................     result *= 0x10000; 
....................     result |= loWord; 
....................     return result; 
.................... } 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /**************************************************** 
....................   Function: 
....................     DWORD Cluster2Sector(DISK * dsk, DWORD cluster) 
....................   Summary: 
....................     Convert a cluster number to the corresponding sector 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     disk -     Disk structure 
....................     cluster -  Cluster to be converted 
....................   Return: 
....................     sector - Sector that corresponds to given cluster 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The Cluster2Sector function will calculate the 
....................     sector number that corresponds to the first sector 
....................     of the cluster whose value was passed into the 
....................     function. 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... DWORD Cluster2Sector(DISK * dsk, DWORD cluster) 
.................... { 
....................     DWORD sector; 
....................  
....................     /* Rt: Settings based on FAT type */ 
....................     switch (dsk->type) 
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             /* In FAT32, there is no separate ROOT region. It is as well stored in DATA region */ 
....................             sector = (((DWORD)cluster-2) * dsk->SecPerClus) + dsk->data; 
....................             break; 
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             // The root dir takes up cluster 0 and 1 
....................             if((cluster == 0) || (cluster == 1)) 
....................                 sector = dsk->root + cluster; 
....................             else 
....................                 sector = (((DWORD)cluster-2) * dsk->SecPerClus) + dsk->data; 
....................             break; 
....................     } 
....................  
....................     return(sector); 
....................  
.................... } 
....................  
....................  
.................... /*************************************************************************** 
....................   Function: 
....................     int FSattrib (FSFILE * file, unsigned char attributes) 
....................   Summary: 
....................     Change the attributes of a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     file -        Pointer to file structure 
....................     attributes -  The attributes to set for the file 
....................                -  Attribute -      Value - Indications 
....................                -  ATTR_READ_ONLY - 0x01  - The read-only attribute 
....................                -  ATTR_HIDDEN -    0x02  - The hidden attribute 
....................                -  ATTR_SYSTEM -    0x04  - The system attribute 
....................                -  ATTR_ARCHIVE -   0x20  - The archive attribute 
....................   Return Values: 
....................     0 -  Attribute change was successful 
....................     -1 - Attribute change was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSattrib funciton will set the attributes of the specified file 
....................     to the attributes passed in by the user.  This function will load the 
....................     file entry, replace the attributes with the ones specified, and write 
....................     the attributes back.  If the specified file is a directory, the 
....................     directory attribute will be preserved. 
....................   Remarks: 
....................     None 
....................   ***************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... int FSattrib (FSFILE * file, unsigned char attributes) 
.................... { 
....................     WORD fHandle; 
....................     DIRENTRY dir; 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................     // Check for valid attributes 
....................     if ((attributes & ~0x27) != 0) 
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
....................         return -1; 
....................     } 
....................  
....................     fHandle = file->entry; 
....................  
....................     file->dirccls = file->dirclus; 
....................  
....................     // Get the file entry 
....................     dir = LoadDirAttrib(file, &fHandle); 
....................  
....................     if (dir == NULL) 
....................     { 
....................         FSerrno = CE_BADCACHEREAD; 
....................         return -1; 
....................     } 
....................  
....................     // Ensure that we aren't trying to change the 
....................     // attributes of a volume entry 
....................     if (dir->DIR_Attr & ATTR_VOLUME) 
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
....................         return -1; 
....................     } 
....................  
....................     // Don't remove the directory attribute from DIR files 
....................     if (file->attributes & ATTR_DIRECTORY) 
....................         file->attributes = attributes | ATTR_DIRECTORY; 
....................     else 
....................         file->attributes = attributes; 
....................  
....................     // just write the last entry in 
....................     if(!Write_File_Entry(file,&fHandle)) 
....................     { 
....................         FSerrno = CE_WRITE_ERROR; 
....................         return -1; 
....................     } 
....................  
....................     return 0; 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Write data to a file 
....................   Conditions: 
....................     File opened in FS_WRITE, FS_APPEND, FS_WRITE+, FS_APPEND+, FS_READ+ mode 
....................   Input: 
....................     data_to_write -     Pointer to source buffer 
....................     size -              Size of units in bytes 
....................     n -                 Number of units to transfer 
....................     stream -  Pointer to file structure 
....................   Return: 
....................     size_t - number of units written 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfwrite function will write data to a file.  First, the sector that 
....................     corresponds to the current position in the file will be loaded (if it hasn't 
....................     already been cached in the global data buffer).  Data will then be written to 
....................     the device from the specified buffer until the specified amount has been written. 
....................     If the end of a cluster is reached, the next cluster will be loaded, unless 
....................     the end-of-file flag for the specified file has been set.  If it has, a new 
....................     cluster will be allocated to the file.  Finally, the new position and filesize 
....................     will be stored in the FSFILE object.  The parameters 'size' and 'n' indicate how 
....................     much data to write.  'Size' refers to the size of one object to write (in bytes), 
....................     and 'n' will refer to the number of these objects to write.  The value returned 
....................     will be equal  to 'n' unless an error occured. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream) 
.................... { 
....................     DWORD       count = size * n; 
....................     BYTE   *    src = (BYTE *) data_to_write; 
....................     DISK   *    dsk;                 // pointer to disk structure 
....................     CETYPE      error = CE_GOOD; 
....................     WORD        pos; 
....................     DWORD       l;                     // absolute lba of sector to load 
....................     DWORD       seek, filesize; 
....................     WORD        writeCount = 0; 
....................  
....................     // see if the file was opened in a write mode 
....................     if(!(stream->flags.write)) 
....................     { 
....................         FSerrno = CE_READONLY; 
....................         error = CE_WRITE_ERROR; 
....................         return 0; 
....................     } 
....................  
....................     if (count == 0) 
....................         return 0; 
....................  
....................     if (MDD_WriteProtectState()) 
....................     { 
....................         FSerrno = CE_WRITE_PROTECTED; 
....................         error = CE_WRITE_PROTECTED; 
....................         return 0; 
....................     } 
....................  
....................     gBufferZeroed = FALSE; 
....................     dsk = stream->dsk; 
....................     // get the stated position 
....................     pos = stream->pos; 
....................     seek = stream->seek; 
....................     l = Cluster2Sector(dsk,stream->ccls); 
....................     l += (WORD)stream->sec;      // add the sector number to it 
....................  
....................     // Check if the current stream was the last one to use the 
....................     // buffer. If not, check if we need to write data from the 
....................     // old stream 
....................     if (gBufferOwner != stream) 
....................     { 
....................         if (gNeedDataWrite) 
....................         { 
....................             if (flushData()) 
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
....................                 return 0; 
....................             } 
....................         } 
....................         gBufferOwner = stream; 
....................     } 
....................     if (gLastDataSectorRead != l) 
....................     { 
....................         if (gNeedDataWrite) 
....................         { 
....................             if (flushData()) 
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
....................                 return 0; 
....................             } 
....................         } 
....................  
....................         gBufferZeroed = FALSE; 
....................         if(!MDD_SectorRead( l, dsk->buffer) ) 
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
....................             error = CE_BAD_SECTOR_READ; 
....................         } 
....................         gLastDataSectorRead = l; 
....................     } 
....................     // exit loop if EOF reached 
....................     filesize = stream->size; 
....................  
....................     // Loop while writing bytes 
....................     while ((error == CE_GOOD) && (count > 0)) 
....................     { 
....................         if( seek == filesize ) 
....................             stream->flags.FileWriteEOF = TRUE; 
....................  
....................         // load a new sector if necessary, multiples of sector 
....................         if (pos == dsk->sectorSize) 
....................         { 
....................             BYTE needRead = TRUE; 
....................  
....................             if (gNeedDataWrite) 
....................                 if (flushData()) 
....................                 { 
....................                     FSerrno = CE_WRITE_ERROR; 
....................                     return 0; 
....................                 } 
....................  
....................             // reset position 
....................             pos = 0; 
....................  
....................             // point to the next sector 
....................             stream->sec++; 
....................  
....................             // get a new cluster if necessary 
....................             if (stream->sec == dsk->SecPerClus) 
....................             { 
....................                 stream->sec = 0; 
....................  
....................                 if(stream->flags.FileWriteEOF) 
....................                 { 
....................                     error = FILEallocate_new_cluster(stream, 0);    // add new cluster to the file 
....................                     needRead = FALSE; 
....................                 } 
....................                 else 
....................                     error = FILEget_next_cluster( stream, 1); 
....................             } 
....................  
....................             if (error == CE_DISK_FULL) 
....................             { 
....................                 FSerrno = CE_DISK_FULL; 
....................                 return 0; 
....................             } 
....................  
....................             if(error == CE_GOOD) 
....................             { 
....................                 l = Cluster2Sector(dsk,stream->ccls); 
....................                 l += (WORD)stream->sec;      // add the sector number to it 
....................                 gBufferOwner = stream; 
....................                 // If we just allocated a new cluster, then the cluster will 
....................                 // contain garbage data, so it doesn't matter what we write to it 
....................                 // Whatever is in the buffer will work fine 
....................                 if (needRead) 
....................                 { 
....................                     if( !MDD_SectorRead( l, dsk->buffer) ) 
....................                     { 
....................                         FSerrno = CE_BADCACHEREAD; 
....................                         error = CE_BAD_SECTOR_READ; 
....................                         gLastDataSectorRead = 0xFFFFFFFF; 
....................                         return 0; 
....................                     } 
....................                     else 
....................                     { 
....................                         gLastDataSectorRead = l; 
....................                     } 
....................                 } 
....................                 else 
....................                     gLastDataSectorRead = l; 
....................             } 
....................         } //  load new sector 
....................  
....................         if(error == CE_GOOD) 
....................         { 
....................             // Write one byte at a time 
....................             RAMwrite(dsk->buffer, pos++, *(char *)src); 
....................             src = src + 1; // compiler bug 
....................             seek++; 
....................             count--; 
....................             writeCount++; 
....................             // now increment the size of the part 
....................             if(stream->flags.FileWriteEOF) 
....................                 filesize++; 
....................             gNeedDataWrite = TRUE; 
....................         } 
....................     } // while count 
....................  
....................     // save off the positon 
....................     stream->pos = pos; 
....................  
....................     // save off the seek 
....................     stream->seek = seek; 
....................  
....................     // now the new size 
....................     stream->size = filesize; 
....................  
....................     return(writeCount / size); 
.................... } // fwrite 
.................... #endif 
....................  
....................  
.................... /********************************************************** 
....................   Function: 
....................     BYTE flushData (void) 
....................   Summary: 
....................     Flush unwritten data to a file 
....................   Conditions: 
....................     File opened in a write mode, data needs to be written 
....................   Return Values: 
....................     CE_GOOD -        Data was updated successfully 
....................     CE_WRITE_ERROR - Data could not be updated 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The flushData function is called when it is necessary to 
....................     read new data into the global data buffer and the 
....................     gNeedDataWrite variable indicates that there is data 
....................     in the buffer that hasn't been written to the device. 
....................     The flushData function will write the data from the 
....................     buffer into the current cluster of the FSFILE object 
....................     that is stored in the gBufferOwner global variable. 
....................   Remarks: 
....................     None 
....................   **********************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... BYTE flushData (void) 
.................... { 
....................     DWORD l; 
....................     DISK * dsk; 
....................  
....................     // This will either be the pointer to the last file, or the handle 
....................     FILEOBJ stream = gBufferOwner; 
....................  
....................     dsk = stream->dsk; 
....................  
....................     // figure out the lba 
....................     l = Cluster2Sector(dsk,stream->ccls); 
....................     l += (WORD)stream->sec;      // add the sector number to it 
....................  
....................     if(!MDD_SectorWrite( l, dsk->buffer, FALSE)) 
....................     { 
....................         return CE_WRITE_ERROR; 
....................     } 
....................  
....................     gNeedDataWrite = FALSE; 
....................  
....................     return CE_GOOD; 
.................... } 
.................... #endif 
....................  
.................... /**************************************************** 
....................   Function: 
....................     int FSfeof( FSFILE * stream ) 
....................   Summary: 
....................     Indicate whether the current file position is at the end 
....................   Conditions: 
....................     File is open in a read mode 
....................   Input: 
....................     stream -  Pointer to the target file 
....................   Return Values: 
....................     Non-Zero - EOF reached 
....................     0 - Not at end of File 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfeof function will indicate that the end-of- 
....................     file has been reached for the specified file by 
....................     comparing the absolute location in the file to the 
....................     size of the file. 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... int FSfeof( FSFILE * stream ) 
.................... { 
....................     FSerrno = CE_GOOD; 
....................     return( stream->seek == stream->size ); 
.................... } 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Read data from a file 
....................   Conditions: 
....................     File is opened in a read mode 
....................   Input: 
....................     ptr -     Destination buffer for read bytes 
....................     size -    Size of units in bytes 
....................     n -       Number of units to be read 
....................     stream -  File to be read from 
....................   Return: 
....................     size_t - number of units read 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfread function will read data from the specified file.  First, 
....................     the appropriate sector of the file is loaded.  Then, data is read into 
....................     the specified buffer until the specified number of bytes have been read. 
....................     When a cluster boundary is reached, a new cluster will be loaded.  The 
....................     parameters 'size' and 'n' indicate how much data to read.  'Size' 
....................     refers to the size of one object to read (in bytes), and 'n' will refer 
....................     to the number of these objects to read.  The value returned will be equal 
....................     to 'n' unless an error occured or the user tried to read beyond the end 
....................     of the file. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... size_t FSfread (void *ptr, size_t size, size_t n, FSFILE *stream) 
.................... { 
....................     DWORD   len = size * n; 
....................     BYTE    *pointer = (BYTE *) ptr; 
....................     DISK    *dsk;               // Disk structure 
....................     DWORD    seek, sec_sel; 
....................     WORD    pos;       //position within sector 
....................     CETYPE   error = CE_GOOD; 
....................     WORD    readCount = 0; 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................     dsk    = (DISK *)stream->dsk; 
....................     pos    = stream->pos; 
....................     seek    = stream->seek; 
....................  
....................     if( !stream->flags.read ) 
....................     { 
....................         FSerrno = CE_WRITEONLY; 
....................         return 0;   // CE_WRITEONLY 
....................     } 
....................  
.................... #ifdef ALLOW_WRITES 
....................     if (gNeedDataWrite) 
....................         if (flushData() != CE_GOOD) 
....................         { 
....................             FSerrno = CE_WRITE_ERROR; 
....................             return 0; 
....................         } 
.................... #endif 
....................  
....................     // if it not my buffer, then get it from the disk. 
....................     if( (gBufferOwner != stream) && (pos != dsk->sectorSize)) 
....................     { 
....................         gBufferOwner = stream; 
....................         sec_sel = Cluster2Sector(dsk,stream->ccls); 
....................         sec_sel += (WORD)stream->sec;      // add the sector number to it 
....................  
....................         gBufferZeroed = FALSE; 
....................         if( !MDD_SectorRead( sec_sel, dsk->buffer) ) 
....................         { 
....................             FSerrno = CE_BAD_SECTOR_READ; 
....................             error = CE_BAD_SECTOR_READ; 
....................             return 0; 
....................         } 
....................         gLastDataSectorRead = sec_sel; 
....................     } 
....................  
....................     //loop reading (count) bytes 
....................     while( len ) 
....................     { 
....................         if( seek == stream->size ) 
....................         { 
....................             FSerrno = CE_EOF; 
....................             error = CE_EOF; 
....................             break; 
....................         } 
....................  
....................         // In fopen, pos is init to 0 and the sect is loaded 
....................         if( pos == dsk->sectorSize ) 
....................         { 
....................             // reset position 
....................             pos = 0; 
....................             // point to the next sector 
....................             stream->sec++; 
....................  
....................             // get a new cluster if necessary 
....................             if( stream->sec == dsk->SecPerClus ) 
....................             { 
....................                 stream->sec = 0; 
....................                 if( (error = FILEget_next_cluster( stream, 1)) != CE_GOOD ) 
....................                 { 
....................                     FSerrno = CE_COULD_NOT_GET_CLUSTER; 
....................                     break; 
....................                 } 
....................             } 
....................  
....................             sec_sel = Cluster2Sector(dsk,stream->ccls); 
....................             sec_sel += (WORD)stream->sec;      // add the sector number to it 
....................  
....................  
....................             gBufferOwner = stream; 
....................             gBufferZeroed = FALSE; 
....................             if( !MDD_SectorRead( sec_sel, dsk->buffer) ) 
....................             { 
....................                 FSerrno = CE_BAD_SECTOR_READ; 
....................                 error = CE_BAD_SECTOR_READ; 
....................                 break; 
....................             } 
....................             gLastDataSectorRead = sec_sel; 
....................         } 
....................  
....................         // copy one byte at a time 
....................         *pointer = RAMread( dsk->buffer, pos++ ); 
....................         pointer++; 
....................         seek++; 
....................         readCount++; 
....................         len--; 
....................     } 
....................  
....................     // save off the positon 
....................     stream->pos = pos; 
....................     // save off the seek 
....................     stream->seek = seek; 
....................  
....................     return(readCount / size); 
.................... } // fread 
....................  
....................  
.................... /*************************************************************************** 
....................   Function: 
....................     BYTE FormatFileName( const char* fileName, FILEOBJ fptr, BYTE mode ) 
....................   Summary: 
....................     Format a file name into dir entry format 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fileName -  The name to be formatted 
....................     fN2 -       The location the formatted name will be stored 
....................     mode -      Non-zero if parital string search chars are allowed 
....................   Return Values: 
....................     TRUE - Name formatted successfully 
....................     FALSE - File name could not be formatted 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     Format an 8.3 filename into FSFILE structure format. If filename is less 
....................     than 8 chars, then it will be padded with spaces. If the extension name is 
....................     fewer than 3 chars, then it will also be oadded with spaces. The 
....................     ValidateChars function is used to ensure the characters in the specified 
....................     filename are valid in this filesystem. 
....................   Remarks: 
....................     None. 
....................   ***************************************************************************/ 
.................... BYTE FormatFileName( const char* fileName, FILEOBJ fptr, BYTE mode) 
.................... { 
....................    char *fN2; 
....................    FILE_DIR_NAME_TYPE fileNameType; 
....................     int temp,count1,count2,count3,count4; 
....................     BOOL supportLFN = FALSE; 
....................    char *localFileName = NULL; 
....................  
....................    // go with static allocation 
....................    #if defined(SUPPORT_LFN) 
....................       unsigned short int tempString[256]; 
....................       BOOL   AscciIndication = TRUE; 
....................       count1 = 256; 
....................    #else 
....................       unsigned short int   tempString[13]; 
....................       count1 = 12; 
....................    #endif 
....................  
....................    // Check whether the length of the file name is valid 
....................    // for LFN support as well as Non LFN support 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................    { 
....................       utf16Filename = (unsigned short int *)fileName; 
....................       fileNameLength = 0; 
....................       while(utf16Filename[fileNameLength]) 
....................       { 
....................          fileNameLength++; 
....................       } 
....................  
....................       if((fileNameLength > count1) || (*utf16Filename == '.') || 
....................          (*utf16Filename == 0)) 
....................       { 
....................          return FALSE; 
....................       } 
....................  
....................       for (count1 = 0;count1 < fileNameLength; count1++) 
....................       { 
....................          tempString[count1] = utf16Filename[count1]; 
....................       } 
....................  
....................       utf16Filename = tempString; 
....................    } 
....................    else 
....................    #endif 
....................    { 
....................       fileNameLength = strlen(fileName); 
....................  
....................       if((fileNameLength > count1) || (*fileName == '.') || (*fileName == 0)) 
....................       { 
....................          return FALSE; 
....................       } 
....................  
....................       asciiFilename = (char *)tempString; 
....................       for (count1 = 0;count1 < fileNameLength; count1++) 
....................       { 
....................          asciiFilename[count1] = fileName[count1]; 
....................       } 
....................    } 
....................     
....................  
....................        #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" FormatFileName len="); 
....................          PrintRAMBytesUART(((unsigned char*)&fileNameLength), 1); 
....................          PrintROMASCIIStringUART(" FormatFileName asciiFilename="); 
....................          PrintRAMBytesUART(((unsigned char*)asciiFilename), 13);          
....................          PrintROMASCIIStringUART(" FormatFileName fileName="); 
....................          PrintRAMBytesUART(((unsigned char*)fileName), 13);          
....................         #endif 
....................  
....................     // Make sure the characters are valid 
....................       fileNameType = ValidateChars(mode); 
....................  
....................     // If the file name doesn't follow 8P3 or LFN format, then return FALSE 
....................     if(NAME_ERROR == fileNameType) 
....................    { 
....................       return FALSE; 
....................    } 
....................  
....................    temp = fileNameLength; 
....................  
....................    #if defined(SUPPORT_LFN) 
....................       fptr->AsciiEncodingType = TRUE; 
....................       fptr->utf16LFNlength = 0; 
....................    #endif 
....................  
....................    // If LFN is supported and the file name is UTF16 type or Ascii mixed type, 
....................    // go for LFN support rather than trying to adjust in 8P3 format 
....................    if(NAME_8P3_ASCII_MIXED_TYPE == fileNameType) 
....................    { 
....................       #if defined(SUPPORT_LFN) 
....................          supportLFN = TRUE; 
....................       #endif 
....................    } 
....................  
....................    #if defined(SUPPORT_LFN) 
....................    if(NAME_8P3_UTF16_TYPE == fileNameType) 
....................    { 
....................       for (count3 = 0; count3 < temp; count3++) 
....................       { 
....................          if(utf16Filename[count3] > 0xFF) 
....................          { 
....................             fileNameType = NAME_8P3_UTF16_NONASCII_TYPE; 
....................             supportLFN = TRUE; 
....................             break; 
....................          } 
....................       } 
....................  
....................       if(count3 == temp) 
....................       { 
....................          fileNameType = NAME_8P3_UTF16_ASCII_CAPS_TYPE; 
....................  
....................          for (count3 = 0; count3 < temp; count3++) 
....................          { 
....................             if((utf16Filename[count3] >= 0x61) && (utf16Filename[count3] <= 0x7A)) 
....................             { 
....................                fileNameType = NAME_8P3_UTF16_ASCII_MIXED_TYPE; 
....................                supportLFN = TRUE; 
....................                break; 
....................             } 
....................          } 
....................       } 
....................    } 
....................    #endif 
....................  
....................    // If the file name follows 8P3 type 
....................    if((NAME_LFN_TYPE != fileNameType) && (FALSE == supportLFN)) 
....................    { 
....................       for (count3 = 0; count3 < temp; count3++) 
....................       { 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................          { 
....................             if(((utf16Filename[count3] == '.') && ((temp - count3) > 4)) || 
....................                (count3 > 8)) 
....................             { 
....................                // UTF File name extension greater then 3 characters or 
....................                 // UTF File name greater then 8 charcters 
....................                supportLFN = TRUE; 
....................                break; 
....................             } 
....................             else if(utf16Filename[count3] == '.') 
....................             { 
....................                break; 
....................             } 
....................          } 
....................          else 
....................          #endif 
....................          { 
....................             if(((asciiFilename[count3] == '.') && ((temp - count3) > 4)) || 
....................                (count3 > 8)) 
....................             { 
....................                // File extension greater then 3 characters or 
....................                // File name greater then 8 charcters 
....................                #if !defined(SUPPORT_LFN) 
....................                   return FALSE; 
....................                #endif 
....................                supportLFN = TRUE; 
....................                break; 
....................             } 
....................             else if(asciiFilename[count3] == '.') 
....................             { 
....................                break; 
....................             } 
....................          } 
....................       } 
....................  
....................       // If LFN not supported try to adjust in 8P3 format 
....................       if(FALSE == supportLFN) 
....................       { 
....................           // point fN2 to short file name 
....................           fN2 = fptr -> name; 
....................  
....................           // Load destination filename to be space intially. 
....................           for (count1 = 0; count1 < FILE_NAME_SIZE_8P3; count1++) 
....................           { 
....................               *(fN2 + count1) = ' '; 
....................           } 
....................  
....................          // multiply the length by 2 as each UTF word has 2 byte 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................          { 
....................             count4 = count3 * 2; 
....................             temp = temp * 2; 
....................             localFileName = (char *)utf16Filename; 
....................          } 
....................          else 
....................          #endif 
....................          { 
....................             count4 = count3; 
....................             localFileName = asciiFilename; 
....................          } 
....................  
....................           //copy only file name ( not the extension part ) 
....................           for (count1 = 0,count2 = 0; (count2 < 8) && (count1 < count4);count1++ ) 
....................           { 
....................             if(localFileName[count1]) 
....................             { 
....................                fN2[count2] = localFileName[count1]; // Destination filename initially filled with SPACE. Now copy only available chars. 
....................  
....................                 // Convert lower-case to upper-case 
....................                 if ((fN2[count2] >= 0x61) && (fN2[count2] <= 0x7A)) 
....................                 { 
....................                     fN2[count2] -= 0x20; 
....................                } 
....................                count2++; 
....................             } 
....................           } 
....................  
....................          if(count4 < temp) 
....................          { 
....................             // Discard the '.' part 
....................             count4++; 
....................  
....................               // Copy the extn to 8th position onwards. Ex: "FILE    .Tx " 
....................               for (count3 = 8; (count3 < 11) && (count4 < temp);count4++ ) 
....................               { 
....................                if(localFileName[count4]) 
....................                { 
....................                      fN2[count3] = localFileName[count4]; 
....................  
....................                       // Convert lower-case to upper-case 
....................                       if ((fN2[count3] >= 0x61) && (fN2[count3] <= 0x7A)) 
....................                       { 
....................                           fN2[count3] -= 0x20; 
....................                   } 
....................                   count3++; 
....................                } 
....................               } 
....................          } 
....................       } 
....................    } 
....................  
....................    // If the file name follows LFN format 
....................     if((NAME_LFN_TYPE == fileNameType) || (TRUE == supportLFN)) 
....................    { 
....................       #if defined(SUPPORT_LFN) 
....................  
....................          // point fN2 to long file name 
....................          fN2 = (char *)(fptr -> utf16LFNptr); 
....................  
....................          if(!utfModeFileName) 
....................          { 
....................             localFileName = asciiFilename; 
....................          } 
....................  
....................          // Copy the LFN name in the adress specified by FSFILE pointer 
....................          count2 = 0; 
....................          for(count1 = 0;count1 < temp;count1++) 
....................          { 
....................             if(utfModeFileName) 
....................             { 
....................                fptr -> utf16LFNptr[count1] = utf16Filename[count1]; 
....................                if(AscciIndication) 
....................                { 
....................                   if(utf16Filename[count1] > 0xFF) 
....................                   { 
....................                      fptr->AsciiEncodingType = FALSE; 
....................                      AscciIndication = FALSE; 
....................                   } 
....................                } 
....................             } 
....................             else 
....................             { 
....................                fN2[count2++] = localFileName[count1]; 
....................                fN2[count2++] = (BYTE)0x00; 
....................             } 
....................          } 
....................          fptr -> utf16LFNptr[count1] = 0x0000; 
....................  
....................          fptr->utf16LFNlength = fileNameLength; 
....................       #else 
....................          return FALSE; 
....................       #endif 
....................    } 
....................  
....................    // Free the temporary heap used for intermediate execution 
....................    return TRUE; 
.................... } 
....................  
.................... #ifdef ALLOW_DIRS 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE FormatDirName (char * string,FILEOBJ fptr, BYTE mode) 
....................   Summary: 
....................     Format a dir name into dir entry format 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     string -  The name to be formatted 
....................     mode - 
....................          - TRUE -  Partial string search characters are allowed 
....................          - FALSE - Partial string search characters are forbidden 
....................   Return Values: 
....................     TRUE - The name was formatted correctly 
....................     FALSE - The name contained invalid characters 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     Format an 8.3 filename into directory structure format. If the name is less 
....................     than 8 chars, then it will be padded with spaces. If the extension name is 
....................     fewer than 3 chars, then it will also be oadded with spaces. The 
....................     ValidateChars function is used to ensure the characters in the specified 
....................     directory name are valid in this filesystem. 
....................   Remarks: 
....................     None. 
....................   *************************************************************************/ 
....................  
.................... BYTE FormatDirName (char * string,FILEOBJ fptr, BYTE mode) 
.................... { 
....................     char tempString [12]; 
....................    FILE_DIR_NAME_TYPE fileNameType; 
....................     int temp,count1,count2; 
....................     BOOL supportLFN = FALSE; 
....................    char *localFileName; 
....................  
....................    // go with static allocation 
....................    #if defined(SUPPORT_LFN) 
....................        int count3,count4; 
....................       BOOL   AscciIndication = TRUE; 
....................       count1 = 256; 
....................    #else 
....................       count1 = 12; 
....................    #endif 
....................  
....................    // Calculate the String length 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................    { 
....................       utf16Filename = (unsigned short int *)string; 
....................       fileNameLength = 0; 
....................       while(utf16Filename[fileNameLength]) 
....................       { 
....................          fileNameLength++; 
....................       } 
....................    } 
....................    else 
....................    #endif 
....................    { 
....................       asciiFilename = string; 
....................       fileNameLength = strlen(string); 
....................    } 
....................  
....................    if(fileNameLength > count1) 
....................    { 
....................       return FALSE; 
....................    } 
....................  
....................     // Make sure the characters are valid 
....................     fileNameType = ValidateChars(mode); 
....................  
....................     // If the file name doesn't follow 8P3 or LFN format, then return FALSE 
....................     if(NAME_ERROR == fileNameType) 
....................    { 
....................       return FALSE; 
....................    } 
....................  
....................    temp = fileNameLength; 
....................  
....................    #if defined(SUPPORT_LFN) 
....................       fptr->AsciiEncodingType = TRUE; 
....................       fptr->utf16LFNlength = 0; 
....................    #endif 
....................  
....................    // If LFN is supported and the file name is UTF16 type or Ascii mixed type, 
....................    // go for LFN support rather than trying to adjust in 8P3 format 
....................    if(NAME_8P3_ASCII_MIXED_TYPE == fileNameType) 
....................    { 
....................       #if defined(SUPPORT_LFN) 
....................          supportLFN = TRUE; 
....................       #endif 
....................    } 
....................  
....................    #if defined(SUPPORT_LFN) 
....................    if(NAME_8P3_UTF16_TYPE == fileNameType) 
....................    { 
....................       for (count3 = 0; count3 < temp; count3++) 
....................       { 
....................          if(utf16Filename[count3] > 0xFF) 
....................          { 
....................             fileNameType = NAME_8P3_UTF16_NONASCII_TYPE; 
....................             supportLFN = TRUE; 
....................             break; 
....................          } 
....................       } 
....................  
....................       if(count3 == temp) 
....................       { 
....................          fileNameType = NAME_8P3_UTF16_ASCII_CAPS_TYPE; 
....................  
....................          for (count3 = 0; count3 < temp; count3++) 
....................          { 
....................             if((utf16Filename[count3] >= 0x61) && (utf16Filename[count3] <= 0x7A)) 
....................             { 
....................                fileNameType = NAME_8P3_UTF16_ASCII_MIXED_TYPE; 
....................                supportLFN = TRUE; 
....................                break; 
....................             } 
....................          } 
....................       } 
....................    } 
....................    #endif 
....................  
....................    // If the file name follows LFN format 
....................     if((NAME_LFN_TYPE == fileNameType) || (TRUE == supportLFN)) 
....................    { 
....................       #if !defined(SUPPORT_LFN) 
....................            return FALSE; 
....................       #else 
....................          fptr -> utf16LFNptr = (unsigned short int *)string; 
....................  
....................          if(utfModeFileName) 
....................          { 
....................             if(utf16Filename != (unsigned short int *)string) 
....................             { 
....................                // Copy the validated/Fomated name in the UTF16 string 
....................                for(count1 = 0; count1 < temp; count1++) 
....................                { 
....................                   fptr -> utf16LFNptr[count1] = utf16Filename[count1]; 
....................                   if(AscciIndication) 
....................                   { 
....................                      if(utf16Filename[count1] > 0xFF) 
....................                      { 
....................                         fptr->AsciiEncodingType = FALSE; 
....................                         AscciIndication = FALSE; 
....................                      } 
....................                   } 
....................                } 
....................                fptr -> utf16LFNptr[count1] = 0x0000; 
....................             } 
....................             else 
....................             { 
....................                for(count1 = 0; count1 < temp; count1++) 
....................                { 
....................                   if(AscciIndication) 
....................                   { 
....................                      if(utf16Filename[count1] > 0xFF) 
....................                      { 
....................                         fptr->AsciiEncodingType = FALSE; 
....................                         AscciIndication = FALSE; 
....................                         break; 
....................                      } 
....................                   } 
....................                } 
....................             } 
....................          } 
....................          else 
....................          { 
....................             #ifdef FS_DYNAMIC_MEM 
....................                 unsigned short int *tempAsciiLFN = (unsigned short int *)FS_malloc((temp + 1) * 2); 
....................             #else 
....................                unsigned short int   tempAsciiLFN[temp + 1]; 
....................             #endif 
....................  
....................             localFileName = (char *)tempAsciiLFN; 
....................  
....................             // Copy the validated/Fomated name in the Ascii string 
....................             count2 = 0; 
....................  
....................             for(count1 = 0; count1 < temp; count1++) 
....................             { 
....................                localFileName[count2++] = asciiFilename[count1]; 
....................  
....................                localFileName[count2++] = (BYTE)0x00; 
....................  
....................             } 
....................  
....................             // Copy the validated/Fomated name in the UTF16 string 
....................             for(count1 = 0; count1 < temp; count1++) 
....................             { 
....................                fptr -> utf16LFNptr[count1] = tempAsciiLFN[count1]; 
....................             } 
....................  
....................             #ifdef FS_DYNAMIC_MEM 
....................                 FS_free((unsigned char *)tempAsciiLFN); 
....................             #endif 
....................             fptr -> utf16LFNptr[count1] = 0x0000; 
....................          } 
....................  
....................          fptr->utf16LFNlength = fileNameLength; 
....................       #endif 
....................    } 
....................    else 
....................    { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................       { 
....................          localFileName = (char *)utf16Filename; 
....................  
....................          // Copy the name part in the temporary string 
....................           count4 = 0; 
....................           for (count3 = 0; (count3 < temp) && (utf16Filename[count3] != '.') && (utf16Filename[count3] != 0); count3++) 
....................           { 
....................             count1 = count3 * 2; 
....................             if(localFileName[count1]) 
....................             { 
....................                  tempString[count4] = localFileName[count1]; 
....................                count4++; 
....................                if(count4 == 8) 
....................                   break; 
....................             } 
....................  
....................             if(localFileName[count1 + 1]) 
....................             { 
....................                  tempString[count4] = localFileName[count1 + 1]; 
....................                count4++; 
....................                if(count4 == 8) 
....................                   break; 
....................             } 
....................           } 
....................  
....................          // File the remaining name portion with spaces 
....................           while (count4 < 8) 
....................           { 
....................               tempString [count4++] = 0x20; 
....................           } 
....................  
....................          // Copy the extension part in the temporary string 
....................           if (utf16Filename[count3] == '.') 
....................           { 
....................             count1 = count3 * 2 + 2; 
....................               while (localFileName[count1] != 0) 
....................               { 
....................                if(localFileName[count3]) 
....................                { 
....................                     tempString[count4] = localFileName[count3]; 
....................                   count4++; 
....................                   if(count4 == 11) 
....................                      break; 
....................                } 
....................               } 
....................           } 
....................  
....................          count1 = count4; 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................          // Copy the name part in the temporary string 
....................           for (count1 = 0; (count1 < 8) && (*(asciiFilename + count1) != '.') && (*(asciiFilename + count1) != 0); count1++) 
....................           { 
....................               tempString[count1] = *(asciiFilename + count1); 
....................           } 
....................  
....................          count2 = count1; 
....................  
....................          // File the remaining name portion with spaces 
....................           while (count1 < 8) 
....................           { 
....................               tempString [count1++] = 0x20; 
....................           } 
....................  
....................          // Copy the extension part in the temporary string 
....................           if (*(asciiFilename + count2) == '.') 
....................           { 
....................               count2++; 
....................               while ((*(asciiFilename + count2) != 0) && (count1 < FILE_NAME_SIZE_8P3)) 
....................               { 
....................                   tempString[count1++] = *(asciiFilename + count2++); 
....................               } 
....................           } 
....................       } 
....................  
....................       // File the remaining portion with spaces 
....................       while (count1 < FILE_NAME_SIZE_8P3) 
....................       { 
....................           tempString[count1++] = 0x20; 
....................       } 
....................  
....................       // Forbidden 
....................       if (tempString[0] == 0x20) 
....................       { 
....................           tempString[0] = '_'; 
....................       } 
....................  
....................       // point fN2 to short file name 
....................       localFileName = fptr -> name; 
....................  
....................       // Copy the formated name in string 
....................       for (count1 = 0; count1 < FILE_NAME_SIZE_8P3; count1++) 
....................       { 
....................           localFileName[count1] = tempString[count1]; 
....................  
....................          // Convert lower-case to upper-case 
....................          if ((tempString[count1] >= 0x61) && (tempString[count1] <= 0x7A)) 
....................          { 
....................              localFileName[count1] -= 0x20; 
....................          } 
....................       } 
....................    } 
....................  
....................    return TRUE; 
.................... } 
.................... #endif 
....................  
....................  
.................... /************************************************************* 
....................   Function: 
....................     FILE_DIR_NAME_TYPE ValidateChars(BYTE mode) 
....................   Summary: 
....................     Validate the characters in a given file name 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     fileName -  The name to be validated 
....................     mode -      Determines if partial string search is allowed 
....................   Return Values: 
....................     TRUE - Name was validated 
....................     FALSE - File name was not valid 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The ValidateChars function will compare characters in a 
....................     specified filename to determine if they're permissable 
....................     in the FAT file system.  Lower-case characters will be 
....................     converted to upper-case.  If the mode argument is specifed 
....................     to be 'TRUE,' partial string search characters are allowed. 
....................   Remarks: 
....................     None. 
....................   *************************************************************/ 
.................... FILE_DIR_NAME_TYPE ValidateChars(BYTE mode) 
.................... { 
....................    FILE_DIR_NAME_TYPE fileNameType; 
....................     unsigned short int count1; 
....................    #if defined(SUPPORT_LFN) 
....................    unsigned short int utf16Value; 
....................     unsigned short int count2; 
....................    int      count3; 
....................    #endif 
....................     unsigned char radix = FALSE,asciiValue; 
....................  
....................    #if defined(SUPPORT_LFN) 
....................  
....................       // Remove the spaces if they are present before the file name 
....................       for (count1 = 0; count1 < fileNameLength; count1++) 
....................       { 
....................            if(utfModeFileName) 
....................          { 
....................             if((utf16Filename[count1] != ' ') && (utf16Filename[count1] != '.')) 
....................             { 
....................                utf16Filename = utf16Filename + count1; 
....................                break; 
....................             } 
....................          } 
....................          else if((asciiFilename[count1] != ' ') && (asciiFilename[count1] != '.')) 
....................          { 
....................             asciiFilename = asciiFilename + count1; 
....................             break; 
....................           } 
....................        } 
....................  
....................        count2 = 0; 
....................  
....................       // Remove the spaces  & dots if they are present after the file name 
....................        for (count3 = fileNameLength - count1 - 1; count3 > 0; count3--) 
....................        { 
....................            if(utfModeFileName) 
....................          { 
....................             if((utf16Filename[count3] != ' ') && (utf16Filename[count3] != '.')) 
....................             { 
....................                break; 
....................             } 
....................          } 
....................          else if((asciiFilename[count3] != ' ') && (asciiFilename[count3] != '.')) 
....................          { 
....................             break; 
....................           } 
....................  
....................           count2++; 
....................        } 
....................  
....................       fileNameLength = fileNameLength - count1 - count2; 
....................  
....................        if(( fileNameLength > MAX_FILE_NAME_LENGTH_LFN ) || (fileNameLength == 0))// 255 
....................            return NAME_ERROR; //long file name 
....................  
....................     #endif 
....................  
....................     // If the string length is greater then 8P3 length, then assume 
....................    // the file name as LFN type provided there are no errors in the 
....................    // below for loop. 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................    { 
....................       if((fileNameLength * 2) > (TOTAL_FILE_SIZE_8P3 * 2)) 
....................       { 
....................          fileNameType = NAME_LFN_TYPE; 
....................       } 
....................       else 
....................       { 
....................          fileNameType = NAME_8P3_UTF16_TYPE; 
....................       } 
....................    } 
....................    else 
....................    #endif 
....................    { 
....................       if(fileNameLength > TOTAL_FILE_SIZE_8P3) 
....................       { 
....................          fileNameType = NAME_LFN_TYPE; 
....................       } 
....................       else 
....................       { 
....................          fileNameType = NAME_8P3_ASCII_CAPS_TYPE; 
....................       } 
....................    } 
....................  
....................    for( count1 = 0; count1 < fileNameLength; count1++ ) 
....................    { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................       { 
....................          utf16Value = utf16Filename[count1]; 
....................           // Characters not valid for either of 8P3 & LFN format 
....................           if (((utf16Value < 0x20) && (utf16Value != 0x05)) || (utf16Value == 0x22) || 
....................             (utf16Value == 0x2F) || (utf16Value == 0x3A) || (utf16Value == 0x3C) || 
....................               (utf16Value == 0x3E) || (utf16Value == 0x5C) || (utf16Value == 0x7C)) 
....................           { 
....................               return NAME_ERROR; 
....................           } 
....................  
....................            // Check for partial string search chars 
....................            if (mode == FALSE) 
....................            { 
....................                if ((utf16Value == '*') || (utf16Value == '?')) 
....................                { 
....................                  return NAME_ERROR; 
....................               } 
....................            } 
....................  
....................          if(fileNameType != NAME_LFN_TYPE) 
....................          { 
....................             // Characters valid for LFN format only 
....................              if ((utf16Value == 0x20) || (utf16Value == 0x2B) || (utf16Value == 0x2C) || 
....................                (utf16Value == 0x3B) || (utf16Value == 0x3D) || (utf16Value == 0x5B) || 
....................                (utf16Value == 0x5D) || ((utf16Value == 0x2E) && (radix == TRUE))) 
....................              { 
....................                fileNameType = NAME_LFN_TYPE; 
....................                continue; 
....................              } 
....................  
....................               // only one radix ('.') character is allowed in 8P3 format, where as 
....................             // multiple radices can be present in LFN format 
....................               if (utf16Filename[count1] == 0x2E) 
....................               { 
....................                   radix = TRUE; 
....................               } 
....................          } 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................          asciiValue = asciiFilename[count1]; 
....................          if(((asciiValue < 0x20) && (asciiValue != 0x05)) || (asciiValue == 0x22) || 
....................             (asciiValue == 0x2F) || (asciiValue == 0x3A) || (asciiValue == 0x3C) || 
....................             (asciiValue == 0x3E) || (asciiValue == 0x5C) || (asciiValue == 0x7C)) 
....................          { 
....................             return NAME_ERROR; 
....................          } 
....................  
....................            // Check for partial string search chars 
....................            if (mode == FALSE) 
....................            { 
....................                if ((asciiValue == '*') || (asciiValue == '?')) 
....................                { 
....................                  return NAME_ERROR; 
....................               } 
....................            } 
....................  
....................          if(fileNameType != NAME_LFN_TYPE) 
....................          { 
....................             // Characters valid for LFN format only 
....................              if ((asciiValue == 0x20) || (asciiValue == 0x2B) || (asciiValue == 0x2C) || 
....................                 (asciiValue == 0x3B) || (asciiValue == 0x3D) || (asciiValue == 0x5B) || 
....................                  (asciiValue == 0x5D) || ((asciiValue == 0x2E) && (radix == TRUE))) 
....................              { 
....................                fileNameType = NAME_LFN_TYPE; 
....................                continue; 
....................              } 
....................  
....................               // only one radix ('.') character is allowed in 8P3 format, where as 
....................             // multiple radices can be present in LFN format 
....................               if (asciiValue == 0x2E) 
....................               { 
....................                   radix = TRUE; 
....................               } 
....................  
....................             // If the characters are mixed type & are within 8P3 length range 
....................             // then store file type as 8P3 mixed type format 
....................             if(fileNameType != NAME_8P3_ASCII_MIXED_TYPE) 
....................             { 
....................                if((asciiValue >= 0x61) && (asciiValue <= 0x7A)) 
....................                { 
....................                   fileNameType = NAME_8P3_ASCII_MIXED_TYPE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................    } 
....................  
....................    return fileNameType; 
.................... } 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FSfseek(FSFILE *stream, long offset, int whence) 
....................   Summary: 
....................     Change the current position in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     stream -    Pointer to file structure 
....................     offset -    Offset from base location 
....................     whence - 
....................            - SEEK_SET -  Seek from start of file 
....................            - SEEK_CUR -  Seek from current location 
....................            - SEEK_END -  Seek from end of file (subtract offset) 
....................   Return Values: 
....................     0 -  Operation successful 
....................     -1 - Operation unsuccesful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfseek function will change the current position in the file to 
....................     one specified by the user.  First, an absolute offset is calculated 
....................     using the offset and base location passed in by the user.  Then, the 
....................     position variables are updated, and the sector number that corresponds 
....................     to the new location.  That sector is then loaded.  If the offset 
....................     falls exactly on a cluster boundary, a new cluster will be allocated 
....................     to the file and the position will be set to the first byte of that 
....................     cluster. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int FSfseek(FSFILE *stream, long offset, int whence) 
.................... { 
....................     DWORD    numsector, temp;   // lba of first sector of first cluster 
....................     DISK*   dsk;            // pointer to disk structure 
....................     BYTE   test; 
....................     long offset2 = offset; 
....................  
....................     dsk = stream->dsk; 
....................  
....................     switch(whence) 
....................     { 
....................         case SEEK_CUR: 
....................             // Apply the offset to the current position 
....................             offset2 += stream->seek; 
....................             break; 
....................         case SEEK_END: 
....................             // Apply the offset to the end of the file 
....................             offset2 = stream->size - offset2; 
....................             break; 
....................         case SEEK_SET: 
....................             // automatically there 
....................         default: 
....................             break; 
....................    } 
....................  
.................... #ifdef ALLOW_WRITES 
....................     if (gNeedDataWrite) 
....................         if (flushData()) 
....................         { 
....................             FSerrno = CE_WRITE_ERROR; 
....................             return EOF; 
....................         } 
.................... #endif 
....................  
....................     // start from the beginning 
....................     temp = stream->cluster; 
....................     stream->ccls = temp; 
....................  
....................     temp = stream->size; 
....................  
....................     if (offset2 > temp) 
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
....................         return (-1);      // past the limits 
....................     } 
....................     else 
....................     { 
....................         // if we are writing we are no longer at the end 
....................         stream->flags.FileWriteEOF = FALSE; 
....................  
....................         // set the new postion 
....................         stream->seek = offset2; 
....................  
....................         // figure out how many sectors 
....................         numsector = offset2 / dsk->sectorSize; 
....................  
....................         // figure out how many bytes off of the offset 
....................         offset2 = offset2 - (numsector * dsk->sectorSize); 
....................         stream->pos = offset2; 
....................  
....................         // figure out how many clusters 
....................         temp = numsector / dsk->SecPerClus; 
....................  
....................         // figure out the stranded sectors 
....................         numsector = numsector - (dsk->SecPerClus * temp); 
....................         stream->sec = numsector; 
....................  
....................         // if we are in the current cluster stay there 
....................         if (temp > 0) 
....................         { 
....................             test = FILEget_next_cluster(stream, temp); 
....................             if (test != CE_GOOD) 
....................             { 
....................                 if (test == CE_FAT_EOF) 
....................                 { 
.................... #ifdef ALLOW_WRITES 
....................                     if (stream->flags.write) 
....................                     { 
....................                         // load the previous cluster 
....................                         stream->ccls = stream->cluster; 
....................                         // Don't perform this operation if there's only one cluster 
....................                         if (temp != 1) 
....................                         test = FILEget_next_cluster(stream, temp - 1); 
....................                         if (FILEallocate_new_cluster(stream, 0) != CE_GOOD) 
....................                         { 
....................                             FSerrno = CE_COULD_NOT_GET_CLUSTER; 
....................                             return -1; 
....................                         } 
....................                         // sec and pos should already be zero 
....................                     } 
....................                     else 
....................                     { 
.................... #endif 
....................                         stream->ccls = stream->cluster; 
....................                         test = FILEget_next_cluster(stream, temp - 1); 
....................                         if (test != CE_GOOD) 
....................                         { 
....................                             FSerrno = CE_COULD_NOT_GET_CLUSTER; 
....................                             return (-1); 
....................                         } 
....................                         stream->pos = dsk->sectorSize; 
....................                         stream->sec = dsk->SecPerClus - 1; 
.................... #ifdef ALLOW_WRITES 
....................                     } 
.................... #endif 
....................                 } 
....................                 else 
....................                 { 
....................                     FSerrno = CE_COULD_NOT_GET_CLUSTER; 
....................                     return (-1);   // past the limits 
....................                 } 
....................             } 
....................         } 
....................  
....................         // Determine the lba of the selected sector and load 
....................         temp = Cluster2Sector(dsk,stream->ccls); 
....................  
....................         // now the extra sectors 
....................         numsector = stream->sec; 
....................         temp += numsector; 
....................  
....................         gBufferOwner = NULL; 
....................         gBufferZeroed = FALSE; 
....................         if( !MDD_SectorRead(temp, dsk->buffer) ) 
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
....................             return (-1);   // Bad read 
....................         } 
....................         gLastDataSectorRead = temp; 
....................     } 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................     return (0); 
.................... } 
....................  
....................  
.................... // FSfopenpgm, FSremovepgm, and FSrenamepgm will only work on PIC18s 
.................... #ifdef __18CXX 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... /***************************************************************** 
....................   Function: 
....................     int FSrenamepgm(const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the file with the ascii ROM string(PIC18) 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file (in ROM) 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -  File renamed successfully 
....................     -1 - File could not be renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the file with the ascii ROM string(PIC18).The Fsrenamepgm 
....................     function will copy the rom fileName specified by the user into a 
....................     RAM array and pass that array into the FSrename function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   *****************************************************************/ 
....................  
.................... int FSrenamepgm (const rom char * fileName, FSFILE * fo) 
.................... { 
....................    #if defined(SUPPORT_LFN) 
....................  
....................       char tempArray[257]; 
....................       unsigned short int count; 
....................    #else 
....................  
....................       char   tempArray[13]; 
....................  
....................        BYTE count; 
....................    #endif 
....................  
....................  
....................     *fileName; 
....................     for(count = 0; count < sizeof(tempArray); count++) 
....................     { 
....................         _asm TBLRDPOSTINC _endasm 
....................         tempArray[count] = TABLAT; 
....................     }//end for(...) 
....................  
....................     return FSrename (tempArray, fo); 
.................... } 
.................... #endif 
....................  
.................... /****************************************************************************** 
....................   Function: 
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode) 
....................   Summary: 
....................     Opens a file on PIC18 Microcontrollers where 'fileName' ROM string is given 
....................     in Ascii format. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to be opened (ROM) 
....................     mode -      The mode the file will be opened in (ROM) 
....................   Return Values: 
....................     FSFILE * - A pointer to the file object 
....................     NULL -     File could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file on PIC18 Microcontrollers where 'fileName' ROM string 
....................     is given in Ascii format.The FSfopenpgm function will copy a PIC18 ROM fileName and 
....................     mode argument into RAM arrays, and then pass those arrays to the FSfopen function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   ******************************************************************************/ 
....................  
.................... FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode) 
.................... { 
....................    #if defined(SUPPORT_LFN) 
....................        char tempArray[257]; 
....................        unsigned short int count = 0; 
....................     #else 
....................        char tempArray[13]; 
....................        BYTE count = 0; 
....................    #endif 
....................     char M[2]; 
....................  
....................     for(;;) 
....................    { 
....................       tempArray[count] = fileName[count]; 
....................       if(tempArray[count]) 
....................          count++; 
....................       else 
....................          break; 
....................    } 
....................  
....................     for (count = 0; count < 2; count++) 
....................     { 
....................         M[count] = *(mode + count); 
....................     } 
....................  
....................     return FSfopen(tempArray, M); 
.................... } 
....................  
.................... /************************************************************* 
....................   Function: 
....................     int FSremovepgm (const rom char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC18 device 
....................   Conditions: 
....................     File not opened; file exists 
....................   Input: 
....................     fileName -  The name of the file to be deleted (ROM) 
....................   Return Values: 
....................     0 -  File was removed successfully 
....................     -1 - File could not be removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC18 device.The FSremovepgm function will copy a 
....................     PIC18 ROM fileName argument into a RAM array, and then pass that array 
....................     to the FSremove function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   *************************************************************/ 
.................... #ifdef ALLOW_WRITES 
.................... int FSremovepgm (const rom char * fileName) 
.................... { 
....................    #ifdef SUPPORT_LFN 
....................       char tempArray[257]; 
....................       unsigned short int count; 
....................    #else 
....................  
....................       char   tempArray[13]; 
....................  
....................        BYTE count; 
....................    #endif 
....................  
....................  
....................     *fileName; 
....................     for(count = 0; count < sizeof(tempArray); count++) 
....................     { 
....................         _asm TBLRDPOSTINC _endasm 
....................         tempArray[count] = TABLAT; 
....................     }//end for(...) 
....................  
....................     return FSremove (tempArray); 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************************** 
....................   Function: 
....................     int FindFirstpgm (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Find a file named with a ROM string on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName -  The name of the file to be found (ROM) 
....................     attr -      The attributes of the file to be found 
....................     rec -       Pointer to a search record to store the file info in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the given parameters was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirstpgm call on passed SearchRec object 
....................     will be lost.The FSerrno variable will be changed. 
....................   Description: 
....................     This function finds a file named with 'fileName' on PIC18. The FindFirstpgm 
....................     function will copy a PIC18 ROM fileName argument into a RAM array, and then 
....................     pass that array to the FindFirst function. 
....................   Remarks: 
....................     Call FindFirstpgm or FindFirst before calling FindNext. 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************************/ 
.................... #ifdef ALLOW_FILESEARCH 
.................... int FindFirstpgm (const rom char * fileName, unsigned int attr, SearchRec * rec) 
.................... { 
....................    #if defined(SUPPORT_LFN) 
....................  
....................       char tempArray[257]; 
....................       unsigned short int count; 
....................    #else 
....................  
....................       char   tempArray[13]; 
....................  
....................        BYTE count; 
....................    #endif 
....................  
....................  
....................     *fileName; 
....................     for(count = 0; count < sizeof(tempArray); count++) 
....................     { 
....................         _asm TBLRDPOSTINC _endasm 
....................         tempArray[count] = TABLAT; 
....................     }//end for 
....................  
....................     return FindFirst (tempArray,attr,rec); 
.................... } 
.................... #endif 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /*********************************************** 
....................   Function: 
....................     DWORD ReadFAT (DISK *dsk, DWORD ccls) 
....................   Summary: 
....................     Read the next entry from the FAT 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -   The disk structure 
....................     ccls -  The current cluster 
....................   Return: 
....................     DWORD - The next cluster in a file chain 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The ReadFAT function will read the FAT and 
....................     determine the next cluster value after the 
....................     cluster specified by 'ccls.' Note that the 
....................     FAT sector that is read is stored in the 
....................     global FAT cache buffer. 
....................   Remarks: 
....................     None. 
....................   ***********************************************/ 
....................  
.................... DWORD ReadFAT (DISK *dsk, DWORD ccls) 
.................... { 
....................     BYTE q; 
....................     DWORD p, l;  // "l" is the sector Address 
....................     DWORD c = 0, d, ClusterFailValue,LastClusterLimit;   // ClusterEntries 
....................  
....................     gBufferZeroed = FALSE; 
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             p = (DWORD)ccls * 4; 
....................             q = 0; // "q" not used for FAT32, only initialized to remove a warning 
....................             ClusterFailValue = CLUSTER_FAIL_FAT32; 
....................             LastClusterLimit = LAST_CLUSTER_FAT32; 
....................             break; 
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
....................             p = (DWORD) ccls *3;  // Mulby1.5 to find cluster pos in FAT 
....................             q = p&1; 
....................             p >>= 1; 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
....................             LastClusterLimit = LAST_CLUSTER_FAT12; 
....................             break; 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             p = (DWORD)ccls *2;     // Mulby 2 to find cluster pos in FAT 
....................             q = 0; // "q" not used for FAT16, only initialized to remove a warning 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
....................             LastClusterLimit = LAST_CLUSTER_FAT16; 
....................             break; 
....................     } 
....................  
....................     l = dsk->fat + (p / dsk->sectorSize);     // 
....................     p &= dsk->sectorSize - 1;                 // Restrict 'p' within the FATbuffer size 
....................  
....................     // Check if the appropriate FAT sector is already loaded 
....................     if (gLastFATSectorRead == l) 
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         if (dsk->type == FAT32) 
....................             c = RAMreadD (gFATBuffer, p); 
....................         else 
.................... #endif 
....................             if(dsk->type == FAT16) 
....................                 c = RAMreadW (gFATBuffer, p); 
.................... #ifdef SUPPORT_FAT12 
....................             else if(dsk->type == FAT12) 
....................             { 
....................                 c = RAMread (gFATBuffer, p); 
....................                 if (q) 
....................                 { 
....................                     c >>= 4; 
....................                 } 
....................                 // Check if the MSB is across the sector boundry 
....................                 p = (p +1) & (dsk->sectorSize-1); 
....................                 if (p == 0) 
....................                 { 
....................                     // Start by writing the sector we just worked on to the card 
....................                     // if we need to 
.................... #ifdef ALLOW_WRITES 
....................                     if (gNeedFATWrite) 
....................                         if(WriteFAT (dsk, 0, 0, TRUE)) 
....................                             return ClusterFailValue; 
.................... #endif 
....................                     if (!MDD_SectorRead (l+1, gFATBuffer)) 
....................                     { 
....................                         gLastFATSectorRead = 0xFFFF; 
....................                         return ClusterFailValue; 
....................                     } 
....................                     else 
....................                     { 
....................                         gLastFATSectorRead = l +1; 
....................                     } 
....................                 } 
....................                 d = RAMread (gFATBuffer, p); 
....................                 if (q) 
....................                 { 
....................                     c += (d <<4); 
....................                 } 
....................                 else 
....................                 { 
....................                     c += ((d & 0x0F)<<8); 
....................                 } 
....................             } 
.................... #endif 
....................         } 
....................         else 
....................         { 
....................             // If there's a currently open FAT sector, 
....................             // write it back before reading into the buffer 
.................... #ifdef ALLOW_WRITES 
....................             if (gNeedFATWrite) 
....................             { 
....................                 if(WriteFAT (dsk, 0, 0, TRUE)) 
....................                     return ClusterFailValue; 
....................             } 
.................... #endif 
....................             if (!MDD_SectorRead (l, gFATBuffer)) 
....................             { 
....................                 gLastFATSectorRead = 0xFFFF;  // Note: It is Sector not Cluster. 
....................                 return ClusterFailValue; 
....................             } 
....................             else 
....................             { 
....................                 gLastFATSectorRead = l; 
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................                 if (dsk->type == FAT32) 
....................                     c = RAMreadD (gFATBuffer, p); 
....................                 else 
.................... #endif 
....................                     if(dsk->type == FAT16) 
....................                         c = RAMreadW (gFATBuffer, p); 
.................... #ifdef SUPPORT_FAT12 
....................                     else if (dsk->type == FAT12) 
....................                     { 
....................                         c = RAMread (gFATBuffer, p); 
....................                         if (q) 
....................                         { 
....................                             c >>= 4; 
....................                         } 
....................                         p = (p +1) & (dsk->sectorSize-1); 
....................                         d = RAMread (gFATBuffer, p); 
....................                         if (q) 
....................                         { 
....................                             c += (d <<4); 
....................                         } 
....................                         else 
....................                         { 
....................                             c += ((d & 0x0F)<<8); 
....................                         } 
....................                     } 
.................... #endif 
....................             } 
....................     } 
....................  
....................     // Normalize it so 0xFFFF is an error 
....................     if (c >= LastClusterLimit) 
....................         c = LastClusterLimit; 
....................  
....................    return c; 
.................... }   // ReadFAT 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Function: 
....................     WORD WriteFAT (DISK *dsk, DWORD ccls, WORD value, BYTE forceWrite) 
....................   Summary: 
....................     Write an entry to the FAT 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     dsk -         The disk structure 
....................     ccls -        The current cluster 
....................     value -       The value to write in 
....................     forceWrite -  Force the function to write the current FAT sector 
....................   Return: 
....................     0 -    The FAT write was successful 
....................     FAIL - The FAT could not be written 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The WriteFAT function writes an entry to the FAT.  If the function 
....................     is called and the 'forceWrite' argument is TRUE, the function will 
....................     write the existing FAT data to the device.  Otherwise, the function 
....................     will replace a single entry in the FAT buffer (indicated by 'ccls') 
....................     with a new value (indicated by 'value.') 
....................   Remarks: 
....................     None. 
....................   ****************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... DWORD WriteFAT (DISK *dsk, DWORD ccls, DWORD value, BYTE forceWrite) 
.................... { 
....................     BYTE i, q, c; 
....................     DWORD p, li, l, ClusterFailValue; 
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................     if ((dsk->type != FAT32) && (dsk->type != FAT16) && (dsk->type != FAT12)) 
....................         return CLUSTER_FAIL_FAT32; 
.................... #else // If FAT32 support not enabled 
....................     if ((dsk->type != FAT16) && (dsk->type != FAT12)) 
....................         return CLUSTER_FAIL_FAT16; 
.................... #endif 
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             ClusterFailValue = CLUSTER_FAIL_FAT32; 
....................             break; 
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             ClusterFailValue = CLUSTER_FAIL_FAT16; 
....................             break; 
....................     } 
....................  
....................     gBufferZeroed = FALSE; 
....................  
....................     // The only purpose for calling this function with forceWrite 
....................     // is to write the current FAT sector to the card 
....................     if (forceWrite) 
....................     { 
....................         for (i = 0, li = gLastFATSectorRead; i < dsk->fatcopy; i++, li += dsk->fatsize) 
....................         { 
....................             if (!MDD_SectorWrite (li, gFATBuffer, FALSE)) 
....................             { 
....................                 return ClusterFailValue; 
....................             } 
....................         } 
....................  
....................         gNeedFATWrite = FALSE; 
....................  
....................         return 0; 
....................     } 
....................  
....................     /* Settings based on FAT type */ 
....................     switch (dsk->type) 
....................     { 
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................         case FAT32: 
....................             p = (DWORD)ccls *4;   // "p" is the position in "gFATBuffer" for corresponding cluster. 
....................             q = 0;      // "q" not used for FAT32, only initialized to remove a warning 
....................             break; 
.................... #endif 
.................... #ifdef SUPPORT_FAT12 
....................         case FAT12: 
....................             p = (DWORD) ccls * 3; // "p" is the position in "gFATBuffer" for corresponding cluster. 
....................             q = p & 1;   // Odd or even? 
....................             p >>= 1; 
....................             break; 
.................... #endif 
....................         case FAT16: 
....................         default: 
....................             p = (DWORD) ccls *2;   // "p" is the position in "gFATBuffer" for corresponding cluster. 
....................             q = 0;      // "q" not used for FAT16, only initialized to remove a warning 
....................             break; 
....................     } 
....................  
....................     l = dsk->fat + (p / dsk->sectorSize);     // 
....................     p &= dsk->sectorSize - 1;                 // Restrict 'p' within the FATbuffer size 
....................  
....................     if (gLastFATSectorRead != l) 
....................     { 
....................         // If we are loading a new sector then write 
....................         // the current one to the card if we need to 
....................         if (gNeedFATWrite) 
....................         { 
....................             for (i = 0, li = gLastFATSectorRead; i < dsk->fatcopy; i++, li += dsk->fatsize) 
....................             { 
....................                 if (!MDD_SectorWrite (li, gFATBuffer, FALSE)) 
....................                 { 
....................                     return ClusterFailValue; 
....................                 } 
....................             } 
....................  
....................             gNeedFATWrite = FALSE; 
....................         } 
....................  
....................         // Load the new sector 
....................         if (!MDD_SectorRead (l, gFATBuffer)) 
....................         { 
....................             gLastFATSectorRead = 0xFFFF; 
....................             return ClusterFailValue; 
....................         } 
....................         else 
....................         { 
....................             gLastFATSectorRead = l; 
....................         } 
....................     } 
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................     if (dsk->type == FAT32)  // Refer page 16 of FAT requirement. 
....................     { 
....................         RAMwrite (gFATBuffer, p,   ((value & 0x000000ff)));         // lsb,1st byte of cluster value 
....................         RAMwrite (gFATBuffer, p+1, ((value & 0x0000ff00) >> 8)); 
....................         RAMwrite (gFATBuffer, p+2, ((value & 0x00ff0000) >> 16)); 
....................         RAMwrite (gFATBuffer, p+3, ((value & 0x0f000000) >> 24));   // the MSB nibble is supposed to be "0" in FAT32. So mask it. 
....................     } 
....................     else 
....................  
.................... #endif 
....................     { 
....................         if (dsk->type == FAT16) 
....................         { 
....................             RAMwrite (gFATBuffer, p, value);            //lsB 
....................             RAMwrite (gFATBuffer, p+1, ((value&0x0000ff00) >> 8));    // msB 
....................         } 
....................        #ifdef SUPPORT_FAT12 
....................         else if (dsk->type == FAT12) 
....................         { 
....................             // Get the current byte from the FAT 
....................             c = RAMread (gFATBuffer, p); 
....................             if (q) 
....................             { 
....................                 c = ((value & 0x0F) << 4) | ( c & 0x0F); 
....................             } 
....................             else 
....................             { 
....................                 c = (value & 0xFF); 
....................             } 
....................             // Write in those bits 
....................             RAMwrite (gFATBuffer, p, c); 
....................  
....................             // FAT12 entries can cross sector boundaries 
....................             // Check if we need to load a new sector 
....................             p = (p +1) & (dsk->sectorSize-1); 
....................             if (p == 0) 
....................             { 
....................                 // call this function to update the FAT on the card 
....................                 if (WriteFAT (dsk, 0,0,TRUE)) 
....................                     return ClusterFailValue; 
....................  
....................                 // Load the next sector 
....................                 if (!MDD_SectorRead (l +1, gFATBuffer)) 
....................                 { 
....................                     gLastFATSectorRead = 0xFFFF; 
....................                     return ClusterFailValue; 
....................                 } 
....................                 else 
....................                 { 
....................                     gLastFATSectorRead = l + 1; 
....................                 } 
....................             } 
....................  
....................             // Get the second byte of the table entry 
....................             c = RAMread (gFATBuffer, p); 
....................             if (q) 
....................             { 
....................                 c = (value >> 4); 
....................             } 
....................             else 
....................             { 
....................                 c = ((value >> 8) & 0x0F) | (c & 0xF0); 
....................             } 
....................             RAMwrite (gFATBuffer, p, c); 
....................         } 
....................        #endif 
....................     } 
....................     gNeedFATWrite = TRUE; 
....................  
....................     return 0; 
.................... } 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_DIRS 
....................  
.................... // This string is used by dir functions to hold dir names temporarily 
.................... #if defined(SUPPORT_LFN) 
....................    char tempDirectoryString [522]; 
.................... #else 
....................    char tempDirectoryString [14]; 
.................... #endif 
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdir (char * path) 
....................   Summary: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC). 
....................     The FSchdir function passes a RAM pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... int FSchdir (char * path) 
.................... { 
....................     return chdirhelper (0, path, NULL); 
.................... } 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int wFSchdir (unsigned short int * path) 
....................   Summary: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC).The FSchdir function passes a RAM 
....................     pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSchdir (unsigned short int * path) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................     result = chdirhelper (0, (char *)path, NULL); 
....................    utfModeFileName = FALSE; 
....................     return result; 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdirpgm (const rom char * path) 
....................   Summary: 
....................     Changes the CWD to the input path on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to (ROM) 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the CWD to the input path on PIC18.The FSchdirpgm function 
....................     passes a PIC18 ROM path pointer to the chdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int FSchdirpgm (const rom char * path) 
.................... { 
....................     return chdirhelper (1, NULL, path); 
.................... } 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int wFSchdirpgm (const rom unsigned short int * path) 
....................   Summary: 
....................     Changed the CWD with a path in ROM on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to (ROM) 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     The FSchdirpgm function passes a PIC18 ROM path pointer to the 
....................     chdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM 
....................   **************************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSchdirpgm (const rom unsigned short int * path) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................     result = chdirhelper (1, NULL, (const char *)path); 
....................    utfModeFileName = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int chdirhelper (BYTE mode, char * ramptr, char * romptr); 
....................     // PIC18 
....................     int chdirhelper (BYTE mode, char * ramptr, const rom char * romptr); 
....................   Summary: 
....................     Helper function for FSchdir 
....................   Conditions: 
....................     None 
....................   Input: 
....................     mode -    Indicates which path pointer to use 
....................     ramptr -  Pointer to the path specified in RAM 
....................     romptr -  Pointer to the path specified in ROM 
....................   Return Values: 
....................     0 -   Directory was changed successfully. 
....................     EOF - Directory could not be changed. 
....................   Side Effects: 
....................     The current working directory will be changed. The FSerrno variable 
....................     will be changed. Any unwritten data in the data buffer will be written 
....................     to the device. 
....................   Description: 
....................     This helper function is used by the FSchdir function. If the path 
....................     argument is specified in ROM for PIC18 this function will be able to 
....................     parse it correctly.  The function will loop through a switch statement 
....................     to process the tokens in the path string.  Dot or dotdot entries are 
....................     handled in the first case statement.  A backslash character is handled 
....................     in the second case statement (note that this case statement will only 
....................     be used if backslash is the first character in the path; backslash 
....................     token delimiters will automatically be skipped after each token in the 
....................     path is processed).  The third case statement will handle actual 
....................     directory name strings. 
....................   Remarks: 
....................     None. 
....................   *************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int chdirhelper (BYTE mode, char * ramptr, const rom char * romptr) 
.................... #else 
.................... int chdirhelper (BYTE mode, char * ramptr, char * romptr) 
.................... #endif 
.................... { 
....................     unsigned short int i,j,k = 0; 
....................     WORD curent = 1; 
....................     DIRENTRY entry; 
....................     char * temppath = ramptr; 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     rom char * temppath2 = romptr; 
....................     rom unsigned short int * utf16path2 = (rom unsigned short int *)romptr; 
.................... #endif 
....................    #ifdef SUPPORT_LFN 
....................       unsigned short int *utf16path = (unsigned short int *)ramptr; 
....................    #endif 
....................  
....................     FSFILE tempCWDobj2; 
....................     FILEOBJ tempCWD = &tempCWDobj2; 
....................  
....................     FileObjectCopy (tempCWD, cwdptr); 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................    // Check the first char of the path 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     if (mode) 
....................    { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................  
....................       { 
....................  
....................          i = *utf16path2; 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................          i = *temppath2; 
....................       } 
....................     } 
....................     else 
.................... #endif 
....................    { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................  
....................       { 
....................  
....................          i = *utf16path; 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................          i = *temppath; 
....................       } 
....................     } 
....................  
....................    // if NULL character return error 
....................     if (i == 0) 
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
....................         return -1; 
....................     } 
....................  
....................     while(1) 
....................     { 
....................         switch (i) 
....................         { 
....................             // First case: dot or dotdot entry 
....................             case '.': 
....................                 // Move past the dot 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 if (mode) 
....................                 { 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................  
....................                { 
....................  
....................                        utf16path2++; 
....................                        i = *utf16path2; 
....................                } 
....................                else 
....................                #endif 
....................                { 
....................                        temppath2++; 
....................                        i = *temppath2; 
....................                } 
....................                 } 
....................                 else 
....................                 { 
.................... #endif 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................  
....................                { 
....................  
....................                        utf16path++; 
....................                        i = *utf16path; 
....................                } 
....................                else 
....................                #endif 
....................                { 
....................                        temppath++; 
....................                        i = *temppath; 
....................                } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 } 
.................... #endif 
....................                 // Check if it's a dotdot entry 
....................                 if (i == '.') 
....................                 { 
....................                     // Increment the path variable 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     if (mode) 
....................                     { 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                           utf16path2++; 
....................                           i = *utf16path2; 
....................                   } 
....................                   else 
....................                   #endif 
....................                   { 
....................                           temppath2++; 
....................                           i = *temppath2; 
....................                   } 
....................                     } 
....................                     else 
....................                     { 
.................... #endif 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                           utf16path++; 
....................                           i = *utf16path; 
....................                   } 
....................                   else 
....................                   #endif 
....................                   { 
....................                           temppath++; 
....................                           i = *temppath; 
....................                   } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     } 
.................... #endif 
....................                     // Check if we're in the root 
....................                     if (tempCWD->dirclus == FatRootDirClusterValue) 
....................                     { 
....................                         // Fails if there's a dotdot chdir from the root 
....................                         FSerrno = CE_INVALID_ARGUMENT; 
....................                         return -1; 
....................                     } 
....................                     else 
....................                     { 
....................                         // Cache the dotdot entry 
....................                         tempCWD->dirccls = tempCWD->dirclus; 
....................                         curent = 1; 
....................                         entry = Cache_File_Entry (tempCWD, &curent, TRUE); 
....................                         if (entry == NULL) 
....................                         { 
....................                             FSerrno = CE_BADCACHEREAD; 
....................                             return -1; 
....................                         } 
....................  
....................                         // Get the cluster 
....................                         tempCWD->dirclus = GetFullClusterNumber(entry); // Get Complete Cluster number. 
....................                         tempCWD->dirccls = tempCWD->dirclus; 
....................  
....................                         // If we changed to root, record the name 
....................                         if (tempCWD->dirclus == VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT) // "0" is the value of Dotdot entry for Root in both FAT types. 
....................                         { 
....................                             j = 0; 
....................                             tempCWD->name[j++] = '\\'; 
.................... //                            if(utfModeFileName) 
.................... //                     { 
.................... //                               tempCWD->name[j++] = 0x00; 
.................... //                     } 
....................                             for (;j < 11;) 
....................                             { 
....................                                 tempCWD->name[j] = 0x20; 
....................                                ++j; 
....................                             } 
....................  
....................                             /* While moving to Root, get the Root cluster value */ 
....................                             tempCWD->dirccls = FatRootDirClusterValue; 
....................                             tempCWD->dirclus = FatRootDirClusterValue; 
....................                         } 
....................                         else 
....................                         { 
....................                             // Otherwise set the name to .. 
....................                             j = 0; 
....................                             tempCWD->name[j++] = '.'; 
.................... //                            if(utfModeFileName) 
.................... //                     { 
.................... //                               tempCWD->name[j++] = 0x00; 
.................... //                               tempCWD->name[j++] = '.'; 
.................... //                               tempCWD->name[j++] = 0x00; 
.................... //                     } 
.................... //                     else 
....................                      { 
....................                                tempCWD->name[j++] = '.'; 
....................                             } 
....................                             for (; j < 11;) 
....................                             { 
....................                                 tempCWD->name[j] = 0x20; 
....................                                ++j; 
....................                             } 
....................                         } 
....................                         // Cache the dot entry 
....................                         curent = 0; 
....................                         if (Cache_File_Entry(tempCWD, &curent, TRUE) == NULL) 
....................                         { 
....................                             FSerrno = CE_BADCACHEREAD; 
....................                             return -1; 
....................                         } 
....................                         // Move past the next backslash, if necessary 
....................                         while (i == '\\') 
....................                         { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                             if (mode) 
....................                             { 
....................                         #ifdef SUPPORT_LFN 
....................                         if(utfModeFileName) 
....................  
....................                         { 
....................  
....................                                 utf16path2++; 
....................                                 i = *utf16path2; 
....................                         } 
....................                         else 
....................                         #endif 
....................                         { 
....................                                 temppath2++; 
....................                                 i = *temppath2; 
....................                         } 
....................                             } 
....................                             else 
....................                             { 
.................... #endif 
....................                         #ifdef SUPPORT_LFN 
....................                         if(utfModeFileName) 
....................  
....................                         { 
....................  
....................                                 utf16path++; 
....................                                 i = *utf16path; 
....................                         } 
....................                         else 
....................                         #endif 
....................                         { 
....................                                 temppath++; 
....................                                 i = *temppath; 
....................                         } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                             } 
.................... #endif 
....................                         } 
....................                         // Copy and return, if we're at the end 
....................                         if (i == 0) 
....................                         { 
....................                             FileObjectCopy (cwdptr, tempCWD); 
....................                             return 0; 
....................                         } 
....................                     } 
....................                 } 
....................                 else 
....................                 { 
....................                     // If we ended with a . entry, 
....................                     // just return what we have 
....................                     if (i == 0) 
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
....................                         return 0; 
....................                     } 
....................                     else 
....................                     { 
....................                         if (i == '\\') 
....................                         { 
....................                             while (i == '\\') 
....................                             { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                                 if (mode) 
....................                                 { 
....................                            #ifdef SUPPORT_LFN 
....................                            if(utfModeFileName) 
....................  
....................                            { 
....................  
....................                                    utf16path2++; 
....................                                    i = *utf16path2; 
....................                            } 
....................                            else 
....................                            #endif 
....................                            { 
....................                                    temppath2++; 
....................                                    i = *temppath2; 
....................                            } 
....................                                 } 
....................                                 else 
....................                                 { 
.................... #endif 
....................                            #ifdef SUPPORT_LFN 
....................                            if(utfModeFileName) 
....................  
....................                            { 
....................  
....................                                    utf16path++; 
....................                                    i = *utf16path; 
....................                            } 
....................                            else 
....................                            #endif 
....................                            { 
....................                                    temppath++; 
....................                                    i = *temppath; 
....................                            } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                                 } 
.................... #endif 
....................                             } 
....................                             if (i == 0) 
....................                             { 
....................                                 FileObjectCopy (cwdptr, tempCWD); 
....................                                 return 0; 
....................                             } 
....................                         } 
....................                         else 
....................                         { 
....................                             // Anything else after a dot doesn't make sense 
....................                             FSerrno = CE_INVALID_ARGUMENT; 
....................                             return -1; 
....................                         } 
....................                     } 
....................                 } 
....................  
....................                 break; 
....................  
....................             // Second case: the first char is the root backslash 
....................             // We will ONLY switch to this case if the first char 
....................             // of the path is a backslash 
....................             case '\\': 
....................             // Increment pointer to second char 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             if (mode) 
....................             { 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................  
....................             { 
....................  
....................                     utf16path2++; 
....................                     i = *utf16path2; 
....................             } 
....................             else 
....................             #endif 
....................             { 
....................                     temppath2++; 
....................                     i = *temppath2; 
....................             } 
....................             } 
....................             else 
....................             { 
.................... #endif 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................  
....................             { 
....................  
....................                     utf16path++; 
....................                     i = *utf16path; 
....................             } 
....................             else 
....................             #endif 
....................             { 
....................                     temppath++; 
....................                     i = *temppath; 
....................             } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             } 
.................... #endif 
....................             // Can't start the path with multiple backslashes 
....................             if (i == '\\') 
....................             { 
....................                 FSerrno = CE_INVALID_ARGUMENT; 
....................                 return -1; 
....................             } 
....................  
....................             if (i == 0) 
....................             { 
....................                 // The user is changing directory to 
....................                 // the root 
....................                 cwdptr->dirclus = FatRootDirClusterValue; 
....................                 cwdptr->dirccls = FatRootDirClusterValue; 
....................                 j = 0; 
....................                 cwdptr->name[j++] = '\\'; 
.................... //                if(utfModeFileName) 
.................... //            { 
.................... //                   cwdptr->name[j++] = 0x00; 
.................... //            } 
....................                 for (; j < 11;) 
....................                 { 
....................                     cwdptr->name[j] = 0x20; 
....................                    ++j; 
....................                 } 
....................                 return 0; 
....................             } 
....................             else 
....................             { 
....................                 // Our first char is the root dir switch 
....................                 tempCWD->dirclus = FatRootDirClusterValue; 
....................                 tempCWD->dirccls = FatRootDirClusterValue; 
....................                 j = 0; 
....................                 tempCWD->name[j++] = '\\'; 
.................... //                if(utfModeFileName) 
.................... //            { 
.................... //                   tempCWD->name[j++] = 0x00; 
.................... //            } 
....................                 for (; j < 11;) 
....................                 { 
....................                     tempCWD->name[j] = 0x20; 
....................                    ++j; 
....................                 } 
....................             } 
....................             break; 
....................  
....................         default: 
....................             // We should be at the beginning of a string of letters/numbers 
....................             j = 0; 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             if (mode) 
....................             { 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................  
....................             { 
....................  
....................                    // Change directories as specified 
....................                k = 512; 
....................  
....................  
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempDirectoryString[j++] = i; 
....................                        tempDirectoryString[j++] = i >> 8; 
....................                        i = *(++utf16path2); 
....................                    } 
....................  
....................                tempDirectoryString[j++] = 0; 
....................             } 
....................  
....................             else 
....................  
....................             #endif 
....................               { 
....................  
....................                #if defined(SUPPORT_LFN) 
....................  
....................                   k = 256; 
....................  
....................                #else 
....................  
....................                   k = 12; 
....................  
....................                #endif 
....................  
....................  
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempDirectoryString[j++] = i; 
....................                        i = *(++temppath2); 
....................                    } 
....................             } 
....................  
....................             } 
....................             else 
....................             { 
.................... #endif 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................  
....................             { 
....................  
....................                    // Change directories as specified 
....................                k = 512; 
....................  
....................  
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempDirectoryString[j++] = i; 
....................                        tempDirectoryString[j++] = i >> 8; 
....................                        i = *(++utf16path); 
....................                    } 
....................  
....................                tempDirectoryString[j++] = 0; 
....................             } 
....................  
....................             else 
....................  
....................             #endif 
....................               { 
....................  
....................                #if defined(SUPPORT_LFN) 
....................  
....................                   k = 256; 
....................  
....................                #else 
....................  
....................                   k = 12; 
....................  
....................                #endif 
....................  
....................  
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempDirectoryString[j++] = i; 
....................                        i = *(++temppath); 
....................                    } 
....................             } 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             } 
.................... #endif 
....................  
....................             tempDirectoryString[j++] = 0; 
....................  
....................             // We got a whole 12 chars 
....................             // There could be more- truncate it 
....................             if (j > k) 
....................             { 
....................                 while ((i != 0) && (i != '\\')) 
....................                 { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     if (mode) 
....................                     { 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                            i = *(++utf16path2); 
....................                        } 
....................                   else 
....................                   #endif 
....................                   { 
....................  
....................                            i = *(++temppath2); 
....................                        } 
....................                     } 
....................                     else 
....................                     { 
.................... #endif 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                            i = *(++utf16path); 
....................                        } 
....................                   else 
....................                   #endif 
....................                   { 
....................  
....................                            i = *(++temppath); 
....................                        } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     } 
.................... #endif 
....................                 } 
....................             } 
....................  
....................             if (FormatDirName (tempDirectoryString, tempCWD,0) == FALSE) 
....................                 return -1; 
....................  
....................             // copy file object over 
....................             FileObjectCopy(&gFileTemp, tempCWD); 
....................  
....................             // See if the directory is there 
....................             if(FILEfind (&gFileTemp, tempCWD, LOOK_FOR_MATCHING_ENTRY, 0) != CE_GOOD) 
....................             { 
....................                 // Couldn't find the DIR 
....................                 FSerrno = CE_DIR_NOT_FOUND; 
....................                 return -1; 
....................             } 
....................             else 
....................             { 
....................                 // Found the file 
....................                 // Check to make sure it's actually a directory 
....................                 if ((gFileTemp.attributes & ATTR_DIRECTORY) == 0 ) 
....................                 { 
....................                     FSerrno = CE_INVALID_ARGUMENT; 
....................                     return -1; 
....................                 } 
....................  
....................                 // Get the new name 
....................             #if defined(SUPPORT_LFN) 
....................                if(!tempCWD->utf16LFNlength) 
....................             #endif 
....................                       for (j = 0; j < 11; j++) 
....................                       { 
....................                           tempCWD->name[j] = gFileTemp.name[j]; 
....................                       } 
....................  
....................                 tempCWD->dirclus = gFileTemp.cluster; 
....................                 tempCWD->dirccls = tempCWD->dirclus; 
....................             } 
....................  
....................             if (i == 0) 
....................             { 
....................                 // If we're at the end of the string, we're done 
....................                 FileObjectCopy (cwdptr, tempCWD); 
....................                 return 0; 
....................             } 
....................             else 
....................             { 
....................                 while (i == '\\') 
....................                 { 
....................                     // If we get to another backslash, increment past it 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     if (mode) 
....................                     { 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                           utf16path2++; 
....................                           i = *utf16path2; 
....................                   } 
....................                   else 
....................                   #endif 
....................                   { 
....................                           temppath2++; 
....................                           i = *temppath2; 
....................                   } 
....................                     } 
....................                     else 
....................                     { 
.................... #endif 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................  
....................                   { 
....................  
....................                           utf16path++; 
....................                           i = *utf16path; 
....................                   } 
....................                   else 
....................                   #endif 
....................                   { 
....................                           temppath++; 
....................                           i = *temppath; 
....................                   } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     } 
.................... #endif 
....................                     if (i == 0) 
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
....................                         return 0; 
....................                     } 
....................                 } 
....................             } 
....................             break; 
....................         } 
....................     } // loop 
.................... } 
....................  
....................  
....................  
.................... // This string is used by FSgetcwd to return the cwd name if the path 
.................... // passed into the function is NULL 
.................... char defaultArray [10]; 
....................  
....................  
.................... /************************************************************** 
....................   Function: 
....................     char * FSgetcwd (char * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in Ascii format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in Ascii format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name 
....................     into the buffer backwards, and insert a backslash character. 
....................     Next, the function will continuously switch to the previous 
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the 
....................     root. 
....................   Remarks: 
....................     None 
....................   **************************************************************/ 
.................... char * FSgetcwd (char * path, int numchars) 
.................... { 
....................     // If path is passed in as null, set up a default 
....................     // array with 10 characters 
....................     unsigned short int totalchars = (path == NULL) ? 10 : numchars; 
....................     char * returnPointer; 
....................     char * bufferEnd; 
....................     FILEOBJ tempCWD = &gFileTemp; 
....................     BYTE bufferOverflow = FALSE; 
....................     signed char j; 
....................     DWORD curclus; 
....................     WORD fHandle, tempindex; 
....................     short int i = 0, index = 0; 
....................     char aChar; 
....................     DIRENTRY entry; 
....................  
....................    #if defined(SUPPORT_LFN) 
....................    WORD prevHandle; 
....................    UINT16_VAL tempShift; 
....................    FSFILE cwdTemp; 
....................    LFN_ENTRY *lfno; 
....................    unsigned short int *tempLFN = (unsigned short int *)&tempDirectoryString[0]; 
....................    #endif 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................     // Set up the return value 
....................     if (path == NULL) 
....................         returnPointer = defaultArray; 
....................     else 
....................     { 
....................         returnPointer = path; 
....................         if (numchars == 0) 
....................         { 
....................             FSerrno = CE_INVALID_ARGUMENT; 
....................             return NULL; 
....................         } 
....................     } 
....................  
....................     bufferEnd = returnPointer + totalchars - 1; 
....................  
....................     FileObjectCopy (tempCWD, cwdptr); 
....................  
....................     if (((tempCWD->name[0] == '.') && (tempCWD->name[1] == '.')) 
....................       #if defined(SUPPORT_LFN) 
....................        || tempCWD->utf16LFNlength 
....................       #endif 
....................       ) 
....................     { 
....................         // We last changed directory into a dotdot entry 
....................         // Save the value of the current directory 
....................         curclus = tempCWD->dirclus; 
....................         // Put this dir's dotdot entry into the dirclus 
....................         // Our cwd absolutely is not the root 
....................         fHandle = 1; 
....................         tempCWD->dirccls = tempCWD->dirclus; 
....................         entry = Cache_File_Entry (tempCWD,&fHandle, TRUE); 
....................         if (entry == NULL) 
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
....................             return NULL; 
....................         } 
....................  
....................        // Get the cluster 
....................        TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number. 
....................  
....................         // For FAT32, if the .. entry is 0, the cluster won't be 0 
.................... #ifdef SUPPORT_FAT32 
....................         if (TempClusterCalc == VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT) 
....................         { 
....................             tempCWD->dirclus = FatRootDirClusterValue; 
....................         } 
....................         else 
.................... #endif 
....................             tempCWD->dirclus = TempClusterCalc; 
....................  
....................         tempCWD->dirccls = tempCWD->dirclus; 
....................  
....................         // Find the direntry for the entry we were just in 
....................         fHandle = 0; 
....................         entry = Cache_File_Entry (tempCWD, &fHandle, TRUE); 
....................         if (entry == NULL) 
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
....................             return NULL; 
....................         } 
....................  
....................         // Get the cluster 
....................         TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number. 
....................  
....................         while ((TempClusterCalc != curclus) || 
....................             ((TempClusterCalc == curclus) && 
....................             (((unsigned char)entry->DIR_Name[0] == 0xE5) || (entry->DIR_Attr == ATTR_VOLUME) || (entry->DIR_Attr == ATTR_LONG_NAME)))) 
....................         { 
....................             fHandle++; 
....................             entry = Cache_File_Entry (tempCWD, &fHandle, FALSE); 
....................             if (entry == NULL) 
....................             { 
....................                 FSerrno = CE_BADCACHEREAD; 
....................                 return NULL; 
....................             } 
....................  
....................             // Get the cluster 
....................             TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number in a loop. 
....................         } 
....................  
....................       #if defined(SUPPORT_LFN) 
....................           FileObjectCopy (&cwdTemp, tempCWD); 
....................          prevHandle = fHandle - 1; 
....................  
....................          lfno = (LFN_ENTRY *)Cache_File_Entry (tempCWD, &prevHandle, FALSE); 
....................  
....................  
....................          while((lfno->LFN_Attribute == ATTR_LONG_NAME) && (lfno->LFN_SequenceNo != DIR_DEL) 
....................  
....................                && (lfno->LFN_SequenceNo != DIR_EMPTY)) 
....................  
....................          { 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[0]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[1]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[2]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[3]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[4]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[5]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[6]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[7]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[8]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[9]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................  
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[0]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[1]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[2]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[3]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[4]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[5]; 
....................  
....................  
....................  
....................             tempLFN[i++] = lfno->LFN_Part3[0]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part3[1]; 
....................  
....................  
....................  
....................             prevHandle = prevHandle - 1; 
....................  
....................             lfno = (LFN_ENTRY *)Cache_File_Entry (tempCWD, &prevHandle, FALSE); 
....................  
....................          } 
....................  
....................          FileObjectCopy (tempCWD, &cwdTemp); 
....................       #endif 
....................  
....................          if(i == 0) 
....................          { 
....................              for (j = 0; j < 11; j++) 
....................               { 
....................                tempCWD->name[j] = entry->DIR_Name[j]; 
....................                cwdptr->name[j] = entry->DIR_Name[j]; 
....................               } 
....................          #if defined(SUPPORT_LFN) 
....................             cwdptr->utf16LFNlength = 0; 
....................  
....................             tempCWD->utf16LFNlength = 0; 
....................  
....................          #endif 
....................          } 
....................  
....................       #if defined(SUPPORT_LFN) 
....................          else 
....................          { 
....................  
....................             tempCWD->utf16LFNlength = i; 
....................  
....................          for(j = 12;j >= 0;j--) 
....................          { 
....................             if((tempLFN[i - j - 1]) == 0x0000) 
....................             { 
....................                tempCWD->utf16LFNlength = i - j - 1; 
....................                break; 
....................             } 
....................          } 
....................          cwdptr->utf16LFNlength = tempCWD->utf16LFNlength; 
....................  
....................             tempCWD->utf16LFNptr = (unsigned short int *)&tempDirectoryString[0]; 
....................  
....................             cwdptr->utf16LFNptr = (unsigned short int *)&tempDirectoryString[0]; 
....................  
....................          } 
....................  
....................       #endif 
....................         // Reset our temp dir back to that cluster 
....................         tempCWD->dirclus = curclus; 
....................         tempCWD->dirccls = curclus; 
....................         // This will set us at the cwd, but it will actually 
....................         // have the name in the name field this time 
....................     } 
....................  
....................     // There's actually some kind of name value in the cwd 
....................    #if defined(SUPPORT_LFN) 
....................     if (((tempCWD->name[0] == '\\') && (tempCWD->utf16LFNlength == 0x0000)) || 
....................       ((tempCWD->utf16LFNlength != 0x0000) && (tempCWD->utf16LFNptr[0] == (unsigned short int)'\\')) || (numchars == 0x02)) 
....................    #else 
....................     if ((tempCWD->name[0] == '\\') || (numchars == 0x02)) 
....................    #endif 
....................     { 
....................         // Easy, our CWD is the root 
....................         *returnPointer = '\\'; 
....................         *(returnPointer + 1) = 0; 
....................         return returnPointer; 
....................     } 
....................     else 
....................     { 
....................         index = 0; 
....................         // Loop until we get back to the root 
....................         while (tempCWD->dirclus != FatRootDirClusterValue) 
....................         { 
....................          #if defined(SUPPORT_LFN) 
....................             if(tempCWD->utf16LFNlength) 
....................             { 
....................              i = tempCWD->utf16LFNlength * 2 - 1; 
....................              while(i >= 0) 
....................             { 
....................                #ifdef SUPPORT_LFN 
....................                if(twoByteMode) 
....................                { 
....................                   returnPointer[index++] = tempDirectoryString[i--]; 
....................                       if (index == totalchars) 
....................                       { 
....................                           index = 0; 
....................                           bufferOverflow = TRUE; 
....................                       } 
....................                } 
....................                else 
....................                #endif 
....................                { 
....................                   if(tempDirectoryString[i]) 
....................                   { 
....................                      returnPointer[index++] = tempDirectoryString[i]; 
....................                               if (index == totalchars) 
....................                               { 
....................                                   index = 0; 
....................                                   bufferOverflow = TRUE; 
....................                               } 
....................  
....................                   } 
....................                   i--; 
....................                } 
....................             } 
....................          } 
....................          else 
....................          #endif 
....................          { 
....................                j = 10; 
....................                while (tempCWD->name[j] == 0x20) 
....................                    j--; 
....................                if (j >= 8) 
....................                { 
....................                    while (j >= 8) 
....................                    { 
....................                        *(returnPointer + index++) = tempCWD->name[j--]; 
....................                        // This is a circular buffer 
....................                        // Any unnecessary values will be overwritten 
....................                        if (index == totalchars) 
....................                        { 
....................                            index = 0; 
....................                            bufferOverflow = TRUE; 
....................                        } 
....................  
....................                   #ifdef SUPPORT_LFN 
....................                   if(twoByteMode) 
....................                   { 
....................                      returnPointer[index++] = 0x00; 
....................                            if (index == totalchars) 
....................                            { 
....................                                index = 0; 
....................                                bufferOverflow = TRUE; 
....................                            } 
....................                   } 
....................                   #endif 
....................                    } 
....................  
....................                    *(returnPointer + index++) = '.'; 
....................                    if (index == totalchars) 
....................                    { 
....................                        index = 0; 
....................                        bufferOverflow = TRUE; 
....................                    } 
....................  
....................                #ifdef SUPPORT_LFN 
....................                if(twoByteMode) 
....................                { 
....................                   returnPointer[index++] = 0x00; 
....................                        if (index == totalchars) 
....................                        { 
....................                            index = 0; 
....................                            bufferOverflow = TRUE; 
....................                        } 
....................                } 
....................                #endif 
....................                } 
....................  
....................                while (tempCWD->name[j] == 0x20) 
....................                    j--; 
....................  
....................                while (j >= 0) 
....................                { 
....................                    *(returnPointer + index++) = tempCWD->name[j--]; 
....................                    // This is a circular buffer 
....................                    // Any unnecessary values will be overwritten 
....................                    if (index == totalchars) 
....................                    { 
....................                        index = 0; 
....................                        bufferOverflow = TRUE; 
....................                    } 
....................  
....................                #ifdef SUPPORT_LFN 
....................                if(twoByteMode) 
....................                { 
....................                   returnPointer[index++] = 0x00; 
....................                        if (index == totalchars) 
....................                        { 
....................                            index = 0; 
....................                            bufferOverflow = TRUE; 
....................                        } 
....................                } 
....................                #endif 
....................                } 
....................          } 
....................  
....................          #ifdef SUPPORT_LFN 
....................          if(twoByteMode) 
....................          { 
....................             returnPointer[index++] = 0x00; 
....................                if (index == totalchars) 
....................                { 
....................                    index = 0; 
....................                    bufferOverflow = TRUE; 
....................                } 
....................          } 
....................          #endif 
....................  
....................             // Put a backslash delimiter in front of the dir name 
....................             *(returnPointer + index++) = '\\'; 
....................             if (index == totalchars) 
....................             { 
....................                 index = 0; 
....................                 bufferOverflow = TRUE; 
....................             } 
....................  
....................             // Load the previous entry 
....................             tempCWD->dirccls = tempCWD->dirclus; 
....................             if (GetPreviousEntry (tempCWD)) 
....................             { 
....................                 FSerrno = CE_BAD_SECTOR_READ; 
....................                 return NULL; 
....................             } 
....................         } 
....................     } 
....................  
....................     // Point the index back at the last char in the string 
....................     index--; 
....................  
....................     i = 0; 
....................     // Swap the chars in the buffer so they are in the right places 
....................     if (bufferOverflow) 
....................     { 
....................         tempindex = index; 
....................         // Swap the overflowed values in the buffer 
....................         while ((index - i) > 0) 
....................         { 
....................              aChar = *(returnPointer + i); 
....................              *(returnPointer + i) = * (returnPointer + index); 
....................              *(returnPointer + index) = aChar; 
....................              index--; 
....................              i++; 
....................         } 
....................  
....................         // Point at the non-overflowed values 
....................         i = tempindex + 1; 
....................         index = bufferEnd - returnPointer; 
....................  
....................         // Swap the non-overflowed values into the right places 
....................         while ((index - i) > 0) 
....................         { 
....................              aChar = *(returnPointer + i); 
....................              *(returnPointer + i) = * (returnPointer + index); 
....................              *(returnPointer + index) = aChar; 
....................              index--; 
....................              i++; 
....................         } 
....................         // All the values should be in the right place now 
....................         // Null-terminate the string 
....................         *(bufferEnd) = 0; 
....................     } 
....................     else 
....................     { 
....................         // There was no overflow, just do one set of swaps 
....................         tempindex = index; 
....................         while ((index - i) > 0) 
....................         { 
....................             aChar = *(returnPointer + i); 
....................             *(returnPointer + i) = * (returnPointer + index); 
....................             *(returnPointer + index) = aChar; 
....................             index--; 
....................             i++; 
....................         } 
....................         *(returnPointer + tempindex + 1) = 0; 
....................     } 
....................  
....................     return returnPointer; 
.................... } 
....................  
.................... #ifdef SUPPORT_LFN 
....................  
.................... /************************************************************** 
....................   Function: 
....................     char * wFSgetcwd (unsigned short int * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in UTF16 format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in UTF16 format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name 
....................     into the buffer backwards, and insert a backslash character. 
....................     Next, the function will continuously switch to the previous 
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the 
....................     root. 
....................   Remarks: 
....................     None 
....................   **************************************************************/ 
.................... char * wFSgetcwd (unsigned short int * path, int numchars) 
.................... { 
....................    char *result; 
....................    twoByteMode = TRUE; 
....................     result = FSgetcwd ((char *)path,numchars); 
....................    twoByteMode = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     void GetPreviousEntry (FSFILE * fo) 
....................   Summary: 
....................     Get the file entry info for the parent dir of the specified dir 
....................   Conditions: 
....................     Should not be called by the user. 
....................   Input: 
....................     fo -  The file to get the previous entry of 
....................   Return Values: 
....................     0 -  The previous entry was successfully retrieved 
....................     -1 - The previous entry could not be retrieved 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The GetPreviousEntry function is used by the FSgetcwd function to 
....................     load the previous (parent) directory.  This function will load the 
....................     parent directory and then search through the file entries in that 
....................     directory for one that matches the cluster number of the original 
....................     directory.  When the matching entry is found, the name of the 
....................     original directory is copied into the 'fo' FSFILE object. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... BYTE GetPreviousEntry (FSFILE * fo) 
.................... { 
....................     int i,j; 
....................     WORD fHandle = 1; 
....................     DWORD dirclus; 
....................     DIRENTRY dirptr; 
....................  
....................    #ifdef SUPPORT_LFN 
....................       unsigned short int *tempLFN = (unsigned short int *)&tempDirectoryString[0]; 
....................       FSFILE cwdTemp; 
....................       LFN_ENTRY *lfno; 
....................  
....................       WORD prevHandle; 
....................       UINT16_VAL tempShift; 
....................  
....................    #endif 
....................  
....................     // Load the previous entry 
....................     dirptr = Cache_File_Entry (fo, &fHandle, TRUE); 
....................     if (dirptr == NULL) 
....................         return -1; 
....................  
....................     // Get the cluster 
....................     TempClusterCalc = GetFullClusterNumber(dirptr); // Get complete cluster number. 
....................  
....................     if (TempClusterCalc == VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT) 
....................     { 
....................         // The previous directory is the root 
....................         fo->name[0] = '\\'; 
....................         for (i = 0; i < 11; i++) 
....................         { 
....................             fo->name[i] = 0x20; 
....................         } 
....................         fo->dirclus = FatRootDirClusterValue; 
....................         fo->dirccls = FatRootDirClusterValue; 
....................     } 
....................     else 
....................     { 
....................         // Get the directory name 
....................         // Save the previous cluster value 
....................        // Get the cluster 
....................  
....................         dirclus = TempClusterCalc; 
....................         fo->dirclus = TempClusterCalc; 
....................         fo->dirccls = TempClusterCalc; 
....................  
....................  
....................         // Load the previous previous cluster 
....................         dirptr = Cache_File_Entry (fo, &fHandle, TRUE); 
....................         if (dirptr == NULL) 
....................             return -1; 
....................  
....................        // Get the cluster 
....................         TempClusterCalc = GetFullClusterNumber(dirptr); // Get complete cluster number. 
.................... #ifdef SUPPORT_FAT32 
....................         // If we're using FAT32 and the previous previous cluster is the root, the 
....................         // value in the dotdot entry will be 0, but the actual cluster won't 
....................         if (TempClusterCalc == VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT) 
....................         { 
....................             fo->dirclus = FatRootDirClusterValue; 
....................         } 
....................         else 
.................... #endif 
....................             fo->dirclus = TempClusterCalc; 
....................  
....................         fo->dirccls = fo->dirclus; 
....................  
....................         fHandle = 0; 
....................         dirptr = Cache_File_Entry (fo, &fHandle, TRUE); 
....................         if (dirptr == NULL) 
....................             return -1; 
....................         // Look through it until we get the name 
....................         // of the previous cluster 
....................         // Get the cluster 
....................         TempClusterCalc = GetFullClusterNumber(dirptr); // Get complete cluster number. 
....................         while ((TempClusterCalc != dirclus) || 
....................             ((TempClusterCalc == dirclus) && 
....................             (((unsigned char)dirptr->DIR_Name[0] == 0xE5) || (dirptr->DIR_Attr == ATTR_VOLUME) || (dirptr->DIR_Attr == ATTR_LONG_NAME)))) 
....................         { 
....................             // Look through the entries until we get the 
....................             // right one 
....................             dirptr = Cache_File_Entry (fo, &fHandle, FALSE); 
....................             if (dirptr == NULL) 
....................                 return -1; 
....................             fHandle++; 
....................  
....................            TempClusterCalc = GetFullClusterNumber(dirptr); // Get complete cluster number in a loop. 
....................         } 
....................  
....................         // The name should be in the entry now 
....................         // Copy the actual directory location back 
....................         fo->dirclus = dirclus; 
....................         fo->dirccls = dirclus; 
....................    } 
....................  
....................       i = 0; 
....................    #ifdef SUPPORT_LFN 
....................           FileObjectCopy (&cwdTemp, fo); 
....................          prevHandle = fHandle - 2; 
....................  
....................          lfno = (LFN_ENTRY *)Cache_File_Entry (fo, &prevHandle, FALSE); 
....................  
....................       // Get the long file name of the short file name(if present) 
....................          while((lfno->LFN_Attribute == ATTR_LONG_NAME) && (lfno->LFN_SequenceNo != DIR_DEL) 
....................  
....................                && (lfno->LFN_SequenceNo != DIR_EMPTY)) 
....................  
....................          { 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[0]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[1]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[2]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[3]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[4]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[5]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[6]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[7]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................             tempShift.byte.LB = lfno->LFN_Part1[8]; 
....................  
....................             tempShift.byte.HB = lfno->LFN_Part1[9]; 
....................  
....................             tempLFN[i++] = tempShift.Val; 
....................  
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[0]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[1]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[2]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[3]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[4]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part2[5]; 
....................  
....................  
....................             tempLFN[i++] = lfno->LFN_Part3[0]; 
....................  
....................             tempLFN[i++] = lfno->LFN_Part3[1]; 
....................  
....................  
....................  
....................             prevHandle = prevHandle - 1; 
....................  
....................             lfno = (LFN_ENTRY *)Cache_File_Entry (fo, &prevHandle, FALSE); 
....................  
....................          } 
....................  
....................  
....................          FileObjectCopy (fo, &cwdTemp); 
....................    #endif 
....................  
....................       if(i == 0) 
....................  
....................    { 
....................           for (j = 0; j < 11; j++) 
....................            fo->name[j] = dirptr->DIR_Name[j]; 
....................       #ifdef SUPPORT_LFN 
....................             fo->utf16LFNlength = 0; 
....................  
....................          #endif 
....................       } 
....................    #ifdef SUPPORT_LFN 
....................       else 
....................  
....................       { 
....................  
....................       fo->utf16LFNlength = i; 
....................  
....................  
....................  
....................       for(j = 12;j >= 0;j--) 
....................  
....................       { 
....................  
....................          if((tempLFN[i - j - 1]) == 0x0000) 
....................  
....................          { 
....................  
....................             fo->utf16LFNlength = i - j - 1; 
....................  
....................             break; 
....................  
....................          } 
....................  
....................       } 
....................  
....................  
....................          fo->utf16LFNptr = (unsigned short int *)&tempDirectoryString[0]; 
....................  
....................       } 
....................  
....................    #endif 
....................  
....................     return 0; 
.................... } 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdir (char * path) 
....................   Summary: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno 
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_WRITES 
.................... int FSmkdir (char * path) 
.................... { 
....................     return mkdirhelper (0, path, NULL); 
.................... } 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int wFSmkdir (unsigned short int * path) 
....................   Summary: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno 
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSmkdir (unsigned short int * path) 
.................... { 
....................    int   result; 
....................    utfModeFileName = TRUE; 
....................     result = mkdirhelper (0, (char *)path, NULL); 
....................    utfModeFileName = FALSE; 
....................     return result; 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdirpgm (const rom char * path) 
....................   Summary: 
....................     Creates a directory as per the path mentioned in the input string on 
....................     PIC18 devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create (ROM) 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno 
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the path mentioned in the input string on 
....................     PIC18 devices.'FSmkdirpgm' creates the directories as per the input 
....................     string path.This function doesn't move the current working 
....................     directory setting. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arugments in ROM 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int FSmkdirpgm (const rom char * path) 
.................... { 
....................     return mkdirhelper (1, NULL, path); 
.................... } 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int wFSmkdirpgm (const rom unsigned short int * path) 
....................   Summary: 
....................     Create a directory with a path in ROM on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create (ROM) 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno 
....................     variable will be changed. 
....................   Description: 
....................     The FSmkdirpgm function passes a PIC18 ROM path pointer to the 
....................     mkdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arugments in ROM 
....................   **************************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSmkdirpgm (const rom unsigned short int * path) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................     result = mkdirhelper (1, NULL, (const char *)path); 
....................    utfModeFileName = FALSE; 
....................     return result; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int mkdirhelper (BYTE mode, char * ramptr, char * romptr) 
....................     // PIC18 
....................     int mkdirhelper (BYTE mode, char * ramptr, const rom char * romptr) 
....................   Summary: 
....................     Helper function for FSmkdir 
....................   Conditions: 
....................     None 
....................   Input: 
....................     mode -   Indicates which path pointer to use 
....................     ramptr - Pointer to the path specified in RAM 
....................     romptr - Pointer to the path specified in ROM 
....................   Return Values: 
....................     0 -  Directory was created 
....................     -1 - Directory could not be created 
....................   Side Effects: 
....................     Will create all non-existant directories in the path. 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This helper function is used by the FSchdir function. If the path 
....................     argument is specified in ROM for PIC18 this function will be able 
....................     to parse it correctly.  This function will first scan through the path 
....................     to ensure that any DIR names don't exceed 11 characters.  It will then 
....................     backup the current working directory and begin changing directories 
....................     through the path until it reaches a directory than can't be changed to. 
....................     It will then create the specified directory and change directories to 
....................     the new directory. The function will continue creating and changing to 
....................     directories until the end of the path is reached.  The function will 
....................     then restore the original current working directory. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int mkdirhelper (BYTE mode, char * ramptr, const rom char * romptr) 
.................... #else 
.................... int mkdirhelper (BYTE mode, char * ramptr, char * romptr) 
.................... #endif 
.................... { 
....................     unsigned short int i,j = 0,k = 0; 
....................     char * temppath = ramptr; 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     rom char * temppath2 = romptr; 
....................     rom unsigned short int * utf16path2 = (rom unsigned short int *)romptr; 
.................... #endif 
....................    unsigned short int *utf16path = (unsigned short int *)ramptr; 
....................     FILEOBJ tempCWD = &tempCWDobj; 
....................  
.................... #ifdef __18CXX 
....................     char dotdotPath[] = ".."; 
....................     char dotdotPath1[5] = {'.','\0','.','\0','\0'}; 
.................... #endif 
....................  
.................... // Do Dynamic allocation if the macro is defined or 
.................... // go with static allocation 
.................... #if defined(SUPPORT_LFN) 
....................    char tempArray[514]; 
.................... #else 
....................    char tempArray[14]; 
.................... #endif 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................     if (MDD_WriteProtectState()) 
....................     { 
....................         FSerrno = CE_WRITE_PROTECTED; 
....................         return (-1); 
....................     } 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     if (mode == 1) 
....................     { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................       { 
....................            // Scan for too-long file names 
....................            while (1) 
....................            { 
....................                i = 0; 
....................                while((*utf16path2 != 0) && (*utf16path2 != '.')&& (*utf16path2 != '\\')) 
....................                { 
....................                    utf16path2++; 
....................                    i++; 
....................                } 
....................  
....................               if (i > 256) 
....................               { 
....................                   FSerrno = CE_INVALID_ARGUMENT; 
....................                   return -1; 
....................               } 
....................  
....................                j = 0; 
....................                if (*utf16path2 == '.') 
....................                { 
....................                    utf16path2++; 
....................                    while ((*utf16path2 != 0) && (*utf16path2 != '\\')) 
....................                    { 
....................                        utf16path2++; 
....................                        j++; 
....................                    } 
....................                  if ((i + j) > 256) 
....................                  { 
....................                      FSerrno = CE_INVALID_ARGUMENT; 
....................                      return -1; 
....................                  } 
....................                } 
....................  
....................             if((i + j) > k) 
....................             { 
....................                k = (i + j); 
....................             } 
....................  
....................                while (*utf16path2 == '\\') 
....................                    utf16path2++; 
....................                if (*utf16path2 == 0) 
....................                    break; 
....................            } 
....................        } 
....................       else 
....................       #endif 
....................       { 
....................            // Scan for too-long file names 
....................            while (1) 
....................            { 
....................                i = 0; 
....................                while((*temppath2 != 0) && (*temppath2 != '.')&& (*temppath2 != '\\')) 
....................                { 
....................                    temppath2++; 
....................                    i++; 
....................                } 
....................  
....................             #if defined(SUPPORT_LFN) 
....................                   if (i > 256) 
....................                   { 
....................                       FSerrno = CE_INVALID_ARGUMENT; 
....................                       return -1; 
....................                   } 
....................             #else 
....................                   if (i > 8) 
....................                   { 
....................                       FSerrno = CE_INVALID_ARGUMENT; 
....................                       return -1; 
....................                   } 
....................             #endif 
....................  
....................                j = 0; 
....................                if (*temppath2 == '.') 
....................                { 
....................                    temppath2++; 
....................                    while ((*temppath2 != 0) && (*temppath2 != '\\')) 
....................                    { 
....................                        temppath2++; 
....................                        j++; 
....................                    } 
....................                #if defined(SUPPORT_LFN) 
....................                      if ((i + j) > 256) 
....................                      { 
....................                          FSerrno = CE_INVALID_ARGUMENT; 
....................                          return -1; 
....................                      } 
....................                #else 
....................                      if (j > 3) 
....................                      { 
....................                          FSerrno = CE_INVALID_ARGUMENT; 
....................                          return -1; 
....................                      } 
....................                #endif 
....................                } 
....................  
....................             if((i + j) > k) 
....................             { 
....................                k = (i + j); 
....................             } 
....................  
....................                while (*temppath2 == '\\') 
....................                    temppath2++; 
....................                if (*temppath2 == 0) 
....................                    break; 
....................            } 
....................        } 
....................     } 
....................     else 
.................... #endif 
....................    { 
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................       { 
....................          utf16path = (unsigned short int *)ramptr; 
....................            // Scan for too-long file names 
....................            while (1) 
....................            { 
....................                i = 0; 
....................                while((*utf16path != 0) && (*utf16path != '.')&& (*utf16path != '\\')) 
....................                { 
....................                    utf16path++; 
....................                    i++; 
....................                } 
....................               if (i > 256) 
....................               { 
....................                   FSerrno = CE_INVALID_ARGUMENT; 
....................                   return -1; 
....................               } 
....................  
....................                j = 0; 
....................                if (*utf16path == '.') 
....................                { 
....................                    utf16path++; 
....................                    while ((*utf16path != 0) && (*utf16path != '\\')) 
....................                    { 
....................                        utf16path++; 
....................                        j++; 
....................                    } 
....................                  if ((i + j) > 256) 
....................                  { 
....................                      FSerrno = CE_INVALID_ARGUMENT; 
....................                      return -1; 
....................                  } 
....................                } 
....................  
....................             if((i + j) > k) 
....................             { 
....................                k = (i + j); 
....................             } 
....................  
....................                while (*utf16path == '\\') 
....................                    utf16path++; 
....................                if (*utf16path == 0) 
....................                    break; 
....................            } 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................            // Scan for too-long file names 
....................            while (1) 
....................            { 
....................                i = 0; 
....................                while((*temppath != 0) && (*temppath != '.')&& (*temppath != '\\')) 
....................                { 
....................                    temppath++; 
....................                    i++; 
....................                } 
....................             #if defined(SUPPORT_LFN) 
....................                   if (i > 256) 
....................                   { 
....................                       FSerrno = CE_INVALID_ARGUMENT; 
....................                       return -1; 
....................                   } 
....................             #else 
....................                   if (i > 8) 
....................                   { 
....................                       FSerrno = CE_INVALID_ARGUMENT; 
....................                       return -1; 
....................                   } 
....................             #endif 
....................  
....................                j = 0; 
....................                if (*temppath == '.') 
....................                { 
....................                    temppath++; 
....................                    while ((*temppath != 0) && (*temppath != '\\')) 
....................                    { 
....................                        temppath++; 
....................                        j++; 
....................                    } 
....................                #if defined(SUPPORT_LFN) 
....................                      if ((i + j) > 256) 
....................                      { 
....................                          FSerrno = CE_INVALID_ARGUMENT; 
....................                          return -1; 
....................                      } 
....................                #else 
....................                      if (j > 3) 
....................                      { 
....................                          FSerrno = CE_INVALID_ARGUMENT; 
....................                          return -1; 
....................                      } 
....................                #endif 
....................                } 
....................  
....................             if((i + j) > k) 
....................             { 
....................                k = (i + j); 
....................             } 
....................  
....................                while (*temppath == '\\') 
....................                    temppath++; 
....................                if (*temppath == 0) 
....................                    break; 
....................            } 
....................       } 
....................    } 
....................  
....................    utf16path = (unsigned short int *)ramptr; 
....................     temppath = ramptr; 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    utf16path2 = (rom unsigned short int *)romptr; 
....................     temppath2 = romptr; 
.................... #endif 
....................  
....................     // We're going to be moving the CWD 
....................     // Back up the CWD 
....................     FileObjectCopy (tempCWD, cwdptr); 
....................  
....................     // get to the target directory 
....................     while (1) 
....................     { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................         if (mode == 1) 
....................         { 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................                i = *utf16path2; 
....................          else 
....................          #endif 
....................                i = *temppath2; 
....................       } 
....................         else 
.................... #endif 
....................       { 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................                i = *utf16path; 
....................          else 
....................          #endif 
....................                i = *temppath; 
....................       } 
....................  
....................         if (i == '.') 
....................         { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             if (mode == 1) 
....................             { 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................             { 
....................                    utf16path2++; 
....................                    i = *utf16path2; 
....................             } 
....................             else 
....................             #endif 
....................                { 
....................                    temppath2++; 
....................                    i = *temppath2; 
....................             } 
....................             } 
....................             else 
....................             { 
.................... #endif 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................             { 
....................                    utf16path++; 
....................                    i = *utf16path; 
....................             } 
....................             else 
....................             #endif 
....................                { 
....................                    temppath++; 
....................                    i = *temppath; 
....................             } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             } 
.................... #endif 
....................  
....................             if ((i != '.') && (i != 0) && (i != '\\')) 
....................             { 
....................                 FSerrno = CE_INVALID_ARGUMENT; 
....................                 return -1; 
....................             } 
....................  
....................             if (i == '.') 
....................             { 
....................                 if (cwdptr->dirclus ==  FatRootDirClusterValue) 
....................                 { 
....................                     // If we try to change to the .. from the 
....................                     // root, operation fails 
....................                     FSerrno = CE_INVALID_ARGUMENT; 
....................                     return -1; 
....................                 } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 if (mode == 1) 
....................                 { 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path2++; 
....................                       i = *utf16path2; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath2++; 
....................                       i = *temppath2; 
....................                } 
....................                 } 
....................                 else 
.................... #endif 
....................                 { 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path++; 
....................                       i = *utf16path; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath++; 
....................                       i = *temppath; 
....................                } 
....................             } 
....................  
....................                 if ((i != '\\') && (i != 0)) 
....................                 { 
....................                     FSerrno = CE_INVALID_ARGUMENT; 
....................                     return -1; 
....................                 } 
.................... // dotdot entry 
.................... #ifndef __18CXX 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................                 FSchdir (".\0.\0\0"); 
....................          #endif 
....................          else 
....................                 FSchdir (".."); 
.................... #else 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................                 FSchdir (dotdotPath1); 
....................          else 
....................          #endif 
....................                 FSchdir (dotdotPath); 
.................... #endif 
....................             } 
....................             // Skip past any backslashes 
....................             while (i == '\\') 
....................             { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 if (mode == 1) 
....................                 { 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path2++; 
....................                       i = *utf16path2; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath2++; 
....................                       i = *temppath2; 
....................                } 
....................                 } 
....................                 else 
....................                 { 
.................... #endif 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path++; 
....................                       i = *utf16path; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath++; 
....................                       i = *temppath; 
....................                } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 } 
.................... #endif 
....................             } 
....................             if (i == 0) 
....................             { 
....................                 // No point in creating a dot or dotdot entry directly 
....................                 FileObjectCopy (cwdptr, tempCWD); 
....................                 FSerrno = CE_INVALID_ARGUMENT; 
....................                 return -1; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if (i == '\\') 
....................             { 
....................                 // Start at the root 
....................                 cwdptr->dirclus = FatRootDirClusterValue; 
....................                 cwdptr->dirccls = FatRootDirClusterValue; 
....................                 i = 0; 
....................                 cwdptr->name[i++] = '\\'; 
.................... //                if(utfModeFileName) 
.................... //            { 
.................... //                   cwdptr->name[i++] = 0x00; 
.................... //            } 
....................                 for (; i < 11; i++) 
....................                 { 
....................                     cwdptr->name[i] = 0x20; 
....................                 } 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 if (mode == 1) 
....................                 { 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path2++; 
....................                       i = *utf16path2; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath2++; 
....................                       i = *temppath2; 
....................                } 
....................                 } 
....................                 else 
....................                 { 
.................... #endif 
....................                #ifdef SUPPORT_LFN 
....................                if(utfModeFileName) 
....................                { 
....................                       utf16path++; 
....................                       i = *utf16path; 
....................                } 
....................                else 
....................                #endif 
....................                   { 
....................                       temppath++; 
....................                       i = *temppath; 
....................                } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                 } 
.................... #endif 
....................                 // If we just got two backslashes in a row at the 
....................                 // beginning of the path, the function fails 
....................                 if ((i == '\\') || (i == 0)) 
....................                 { 
....................                     FileObjectCopy (cwdptr, tempCWD); 
....................                     FSerrno = CE_INVALID_ARGUMENT; 
....................                     return -1; 
....................                 } 
....................             } 
....................             else 
....................             { 
....................                 break; 
....................             } 
....................         } 
....................     } 
....................  
....................     while (1) 
....................     { 
....................         while(1) 
....................         { 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             if (mode == 1) 
....................             { 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................             { 
....................                    // Change directories as specified 
....................                    i = *utf16path2; 
....................                    j = 0; 
....................  
....................                k = 512; 
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempArray[j++] = i; 
....................                        tempArray[j++] = i >> 8; 
....................                        utf16path2++; 
....................                        i = *utf16path2; 
....................                    } 
....................             } 
....................             else 
....................             #endif 
....................               { 
....................                    // Change directories as specified 
....................                    i = *temppath2; 
....................                    j = 0; 
....................  
....................                #if defined(SUPPORT_LFN) 
....................                   k = 256; 
....................                #else 
....................                   k = 12; 
....................                #endif 
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempArray[j++] = i; 
....................                        temppath2++; 
....................                        i = *temppath2; 
....................                    } 
....................             } 
....................             } 
....................             else 
....................             { 
.................... #endif 
....................             #ifdef SUPPORT_LFN 
....................             if(utfModeFileName) 
....................             { 
....................                    // Change directories as specified 
....................                    i = *utf16path; 
....................                    j = 0; 
....................  
....................                k = 512; 
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempArray[j++] = i; 
....................                        tempArray[j++] = i >> 8; 
....................                        utf16path++; 
....................                        i = *utf16path; 
....................                    } 
....................             } 
....................             else 
....................             #endif 
....................               { 
....................                    // Change directories as specified 
....................                    i = *temppath; 
....................                    j = 0; 
....................  
....................                #if defined(SUPPORT_LFN) 
....................                   k = 256; 
....................                #else 
....................                   k = 12; 
....................                #endif 
....................  
....................                    // Parse the next token 
....................                    while ((i != 0) && (i != '\\') && (j < k)) 
....................                    { 
....................                        tempArray[j++] = i; 
....................                        temppath++; 
....................                        i = *temppath; 
....................                    } 
....................             } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................             } 
.................... #endif 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................          { 
....................                tempArray[j++] = 0; 
....................                tempArray[j] = 0; 
....................  
....................                if ((tempArray[0] == '.') && (tempArray[1] == 0)) 
....................                { 
....................                    if (((tempArray[2] != 0) || (tempArray[3] != 0)) && ((tempArray[2] != '.') || (tempArray[3] != 0))) 
....................                    { 
....................                        FileObjectCopy (cwdptr, tempCWD); 
....................                        FSerrno = CE_INVALID_ARGUMENT; 
....................                        return -1; 
....................                    } 
....................                    if (((tempArray[2] == '.') && (tempArray[3] == 0)) && ((tempArray[4] != 0) || (tempArray[5] != 0))) 
....................                    { 
....................                        FileObjectCopy (cwdptr, tempCWD); 
....................                        FSerrno = CE_INVALID_ARGUMENT; 
....................                        return -1; 
....................                    } 
....................                } 
....................          } 
....................          else 
....................          #endif 
....................          { 
....................                tempArray[j] = 0; 
....................  
....................                if (tempArray[0] == '.') 
....................                { 
....................                    if ((tempArray[1] != 0) && (tempArray[1] != '.')) 
....................                    { 
....................                        FileObjectCopy (cwdptr, tempCWD); 
....................                        FSerrno = CE_INVALID_ARGUMENT; 
....................                        return -1; 
....................                    } 
....................                    if ((tempArray[1] == '.') && (tempArray[2] != 0)) 
....................                    { 
....................                        FileObjectCopy (cwdptr, tempCWD); 
....................                        FSerrno = CE_INVALID_ARGUMENT; 
....................                        return -1; 
....................                    } 
....................                } 
....................          } 
....................  
....................             // Try to change to it 
....................             // If you can't we need to create it 
....................             if (FSchdir (tempArray)) 
....................             break; 
....................             else 
....................             { 
....................                 // We changed into the directory 
....................                 while (i == '\\') 
....................                 { 
....................                     // Next char is a backslash 
....................                     // Move past it 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     if (mode == 1) 
....................                     { 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................                   { 
....................                          utf16path2++; 
....................                          i = *utf16path2; 
....................                   } 
....................                   else 
....................                   #endif 
....................                      { 
....................                          temppath2++; 
....................                          i = *temppath2; 
....................                   } 
....................                     } 
....................                     else 
....................                     { 
.................... #endif 
....................                   #ifdef SUPPORT_LFN 
....................                   if(utfModeFileName) 
....................                   { 
....................                          utf16path++; 
....................                          i = *utf16path; 
....................                   } 
....................                   else 
....................                   #endif 
....................                      { 
....................                          temppath++; 
....................                          i = *temppath; 
....................                   } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................                     } 
.................... #endif 
....................                 } 
....................                 // If it's the last one, return success 
....................                 if (i == 0) 
....................                 { 
....................                     FileObjectCopy (cwdptr, tempCWD); 
....................                     return 0; 
....................                 } 
....................             } 
....................         } 
....................  
....................       #ifdef SUPPORT_LFN 
....................       if(utfModeFileName) 
....................       { 
....................          unsigned short int *tempPtr1; 
....................          unsigned short int *tempPtr2; 
....................          k = 0; 
....................          tempPtr1 = (unsigned short int *)&tempArray[0]; 
....................          tempPtr2 = (unsigned short int *)&tempDirectoryString[0]; 
....................  
....................          for(;;) 
....................          { 
....................             tempPtr2[k] = tempPtr1[k]; 
....................             if(tempPtr2[k]) 
....................                k++; 
....................             else 
....................                break; 
....................          } 
....................       } 
....................       else 
....................       #endif 
....................       { 
....................          strcpy(&tempDirectoryString[0],&tempArray[0]); 
....................       } 
....................  
....................         // Create a dir here 
....................         if (!CreateDIR (tempDirectoryString)) 
....................         { 
....................             FileObjectCopy (cwdptr, tempCWD); 
....................            return -1; 
....................         } 
....................  
....................         // Try to change to that directory 
....................         if (FSchdir (tempArray)) 
....................         { 
....................             FileObjectCopy (cwdptr, tempCWD); 
....................             FSerrno = CE_BADCACHEREAD; 
....................            return -1; 
....................         } 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................         if (mode == 1) 
....................         { 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................          { 
....................                while (*utf16path2 == '\\') 
....................                { 
....................                    utf16path2++; 
....................                    i = *utf16path2; 
....................                } 
....................          } 
....................          else 
....................          #endif 
....................            { 
....................                // Check for another backslash 
....................                while (*temppath2 == '\\') 
....................                { 
....................                    temppath2++; 
....................                    i = *temppath2; 
....................                } 
....................          } 
....................         } 
....................         else 
....................         { 
.................... #endif 
....................          #ifdef SUPPORT_LFN 
....................          if(utfModeFileName) 
....................          { 
....................                while (*utf16path == '\\') 
....................                { 
....................                    utf16path++; 
....................                    i = *utf16path; 
....................                } 
....................          } 
....................          else 
....................          #endif 
....................            { 
....................                while (*temppath == '\\') 
....................                { 
....................                    temppath++; 
....................                    i = *temppath; 
....................                } 
....................          } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................         } 
.................... #endif 
....................  
....................         // Check to see if we're at the end of the path string 
....................         if (i == 0) 
....................         { 
....................             // We already have one 
....................             FileObjectCopy (cwdptr, tempCWD); 
....................            return 0; 
....................         } 
....................     } 
.................... } 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int CreateDIR (char * path) 
....................   Summary: 
....................     FSmkdir helper function to create a directory 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     path -  The name of the dir to create 
....................   Return Values: 
....................     TRUE -  Directory was created successfully 
....................     FALSE - Directory could not be created. 
....................   Side Effects: 
....................     Any unwritten data in the data buffer or the FAT buffer will be written 
....................     to the device. 
....................   Description: 
....................     The CreateDIR function is a helper function for the mkdirhelper 
....................     function.  The CreateDIR function will create a new file entry for 
....................     a directory and assign a cluster to it.  It will erase the cluster 
....................     and write a dot and dotdot entry to it. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int CreateDIR (char * path) 
.................... { 
....................     FSFILE * dirEntryPtr = &gFileTemp; 
....................     DIRENTRY dir; 
....................     WORD handle = 0; 
....................     DWORD dot, dotdot; 
....................  
....................     if (FormatDirName(path, dirEntryPtr,0) == FALSE) 
....................     { 
....................         FSerrno = CE_INVALID_FILENAME; 
....................         return FALSE; 
....................     } 
....................  
....................     dirEntryPtr->dirclus = cwdptr->dirclus; 
....................     dirEntryPtr->dirccls = cwdptr->dirccls; 
....................     dirEntryPtr->cluster = 0; 
....................     dirEntryPtr->ccls = 0; 
....................     dirEntryPtr->dsk = cwdptr->dsk; 
....................  
....................     // Create a directory entry 
....................     if(CreateFileEntry(dirEntryPtr, &handle, DIRECTORY, TRUE) != CE_GOOD) 
....................     { 
....................         return FALSE; 
....................     } 
....................     else 
....................     { 
....................         if (gNeedFATWrite) 
....................             if(WriteFAT (dirEntryPtr->dsk, 0, 0, TRUE)) 
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
....................                 return FALSE; 
....................             } 
....................         // Zero that cluster 
....................         if (dirEntryPtr->dirclus == FatRootDirClusterValue) 
....................             dotdot = 0; 
....................         else 
....................             dotdot = dirEntryPtr->dirclus; 
....................         dirEntryPtr->dirccls = dirEntryPtr->dirclus; 
....................         dir = Cache_File_Entry(dirEntryPtr, &handle, TRUE); 
....................         if (dir == NULL) 
....................         { 
....................             FSerrno = CE_BADCACHEREAD; 
....................             return FALSE; 
....................         } 
....................  
....................         // Get the cluster 
....................         dot = GetFullClusterNumber(dir); // Get complete cluster number. 
....................  
....................         if (writeDotEntries (dirEntryPtr->dsk, dot, dotdot)) 
....................             return TRUE; 
....................         else 
....................             return FALSE; 
....................  
....................     } 
.................... } 
....................  
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     BYTE writeDotEntries (DISK * disk, DWORD dotAddress, DWORD dotdotAddress) 
....................   Summary: 
....................     Create dot and dotdot entries in a non-root directory 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     disk -           The global disk structure 
....................     dotAddress -     The cluster the current dir is in 
....................     dotdotAddress -  The cluster the previous directory was in 
....................   Return Values: 
....................     TRUE -  The dot and dotdot entries were created 
....................     FALSE - The dot and dotdot entries could not be created in the new directory 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The writeDotEntries function will create and write dot and dotdot entries 
....................     to a newly created directory. 
....................   Remarks: 
....................     None. 
....................   ***********************************************************************************/ 
....................  
.................... BYTE writeDotEntries (DISK * disk, DWORD dotAddress, DWORD dotdotAddress) 
.................... { 
....................     WORD i; 
....................     WORD size; 
....................     volatile _DIRENTRY entry; 
....................     DIRENTRY entryptr = (DIRENTRY)&entry; 
....................     DWORD sector; 
....................  
....................     gBufferOwner = NULL; 
....................  
....................     size = sizeof (_DIRENTRY); 
....................  
....................    memset(disk->buffer, 0x00, disk->sectorSize); 
....................  
....................     entry.DIR_Name[0] = '.'; 
....................  
....................     for (i = 1; i < 8; i++) 
....................     { 
....................         entry.DIR_Name[i] = 0x20; 
....................     } 
....................     for (i = 0; i < 3; i++) 
....................     { 
....................         entry.DIR_Extension[i] = 0x20; 
....................     } 
....................  
....................     entry.DIR_Attr = ATTR_DIRECTORY; 
....................     entry.DIR_NTRes = 0x00; 
....................  
....................     entry.DIR_FstClusLO = (WORD)(dotAddress & 0x0000FFFF); // Lower 16 bit address 
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................     entry.DIR_FstClusHI = (WORD)((dotAddress & 0x0FFF0000)>> 16); // Higher 16 bit address. FAT32 uses only 28 bits. Mask even higher nibble also. 
.................... #else // If FAT32 support not enabled 
....................     entry.DIR_FstClusHI = 0; 
.................... #endif 
....................  
....................     entry.DIR_FileSize = 0x00; 
....................  
.................... // Times need to be the same as the times in the directory entry 
....................  
.................... // Set dir date for uncontrolled clock source 
.................... #ifdef INCREMENTTIMESTAMP 
....................     entry.DIR_CrtTimeTenth = 0xB2; 
....................     entry.DIR_CrtTime = 0x7278; 
....................     entry.DIR_CrtDate = 0x32B0; 
....................     entry.DIR_LstAccDate = 0x0000; 
....................     entry.DIR_WrtTime = 0x0000; 
....................     entry.DIR_WrtDate = 0x0000; 
.................... #endif 
....................  
.................... #ifdef USEREALTIMECLOCK 
....................     entry.DIR_CrtTimeTenth = gTimeCrtMS;         // millisecond stamp 
....................     entry.DIR_CrtTime =      gTimeCrtTime;      // time created // 
....................     entry.DIR_CrtDate =      gTimeCrtDate;      // date created (1/1/2004) 
....................     entry.DIR_LstAccDate =   0x0000;         // Last Access date 
....................     entry.DIR_WrtTime =      0x0000;         // last update time 
....................     entry.DIR_WrtDate =      0x0000;         // last update date 
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................     entry.DIR_CrtTimeTenth  =   gTimeCrtMS;         // millisecond stamp 
....................     entry.DIR_CrtTime       =   gTimeCrtTime;       // time created // 
....................     entry.DIR_CrtDate       =   gTimeCrtDate;       // date created (1/1/2004) 
....................     entry.DIR_LstAccDate    =   0x0000;             // Last Access date 
....................     entry.DIR_WrtTime       =   0x0000;             // last update time 
....................     entry.DIR_WrtDate       =   0x0000;             // last update date 
.................... #endif 
....................  
....................     for (i = 0; i < size; i++) 
....................     { 
....................         *(disk->buffer + i) = *((char *)entryptr + i); 
....................     } 
....................     entry.DIR_Name[1] = '.'; 
....................  
....................     entry.DIR_FstClusLO = (WORD)(dotdotAddress & 0x0000FFFF); // Lower 16 bit address 
....................  
.................... #ifdef SUPPORT_FAT32 // If FAT32 supported. 
....................     entry.DIR_FstClusHI = (WORD)((dotdotAddress & 0x0FFF0000)>> 16); // Higher 16 bit address. FAT32 uses only 28 bits. Mask even higher nibble also. 
.................... #else // If FAT32 support not enabled 
....................     entry.DIR_FstClusHI = 0; 
.................... #endif 
....................  
....................  
....................     for (i = 0; i < size; i++) 
....................     { 
....................         *(disk->buffer + i + size) = *((char *)entryptr + i); 
....................     } 
....................  
....................     sector = Cluster2Sector (disk, dotAddress); 
....................  
....................     if (MDD_SectorWrite(sector, disk->buffer, FALSE) == FALSE) 
....................     { 
....................         FSerrno = CE_WRITE_ERROR; 
....................         return FALSE; 
....................     } 
....................  
....................     return TRUE; 
.................... } 
....................  
.................... // This array is used to prevent a stack frame error 
.................... #ifdef __18CXX 
....................     char tempArray[13] = "           "; 
.................... #endif 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdir (char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs - 
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int FSrmdir (char * path, unsigned char rmsubdirs) 
.................... { 
....................     return rmdirhelper (0, path, NULL, rmsubdirs); 
.................... } 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs) 
....................   Summary: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs - 
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
.................... #ifdef SUPPORT_LFN 
.................... int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................     result = rmdirhelper (0, (char *)path, NULL, rmsubdirs); 
....................    utfModeFileName = FALSE; 
....................     return result; 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdirpgm (const rom char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     path -      The path of the directory to remove (ROM) 
....................     rmsubdirs - 
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................     This function deletes the directory as specified in the path. 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int FSrmdirpgm (const rom char * path, unsigned char rmsubdirs) 
.................... { 
....................     return rmdirhelper (1, NULL, path, rmsubdirs); 
.................... } 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................         int wFSrmdirpgm (const rom unsigned short int * path, unsigned char rmsubdirs) 
....................   Summary: 
....................     Delete a directory with a path in ROM on PIC18 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     path -      The path of the directory to remove (ROM) 
....................     rmsubdirs - 
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSrmdirpgm function passes a PIC18 ROM path pointer to the 
....................     rmdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................  
.................... #ifdef SUPPORT_LFN 
.................... int wFSrmdirpgm (const rom unsigned short int * path, unsigned char rmsubdirs) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................     result = rmdirhelper (1, NULL, (const char *)path, rmsubdirs); 
....................    utfModeFileName = FALSE; 
....................     return result; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /************************************************************************************************ 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int rmdirhelper (BYTE mode, char * ramptr, char * romptr, unsigned char rmsubdirs) 
....................     // PIC18 
....................     int rmdirhelper (BYTE mode, char * ramptr, const rom char * romptr, unsigned char rmsubdirs) 
....................   Summary: 
....................     Helper function for FSrmdir 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     path -      The path of the dir to delete 
....................     rmsubdirs - 
....................               - TRUE -  Remove all sub-directories and files in the directory 
....................               - FALSE - Non-empty directories can not be removed 
....................   Return Values: 
....................     0 -   The specified directory was successfully removed. 
....................     EOF - The specified directory could not be removed. 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This helper function is used by the FSmkdir function.  If the path 
....................     argument is specified in ROM for PIC18 this function will be able 
....................     to parse it correctly.  This function will first change to the 
....................     specified directory.  If the rmsubdirs argument is FALSE the function 
....................     will search through the directory to ensure that it is empty and then 
....................     remove it.  If the rmsubdirs argument is TRUE the function will also 
....................     search through the directory for subdirectories or files.  When the 
....................     function finds a file, the file will be erased.  When the function 
....................     finds a subdirectory, it will switch to the subdirectory and begin 
....................     removing all of the files in that subdirectory.  Once the subdirectory 
....................     is empty, the function will switch back to the original directory. 
....................     return to the original position in that directory, and continue removing 
....................     files.  Once the specified directory is empty, the function will 
....................     change to the parent directory, search through it for the directory 
....................     to remove, and then erase that directory. 
....................   Remarks: 
....................     None. 
....................   ************************************************************************************************/ 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
.................... int rmdirhelper (BYTE mode, char * ramptr, const rom char * romptr, unsigned char rmsubdirs) 
.................... #else 
.................... int rmdirhelper (BYTE mode, char * ramptr, char * romptr, unsigned char rmsubdirs) 
.................... #endif 
.................... { 
....................     FILEOBJ tempCWD = &tempCWDobj; 
....................     FILEOBJ fo = &gFileTemp; 
....................     DIRENTRY entry; 
....................     WORD handle = 0; 
....................     WORD handle2; 
....................     WORD subDirDepth; 
....................     short int Index3 = 0; 
....................     char Index, Index2; 
....................  
....................    #if defined(SUPPORT_LFN) 
....................  
....................       BOOL prevUtfModeFileName = utfModeFileName; 
....................       char tempArray[514]; 
....................        WORD prevHandle; 
....................        LFN_ENTRY *lfno; 
....................        FSFILE cwdTemp; 
....................       UINT16_VAL tempShift; 
....................       unsigned short int *tempLFN = (unsigned short int *)&tempArray[0]; 
....................       BOOL   forFirstTime; 
....................    #else 
....................  
....................       char   tempArray[13]; 
....................  
....................    #endif 
....................  
.................... #ifndef __18CXX 
....................  
.................... #else 
....................     char dotdotname[] = ".."; 
....................     char dotdotname1[5] = {'.','\0','.','\0','\0'}; 
.................... #endif 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................     // Back up the current working directory 
....................     FileObjectCopy (tempCWD, cwdptr); 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     if (mode) 
....................     { 
....................         if (chdirhelper (1, NULL, romptr)) 
....................         { 
....................             FSerrno = CE_DIR_NOT_FOUND; 
....................             return -1; 
....................         } 
....................     } 
....................     else 
....................     { 
.................... #endif 
....................         if (FSchdir (ramptr)) 
....................         { 
....................             FSerrno = CE_DIR_NOT_FOUND; 
....................             return -1; 
....................         } 
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................     } 
.................... #endif 
....................  
....................     // Make sure we aren't trying to remove the root dir or the CWD 
....................     if ((cwdptr->dirclus == FatRootDirClusterValue) || (cwdptr->dirclus == tempCWD->dirclus)) 
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
....................         FSerrno = CE_INVALID_ARGUMENT; 
....................         return -1; 
....................     } 
....................  
....................     handle++; 
....................     entry = Cache_File_Entry (cwdptr, &handle, TRUE); 
....................  
....................     if (entry == NULL) 
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
....................         FSerrno = CE_BADCACHEREAD; 
....................         return -1; 
....................     } 
....................  
....................     handle++; 
....................     entry = Cache_File_Entry (cwdptr, &handle, FALSE); 
....................     if (entry == NULL) 
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
....................         FSerrno = CE_BADCACHEREAD; 
....................         return -1; 
....................     } 
....................     // Don't remove subdirectories and sub-files 
....................     if (!rmsubdirs) 
....................     { 
....................         while (entry->DIR_Name[0] != 0) 
....................         { 
....................             if ((unsigned char)entry->DIR_Name[0] != 0xE5) 
....................             { 
....................                 FileObjectCopy (cwdptr, tempCWD); 
....................                 FSerrno = CE_DIR_NOT_EMPTY; 
....................                 return -1; 
....................             } 
....................             handle++; 
....................             entry = Cache_File_Entry (cwdptr, &handle, FALSE); 
....................             if ((entry == NULL)) 
....................             { 
....................                 FileObjectCopy (cwdptr, tempCWD); 
....................                 FSerrno = CE_BADCACHEREAD; 
....................                 return -1; 
....................             } 
....................         } 
....................     } 
....................     else 
....................     { 
....................         // Do remove subdirectories and sub-files 
....................         dirCleared = FALSE; 
....................         subDirDepth = 0; 
....................       #if defined(SUPPORT_LFN) 
....................       tempCWD-> utf16LFNptr = (unsigned short int *)&tempArray[0]; 
....................       fo-> utf16LFNptr = (unsigned short int *)&tempArray[0]; 
....................       #endif 
....................  
....................         while (!dirCleared) 
....................         { 
....................             if (entry->DIR_Name[0] != 0) 
....................             { 
....................                 if (((unsigned char)entry->DIR_Name[0] != 0xE5) && (entry->DIR_Attr == ATTR_LONG_NAME)) 
....................             { 
....................                #if defined(SUPPORT_LFN) 
....................                lfno = (LFN_ENTRY *)entry; 
....................  
....................                if(lfno->LFN_SequenceNo & 0x40) 
....................                { 
....................                   Index3 = (lfno->LFN_SequenceNo - 0x41) * 13; 
....................                   tempLFN[Index3 + 13] = 0x0000; 
....................                   forFirstTime = TRUE; 
....................                } 
....................                else 
....................                { 
....................                   Index3 = (lfno->LFN_SequenceNo - 1) * 13; 
....................                   forFirstTime = FALSE; 
....................                } 
....................  
....................                tempShift.byte.LB = lfno->LFN_Part1[0]; 
....................                tempShift.byte.HB = lfno->LFN_Part1[1]; 
....................                tempLFN[Index3++] = tempShift.Val; 
....................                tempShift.byte.LB = lfno->LFN_Part1[2]; 
....................                tempShift.byte.HB = lfno->LFN_Part1[3]; 
....................                tempLFN[Index3++] = tempShift.Val; 
....................                tempShift.byte.LB = lfno->LFN_Part1[4]; 
....................                tempShift.byte.HB = lfno->LFN_Part1[5]; 
....................                tempLFN[Index3++] = tempShift.Val; 
....................                tempShift.byte.LB = lfno->LFN_Part1[6]; 
....................                tempShift.byte.HB = lfno->LFN_Part1[7]; 
....................                tempLFN[Index3++] = tempShift.Val; 
....................                tempShift.byte.LB = lfno->LFN_Part1[8]; 
....................                tempShift.byte.HB = lfno->LFN_Part1[9]; 
....................                tempLFN[Index3++] = tempShift.Val; 
....................  
....................                tempLFN[Index3++] = lfno->LFN_Part2[0]; 
....................                tempLFN[Index3++] = lfno->LFN_Part2[1]; 
....................                tempLFN[Index3++] = lfno->LFN_Part2[2]; 
....................                tempLFN[Index3++] = lfno->LFN_Part2[3]; 
....................                tempLFN[Index3++] = lfno->LFN_Part2[4]; 
....................                tempLFN[Index3++] = lfno->LFN_Part2[5]; 
....................  
....................                tempLFN[Index3++] = lfno->LFN_Part3[0]; 
....................                tempLFN[Index3] = lfno->LFN_Part3[1]; 
....................  
....................                if(forFirstTime) 
....................                { 
....................                   tempCWD->utf16LFNlength = Index3; 
....................  
....................                   for(Index = 12;Index >= 0;Index--) 
....................                   { 
....................                      if((tempLFN[Index3 - Index - 1]) == 0x0000) 
....................                      { 
....................                         tempCWD->utf16LFNlength = Index3 - Index - 1; 
....................                         break; 
....................                      } 
....................                   } 
....................  
....................                   fo->utf16LFNlength = tempCWD->utf16LFNlength; 
....................                } 
....................                    handle++; 
....................                #endif 
....................             } 
....................                 else if (((unsigned char)entry->DIR_Name[0] != 0xE5) && (entry->DIR_Attr != ATTR_VOLUME) && (entry->DIR_Attr != ATTR_LONG_NAME)) 
....................                 { 
....................                     if ((entry->DIR_Attr & ATTR_DIRECTORY) == ATTR_DIRECTORY) 
....................                     { 
....................                         // We have a directory 
....................                         subDirDepth++; 
....................                   #if defined(SUPPORT_LFN) 
....................                   if(tempCWD-> utf16LFNlength) 
....................                   { 
....................                      utfModeFileName = 1; 
....................                      Index = FSchdir(&tempArray[0]); 
....................                      utfModeFileName = prevUtfModeFileName; 
....................                      tempCWD-> utf16LFNlength = 0; 
....................                      fo-> utf16LFNlength = 0; 
....................                   } 
....................                   else 
....................                   #endif 
....................                   { 
....................                            for (Index = 0; (Index < DIR_NAMESIZE) && (entry->DIR_Name[(BYTE)Index] != 0x20); Index++) 
....................                            { 
....................                                tempArray[(BYTE)Index] = entry->DIR_Name[(BYTE)Index]; 
....................                            } 
....................                            if (entry->DIR_Extension[0] != 0x20) 
....................                            { 
....................                                tempArray[(BYTE)Index++] = '.'; 
....................                                for (Index2 = 0; (Index2 < DIR_EXTENSION) && (entry->DIR_Extension[(BYTE)Index2] != 0x20); Index2++) 
....................                                { 
....................                                    tempArray[(BYTE)Index++] = entry->DIR_Extension[(BYTE)Index2]; 
....................                                } 
....................                            } 
....................                            tempArray[(BYTE)Index] = 0; 
....................                      #ifdef SUPPORT_LFN 
....................                      utfModeFileName = 0; 
....................                      #endif 
....................                      Index = FSchdir(&tempArray[0]); 
....................                      #ifdef SUPPORT_LFN 
....................                      utfModeFileName = prevUtfModeFileName; 
....................                      #endif 
....................                   } 
....................  
....................                         // Change to the subdirectory 
....................                         if (Index) 
....................                         { 
....................                             FileObjectCopy (cwdptr, tempCWD); 
....................                             FSerrno = CE_DIR_NOT_FOUND; 
....................                             return -1; 
....................                         } 
....................                         else 
....................                         { 
....................                             // Make sure we're not trying to delete the CWD 
....................                             if (cwdptr->dirclus == tempCWD->dirclus) 
....................                             { 
....................                                 FileObjectCopy (cwdptr, tempCWD); 
....................                                 FSerrno = CE_INVALID_ARGUMENT; 
....................                                 return -1; 
....................                             } 
....................                         } 
....................                         handle = 2; 
....................                         recache = TRUE; 
....................                     } 
....................                     else 
....................                     { 
....................                   #if defined(SUPPORT_LFN) 
....................                   if(!tempCWD-> utf16LFNlength) 
....................                   #endif 
....................                   { 
....................                            for (Index = 0; Index < 8; Index++) 
....................                            { 
....................                                fo->name[(BYTE)Index] = entry->DIR_Name[(BYTE)Index]; 
....................                            } 
....................  
....................                            for (Index = 0; Index < 3; Index++) 
....................                            { 
....................                                fo->name[(BYTE)Index + 8] = entry->DIR_Extension[(BYTE)Index]; 
....................                            } 
....................                   } 
....................  
....................                         fo->dsk = &gDiskData; 
....................  
....................                         fo->entry = handle; 
....................                         fo->dirclus = cwdptr->dirclus; 
....................                         fo->dirccls = cwdptr->dirccls; 
....................                         fo->cluster = 0; 
....................                         fo->ccls    = 0; 
....................  
....................                         if (FILEerase(fo, &handle, TRUE)) 
....................                         { 
....................                      #if defined(SUPPORT_LFN) 
....................                      tempCWD-> utf16LFNlength = 0; 
....................                      fo-> utf16LFNlength = 0; 
....................                      #endif 
....................                             FileObjectCopy (cwdptr, tempCWD); 
....................                             FSerrno = CE_ERASE_FAIL; 
....................                             return -1; 
....................                         } 
....................                         else 
....................                         { 
....................                             handle++; 
....................                         } 
....................                   #if defined(SUPPORT_LFN) 
....................                   tempCWD-> utf16LFNlength = 0; 
....................                   fo-> utf16LFNlength = 0; 
....................                   #endif 
....................                     } // Check to see if it's a DIR entry 
....................                 }// Check non-dir entry to see if its a valid file 
....................                 else 
....................                 { 
....................                     handle++; 
....................                 } 
....................  
....................                 if (recache) 
....................                 { 
....................                     recache = FALSE; 
....................                     cwdptr->dirccls = cwdptr->dirclus; 
....................                     entry = Cache_File_Entry (cwdptr, &handle, TRUE); 
....................                 } 
....................                 else 
....................                 { 
....................                     entry = Cache_File_Entry (cwdptr, &handle, FALSE); 
....................                 } 
....................  
....................             if (entry == NULL) 
....................                 { 
....................                #if defined(SUPPORT_LFN) 
....................                tempCWD-> utf16LFNlength = 0; 
....................                fo-> utf16LFNlength = 0; 
....................                #endif 
....................                     FileObjectCopy (cwdptr, tempCWD); 
....................                     FSerrno = CE_BADCACHEREAD; 
....................                     return -1; 
....................                 } 
....................             } 
....................             else 
....................             { 
....................             #if defined(SUPPORT_LFN) 
....................             tempCWD-> utf16LFNlength = 0; 
....................             fo-> utf16LFNlength = 0; 
....................             #endif 
....................  
....................                 // We have reached the end of the directory 
....................                 if (subDirDepth != 0) 
....................                 { 
....................                     handle2 = 0; 
....................  
....................                     cwdptr->dirccls = cwdptr->dirclus; 
....................                     entry = Cache_File_Entry (cwdptr, &handle2, TRUE); 
....................                     if (entry == NULL) 
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
....................                         FSerrno = CE_BADCACHEREAD; 
....................                         return -1; 
....................                     } 
....................  
....................                     // Get the cluster 
....................                     handle2 = GetFullClusterNumber(entry); // Get complete cluster number. 
....................  
.................... #ifndef __18CXX 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................  
....................         Index3 = FSchdir (".\0.\0\0"); 
....................  
....................    else 
....................  
....................    #endif 
....................         Index3 = FSchdir (".."); 
....................  
.................... #else 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................  
....................         Index3 = FSchdir (dotdotname1); 
....................  
....................    else 
....................  
....................    #endif 
....................         Index3 = FSchdir (dotdotname); 
....................  
.................... #endif 
....................                     if(Index3) 
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
....................                         FSerrno = CE_DIR_NOT_FOUND; 
....................                         return -1; 
....................                     } 
....................                     // Return to our previous position in this directory 
....................                     handle = 2; 
....................                     cwdptr->dirccls = cwdptr->dirclus; 
....................                     entry = Cache_File_Entry (cwdptr, &handle, TRUE); 
....................                     if (entry == NULL) 
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
....................                         FSerrno = CE_BADCACHEREAD; 
....................                         return -1; 
....................                     } 
....................  
....................                     // Get the cluster 
....................                     TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number. 
....................  
....................                     while ((TempClusterCalc != handle2) || 
....................                     ((TempClusterCalc == handle2) && 
....................                     (((unsigned char)entry->DIR_Name[0] == 0xE5) || (entry->DIR_Attr == ATTR_VOLUME)))) 
....................                     { 
....................                         handle++; 
....................                         entry = Cache_File_Entry (cwdptr, &handle, FALSE); 
....................                         if (entry == NULL) 
....................                         { 
....................                             FileObjectCopy (cwdptr, tempCWD); 
....................                             FSerrno = CE_BADCACHEREAD; 
....................                             return -1; 
....................                         } 
....................                         // Get the cluster 
....................                         TempClusterCalc = GetFullClusterNumber(entry); // Get complete cluster number in a loop. 
....................                     } 
....................  
....................                Index3 = 0; 
....................                #if defined(SUPPORT_LFN) 
....................                  FileObjectCopy (&cwdTemp, cwdptr); 
....................                prevHandle = handle - 1; 
....................                lfno = (LFN_ENTRY *)Cache_File_Entry (cwdptr, &prevHandle, FALSE); 
....................  
....................  
....................                while((lfno->LFN_Attribute == ATTR_LONG_NAME) && (lfno->LFN_SequenceNo != DIR_DEL) 
....................                      && (lfno->LFN_SequenceNo != DIR_EMPTY)) 
....................                { 
....................                   tempShift.byte.LB = lfno->LFN_Part1[0]; 
....................                   tempShift.byte.HB = lfno->LFN_Part1[1]; 
....................                   tempLFN[Index3++] = tempShift.Val; 
....................                   tempShift.byte.LB = lfno->LFN_Part1[2]; 
....................                   tempShift.byte.HB = lfno->LFN_Part1[3]; 
....................                   tempLFN[Index3++] = tempShift.Val; 
....................                   tempShift.byte.LB = lfno->LFN_Part1[4]; 
....................                   tempShift.byte.HB = lfno->LFN_Part1[5]; 
....................                   tempLFN[Index3++] = tempShift.Val; 
....................                   tempShift.byte.LB = lfno->LFN_Part1[6]; 
....................                   tempShift.byte.HB = lfno->LFN_Part1[7]; 
....................                   tempLFN[Index3++] = tempShift.Val; 
....................                   tempShift.byte.LB = lfno->LFN_Part1[8]; 
....................                   tempShift.byte.HB = lfno->LFN_Part1[9]; 
....................                   tempLFN[Index3++] = tempShift.Val; 
....................  
....................                   tempLFN[Index3++] = lfno->LFN_Part2[0]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part2[1]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part2[2]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part2[3]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part2[4]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part2[5]; 
....................  
....................                   tempLFN[Index3++] = lfno->LFN_Part3[0]; 
....................                   tempLFN[Index3++] = lfno->LFN_Part3[1]; 
....................  
....................                   prevHandle = prevHandle - 1; 
....................                   lfno = (LFN_ENTRY *)Cache_File_Entry (cwdptr, &prevHandle, FALSE); 
....................                } 
....................  
....................                FileObjectCopy (cwdptr, &cwdTemp); 
....................  
....................                #endif 
....................  
....................                if(Index3 == 0) 
....................                { 
....................                        memset (tempArray, 0x00, 12); 
....................                        for (Index = 0; Index < 8; Index++) 
....................                        { 
....................                            tempArray[(BYTE)Index] = entry->DIR_Name[(BYTE)Index]; 
....................                        } 
....................                        for (Index = 0; Index < 3; Index++) 
....................                        { 
....................                            tempArray[(BYTE)Index + 8] = entry->DIR_Extension[(BYTE)Index]; 
....................                        } 
....................                   #if defined(SUPPORT_LFN) 
....................                   cwdptr->utf16LFNlength = 0; 
....................                   #endif 
....................                } 
....................                #if defined(SUPPORT_LFN) 
....................                else 
....................                { 
....................                   cwdptr->utf16LFNlength = Index3; 
....................  
....................                   for(Index = 12;Index >= 0;Index--) 
....................                   { 
....................                      if((tempLFN[Index3 - Index - 1]) == 0x0000) 
....................                      { 
....................                         cwdptr->utf16LFNlength = Index3 - Index - 1; 
....................                         break; 
....................                      } 
....................                   } 
....................  
....................                   cwdptr->utf16LFNptr = (unsigned short int *)&tempArray[0]; 
....................                } 
....................                #endif 
....................                     // Erase the directory that we just cleared the subdirectories out of 
....................  
....................                     if (eraseDir (&tempArray[0])) 
....................                     { 
....................                         FileObjectCopy (cwdptr, tempCWD); 
....................                         FSerrno = CE_ERASE_FAIL; 
....................                         return -1; 
....................                     } 
....................                     else 
....................                     { 
....................                         handle++; 
....................                         cwdptr->dirccls = cwdptr->dirclus; 
....................                         entry = Cache_File_Entry (cwdptr, &handle, TRUE); 
....................                         if (entry == NULL) 
....................                         { 
....................                             FileObjectCopy (cwdptr, tempCWD); 
....................                             FSerrno = CE_BADCACHEREAD; 
....................                             return -1; 
....................                         } 
....................                     } 
....................  
....................                     // Decrease the subdirectory depth 
....................                     subDirDepth--; 
....................                 } 
....................                 else 
....................                 { 
....................                     dirCleared = TRUE; 
....................                 } // Check subdirectory depth 
....................             } // Check until we get an empty entry 
....................         } // Loop until the whole dir is cleared 
....................     } 
....................  
....................     // Cache the current directory name 
....................     // tempArray is used so we don't disturb the 
....................     // global getcwd buffer 
....................     if (FSgetcwd (&tempArray[0], 2) == NULL) 
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
....................         return -1; 
....................     } 
....................    else 
....................    { 
....................       #if defined(SUPPORT_LFN) 
....................          if(!cwdptr->utf16LFNlength) 
....................       #endif 
....................          { 
....................               memset (tempArray, 0x00, 12); 
....................               for (Index = 0; Index < 11; Index++) 
....................               { 
....................                   tempArray[(BYTE)Index] = cwdptr->name[(BYTE)Index]; 
....................               } 
....................          } 
....................    } 
....................  
....................     // If we're here, this directory is empty 
.................... #ifndef __18CXX 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................  
....................         Index3 = FSchdir (".\0.\0\0"); 
....................  
....................    else 
....................  
....................    #endif 
....................         Index3 = FSchdir (".."); 
....................  
.................... #else 
....................    #ifdef SUPPORT_LFN 
....................    if(utfModeFileName) 
....................  
....................         Index3 = FSchdir (dotdotname1); 
....................  
....................    else 
....................  
....................    #endif 
....................         Index3 = FSchdir (dotdotname); 
....................  
.................... #endif 
....................     if(Index3) 
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
....................         FSerrno = CE_DIR_NOT_FOUND; 
....................         return -1; 
....................     } 
....................  
....................    #if defined(SUPPORT_LFN) 
....................    if(cwdptr->utf16LFNlength) 
....................    { 
....................       Index3 = eraseDir((char *)cwdptr->utf16LFNptr); 
....................    } 
....................    else 
....................    #endif 
....................    { 
....................       Index3 = eraseDir(tempArray); 
....................    } 
....................  
....................     if (Index3) 
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
....................         FSerrno = CE_ERASE_FAIL; 
....................         return -1; 
....................     } 
....................     else 
....................     { 
....................         FileObjectCopy (cwdptr, tempCWD); 
....................         return 0; 
....................     } 
.................... } 
....................  
....................  
.................... /**************************************************************** 
....................   Function: 
....................     int eraseDir (char * path) 
....................   Summary: 
....................     FSrmdir helper function to erase dirs 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     path -  The name of the directory to delete 
....................   Return Values: 
....................     0 -  Dir was deleted successfully 
....................     -1 - Dir could not be deleted. 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The eraseDir function is a helper function for the rmdirhelper 
....................     function.  The eraseDir function will search for the 
....................     directory that matches the specified path name and then erase 
....................     it with the FILEerase function. 
....................   Remarks: 
....................     None. 
....................   *****************************************************************/ 
....................  
.................... int eraseDir (char * path) 
.................... { 
....................     int result; 
....................     BYTE Index; 
....................     FSFILE tempCWDobj2; 
....................  
....................     if (MDD_WriteProtectState()) 
....................     { 
....................         return (-1); 
....................     } 
....................  
....................     // preserve CWD 
....................     FileObjectCopy(&tempCWDobj2, cwdptr); 
....................  
....................    // If long file name not present, copy the 8.3 name in cwdptr 
....................    #if defined(SUPPORT_LFN) 
....................     if(!cwdptr->utf16LFNlength) 
....................    #endif 
....................     { 
....................        for (Index = 0; Index <11; Index++) 
....................        { 
....................            cwdptr->name[Index] = *(path + Index); 
....................        } 
....................    } 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&gFileTemp, cwdptr); 
....................  
....................     // See if the file is found 
....................    if(FILEfind (cwdptr, &gFileTemp, LOOK_FOR_MATCHING_ENTRY, 0) == CE_GOOD) 
....................    { 
....................       if(FILEerase(cwdptr, &cwdptr->entry, TRUE) == CE_GOOD) 
....................          result = 0; 
....................       else 
....................          result = -1; 
....................    } 
....................    else 
....................       result = -1; 
....................  
....................    FileObjectCopy(cwdptr, &tempCWDobj2); 
....................    return(result); 
.................... } 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_FILESEARCH 
....................  
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................     The FindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the 
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was 
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec) 
.................... { 
....................     FSFILE f; 
....................     FILEOBJ fo = &f; 
....................     WORD fHandle; 
....................     BYTE j; 
....................     BYTE Index; 
....................    #ifdef SUPPORT_LFN 
....................       short int indexLFN; 
....................    #endif 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................    #ifdef SUPPORT_LFN 
....................       fo->utf16LFNptr = &recordSearchName[0]; 
....................       rec->utf16LFNfound = &recordFoundName[0]; 
....................    #endif 
....................  
....................    // Format the file name as per 8.3 format or LFN format 
....................     if( !FormatFileName(fileName, fo, 1) ) 
....................     { 
....................         FSerrno = CE_INVALID_FILENAME; 
....................         return -1; 
....................     } 
....................  
....................     rec->initialized = FALSE; 
....................  
....................    #if defined(SUPPORT_LFN) 
....................    rec->AsciiEncodingType = fo->AsciiEncodingType; 
....................    recordSearchLength = fo->utf16LFNlength; 
....................  
....................    // If file name is 8.3 format copy it in 'searchname' string 
....................     if(!recordSearchLength) 
....................    #endif 
....................     { 
....................        for (Index = 0; (Index < 12) && (fileName[Index] != 0); Index++) 
....................        { 
....................            rec->searchname[Index] = fileName[Index]; 
....................        } 
....................  
....................        for (;Index < FILE_NAME_SIZE_8P3 + 2; Index++) 
....................        { 
....................            rec->searchname[Index] = 0; 
....................        } 
....................    } 
....................  
....................     rec->searchattr = attr; 
.................... #ifdef ALLOW_DIRS 
....................     rec->cwdclus = cwdptr->dirclus; 
.................... #else 
....................     rec->cwdclus = FatRootDirClusterValue; 
.................... #endif 
....................  
....................     fo->dsk = &gDiskData; 
....................     fo->cluster = 0; 
....................     fo->ccls    = 0; 
....................     fo->entry = 0; 
....................     fo->attributes = attr; 
....................  
.................... #ifndef ALLOW_DIRS 
....................     // start at the root directory 
....................     fo->dirclus    = FatRootDirClusterValue; 
....................     fo->dirccls    = FatRootDirClusterValue; 
.................... #else 
....................     fo->dirclus = cwdptr->dirclus; 
....................     fo->dirccls = cwdptr->dirccls; 
.................... #endif 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&gFileTemp, fo); 
....................  
....................     // See if the file is found 
....................     if (FILEfind (fo, &gFileTemp,LOOK_FOR_MATCHING_ENTRY, 1) != CE_GOOD) 
....................     { 
....................         FSerrno = CE_FILE_NOT_FOUND; 
....................         return -1; 
....................     } 
....................  
....................     fHandle = fo->entry; 
....................  
....................     if (FILEopen (fo, &fHandle, 'r') == CE_GOOD) 
....................     { 
....................       #if defined(SUPPORT_LFN) 
....................       rec->utf16LFNfoundLength = fo->utf16LFNlength; 
....................       if(fo->utf16LFNlength) 
....................       { 
....................          indexLFN = fo->utf16LFNlength; 
....................          recordFoundName[indexLFN] = 0x0000; 
....................          while(indexLFN--) 
....................             recordFoundName[indexLFN] = fileFoundString[indexLFN]; 
....................       } 
....................       #endif 
....................  
....................       for(j = 0; j < FILE_NAME_SIZE_8P3 + 2 ; j++) 
....................       { 
....................             rec->filename[j] = 0; 
....................       } 
....................  
....................         // Copy as much name as there is 
....................         if (fo->attributes != ATTR_VOLUME) 
....................         { 
....................             for (Index = 0, j = 0; (j < 8) && (fo->name[j] != 0x20); Index++, j++) 
....................             { 
....................                rec->filename[Index] = fo->name[j]; 
....................             } 
....................  
....................          if(fo->name[8] != 0x20) 
....................          { 
....................                rec->filename[Index++] = '.'; 
....................  
....................                // Move to the extension, even if there are more space chars 
....................                for (j = 8; (j < 11) && (fo->name[j] != 0x20); Index++, j++) 
....................                { 
....................                   rec->filename[Index] = fo->name[j]; 
....................                } 
....................          } 
....................         } 
....................         else 
....................         { 
....................             for (Index = 0; Index < DIR_NAMECOMP; Index++) 
....................             { 
....................                 rec->filename[Index] = fo->name[Index]; 
....................             } 
....................         } 
....................  
....................         rec->attributes = fo->attributes; 
....................         rec->filesize = fo->size; 
....................         rec->timestamp = (DWORD)((DWORD)fo->date << 16) + fo->time; 
....................         rec->entry = fo->entry; 
....................         rec->initialized = TRUE; 
....................  
....................  
....................        #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" FINDFirst foCompareTo="); 
....................          PrintRAMBytesUART(((unsigned char*)fo->name), 13); 
....................          PrintROMASCIIStringUART(" FINDFirst recSearchname="); 
....................          PrintRAMBytesUART(((unsigned char*)rec->searchname), 13);          
....................          PrintROMASCIIStringUART(" FINDFirst gTempCompareTo="); 
....................          PrintRAMBytesUART(((unsigned char*)gFileTemp.name), 13); 
....................         #endif 
....................  
....................         return 0; 
....................     } 
....................     else 
....................     { 
....................         FSerrno = CE_BADCACHEREAD; 
....................         return -1; 
....................     } 
.................... } 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FindNext (SearchRec * rec) 
....................   Summary: 
....................     Sequential search function 
....................   Conditions: 
....................     None 
....................   Input: 
....................     rec -  The structure to store the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No additional files matching the specified criteria were found 
....................   Side Effects: 
....................     Search criteria from previous FindNext call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     The FindNext function performs the same function as the FindFirst 
....................     funciton, except it does not copy any search parameters into the 
....................     SearchRec structure (only info about found files) and it begins 
....................     searching at the last directory entry offset at which a file was 
....................     found, rather than at the beginning of the current working 
....................     directory.If the return value of the function is 0 then "utf16LFNfoundLength" 
....................     indicates whether the file found was long file name or short file 
....................     name(8P3 format). The "utf16LFNfoundLength" is non-zero for long file name 
....................     and is zero for 8P3 format."utf16LFNfound" points to the address of long 
....................     file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling this function 
....................   **********************************************************************/ 
....................  
.................... int FindNext (SearchRec * rec) 
.................... { 
....................     FSFILE f; 
....................     FILEOBJ fo = &f; 
....................     BYTE i, j; 
....................    #ifdef SUPPORT_LFN 
....................       short int indexLFN; 
....................    #endif 
....................  
....................     FSerrno = CE_GOOD; 
....................  
....................     // Make sure we called FindFirst on this object 
....................     if (rec->initialized == FALSE) 
....................     { 
....................         FSerrno = CE_NOT_INIT; 
....................         return -1; 
....................     } 
....................  
....................     // Make sure we called FindFirst in the cwd 
.................... #ifdef ALLOW_DIRS 
....................     if (rec->cwdclus != cwdptr->dirclus) 
....................     { 
....................         FSerrno = CE_INVALID_ARGUMENT; 
....................         return -1; 
....................     } 
.................... #endif 
....................  
....................    #if defined(SUPPORT_LFN) 
....................     fo->AsciiEncodingType = rec->AsciiEncodingType; 
....................     fo->utf16LFNlength = recordSearchLength; 
....................    if(fo->utf16LFNlength) 
....................    { 
....................        fo->utf16LFNptr = &recordSearchName[0]; 
....................     } 
....................    else 
....................    #endif 
....................    { 
....................       // Format the file name 
....................        if( !FormatFileName(rec->searchname, fo, 1) ) 
....................        { 
....................            FSerrno = CE_INVALID_FILENAME; 
....................            return -1; 
....................        } 
....................     } 
....................  
....................        #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" FindNext foCompareTo="); 
....................          PrintRAMBytesUART(((unsigned char*)fo->name), 13); 
....................          PrintROMASCIIStringUART(" FindNext recSearchname="); 
....................          PrintRAMBytesUART(((unsigned char*)rec->searchname), 13);          
....................         #endif 
....................  
....................     /* Brn: Copy the formatted name to "fo" which is necesary before calling "FILEfind" function */ 
....................     //strcpy(fo->name,rec->searchname); 
....................  
....................     fo->dsk = &gDiskData; 
....................     fo->cluster = 0; 
....................     fo->ccls    = 0; 
....................     fo->entry = rec->entry + 1; 
....................     fo->attributes = rec->searchattr; 
....................  
.................... #ifndef ALLOW_DIRS 
....................     // start at the root directory 
....................     fo->dirclus    = FatRootDirClusterValue; 
....................     fo->dirccls    = FatRootDirClusterValue; 
.................... #else 
....................     fo->dirclus = cwdptr->dirclus; 
....................     fo->dirccls = cwdptr->dirccls; 
.................... #endif 
....................  
....................     // copy file object over 
....................     FileObjectCopy(&gFileTemp, fo); 
....................  
....................        #ifdef __DEBUG_UART   
....................          PrintROMASCIIStringUART(" FindNext2 foCompareTo="); 
....................          PrintRAMBytesUART(((unsigned char*)fo->name), 13); 
....................          PrintROMASCIIStringUART(" FindNext2 recSearchname="); 
....................          PrintRAMBytesUART(((unsigned char*)gFileTemp.name), 13);          
....................         #endif 
....................  
....................     // See if the file is found 
....................     if (CE_GOOD != FILEfind (fo, &gFileTemp,LOOK_FOR_MATCHING_ENTRY, 1)) 
....................     { 
....................         FSerrno = CE_FILE_NOT_FOUND; 
....................         return -1; 
....................     } 
....................     else 
....................     { 
....................       #if defined(SUPPORT_LFN) 
....................       rec->utf16LFNfoundLength = fo->utf16LFNlength; 
....................       if(fo->utf16LFNlength) 
....................       { 
....................          indexLFN = fo->utf16LFNlength; 
....................          recordFoundName[indexLFN] = 0x0000; 
....................          while(indexLFN--) 
....................             recordFoundName[indexLFN] = fileFoundString[indexLFN]; 
....................       } 
....................       #endif 
....................  
....................       for(j = 0; j < FILE_NAME_SIZE_8P3 + 2 ; j++) 
....................       { 
....................             rec->filename[j] = 0; 
....................       } 
....................  
....................         if (fo->attributes != ATTR_VOLUME) 
....................         { 
....................             for (i = 0, j = 0; (j < 8) && (fo->name[j] != 0x20); i++, j++) 
....................             { 
....................                rec->filename[i] = fo->name[j]; 
....................             } 
....................  
....................          if(fo->name[8] != 0x20) 
....................          { 
....................                rec->filename[i++] = '.'; 
....................  
....................                // Move to the extension, even if there are more space chars 
....................                for (j = 8; (j < 11) && (fo->name[j] != 0x20); i++, j++) 
....................                { 
....................                   rec->filename[i] = fo->name[j]; 
....................                } 
....................          } 
....................         } 
....................         else 
....................         { 
....................             for (i = 0; i < DIR_NAMECOMP; i++) 
....................             { 
....................                 rec->filename[i] = fo->name[i]; 
....................             } 
....................         } 
....................  
....................         rec->attributes = fo->attributes; 
....................         rec->filesize = fo->size; 
....................         rec->timestamp = (DWORD)((DWORD)fo->date << 16) + fo->time; 
....................         rec->entry = fo->entry; 
....................         return 0; 
....................     } 
.................... } 
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous wFindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent wFindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................     The wFindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the 
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was 
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... #ifdef SUPPORT_LFN 
.................... int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec) 
.................... { 
....................    int result; 
....................    utfModeFileName = TRUE; 
....................    result = FindFirst ((const char *)fileName,attr,rec); 
....................    utfModeFileName = FALSE; 
....................    return result; 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FSputc (char c, FSFILE * file) 
....................   Summary: 
....................     FSfprintf helper function to write a char 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     c - The character to write to the file. 
....................     file - The file to write to. 
....................   Return Values: 
....................     0 -   The character was written successfully 
....................     EOF - The character was not written to the file. 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This is a helper function for FSfprintf.  It will write one 
....................     character to a file. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int FSputc (char c, FSFILE * file) 
.................... { 
....................     if (FSfwrite ((void *)&c, 1, 1, file) != 1) 
....................         return EOF; 
....................     else 
....................         return 0; 
.................... } 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int str_put_n_chars (FSFILE * handle, unsigned char n, char c) 
....................   Summary: 
....................     FSfprintf helper function to write a char multiple times 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     handle - The file to write to. 
....................     n -      The number of times to write that character to a file. 
....................     c - The character to write to the file. 
....................   Return Values: 
....................     0 -   The characters were written successfully 
....................     EOF - The characters were not written to the file. 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This funciton is used by the FSfprintf function to write multiple 
....................     instances of a single character to a file (for example, when 
....................     padding a format specifier with leading spacez or zeros). 
....................   Remarks: 
....................     None. 
....................   **********************************************************************/ 
....................  
....................  
.................... unsigned char str_put_n_chars (FSFILE * handle, unsigned char n, char c) 
.................... { 
....................     while (n--) 
....................     if (FSputc (c, handle) == EOF) 
....................         return 1; 
....................     return 0; 
.................... } 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int FSfprintf (FSFILE * fptr, const char * fmt, ...) 
....................     // PIC18 
....................     int FSfpritnf (FSFILE * fptr, const rom char * fmt, ...) 
....................   Summary: 
....................     Function to write formatted strings to a file 
....................   Conditions: 
....................     For PIC18, integer promotion must be enabled in the project build 
....................     options menu.  File opened in a write mode. 
....................   Input: 
....................     fptr - A pointer to the file to write to. 
....................     fmt -  A string of characters and format specifiers to write to 
....................            the file 
....................     ... -  Additional arguments inserted in the string by format 
....................            specifiers 
....................   Returns: 
....................     The number of characters written to the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Writes a specially formatted string to a file. 
....................   Remarks: 
....................     Consult AN1045 for a full description of how to use format 
....................     specifiers. 
....................   **********************************************************************/ 
....................  
.................... #ifdef __18CXX 
.................... int FSfprintf (FSFILE *fptr, const rom char *fmt, ...) 
.................... #else 
.................... int FSfprintf (FSFILE *fptr, const char * fmt, ...) 
.................... #endif 
.................... { 
....................     va_list ap; 
....................     int n; 
....................  
....................     va_start (ap, fmt); 
....................     n = FSvfprintf (fptr, fmt, ap); 
....................     va_end (ap); 
....................     return n; 
.................... } 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int FSvfprintf (FSFILE * handle, const char * formatString, va_list ap) 
....................     // PIC18 
....................     int FSvfpritnf (auto FSFILE * handle, auto const rom char * formatString, auto va_list ap) 
....................   Summary: 
....................     Helper function for FSfprintf 
....................   Conditions: 
....................     This function should not be called by the user. 
....................   Input: 
....................     handle -        A pointer to the file to write to. 
....................     formatString -  A string of characters and format specifiers to write to 
....................                     the file 
....................     ap -            A structure pointing to the arguments on the stack 
....................   Returns: 
....................     The number of characters written to the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This helper function will access the elements passed to FSfprintf 
....................   Remarks: 
....................     Consult AN1045 for a full description of how to use format 
....................     specifiers. 
....................   **********************************************************************/ 
....................  
.................... #ifdef __18CXX 
.................... int FSvfprintf (auto FSFILE *handle, auto const rom char * formatString, auto va_list ap) 
.................... #else 
.................... int FSvfprintf (FSFILE *handle, const char * formatString, va_list ap) 
.................... #endif 
.................... { 
....................     unsigned char c; 
....................     int count = 0; 
....................  
....................     for (c = *formatString; c; c = *++formatString) 
....................     { 
....................         if (c == '%') 
....................         { 
....................             unsigned char    flags = 0; 
....................             unsigned char    width = 0; 
....................             unsigned char    precision = 0; 
....................             unsigned char    have_precision = 0; 
....................             unsigned char    size = 0; 
.................... #ifndef __18CXX 
....................             unsigned char   size2 = 0; 
.................... #endif 
....................             unsigned char    space_cnt; 
....................             unsigned char    cval; 
.................... #ifdef __18CXX 
....................             unsigned long    larg; 
....................             far rom char *   romstring; 
.................... #else 
....................             unsigned long long larg; 
.................... #endif 
....................             char *         ramstring; 
....................             int n; 
....................  
....................             FSerrno = CE_GOOD; 
....................  
....................             c = *++formatString; 
....................  
....................             while ((c == '-') || (c == '+') || (c == ' ') || (c == '#') || (c == '0')) 
....................             { 
....................                 switch (c) 
....................                 { 
....................                     case '-': 
....................                         flags |= _FLAG_MINUS; 
....................                         break; 
....................                     case '+': 
....................                         flags |= _FLAG_PLUS; 
....................                         break; 
....................                     case ' ': 
....................                         flags |= _FLAG_SPACE; 
....................                         break; 
....................                     case '#': 
....................                         flags |= _FLAG_OCTO; 
....................                         break; 
....................                     case '0': 
....................                         flags |= _FLAG_ZERO; 
....................                         break; 
....................                 } 
....................                 c = *++formatString; 
....................             } 
....................             /* the optional width field is next */ 
....................             if (c == '*') 
....................             { 
....................                 n = va_arg (ap, int); 
....................                 if (n < 0) 
....................                 { 
....................                     flags |= _FLAG_MINUS; 
....................                     width = -n; 
....................                 } 
....................                 else 
....................                     width = n; 
....................                 c = *++formatString; 
....................             } 
....................             else 
....................             { 
....................                 cval = 0; 
....................                 while ((unsigned char) isdigit (c)) 
....................                 { 
....................                     cval = cval * 10 + c - '0'; 
....................                     c = *++formatString; 
....................                 } 
....................                 width = cval; 
....................             } 
....................  
....................             /* if '-' is specified, '0' is ignored */ 
....................             if (flags & _FLAG_MINUS) 
....................                 flags &= ~_FLAG_ZERO; 
....................  
....................             /* the optional precision field is next */ 
....................             if (c == '.') 
....................             { 
....................                 c = *++formatString; 
....................                 if (c == '*') 
....................                 { 
....................                     n = va_arg (ap, int); 
....................                     if (n >= 0) 
....................                     { 
....................                         precision = n; 
....................                         have_precision = 1; 
....................                     } 
....................                     c = *++formatString; 
....................                 } 
....................                 else 
....................                 { 
....................                     cval = 0; 
....................                     while ((unsigned char) isdigit (c)) 
....................                     { 
....................                         cval = cval * 10 + c - '0'; 
....................                         c = *++formatString; 
....................                     } 
....................                     precision = cval; 
....................                     have_precision = 1; 
....................                 } 
....................             } 
....................  
....................             /* the optional 'h' specifier. since int and short int are 
....................                 the same size for MPLAB C18, this is a NOP for us. */ 
....................             if (c == 'h') 
....................             { 
....................                 c = *++formatString; 
....................                 /* if 'c' is another 'h' character, this is an 'hh' 
....................                     specifier and the size is 8 bits */ 
....................                 if (c == 'h') 
....................                 { 
....................                     size = _FMT_BYTE; 
....................                     c = *++formatString; 
....................                 } 
....................             } 
....................             else if ((c == 't') || (c == 'z')) 
....................                 c = *++formatString; 
.................... #ifdef __18CXX 
....................             else if ((c == 'H') || (c == 'T') || (c == 'Z')) 
....................             { 
....................                 size = _FMT_SHRTLONG; 
....................                 c = *++formatString; 
....................             } 
....................             else if ((c == 'l') || (c == 'j')) 
.................... #else 
....................             else if ((c == 'q') || (c == 'j')) 
....................             { 
....................                 size = _FMT_LONGLONG; 
....................                 c = *++formatString; 
....................             } 
....................             else if (c == 'l') 
.................... #endif 
....................             { 
....................                 size = _FMT_LONG; 
....................                 c = *++formatString; 
....................             } 
....................  
....................             switch (c) 
....................             { 
....................                 case '\0': 
....................                 /* this is undefined behaviour. we have a trailing '%' character 
....................                     in the string, perhaps with some flags, width, precision 
....................                     stuff as well, but no format specifier. We'll, arbitrarily, 
....................                     back up a character so that the loop will terminate 
....................                     properly when it loops back and we'll output a '%' 
....................                     character. */ 
....................                     --formatString; 
....................                 /* fallthrough */ 
....................                 case '%': 
....................                     if (FSputc ('%', handle) == EOF) 
....................                     { 
....................                         FSerrno = CE_WRITE_ERROR; 
....................                         return EOF; 
....................                     } 
....................                     ++count; 
....................                     break; 
....................                 case 'c': 
....................                     space_cnt = 0; 
....................                     if (width > 1) 
....................                     { 
....................                         space_cnt = width - 1; 
....................                         count += space_cnt; 
....................                     } 
....................                     if (space_cnt && !(flags & _FLAG_MINUS)) 
....................                     { 
....................                         if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                         { 
....................                             FSerrno = CE_WRITE_ERROR; 
....................                             return EOF; 
....................                         } 
....................                         space_cnt = 0; 
....................                     } 
....................                     c = va_arg (ap, int); 
....................                     if (FSputc (c, handle) == EOF) 
....................                     { 
....................                         FSerrno = CE_WRITE_ERROR; 
....................                         return EOF; 
....................                     } 
....................                     ++count; 
....................                     if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                     { 
....................                         FSerrno = CE_WRITE_ERROR; 
....................                         return EOF; 
....................                     } 
....................                     break; 
....................                 case 'S': 
.................... #ifdef __18CXX 
....................                     if (size == _FMT_SHRTLONG) 
....................                         romstring = va_arg (ap, rom far char *); 
....................                     else 
....................                         romstring = (far rom char*)va_arg (ap, rom near char *); 
....................                     n = strlenpgm (romstring); 
....................                     /* Normalize the width based on the length of the actual 
....................                         string and the precision. */ 
....................                     if (have_precision && precision < (unsigned char) n) 
....................                         n = precision; 
....................                     if (width < (unsigned char) n) 
....................                         width = n; 
....................                     space_cnt = width - (unsigned char) n; 
....................                     count += space_cnt; 
....................                     /* we've already calculated the space count that the width 
....................                         will require. now we want the width field to have the 
....................                         number of character to display from the string itself, 
....................                         limited by the length of the actual string and the 
....................                         specified precision. */ 
....................                     if (have_precision && precision < width) 
....................                         width = precision; 
....................                     /* if right justified, we print the spaces before the 
....................                         string */ 
....................                     if (!(flags & _FLAG_MINUS)) 
....................                     { 
....................                         if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                         { 
....................                             FSerrno = CE_WRITE_ERROR; 
....................                             return EOF; 
....................                         } 
....................                         space_cnt = 0; 
....................                     } 
....................                     cval = 0; 
....................                     for (c = *romstring; c && cval < width; c = *++romstring) 
....................                     { 
....................                         if (FSputc (c, handle) == EOF) 
....................                         { 
....................                             FSerrno = CE_WRITE_ERROR; 
....................                             return EOF; 
....................                         } 
....................                         ++count; 
....................                         ++cval; 
....................                     } 
....................                     /* If there are spaces left, it's left justified. 
....................                         Either way, calling the function unconditionally 
....................                         is smaller code. */ 
....................                     if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                     { 
....................                         FSerrno = CE_WRITE_ERROR; 
....................                         return EOF; 
....................                     } 
....................                     break; 
.................... #endif 
....................                 case 's': 
....................                     ramstring = va_arg (ap, char *); 
....................                     n = strlen (ramstring); 
....................                     /* Normalize the width based on the length of the actual 
....................                         string and the precision. */ 
....................                     if (have_precision && precision < (unsigned char) n) 
....................                         n = precision; 
....................                     if (width < (unsigned char) n) 
....................                         width = n; 
....................                     space_cnt = width - (unsigned char) n; 
....................                     count += space_cnt; 
....................                     /* we've already calculated the space count that the width 
....................                         will require. now we want the width field to have the 
....................                         number of character to display from the string itself, 
....................                         limited by the length of the actual string and the 
....................                         specified precision. */ 
....................                     if (have_precision && precision < width) 
....................                         width = precision; 
....................                     /* if right justified, we print the spaces before the string */ 
....................                     if (!(flags & _FLAG_MINUS)) 
....................                     { 
....................                         if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                         { 
....................                             FSerrno = CE_WRITE_ERROR; 
....................                             return EOF; 
....................                         } 
....................                         space_cnt = 0; 
....................                     } 
....................                     cval = 0; 
....................                     for (c = *ramstring; c && cval < width; c = *++ramstring) 
....................                     { 
....................                         if (FSputc (c, handle) == EOF) 
....................                         { 
....................                             FSerrno = CE_WRITE_ERROR; 
....................                             return EOF; 
....................                         } 
....................                         ++count; 
....................                         ++cval; 
....................                     } 
....................                     /* If there are spaces left, it's left justified. 
....................                         Either way, calling the function unconditionally 
....................                         is smaller code. */ 
....................                     if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                     { 
....................                         FSerrno = CE_WRITE_ERROR; 
....................                         return EOF; 
....................                     } 
....................                     break; 
....................                 case 'd': 
....................                 case 'i': 
....................                     flags |= _FLAG_SIGNED; 
....................                 /* fall through */ 
....................                 case 'o': 
....................                 case 'u': 
....................                 case 'x': 
....................                 case 'X': 
....................                 case 'b': 
....................                 case 'B': 
....................                     /* This is a bit of a trick. The 'l' and 'hh' size 
....................                         specifiers are valid only for the integer conversions, 
....................                         not the 'p' or 'P' conversions, and are ignored for the 
....................                         latter. By jumping over the additional size specifier 
....................                         checks here we get the best code size since we can 
....................                         limit the size checks in the remaining code. */ 
....................                     if (size == _FMT_LONG) 
....................                     { 
....................                         if (flags & _FLAG_SIGNED) 
....................                             larg = va_arg (ap, long int); 
....................                         else 
....................                             larg = va_arg (ap, unsigned long int); 
....................                         goto _do_integer_conversion; 
....................                     } 
....................                     else if (size == _FMT_BYTE) 
....................                     { 
....................                         if (flags & _FLAG_SIGNED) 
....................                             larg = (signed char) va_arg (ap, int); 
....................                         else 
....................                             larg = (unsigned char) va_arg (ap, unsigned int); 
....................                         goto _do_integer_conversion; 
....................                     } 
.................... #ifndef __18CXX 
....................                     else if (size == _FMT_LONGLONG) 
....................                     { 
....................                         if (flags & _FLAG_SIGNED) 
....................                             larg = (signed long long)va_arg (ap, long long); 
....................                         else 
....................                             larg = (unsigned long long) va_arg (ap, unsigned long long); 
....................                         goto _do_integer_conversion; 
....................                     } 
.................... #endif 
....................                     /* fall trough */ 
....................                 case 'p': 
....................                 case 'P': 
.................... #ifdef __18CXX 
....................                     if (size == _FMT_SHRTLONG) 
....................                     { 
....................                         if (flags & _FLAG_SIGNED) 
....................                             larg = va_arg (ap, short long int); 
....................                         else 
....................                             larg = va_arg (ap, unsigned short long int); 
....................                     } 
....................                     else 
.................... #endif 
....................                         if (flags & _FLAG_SIGNED) 
....................                             larg = va_arg (ap, int); 
....................                         else 
....................                             larg = va_arg (ap, unsigned int); 
....................                     _do_integer_conversion: 
....................                         /* default precision is 1 */ 
....................                         if (!have_precision) 
....................                             precision = 1; 
....................                         { 
....................                             unsigned char digit_cnt = 0; 
....................                             unsigned char prefix_cnt = 0; 
....................                             unsigned char sign_char; 
....................                             /* A 32 bit number will require at most 32 digits in the 
....................                                 string representation (binary format). */ 
.................... #ifdef __18CXX 
....................                             char buf[33]; 
....................                             /* Start storing digits least-significant first */ 
....................                             char *q = &buf[31]; 
....................                             /* null terminate the string */ 
....................                             buf[32] = '\0'; 
.................... #else 
....................                             char buf[65]; 
....................                             char *q = &buf[63]; 
....................                             buf[64] = '\0'; 
.................... #endif 
....................                             space_cnt = 0; 
....................                             size = 10; 
....................  
....................                             switch (c) 
....................                             { 
....................                                 case 'b': 
....................                                 case 'B': 
....................                                     size = 2; 
.................... #ifndef __18CXX 
....................                                     size2 = 1; 
.................... #endif 
....................                                     break; 
....................                                 case 'o': 
....................                                     size = 8; 
.................... #ifndef __18CXX 
....................                                     size2 = 3; 
.................... #endif 
....................                                     break; 
....................                                 case 'p': 
....................                                 case 'P': 
....................                                     /* from here on out, treat 'p' conversions just 
....................                                         like 'x' conversions. */ 
....................                                     c += 'x' - 'p'; 
....................                                 /* fall through */ 
....................                                 case 'x': 
....................                                 case 'X': 
....................                                     size = 16; 
.................... #ifndef __18CXX 
....................                                     size2 = 4; 
.................... #endif 
....................                                     break; 
....................                             }// switch (c) 
....................  
....................                             /* if it's an unsigned conversion, we should ignore the 
....................                                 ' ' and '+' flags */ 
....................                             if (!(flags & _FLAG_SIGNED)) 
....................                                 flags &= ~(_FLAG_PLUS | _FLAG_SPACE); 
....................  
....................                             /* if it's a negative value, we need to negate the 
....................                                 unsigned version before we convert to text. Using 
....................                                 unsigned for this allows us to (ab)use the 2's 
....................                                 complement system to avoid overflow and be able to 
....................                                 adequately handle LONG_MIN. 
....................  
....................                                 We'll figure out what sign character to print, if 
....................                                 any, here as well. */ 
.................... #ifdef __18CXX 
....................                             if (flags & _FLAG_SIGNED && ((long) larg < 0)) 
....................                             { 
....................                                 larg = -(long) larg; 
.................... #else 
....................                             if (flags & _FLAG_SIGNED && ((long long) larg < 0)) 
....................                             { 
....................                                 larg = -(long long) larg; 
.................... #endif 
....................                                 sign_char = '-'; 
....................                                 ++digit_cnt; 
....................                             } 
....................                             else if (flags & _FLAG_PLUS) 
....................                             { 
....................                         sign_char = '+'; 
....................                         ++digit_cnt; 
....................                      } 
....................                       else if (flags & _FLAG_SPACE) 
....................                       { 
....................                                 sign_char = ' '; 
....................                                 ++digit_cnt; 
....................                             } 
....................                             else 
....................                                 sign_char = '\0'; 
....................                             /* get the digits for the actual number. If the 
....................                                 precision is zero and the value is zero, the result 
....................                                 is no characters. */ 
....................                             if (precision || larg) 
....................                             { 
....................                                 do 
....................                                 { 
.................... #ifdef __18CXX 
....................                                     cval = s_digits[larg % size]; 
....................                                     if ((c == 'X') && (cval >= 'a')) 
....................                                         cval -= 'a' - 'A'; 
....................                                     larg /= size; 
.................... #else 
....................                                     // larg is congruent mod size2 to its lower 16 bits 
....................                                     // for size2 = 2^n, 0 <= n <= 4 
....................                                     if (size2 != 0) 
....................                                         cval = s_digits[(unsigned int) larg % size]; 
....................                                     else 
....................                                         cval = s_digits[larg % size]; 
....................                                     if ((c == 'X') && (cval >= 'a')) 
....................                                         cval -= 'a' - 'A'; 
....................                                     if (size2 != 0) 
....................                                         larg = larg >> size2; 
....................                                     else 
....................                                         larg /= size; 
.................... #endif 
....................                                     *q-- = cval; 
....................                                     ++digit_cnt; 
....................                                 } while (larg); 
....................                                 /* if the '#' flag was specified and we're dealing 
....................                                     with an 'o', 'b', 'B', 'x', or 'X' conversion, 
....................                                     we need a bit more. */ 
....................                                 if (flags & _FLAG_OCTO) 
....................                                 { 
....................                                     if (c == 'o') 
....................                                     { 
....................                                         /* per the standard, for octal, the '#' flag 
....................                                             makes the precision be at least one more 
....................                                             than the number of digits in the number */ 
....................                                         if (precision <= digit_cnt) 
....................                                             precision = digit_cnt + 1; 
....................                                     } 
....................                                     else if ((c == 'x') || (c == 'X') || (c == 'b') || (c == 'B')) 
....................                                         prefix_cnt = 2; 
....................                                 } 
....................                             } 
....................                             else 
....................                                 digit_cnt = 0; 
....................  
....................                             /* The leading zero count depends on whether the '0' 
....................                                 flag was specified or not. If it was not, then the 
....................                                 count is the difference between the specified 
....................                                 precision and the number of digits (including the 
....................                                 sign character, if any) to be printed; otherwise, 
....................                                 it's as if the precision were equal to the max of 
....................                                 the specified precision and the field width. If a 
....................                                 precision was specified, the '0' flag is ignored, 
....................                                 however. */ 
....................                             if ((flags & _FLAG_ZERO) && (width > precision) 
....................                                 && !have_precision) 
....................                                 precision = width; 
....................                             /* for the rest of the processing, precision contains 
....................                                 the leading zero count for the conversion. */ 
....................                             if (precision > digit_cnt) 
....................                                 precision -= digit_cnt; 
....................                             else 
....................                                 precision = 0; 
....................                             /* the space count is the difference between the field 
....................                                 width and the digit count plus the leading zero 
....................                                 count. If the width is less than the digit count 
....................                                 plus the leading zero count, the space count is 
....................                                 zero. */ 
....................                             if (width > precision + digit_cnt + prefix_cnt) 
....................                                 space_cnt =   width - precision - digit_cnt - prefix_cnt; 
....................  
....................                             /* for output, we check the justification, if it's 
....................                                 right justified and the space count is positive, we 
....................                                 emit the space characters first. */ 
....................                             if (!(flags & _FLAG_MINUS) && space_cnt) 
....................                             { 
....................                                 if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                                 { 
....................                                     FSerrno = CE_WRITE_ERROR; 
....................                                     return EOF; 
....................                                 } 
....................                                 count += space_cnt; 
....................                                 space_cnt = 0; 
....................                             } 
....................                             /* if we have a sign character to print, that comes 
....................                                 next */ 
....................                             if (sign_char) 
....................                                 if (FSputc (sign_char, handle) == EOF) 
....................                                 { 
....................                                     FSerrno = CE_WRITE_ERROR; 
....................                                     return EOF; 
....................                                 } 
....................                             /* if we have a prefix (0b, 0B, 0x or 0X), that's next */ 
....................                             if (prefix_cnt) 
....................                             { 
....................                                 if (FSputc ('0', handle) == EOF) 
....................                                 { 
....................                                     FSerrno = CE_WRITE_ERROR; 
....................                                     return EOF; 
....................                                 } 
....................                                 if (FSputc (c, handle) == EOF) 
....................                                 { 
....................                                     FSerrno = CE_WRITE_ERROR; 
....................                                     return EOF; 
....................                                 } 
....................                             } 
....................                             /* if we have leading zeros, they follow. the prefix, if any 
....................                                 is included in the number of digits when determining how 
....................                                 many leading zeroes are needed. */ 
.................... //                            if (precision > prefix_cnt) 
....................   //                              precision -= prefix_cnt; 
....................                             if (str_put_n_chars (handle, precision, '0')) 
....................                             { 
....................                                 FSerrno = CE_WRITE_ERROR; 
....................                                 return EOF; 
....................                             } 
....................                             /* print the actual number */ 
....................                             for (cval = *++q; cval; cval = *++q) 
....................                                 if (FSputc (cval, handle) == EOF) 
....................                                 { 
....................                                     FSerrno = CE_WRITE_ERROR; 
....................                                     return EOF; 
....................                                 } 
....................                             /* if there are any spaces left, they go to right-pad 
....................                                 the field */ 
....................                             if (str_put_n_chars (handle, space_cnt, ' ')) 
....................                             { 
....................                                 FSerrno = CE_WRITE_ERROR; 
....................                                 return EOF; 
....................                             } 
....................  
....................                             count += precision + digit_cnt + space_cnt + prefix_cnt; 
....................                         } 
....................                         break; 
....................                 case 'n': 
....................                     switch (size) 
....................                     { 
....................                         case _FMT_LONG: 
....................                             *(long *) va_arg (ap, long *) = count; 
....................                             break; 
.................... #ifdef __18CXX 
....................                         case _FMT_SHRTLONG: 
....................                             *(short long *) va_arg (ap, short long *) = count; 
....................                             break; 
.................... #else 
....................                         case _FMT_LONGLONG: 
....................                             *(long long *) va_arg (ap, long long *) = count; 
....................                             break; 
.................... #endif 
....................                         case _FMT_BYTE: 
....................                             *(signed char *) va_arg (ap, signed char *) = count; 
....................                             break; 
....................                         default: 
....................                             *(int *) va_arg (ap, int *) = count; 
....................                             break; 
....................                     } 
....................                     break; 
....................                 default: 
....................                     /* undefined behaviour. we do nothing */ 
....................                     break; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if (FSputc (c, handle) == EOF) 
....................             { 
....................                 FSerrno = CE_WRITE_ERROR; 
....................                 return EOF; 
....................             } 
....................             ++count; 
....................         } 
....................     } 
....................     return count; 
.................... } 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #if defined(USE_SD_INTERFACE_WITH_SPI) 
.................... #include "sd-spi.c" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        SD-SPI.c 
....................  * Dependencies:    SD-SPI.h 
....................  *                  string.h 
....................  *                  FSIO.h 
....................  *                  FSDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the "Company") for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... ***************************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev     Description 
....................   -----   ----------- 
....................   1.2.5   Fixed bug in the calculation of the capacity for v1.0 devices 
....................   1.3.0   Improved media initialization sequence, for better card compatibility 
....................           (especially with SDHC cards). 
....................           Implemented SPI optimizations for data transfer rate improvement. 
....................           Added new MDD_SDSPI_AsyncReadTasks() and MDD_SDSPI_AsyncWriteTasks()  
....................           API functions.  These are non-blocking, state machine based read/write 
....................           handlers capable of considerably improved data throughput, particularly 
....................           for multi-block reads and multi-block writes. 
....................   1.3.2   Modified MDD_SDSPI_AsyncWriteTasks() so pre-erase command only gets 
....................           used for multi-block write scenarios.    
....................   1.3.4   1) Added support for dsPIC33E & PIC24E controllers. 
....................           2) #include "HardwareProfile.h" is moved up in the order. 
....................           3) "SPI_INTERRUPT_FLAG_ASM" macro has to be defined in "HardwareProfile.h" file 
....................              for PIC18 microcontrollers.Or else an error is generated while building 
....................              the code. 
....................                        "#define SPI_INTERRUPT_FLAG_ASM  PIR1, 3" is removed from SD-SPI.c 
....................           4) Replaced "__C30" usage with "__C30__" . 
....................   1.3.6   1) Modified "FSConfig.h" to "FSconfig.h" in '#include' directive. 
....................           2) Moved 'spiconvalue' variable definition to only C30 usage, as C32 
....................              is not using it. 
....................           3) Modified 'MDD_SDSPI_MediaDetect' function to ensure that CMD0 is sent freshly 
....................              after CS is asserted low. This minimizes the risk of SPI clock pulse master/slave 
....................              syncronization problems. 
....................  
.................... ********************************************************************/ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *					dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *					Microchip C30 v3.01 or higher 
....................  *					Microchip C18 v3.13 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006	Original, copied from old Compiler.h 
....................  * 11/07/2007	Reorganized and simplified 
....................  * 03/31/2010	Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__PCH__) 
....................    #include <p18cxxx.h> 
.................... #elif defined(__PCD__) 
....................    #include <..\CCSIncludes\PCDxxxx.h> 
.................... #elif defined(__18CXX) && !defined(HI_TECH_C)	 
.................... 	// PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)	 
.................... 	// PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
.................... 	#if !defined(__18CXX) 
.................... 		#define __18CXX 
.................... 	#endif 
....................     #define COMPILER_HITECH_PICC18 
.................... 	#include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)	// Microchip C30 compiler 
.................... 	// dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p30fxxxx.h> 
.................... #elif defined(__C30__)		// Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
.................... 	#include <p30sim.h> 
.................... 	// Define some useful inline assembly functions which are normally in the  
.................... 	// processor header files, but absent from the generic p30sim.h file. 
.................... 	#if !defined(Nop) 
.................... 		#define Nop()    __builtin_nop() 
.................... 		#define ClrWdt() {__asm__ volatile ("clrwdt");} 
.................... 		#define Sleep()  {__asm__ volatile ("pwrsav #0");} 
.................... 		#define Idle()   {__asm__ volatile ("pwrsav #1");} 
.................... 	#endif 
.................... #elif defined(__PIC32MX__)	// Microchip C32 compiler 
.................... 	#if !defined(__C32__) 
.................... 		#define __C32__ 
.................... 	#endif 
....................     #define COMPILER_MPLAB_C32 
.................... 	#include <p32xxxx.h> 
.................... 	#include <plib.h> 
.................... #else 
.................... 	#error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
.................... #include <string.h> 
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PIC32MX__) 
.................... 	#define PTR_BASE		unsigned long 
.................... 	#define ROM_PTR_BASE	unsigned long 
.................... #elif defined(__C30__) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
.................... 	#define PTR_BASE		unsigned short 
.................... 	#define ROM_PTR_BASE	unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
.................... 	#define memcmppgm2ram(a,b,c)	memcmp(a,b,c) 
.................... 	#define strcmppgm2ram(a,b)		strcmp(a,b) 
.................... 	#define memcpypgm2ram(a,b,c)	memcpy(a,b,c) 
.................... 	#define strcpypgm2ram(a,b)		strcpy(a,b) 
.................... 	#define strncpypgm2ram(a,b,c)	strncpy(a,b,c) 
.................... 	#define strstrrampgm(a,b)		strstr(a,b) 
.................... 	#define	strlenpgm(a)			strlen(a) 
.................... 	#define strchrpgm(a,b)			strchr(a,b) 
.................... 	#define strcatpgm2ram(a,b)		strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
.................... 	#define	__attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
.................... 	// Microchip C18 specific defines 
.................... 	#if defined(COMPILER_MPLAB_C18) 
.................... 	    #define ROM                 	rom 
.................... 	#endif 
.................... 	 
.................... 	// HI TECH PICC-18 specific defines 
.................... 	#if defined(COMPILER_HITECH_PICC18) 
.................... 	    #define ROM                 	const 
.................... 		#define rom 
.................... 	    #define Nop()               	asm("NOP"); 
.................... 		#define ClrWdt()				asm("CLRWDT"); 
.................... 	    #define Reset()					asm("RESET"); 
.................... 	#endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
.................... 	#define	ROM						const 
....................  
.................... 	// 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
.................... 	#if defined(__C30__) 
.................... 		#define Reset()				asm("reset") 
....................         #define FAR                 __attribute__((far)) 
.................... 	#endif 
....................  
.................... 	// 32-bit specific defines (PIC32) 
.................... 	#if defined(__PIC32MX__) 
.................... 		#define persistent 
.................... 		#define far 
....................         #define FAR 
.................... 		#define Reset()				SoftReset() 
.................... 		#define ClrWdt()			(WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
.................... 		// MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
.................... 		// Nop() function. However, version 1.05 has Nop() declared as _nop(). 
.................... 		#if !defined(Nop) && (__C32_VERSION__ <= 104) 
.................... 			#define Nop()				asm("nop") 
.................... 		#endif 
.................... 	#endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "HardwareProfile.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        HardwareProfile.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _MDD_HARDWAREPROFILE_H_ 
.................... #define _MDD_HARDWAREPROFILE_H_ 
....................  
.................... /*********************************************************************/ 
.................... /******************* Pin and Register Definitions ********************/ 
.................... /*********************************************************************/ 
....................  
.................... /* SD Card definitions: Change these to fit your application when using 
....................    an SD-card-based physical layer                                   */ 
.................... /* 
.................... #if (defined(HW_CCS_3V_ETHERNET)||defined(HW_CCS_46K20)) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)) 
.................... //CCS 18F67J60 3.3V Ethernet development kit with SD card 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................          
....................         // Chip Select Signal 
....................         #define SD_CS               PORTCbits.RC2 
....................         #define SD_CS_TRIS          TRISCbits.TRISC2 
....................          
....................         // Card detect signal 
....................         #define SD_CD               PORTEbits.RE5 
....................         #define SD_CD_TRIS          TRISEbits.TRISE5 
....................          
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................          
....................         // Defines for the HPC Explorer board 
....................         #define SPICLOCK            TRISCbits.TRISC3 
....................         #define SPIIN               TRISCbits.TRISC4 
....................         #define SPIOUT              TRISCbits.TRISC5 
....................      
....................         // Latch pins for SCK/SDI/SDO lines 
....................         #define SPICLOCKLAT         LATCbits.LATC3 
....................         #define SPIINLAT            LATCbits.LATC4 
....................         #define SPIOUTLAT           LATCbits.LATC5 
....................      
....................         // Port pins for SCK/SDI/SDO lines 
....................         #define SPICLOCKPORT        PORTCbits.RC3 
....................         #define SPIINPORT           PORTCbits.RC4 
....................         #define SPIOUTPORT          PORTCbits.RC5 
....................  
....................         // Registers for the SPI module you want to use 
....................         #define SPICON1             SSP1CON1 
....................         #define SPISTAT             SSP1STAT 
....................         #define SPIBUF              SSP1BUF 
....................         #define SPICON1bits         SSP1CON1bits 
....................         #define SPISTATbits         SSP1STATbits 
....................          
....................         #define PIR1_LOC   getenv("SFR:PIR1") 
....................         //#define SPI_INTERRUPT_FLAG_ASM PIR1_LOC,3 
....................         #define SPI_INTERRUPT_FLAG_ASM PIR1,3 
....................  
....................        //set SPI_INTERRUPT_FLAG to SPI1 interrupt flag. 
....................        //some PICs this bit is defined as SSP1IF and some PICs this is defined 
....................        //as SSPIF. 
....................         #if getenv("BIT_VALID:SSP1IF") 
....................          #bit SPI_INTERRUPT_FLAG=getenv("BIT:SSP1IF") 
....................         #else 
....................          #bit SPI_INTERRUPT_FLAG=getenv("BIT:SSPIF") 
....................         #endif 
....................      
....................         #define SPIENABLE           SPICON1bits.SSPEN 
.................... #endif   //HW_CCS_3V_ETHERNET 
....................  
.................... // ccs dsp analog board with (33hj) sd connector 
.................... #if defined(HW_CCS_DSP_AUDIO) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATDbits.LATD8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISDbits.TRISD8 
....................                  
....................          //NO SD_CD or SD_CD_TRIS 
....................          #define MEDIA_SOFT_DETECT 
....................  
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI2CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI2STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI2BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI2STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI2STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI2CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI2STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISFbits.TRISF4 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISFbits.TRISF5 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISBbits.TRISB15 
.................... #endif 
....................  
.................... // ccs dsp analog board (33ep) with sd connector 
.................... #if defined(HW_CCS_DSP_AUDIO2) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATDbits.LATD8 //PIN_D8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISDbits.TRISD8 
....................         #define SD_CS_ANSEL         ANSELEbits.ANSE8 
....................          
....................          //NO SD_CD or SD_CD_TRIS   //PIN_E1 
....................          #define SD_CD              PORTEbits.RE1 
....................          #define SD_CD_TRIS              TRISEbits.TRISE1 
....................  
....................         // no write enable pin 
....................         int1 SD_WE_TRIS; 
....................         #define SD_WE   FALSE 
....................  
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI1CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI1STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI1BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI1STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI1STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI1CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI1STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISGbits.TRISG6 
....................         #define SD_SCK_ANSEL        ANSELGbits.ANSG6 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISGbits.TRISG7 
....................         #define SD_SDI_ANSEL        ANSELGbits.ANSG7 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISGbits.TRISG8 
....................         #define SD_SDO_ANSEL        ANSELGbits.ANSG8 
.................... #endif 
....................  
.................... #if defined(HW_CCS_DSP_AUDIO) && defined(USE_SST25_INTERFACE) 
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
....................         #define GetSystemClock() getenv("CLOCK") 
....................         #define GetPeripheralClock()    GetSystemClock() 
....................         #define GetInstructionClock()   (GetSystemClock() / 2) 
....................          
....................         //chip select pin of SST25 
....................         #define FLASH_SELECT_PIN PIN_F1 
....................          
....................         //configure sst25 library spi stream 
....................         #use spi(SPI2, MODE=0, BITS=8, baud=1000000, STREAM=SPI_SST25, FORCE_HW) 
....................         #define FLASH_STREAM SPI_SST25 
.................... #endif 
....................  
.................... */ 
.................... #if defined(HW_CCS_PIC24USB) && (!defined(USE_SD_INTERFACE_WITH_SPI)&&!defined(USE_CF_INTERFACE_WITH_PMP)&&!defined(USE_MANUAL_CF_INTERFACE)&&!defined(USE_USB_INTERFACE)&&!defined(USE_SST25_INTERFACE)) 
.................... // ccs dsp analog board with sd connector 
....................  
....................          // Select your interface type 
....................          // This library currently only supports a single physical interface layer at a time 
....................          // Description: Macro used to enable the SD-SPI physical layer (SD-SPI.c and .h) 
....................          #define USE_SD_INTERFACE_WITH_SPI 
....................          // Description: Macro used to enable the CF-PMP physical layer (CF-PMP.c and .h) 
....................          //#define USE_CF_INTERFACE_WITH_PMP 
....................          // Description: Macro used to enable the CF-Manual physical layer (CF-Bit transaction.c and .h)                                                                 
....................          //#define USE_MANUAL_CF_INTERFACE 
....................          // Description: Macro used to enable the USB Host physical layer (USB host MSD library) 
....................          //#define USE_USB_INTERFACE 
....................  
....................  
....................         //unless you are doing something exotic, you can use the following 
....................         //definitions for all hardware - it will get clock speed from your 
....................         //#use delay() statement. 
.................... //        #define GetSystemClock() getenv("CLOCK") 
....................  //       #define GetPeripheralClock()    GetSystemClock() 
....................   //      #define GetInstructionClock()   (GetSystemClock() / 2) 
....................         
....................         // Description: SD-SPI Chip Select Output bit 
....................         #define SD_CS            LATGbits.LATG8      //pin_G8 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         #define SD_CS_TRIS          TRISGbits.TRISG8 
....................  
.................... //This is the old setup  December 30, 2014 
....................         // Description: SD-SPI Chip Select Output bit 
....................         //#define SD_CS            LATBbits.LATB14      //pin_b14 
....................         // Description: SD-SPI Chip Select TRIS bit 
....................         //#define SD_CS_TRIS          TRISBbits.TRISB14 
....................  
....................         #define SD_CD            PORTBbits.RB12      //pin_b12 
....................         #define SD_CD_TRIS          TRISBbits.TRISB12 
....................  
....................          //NO SD_WE_TRIS         
....................          int1 SD_WE_TRIS; 
....................          int1 SD_WE=0; 
....................  
....................         // Registers for the SPI module you want to use 
....................  
....................         // Description: The main SPI control register 
....................         #define SPICON1             SPI1CON1 
....................         // Description: The SPI status register 
....................         #define SPISTAT             SPI1STAT 
....................         // Description: The SPI Buffer 
....................         #define SPIBUF              SPI1BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         #define SPISTAT_RBF         SPI1STATbits.SPIRBF 
....................         #define SPISTAT_TBF         SPI1STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         #define SPICON1bits         SPI1CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         #define SPISTATbits         SPI1STATbits 
....................         // Description: The enable bit for the SPI module 
....................         #define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The main SPI control register 
....................         //#define SPICON1             SPI2CON1 
....................         // Description: The SPI status register 
....................         //#define SPISTAT             SPI2STAT 
....................         // Description: The SPI Buffer 
....................         //#define SPIBUF              SPI2BUF 
....................         // Description: The receive buffer full bit in the SPI status register 
....................         //#define SPISTAT_RBF         SPI2STATbits.SPIRBF 
....................         //#define SPISTAT_TBF         SPI2STATbits.SPITBF 
....................         // Description: The bitwise define for the SPI control register (i.e. _____bits) 
....................         //#define SPICON1bits         SPI2CON1bits 
....................         // Description: The bitwise define for the SPI status register (i.e. _____bits) 
....................         //#define SPISTATbits         SPI2STATbits 
....................         // Description: The enable bit for the SPI module 
....................         //#define SPIENABLE           SPISTATbits.SPIEN 
....................  
....................  
....................  
....................         // Tris pins for SCK/SDI/SDO lines 
....................  
....................  
....................        // Description: The TRIS bit for the SCK pin 
....................         #define SPICLOCK            TRISFbits.TRISF3 
....................         // Description: The TRIS bit for the SDI pin 
....................         #define SPIIN               TRISFbits.TRISF6 
....................         // Description: The TRIS bit for the SDO pin 
....................         #define SPIOUT              TRISFbits.TRISF2 
....................  
....................  
.................... //This is the orginal settings   This is the old setup  December 31, 2014 
....................  
....................         // Description: The TRIS bit for the SCK pin 
....................         //#define SPICLOCK            TRISGbits.TRISG6 
....................         // Description: The TRIS bit for the SDI pin 
....................         //#define SPIIN               TRISGbits.TRISG7 
....................         // Description: The TRIS bit for the SDO pin 
....................         //#define SPIOUT              TRISGbits.TRISG8 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "MDD File System/FSIO.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSIO.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  *                  FSconfig.h 
....................  *                  FSDefs.h 
....................  *                  stddef.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.4.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  FS_DOT_H 
.................... #define  FS_DOT_H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... #include "../FSconfig.h" 
.................... #include "FSDefs.h"  
.................... #include "stddef.h" 
....................  
.................... #ifdef USE_SD_INTERFACE_WITH_SPI 
....................     #include    "SD-SPI.h" 
.................... #endif 
.................... #ifdef USE_CF_INTERFACE_WITH_PMP 
....................     #include    "CF-PMP.h" 
.................... #endif 
.................... #ifdef USE_MANUAL_CF_INTERFACE 
....................     #include    "CF- Bit transaction.h" 
.................... #endif 
.................... #ifdef USE_USB_INTERFACE 
....................     #include    "usb_host_msd_scsi.h" 
.................... #endif 
.................... #ifdef USE_INTERNAL_FLASH 
....................     #include    "Internal Flash.h" 
.................... #endif 
....................  
....................  
.................... /*******************************************************************/ 
.................... /*                     Strunctures and defines                     */ 
.................... /*******************************************************************/ 
....................  
.................... #ifndef FALSE 
....................     // Summary: False value 
....................     // Description:  This macro will indicate that a condition is false. 
....................     #define FALSE   0 
.................... #endif 
.................... #ifndef TRUE 
....................     // Summary: True value 
....................     // Description: This macro will indicate that a condition is true. 
....................     #define TRUE    !FALSE  // True value 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #ifndef SEEK_SET 
....................     // Summary: Macro for the FSfseek SEEK_SET base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed  
....................     //              relative to the beginning of the file. 
....................     #define SEEK_SET 0 
....................  
.................... #endif 
.................... #ifndef SEEK_CUR 
....................  
....................     // Summary: Macro for the FSfseek SEEK_CUR base location. 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the current location of the file 
....................     #define SEEK_CUR 1 
....................  
.................... #endif 
.................... #ifndef SEEK_END 
....................  
....................     // Summary: Macro for the FSfseek SEEK_END base location 
....................     // Description: Functions as an input for FSfseek that specifies that the position in the file will be changed 
....................     //              relative to the end of the file.  For this macro, the offset value will be subtracted from 
....................     //              the end location of the file by default. 
....................     #define SEEK_END 2 
....................  
.................... #endif 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file. 
.................... #define FS_APPEND   "a" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file. 
.................... #define FS_WRITE    "w" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file. 
.................... #define FS_READ "r" 
....................  
.................... // Summary: Macro for the FSfopen FS_APPEND+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it's file information will be loaded and the 
.................... //              current location in the file will be set to the end.  The user will then be able to write to the file 
.................... //              or read from the file. 
.................... #define FS_APPENDPLUS   "a+" 
....................  
.................... // Summary: Macro for the FSfopen FS_WRITE+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file being opened will 
.................... //              be created if it doesn't exist.  If it does exist, it will be erased and replaced by an empty file 
.................... //              of the same name.  The user will then be able to write to the file or read from the file. 
.................... #define FS_WRITEPLUS    "w+" 
....................  
.................... // Summary: Macro for the FSfopen FS_READ+ mode 
.................... // Description: If this macro is specified as the mode argument in a call of FSfopen, the file information for the  
.................... //              specified file will be loaded.  If the file does not exist, the FSfopen function will fail.  The user  
.................... //              will then be able to read from the file or write to the file. 
.................... #define FS_READPLUS     "r+" 
....................  
.................... #ifndef intmax_t 
....................     #ifdef __PIC24F__ 
....................         // Summary: A data type indicating the maximum integer size in an architecture 
....................         // Description: The intmax_t data type refers to the maximum-sized data type on any given architecture.  This 
....................         //              data type can be specified as a format specifier size specification for the FSfprintf function. 
....................         #define intmax_t long long 
....................     #elif defined __PIC24H__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC30F__ 
....................         #define intmax_t long long 
....................     #elif defined __dsPIC33F__ 
....................         #define intmax_t long long 
....................     #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary:  Indicates flag conditions for a file object 
.................... // Description: The FILEFLAGS structure is used to indicate conditions in a file.  It contains three flags: 'write' indicates 
.................... //              that the file was opened in a mode that allows writes, 'read' indicates that the file was opened in a mode 
.................... //              that allows reads, and 'FileWriteEOF' indicates that additional data that is written to the file will increase 
.................... //              the file size. 
.................... typedef struct 
.................... { 
....................     unsigned    write :1;           // Indicates a file was opened in a mode that allows writes 
....................     unsigned    read :1;            // Indicates a file was opened in a mode that allows reads 
....................     unsigned    FileWriteEOF :1;    // Indicates the current position in a file is at the end of the file 
.................... }FILEFLAGS; 
....................  
....................  
....................  
.................... // Summary: Indicates how to search for file entries in the FILEfind function 
.................... // Description: The values in the SEARCH_TYPE enumeration are used internally by the library to indicate how the FILEfind function 
.................... //              how to perform a search.  The 'LOOK_FOR_EMPTY_ENTRY' value indicates that FILEfind should search for an empty file entry. 
.................... //              The 'LOOK_FOR_MATCHING_ENTRY' value indicates that FILEfind should search for an entry that matches the FSFILE object 
.................... //              that was passed into the FILEfind function. 
.................... typedef enum{ 
....................     LOOK_FOR_EMPTY_ENTRY = 0, 
....................     LOOK_FOR_MATCHING_ENTRY 
.................... } SEARCH_TYPE; 
....................  
....................  
....................  
.................... // Summary: Macro indicating the length of a 8.3 file name 
.................... // Description: The TOTAL_FILE_SIZE_8P3 macro indicates the maximum number of characters in an 8.3 file name.  This value includes 
.................... //              8 characters for the name, three for the extentsion, and 1 for the radix ('.') 
.................... #define TOTAL_FILE_SIZE_8P3             (8+3+1) 
.................... #define TOTAL_FILE_SIZE                 TOTAL_FILE_SIZE_8P3 
....................  
.................... // Summary: Macro indicating the max length of a LFN file name 
.................... // Description: The MAX_FILE_NAME_LENGTH_LFN macro indicates the maximum number of characters in an LFN file name. 
.................... #define MAX_FILE_NAME_LENGTH_LFN             256 
....................  
.................... // Summary: A mask that indicates the limit of directory entries in a sector 
.................... // Description: The MASK_MAX_FILE_ENTRY_LIMIT_BITS is used to indicate to the Cache_File_Entry function that a new sector needs to 
.................... //              be loaded. 
.................... #define MASK_MAX_FILE_ENTRY_LIMIT_BITS          0x0f 
....................  
.................... // Summary: Value used for shift operations to calculate the sector offset in a directory 
.................... // Description: The VALUE_BASED_ON_ENTRIES_PER_CLUSTER macro is used to calculate sector offsets for directories.  The position of the 
.................... //              entry is shifted by 4 bits (divided by 16, since there are 16 entries in a sector) to calculate how many sectors a 
.................... //              specified entry is offset from the beginning of the directory. 
.................... #define VALUE_BASED_ON_ENTRIES_PER_CLUSTER      4 
....................  
.................... // Summary: A value that will indicate that a dotdot directory entry points to the root. 
.................... // Description: The VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT macro is used as an absolute address when writing information to a dotdot entry 
.................... //              in a newly created directory.  If a dotdot entry points to the root directory, it's cluster value must be set to 0, 
.................... //              regardless of the actual cluster number of the root directory. 
.................... #define VALUE_DOTDOT_CLUSTER_VALUE_FOR_ROOT     0 
....................  
.................... // Summary: MAcro indicating the length of an 8.3 file name in a directory entry 
.................... // Description: The FILE_NAME_SIZE_8P3 macro indicates the number of characters that an 8.3 file name will take up when packed in 
.................... //              a directory entry.  This value includes 8 characters for the name and 3 for the extension.  Note that the radix is not 
.................... //              stored in the directory entry. 
.................... #define FILE_NAME_SIZE_8P3           11 
.................... #define FILE_NAME_SIZE               FILE_NAME_SIZE_8P3 
....................  
....................  
.................... // Summary: Contains file information and is used to indicate which file to access. 
.................... // Description: The FSFILE structure is used to hold file information for an open file as it's being modified or accessed.  A pointer to  
.................... //              an open file's FSFILE structure will be passeed to any library function that will modify that file. 
.................... typedef struct 
.................... { 
....................     DISK    *       dsk;            // Pointer to a DISK structure 
....................     DWORD           cluster;        // The first cluster of the file 
....................     DWORD           ccls;           // The current cluster of the file 
....................     WORD            sec;            // The current sector in the current cluster of the file 
....................     WORD            pos;            // The position in the current sector 
....................     DWORD           seek;           // The absolute position in the file 
....................     DWORD           size;           // The size of the file 
....................     FILEFLAGS       flags;          // A structure containing file flags 
....................     WORD            time;           // The file's last update time 
....................     WORD            date;           // The file's last update date 
....................     char            name[FILE_NAME_SIZE_8P3];       // The short name of the file 
....................    #ifdef SUPPORT_LFN 
....................        BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNptr;           // Pointer to long file name in UTF16 format 
....................       unsigned short int utf16LFNlength;          // LFN length in terms of words excluding the NULL word at the last. 
....................    #endif 
....................     WORD            entry;          // The position of the file's directory entry in it's directory 
....................     WORD            chk;            // File structure checksum 
....................     WORD            attributes;     // The file attributes 
....................     DWORD           dirclus;        // The base cluster of the file's directory 
....................     DWORD           dirccls;        // The current cluster of the file's directory 
.................... } FSFILE; 
....................  
.................... /* Summary: Possible results of the FSGetDiskProperties() function. 
.................... ** Description: See the FSGetDiskProperties() function for more information. 
.................... */ 
.................... typedef enum 
.................... { 
....................     FS_GET_PROPERTIES_NO_ERRORS = 0, 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED, 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE, 
....................     FS_GET_PROPERTIES_STILL_WORKING = 0xFF 
.................... } FS_DISK_ERRORS; 
....................  
....................  
.................... /* Summary: Contains the disk search information, intermediate values, and results 
.................... ** Description: This structure is used in conjunction with the FSGetDiskProperties() 
.................... **              function.  See that function for more information about the usage. 
.................... */ 
.................... typedef struct 
.................... { 
....................     DISK *  disk;           /* pointer to the disk we are searching */ 
....................     BOOL    new_request;    /* is this a new request or a continued request */ 
....................     FS_DISK_ERRORS properties_status;  /* status of the last call of the function */ 
....................  
....................     struct 
....................     { 
....................         BYTE disk_format;           /* disk format: FAT12, FAT16, FAT32 */ 
....................         WORD sector_size;           /* sector size of the drive */ 
....................         BYTE sectors_per_cluster;   /* number of sectors per cluster */ 
....................         DWORD total_clusters;       /* the number of total clusters on the drive */ 
....................         DWORD free_clusters;        /* the number of free (unused) clusters on drive */ 
....................     } results;                      /* the results of the current search */ 
....................  
....................     struct 
....................     { 
....................         DWORD   c;      
....................         DWORD   curcls; 
....................         DWORD   EndClusterLimit; 
....................         DWORD   ClusterFailValue; 
....................     } private;      /* intermediate values used to continue searches.  This 
....................                          member should be used only by the FSGetDiskProperties() 
....................                          function */ 
....................  
.................... } FS_DISK_PROPERTIES; 
....................  
.................... // Summary: A structure used for searching for files on a device. 
.................... // Description: The SearchRec structure is used when searching for file on a device.  It contains parameters that will be loaded with 
.................... //              file information when a file is found.  It also contains the parameters that the user searched for, allowing further 
.................... //              searches to be perfomed in the same directory for additional files that meet the specified criteria. 
.................... typedef struct 
.................... { 
....................     char            filename[FILE_NAME_SIZE_8P3 + 2];   // The name of the file that has been found 
....................     unsigned char   attributes;                     // The attributes of the file that has been found 
....................     unsigned long   filesize;                       // The size of the file that has been found 
....................     unsigned long   timestamp;                      // The last modified time of the file that has been found (create time for directories) 
....................    #ifdef SUPPORT_LFN 
....................       BOOL         AsciiEncodingType;          // Ascii file name or Non-Ascii file name indicator 
....................       unsigned short int *utf16LFNfound;          // Pointer to long file name found in UTF16 format 
....................       unsigned short int utf16LFNfoundLength;     // LFN Found length in terms of words including the NULL word at the last. 
....................    #endif 
....................     unsigned int    entry;                          // The directory entry of the last file found that matches the specified attributes. (Internal use only) 
....................     char            searchname[FILE_NAME_SIZE_8P3 + 2]; // The 8.3 format name specified when the user began the search. (Internal use only) 
....................     unsigned char   searchattr;                     // The attributes specified when the user began the search. (Internal use only) 
....................     unsigned long   cwdclus;                        // The directory that this search was performed in. (Internal use only) 
....................     unsigned char   initialized;                    // Check to determine if the structure was initialized by FindFirst (Internal use only) 
.................... } SearchRec; 
....................  
....................  
.................... /*************************************************************************** 
.................... * Prototypes                                                               * 
.................... ***************************************************************************/ 
....................  
....................  
....................  
....................  
.................... /************************************************************************* 
....................   Function: 
....................     int FSInit(void) 
....................   Summary: 
....................     Function to initialize the device. 
....................   Conditions: 
....................     The physical device should be connected to the microcontroller. 
....................   Input: 
....................     None 
....................   Return Values: 
....................     TRUE -  Initialization successful 
....................     FALSE - Initialization unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function initializes the file system stack & the interfacing device. 
....................     Initializes the static or dynamic memory slots for holding file 
....................     structures. Initializes the device with the DISKmount function. Loads  
....................     MBR and boot sector information. Initializes the current working 
....................     directory to the root directory for the device if directory support 
....................     is enabled. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... int FSInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * FSfopen (const char * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with ascii input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will open a ascii name file or directory on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * FSfopen(const char * fileName, const char *mode); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     FSFILE * wFSfopen (const unsigned short int * fileName, const char *mode) 
....................   Summary: 
....................     Opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to open 
....................     mode - 
....................          - FS_WRITE -      Create a new file or replace an existing file 
....................          - FS_READ -       Read data from an existing file 
....................          - FS_APPEND -     Append data to an existing file 
....................          - FS_WRITEPLUS -  Create a new file or replace an existing file (reads also enabled) 
....................          - FS_READPLUS -   Read data from an existing file (writes also enabled) 
....................          - FS_APPENDPLUS - Append data to an existing file (reads also enabled) 
....................   Return Values: 
....................     FSFILE * - The pointer to the file object 
....................     NULL -     The file could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file with UTF16 input 'fileName' on PIC24/PIC32/dsPIC MCU's. 
....................     First, RAM in the dynamic heap or static array will be allocated to a 
....................     new FSFILE object. Then, the specified file name will be formatted to 
....................     ensure that it's in 8.3 format or LFN format. Next, the FILEfind function 
....................     will be used to search for the specified file name. If the name is found, 
....................     one of three things will happen: if the file was opened in read mode, its 
....................     file info will be loaded using the FILEopen function; if it was opened in 
....................     write mode, it will be erased, and a new file will be constructed in 
....................     its place; if it was opened in append mode, its file info will be 
....................     loaded with FILEopen and the current location will be moved to the 
....................     end of the file using the FSfseek function.  If the file was not 
....................     found by FILEfind, a new file will be created if the mode was specified as 
....................     a write or append mode.  In these cases, a pointer to the heap or 
....................     static FSFILE object array will be returned. If the file was not 
....................     found and the mode was specified as a read mode, the memory 
....................     allocated to the file will be freed and the NULL pointer value 
....................     will be returned. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************/ 
....................  
.................... FSFILE * wFSfopen(const unsigned short int * fileName, const char *mode); 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................  
.................... /****************************************************************************** 
....................   Function: 
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode) 
....................   Summary: 
....................     Opens a file on PIC18 Microcontrollers where 'fileName' ROM string is given 
....................     in Ascii format. 
....................   Conditions: 
....................     For read modes, file exists; FSInit performed 
....................   Input: 
....................     fileName -  The name of the file to be opened (ROM) 
....................     mode -      The mode the file will be opened in (ROM) 
....................   Return Values: 
....................     FSFILE * - A pointer to the file object 
....................     NULL -     File could not be opened 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function opens a file on PIC18 Microcontrollers where 'fileName' ROM string 
....................     is given in Ascii format.The FSfopenpgm function will copy a PIC18 ROM fileName and 
....................     mode argument into RAM arrays, and then pass those arrays to the FSfopen function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   ******************************************************************************/ 
....................  
....................     FSFILE * FSfopenpgm(const rom char * fileName, const rom char *mode); 
....................  
....................  
.................... /************************************************************************************** 
....................   Function: 
....................     int FindFirstpgm (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Find a file named with a ROM string on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName -  The name of the file to be found (ROM) 
....................     attr -      The attributes of the file to be found 
....................     rec -       Pointer to a search record to store the file info in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the given parameters was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirstpgm call on passed SearchRec object 
....................     will be lost.The FSerrno variable will be changed. 
....................   Description: 
....................     This function finds a file named with 'fileName' on PIC18. The FindFirstpgm 
....................     function will copy a PIC18 ROM fileName argument into a RAM array, and then 
....................     pass that array to the FindFirst function. 
....................   Remarks: 
....................     Call FindFirstpgm or FindFirst before calling FindNext. 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************************/ 
....................  
....................     int FindFirstpgm (const rom char * fileName, unsigned int attr, SearchRec * rec); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdirpgm (const rom char * path) 
....................   Summary: 
....................     Changes the CWD to the input path on PIC18 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to (ROM) 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the CWD to the input path on PIC18.The FSchdirpgm function 
....................     passes a PIC18 ROM path pointer to the chdirhelper function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM 
....................   **************************************************************************/ 
....................  
....................     int FSchdirpgm (const rom char * path); 
....................  
....................     #ifdef ALLOW_WRITES 
....................  
....................  
.................... /************************************************************* 
....................   Function: 
....................     int FSremovepgm (const rom char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC18 device 
....................   Conditions: 
....................     File not opened; file exists 
....................   Input: 
....................     fileName -  The name of the file to be deleted (ROM) 
....................   Return Values: 
....................     0 -  File was removed successfully 
....................     -1 - File could not be removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC18 device.The FSremovepgm function will copy a 
....................     PIC18 ROM fileName argument into a RAM array, and then pass that array 
....................     to the FSremove function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   *************************************************************/ 
....................  
....................         int FSremovepgm (const rom char * fileName); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdirpgm (const rom char * path) 
....................   Summary: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create (ROM) 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the path mentioned in the input string on  
....................     PIC18 devices.'FSmkdirpgm' creates the directories as per the input 
....................     string path.This function doesn't move the current working 
....................     directory setting. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arugments in ROM 
....................   **************************************************************************/ 
....................  
....................         int FSmkdirpgm (const rom char * path); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdirpgm (const rom char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     path -      The path of the directory to remove (ROM) 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC18). 
....................     This function deletes the directory as specified in the path. 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM. 
....................   **************************************************************************/ 
....................  
....................         int FSrmdirpgm (const rom char * path, unsigned char rmsubdirs); 
....................  
....................  
.................... /***************************************************************** 
....................   Function: 
....................     int FSrenamepgm(const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the file with the ascii ROM string(PIC18) 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file (in ROM) 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -  File renamed successfully 
....................     -1 - File could not be renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the file with the ascii ROM string(PIC18).The Fsrenamepgm 
....................     function will copy the rom fileName specified by the user into a  
....................     RAM array and pass that array into the FSrename function. 
....................   Remarks: 
....................     This function is for use with PIC18 when passing arguments in ROM.                        
....................   *****************************************************************/ 
....................  
....................         int FSrenamepgm (const rom char * fileName, FSFILE * fo); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************ 
....................   Function: 
....................     int FSfclose(FSFILE *fo) 
....................   Summary: 
....................     Update file information and free FSFILE objects 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to the file to close 
....................   Return Values: 
....................     0 -   File closed successfully  
....................     EOF - Error closing the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     This function will update the directory entry for the  
....................     file pointed to by 'fo' with the information contained 
....................     in 'fo,' including the new file size and attributes. 
....................     Timestamp information will also be loaded based on the 
....................     method selected by the user and written to the entry 
....................     as the last modified time and date.  The file entry will 
....................     then be written to the device.  Finally, the memory 
....................     used for the specified file object will be freed from 
....................     the dynamic heap or the array of FSFILE objects. 
....................   Remarks: 
....................     A function to flush data to the device without closing the 
....................     file can be created by removing the portion of this 
....................     function that frees the memory and the line that clears 
....................     the write flag. 
....................   ************************************************************/ 
....................  
.................... int FSfclose(FSFILE *fo); 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     void FSrewind (FSFILE * fo) 
....................   Summary: 
....................     Set the current position in a file to the beginning 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The FSrewind funciton will reset the position of the 
....................     specified file to the beginning of the file.  This 
....................     functionality is faster than using FSfseek to reset 
....................     the position in the file. 
....................   Remarks: 
....................     None. 
....................   *********************************************************/ 
....................  
.................... void FSrewind (FSFILE *fo); 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Read data from a file 
....................   Conditions: 
....................     File is opened in a read mode 
....................   Input: 
....................     ptr -     Destination buffer for read bytes 
....................     size -    Size of units in bytes 
....................     n -       Number of units to be read 
....................     stream -  File to be read from 
....................   Return: 
....................     size_t - number of units read 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfread function will read data from the specified file.  First, 
....................     the appropriate sector of the file is loaded.  Then, data is read into 
....................     the specified buffer until the specified number of bytes have been read. 
....................     When a cluster boundary is reached, a new cluster will be loaded.  The 
....................     parameters 'size' and 'n' indicate how much data to read.  'Size' 
....................     refers to the size of one object to read (in bytes), and 'n' will refer  
....................     to the number of these objects to read.  The value returned will be equal  
....................     to 'n' unless an error occured or the user tried to read beyond the end 
....................     of the file. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... size_t FSfread(void *ptr, size_t size, size_t n, FSFILE *stream); 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FSfseek(FSFILE *stream, long offset, int whence) 
....................   Summary: 
....................     Change the current position in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     stream -    Pointer to file structure 
....................     offset -    Offset from base location 
....................     whence -     
....................            - SEEK_SET -  Seek from start of file 
....................            - SEEK_CUR -  Seek from current location 
....................            - SEEK_END -  Seek from end of file (subtract offset) 
....................   Return Values: 
....................     0 -  Operation successful  
....................     -1 - Operation unsuccesful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfseek function will change the current position in the file to 
....................     one specified by the user.  First, an absolute offset is calculated 
....................     using the offset and base location passed in by the user.  Then, the 
....................     position variables are updated, and the sector number that corresponds 
....................     to the new location.  That sector is then loaded.  If the offset 
....................     falls exactly on a cluster boundary, a new cluster will be allocated 
....................     to the file and the position will be set to the first byte of that 
....................     cluster. 
....................   Remarks: 
....................     None                                                                
....................   **********************************************************************/ 
....................  
.................... int FSfseek(FSFILE *stream, long offset, int whence); 
....................  
....................  
.................... /******************************************************************* 
....................   Function: 
....................     long FSftell (FSFILE * fo) 
....................   Summary: 
....................     Determine the current location in a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     fo -  Pointer to file structure 
....................   Return: Current location in the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     The FSftell function will return the current position in the 
....................     file pointed to by 'fo' by returning the 'seek' variable in the 
....................     FSFILE object, which is used to keep track of the absolute 
....................     location of the current position in the file. 
....................   Remarks: 
....................     None                                                             
....................   *******************************************************************/ 
....................  
.................... long FSftell(FSFILE *fo); 
....................  
....................  
.................... /**************************************************** 
....................   Function: 
....................     int FSfeof( FSFILE * stream ) 
....................   Summary: 
....................     Indicate whether the current file position is at the end 
....................   Conditions: 
....................     File is open in a read mode 
....................   Input: 
....................     stream -  Pointer to the target file 
....................   Return Values: 
....................     Non-Zero - EOF reached  
....................     0 - Not at end of File 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfeof function will indicate that the end-of- 
....................     file has been reached for the specified file by 
....................     comparing the absolute location in the file to the 
....................     size of the file. 
....................   Remarks: 
....................     None. 
....................   ****************************************************/ 
....................  
.................... int FSfeof( FSFILE * stream ); 
....................  
....................  
.................... #ifdef ALLOW_FORMATS 
.................... /******************************************************************* 
....................   Function: 
....................     int FSformat (char mode, long int serialNumber, char * volumeID) 
....................   Summary: 
....................     Formats a device 
....................   Conditions: 
....................     The device must possess a valid master boot record. 
....................   Input: 
....................     mode -          - 0 - Just erase the FAT and root 
....................                     - 1 - Create a new boot sector 
....................     serialNumber -  Serial number to write to the card 
....................     volumeID -      Name of the card 
....................   Return Values: 
....................     0 -    Format was successful 
....................     EOF -  Format was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSformat function can be used to create a new boot sector 
....................     on a device, based on the information in the master boot record. 
....................     This function will first initialize the I/O pins and the device, 
....................     and then attempts to read the master boot record.  If the MBR 
....................     cannot be loaded successfully, the function will fail.  Next, if 
....................     the 'mode' argument is specified as '0' the existing boot sector 
....................     information will be loaded.  If the 'mode' argument is '1' an 
....................     entirely new boot sector will be constructed using the disk 
....................     values from the master boot record.  Once the boot sector has 
....................     been successfully loaded/created, the locations of the FAT and 
....................     root will be loaded from it, and they will be completely 
....................     erased.  If the user has specified a volumeID parameter, a  
....................     VOLUME attribute entry will be created in the root directory 
....................     to name the device. 
....................  
....................     FAT12, FAT16 and FAT32 formatting are supported. 
....................  
....................     Based on the number of sectors, the format function automatically 
....................     compute the smallest possible value for the cluster size in order to 
....................     accommodate the physical size of the media. In this case, if a media  
....................     with a big capacity is formatted, the format function may take a very 
....................     long time to write all the FAT tables.  
....................  
....................     Therefore, the FORMAT_SECTORS_PER_CLUSTER macro may be used to  
....................     specify the exact cluster size (in multiples of sector size). This  
....................     macro can be defined in FSconfig.h 
....................  
....................   Remarks: 
....................     Only devices with a sector size of 512 bytes are supported by the  
....................     format function                       
....................   *******************************************************************/ 
....................  
.................... int FSformat (char mode, long int serialNumber, char * volumeID); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_WRITES 
.................... /*************************************************************************** 
....................   Function: 
....................     int FSattrib (FSFILE * file, unsigned char attributes) 
....................   Summary: 
....................     Change the attributes of a file 
....................   Conditions: 
....................     File opened 
....................   Input: 
....................     file -        Pointer to file structure 
....................     attributes -  The attributes to set for the file 
....................                -  Attribute -      Value - Indications  
....................                -  ATTR_READ_ONLY - 0x01  - The read-only attribute 
....................                -  ATTR_HIDDEN -    0x02  - The hidden attribute  
....................                -  ATTR_SYSTEM -    0x04  - The system attribute  
....................                -  ATTR_ARCHIVE -   0x20  - The archive attribute 
....................   Return Values: 
....................     0 -  Attribute change was successful  
....................     -1 - Attribute change was unsuccessful 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSattrib funciton will set the attributes of the specified file 
....................     to the attributes passed in by the user.  This function will load the 
....................     file entry, replace the attributes with the ones specified, and write 
....................     the attributes back.  If the specified file is a directory, the 
....................     directory attribute will be preserved. 
....................   Remarks: 
....................     None                                                                 
....................   ***************************************************************************/ 
....................  
.................... int FSattrib (FSFILE * file, unsigned char attributes); 
....................  
....................  
.................... /*************************************************************** 
....................   Function: 
....................     int FSrename (const rom char * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the Ascii name of the file or directory on PIC24/PIC32/dsPIC devices. 
....................     First, it will search through the current working directory to ensure the 
....................     specified new filename is not already in use. If it isn't, the new filename 
....................     will be written to the file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None                                                         
....................   ***************************************************************/ 
....................  
.................... int FSrename (const char * fileName, FSFILE * fo); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*************************************************************** 
....................   Function: 
....................     int wFSrename (const rom unsigned short int * fileName, FSFILE * fo) 
....................   Summary: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices 
....................   Conditions: 
....................     File opened. 
....................   Input: 
....................     fileName -  The new name of the file 
....................     fo -        The file to rename 
....................   Return Values: 
....................     0 -   File was renamed successfully 
....................     EOF - File was not renamed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Renames the name of the file or directory to the UTF16 input fileName 
....................     on PIC24/PIC32/dsPIC devices. First, it will search through the current 
....................     working directory to ensure the specified new UTF16 filename is not 
....................     already in use.  If it isn't, the new filename will be written to the 
....................     file entry of the file pointed to by 'fo.' 
....................   Remarks: 
....................     None 
....................   ***************************************************************/ 
....................  
.................... int wFSrename (const unsigned short int * fileName, FSFILE * fo); 
.................... #endif 
....................  
.................... /********************************************************************* 
....................   Function: 
....................     int FSremove (const char * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed  
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in ascii format. 
....................     The FSremove function will attempt to find the specified file with the FILEfind 
....................     function.  If the file is found, it will be erased using the FILEerase function. 
....................     The user can also provide ascii alias name of the ascii long file name as the 
....................     input to this function to get it erased from the memory. 
....................   Remarks: 
....................     None                                        
....................   **********************************************************************/ 
....................  
.................... int FSremove (const char * fileName); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /********************************************************************* 
....................   Function: 
....................     int wFSremove (const unsigned short int * fileName) 
....................   Summary: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................   Conditions: 
....................     File not opened, file exists 
....................   Input: 
....................     fileName -  Name of the file to erase 
....................   Return Values: 
....................     0 -   File removed 
....................     EOF - File was not removed 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the file on PIC24/PIC32/dsPIC device.The 'fileName' is in UTF16 format. 
....................     The wFSremove function will attempt to find the specified UTF16 file 
....................     name with the FILEfind function. If the file is found, it will be erased 
....................     using the FILEerase function. 
....................   Remarks: 
....................     None 
....................   **********************************************************************/ 
....................  
.................... int wFSremove (const unsigned short int * fileName); 
.................... #endif 
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream) 
....................   Summary: 
....................     Write data to a file 
....................   Conditions: 
....................     File opened in FS_WRITE, FS_APPEND, FS_WRITE+, FS_APPEND+, FS_READ+ mode 
....................   Input: 
....................     data_to_write -     Pointer to source buffer 
....................     size -              Size of units in bytes 
....................     n -                 Number of units to transfer 
....................     stream -            Pointer to file structure 
....................   Return: 
....................     size_t - number of units written 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     The FSfwrite function will write data to a file.  First, the sector that 
....................     corresponds to the current position in the file will be loaded (if it hasn't 
....................     already been cached in the global data buffer).  Data will then be written to 
....................     the device from the specified buffer until the specified amount has been written. 
....................     If the end of a cluster is reached, the next cluster will be loaded, unless 
....................     the end-of-file flag for the specified file has been set.  If it has, a new 
....................     cluster will be allocated to the file.  Finally, the new position and filesize 
....................     will be stored in the FSFILE object.  The parameters 'size' and 'n' indicate how  
....................     much data to write.  'Size' refers to the size of one object to write (in bytes),  
....................     and 'n' will refer to the number of these objects to write.  The value returned  
....................     will be equal  to 'n' unless an error occured. 
....................   Remarks: 
....................     None. 
....................   *********************************************************************************/ 
....................  
.................... size_t FSfwrite(const void *data_to_write, size_t size, size_t n, FSFILE *stream); 
....................  
.................... #endif 
....................  
.................... #ifdef ALLOW_DIRS 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSchdir (char * path) 
....................   Summary: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Changes the current working directory to the ascii input path(PIC24/PIC32/dsPIC). 
....................     The FSchdir function passes a RAM pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSchdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSchdir (unsigned short int * path) 
....................   Summary: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of the directory to change to. 
....................   Return Values: 
....................     0 -   The current working directory was changed successfully 
....................     EOF - The current working directory could not be changed 
....................   Side Effects: 
....................     The current working directory may be changed. The FSerrno variable will 
....................     be changed. 
....................   Description: 
....................     Change the current working directory as per the path specified in 
....................     UTF16 format (PIC24/PIC32/dsPIC).The FSchdir function passes a RAM 
....................     pointer to the path to the chdirhelper function. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSchdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************** 
....................   Function: 
....................     char * FSgetcwd (char * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in Ascii format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in Ascii format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * FSgetcwd (char * path, int numbchars); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************** 
....................   Function: 
....................     char * wFSgetcwd (unsigned short int * path, int numchars) 
....................   Summary: 
....................     Get the current working directory path in UTF16 format 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      Pointer to the array to return the cwd name in 
....................     numchars -  Number of chars in the path 
....................   Return Values: 
....................     char * - The cwd name string pointer (path or defaultArray) 
....................     NULL -   The current working directory name could not be loaded. 
....................   Side Effects: 
....................     The FSerrno variable will be changed 
....................   Description: 
....................     Get the current working directory path in UTF16 format. 
....................     The FSgetcwd function will get the name of the current 
....................     working directory and return it to the user.  The name 
....................     will be copied into the buffer pointed to by 'path,' 
....................     starting at the root directory and copying as many chars 
....................     as possible before the end of the buffer.  The buffer 
....................     size is indicated by the 'numchars' argument.  The first 
....................     thing this function will do is load the name of the current 
....................     working directory, if it isn't already present.  This could 
....................     occur if the user switched to the dotdot entry of a 
....................     subdirectory immediately before calling this function.  The 
....................     function will then copy the current working directory name  
....................     into the buffer backwards, and insert a backslash character.   
....................     Next, the function will continuously switch to the previous  
....................     directories and copy their names backwards into the buffer 
....................     until it reaches the root.  If the buffer overflows, it 
....................     will be treated as a circular buffer, and data will be 
....................     copied over existing characters, starting at the beginning. 
....................     Once the root directory is reached, the text in the buffer 
....................     will be swapped, so that the buffer contains as much of the 
....................     current working directory name as possible, starting at the  
....................     root. 
....................   Remarks: 
....................     None                                                        
....................   **************************************************************/ 
....................  
.................... char * wFSgetcwd (unsigned short int * path, int numbchars); 
.................... #endif 
....................  
.................... #ifdef ALLOW_WRITES 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSmkdir (char * path) 
....................   Summary: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int FSmkdir (char * path); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSmkdir (unsigned short int * path) 
....................   Summary: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC) 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path - The path of directories to create. 
....................   Return Values: 
....................     0 -   The specified directory was created successfully 
....................     EOF - The specified directory could not be created 
....................   Side Effects: 
....................     Will create all non-existent directories in the path. The FSerrno  
....................     variable will be changed. 
....................   Description: 
....................     Creates a directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function doesn't move the current working directory setting. 
....................   Remarks: 
....................     None                                             
....................   **************************************************************************/ 
....................  
.................... int wFSmkdir (unsigned short int * path); 
.................... #endif 
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSrmdir (char * path) 
....................   Summary: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the ascii input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int FSrmdir (char * path, unsigned char rmsubdirs); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /************************************************************************** 
....................   Function: 
....................     int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs) 
....................   Summary: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................   Conditions: 
....................     None 
....................   Input: 
....................     path -      The path of the directory to remove 
....................     rmsubdirs -  
....................               - TRUE -  All sub-dirs and files in the target dir will be removed 
....................               - FALSE - FSrmdir will not remove non-empty directories 
....................   Return Values: 
....................     0 -   The specified directory was deleted successfully 
....................     EOF - The specified directory could not be deleted 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Deletes the directory as per the UTF16 input path (PIC24/PIC32/dsPIC). 
....................     This function wont delete the current working directory. 
....................   Remarks: 
....................     None. 
....................   **************************************************************************/ 
....................  
.................... int wFSrmdir (unsigned short int * path, unsigned char rmsubdirs); 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #ifdef USERDEFINEDCLOCK 
....................  
....................  
.................... /*********************************************************************************************************** 
....................   Function: 
....................     int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second) 
....................   Summary: 
....................     Manually set timestamp variables 
....................   Conditions: 
....................     USERDEFINEDCLOCK macro defined in FSconfig.h. 
....................   Input: 
....................     year -     The year (1980\-2107) 
....................     month -   The month (1\-12) 
....................     day -     The day of the month (1\-31) 
....................     hour -    The hour (0\-23) 
....................     minute -  The minute (0\-59) 
....................     second -  The second (0\-59) 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     Modifies global timing variables 
....................   Description: 
....................     Lets the user manually set the timing variables.  The values passed in will be converted to the format 
....................     used by the FAT timestamps. 
....................   Remarks: 
....................     Call this before creating a file or directory (set create time) and 
....................     before closing a file (set last access time, last modified time)                                         
....................   ***********************************************************************************************************/ 
....................  
.................... int SetClockVars (unsigned int year, unsigned char month, unsigned char day, unsigned char hour, unsigned char minute, unsigned char second); 
.................... #endif 
....................  
....................  
.................... #ifdef ALLOW_FILESEARCH 
....................  
.................... /*********************************************************************************** 
....................   Function: 
....................     int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous FindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the input Ascii fileName on PIC24/PIC32/dsPIC devices. 
....................     The FindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int FindFirst (const char * fileName, unsigned int attr, SearchRec * rec); 
....................  
.................... #ifdef SUPPORT_LFN 
.................... /*********************************************************************************** 
....................   Function: 
....................     int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec) 
....................   Summary: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fileName - The name to search for 
....................              - Parital string search characters 
....................              - * - Indicates the rest of the filename or extension can vary (e.g. FILE.*) 
....................              - ? - Indicates that one character in a filename can vary (e.g. F?LE.T?T) 
....................     attr -            The attributes that a found file may have 
....................          - ATTR_READ_ONLY -  File may be read only 
....................          - ATTR_HIDDEN -     File may be a hidden file 
....................          - ATTR_SYSTEM -     File may be a system file 
....................          - ATTR_VOLUME -     Entry may be a volume label 
....................          - ATTR_DIRECTORY -  File may be a directory 
....................          - ATTR_ARCHIVE -    File may have archive attribute 
....................          - ATTR_MASK -       All attributes 
....................     rec -             pointer to a structure to put the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No file matching the specified criteria was found 
....................   Side Effects: 
....................     Search criteria from previous wFindFirst call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent wFindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     Initial search function for the 'fileName' in UTF16 format on PIC24/PIC32/dsPIC devices. 
....................     The wFindFirst function will search for a file based on parameters passed in 
....................     by the user.  This function will use the FILEfind function to parse through 
....................     the current working directory searching for entries that match the specified 
....................     parameters.  If a file is found, its parameters are copied into the SearchRec 
....................     structure, as are the initial parameters passed in by the user and the position 
....................     of the file entry in the current working directory.If the return value of the  
....................     function is 0 then "utf16LFNfoundLength" indicates whether the file found was  
....................     long file name or short file name(8P3 format). The "utf16LFNfoundLength" is non-zero 
....................     for long file name and is zero for 8P3 format."utf16LFNfound" points to the 
....................     address of long file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling FindNext 
....................   ***********************************************************************************/ 
....................  
.................... int wFindFirst (const unsigned short int * fileName, unsigned int attr, SearchRec * rec); 
.................... #endif 
....................  
.................... /********************************************************************** 
....................   Function: 
....................     int FindNext (SearchRec * rec) 
....................   Summary: 
....................     Sequential search function 
....................   Conditions: 
....................     None 
....................   Input: 
....................     rec -  The structure to store the file information in 
....................   Return Values: 
....................     0 -  File was found 
....................     -1 - No additional files matching the specified criteria were found 
....................   Side Effects: 
....................     Search criteria from previous FindNext call on passed SearchRec object 
....................     will be lost. "utf16LFNfound" is overwritten after subsequent FindFirst/FindNext 
....................     operations.It is the responsibility of the application to read the "utf16LFNfound" 
....................     before it is lost.The FSerrno variable will be changed. 
....................   Description: 
....................     The FindNext function performs the same function as the FindFirst 
....................     funciton, except it does not copy any search parameters into the 
....................     SearchRec structure (only info about found files) and it begins 
....................     searching at the last directory entry offset at which a file was 
....................     found, rather than at the beginning of the current working 
....................     directory.If the return value of the function is 0 then "utf16LFNfoundLength" 
....................     indicates whether the file found was long file name or short file 
....................     name(8P3 format). The "utf16LFNfoundLength" is non-zero for long file name 
....................     and is zero for 8P3 format."utf16LFNfound" points to the address of long  
....................     file name if found during the operation. 
....................   Remarks: 
....................     Call FindFirst or FindFirstpgm before calling this function 
....................   **********************************************************************/ 
....................  
.................... int FindNext (SearchRec * rec);  
.................... #endif 
....................  
....................  
.................... /********************************************************************** 
....................   Function: 
....................     // PIC24/30/33/32 
....................     int FSfprintf (FSFILE * fptr, const char * fmt, ...) 
....................     // PIC18 
....................     int FSfpritnf (FSFILE * fptr, const rom char * fmt, ...) 
....................   Summary: 
....................     Function to write formatted strings to a file 
....................   Conditions: 
....................     For PIC18, integer promotion must be enabled in the project build 
....................     options menu.  File opened in a write mode. 
....................   Input: 
....................     fptr - A pointer to the file to write to. 
....................     fmt -  A string of characters and format specifiers to write to 
....................            the file 
....................     ... -  Additional arguments inserted in the string by format 
....................            specifiers 
....................   Returns: 
....................     The number of characters written to the file 
....................   Side Effects: 
....................     The FSerrno variable will be changed. 
....................   Description: 
....................     Writes a specially formatted string to a file. 
....................   Remarks: 
....................     Consult AN1045 for a full description of how to use format 
....................     specifiers.         
....................   **********************************************************************/ 
....................  
.................... #ifdef ALLOW_FSFPRINTF 
....................     #ifdef __18CXX 
....................         int FSfprintf (FSFILE *fptr, const rom char *fmt, ...); 
....................     #else 
....................         int FSfprintf (FSFILE *fptr, const char * fmt, ...); 
....................     #endif 
.................... #endif 
....................  
....................  
.................... /************************************************************************** 
....................   Function: 
....................     int FSerror (void) 
....................   Summary: 
....................     Return an error code for the last function call 
....................   Conditions: 
....................     The return value depends on the last function called. 
....................   Input: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Return Values: 
....................     FSInit       -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The physical media could not be initialized 
....................                  - CE_BAD_SECTOR_READ        The MBR or the boot sector could not be 
....................                                               read correctly 
....................                  - CE_BAD_PARITION           The MBR signature code was incorrect. 
....................                  - CE_NOT_FORMATTED          The boot sector signature code was incorrect or 
....................                                               indicates an invalid number of bytes per sector.  
....................                  - CE_CARDFAT32              The physical media is FAT32 type (only an error  
....................                                               when FAT32 support is disabled).  
....................                  - CE_UNSUPPORTED_FS         The device is formatted with an unsupported file  
....................                                               system (not FAT12 or 16). 
....................     FSfopen      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The device has not been initialized.  
....................                  - CE_TOO_MANY_FILES_OPEN    The function could not allocate any  
....................                                               additional file information to the array  
....................                                               of FSFILE structures or the heap.  
....................                  - CE_INVALID_FILENAME       The file name argument was invalid. 
....................                  - CE_INVALID_ARGUMENT       The user attempted to open a directory in a  
....................                                               write mode or specified an invalid mode argument.  
....................                  - CE_FILE_NOT_FOUND         The specified file (which was to be opened in read  
....................                                               mode) does not exist on the device.  
....................                  - CE_BADCACHEREAD           A read from the device failed. 
....................                  - CE_ERASE_FAIL             The existing file could not be erased (when opening  
....................                                               a file in FS_WRITE mode).  
....................                  - CE_DIR_FULL               The directory is full.  
....................                  - CE_DISK_FULL              The data memory section is full.  
....................                  - CE_WRITE_ERROR            A write to the device failed.  
....................                  - CE_SEEK_ERROR             The current position in the file could not be set to  
....................                                               the end (when the file was opened in FS_APPEND mode). 
....................     FSfclose     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer or the new file 
....................                                               entry information could not be written to the device. 
....................                  - CE_BADCACHEREAD           The file entry information could not be cached 
....................     FSfread      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITEONLY              The file was opened in a write-only mode. 
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device.  
....................                  - CE_BAD_SECTOR_READ        The data sector could not be read.  
....................                  - CE_EOF                    The end of the file was reached. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be loaded. 
....................     FSfwrite     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_READONLY               The file was opened in a read-only mode.  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected. 
....................                  - CE_WRITE_ERROR            There was an error writing data to the device. 
....................                  - CE_BADCACHEREAD           The data sector to be modified could not be read from 
....................                                               the device.  
....................                  - CE_DISK_FULL              All data clusters on the device are in use. 
....................     FSfseek      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be 
....................                                               written to the device.  
....................                  - CE_INVALID_ARGUMENT       The specified offset exceeds the size of the file.  
....................                  - CE_BADCACHEREAD           The sector that contains the new current position  
....................                                               could not be loaded. 
....................                  - CE_COULD_NOT_GET_CLUSTER  Additional clusters in the file could not be  
....................                                               loaded/allocated. 
....................     FSftell      -  
....................                  - CE_GOOD                   No Error 
....................     FSattrib     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The attribute argument was invalid.  
....................                  - CE_BADCACHEREAD           The existing file entry information could not be  
....................                                               loaded.  
....................                  - CE_WRITE_ERROR            The file entry information could not be written to  
....................                                               the device. 
....................     FSrename     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_FILENOTOPENED          A null file pointer was passed into the function.  
....................                  - CE_INVALID_FILENAME       The file name passed into the function was invalid.  
....................                  - CE_BADCACHEREAD           A read from the device failed.  
....................                  - CE_FILENAME_EXISTS        A file with the specified name already exists.  
....................                  - CE_WRITE_ERROR            The new file entry data could not be written to the  
....................                                               device. 
....................     FSfeof       - 
....................                  - CE_GOOD                   No Error 
....................     FSformat     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INIT_ERROR             The device could not be initialized.  
....................                  - CE_BADCACHEREAD           The master boot record or boot sector could not be  
....................                                               loaded successfully.  
....................                  - CE_INVALID_ARGUMENT       The user selected to create their own boot sector on  
....................                                               a device that has no master boot record, or the mode  
....................                                               argument was invalid.  
....................                  - CE_WRITE_ERROR            The updated MBR/Boot sector could not be written to  
....................                                               the device. 
....................                  - CE_BAD_PARTITION          The calculated number of sectors per clusters was  
....................                                               invalid.  
....................                  - CE_NONSUPPORTED_SIZE      The card has too many sectors to be formatted as  
....................                                               FAT12 or FAT16. 
....................     FSremove     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         The specified file could not be found. 
....................                  - CE_ERASE_FAIL             The file could not be erased. 
....................     FSchdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed or the user tried to  
....................                                               change to a non-directory file. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_FOUND          Could not find a directory in the path. 
....................     FSgetcwd     - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The user passed a 0-length buffer into the function. 
....................                  - CE_BADCACHEREAD           A directory entry could not be cached.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the current working directory. 
....................     FSmkdir      - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_PROTECTED        The device write-protect check function indicated  
....................                                               that the device has been write-protected.  
....................                  - CE_INVALID_ARGUMENT       The path string was mis-formed. 
....................                  - CE_BADCACHEREAD           Could not successfully change to a recently created  
....................                                               directory to store its dir entry information, or  
....................                                               could not cache directory entry information.  
....................                  - CE_INVALID_FILENAME       One or more of the directory names has an invalid  
....................                                               format.  
....................                  - CE_WRITE_ERROR            The existing data in the data buffer could not be  
....................                                               written to the device or the dot/dotdot entries could  
....................                                               not be written to a newly created directory. 
....................                  - CE_DIR_FULL               There are no available dir entries in the CWD. 
....................                  - CE_DISK_FULL              There are no available clusters in the data region of  
....................                                               the device.     
....................     FSrmdir      -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_DIR_NOT_FOUND          The directory specified could not be found or the  
....................                                               function could not change to a subdirectory within  
....................                                               the directory to be deleted (when recursive delete is  
....................                                               enabled). 
....................                  - CE_INVALID_ARGUMENT       The user tried to remove the CWD or root directory.  
....................                  - CE_BADCACHEREAD           A directory entry could not be cached. 
....................                  - CE_DIR_NOT_EMPTY          The directory to be deleted was not empty and  
....................                                               recursive subdirectory removal was disabled.  
....................                  - CE_ERASE_FAIL             The directory or one of the directories or files  
....................                                               within it could not be deleted.  
....................                  - CE_BAD_SECTOR_READ        The function could not determine a previous directory  
....................                                               of the CWD. 
....................     SetClockVars - 
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_ARGUMENT       The time values passed into the function were  
....................                                               invalid.     
....................     FindFirst    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_INVALID_FILENAME       The specified filename was invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found.  
....................                  - CE_BADCACHEREAD           The file information for the file that was found  
....................                                               could not be cached. 
....................     FindNext     -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_NOT_INIT               The SearchRec object was not initialized by a call to  
....................                                               FindFirst.  
....................                  - CE_INVALID_ARGUMENT       The SearchRec object was initialized in a different  
....................                                               directory from the CWD. 
....................                  - CE_INVALID_FILENAME       The filename is invalid.  
....................                  - CE_FILE_NOT_FOUND         No file matching the specified criteria was found. 
....................     FSfprintf    -  
....................                  - CE_GOOD                   No Error  
....................                  - CE_WRITE_ERROR            Characters could not be written to the file.                                                    
....................   Description: 
....................     The FSerror function will return the FSerrno variable.  This global 
....................     variable will have been set to an error value during the last call of a 
....................     library function. 
....................   Remarks: 
....................     None 
....................   **************************************************************************/ 
....................  
.................... int FSerror (void); 
....................  
....................  
.................... /********************************************************************************* 
....................   Function: 
....................     int FSCreateMBR (unsigned long firstSector, unsigned long numSectors) 
....................   Summary: 
....................     Creates a master boot record 
....................   Conditions: 
....................     The I/O pins for the device have been initialized by the InitIO function. 
....................   Input: 
....................     firstSector -  The first sector of the partition on the device (cannot 
....................                    be 0; that's the MBR) 
....................     numSectors -   The number of sectors available in memory (including the 
....................                    MBR) 
....................   Return Values: 
....................     0 -   MBR was created successfully 
....................     EOF - MBR could not be created 
....................   Side Effects: 
....................     None 
....................   Description:   
....................     This function can be used to create a master boot record for a device.  Note 
....................     that this function should not be used on a device that is already formatted 
....................     with a master boot record (i.e. most SD cards, CF cards, USB keys).  This 
....................     function will fill the global data buffer with appropriate partition information 
....................     for a FAT partition with a type determined by the number of sectors available 
....................     to the partition.  It will then write the MBR information to the first sector 
....................     on the device.  This function should be followed by a call to FSformat, which 
....................     will create a boot sector, root dir, and FAT appropriate the the information 
....................     contained in the new master boot record.  Note that FSformat only supports 
....................     FAT12 and FAT16 formatting at this time, and so cannot be used to format a 
....................     device with more than 0x3FFD5F sectors. 
....................   Remarks: 
....................     This function can damage the device being used, and should not be called 
....................     unless the user is sure about the size of the device and the first sector value. 
....................   *********************************************************************************/ 
....................  
.................... int FSCreateMBR (unsigned long firstSector, unsigned long numSectors); 
....................  
....................  
.................... #ifdef ALLOW_GET_DISK_PROPERTIES 
.................... /********************************************************************************* 
....................   Function: 
....................     void FSGetDiskProperties(FS_DISK_PROPERTIES* properties) 
....................   Summary: 
....................     Allows user to get the disk properties (size of disk, free space, etc) 
....................   Conditions: 
....................     1) ALLOW_GET_DISK_PROPERTIES must be defined in FSconfig.h 
....................     2) a FS_DISK_PROPERTIES object must be created before the function is called 
....................     3) the new_request member of the FS_DISK_PROPERTIES object must be set before 
....................         calling the function for the first time.  This will start a new search. 
....................     4) this function should not be called while there is a file open.  Close all 
....................         files before calling this function. 
....................   Input: 
....................     properties - a pointer to a FS_DISK_PROPERTIES object where the results should 
....................       be stored. 
....................   Return Values: 
....................     This function returns void.  The properties_status of the previous call of  
....................       this function is located in the properties.status field.  This field has  
....................       the following possible values: 
....................  
....................     FS_GET_PROPERTIES_NO_ERRORS - operation completed without error.  Results 
....................       are in the properties object passed into the function. 
....................     FS_GET_PROPERTIES_DISK_NOT_MOUNTED - there is no mounted disk.  Results in 
....................       properties object is not valid 
....................     FS_GET_PROPERTIES_CLUSTER_FAILURE - there was a failure trying to read a  
....................       cluster from the drive.  The results in the properties object is a partial 
....................       result up until the point of the failure. 
....................     FS_GET_PROPERTIES_STILL_WORKING - the search for free sectors is still in 
....................       process.  Continue calling this function with the same properties pointer  
....................       until either the function completes or until the partial results meets the 
....................       application needs.  The properties object contains the partial results of 
....................       the search and can be used by the application.   
....................   Side Effects: 
....................     Can cause errors if called when files are open.  Close all files before 
....................     calling this function. 
....................  
....................     Calling this function without setting the new_request member on the first 
....................     call can result in undefined behavior and results. 
....................  
....................     Calling this function after a result is returned other than 
....................     FS_GET_PROPERTIES_STILL_WORKING can result in undefined behavior and results. 
....................   Description:   
....................     This function returns the information about the mounted drive.  The results  
....................     member of the properties object passed into the function is populated with  
....................     the information about the drive.     
....................  
....................     Before starting a new request, the new_request member of the properties 
....................     input parameter should be set to TRUE.  This will initiate a new search 
....................     request. 
....................  
....................     This function will return before the search is complete with partial results. 
....................     All of the results except the free_clusters will be correct after the first 
....................     call.  The free_clusters will contain the number of free clusters found up 
....................     until that point, thus the free_clusters result will continue to grow until 
....................     the entire drive is searched.  If an application only needs to know that a  
....................     certain number of bytes is available and doesn't need to know the total free  
....................     size, then this function can be called until the required free size is 
....................     verified.  To continue a search, pass a pointer to the same FS_DISK_PROPERTIES 
....................     object that was passed in to create the search. 
....................  
....................     A new search request sould be made once this function has returned a value  
....................     other than FS_GET_PROPERTIES_STILL_WORKING.  Continuing a completed search 
....................     can result in undefined behavior or results. 
....................  
....................     Typical Usage: 
....................     <code> 
....................     FS_DISK_PROPERTIES disk_properties; 
....................  
....................     disk_properties.new_request = TRUE; 
....................  
....................     do 
....................     { 
....................         FSGetDiskProperties(&disk_properties); 
....................     } while (disk_properties.properties_status == FS_GET_PROPERTIES_STILL_WORKING); 
....................     </code> 
....................  
....................     results.disk_format - contains the format of the drive.  Valid results are  
....................       FAT12(1), FAT16(2), or FAT32(3). 
....................  
....................     results.sector_size - the sector size of the mounted drive.  Valid values are 
....................       512, 1024, 2048, and 4096. 
....................  
....................     results.sectors_per_cluster - the number sectors per cluster. 
....................  
....................     results.total_clusters - the number of total clusters on the drive.  This  
....................       can be used to calculate the total disk size (total_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................     results.free_clusters - the number of free (unallocated) clusters on the drive. 
....................       This can be used to calculate the total free disk size (free_clusters *  
....................       sectors_per_cluster * sector_size = total size of drive in bytes) 
....................  
....................   Remarks: 
....................     PIC24F size estimates: 
....................       Flash - 400 bytes (-Os setting) 
....................  
....................     PIC24F speed estimates: 
....................       Search takes approximately 7 seconds per Gigabyte of drive space.  Speed 
....................         will vary based on the number of sectors per cluster and the sector size. 
....................   *********************************************************************************/ 
.................... void FSGetDiskProperties(FS_DISK_PROPERTIES* properties); 
.................... #endif 
....................  
.................... /************************************************************************* 
....................   Function: 
....................     BYTE FILEget_next_cluster(FSFILE *fo, DWORD n) 
....................   Summary: 
....................     Step through a chain of clusters 
....................   Conditions: 
....................     None 
....................   Input: 
....................     fo - The file to get the next cluster of 
....................     n -  Number of links in the FAT cluster chain to jump through 
....................   Return Values: 
....................     CE_GOOD - Operation successful 
....................     CE_BAD_SECTOR_READ - A bad read occured of a sector 
....................     CE_INVALID_CLUSTER - Invalid cluster value \> maxcls 
....................     CE_FAT_EOF - Fat attempt to read beyond EOF 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     This function will load 'n' proximate clusters for a file from 
....................     the FAT on the device.  It will stop checking for clusters if the 
....................     ReadFAT function returns an error, if it reaches the last cluster in 
....................     a file, or if the device tries to read beyond the last cluster used 
....................     by the device. 
....................   Remarks: 
....................     None 
....................   *************************************************************************/ 
....................  
.................... BYTE FILEget_next_cluster(FSFILE *fo, DWORD n); 
....................  
.................... #endif 
....................  
.................... #include "MDD File System/FSDefs.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSDefs.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.2.4 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef  _FSDEF__H 
.................... #define  _FSDEF__H 
....................  
.................... #include "../GenericTypeDefs.h" 
....................  
.................... // Summary: An enumeration used for various error codes. 
.................... // Description: The CETYPE enumeration is used to indicate different error conditions during device operation. 
.................... typedef enum _CETYPE 
.................... { 
....................     CE_GOOD = 0,                    // No error 
....................     CE_ERASE_FAIL,                  // An erase failed 
....................     CE_NOT_PRESENT,                 // No device was present 
....................     CE_NOT_FORMATTED,               // The disk is of an unsupported format 
....................     CE_BAD_PARTITION,               // The boot record is bad 
....................     CE_UNSUPPORTED_FS,              // The file system type is unsupported 
....................     CE_INIT_ERROR,                  // An initialization error has occured 
....................     CE_NOT_INIT,                    // An operation was performed on an uninitialized device 
....................     CE_BAD_SECTOR_READ,             // A bad read of a sector occured 
....................     CE_WRITE_ERROR,                 // Could not write to a sector 
....................     CE_INVALID_CLUSTER,             // Invalid cluster value > maxcls 
....................     CE_FILE_NOT_FOUND,              // Could not find the file on the device 
....................     CE_DIR_NOT_FOUND,               // Could not find the directory 
....................     CE_BAD_FILE,                    // File is corrupted 
....................     CE_DONE,                        // No more files in this directory 
....................     CE_COULD_NOT_GET_CLUSTER,       // Could not load/allocate next cluster in file 
....................     CE_FILENAME_2_LONG,             // A specified file name is too long to use 
....................     CE_FILENAME_EXISTS,             // A specified filename already exists on the device 
....................     CE_INVALID_FILENAME,            // Invalid file name 
....................     CE_DELETE_DIR,                  // The user tried to delete a directory with FSremove 
....................     CE_DIR_FULL,                    // All root dir entry are taken 
....................     CE_DISK_FULL,                   // All clusters in partition are taken 
....................     CE_DIR_NOT_EMPTY,               // This directory is not empty yet, remove files before deleting 
....................     CE_NONSUPPORTED_SIZE,           // The disk is too big to format as FAT16 
....................     CE_WRITE_PROTECTED,             // Card is write protected 
....................     CE_FILENOTOPENED,               // File not opened for the write 
....................     CE_SEEK_ERROR,                  // File location could not be changed successfully 
....................     CE_BADCACHEREAD,                // Bad cache read 
....................     CE_CARDFAT32,                   // FAT 32 - card not supported 
....................     CE_READONLY,                    // The file is read-only 
....................     CE_WRITEONLY,                   // The file is write-only 
....................     CE_INVALID_ARGUMENT,            // Invalid argument 
....................     CE_TOO_MANY_FILES_OPEN,         // Too many files are already open 
....................     CE_UNSUPPORTED_SECTOR_SIZE,     // Unsupported sector size 
....................     CE_EOF = 61 
.................... } CETYPE; 
....................  
....................  
.................... // Summary: A macro indicating a dir entry was found 
.................... // Description: The FOUND macro indicates that a directory entry was found in the specified position 
.................... #define FOUND       0 
....................  
.................... // Summary: A macro indicating no dir entry was found 
.................... // Description: The NOT_FOUND macro indicates that the specified directory entry to load was deleted 
.................... #define NOT_FOUND   1 
....................  
.................... // Summary: A macro indicating that no more files were found 
.................... // Description: The NO_MORE macro indicates that there are no more directory entries to search for 
.................... #define NO_MORE     2 
....................  
....................  
....................  
.................... // Summary: A macro indicating the device is formatted with FAT12 
.................... // Description: The FAT12 macro is used to indicate that the file system on the device being accessed is a FAT12 file system. 
.................... #define FAT12       1 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT16 
.................... // Description: The FAT16 macro is used to indicate that the file system on the device being accessed is a FAT16 file system. 
.................... #define FAT16       2 
....................  
.................... // Summary: A macro indicating the device is formatted with FAT32 
.................... // Description: The FAT32 macro is used to indicate that the file system on the device being accessed is a FAT32 file system. 
.................... #define FAT32       3 
....................  
....................  
....................  
.................... // Summary: A read-only attribute macro 
.................... // Description: A macro for the read-only attribute.  A file with this attribute should not be written to.  Note that this 
.................... //              attribute will not actually prevent a write to the file; that functionality is operating-system dependant.  The 
.................... //              user should take care not to write to a read-only file. 
.................... #define ATTR_READ_ONLY      0x01 
....................  
.................... // Summary: A hidden attribute macro 
.................... // Description: A macro for the hidden attribute.  A file with this attribute may be hidden from the user, depending on the 
.................... //              implementation of the operating system. 
.................... #define ATTR_HIDDEN         0x02 
....................  
.................... // Summary: A system attribute macro 
.................... // Description: A macro for the system attribute.  A file with this attribute is used by the operating system, and should not be 
.................... //              modified.  Note that this attribute will not actually prevent a write to the file. 
.................... #define ATTR_SYSTEM         0x04 
....................  
.................... // Summary: A volume attribute macro 
.................... // Description: A macro for the volume attribute.  If the first directory entry in the root directory has the volume attribute set, 
.................... //              the device will use the name in that directory entry as the volume name. 
.................... #define ATTR_VOLUME         0x08 
....................  
.................... // Summary: A macro for the attributes for a long-file name entry 
.................... // Description: A macro for the long-name attributes.  If a directory entry is used in a long-file name implementation, it will have 
.................... //              all four lower bits set.  This indicates that any software that does not support long file names should ignore that 
.................... //              entry. 
.................... #define ATTR_LONG_NAME      0x0f 
....................  
.................... // Summary: A directory attribute macro 
.................... // Description: A macro for the directory attribute.  If a directory entry has this attribute set, the file it points to is a directory- 
.................... //              type file, and will contain directory entries that point to additional directories or files. 
.................... #define ATTR_DIRECTORY      0x10 
....................  
.................... // Summary: An archive attribute macro 
.................... // Description: A macro for the archive attribute.  This attribute will indicate to some archiving programs that the file with this 
.................... //              attribute needs to be backed up.  Most operating systems create files with the archive attribute set. 
.................... #define ATTR_ARCHIVE        0x20 
....................  
.................... // Summary: A macro for all attributes 
.................... // Description: A macro for all attributes.  The search functions in this library require an argument that determines which attributes 
.................... //              a file is allowed to have in order to be found.  If ATTR_MASK is specified as this argument, any file may be found, regardless 
.................... //              of its attributes. 
.................... #define ATTR_MASK           0x3f 
....................  
....................  
....................  
.................... // Summary: A macro to indicate an empty FAT entry 
.................... // Description: The CLUSTER_EMPTY value is used to indicate that a FAT entry and it's corresponding cluster are available. 
.................... #define CLUSTER_EMPTY               0x0000  
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT12 
.................... // Description: The LAST_CLUSTER_FAT12 macro is used when reading the FAT to indicate that the next FAT12 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT12          0xff8 
....................  
.................... // Summary: A macro to indicate the last cluster value for FAT16 
.................... // Description: The LAST_CLUSTER_FAT16 macro is used when reading the FAT to indicate that the next FAT16 entry for a file contains 
.................... //              the end-of-file value. 
.................... #define LAST_CLUSTER_FAT16          0xfff8 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT12 
.................... // Description: The END_CLUSTER_FAT12 value is used as a comparison in FAT12 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT12           0xFF7 
....................  
.................... // Summary: A macro to indicate the last allocatable cluster for FAT16 
.................... // Description: The END_CLUSTER_FAT16 value is used as a comparison in FAT16 to determine that the firmware has reached the end of 
.................... //              the range of allowed allocatable clusters. 
.................... #define END_CLUSTER_FAT16           0xFFF7 
....................  
.................... // Summary: A macro to indicate the failure of the ReadFAT function 
.................... // Description: The CLUSTER_FAIL_FAT16 macro is used by the ReadFAT function to indicate that an error occured reading a FAT12 or FAT16 
.................... //              file allocation table.  Note that since '0xFFF8' is used for the last cluster return value in the FAT16 implementation 
.................... //              the end-of-file value '0xFFFF' can be used to indicate an error condition. 
.................... #define CLUSTER_FAIL_FAT16          0xFFFF 
....................  
....................  
....................  
.................... #ifdef SUPPORT_FAT32 
....................     // Summary: A macro to indicate the last cluster value for FAT32 
....................     // Description: The LAST_CLUSTER_FAT32 macro is used when reading the FAT to indicate that the next FAT32 entry for a file contains 
....................     //              the end-of-file value. 
....................     #define LAST_CLUSTER_FAT32      0x0FFFFFF8 
....................  
....................     // Summary: A macro to indicate the last allocatable cluster for FAT32 
....................     // Description: The END_CLUSTER_FAT32 value is used as a comparison in FAT32 to determine that the firmware has reached the end of 
....................     //              the range of allowed allocatable clusters. 
....................     #define END_CLUSTER_FAT32       0x0FFFFFF7 
....................  
....................     // Summary: A macro to indicate the failure of the ReadFAT function 
....................     // Description: The CLUSTER_FAIL_FAT32 macro is used by the ReadFAT function to indicate that an error occured reading a FAT32 
....................     //              file allocation able. 
....................     #define CLUSTER_FAIL_FAT32      0x0FFFFFFF 
....................  
.................... #endif 
....................  
.................... // Summary: A macro indicating the number of bytes in a directory entry. 
.................... // Description: The NUMBER_OF_BYTES_IN_DIR_ENTRY macro represents the number of bytes in one directory entry.  It is used to calculate 
.................... //              the number of sectors in the root directory based on information in the boot sector. 
.................... #define NUMBER_OF_BYTES_IN_DIR_ENTRY    32 
....................  
....................  
....................  
.................... // Summary: A macro for a deleted dir entry marker. 
.................... // Description: The DIR_DEL macro is used to mark a directory entry as deleted.  When a file is deleted, this value will replace the 
.................... //              first character in the file name, and will indicate that the file the entry points to was deleted. 
.................... #define DIR_DEL             0xE5 
....................  
.................... // Summary: A macro for the last dir entry marker. 
.................... // Description: The DIR_EMPTY macro is used to indicate the last entry in a directory.  Since entries in use cannot start with a 0 and 
.................... //              deleted entries start with the DIR_DEL character, a 0 will mark the end of the in-use or previously used group of 
.................... //              entries in a directory 
.................... #define DIR_EMPTY           0 
....................  
....................  
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name 
.................... // Description: The DIR_NAMESIZE macro is used when validing the name portion of 8.3 filenames 
.................... #define DIR_NAMESIZE        8 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file extension 
.................... // Description: The DIR_EXTENSION macro is used when validating the extension portion of 8.3 filenames 
.................... #define DIR_EXTENSION       3 
....................  
.................... // Summary: A macro used to indicate the length of an 8.3 file name and extension 
.................... // Description: The DIR_NAMECOMP macro is used when validating 8.3 filenames 
.................... #define DIR_NAMECOMP        (DIR_NAMESIZE+DIR_EXTENSION) 
....................  
....................  
....................  
.................... // Summary: A macro to write a byte to RAM 
.................... // Description: The RAMwrite macro is used to write a byte of data to a RAM array 
.................... #define RAMwrite( a, f, d) *(a+f) = d 
....................  
.................... // Summary: A macro to read a byte from RAM 
.................... // Description: The RAMread macro is used to read a byte of data from a RAM array 
.................... #define RAMread( a, f)  *(a+f) 
....................  
.................... // Summary: A macro to read a 16-bit word from RAM 
.................... // Description: The RAMreadW macro is used to read two bytes of data from a RAM array 
.................... #define RAMreadW( a, f) *(WORD *)(a+f) 
....................  
.................... // Summary: A macro to read a 32-bit word from RAM 
.................... // Description: The RAMreadD macro is used to read four bytes of data from a RAM array 
.................... #define RAMreadD( a, f) *(DWORD *)(a+f) 
....................  
....................  
....................  
.................... #ifndef EOF 
....................     // Summary: Indicates error conditions or end-of-file conditions 
....................     // Description: The EOF macro is used to indicate error conditions in some function calls.  It is also used to indicate 
....................     //              that the end-of-file has been reached. 
....................     #define EOF             ((int)-1) 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing information about the device. 
.................... // Description: The DISK structure contains information about the device being accessed. 
.................... typedef struct 
.................... {  
....................     BYTE    *   buffer;         // Address of the global data buffer used to read and write file information 
....................     DWORD       firsts;         // Logical block address of the first sector of the FAT partition on the device 
....................     DWORD       fat;            // Logical block address of the FAT 
....................     DWORD       root;           // Logical block address of the root directory 
....................     DWORD       data;           // Logical block address of the data section of the device. 
....................     WORD        maxroot;        // The maximum number of entries in the root directory. 
....................     DWORD       maxcls;         // The maximum number of clusters in the partition. 
....................     DWORD       sectorSize;     // The size of a sector in bytes 
....................     DWORD       fatsize;        // The number of sectors in the FAT 
....................     BYTE        fatcopy;        // The number of copies of the FAT in the partition 
....................     BYTE        SecPerClus;     // The number of sectors per cluster in the data region 
....................     BYTE        type;           // The file system type of the partition (FAT12, FAT16 or FAT32) 
....................     BYTE        mount;          // Device mount flag (TRUE if disk was mounted successfully, FALSE otherwise) 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... } __attribute__ ((packed)) DISK; 
.................... #else 
.................... } DISK; 
.................... #endif 
....................  
....................  
.................... #if defined(__18CXX) && !defined(__CCS__) 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef unsigned short long SWORD; 
.................... #else 
....................     // Summary: A 24-bit data type 
....................     // Description: The SWORD macro is used to defined a 24-bit data type.  For 16+ bit architectures, this must be represented as 
....................     //              an array of three bytes. 
....................     typedef struct 
....................     { 
....................         unsigned char array[3]; 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) SWORD; 
.................... #else 
....................     } SWORD; 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT12 file system (in the boot sector) 
.................... // Description: The _BPB_FAT12 structure provides a layout of the "bios parameter block" in the boot sector of a FAT12 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BPS;               // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD BootSec_ResrvSec;          // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD BootSec_RootDirEnts;       // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD BootSec_SPF;               // Number of sectors per FAT 
....................     WORD BootSec_SPT;               // Number of sectors per track 
....................     WORD BootSec_HeadCnt;           // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD  BootSec_Reserved;        // Reserved space 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved2;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination    
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT12; 
.................... #else 
....................     } _BPB_FAT12; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT16 file system (in the boot sector) 
.................... // Description: The _BPB_FAT16 structure provides a layout of the "bios parameter block" in the boot sector of a FAT16 partition. 
.................... typedef struct { 
....................     SWORD BootSec_JumpCmd;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD  BootSec_BPS;              // Number of bytes per sector 
....................     BYTE  BootSec_SPC;              // Number of sectors per cluster 
....................     WORD  BootSec_ResrvSec;         // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_FATCount;         // Number of FATs on the partition 
....................     WORD  BootSec_RootDirEnts;      // Number of root directory entries 
....................     WORD  BootSec_TotSec16;         // Total number of sectors 
....................     BYTE  BootSec_MDesc;            // Media descriptor 
....................     WORD  BootSec_SPF;              // Number of sectors per FAT 
....................     WORD  BootSec_SPT;              // Number of sectors per track 
....................     WORD  BootSec_HeadCnt;          // Number of heads 
....................     DWORD BootSec_HiddenSecCnt;     // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     BYTE  BootSec_DriveNum;         // Drive number 
....................     BYTE  BootSec_Reserved;         // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - equal to 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLabel[11];     // Volume Label 
....................     BYTE  BootSec_FSType[8];        // File system type in ASCII. Not used for determination      
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT16; 
.................... #else 
....................     } _BPB_FAT16; 
.................... #endif 
....................  
.................... // Summary: A structure containing the bios parameter block for a FAT32 file system (in the boot sector) 
.................... // Description: The _BPB_FAT32 structure provides a layout of the "bios parameter block" in the boot sector of a FAT32 partition. 
.................... typedef struct { 
....................     SWORD BootSec_jmpBoot;          // Jump Command 
....................     BYTE  BootSec_OEMName[8];       // OEM name 
....................     WORD BootSec_BytsPerSec;        // Number of bytes per sector 
....................     BYTE  BootSec_SecPerClus;       // Number of sectors per cluster 
....................     WORD BootSec_RsvdSecCnt;        // Number of reserved sectors at the beginning of the partition 
....................     BYTE  BootSec_NumFATs;          // Number of FATs on the partition 
....................     WORD BootSec_RootEntCnt;        // Number of root directory entries 
....................     WORD BootSec_TotSec16;          // Total number of sectors 
....................     BYTE  BootSec_Media;            // Media descriptor 
....................     WORD BootSec_FATSz16;           // Number of sectors per FAT 
....................     WORD BootSec_SecPerTrk;         // Number of sectors per track 
....................     WORD BootSec_NumHeads;          // Number of heads 
....................     DWORD BootSec_HiddSec;          // Number of hidden sectors 
....................     DWORD BootSec_TotSec32;         // Total sector count (32 bits) 
....................     DWORD BootSec_FATSz32;          // Sectors per FAT (32 bits) 
....................     WORD BootSec_ExtFlags;          // Presently active FAT. Defined by bits 0-3 if bit 7 is 1. 
....................     WORD BootSec_FSVers;            // FAT32 filesystem version.  Should be 0:0 
....................     DWORD BootSec_RootClus;         // Start cluster of the root directory (should be 2) 
....................     WORD BootSec_FSInfo;            // File system information 
....................     WORD BootSec_BkBootSec;         // Backup boot sector address. 
....................     BYTE  BootSec_Reserved[12];     // Reserved space 
....................     BYTE  BootSec_DrvNum;           // Drive number 
....................     BYTE  BootSec_Reserved1;        // Reserved space 
....................     BYTE  BootSec_BootSig;          // Boot signature - 0x29 
....................     BYTE  BootSec_VolID[4];         // Volume ID 
....................     BYTE  BootSec_VolLab[11];       // Volume Label 
....................     BYTE  BootSec_FilSysType[8];    // File system type in ASCII.  Not used for determination   
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BPB_FAT32; 
.................... #else 
....................     } _BPB_FAT32; 
.................... #endif 
....................  
....................  
.................... // Description: A macro for the boot sector bytes per sector value offset 
.................... #define BSI_BPS            11 
....................  
.................... // Description: A macro for the boot sector sector per cluster value offset 
.................... #define BSI_SPC            13 
....................  
.................... // Description: A macro for the boot sector reserved sector count value offset 
.................... #define BSI_RESRVSEC       14 
....................  
.................... // Description: A macro for the boot sector FAT count value offset 
.................... #define BSI_FATCOUNT       16 
....................  
.................... // Description: A macro for the boot sector root directory entry count value offset 
.................... #define BSI_ROOTDIRENTS    17 
....................  
.................... // Description: A macro for the boot sector 16-bit total sector count value offset 
.................... #define BSI_TOTSEC16       19 
....................  
.................... // Description: A macro for the boot sector sectors per FAT value offset 
.................... #define BSI_SPF            22 
....................  
.................... // Description: A macro for the boot sector 32-bit total sector count value offset 
.................... #define BSI_TOTSEC32       32 
....................  
.................... // Description: A macro for the boot sector boot signature offset 
.................... #define BSI_BOOTSIG        38 
....................  
.................... // Description: A macro for the boot sector file system type string offset 
.................... #define BSI_FSTYPE         54 
....................  
.................... // Description: A macro for the boot sector 32-bit sector per FAT value offset 
.................... #define  BSI_FATSZ32       36 
....................  
.................... // Description: A macro for the boot sector start cluster of root directory value offset 
.................... #define  BSI_ROOTCLUS      44 
....................  
.................... // Description: A macro for the FAT32 boot sector boot signature offset 
.................... #define  BSI_FAT32_BOOTSIG 66 
....................  
.................... // Description: A macro for the FAT32 boot sector file system type string offset 
.................... #define  BSI_FAT32_FSTYPE  82 
....................  
....................  
....................  
.................... // Summary: A partition table entry structure. 
.................... // Description: The PTE_MBR structure contains values found in a partition table entry in the MBR of a device. 
.................... typedef struct 
.................... { 
....................     BYTE      PTE_BootDes;            // The boot descriptor (should be 0x00 in a non-bootable device) 
....................     SWORD     PTE_FrstPartSect;       // The cylinder-head-sector address of the first sector of the partition 
....................     BYTE      PTE_FSDesc;             // The file system descriptor 
....................     SWORD     PTE_LstPartSect;        // The cylinder-head-sector address of the last sector of the partition 
....................     DWORD     PTE_FrstSect;           // The logical block address of the first sector of the partition 
....................     DWORD     PTE_NumSect;            // The number of sectors in a partition 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) PTE_MBR; 
.................... #else 
....................     } PTE_MBR; 
.................... #endif 
....................  
....................  
.................... // Summary: A structure of the organization of a master boot record. 
.................... // Description: The _PT_MBR structure has the same form as a master boot record.  When the MBR is loaded from the device, it will 
.................... //              be cast as a _PT_MBR structure so the MBR elements can be accessed. 
.................... typedef struct 
.................... { 
....................     BYTE        ConsChkRtn[446];        // Boot code 
....................     PTE_MBR     Partition0;             // The first partition table entry 
....................     PTE_MBR     Partition1;             // The second partition table entry 
....................     PTE_MBR     Partition2;             // The third partition table entry 
....................     PTE_MBR     Partition3;             // The fourth partition table entry 
....................     BYTE        Signature0;             // MBR signature code - equal to 0x55 
....................     BYTE        Signature1;             // MBR signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
.................... }__attribute__((packed)) _PT_MBR; 
.................... #else 
.................... }_PT_MBR; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _PT_MBR structure 
.................... // Description: The PT_MBR pointer points to a _PT_MBR structure. 
.................... typedef _PT_MBR *  PT_MBR; 
....................  
....................  
....................  
.................... // Summary: A structure of the organization of a boot sector. 
.................... // Description: The _BootSec structure has the same form as a boot sector.  When the boot sector is loaded from the device, it will 
.................... //              be cast as a _BootSec structure so the boot sector elements can be accessed. 
.................... typedef struct 
.................... { 
....................     // A union of different bios parameter blocks 
....................     union 
....................     { 
....................         _BPB_FAT32  FAT_32; 
....................         _BPB_FAT16  FAT_16; 
....................         _BPB_FAT12  FAT_12; 
....................     }FAT; 
....................     BYTE    Reserved[512-sizeof(_BPB_FAT32)-2]; // Reserved space 
....................     BYTE    Signature0;         // Boot sector signature code - equal to 0x55 
....................     BYTE    Signature1;         // Boot sector signature code - equal to 0xAA 
.................... #if defined __PIC32MX__ || defined __C30__ 
....................     } __attribute__ ((packed)) _BootSec; 
.................... #else 
....................     } _BootSec; 
.................... #endif 
....................  
.................... // Summary: A pointer to a _BootSec structure 
.................... // Description: The BootSec pointer points to a _BootSec structure. 
.................... typedef _BootSec * BootSec; 
....................  
....................  
....................  
.................... // Summary: A macro indicating the offset for the master boot record 
.................... // Description: FO_MBR is a macro that indicates the addresss of the master boot record on the device.  When the device is initialized 
.................... //              this sector will be read 
.................... #define FO_MBR          0L 
....................  
....................  
....................  
.................... // Summary: A macro for the first boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_0 macro is used to determine that the first byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_0     0x55 
....................  
.................... // Summary: A macro for the second boot sector/MBR signature byte 
.................... // Description: The FAT_GOOD_SIGN_1 macro is used to determine that the second byte of the MBR or boot sector signature code is correct 
.................... #define FAT_GOOD_SIGN_1     0xAA 
....................  
....................  
.................... typedef struct  
.................... { 
....................     BYTE    errorCode; 
....................     union  
....................     { 
....................         BYTE    value; 
....................         struct  
....................         { 
....................             BYTE    sectorSize  : 1; 
....................             BYTE    maxLUN      : 1; 
....................         }   bits; 
....................     } validityFlags; 
....................      
....................     WORD    sectorSize; 
....................     BYTE    maxLUN; 
.................... } MEDIA_INFORMATION; 
....................  
.................... typedef enum 
.................... { 
....................     MEDIA_NO_ERROR,                     // No errors 
....................     MEDIA_DEVICE_NOT_PRESENT,           // The requested device is not present 
....................     MEDIA_CANNOT_INITIALIZE             // Cannot initialize media 
.................... } MEDIA_ERRORS;                 
....................  
....................  
.................... #endif 
....................  
.................... #include "MDD File System/SD-SPI.h" 
.................... /****************************************************************************** 
....................  * 
....................  *                Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        SD-SPI.h 
....................  * Dependencies:    GenericTypeDefs.h 
....................  *                  FSconfig.h 
....................  *                  FSDefs.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the "Company") for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
.................... #ifndef SDMMC_H 
.................... #define SDMMC_H 
....................  
.................... #include "../GenericTypeDefs.h" 
.................... #include "../FSconfig.h" 
.................... #include "FSDefs.h" 
....................  
....................  
.................... #ifdef __18CXX 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 4x prescale divider 
....................     #define   SYNC_MODE_FAST    0x00 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 16x prescale divider 
....................     #define   SYNC_MODE_MED     0x01 
....................     // Description: This macro is used to initialize a PIC18 SPI module with a 64x prescale divider 
....................     #define   SYNC_MODE_SLOW    0x02 
.................... #elif defined __PIC32MX__ 
....................     // Description: This macro is used to initialize a PIC32 SPI module 
....................     #define   SYNC_MODE_FAST    0x3E 
....................     // Description: This macro is used to initialize a PIC32 SPI module 
....................     #define   SYNC_MODE_SLOW    0x3C 
.................... #else 
....................     // Description: This macro indicates the SPI enable bit for 16-bit PICs 
....................     #ifndef MASTER_ENABLE_ON 
....................         #define  MASTER_ENABLE_ON       0x0020 
....................     #endif 
....................  
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module 
....................     #ifndef SYNC_MODE_FAST 
....................         #define   SYNC_MODE_FAST    0x3E 
....................     #endif 
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module 
....................     #ifndef SYNC_MODE_SLOW 
....................         #define   SYNC_MODE_SLOW    0x3C 
....................     #endif 
....................  
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module secondary prescaler 
....................     #ifndef SEC_PRESCAL_1_1 
....................         #define  SEC_PRESCAL_1_1        0x001c 
....................     #endif 
....................     // Description: This macro is used to initialize a 16-bit PIC SPI module primary prescaler 
....................     #ifndef PRI_PRESCAL_1_1 
....................         #define  PRI_PRESCAL_1_1        0x0003 
....................     #endif 
.................... #endif 
....................  
....................  
....................  
.................... /*****************************************************************/ 
.................... /*                  Strcutures and defines                       */ 
.................... /*****************************************************************/ 
....................  
....................  
.................... // Description: This macro represents an SD card start single data block token (used for single block writes) 
.................... #define DATA_START_TOKEN            0xFE 
....................  
.................... // Description: This macro represents an SD card start multi-block data token (used for multi-block writes) 
.................... #define DATA_START_MULTI_BLOCK_TOKEN    0xFC 
....................  
.................... // Description: This macro represents an SD card stop transmission token.  This is used when finishing a multi block write sequence. 
.................... #define DATA_STOP_TRAN_TOKEN        0xFD 
....................  
.................... // Description: This macro represents an SD card data accepted token 
.................... #define DATA_ACCEPTED               0x05 
....................  
.................... // Description: This macro indicates that the SD card expects to transmit or receive more data 
.................... #define MOREDATA    !0 
....................  
.................... // Description: This macro indicates that the SD card does not expect to transmit or receive more data 
.................... #define NODATA      0 
....................  
.................... // Description: This macro represents a floating SPI bus condition 
.................... #define MMC_FLOATING_BUS    0xFF 
....................  
.................... // Description: This macro represents a bad SD card response byte 
.................... #define MMC_BAD_RESPONSE    MMC_FLOATING_BUS 
....................  
.................... // The SDMMC Commands 
....................  
.................... // Description: This macro defines the command code to reset the SD card 
.................... #define     cmdGO_IDLE_STATE        0 
.................... // Description: This macro defines the command code to initialize the SD card 
.................... #define     cmdSEND_OP_COND         1         
.................... // Description: This macro defined the command code to check for sector addressing 
.................... #define     cmdSEND_IF_COND         8 
.................... // Description: This macro defines the command code to get the Card Specific Data 
.................... #define     cmdSEND_CSD             9 
.................... // Description: This macro defines the command code to get the Card Information 
.................... #define     cmdSEND_CID             10 
.................... // Description: This macro defines the command code to stop transmission during a multi-block read 
.................... #define     cmdSTOP_TRANSMISSION    12 
.................... // Description: This macro defines the command code to get the card status information 
.................... #define     cmdSEND_STATUS          13 
.................... // Description: This macro defines the command code to set the block length of the card 
.................... #define     cmdSET_BLOCKLEN         16 
.................... // Description: This macro defines the command code to read one block from the card 
.................... #define     cmdREAD_SINGLE_BLOCK    17 
.................... // Description: This macro defines the command code to read multiple blocks from the card 
.................... #define     cmdREAD_MULTI_BLOCK     18 
.................... // Description: This macro defines the command code to tell the media how many blocks to pre-erase (for faster multi-block writes to follow) 
.................... //Note: This is an "application specific" command.  This tells the media how many blocks to pre-erase for the subsequent WRITE_MULTI_BLOCK 
.................... #define     cmdSET_WR_BLK_ERASE_COUNT   23 
.................... // Description: This macro defines the command code to write one block to the card 
.................... #define     cmdWRITE_SINGLE_BLOCK   24     
.................... // Description: This macro defines the command code to write multiple blocks to the card 
.................... #define     cmdWRITE_MULTI_BLOCK    25 
.................... // Description: This macro defines the command code to set the address of the start of an erase operation 
.................... #define     cmdTAG_SECTOR_START     32 
.................... // Description: This macro defines the command code to set the address of the end of an erase operation 
.................... #define     cmdTAG_SECTOR_END       33 
.................... // Description: This macro defines the command code to erase all previously selected blocks 
.................... #define     cmdERASE                38 
.................... //Description: This macro defines the command code to intitialize an SD card and provide the CSD register value. 
.................... //Note: this is an "application specific" command (specific to SD cards) and must be preceded by cmdAPP_CMD. 
.................... #define     cmdSD_SEND_OP_COND      41 
.................... // Description: This macro defines the command code to begin application specific command inputs 
.................... #define     cmdAPP_CMD              55 
.................... // Description: This macro defines the command code to get the OCR register information from the card 
.................... #define     cmdREAD_OCR             58 
.................... // Description: This macro defines the command code to disable CRC checking 
.................... #define     cmdCRC_ON_OFF           59 
....................  
....................  
.................... // Description: Enumeration of different SD response types 
.................... typedef enum 
.................... { 
....................     R1,     // R1 type response 
....................     R1b,    // R1b type response 
....................     R2,     // R2 type response 
....................     R3,     // R3 type response  
....................     R7      // R7 type response  
.................... }RESP; 
....................  
.................... // Summary: SD card command data structure 
.................... // Description: The typMMC_CMD structure is used to create a command table of information needed for each relevant SD command 
.................... typedef struct 
.................... { 
....................     BYTE      CmdCode;          // The command code 
....................     BYTE      CRC;              // The CRC value for that command 
....................     RESP    responsetype;       // The response type 
....................     BYTE    moredataexpected;   // Set to MOREDATA or NODATA, depending on whether more data is expected or not 
.................... } typMMC_CMD; 
....................  
....................  
.................... // Summary: An SD command packet 
.................... // Description: This union represents different ways to access an SD card command packet 
.................... typedef union 
.................... { 
....................     // This structure allows array-style access of command bytes 
....................     struct 
....................     { 
....................         #ifdef __18CXX 
....................             BYTE field[6];      // BYTE array 
....................         #else 
....................             BYTE field[7]; 
....................         #endif 
....................     }; 
....................     // This structure allows byte-wise access of packet command bytes 
....................     struct 
....................     { 
....................         BYTE crc;               // The CRC byte 
....................         #if defined __C30__ 
....................             BYTE c30filler;     // Filler space (since bitwise declarations can't cross a WORD boundary) 
....................         #elif defined __C32__ 
....................             BYTE c32filler[3];  // Filler space (since bitwise declarations can't cross a DWORD boundary) 
....................         #endif 
....................          
....................         BYTE addr0;             // Address byte 0 
....................         BYTE addr1;             // Address byte 1 
....................         BYTE addr2;             // Address byte 2 
....................         BYTE addr3;             // Address byte 3 
....................         BYTE cmd;               // Command code byte 
....................     }; 
....................     // This structure allows bitwise access to elements of the command bytes 
....................     struct 
....................     { 
....................         BYTE  END_BIT:1;        // Packet end bit 
....................         BYTE  CRC7:7;           // CRC value 
....................         DWORD     address;      // Address 
....................         BYTE  CMD_INDEX:6;      // Command code 
....................         BYTE  TRANSMIT_BIT:1;   // Transmit bit 
....................         BYTE  START_BIT:1;      // Packet start bit 
....................     }; 
.................... } CMD_PACKET; 
....................  
....................  
.................... // Summary: The format of an R1 type response 
.................... // Description: This union represents different ways to access an SD card R1 type response packet. 
.................... typedef union 
.................... { 
....................     BYTE _byte;                         // Byte-wise access 
....................     // This structure allows bitwise access of the response 
....................     struct 
....................     { 
....................         unsigned IN_IDLE_STATE:1;       // Card is in idle state 
....................         unsigned ERASE_RESET:1;         // Erase reset flag 
....................         unsigned ILLEGAL_CMD:1;         // Illegal command flag 
....................         unsigned CRC_ERR:1;             // CRC error flag 
....................         unsigned ERASE_SEQ_ERR:1;       // Erase sequence error flag 
....................         unsigned ADDRESS_ERR:1;         // Address error flag 
....................         unsigned PARAM_ERR:1;           // Parameter flag    
....................         unsigned B7:1;                  // Unused bit 7 
....................     }; 
.................... } RESPONSE_1; 
....................  
.................... // Summary: The format of an R2 type response 
.................... // Description: This union represents different ways to access an SD card R2 type response packet 
.................... typedef union 
.................... { 
....................     WORD _word; 
....................     struct 
....................     { 
....................         BYTE      _byte0; 
....................         BYTE      _byte1; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned IN_IDLE_STATE:1; 
....................         unsigned ERASE_RESET:1; 
....................         unsigned ILLEGAL_CMD:1; 
....................         unsigned CRC_ERR:1; 
....................         unsigned ERASE_SEQ_ERR:1; 
....................         unsigned ADDRESS_ERR:1; 
....................         unsigned PARAM_ERR:1; 
....................         unsigned B7:1; 
....................         unsigned CARD_IS_LOCKED:1; 
....................         unsigned WP_ERASE_SKIP_LK_FAIL:1; 
....................         unsigned ERROR:1; 
....................         unsigned CC_ERROR:1; 
....................         unsigned CARD_ECC_FAIL:1; 
....................         unsigned WP_VIOLATION:1; 
....................         unsigned ERASE_PARAM:1; 
....................         unsigned OUTRANGE_CSD_OVERWRITE:1; 
....................     }; 
.................... } RESPONSE_2; 
....................  
.................... // Summary: The format of an R7 or R3 type response 
.................... // Description: This union represents different ways to access an SD card R7 type response packet. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         BYTE _byte;                         // Byte-wise access 
....................         union 
....................         { 
....................             //Note: The SD card argument response field is 32-bit, big endian format. 
....................             //However, the C compiler stores 32-bit values in little endian in RAM. 
....................             //When writing to the _returnVal/argument bytes, make sure to byte 
....................             //swap the order from which it arrived over the SPI from the SD card. 
....................             DWORD _returnVal; 
....................             struct 
....................             { 
....................                 BYTE _byte0; 
....................                 BYTE _byte1; 
....................                 BYTE _byte2; 
....................                 BYTE _byte3; 
....................             };     
....................         }argument;     
....................     } bytewise; 
....................     // This structure allows bitwise access of the response 
....................     struct 
....................     { 
....................         struct 
....................         { 
....................             unsigned IN_IDLE_STATE:1;       // Card is in idle state 
....................             unsigned ERASE_RESET:1;         // Erase reset flag 
....................             unsigned ILLEGAL_CMD:1;         // Illegal command flag 
....................             unsigned CRC_ERR:1;             // CRC error flag 
....................             unsigned ERASE_SEQ_ERR:1;       // Erase sequence error flag 
....................             unsigned ADDRESS_ERR:1;         // Address error flag 
....................             unsigned PARAM_ERR:1;           // Parameter flag    
....................             unsigned B7:1;                  // Unused bit 7 
....................         }bits; 
....................         DWORD _returnVal; 
....................     } bitwise; 
.................... } RESPONSE_7; 
....................  
.................... // Summary: A union of responses from an SD card 
.................... // Description: The MMC_RESPONSE union represents any of the possible responses that an SD card can return after 
.................... //              being issued a command. 
.................... typedef union 
.................... { 
....................     RESPONSE_1  r1;   
....................     RESPONSE_2  r2; 
....................     RESPONSE_7  r7; 
.................... }MMC_RESPONSE; 
....................  
....................  
.................... // Summary: A description of the card specific data register 
.................... // Description: This union represents different ways to access information in a packet with SD card CSD informaiton.  For more 
.................... //              information on the CSD register, consult an SD card user's manual. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         DWORD _u320; 
....................         DWORD _u321; 
....................         DWORD _u322; 
....................         DWORD _u323; 
....................     }; 
....................     struct 
....................     { 
....................         BYTE _byte[16]; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned NOT_USED           :1; 
....................         unsigned CRC                :7; 
....................         unsigned ECC                :2; 
....................         unsigned FILE_FORMAT        :2; 
....................         unsigned TMP_WRITE_PROTECT  :1; 
....................         unsigned PERM_WRITE_PROTECT :1; 
....................         unsigned COPY               :1; 
....................         unsigned FILE_FORMAT_GRP    :1; 
....................         unsigned RESERVED_1         :5; 
....................         unsigned WRITE_BL_PARTIAL   :1; 
....................         unsigned WRITE_BL_LEN_L     :2; 
....................         unsigned WRITE_BL_LEN_H     :2; 
....................         unsigned R2W_FACTOR         :3; 
....................         unsigned DEFAULT_ECC        :2; 
....................         unsigned WP_GRP_ENABLE      :1; 
....................         unsigned WP_GRP_SIZE        :5; 
....................         unsigned ERASE_GRP_SIZE_L   :3; 
....................         unsigned ERASE_GRP_SIZE_H   :2; 
....................         unsigned SECTOR_SIZE        :5; 
....................         unsigned C_SIZE_MULT_L      :1; 
....................         unsigned C_SIZE_MULT_H      :2; 
....................         unsigned VDD_W_CURR_MAX     :3; 
....................         unsigned VDD_W_CUR_MIN      :3; 
....................         unsigned VDD_R_CURR_MAX     :3; 
....................         unsigned VDD_R_CURR_MIN     :3; 
....................         unsigned C_SIZE_L           :2; 
....................         unsigned C_SIZE_H           :8; 
....................         unsigned C_SIZE_U           :2; 
....................         unsigned RESERVED_2         :2; 
....................         unsigned DSR_IMP            :1; 
....................         unsigned READ_BLK_MISALIGN  :1; 
....................         unsigned WRITE_BLK_MISALIGN :1; 
....................         unsigned READ_BL_PARTIAL    :1; 
....................         unsigned READ_BL_LEN        :4; 
....................         unsigned CCC_L              :4; 
....................         unsigned CCC_H              :8; 
....................         unsigned TRAN_SPEED         :8; 
....................         unsigned NSAC               :8; 
....................         unsigned TAAC               :8; 
....................         unsigned RESERVED_3         :2; 
....................         unsigned SPEC_VERS          :4; 
....................         unsigned CSD_STRUCTURE      :2; 
....................     }; 
.................... } CSD; 
....................  
....................  
.................... // Summary: A description of the card information register 
.................... // Description: This union represents different ways to access information in a packet with SD card CID register informaiton.  For more 
.................... //              information on the CID register, consult an SD card user's manual. 
.................... typedef union 
.................... { 
....................     struct 
....................     { 
....................         DWORD _u320; 
....................         DWORD _u321; 
....................         DWORD _u322; 
....................         DWORD _u323; 
....................     }; 
....................     struct 
....................     { 
....................         BYTE _byte[16]; 
....................     }; 
....................     struct 
....................     { 
....................         unsigned    NOT_USED            :1; 
....................         unsigned    CRC                 :7; 
....................         unsigned    MDT                 :8; 
....................         DWORD       PSN; 
....................         unsigned    PRV                 :8; 
....................         char        PNM[6]; 
....................         WORD        OID; 
....................         unsigned    MID                 :8; 
....................     }; 
.................... } CID; 
....................  
.................... #ifndef FALSE 
....................     #define FALSE   0 
.................... #endif 
.................... #ifndef TRUE 
....................     #define TRUE    !FALSE 
.................... #endif 
....................  
.................... #define INPUT   1 
.................... #define OUTPUT  0 
....................  
....................  
.................... // Description: A delay prescaler 
.................... #define DELAY_PRESCALER   (BYTE)      8 
....................  
.................... // Description: An approximation of the number of cycles per delay loop of overhead 
.................... #define DELAY_OVERHEAD    (BYTE)      5 
....................  
.................... // Description: An approximate calculation of how many times to loop to delay 1 ms in the Delayms function 
.................... #define MILLISECDELAY   (WORD)      ((GetInstructionClock()/DELAY_PRESCALER/(WORD)1000) - DELAY_OVERHEAD) 
....................  
....................  
.................... // Desription: Media Response Delay Timeouts  
.................... #define NCR_TIMEOUT     (WORD)20        //Byte times before command response is expected (must be at least 8) 
.................... #define NAC_TIMEOUT     (DWORD)0x40000  //SPI byte times we should wait when performing read operations (should be at least 100ms for SD cards) 
.................... #define WRITE_TIMEOUT   (DWORD)0xA0000  //SPI byte times to wait before timing out when the media is performing a write operation (should be at least 250ms for SD cards). 
....................  
.................... // Summary: An enumeration of SD commands 
.................... // Description: This enumeration corresponds to the position of each command in the sdmmc_cmdtable array 
.................... //              These macros indicate to the SendMMCCmd function which element of the sdmmc_cmdtable array 
.................... //              to retrieve command code information from. 
.................... typedef enum 
.................... { 
....................     GO_IDLE_STATE, 
....................     SEND_OP_COND, 
....................     SEND_IF_COND, 
....................     SEND_CSD, 
....................     SEND_CID, 
....................     STOP_TRANSMISSION, 
....................     SEND_STATUS, 
....................     SET_BLOCKLEN, 
....................     READ_SINGLE_BLOCK, 
....................     READ_MULTI_BLOCK, 
....................     WRITE_SINGLE_BLOCK, 
....................     WRITE_MULTI_BLOCK, 
....................     TAG_SECTOR_START, 
....................     TAG_SECTOR_END, 
....................     ERASE, 
....................     APP_CMD, 
....................     READ_OCR, 
....................     CRC_ON_OFF, 
....................     SD_SEND_OP_COND, 
....................     SET_WR_BLK_ERASE_COUNT 
.................... }sdmmc_cmd; 
....................  
....................  
.................... #define SD_MODE_NORMAL  0 
.................... #define SD_MODE_HC      1 
....................  
....................  
.................... //Definition for a structure used when calling either MDD_SDSPI_AsyncReadTasks()  
.................... //function, or the MDD_SDSPI_AsyncWriteTasks() function. 
.................... typedef struct 
.................... { 
....................     WORD wNumBytes;         //Number of bytes to attempt to read or write in the next call to MDD_SDSPI_AsyncReadTasks() or MDD_SDSPI_AsyncWriteTasks.  May be updated between calls to the handler. 
....................     DWORD dwBytesRemaining; //Should be initialized to the total number of bytes that you wish to read or write.  This value is allowed to be greater than a single block size of the media. 
....................     BYTE* pBuffer;          //Pointer to where the read/written bytes should be copied to/from.  May be updated between calls to the handler function. 
....................     DWORD dwAddress;        //Starting block address to read or to write to on the media.  Should only get initialized, do not modify after that. 
....................     BYTE bStateVariable;    //State machine variable.  Should get initialized to ASYNC_READ_QUEUED or ASYNC_WRITE_QUEUED to start an operation.  After that, do not modify until the read or write is complete. 
.................... }ASYNC_IO;    
....................  
....................  
.................... //Response codes for the MDD_SDSPI_AsyncReadTasks() function. 
.................... #define ASYNC_READ_COMPLETE             0x00 
.................... #define ASYNC_READ_BUSY                 0x01 
.................... #define ASYNC_READ_NEW_PACKET_READY     0x02 
.................... #define ASYNC_READ_ERROR                0xFF 
....................  
.................... //MDD_SDSPI_AsyncReadTasks() state machine variable values.  These are used internally to SD-SPI.c. 
.................... //#define ASYNC_READ_COMPLETE             0x00 
.................... #define ASYNC_READ_QUEUED               0x01    //Initialize to this to start a read sequence 
.................... #define ASYNC_READ_WAIT_START_TOKEN     0x03 
.................... //#define ASYNC_READ_NEW_PACKET_READY     0x02 
.................... #define ASYNC_READ_ABORT                0xFE 
.................... //#define ASYNC_READ_ERROR                0xFF 
....................  
.................... //Possible return values when calling MDD_SDSPI_AsyncWriteTasks() 
.................... #define ASYNC_WRITE_COMPLETE        0x00 
.................... #define ASYNC_WRITE_SEND_PACKET     0x02 
.................... #define ASYNC_WRITE_BUSY            0x03 
.................... #define ASYNC_WRITE_ERROR           0xFF 
....................  
.................... //MDD_SDSPI_AsyncWriteTasks() state machine variable values.  These are used internally to SD-SPI.c. 
.................... //#define ASYNC_WRITE_COMPLETE            0x00 
.................... #define ASYNC_WRITE_QUEUED              0x01    //Initialize to this to start a write sequence 
.................... #define ASYNC_WRITE_TRANSMIT_PACKET     0x02 
.................... #define ASYNC_WRITE_MEDIA_BUSY          0x03 
.................... #define ASYNC_STOP_TOKEN_SENT_WAIT_BUSY 0x04 
.................... #define ASYNC_WRITE_ABORT               0xFE 
.................... //#define ASYNC_WRITE_ERROR               0xFF 
....................  
....................  
.................... //Constants 
.................... #define MEDIA_BLOCK_SIZE            512u  //Should always be 512 for v1 and v2 devices. 
.................... #define WRITE_RESPONSE_TOKEN_MASK   0x1F  //Bit mask to AND with the write token response byte from the media, to clear the don't care bits. 
....................  
....................  
....................  
.................... /***************************************************************************/ 
.................... /*                               Macros                                    */ 
.................... /***************************************************************************/ 
....................  
.................... // Description: A macro to send clock cycles to dummy-read the CRC 
.................... #define mReadCRC()              WriteSPIM(0xFF);WriteSPIM(0xFF); 
....................  
.................... // Description: A macro to send clock cycles to dummy-write the CRC 
.................... #define mSendCRC()              WriteSPIM(0xFF);WriteSPIM(0xFF); 
....................  
.................... // Description: A macro to send 8 clock cycles for SD timing requirements 
.................... #define mSend8ClkCycles()       WriteSPIM(0xFF); 
....................  
.................... /*****************************************************************************/ 
.................... /*                                 Public Prototypes                         */ 
.................... /*****************************************************************************/ 
....................  
.................... //These are the public API functions provided by SD-SPI.c 
.................... BYTE MDD_SDSPI_MediaDetect(void); 
.................... MEDIA_INFORMATION * MDD_SDSPI_MediaInitialize(void); 
.................... DWORD MDD_SDSPI_ReadCapacity(void); 
.................... WORD MDD_SDSPI_ReadSectorSize(void); 
.................... void MDD_SDSPI_InitIO(void); 
.................... BYTE MDD_SDSPI_SectorRead(DWORD sector_addr, BYTE* buffer); 
.................... BYTE MDD_SDSPI_SectorWrite(DWORD sector_addr, BYTE* buffer, BYTE allowWriteToZero); 
.................... BYTE MDD_SDSPI_AsyncReadTasks(ASYNC_IO*); 
.................... BYTE MDD_SDSPI_AsyncWriteTasks(ASYNC_IO*); 
.................... BYTE MDD_SDSPI_WriteProtectState(void); 
.................... BYTE MDD_SDSPI_ShutdownMedia(void); 
....................  
....................  
.................... #if defined __C30__ || defined __C32__ 
....................     extern BYTE ReadByte( BYTE* pBuffer, WORD index ); 
....................     extern WORD ReadWord( BYTE* pBuffer, WORD index ); 
....................     extern DWORD ReadDWord( BYTE* pBuffer, WORD index ); 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "string.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "FSconfig.h" 
.................... /****************************************************************************** 
....................  * 
....................  *               Microchip Memory Disk Drive File System 
....................  * 
....................  ****************************************************************************** 
....................  * FileName:        FSconfig.h 
....................  * Processor:       PIC18/PIC24/dsPIC30/dsPIC33/PIC32 
....................  * Dependencies:    None 
....................  * Compiler:        C18/C30/C32 
....................  * Company:         Microchip Technology, Inc. 
....................  * Version:         1.3.0 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
.................... *****************************************************************************/ 
....................  
....................  
.................... #ifndef _FS_DEF_ 
.................... #define _FS_DEF_ 
....................  
.................... //#include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // something to do with long filenames. 
.................... //#define SUPPORT_LFN 
....................  
.................... // Summary: A macro indicating the maximum number of concurrently open files 
.................... // Description: The FS_MAX_FILES_OPEN #define is only applicable when dynamic memory allocation is not used (FS_DYNAMIC_MEM is not defined). 
.................... //              This macro defines the maximum number of open files at any given time.  The amount of RAM used by FSFILE objects will 
.................... //              be equal to the size of an FSFILE object multipled by this macro value.  This value should be kept as small as possible 
.................... //              as dictated by the application.  This will reduce memory usage. 
.................... #define FS_MAX_FILES_OPEN    1 
....................  
....................  
.................... // if defined, MDD will be configured to use SST25 flash device. this definition 
.................... // should also define the size of the SST25 flash device. 
.................... // if not defined, will use SD card. 
.................... // #define  USE_SST25_INTERFACE  ((unsigned int32)2*1024*1024) 
....................  
.................... // Summary: A macro defining the size of a sector 
.................... // Description: The MEDIA_SECTOR_SIZE macro will define the size of a sector on the FAT file system.  This value must equal 512 bytes, 
.................... //              1024 bytes, 2048 bytes, or 4096 bytes.  The value of a sector will usually be 512 bytes. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define MEDIA_SECTOR_SIZE       4096   //erase size of SST25 flash device 
.................... #else 
.................... #define MEDIA_SECTOR_SIZE       512 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* *******************************************************************************************************/ 
.................... /************** Compiler options to enable/Disable Features based on user's application ******************/ 
.................... /* *******************************************************************************************************/ 
....................  
....................  
.................... // Summary: A macro to enable/disable file search functions. 
.................... // Description: The ALLOW_FILESEARCH definition can be commented out to disable file search functions in the library.  This will 
.................... //              prevent the use of the FindFirst and FindNext functions and reduce code size. 
.................... #define ALLOW_FILESEARCH 
....................  
.................... // Summary: A macro to enable/disable write functionality 
.................... // Description: The ALLOW_WRITES definition can be commented out to disable all operations that write to the device.  This will 
.................... //              greatly reduce code size. 
.................... #define ALLOW_WRITES 
....................  
....................  
.................... // Summary: A macro to enable/disable format functionality 
.................... // Description: The ALLOW_FORMATS definition can be commented out to disable formatting functionality.  This will prevent the use of 
.................... //              the FSformat function.  If formats are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES. 
.................... #if defined(USE_SST25_INTERFACE) 
.................... #define ALLOW_FORMATS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable directory operations. 
.................... // Description: The ALLOW_DIRS definition can be commented out to disable all directory functionality.  This will reduce code size. 
.................... //              If directories are enabled, write operations must also be enabled by uncommenting ALLOW_WRITES in order to use 
.................... //              the FSmkdir or FSrmdir functions. 
.................... #define ALLOW_DIRS 
....................  
.................... // Summary: A macro to enable/disable PIC18 ROM functions. 
.................... // Description: The ALLOW_PGMFUNCTIONS definition can be commented out to disable all PIC18 functions that allow the user to pass string 
.................... //              arguments in ROM (denoted by the suffix -pgm).  Note that this functionality must be disabled when not using PIC18. 
.................... #if !defined(__CCS__) 
.................... #define ALLOW_PGMFUNCTIONS 
.................... #endif 
....................  
.................... // Summary: A macro to enable/disable the FSfprintf function. 
.................... // Description: The ALLOW_FSFPRINTF definition can be commented out to disable the FSfprintf function.  This will save code space.  Note that 
.................... //              if FSfprintf is enabled and the PIC18 architecture is used, integer promotions must be enabled in the Project->Build Options 
.................... //              menu.  Write operations must be enabled to use FSfprintf. 
.................... //#define ALLOW_FSFPRINTF 
....................  
.................... // CCS added this config option to disable FAT12 to prevent recursion. 
.................... //__CCS__ added by ccs 
.................... //#define SUPPORT_FAT12 
....................  
.................... // Summary: A macro to enable/disable FAT32 support. 
.................... // Description: The SUPPORT_FAT32 definition can be commented out to disable support for FAT32 functionality.  This will save a small amount 
.................... //              of code space. 
.................... #define SUPPORT_FAT32 
....................  
....................  
....................  
.................... /**************************************************************************************************/ 
.................... // Select a method for updating file timestamps 
.................... /**************************************************************************************************/ 
....................  
.................... // Summary: A macro to enable RTCC based timestamp generation 
.................... // Description: The USEREALTIMECLOCK macro will configure the code to automatically 
.................... //              generate timestamp information for files from the RTCC module. The user 
.................... //              must enable and configure the RTCC module before creating or modifying 
.................... //              files.                                                                  
.................... //#define USEREALTIMECLOCK 
....................  
.................... // Summary: A macro to enable manual timestamp generation 
.................... // Description: The USERDEFINEDCLOCK macro will allow the user to manually set 
.................... //              timestamp information using the SetClockVars function. The user will 
.................... //              need to set the time variables immediately before creating or closing a 
.................... //              file or directory.                                                     
.................... #define USERDEFINEDCLOCK 
....................  
.................... // Summary: A macro to enable don't-care timestamp generation 
.................... // Description: The INCREMENTTIMESTAMP macro will set the create time of a file to a 
.................... //              static value and increment it when a file is updated. This timestamp 
.................... //              generation method should only be used in applications where file times 
.................... //              are not necessary.                                                     
.................... //#define INCREMENTTIMESTAMP 
....................  
....................  
.................... #ifdef __18CXX 
....................    #ifdef USEREALTIMECLOCK 
....................       #error Not all PIC18 devices have a Real-time clock and calander module 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef ALLOW_PGMFUNCTIONS 
....................    #ifndef __18CXX 
....................       #error The pgm functions are unneccessary when not using PIC18 
....................    #endif 
.................... #endif 
....................  
.................... #ifndef USEREALTIMECLOCK 
....................     #ifndef USERDEFINEDCLOCK 
....................         #ifndef INCREMENTTIMESTAMP 
....................             #error Please enable USEREALTIMECLOCK, USERDEFINEDCLOCK, or INCREMENTTIMESTAMP 
....................         #endif 
....................     #endif 
.................... #endif 
....................  
.................... /************************************************************************/ 
.................... // Set this preprocessor option to '1' to use dynamic FSFILE object allocation.  It will 
.................... // be necessary to allocate a heap when dynamically allocating FSFILE objects. 
.................... // Set this option to '0' to use static FSFILE object allocation. 
.................... /************************************************************************/ 
....................  
.................... //#if 1  //from mirochip 
.................... #if defined(__PCH__) //__CCS__ 
....................     // Summary: A macro indicating that FSFILE objects will be allocated dynamically 
....................     // Description: The FS_DYNAMIC_MEM macro will cause FSFILE objects to be allocated from a dynamic heap.  If it is undefined, 
....................     //              the file objects will be allocated using a static array. 
....................    //#define FS_DYNAMIC_MEM 
....................    #ifdef __18CXX 
....................         // Description: Function pointer to a dynamic memory allocation function 
....................       #define FS_malloc   SRAMalloc 
....................         // Description: Function pointer to a dynamic memory free function 
....................       #define FS_free      SRAMfree 
....................    #else 
....................       #define FS_malloc   malloc 
....................       #define FS_free      free 
....................    #endif 
.................... #elif defined(__CCS__) 
....................    #error/warning Not using FS_DYNAMIC_MEM for PCD compiler 
.................... #endif 
....................  
....................  
.................... #ifdef __18CXX 
....................     /* Define the locations for the dataBuffer and FATbuffer; PLEASE CHECK THE LINKER FILE */ 
....................     #define DATA_BUFFER_ADDRESS      0x700 
....................     #define FAT_BUFFER_ADDRESS       0x900 
.................... #endif 
....................  
....................  
.................... // Function definitions 
.................... // Associate the physical layer functions with the correct physical layer 
.................... #ifdef USE_SD_INTERFACE_WITH_SPI       // SD-SPI.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_SDSPI_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_SDSPI_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_SDSPI_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_SDSPI_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_SDSPI_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_SDSPI_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_SDSPI_WriteProtectState 
....................  
....................     // Description: Function pointer to the Read Capacity Physical Layer function 
....................     #define MDD_ReadCapacity        MDD_SDSPI_ReadCapacity 
....................  
....................     // Description: Function pointer to the Read Sector Size Physical Layer Function 
....................     #define MDD_ReadSectorSize      MDD_SDSPI_ReadSectorSize 
....................  
.................... #elif defined USE_CF_INTERFACE_WITH_PMP       // CF-PMP.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFPMP_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFPMP_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFPMP_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFPMP_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFPMP_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFPMP_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFPMP_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFPMP_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFPMP_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFPMP_CFread 
....................  
.................... #elif defined USE_MANUAL_CF_INTERFACE         // CF-Bit transaction.c and .h 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     MDD_CFBT_MediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         MDD_CFBT_MediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          MDD_CFBT_SectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         MDD_CFBT_SectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO              MDD_CFBT_InitIO 
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       MDD_CFBT_ShutdownMedia 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   MDD_CFBT_WriteProtectState 
....................  
....................     // Description: Function pointer to the CompactFlash Wait Physical Layer function 
....................     #define MDD_CFwait              MDD_CFBT_CFwait 
....................  
....................     // Description: Function pointer to the CompactFlash Write Physical Layer function 
....................     #define MDD_CFwrite             MDD_CFBT_CFwrite 
....................  
....................     // Description: Function pointer to the CompactFlash Read Physical Layer function 
....................     #define MDD_CFread              MDD_CFBT_CFread 
....................  
.................... #elif defined USE_USB_INTERFACE               // USB host MSD library 
....................  
....................     // Description: Function pointer to the Media Initialize Physical Layer function 
....................     #define MDD_MediaInitialize     USBHostMSDSCSIMediaInitialize 
....................  
....................     // Description: Function pointer to the Media Detect Physical Layer function 
....................     #define MDD_MediaDetect         USBHostMSDSCSIMediaDetect 
....................  
....................     // Description: Function pointer to the Sector Read Physical Layer function 
....................     #define MDD_SectorRead          USBHostMSDSCSISectorRead 
....................  
....................     // Description: Function pointer to the Sector Write Physical Layer function 
....................     #define MDD_SectorWrite         USBHostMSDSCSISectorWrite 
....................  
....................     // Description: Function pointer to the I/O Initialization Physical Layer function 
....................     #define MDD_InitIO();               
....................  
....................     // Description: Function pointer to the Media Shutdown Physical Layer function 
....................     #define MDD_ShutdownMedia       USBHostMSDSCSIMediaReset 
....................  
....................     // Description: Function pointer to the Write Protect Check Physical Layer function 
....................     #define MDD_WriteProtectState   USBHostMSDSCSIWriteProtectState 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Global Variables 
....................  *****************************************************************************/ 
....................  
.................... // Description:  Used for the mass-storage library to determine capacity 
.................... DWORD MDD_SDSPI_finalLBA; 
.................... WORD gMediaSectorSize; 
.................... BYTE gSDMode; 
.................... static MEDIA_INFORMATION mediaInformation; 
.................... static ASYNC_IO ioInfo; //Declared global context, for fast/code efficient access 
....................  
....................  
.................... #ifdef __18CXX 
....................     // Summary: Table of SD card commands and parameters 
....................     // Description: The sdmmc_cmdtable contains an array of SD card commands, the corresponding CRC code, the 
....................     //              response type that the card will return, and a parameter indicating whether to expect 
....................     //              additional data from the card. 
....................     const rom typMMC_CMD sdmmc_cmdtable[] = 
.................... #else 
....................     const typMMC_CMD sdmmc_cmdtable[] = 
.................... #endif 
.................... { 
....................     // cmd                      crc     response 
....................     {cmdGO_IDLE_STATE,          0x95,   R1,     NODATA}, 
....................     {cmdSEND_OP_COND,           0xF9,   R1,     NODATA}, 
....................     {cmdSEND_IF_COND,            0x87,   R7,     NODATA}, 
....................     {cmdSEND_CSD,               0xAF,   R1,     MOREDATA}, 
....................     {cmdSEND_CID,               0x1B,   R1,     MOREDATA}, 
....................     {cmdSTOP_TRANSMISSION,      0xC3,   R1b,    NODATA}, 
....................     {cmdSEND_STATUS,            0xAF,   R2,     NODATA}, 
....................     {cmdSET_BLOCKLEN,           0xFF,   R1,     NODATA}, 
....................     {cmdREAD_SINGLE_BLOCK,      0xFF,   R1,     MOREDATA}, 
....................     {cmdREAD_MULTI_BLOCK,       0xFF,   R1,     MOREDATA}, 
....................     {cmdWRITE_SINGLE_BLOCK,     0xFF,   R1,     MOREDATA}, 
....................     {cmdWRITE_MULTI_BLOCK,      0xFF,   R1,     MOREDATA},  
....................     {cmdTAG_SECTOR_START,       0xFF,   R1,     NODATA}, 
....................     {cmdTAG_SECTOR_END,         0xFF,   R1,     NODATA}, 
....................     {cmdERASE,                  0xDF,   R1b,    NODATA}, 
....................     {cmdAPP_CMD,                0x73,   R1,     NODATA}, 
....................     {cmdREAD_OCR,               0x25,   R7,     NODATA}, 
....................     {cmdCRC_ON_OFF,             0x25,   R1,     NODATA}, 
....................     {cmdSD_SEND_OP_COND,        0xFF,   R7,     NODATA}, //Actual response is R3, but has same number of bytes as R7. 
....................     {cmdSET_WR_BLK_ERASE_COUNT, 0xFF,   R1,     NODATA} 
.................... }; 
....................  
....................  
....................  
....................  
.................... /****************************************************************************** 
....................  * Prototypes 
....................  *****************************************************************************/ 
.................... extern void Delayms(BYTE milliseconds); 
.................... BYTE MDD_SDSPI_ReadMedia(void); 
.................... MEDIA_INFORMATION * MDD_SDSPI_MediaInitialize(void); 
.................... MMC_RESPONSE SendMMCCmd(BYTE cmd, DWORD address); 
....................  
.................... #if defined __C30__ || defined __C32__ 
....................     void OpenSPIM ( unsigned int sync_mode); 
....................     void CloseSPIM( void ); 
....................     unsigned char WriteSPIM( unsigned char data_out ); 
.................... #elif defined __18CXX 
....................     void OpenSPIM ( unsigned char sync_mode); 
....................     void CloseSPIM( void ); 
....................     unsigned char WriteSPIM( unsigned char data_out ); 
....................  
....................     unsigned char WriteSPIManual(unsigned char data_out); 
....................     BYTE ReadMediaManual (void); 
....................     MMC_RESPONSE SendMMCCmdManual(BYTE cmd, DWORD address); 
.................... #endif 
.................... void InitSPISlowMode(void); 
....................  
.................... #if defined __18CXX 
.................... //Private function prototypes 
.................... static void PIC18_Optimized_SPI_Write_Packet(void); 
.................... static void PIC18_Optimized_SPI_Read_Packet(void); 
.................... #endif 
....................  
.................... //-------------Function name redirects------------------------------------------ 
.................... //During the media initialization sequence, it is 
.................... //necessary to clock the media at no more than 400kHz SPI speeds, since some 
.................... //media types power up in open drain output mode and cannot run fast initially. 
.................... //On PIC18 devices, when the CPU is run at full frequency, the standard SPI  
.................... //prescalars cannot reach a low enough SPI frequency.  Therefore, we initialize 
.................... //the card at low speed using bit-banged SPI on PIC18 devices.  On  
.................... //PIC32/PIC24/dsPIC devices, the SPI module is flexible enough to reach <400kHz 
.................... //speeds regardless of CPU frequency, and therefore bit-banged code is not  
.................... //necessary.  Therefore, we use function redirects where necessary, to point to 
.................... //the proper SPI related code, given the processor type. 
....................  
.................... #if defined __18CXX 
....................     #define SendMediaSlowCmd    SendMMCCmdManual 
....................     #define WriteSPISlow        WriteSPIManual 
.................... #else 
....................     #define SendMediaSlowCmd    SendMMCCmd 
....................     #define WriteSPISlow        WriteSPIM 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... #ifdef __PIC32MX__ 
.................... /********************************************************* 
....................   Function: 
....................     static inline __attribute__((always_inline)) unsigned char SPICacutateBRG (unsigned int pb_clk, unsigned int spi_clk) 
....................   Summary: 
....................     Calculate the PIC32 SPI BRG value 
....................   Conditions: 
....................     None 
....................   Input: 
....................     pb_clk -  The value of the PIC32 peripheral clock 
....................     spi_clk - The desired baud rate 
....................   Return: 
....................     The corresponding BRG register value. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The SPICalutateBRG function is used to determine an appropriate BRG register value for the PIC32 SPI module. 
....................   Remarks: 
....................     None                                                   
....................   *********************************************************/ 
....................  
.................... static inline __attribute__((always_inline)) unsigned char SPICalutateBRG(unsigned int pb_clk, unsigned int spi_clk) 
.................... { 
....................     unsigned int brg; 
....................  
....................     brg = pb_clk / (2 * spi_clk); 
....................  
....................     if(pb_clk % (2 * spi_clk)) 
....................         brg++; 
....................  
....................     if(brg > 0x100) 
....................         brg = 0x100; 
....................  
....................     if(brg) 
....................         brg--; 
....................  
....................     return (unsigned char) brg; 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     BYTE MDD_SDSPI_MediaDetect 
....................   Summary: 
....................     Determines whether an SD card is present 
....................   Conditions: 
....................     The MDD_MediaDetect function pointer must be configured 
....................     to point to this function in FSconfig.h 
....................   Input: 
....................     None 
....................   Return Values: 
....................     TRUE -  Card detected 
....................     FALSE - No card detected 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_MediaDetect function determine if an SD card is connected to  
....................     the microcontroller. 
....................     If the MEDIA_SOFT_DETECT is not defined, the detection is done by polling 
....................     the SD card detect pin. 
....................     The MicroSD connector does not have a card detect pin, and therefore a 
....................     software mechanism must be used. To do this, the SEND_STATUS command is sent  
....................     to the card. If the card is not answering with 0x00, the card is either not  
....................     present, not configured, or in an error state. If this is the case, we try 
....................     to reconfigure the card. If the configuration fails, we consider the card not  
....................     present (it still may be present, but malfunctioning). In order to use the  
....................     software card detect mechanism, the MEDIA_SOFT_DETECT macro must be defined. 
....................      
....................   Remarks: 
....................     None                                                   
....................   *********************************************************/ 
....................  
.................... BYTE MDD_SDSPI_MediaDetect (void) 
.................... { 
.................... #ifndef MEDIA_SOFT_DETECT 
....................     return(!SD_CD); 
.................... #else 
....................    MMC_RESPONSE    response; 
....................  
....................     //First check if SPI module is enabled or not. 
....................    if (SPIENABLE == 0) 
....................    { 
....................         unsigned char timeout; 
....................  
....................       //If the SPI module is not enabled, then the media has evidently not 
....................       //been initialized.  Try to send CMD0 and CMD13 to reset the device and 
....................       //get it into SPI mode (if present), and then request the status of 
....................       //the media.  If this times out, then the card is presumably not physically 
....................       //present. 
....................        
....................       InitSPISlowMode(); 
....................        
....................         //Send CMD0 to reset the media 
....................        //If the card is physically present, then we should get a valid response. 
....................         timeout = 4; 
....................         do 
....................         { 
....................             //Toggle chip select, to make media abandon whatever it may have been doing 
....................             //before.  This ensures the CMD0 is sent freshly after CS is asserted low, 
....................             //minimizing risk of SPI clock pulse master/slave syncronization problems,  
....................             //due to possible application noise on the SCK line. 
....................             SD_CS = 1; 
....................             WriteSPISlow(0xFF);   //Send some "extraneous" clock pulses.  If a previous 
....................                                   //command was terminated before it completed normally, 
....................                                   //the card might not have received the required clocking 
....................                                   //following the transfer. 
....................             SD_CS = 0; 
....................             timeout--; 
....................      
....................             //Send CMD0 to software reset the device 
....................             response = SendMediaSlowCmd(GO_IDLE_STATE, 0x0); 
....................         } while((response.r1._byte != 0x01) && (timeout != 0)); 
....................  
....................        //Check if response was invalid (R1 response byte should be = 0x01 after GO_IDLE_STATE) 
....................        if(response.r1._byte != 0x01) 
....................        { 
....................            CloseSPIM(); 
....................            return FALSE; 
....................        }     
....................        else 
....................        { 
....................            //Card is presumably present.  The SDI pin should have a pull up resistor on 
....................            //it, so the odds of SDI "floating" to 0x01 after sending CMD0 is very 
....................            //remote, unless the media is genuinely present.  Therefore, we should 
....................            //try to perform a full card initialization sequence now. 
....................           MDD_SDSPI_MediaInitialize();    //Can block and take a long time to execute. 
....................           if(mediaInformation.errorCode == MEDIA_NO_ERROR) 
....................           { 
....................              /* if the card was initialized correctly, it means it is present */ 
....................              return TRUE; 
....................           } 
....................           else  
....................           { 
....................               CloseSPIM(); 
....................              return FALSE; 
....................           }       
....................  
....................        }     
....................    }//if (SPIENABLE == 0) 
....................    else 
....................    { 
....................        //The SPI module was already enabled.  This most likely means the media is 
....................        //present and has already been initialized.  However, it is possible that 
....................        //the user could have unplugged the media, in which case it is no longer 
....................        //present.  We should send it a command, to check the status. 
....................        response = SendMMCCmd(SEND_STATUS,0x0); 
....................        if((response.r2._word & 0xEC0C) != 0x0000) 
....................        { 
....................            //The card didn't respond with the expected result.  This probably 
....................            //means it is no longer present.  We can try to re-initialized it, 
....................            //just to be doubly sure. 
....................           CloseSPIM(); 
....................           MDD_SDSPI_MediaInitialize();    //Can block and take a long time to execute. 
....................           if(mediaInformation.errorCode == MEDIA_NO_ERROR) 
....................           { 
....................              /* if the card was initialized correctly, it means it is present */ 
....................              return TRUE; 
....................           } 
....................           else  
....................           { 
....................               CloseSPIM(); 
....................              return FALSE; 
....................           } 
....................        } 
....................        else 
....................        { 
....................            //The CMD13 response to SEND_STATUS was valid.  This presumably 
....................            //means the card is present and working normally. 
....................            return TRUE; 
....................         }           
....................  
....................    } 
....................  
....................     //Should theoretically never execute to here.  All pathways should have  
....................     //already returned with the status. 
....................     return TRUE; 
....................  
.................... #endif 
....................  
.................... }//end MediaDetect 
....................  
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     WORD MDD_SDSPI_ReadSectorSize (void) 
....................   Summary: 
....................     Determines the current sector size on the SD card 
....................   Conditions: 
....................     MDD_MediaInitialize() is complete 
....................   Input: 
....................     None 
....................   Return: 
....................     The size of the sectors for the physical media 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_ReadSectorSize function is used by the 
....................     USB mass storage class to return the card's sector 
....................     size to the PC on request. 
....................   Remarks: 
....................     None 
....................   *********************************************************/ 
....................  
.................... WORD MDD_SDSPI_ReadSectorSize(void) 
.................... { 
....................     return gMediaSectorSize; 
.................... } 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     DWORD MDD_SDSPI_ReadCapacity (void) 
....................   Summary: 
....................     Determines the current capacity of the SD card 
....................   Conditions: 
....................     MDD_MediaInitialize() is complete 
....................   Input: 
....................     None 
....................   Return: 
....................     The capacity of the device 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_ReadCapacity function is used by the 
....................     USB mass storage class to return the total number 
....................     of sectors on the card. 
....................   Remarks: 
....................     None 
....................   *********************************************************/ 
.................... DWORD MDD_SDSPI_ReadCapacity(void) 
.................... { 
....................     return (MDD_SDSPI_finalLBA); 
.................... } 
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     WORD MDD_SDSPI_InitIO (void) 
....................   Summary: 
....................     Initializes the I/O lines connected to the card 
....................   Conditions: 
....................     MDD_MediaInitialize() is complete.  The MDD_InitIO 
....................     function pointer is pointing to this function. 
....................   Input: 
....................     None 
....................   Return: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_InitIO function initializes the I/O 
....................     pins connected to the SD card. 
....................   Remarks: 
....................     None 
....................   *********************************************************/ 
....................  
.................... void MDD_SDSPI_InitIO (void) 
.................... { 
....................     // Turn off the card 
....................    #if !defined(MEDIA_SOFT_DETECT) 
....................     SD_CD_TRIS = INPUT;            //Card Detect - input 
....................    #endif     
....................     SD_CS = 1;                     //Initialize Chip Select line 
....................     SD_CS_TRIS = OUTPUT;           //Card Select - output 
....................    #if defined(SD_WE_TRIS) 
....................     SD_WE_TRIS = INPUT;            //Write Protect - input 
....................    #endif 
....................  
.................... #if defined   (__dsPIC33E__) || defined (__PIC24E__) 
....................     SD_CS_ANSEL = 0; 
....................     SD_SCK_ANSEL = 0; 
....................     SD_SDI_ANSEL = 0; 
....................     SD_SDO_ANSEL = 0; 
.................... #endif     
.................... } 
....................  
....................  
....................  
.................... /********************************************************* 
....................   Function: 
....................     BYTE MDD_SDSPI_ShutdownMedia (void) 
....................   Summary: 
....................     Disables the SD card 
....................   Conditions: 
....................     The MDD_ShutdownMedia function pointer is pointing  
....................     towards this function. 
....................   Input: 
....................     None 
....................   Return: 
....................     None 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     This function will disable the SPI port and deselect 
....................     the SD card. 
....................   Remarks: 
....................     None 
....................   *********************************************************/ 
....................  
.................... BYTE MDD_SDSPI_ShutdownMedia(void) 
.................... { 
....................     // close the spi bus 
....................     CloseSPIM(); 
....................      
....................     // deselect the device 
....................     SD_CS = 1; 
....................  
....................     return 0; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     MMC_RESPONSE SendMMCCmd (BYTE cmd, DWORD address) 
....................   Summary: 
....................     Sends a command packet to the SD card. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     None. 
....................   Return Values: 
....................     MMC_RESPONSE    - The response from the card 
....................                     - Bit 0 - Idle state 
....................                     - Bit 1 - Erase Reset 
....................                     - Bit 2 - Illegal Command 
....................                     - Bit 3 - Command CRC Error 
....................                     - Bit 4 - Erase Sequence Error 
....................                     - Bit 5 - Address Error 
....................                     - Bit 6 - Parameter Error 
....................                     - Bit 7 - Unused. Always 0. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     SendMMCCmd prepares a command packet and sends it out over the SPI interface. 
....................     Response data of type 'R1' (as indicated by the SD/MMC product manual is returned. 
....................   Remarks: 
....................     None. 
....................   *****************************************************************************/ 
....................  
.................... MMC_RESPONSE SendMMCCmd(BYTE cmd, DWORD address) 
.................... { 
....................     MMC_RESPONSE    response; 
....................     CMD_PACKET  CmdPacket; 
....................     WORD timeout; 
....................     DWORD longTimeout; 
....................      
....................     SD_CS = 0;                           //Select card 
....................      
....................     // Copy over data 
....................     CmdPacket.cmd        = sdmmc_cmdtable[cmd].CmdCode; 
....................     CmdPacket.address    = address; 
....................     CmdPacket.crc        = sdmmc_cmdtable[cmd].CRC;       // Calc CRC here 
....................      
....................     CmdPacket.TRANSMIT_BIT = 1;             //Set Tranmission bit 
....................  
....................      #ifdef __DEBUG_UART   
....................      PrintROMASCIIStringUART("SendMMCCmdFast cmd="); 
....................      PrintRAMBytesUART(((unsigned char*)&cmd), 1); 
....................      PrintROMASCIIStringUART(" cmd="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.cmd), 1); 
....................      PrintROMASCIIStringUART(" addy="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.address), 4); 
....................      PrintROMASCIIStringUART(" crc="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.crc), 1); 
....................      PrintROMASCIIStringUART(" type="); 
....................      char type; 
....................      type = sdmmc_cmdtable[cmd].responsetype; 
....................      PrintRAMBytesUART(((unsigned char*)&type), 1); 
....................      #endif 
....................  
....................     WriteSPIM(CmdPacket.cmd);                //Send Command 
....................     WriteSPIM(CmdPacket.addr3);              //Most Significant Byte 
....................     WriteSPIM(CmdPacket.addr2); 
....................     WriteSPIM(CmdPacket.addr1); 
....................     WriteSPIM(CmdPacket.addr0);              //Least Significant Byte 
....................     WriteSPIM(CmdPacket.crc);                //Send CRC 
....................  
....................     //Special handling for CMD12 (STOP_TRANSMISSION).  The very first byte after 
....................     //sending the command packet may contain bogus non-0xFF data.  This  
....................     //"residual data" byte should not be interpreted as the R1 response byte. 
....................     if(cmd == STOP_TRANSMISSION) 
....................     { 
....................         MDD_SDSPI_ReadMedia(); //Perform dummy read to fetch the residual non R1 byte 
....................     }  
....................  
....................     //Loop until we get a response from the media.  Delay (NCR) could be up  
....................     //to 8 SPI byte times.  First byte of response is always the equivalent of  
....................     //the R1 byte, even for R1b, R2, R3, R7 responses. 
....................     timeout = NCR_TIMEOUT; 
....................     do 
....................     { 
....................         response.r1._byte = MDD_SDSPI_ReadMedia(); 
....................         timeout--; 
....................        #ifdef __DEBUG_UART 
....................         if (response.r1._byte != MMC_FLOATING_BUS) 
....................         { 
....................             PrintROMASCIIStringUART(" r1="); 
....................             PrintRAMBytesUART(&response.r1._byte, 1); 
....................         } 
....................        #endif 
....................     }while((response.r1._byte == MMC_FLOATING_BUS) && (timeout != 0)); 
....................      
....................     //Check if we should read more bytes, depending upon the response type expected.   
....................     if(sdmmc_cmdtable[cmd].responsetype == R2) 
....................     { 
....................         response.r2._byte1 = response.r1._byte; //We already received the first byte, just make sure it is in the correct location in the struct. 
....................         response.r2._byte0 = MDD_SDSPI_ReadMedia(); //Fetch the second byte of the response. 
....................         
....................        #ifdef __DEBUG_UART 
....................         PrintROMASCIIStringUART(" r2="); 
....................         PrintRAMBytesUART(&response.r2._byte0, 1); 
....................        #endif         
....................     } 
....................     else if(sdmmc_cmdtable[cmd].responsetype == R1b) 
....................     { 
....................         //Keep trying to read from the media, until it signals it is no longer 
....................         //busy.  It will continuously send 0x00 bytes until it is not busy. 
....................         //A non-zero value means it is ready for the next command. 
....................         //The R1b response is received after a CMD12 STOP_TRANSMISSION 
....................         //command, where the media card may be busy writing its internal buffer 
....................         //to the flash memory.  This can typically take a few milliseconds,  
....................         //with a recommended maximum timeout of 250ms or longer for SD cards. 
....................         longTimeout = WRITE_TIMEOUT; 
....................         do 
....................         { 
....................             response.r1._byte = MDD_SDSPI_ReadMedia(); 
....................             longTimeout--; 
....................         }while((response.r1._byte == 0x00) && (longTimeout != 0)); 
....................  
....................         response.r1._byte = 0x00; 
....................     } 
....................     else if (sdmmc_cmdtable[cmd].responsetype == R7) //also used for response R3 type 
....................     { 
....................         //Fetch the other four bytes of the R3 or R7 response. 
....................         //Note: The SD card argument response field is 32-bit, big endian format. 
....................         //However, the C compiler stores 32-bit values in little endian in RAM. 
....................         //When writing to the _returnVal/argument bytes, make sure the order it  
....................         //gets stored in is correct.       
....................         response.r7.bytewise.argument._byte3 = MDD_SDSPI_ReadMedia(); 
....................         response.r7.bytewise.argument._byte2 = MDD_SDSPI_ReadMedia(); 
....................         response.r7.bytewise.argument._byte1 = MDD_SDSPI_ReadMedia(); 
....................         response.r7.bytewise.argument._byte0 = MDD_SDSPI_ReadMedia(); 
....................     } 
....................  
....................     WriteSPIM(0xFF);    //Device requires at least 8 clock pulses after  
....................                              //the response has been sent, before if can process 
....................                              //the next command.  CS may be high or low. 
....................  
....................     // see if we are expecting more data or not 
....................     if(!(sdmmc_cmdtable[cmd].moredataexpected)) 
....................         SD_CS = 1; 
....................       
....................      #ifdef __DEBUG_UART 
....................      PrintROMASCIIStringUART(" r1="); 
....................      PrintRAMBytesUART(((unsigned char*)&response.r1._byte), 1); 
....................      #endif 
....................  
....................  
....................     #ifdef __DEBUG_UART   
....................     UARTSendLineFeedCarriageReturn(); 
....................     #endif 
....................  
....................     return(response); 
.................... } 
....................  
.................... #ifdef __18CXX 
.................... /***************************************************************************** 
....................   Function: 
....................     MMC_RESPONSE SendMMCCmdManual (BYTE cmd, DWORD address) 
....................   Summary: 
....................     Sends a command packet to the SD card with bit-bang SPI. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     Need input cmd index into a rom table of implemented commands. 
....................     Also needs 4 bytes of data as address for some commands (also used for 
....................     other purposes in other commands). 
....................   Return Values: 
....................     Assuming an "R1" type of response, each bit will be set depending upon status: 
....................     MMC_RESPONSE    - The response from the card 
....................                     - Bit 0 - Idle state 
....................                     - Bit 1 - Erase Reset 
....................                     - Bit 2 - Illegal Command 
....................                     - Bit 3 - Command CRC Error 
....................                     - Bit 4 - Erase Sequence Error 
....................                     - Bit 5 - Address Error 
....................                     - Bit 6 - Parameter Error 
....................                     - Bit 7 - Unused. Always 0. 
....................     Other response types (ex: R3/R7) have up to 5 bytes of response.  The first 
....................     byte is always the same as the R1 response.  The contents of the other bytes  
....................     depends on the command. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     SendMMCCmd prepares a command packet and sends it out over the SPI interface. 
....................     Response data of type 'R1' (as indicated by the SD/MMC product manual is returned. 
....................     This function is intended to be used when the clock speed of a PIC18 device is 
....................     so high that the maximum SPI divider can't reduce the clock below the maximum 
....................     SD card initialization sequence speed. 
....................   Remarks: 
....................     None. 
....................   ***************************************************************************************/ 
.................... MMC_RESPONSE SendMMCCmdManual(BYTE cmd, DWORD address) 
.................... { 
....................     BYTE index; 
....................     MMC_RESPONSE    response; 
....................     CMD_PACKET  CmdPacket; 
....................     WORD timeout; 
....................      
....................     SD_CS = 0;                           //Select card 
....................      
....................     // Copy over data 
....................     CmdPacket.cmd        = sdmmc_cmdtable[cmd].CmdCode; 
....................     CmdPacket.address    = address; 
....................     CmdPacket.crc        = sdmmc_cmdtable[cmd].CRC;       // Calc CRC here 
....................     
....................     CmdPacket.TRANSMIT_BIT = 1;             //Set Tranmission bit 
....................  
....................      #ifdef __DEBUG_UART   
....................      PrintROMASCIIStringUART("SendMMCCmdManual cmd="); 
....................      PrintRAMBytesUART(((unsigned char*)&cmd), 1); 
....................      PrintROMASCIIStringUART(" cmd="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.cmd), 1); 
....................      PrintROMASCIIStringUART(" addy="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.address), 4); 
....................      PrintROMASCIIStringUART(" crc="); 
....................      PrintRAMBytesUART(((unsigned char*)&CmdPacket.crc), 1); 
....................      PrintROMASCIIStringUART(" type="); 
....................      char type; 
....................      type = sdmmc_cmdtable[cmd].responsetype; 
....................      PrintRAMBytesUART(((unsigned char*)&type), 1); 
....................      #endif 
....................  
....................     WriteSPIManual(CmdPacket.cmd);                //Send Command 
....................     WriteSPIManual(CmdPacket.addr3);              //Most Significant Byte 
....................     WriteSPIManual(CmdPacket.addr2); 
....................     WriteSPIManual(CmdPacket.addr1); 
....................     WriteSPIManual(CmdPacket.addr0);              //Least Significant Byte 
....................     WriteSPIManual(CmdPacket.crc);                //Send CRC 
....................  
....................     //Special handling for CMD12 (STOP_TRANSMISSION).  The very first byte after 
....................     //sending the command packet may contain bogus non-0xFF data.  This  
....................     //"residual data" byte should not be interpreted as the R1 response byte. 
....................     if(cmd == STOP_TRANSMISSION) 
....................     { 
....................         ReadMediaManual(); //Perform dummy read to fetch the residual non R1 byte 
....................     }  
....................  
....................     //Loop until we get a response from the media.  Delay (NCR) could be up  
....................     //to 8 SPI byte times.  First byte of response is always the equivalent of  
....................     //the R1 byte, even for R1b, R2, R3, R7 responses. 
....................     timeout = NCR_TIMEOUT; 
....................     do 
....................     { 
....................         response.r1._byte = ReadMediaManual(); 
....................         timeout--; 
....................     }while((response.r1._byte == MMC_FLOATING_BUS) && (timeout != 0)); 
....................      
....................  
....................      #ifdef __DEBUG_UART   
....................      PrintROMASCIIStringUART(" r1="); 
....................      PrintRAMBytesUART(((unsigned char*)&response.r1._byte), 1); 
....................      #endif 
....................  
....................     //Check if we should read more bytes, depending upon the response type expected.   
....................     if(sdmmc_cmdtable[cmd].responsetype == R2) 
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART(" getr2"); 
....................         #endif 
....................      
....................         response.r2._byte1 = response.r1._byte; //We already received the first byte, just make sure it is in the correct location in the struct. 
....................         response.r2._byte0 = ReadMediaManual(); //Fetch the second byte of the response. 
....................     } 
....................     else if(sdmmc_cmdtable[cmd].responsetype == R1b) 
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART(" getr1b"); 
....................         #endif     
....................         //Keep trying to read from the media, until it signals it is no longer 
....................         //busy.  It will continuously send 0x00 bytes until it is not busy. 
....................         //A non-zero value means it is ready for the next command. 
....................         timeout = 0xFFFF; 
....................         do 
....................         { 
....................             response.r1._byte = ReadMediaManual(); 
....................             timeout--; 
....................         }while((response.r1._byte == 0x00) && (timeout != 0)); 
....................  
....................         response.r1._byte = 0x00; 
....................     } 
....................     else if (sdmmc_cmdtable[cmd].responsetype == R7) //also used for response R3 type 
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART(" getr7"); 
....................         #endif     
....................         //Fetch the other four bytes of the R3 or R7 response. 
....................         //Note: The SD card argument response field is 32-bit, big endian format. 
....................         //However, the C compiler stores 32-bit values in little endian in RAM. 
....................         //When writing to the _returnVal/argument bytes, make sure the order it  
....................         //gets stored in is correct.       
....................         response.r7.bytewise.argument._byte3 = ReadMediaManual(); 
....................         response.r7.bytewise.argument._byte2 = ReadMediaManual(); 
....................         response.r7.bytewise.argument._byte1 = ReadMediaManual(); 
....................         response.r7.bytewise.argument._byte0 = ReadMediaManual(); 
....................     } 
....................      
....................  
....................     WriteSPIManual(0xFF);    //Device requires at least 8 clock pulses after  
....................                              //the response has been sent, before if can process 
....................                              //the next command.  CS may be high or low. 
....................  
....................     // see if we are expecting more data or not 
....................     if(!(sdmmc_cmdtable[cmd].moredataexpected)) 
....................     { 
....................        #ifdef __DEBUG_UART   
....................        PrintROMASCIIStringUART(" csup"); 
....................        #endif 
....................  
....................         SD_CS = 1; 
....................     } 
....................  
....................      #ifdef __DEBUG_UART   
....................      PrintROMASCIIStringUART(" r1="); 
....................      PrintRAMBytesUART(((unsigned char*)&response.r1._byte), 1); 
....................      #endif 
....................  
....................  
....................     #ifdef __DEBUG_UART   
....................     UARTSendLineFeedCarriageReturn(); 
....................     #endif 
....................  
....................     return(response); 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE MDD_SDSPI_SectorRead (DWORD sector_addr, BYTE * buffer) 
....................   Summary: 
....................     Reads a sector of data from an SD card. 
....................   Conditions: 
....................     The MDD_SectorRead function pointer must be pointing towards this function. 
....................   Input: 
....................     sector_addr - The address of the sector on the card. 
....................     buffer -      The buffer where the retrieved data will be stored.  If 
....................                   buffer is NULL, do not store the data anywhere. 
....................   Return Values: 
....................     TRUE -  The sector was read successfully 
....................     FALSE - The sector could not be read 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     The MDD_SDSPI_SectorRead function reads a sector of data bytes (512 bytes)  
....................     of data from the SD card starting at the sector address and stores them in  
....................     the location pointed to by 'buffer.' 
....................   Remarks: 
....................     The card expects the address field in the command packet to be a byte address. 
....................     The sector_addr value is converted to a byte address by shifting it left nine 
....................     times (multiplying by 512). 
....................      
....................     This function performs a synchronous read operation.  In other words, this 
....................     function is a blocking function, and will not return until either the data 
....................     has fully been read, or, a timeout or other error occurred. 
....................   ***************************************************************************************/ 
.................... BYTE MDD_SDSPI_SectorRead(DWORD sector_addr, BYTE* buffer) 
.................... { 
....................     ASYNC_IO info; 
....................     BYTE status; 
....................      
....................     //Initialize info structure for using the MDD_SDSPI_AsyncReadTasks() function. 
....................     info.wNumBytes = 512; 
....................     info.dwBytesRemaining = 512; 
....................     info.pBuffer = buffer; 
....................     info.dwAddress = sector_addr; 
....................     info.bStateVariable = ASYNC_READ_QUEUED; 
....................      
....................     //Blocking loop, until the state machine finishes reading the sector, 
....................     //or a timeout or other error occurs.  MDD_SDSPI_AsyncReadTasks() will always 
....................     //return either ASYNC_READ_COMPLETE or ASYNC_READ_FAILED eventually  
....................     //(could take awhile in the case of timeout), so this won't be a totally 
....................     //infinite blocking loop. 
....................     while(1) 
....................     { 
....................         status = MDD_SDSPI_AsyncReadTasks(&info); 
....................         if(status == ASYNC_READ_COMPLETE) 
....................         { 
....................             return TRUE; 
....................         } 
....................         else if(status == ASYNC_READ_ERROR) 
....................         { 
....................             return FALSE; 
....................         }  
....................     }        
....................  
....................     //Impossible to get here, but we will return a value anyay to avoid possible  
....................     //compiler warnings. 
....................     return FALSE; 
.................... }     
....................  
....................   
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE MDD_SDSPI_AsyncReadTasks(ASYNC_IO* info) 
....................   Summary: 
....................     Speed optimized, non-blocking, state machine based read function that reads  
....................     data packets from the media, and copies them to a user specified RAM buffer. 
....................   Pre-Conditions: 
....................     The ASYNC_IO structure must be initialized correctly, prior to calling 
....................     this function for the first time.  Certain parameters, such as the user 
....................     data buffer pointer (pBuffer) in the ASYNC_IO struct are allowed to be changed 
....................     by the application firmware, in between each call to MDD_SDSPI_AsyncReadTasks(). 
....................     Additionally, the media and microcontroller SPI module should have already  
....................     been initalized before using this function.  This function is mutually 
....................     exclusive with the MDD_SDSPI_AsyncWriteTasks() function.  Only one operation 
....................     (either one read or one write) is allowed to be in progress at a time, as 
....................     both functions share statically allocated resources and monopolize the SPI bus. 
....................   Input: 
....................     ASYNC_IO* info -        A pointer to a ASYNC_IO structure.  The  
....................                             structure contains information about how to complete 
....................                             the read operation (ex: number of total bytes to read, 
....................                             where to copy them once read, maximum number of bytes 
....................                             to return for each call to MDD_SDSPI_AsyncReadTasks(), etc.). 
....................   Return Values: 
....................     BYTE - Returns a status byte indicating the current state of the read  
....................             operation. The possible return values are: 
....................              
....................             ASYNC_READ_BUSY - Returned when the state machine is busy waiting for 
....................                              a data start token from the media.  The media has a 
....................                              random access time, which can often be quite long 
....................                              (<= ~3ms typ, with maximum of 100ms).  No data 
....................                              has been copied yet in this case, and the application 
....................                              should keep calling MDD_SDSPI_AsyncReadTasks() until either 
....................                              an error/timeout occurs, or ASYNC_READ_NEW_PACKET_READY 
....................                              is returned. 
....................             ASYNC_READ_NEW_PACKET_READY -   Returned after a single packet, of 
....................                                             the specified size (in info->numBytes), 
....................                                             is ready to be read from the  
....................                                             media and copied to the user  
....................                                             specified data buffer.  Often, after 
....................                                             receiving this return value, the  
....................                                             application firmware would want to 
....................                                             update the info->pReceiveBuffer pointer 
....................                                             before calling MDD_SDSPI_AsyncReadTasks() 
....................                                             again.  This way, the application can 
....................                                             begin fetching the next packet worth 
....................                                             of data, while still using/consuming 
....................                                             the previous packet of data. 
....................             ASYNC_READ_COMPLETE - Returned when all data bytes in the read  
....................                                  operation have been read and returned successfully, 
....................                                  and the media is now ready for the next operation. 
....................             ASYNC_READ_ERROR - Returned when some failure occurs.  This could be 
....................                                either due to a media timeout, or due to some other 
....................                                unknown type of error.  In this case, the  
....................                                MDD_SDSPI_AsyncReadTasks() handler will terminate 
....................                                the read attempt and will try to put the media  
....................                                back in a default state, ready for a new command.   
....................                                The application firmware may then retry the read 
....................                                attempt (if desired) by re-initializing the  
....................                                ASYNC_IO structure and setting the  
....................                                bStateVariable = ASYNC_READ_QUEUED. 
....................  
....................              
....................   Side Effects: 
....................     Uses the SPI bus and the media.  The media and SPI bus should not be 
....................     used by any other function until the read operation has either completed 
....................     successfully, or returned with the ASYNC_READ_ERROR condition. 
....................   Description: 
....................     Speed optimized, non-blocking, state machine based read function that reads  
....................     data packets from the media, and copies them to a user specified RAM buffer. 
....................     This function uses the multi-block read command (and stop transmission command)  
....................     to perform fast reads of data.  The total amount of data that will be returned  
....................     on any given call to MDD_SDSPI_AsyncReadTasks() will be the info->numBytes parameter. 
....................     However, if the function is called repeatedly, with info->bytesRemaining set 
....................     to a large number, this function can successfully fetch data sizes >> than 
....................     the block size (theoretically anything up to ~4GB, since bytesRemaining is  
....................     a 32-bit DWORD).  The application firmware should continue calling  
....................     MDD_SDSPI_AsyncReadTasks(), until the ASYNC_READ_COMPLETE value is returned  
....................     (or ASYNC_READ_ERROR), even if it has already received all of the data expected. 
....................     This is necessary, so the state machine can issue the CMD12 (STOP_TRANMISSION)  
....................     to terminate the multi-block read operation, once the total expected number  
....................     of bytes have been read.  This puts the media back into the default state  
....................     ready for a new command. 
....................      
....................     During normal/successful operations, calls to MDD_SDSPI_AsyncReadTasks()  
....................     would typically return: 
....................     1. ASYNC_READ_BUSY - repeatedly up to several milliseconds, then  
....................     2. ASYNC_READ_NEW_PACKET_READY - repeatedly, until 512 bytes [media read  
....................         block size] is received, then  
....................     3. Back to ASYNC_READ_BUSY (for awhile, may be short), then 
....................     4. Back to ASYNC_READ_NEW_PACKET_READY (repeatedly, until the next 512 byte 
....................        boundary, then back to #3, etc. 
....................     5. After all data is received successfully, then the function will return  
....................        ASYNC_READ_COMPLETE, for all subsequent calls (until a new read operation 
....................        is started, by re-initializing the ASYNC_IO structure, and re-calling 
....................        the function). 
....................      
....................   Remarks: 
....................     This function will monopolize the SPI module during the operation.  Do not 
....................     use the SPI module for any other purpose, while a fetch operation is in 
....................     progress.  Additionally, the ASYNC_IO structure must not be modified 
....................     in a different context, while the MDD_SDSPI_AsyncReadTasks() function is executing. 
....................     In between calls to MDD_SDSPI_AsyncReadTasks(), certain parameters, namely the 
....................     info->numBytes and info->pReceiveBuffer are allowed to change however. 
....................      
....................     The bytesRemaining value must always be an exact integer multiple of numBytes  
....................     for the function to operate correctly.  Additionally, it is recommended, although 
....................     not essential, for the bytesRemaining to be an integer multiple of the media 
....................     read block size. 
....................      
....................     When starting a read operation, the info->stateVariable must be initalized to 
....................     ASYNC_READ_QUEUED.  All other fields in the info structure should also be 
....................     initialized correctly. 
....................      
....................     The info->wNumBytes must always be less than or equal to the media block size, 
....................     (which is 512 bytes).  Additionally, info->wNumBytes must always be an exact  
....................     integer factor of the media block size (unless info->dwBytesRemaining is less 
....................     than the media block size).  Example values that are allowed for info->wNumBytes 
....................     are: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512. 
....................   *****************************************************************************/ 
....................  
.................... BYTE MDD_SDSPI_AsyncReadTasks(ASYNC_IO* info) 
.................... { 
....................     BYTE bData; 
....................     MMC_RESPONSE response; 
....................     static WORD blockCounter; 
....................     static DWORD longTimeoutCounter; 
....................     static BOOL SingleBlockRead; 
....................      
....................     //Check what state we are in, to decide what to do. 
....................     switch(info->bStateVariable) 
....................     { 
....................         case ASYNC_READ_COMPLETE: 
....................             return ASYNC_READ_COMPLETE; 
....................         case ASYNC_READ_QUEUED: 
....................             //Start the read request.   
....................              
....................             //Initialize some variables we will use later. 
....................             blockCounter = MEDIA_BLOCK_SIZE; //Counter will be used later for block boundary tracking 
....................             ioInfo = *info; //Get local copy of structure, for quicker access with less code size 
....................  
....................             //SDHC cards are addressed on a 512 byte block basis.  This is 1:1 equivalent 
....................             //to LBA addressing.  For standard capacity media, the media is expecting 
....................             //a complete byte address.  Therefore, to convert from the LBA address to the 
....................             //byte address, we need to multiply by 512. 
....................             if (gSDMode == SD_MODE_NORMAL) 
....................             { 
....................                 ioInfo.dwAddress <<= 9; //Equivalent to multiply by 512 
....................             }   
....................             if(ioInfo.dwBytesRemaining <= MEDIA_BLOCK_SIZE) 
....................             { 
....................                 SingleBlockRead = TRUE; 
....................                 response = SendMMCCmd(READ_SINGLE_BLOCK, ioInfo.dwAddress); 
....................             }     
....................             else 
....................             { 
....................                 SingleBlockRead = FALSE; 
....................                 response = SendMMCCmd(READ_MULTI_BLOCK, ioInfo.dwAddress); 
....................             }     
....................             //Note: SendMMCmd() sends 8 SPI clock cycles after getting the 
....................             //response.  This meets the NAC min timing paramemter, so we don't 
....................             //need additional clocking here. 
....................              
....................             // Make sure the command was accepted successfully 
....................             if(response.r1._byte != 0x00) 
....................             { 
....................                 //Perhaps the card isn't initialized or present. 
....................                 info->bStateVariable = ASYNC_READ_ABORT; 
....................                 return ASYNC_READ_BUSY;  
....................             } 
....................              
....................             //We successfully sent the READ_MULTI_BLOCK command to the media. 
....................             //We now need to keep polling the media until it sends us the data 
....................             //start token byte. 
....................             longTimeoutCounter = NAC_TIMEOUT; //prepare timeout counter for next state 
....................             info->bStateVariable = ASYNC_READ_WAIT_START_TOKEN; 
....................             return ASYNC_READ_BUSY; 
....................         case ASYNC_READ_WAIT_START_TOKEN: 
....................             //In this case, we have already issued the READ_MULTI_BLOCK command 
....................             //to the media, and we need to keep polling the media until it sends 
....................             //us the data start token byte.  This could typically take a  
....................             //couple/few milliseconds, up to a maximum of 100ms. 
....................             if(longTimeoutCounter != 0x00000000) 
....................             { 
....................                 longTimeoutCounter--; 
....................                 bData = MDD_SDSPI_ReadMedia(); 
....................                  
....................                 if(bData != MMC_FLOATING_BUS) 
....................                 { 
....................                     if(bData == DATA_START_TOKEN) 
....................                     {    
....................                         //We got the start token.  Ready to receive the data 
....................                         //block now. 
....................                         info->bStateVariable = ASYNC_READ_NEW_PACKET_READY; 
....................                         return ASYNC_READ_NEW_PACKET_READY; 
....................                     } 
....................                     else 
....................                     { 
....................                         //We got an unexpected non-0xFF, non-start token byte back? 
....................                         //Some kind of error must have occurred.  
....................                         info->bStateVariable = ASYNC_READ_ABORT;  
....................                         return ASYNC_READ_BUSY; 
....................                     }         
....................                 } 
....................                 else 
....................                 { 
....................                     //Media is still busy.  Start token not received yet. 
....................                     return ASYNC_READ_BUSY; 
....................                 }                     
....................             }  
....................             else 
....................             { 
....................                 //The media didn't respond with the start data token in the timeout 
....................                 //interval allowed.  Operation failed.  Abort the operation. 
....................                 info->bStateVariable = ASYNC_READ_ABORT;  
....................                 return ASYNC_READ_BUSY;                 
....................             }        
....................             //Should never execute to here 
....................              
....................         case ASYNC_READ_NEW_PACKET_READY: 
....................             //We have sent the READ_MULTI_BLOCK command and have successfully 
....................             //received the data start token byte.  Therefore, we are ready 
....................             //to receive raw data bytes from the media. 
....................             if(ioInfo.dwBytesRemaining != 0x00000000) 
....................             { 
....................                 //Re-update local copy of pointer and number of bytes to read in this 
....................                 //call.  These parameters are allowed to change between packets. 
....................                 ioInfo.wNumBytes = info->wNumBytes; 
....................                   ioInfo.pBuffer = info->pBuffer; 
....................                    
....................                   //Update counters for state tracking and loop exit condition tracking. 
....................                 ioInfo.dwBytesRemaining -= ioInfo.wNumBytes; 
....................                 blockCounter -= ioInfo.wNumBytes; 
....................  
....................                 //Now read a ioInfo.wNumBytes packet worth of SPI bytes,  
....................                 //and place the received bytes in the user specified pBuffer. 
....................                 //This operation directly dictates data thoroughput in the  
....................                 //application, therefore optimized code should be used for each  
....................                 //processor type. 
....................                #if defined __C30__ || defined __C32__ 
....................                 { 
....................                     //PIC24/dsPIC/PIC32 architecture is efficient with pointers. 
....................                     //Therefore, this code can provide good SPI bus utilization,  
....................                     //provided the compiler optimization level is 's' or '3'. 
....................                     BYTE* localPointer = ioInfo.pBuffer; 
....................                     WORD localCounter = ioInfo.wNumBytes; 
....................                      
....................                     if(localCounter != 0x0000) 
....................                     { 
....................                         localPointer--; 
....................                         while(1) 
....................                         { 
....................                             SPIBUF = 0xFF; 
....................                             localPointer++; 
....................                             if((--localCounter) == 0x0000) 
....................                             { 
....................                                break;  
....................                             }  
....................                             while(!SPISTAT_RBF); 
....................                             *localPointer = (BYTE)SPIBUF; 
....................                         } 
....................                         while(!SPISTAT_RBF); 
....................                         *localPointer = (BYTE)SPIBUF;   
....................                     }   
....................                 }     
....................                 #elif defined __18CXX 
....................                     PIC18_Optimized_SPI_Read_Packet(); 
....................                #endif    
....................  
....................                 //Check if we have received a multiple of the media block  
....................                 //size (ex: 512 bytes).  If so, the next two bytes are going to  
....................                 //be CRC values, rather than data bytes.   
....................                 if(blockCounter == 0) 
....................                 { 
....................                     //Read two bytes to receive the CRC-16 value on the data block. 
....................                     MDD_SDSPI_ReadMedia(); 
....................                     MDD_SDSPI_ReadMedia(); 
....................                     //Following sending of the CRC-16 value, the media may still 
....................                     //need more access time to internally fetch the next block. 
....................                     //Therefore, it will send back 0xFF idle value, until it is 
....................                     //ready.  Then it will send a new data start token, followed 
....................                     //by the next block of useful data. 
....................                     if(ioInfo.dwBytesRemaining != 0x00000000) 
....................                     { 
....................                         info->bStateVariable = ASYNC_READ_WAIT_START_TOKEN; 
....................                     } 
....................                     blockCounter = MEDIA_BLOCK_SIZE; 
....................                     return ASYNC_READ_BUSY; 
....................                 } 
....................                      
....................                 return ASYNC_READ_NEW_PACKET_READY; 
....................             }//if(ioInfo.dwBytesRemaining != 0x00000000) 
....................             else 
....................             { 
....................                 //We completed the read operation successfully and have returned 
....................                 //all data bytes requested. 
....................                 //Send CMD12 to let the media know we are finished reading 
....................                 //blocks from it, if we sent a multi-block read request earlier. 
....................                 if(SingleBlockRead == FALSE) 
....................                 { 
....................                     SendMMCCmd(STOP_TRANSMISSION, 0x00000000); 
....................                 }     
....................                 SD_CS = 1;  //De-select media 
....................                 mSend8ClkCycles();   
....................                 info->bStateVariable = ASYNC_READ_COMPLETE; 
....................                 return ASYNC_READ_COMPLETE; 
....................             } 
....................         case ASYNC_READ_ABORT: 
....................             //If the application firmware wants to cancel a read request. 
....................             info->bStateVariable = ASYNC_READ_ERROR; 
....................             //Send CMD12 to terminate the multi-block read request. 
....................             response = SendMMCCmd(STOP_TRANSMISSION, 0x00000000); 
....................             //Fall through to ASYNC_READ_ERROR/default case. 
....................         case ASYNC_READ_ERROR: 
....................         default: 
....................             //Some error must have happened. 
....................             SD_CS = 1;  //De-select media 
....................             mSend8ClkCycles();   
....................             return ASYNC_READ_ERROR;  
....................     }//switch(info->stateVariable)     
....................      
....................     //Should never get to here.  All pathways should have already returned. 
....................     return ASYNC_READ_ERROR; 
.................... }     
....................  
....................  
....................  
....................  
.................... #ifdef __18CXX 
.................... /***************************************************************************** 
....................   Function: 
....................     static void PIC18_Optimized_SPI_Read_Packet(void) 
....................   Summary: 
....................     A private function intended for use internal to the SD-SPI.c file. 
....................     This function reads a specified number of bytes from the SPI module, 
....................     at high speed for optimum thoroughput, and copies them into the user 
....................     specified RAM buffer. 
....................     This function is only implemented and used on PIC18 devices. 
....................   Pre-Conditions: 
....................     The ioInfo.wNumBytes must be pre-initialized prior to calling  
....................     PIC18_Optimized_SPI_Read_Packet(). 
....................     Additionally, the ioInfo.pBuffer must also be pre-initialized, prior 
....................     to calling PIC18_Optimized_SPI_Read_Packet(). 
....................   Input: 
....................     ioInfo.wNumBytes global variable, initialized to the number of bytes to read. 
....................     ioInfo.pBuffer global variable, initialize to point to the RAM location that 
....................         the read data should be copied to. 
....................   Return Values: 
....................     None (although the ioInfo.pBuffer RAM specified will contain new contents) 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     A private function intended for use internal to the SD-SPI.c file. 
....................     This function reads a specified number of bytes from the SPI module, 
....................     at high speed for optimum thoroughput, and copies them into the user 
....................     specified RAM buffer. 
....................     This function is only implemented and used on PIC18 devices. 
....................   Remarks: 
....................     This function is speed optimized, using inline assembly language code, and 
....................     makes use of C compiler managed resources.  It is currently written to work 
....................     with the Microchip MPLAB C18 compiler, and may need modification is built 
....................     with a different PIC18 compiler. 
....................   *****************************************************************************/ 
.................... static void PIC18_Optimized_SPI_Read_Packet(void) 
.................... { 
....................     static WORD FSR0Save; 
....................     static WORD PRODSave; 
....................  
....................     //Make sure the SPI_INTERRUPT_FLAG_ASM has been correctly defined, for the SPI 
....................     //module that is actually being used in the hardware. 
....................     #ifndef SPI_INTERRUPT_FLAG_ASM 
....................         #error "Please define SPI_INTERRUPT_FLAG_ASM.  Double click this message for more info." 
....................         //In the HardwareProfile - [platform name].h file for your project, please 
....................         //add a "#define SPI_INTERRUPT_FLAG_ASM  PIRx, y" definition, where 
....................         //PIRx is the PIR register holding the SSPxIF flag for the SPI module being used 
....................         //to interface with the SD/MMC card, and y is the bit number for the SSPxIF bit (ex: 0-7). 
....................     #endif 
....................  
....................     //Make sure at least one byte needs to be read. 
....................     if(ioInfo.wNumBytes == 0) 
....................     { 
....................         return; 
....................     } 
....................  
....................     //Context save C compiler managed registers that we will modify in this function. 
....................     FSR0Save = FSR0;     
....................     PRODSave = PROD;     
....................      
....................     //Using PRODH and PRODL as convenient 16-bit access bank counter 
....................     PROD = ioInfo.wNumBytes;    //ioInfo.wNumBytes holds the total number of bytes 
....................                                 //this function will read from SPI. 
....................     //Going to use the FSR0 directly.  This is non-conventional, but delivers 
....................     //better performance than using a normal C managed software RAM pointer. 
....................     FSR0 = (WORD)ioInfo.pBuffer; 
....................  
....................     //Initiate the first SPI operation 
....................     WREG = SPIBUF; 
....................     SPI_INTERRUPT_FLAG = 0; 
....................     SPIBUF = 0xFF; 
....................  
.................... #if defined(__CCS__) 
.................... //had to modify this code to get rid of -2 BRA and the ,0 for all byte access 
.................... #endif 
....................  
....................     //Highly speed efficient SPI read loop, written in inline assembly 
....................     //language for best performance.  Total number of bytes that will be fetched 
....................     //is exactly == the value of ioInfo.wNumBytes prior to calling this function. 
....................     _asm 
....................         bra     ASMSPIReadLoopEntryPoint 
....................      
.................... ASMSPIReadLoop: 
....................         //Wait until last hardware SPI transaction is complete 
....................         btfss   SPI_INTERRUPT_FLAG_ASM 
....................         bra     ASMSPIReadLoop 
....................         bcf     SPI_INTERRUPT_FLAG_ASM 
....................  
....................         //Save received byte and start the next transfer 
....................         movf    SPIBUF, 0    //Copy SPIBUF byte into WREG 
....................         setf    SPIBUF       //Write 0xFF to SPIBUF, to start a SPI transaction 
....................         movwf   POSTINC0     //Write the last received byte to the user's RAM buffer 
....................      
.................... ASMSPIReadLoopEntryPoint: 
....................         //Now decrement 16-bit counter for loop exit test condition 
....................         movlw   0x00 
....................         decf    PRODL, 1     //Decrement LSB 
....................         subwfb  PRODH, 1     //Decrement MSB, only if borrow from LSB decrement 
....................         //Check if anymore bytes remain to be sent 
....................         movf    PRODL, 0     //copy PRODL to WREG 
....................         iorwf   PRODH, 0     //Z bit will be set if both PRODL and PRODH == 0x00 
....................         bnz     ASMSPIReadLoop  //Go back and loop if our counter isn't = 0x0000. 
....................  
....................         //Wait until the very last SPI transaction is complete and save the byte 
.................... ASMSPIReadLoopEntryPoint2: 
....................         btfss   SPI_INTERRUPT_FLAG_ASM 
....................         bra     ASMSPIReadLoopEntryPoint2 
....................         movff   SPIBUF, POSTINC0 
....................     _endasm 
....................  
....................     SPI_INTERRUPT_FLAG = 0;     
....................  
....................     //Context restore C compiler managed registers 
....................     PROD = PRODSave; 
....................     FSR0 = FSR0Save;     
.................... }     
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE MDD_SDSPI_AsyncWriteTasks(ASYNC_IO* info) 
....................   Summary: 
....................     Speed optimized, non-blocking, state machine based write function that writes 
....................     data from the user specified buffer, onto the media, at the specified  
....................     media block address. 
....................   Pre-Conditions: 
....................     The ASYNC_IO structure must be initialized correctly, prior to calling 
....................     this function for the first time.  Certain parameters, such as the user 
....................     data buffer pointer (pBuffer) in the ASYNC_IO struct are allowed to be changed 
....................     by the application firmware, in between each call to MDD_SDSPI_AsyncWriteTasks(). 
....................     Additionally, the media and microcontroller SPI module should have already  
....................     been initalized before using this function.  This function is mutually 
....................     exclusive with the MDD_SDSPI_AsyncReadTasks() function.  Only one operation 
....................     (either one read or one write) is allowed to be in progress at a time, as 
....................     both functions share statically allocated resources and monopolize the SPI bus. 
....................   Input: 
....................     ASYNC_IO* info -        A pointer to a ASYNC_IO structure.  The  
....................                             structure contains information about how to complete 
....................                             the write operation (ex: number of total bytes to write, 
....................                             where to obtain the bytes from, number of bytes 
....................                             to write for each call to MDD_SDSPI_AsyncWriteTasks(), etc.). 
....................   Return Values: 
....................     BYTE - Returns a status byte indicating the current state of the write  
....................             operation. The possible return values are: 
....................              
....................             ASYNC_WRITE_BUSY - Returned when the state machine is busy waiting for 
....................                              the media to become ready to accept new data.  The  
....................                              media has write time, which can often be quite long 
....................                              (a few ms typ, with maximum of 250ms).  The application 
....................                              should keep calling MDD_SDSPI_AsyncWriteTasks() until either 
....................                              an error/timeout occurs, ASYNC_WRITE_SEND_PACKET 
....................                              is returned, or ASYNC_WRITE_COMPLETE is returned. 
....................             ASYNC_WRITE_SEND_PACKET -   Returned when the MDD_SDSPI_AsyncWriteTasks() 
....................                                         handler is ready to consume data and send 
....................                                         it to the media.  After ASYNC_WRITE_SEND_PACKET 
....................                                         is returned, the application should make certain 
....................                                         that the info->wNumBytes and pBuffer parameters 
....................                                         are correct, prior to calling  
....................                                         MDD_SDSPI_AsyncWriteTasks() again.  After 
....................                                         the function returns, the application is 
....................                                         then free to write new data into the pBuffer 
....................                                         RAM location.  
....................             ASYNC_WRITE_COMPLETE - Returned when all data bytes in the write 
....................                                  operation have been written to the media successfully, 
....................                                  and the media is now ready for the next operation. 
....................             ASYNC_WRITE_ERROR - Returned when some failure occurs.  This could be 
....................                                either due to a media timeout, or due to some other 
....................                                unknown type of error.  In this case, the  
....................                                MDD_SDSPI_AsyncWriteTasks() handler will terminate 
....................                                the write attempt and will try to put the media  
....................                                back in a default state, ready for a new command.   
....................                                The application firmware may then retry the write 
....................                                attempt (if desired) by re-initializing the  
....................                                ASYNC_IO structure and setting the  
....................                                bStateVariable = ASYNC_WRITE_QUEUED. 
....................  
....................              
....................   Side Effects: 
....................     Uses the SPI bus and the media.  The media and SPI bus should not be 
....................     used by any other function until the read operation has either completed 
....................     successfully, or returned with the ASYNC_WRITE_ERROR condition. 
....................   Description: 
....................     Speed optimized, non-blocking, state machine based write function that writes  
....................     data packets to the media, from a user specified RAM buffer. 
....................     This function uses either the single block or multi-block write command  
....................     to perform fast writes of the data.  The total amount of data that will be  
....................     written on any given call to MDD_SDSPI_AsyncWriteTasks() will be the  
....................     info->numBytes parameter. 
....................     However, if the function is called repeatedly, with info->dwBytesRemaining 
....................     set to a large number, this function can successfully write data sizes >> than 
....................     the block size (theoretically anything up to ~4GB, since dwBytesRemaining is  
....................     a 32-bit DWORD).  The application firmware should continue calling  
....................     MDD_SDSPI_AsyncWriteTasks(), until the ASYNC_WRITE_COMPLETE value is returned  
....................     (or ASYNC_WRITE_ERROR), even if it has already sent all of the data expected. 
....................     This is necessary, so the state machine can finish the write process and  
....................     terminate the multi-block write operation, once the total expected number  
....................     of bytes have been written.  This puts the media back into the default state  
....................     ready for a new command. 
....................      
....................     During normal/successful operations, calls to MDD_SDSPI_AsyncWriteTasks()  
....................     would typically return: 
....................     1. ASYNC_WRITE_SEND_PACKET - repeatedly, until 512 bytes [media read  
....................         block size] is received, then  
....................     2. ASYNC_WRITE_BUSY (for awhile, could be a long time, many milliseconds), then 
....................     3. Back to ASYNC_WRITE_SEND_PACKET (repeatedly, until the next 512 byte 
....................        boundary, then back to #2, etc. 
....................     4. After all data is copied successfully, then the function will return  
....................        ASYNC_WRITE_COMPLETE, for all subsequent calls (until a new write operation 
....................        is started, by re-initializing the ASYNC_IO structure, and re-calling 
....................        the function). 
....................      
....................   Remarks: 
....................     When starting a read operation, the info->stateVariable must be initalized to 
....................     ASYNC_WRITE_QUEUED.  All other fields in the info structure should also be 
....................     initialized correctly. 
....................  
....................     This function will monopolize the SPI module during the operation.  Do not 
....................     use the SPI module for any other purpose, while a write operation is in 
....................     progress.  Additionally, the ASYNC_IO structure must not be modified 
....................     in a different context, while the MDD_SDSPI_AsyncReadTasks() function is  
....................     actively executing. 
....................     In between calls to MDD_SDSPI_AsyncWriteTasks(), certain parameters, namely the 
....................     info->wNumBytes and info->pBuffer are allowed to change however. 
....................      
....................     The dwBytesRemaining value must always be an exact integer multiple of wNumBytes  
....................     for the function to operate correctly.  Additionally, it is required that 
....................     the wNumBytes parameter, must always be less than or equal to the media block size, 
....................     (which is 512 bytes).  Additionally, info->wNumBytes must always be an exact  
....................     integer factor of the media block size.  Example values that are allowed for 
....................     info->wNumBytes are: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512. 
....................   *****************************************************************************/ 
.................... BYTE MDD_SDSPI_AsyncWriteTasks(ASYNC_IO* info) 
.................... { 
....................     static BYTE data_byte; 
....................     static WORD blockCounter; 
....................     static DWORD WriteTimeout; 
....................     static BYTE command; 
....................     DWORD preEraseBlockCount; 
....................     MMC_RESPONSE response; 
....................  
....................      
....................     //Check what state we are in, to decide what to do. 
....................     switch(info->bStateVariable) 
....................     { 
....................         case ASYNC_WRITE_COMPLETE: 
....................             return ASYNC_WRITE_COMPLETE; 
....................         case ASYNC_WRITE_QUEUED: 
....................             //Initiate the write sequence. 
....................             blockCounter = MEDIA_BLOCK_SIZE;    //Initialize counter.  Will be used later for block boundary tracking. 
....................  
....................             //Copy input structure into a statically allocated global instance  
....................             //of the structure, for faster local access of the parameters with  
....................             //smaller code size. 
....................             ioInfo = *info; 
....................  
....................             //Check if we are writing only a single block worth of data, or  
....................             //multiple blocks worth of data. 
....................             if(ioInfo.dwBytesRemaining <= MEDIA_BLOCK_SIZE) 
....................             { 
....................                 command = WRITE_SINGLE_BLOCK; 
....................             }     
....................             else 
....................             { 
....................                 command = WRITE_MULTI_BLOCK; 
....................                  
....................                 //Compute the number of blocks that we are going to be writing in this multi-block write operation. 
....................                 preEraseBlockCount = (ioInfo.dwBytesRemaining >> 9); //Divide by 512 to get the number of blocks to write 
....................                 //Always need to erase at least one block. 
....................                 if(preEraseBlockCount == 0) 
....................                 { 
....................                     preEraseBlockCount++;    
....................                 }  
....................      
....................                 //Should send CMD55/ACMD23 to let the media know how many blocks it should  
....................                 //pre-erase.  This isn't essential, but it allows for faster multi-block  
....................                 //writes, and probably also reduces flash wear on the media. 
....................                 response = SendMMCCmd(APP_CMD, 0x00000000);    //Send CMD55 
....................                 if(response.r1._byte == 0x00)   //Check if successful. 
....................                 { 
....................                     SendMMCCmd(SET_WR_BLK_ERASE_COUNT , preEraseBlockCount);    //Send ACMD23         
....................                 } 
....................             }     
....................  
....................             //The info->dwAddress parameter is the block address. 
....................             //For standard capacity SD cards, the card expects a complete byte address. 
....................             //To convert the block address into a byte address, we multiply by the block size (512). 
....................             //For SDHC (high capacity) cards, the card expects a block address already, so no 
....................             //address cconversion is needed 
....................             if (gSDMode == SD_MODE_NORMAL)   
....................             { 
....................                 ioInfo.dwAddress <<= 9;   //<< 9 multiplies by 512 
....................             }     
....................  
....................             //Send the write single or write multi command, with the LBA or byte  
....................             //address (depeding upon SDHC or standard capacity card) 
....................             response = SendMMCCmd(command, ioInfo.dwAddress);     
....................  
....................             //See if it was accepted 
....................             if(response.r1._byte != 0x00) 
....................             { 
....................                 //Perhaps the card isn't initialized or present. 
....................                 info->bStateVariable = ASYNC_WRITE_ERROR; 
....................                 return ASYNC_WRITE_ERROR;  
....................             }     
....................             else 
....................             { 
....................                 //Card is ready to receive start token and data bytes. 
....................                 info->bStateVariable = ASYNC_WRITE_TRANSMIT_PACKET; 
....................             }  
....................             return ASYNC_WRITE_SEND_PACKET;    
....................  
....................         case ASYNC_WRITE_TRANSMIT_PACKET: 
....................             //Check if we just finished programming a block, or we are starting 
....................             //for the first time.  In this case, we need to send the data start token. 
....................             if(blockCounter == MEDIA_BLOCK_SIZE) 
....................             { 
....................                 //Send the correct data start token, based on the type of write we are doing 
....................                 if(command == WRITE_MULTI_BLOCK) 
....................                 { 
....................                     WriteSPIM(DATA_START_MULTI_BLOCK_TOKEN);    
....................                 } 
....................                 else 
....................                 { 
....................                     //Else must be a single block write 
....................                     WriteSPIM(DATA_START_TOKEN);    
....................                 }         
....................             }  
....................                 
....................             //Update local copy of pointer and byte count.  Application firmware 
....................             //is alllowed to change these between calls to this handler function. 
....................             ioInfo.wNumBytes = info->wNumBytes; 
....................             ioInfo.pBuffer = info->pBuffer; 
....................              
....................             //Keep track of variables for loop/state exit conditions. 
....................             ioInfo.dwBytesRemaining -= ioInfo.wNumBytes; 
....................             blockCounter -= ioInfo.wNumBytes; 
....................              
....................             //Now send a packet of raw data bytes to the media, over SPI. 
....................             //This code directly impacts data thoroughput in a significant way.   
....................             //Special care should be used to make sure this code is speed optimized. 
....................            #if defined __C30__ || defined __C32__ 
....................             { 
....................                 //PIC24/dsPIC/PIC32 architecture is efficient with pointers and  
....................                 //local variables due to the large number of WREGs available. 
....................                 //Therefore, this code gives good SPI bus utilization, provided 
....................                 //the compiler optimization level is 's' or '3'. 
....................                 BYTE* localPointer = ioInfo.pBuffer;     
....................                 WORD localCounter = ioInfo.wNumBytes; 
....................                 do 
....................                 { 
....................                     SPIBUF = *localPointer++; 
....................                     localCounter--; 
....................                     while(!SPISTAT_RBF); 
....................                     data_byte = SPIBUF; //Dummy read to clear SPISTAT_RBF 
....................                 }while(localCounter);          
....................             }                        
....................             #elif defined __18CXX    
....................                 PIC18_Optimized_SPI_Write_Packet(); 
....................             #endif 
....................   
....................             //Check if we have finshed sending a 512 byte block.  If so, 
....................             //need to receive 16-bit CRC, and retrieve the data_response token 
....................             if(blockCounter == 0) 
....................             { 
....................                 blockCounter = MEDIA_BLOCK_SIZE;    //Re-initialize counter 
....................                  
....................                 //Add code to compute CRC, if using CRC. By default, the media  
....................                 //doesn't use CRC unless it is enabled manually during the card  
....................                 //initialization sequence. 
....................                 mSendCRC();  //Send 16-bit CRC for the data block just sent 
....................                  
....................                 //Read response token byte from media, mask out top three don't  
....................                 //care bits, and check if there was an error 
....................                 if((MDD_SDSPI_ReadMedia() & WRITE_RESPONSE_TOKEN_MASK) != DATA_ACCEPTED) 
....................                 { 
....................                     //Something went wrong.  Try and terminate as gracefully as  
....................                     //possible, so as allow possible recovery. 
....................                     info->bStateVariable = ASYNC_WRITE_ABORT;  
....................                     return ASYNC_WRITE_BUSY; 
....................                 } 
....................                  
....................                 //The media will now send busy token (0x00) bytes until 
....................                 //it is internally ready again (after the block is successfully 
....................                 //writen and the card is ready to accept a new block. 
....................                 info->bStateVariable = ASYNC_WRITE_MEDIA_BUSY; 
....................                 WriteTimeout = WRITE_TIMEOUT;       //Initialize timeout counter 
....................                 return ASYNC_WRITE_BUSY; 
....................             }//if(blockCounter == 0) 
....................              
....................             //If we get to here, we haven't reached a block boundary yet.  Keep  
....................             //on requesting packets of data from the application. 
....................             return ASYNC_WRITE_SEND_PACKET;    
....................  
....................         case ASYNC_WRITE_MEDIA_BUSY: 
....................             if(WriteTimeout != 0) 
....................             { 
....................                 WriteTimeout--; 
....................                 mSend8ClkCycles();  //Dummy read to gobble up a byte (ex: to ensure we meet NBR timing parameter) 
....................                 data_byte = MDD_SDSPI_ReadMedia();  //Poll the media.  Will return 0x00 if still busy.  Will return non-0x00 is ready for next data block. 
....................                 if(data_byte != 0x00) 
....................                 { 
....................                     //The media is done and is no longer busy.  Go ahead and 
....................                     //either send the next packet of data to the media, or the stop 
....................                     //token if we are finshed. 
....................                     if(ioInfo.dwBytesRemaining == 0) 
....................                     { 
....................                         WriteTimeout = WRITE_TIMEOUT; 
....................                         if(command == WRITE_MULTI_BLOCK) 
....................                         { 
....................                             //We finished sending all bytes of data.  Send the stop token byte. 
....................                             WriteSPIM(DATA_STOP_TRAN_TOKEN); 
....................                             //After sending the stop transmission token, we need to 
....................                             //gobble up one byte before checking for media busy (0x00). 
....................                             //This is to meet the NBR timing parameter.  During the NBR 
....................                             //interval the SD card may not respond with the busy signal, even 
....................                             //though it is internally busy. 
....................                             mSend8ClkCycles(); 
....................                                                  
....................                             //The media still needs to finish internally writing. 
....................                             info->bStateVariable = ASYNC_STOP_TOKEN_SENT_WAIT_BUSY; 
....................                             return ASYNC_WRITE_BUSY; 
....................                         } 
....................                         else 
....................                         { 
....................                             //In this case we were doing a single block write, 
....................                             //so no stop token is necessary.  In this case we are 
....................                             //now fully complete with the write operation. 
....................                             SD_CS = 1;          //De-select media 
....................                             mSend8ClkCycles();   
....................                             info->bStateVariable = ASYNC_WRITE_COMPLETE; 
....................                             return ASYNC_WRITE_COMPLETE;                             
....................                         }                             
....................                          
....................                     } 
....................                     //Else we have more data to write in the multi-block write.     
....................                     info->bStateVariable = ASYNC_WRITE_TRANSMIT_PACKET;   
....................                     return ASYNC_WRITE_SEND_PACKET;                     
....................                 }     
....................                 else 
....................                 { 
....................                     //The media is still busy. 
....................                     return ASYNC_WRITE_BUSY; 
....................                 }     
....................             } 
....................             else 
....................             { 
....................                 //Timeout occurred.  Something went wrong.  The media should not  
....................                 //have taken this long to finish the write. 
....................                 info->bStateVariable = ASYNC_WRITE_ABORT; 
....................                 return ASYNC_WRITE_BUSY; 
....................             }         
....................          
....................         case ASYNC_STOP_TOKEN_SENT_WAIT_BUSY: 
....................             //We already sent the stop transmit token for the multi-block write  
....................             //operation.  Now all we need to do, is keep waiting until the card 
....................             //signals it is no longer busy.  Card will keep sending 0x00 bytes 
....................             //until it is no longer busy. 
....................             if(WriteTimeout != 0) 
....................             { 
....................                 WriteTimeout--; 
....................                 data_byte = MDD_SDSPI_ReadMedia(); 
....................                 //Check if card is no longer busy.   
....................                 if(data_byte != 0x00) 
....................                 { 
....................                     //If we get to here, multi-block write operation is fully 
....................                     //complete now.   
....................  
....................                     //Should send CMD13 (SEND_STATUS) after a programming sequence,  
....................                     //to confirm if it was successful or not inside the media. 
....................                                  
....................                     //Prepare to receive the next command. 
....................                     SD_CS = 1;          //De-select media 
....................                     mSend8ClkCycles();  //NEC timing parameter clocking 
....................                     info->bStateVariable = ASYNC_WRITE_COMPLETE; 
....................                     return ASYNC_WRITE_COMPLETE; 
....................                 } 
....................                 //If we get to here, the media is still busy with the write. 
....................                 return ASYNC_WRITE_BUSY;     
....................             }     
....................             //Timeout occurred.  Something went wrong.  Fall through to ASYNC_WRITE_ABORT. 
....................         case ASYNC_WRITE_ABORT: 
....................             //An error occurred, and we need to stop the write sequence so as to try and allow 
....................             //for recovery/re-attempt later. 
....................             SendMMCCmd(STOP_TRANSMISSION, 0x00000000); 
....................             SD_CS = 1;  //deselect media 
....................             mSend8ClkCycles();  //After raising CS pin, media may not tri-state data out for 1 bit time. 
....................             info->bStateVariable = ASYNC_WRITE_ERROR;  
....................             //Fall through to default case. 
....................         default: 
....................             //Used for ASYNC_WRITE_ERROR case. 
....................             return ASYNC_WRITE_ERROR;  
....................     }//switch(info->stateVariable)     
....................      
....................  
....................     //Should never execute to here.  All pathways should have a hit a return already. 
....................     info->bStateVariable = ASYNC_WRITE_ABORT; 
....................     return ASYNC_WRITE_BUSY; 
.................... }  
....................  
....................  
.................... #ifdef __18CXX    
.................... /***************************************************************************** 
....................   Function: 
....................     static void PIC18_Optimized_SPI_Write_Packet(void) 
....................   Summary: 
....................     A private function intended for use internal to the SD-SPI.c file. 
....................     This function writes a specified number of bytes to the SPI module, 
....................     at high speed for optimum throughput, copied from the user specified RAM 
....................     buffer. 
....................     This function is only implemented and used on PIC18 devices. 
....................   Pre-Conditions: 
....................     The ioInfo.wNumBytes must be pre-initialized prior to calling  
....................     PIC18_Optimized_SPI_Write_Packet(). 
....................     Additionally, the ioInfo.pBuffer must also be pre-initialized, prior 
....................     to calling PIC18_Optimized_SPI_Write_Packet(). 
....................   Input: 
....................     ioInfo.wNumBytes global variable, initialized to the number of bytes to send 
....................     ioInfo.pBuffer global variable, initialized to point to the RAM location that 
....................         contains the data to send out the SPI port 
....................   Return Values: 
....................     None 
....................   Side Effects: 
....................     None 
....................   Description: 
....................     A private function intended for use internal to the SD-SPI.c file. 
....................     This function writes a specified number of bytes to the SPI module, 
....................     at high speed for optimum throughput, copied from the user specified RAM 
....................     buffer. 
....................     This function is only implemented and used on PIC18 devices. 
....................   Remarks: 
....................     This function is speed optimized, using inline assembly language code, and 
....................     makes use of C compiler managed resources.  It is currently written to work 
....................     with the Microchip MPLAB C18 compiler, and may need modification if built 
....................     with a different PIC18 compiler. 
....................   *****************************************************************************/ 
.................... static void PIC18_Optimized_SPI_Write_Packet(void) 
.................... { 
....................     static BYTE bData; 
....................     static WORD FSR0Save; 
....................     static WORD PRODSave; 
....................  
....................     //Make sure the SPI_INTERRUPT_FLAG_ASM has been correctly defined, for the SPI 
....................     //module that is actually being used in the hardware. 
....................     #ifndef SPI_INTERRUPT_FLAG_ASM 
....................         #error Please add "#define SPI_INTERRUPT_FLAG_ASM  PIRx, Y" to your hardware profile.  Replace x and Y with appropriate numbers for your SPI module interrupt flag. 
....................     #endif 
....................      
....................     //Make sure at least one byte needs copying. 
....................     if(ioInfo.wNumBytes == 0) 
....................     { 
....................         return; 
....................     }     
....................  
....................     //Context save C compiler managed registers. 
....................     FSR0Save = FSR0;  
....................     PRODSave = PROD; 
....................      
....................     //Using PRODH and PRODL as 16 bit loop counter.  These are convenient since 
....................     //they are always in the access bank. 
....................     PROD = ioInfo.wNumBytes; 
....................     //Using FSR0 directly, for optimal SPI loop speed. 
....................     FSR0 = (WORD)ioInfo.pBuffer;  
....................  
.................... #if defined(__CCS__) 
.................... //had to modify this code to get rid of -2 BRA and the ,0 for all byte access 
.................... #endif 
....................  
....................  
....................     _asm 
....................         movf    POSTINC0, 0  //Fetch next byte to send and store in WREG 
....................         bra     ASMSPIXmitLoopEntryPoint 
.................... ASMSPIXmitLoop:     
....................         movf    POSTINC0, 0  //Pre-Fetch next byte to send and temporarily store in WREG 
....................         //Wait until last hardware SPI transaction is complete 
.................... ASMSPIXmitLoop2: 
....................         btfss   SPI_INTERRUPT_FLAG_ASM 
....................         bra     ASMSPIXmitLoop2 
....................          
.................... ASMSPIXmitLoopEntryPoint: 
....................         //Start the next SPI transaction 
....................         bcf     SPI_INTERRUPT_FLAG_ASM   //Clear interrupt flag 
....................         movwf   SPIBUF      //Write next byte to transmit to SSPBUF 
....................          
....................         //Now decrement byte counter for loop exit condition 
....................         movlw   0x00 
....................         decf    PRODL, 1     //Decrement LSB 
....................         subwfb  PRODH, 1    //Decrement MSB, only if borrow from LSB decrement 
....................         //Check if anymore bytes remain to be sent 
....................         movf    PRODL, 0     //copy PRODL to WREG 
....................         iorwf   PRODH, 0    //Z bit will be set if both PRODL and PRODH == 0x00 
....................         bnz     ASMSPIXmitLoop  //Go back and loop if our counter isn't = 0x0000. 
....................     _endasm 
....................  
....................     //Wait until the last SPI transaction is really complete.   
....................     //Above loop jumps out after the last byte is started, but not finished yet. 
....................     while(!SPI_INTERRUPT_FLAG); 
....................  
....................     //Leave SPI module in a "clean" state, ready for next transaction. 
....................     bData = SPIBUF;         //Dummy read to clear BF flag. 
....................     SPI_INTERRUPT_FLAG = 0; //Clear interrupt flag. 
....................     //Restore C compiler managed registers that we modified 
....................     PROD = PRODSave; 
....................     FSR0 = FSR0Save; 
.................... }     
.................... #endif     
....................  
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE MDD_SDSPI_SectorWrite (DWORD sector_addr, BYTE * buffer, BYTE allowWriteToZero) 
....................   Summary: 
....................     Writes a sector of data to an SD card. 
....................   Conditions: 
....................     The MDD_SectorWrite function pointer must be pointing to this function. 
....................   Input: 
....................     sector_addr -      The address of the sector on the card. 
....................     buffer -           The buffer with the data to write. 
....................     allowWriteToZero - 
....................                      - TRUE -  Writes to the 0 sector (MBR) are allowed 
....................                      - FALSE - Any write to the 0 sector will fail. 
....................   Return Values: 
....................     TRUE -  The sector was written successfully. 
....................     FALSE - The sector could not be written. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_SectorWrite function writes one sector of data (512 bytes)  
....................     of data from the location pointed to by 'buffer' to the specified sector of  
....................     the SD card. 
....................   Remarks: 
....................     The card expects the address field in the command packet to be a byte address. 
....................     The sector_addr value is ocnverted to a byte address by shifting it left nine 
....................     times (multiplying by 512). 
....................   ***************************************************************************************/ 
.................... BYTE MDD_SDSPI_SectorWrite(DWORD sector_addr, BYTE* buffer, BYTE allowWriteToZero) 
.................... { 
....................     static ASYNC_IO info; 
....................     BYTE status; 
....................      
....................     if(allowWriteToZero == FALSE) 
....................     { 
....................         if(sector_addr == 0x00000000) 
....................         { 
....................             return FALSE; 
....................         }     
....................     }     
....................      
....................     //Initialize structure so we write a single sector worth of data. 
....................     info.wNumBytes = 512; 
....................     info.dwBytesRemaining = 512; 
....................     info.pBuffer = buffer; 
....................     info.dwAddress = sector_addr; 
....................     info.bStateVariable = ASYNC_WRITE_QUEUED; 
....................      
....................     //Repeatedly call the write handler until the operation is complete (or a 
....................     //failure/timeout occurred). 
....................     while(1) 
....................     { 
....................         status = MDD_SDSPI_AsyncWriteTasks(&info); 
....................         if(status == ASYNC_WRITE_COMPLETE) 
....................         { 
....................             return TRUE; 
....................         }     
....................         else if(status == ASYNC_WRITE_ERROR) 
....................         { 
....................             return FALSE; 
....................         } 
....................     }     
....................     return TRUE; 
.................... }     
....................  
....................  
....................  
....................  
.................... /******************************************************************************* 
....................   Function: 
....................     BYTE MDD_SDSPI_WriteProtectState 
....................   Summary: 
....................     Indicates whether the card is write-protected. 
....................   Conditions: 
....................     The MDD_WriteProtectState function pointer must be pointing to this function. 
....................   Input: 
....................     None. 
....................   Return Values: 
....................     TRUE -  The card is write-protected 
....................     FALSE - The card is not write-protected 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_WriteProtectState function will determine if the SD card is 
....................     write protected by checking the electrical signal that corresponds to the 
....................     physical write-protect switch. 
....................   Remarks: 
....................     None 
.................... *******************************************************************************/ 
....................  
.................... BYTE MDD_SDSPI_WriteProtectState(void) 
.................... { 
....................    #if defined(SD_WE) 
....................     return(SD_WE); 
....................    #else 
....................     return(FALSE); 
....................    #endif 
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................   Function: 
....................     void Delayms (BYTE milliseconds) 
....................   Summary: 
....................     Delay. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     BYTE milliseconds - Number of ms to delay 
....................   Return: 
....................     None. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The Delayms function will delay a specified number of milliseconds.  Used for SPI 
....................     timing. 
....................   Remarks: 
....................     Depending on compiler revisions, this function may not delay for the exact  
....................     time specified.  This shouldn't create a significant problem. 
.................... *******************************************************************************/ 
....................  
.................... void Delayms(BYTE milliseconds) 
.................... { 
....................     BYTE    ms; 
....................     DWORD   count; 
....................      
....................     ms = milliseconds; 
....................     while (ms--) 
....................     { 
....................         count = MILLISECDELAY; 
....................         while (count--); 
....................     } 
....................     Nop(); 
....................     return; 
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................   Function: 
....................     void CloseSPIM (void) 
....................   Summary: 
....................     Disables the SPI module. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     None. 
....................   Return: 
....................     None. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     Disables the SPI module. 
....................   Remarks: 
....................     None. 
.................... *******************************************************************************/ 
....................  
.................... void CloseSPIM (void) 
.................... { 
.................... #if defined __C30__ || defined __C32__ 
....................  
....................     SPISTAT &= 0x7FFF; 
....................  
.................... #elif defined __18CXX 
....................  
....................     SPICON1 &= 0xDF; 
....................  
.................... #endif 
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     unsigned char WriteSPIM (unsigned char data_out) 
....................   Summary: 
....................     Writes data to the SD card. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     data_out - The data to write. 
....................   Return: 
....................     0. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The WriteSPIM function will write a byte of data from the microcontroller to the 
....................     SD card. 
....................   Remarks: 
....................     None. 
....................   ***************************************************************************************/ 
....................  
.................... unsigned char WriteSPIM( unsigned char data_out ) 
.................... { 
.................... #ifdef __PIC32MX__ 
....................     BYTE   clear; 
....................     putcSPI((BYTE)data_out); 
....................     clear = getcSPI(); 
....................     return ( 0 );                // return non-negative# 
.................... #elif defined __18CXX 
....................     BYTE clear; 
....................     clear = SPIBUF; 
....................     SPICON1 &= 0x7F;       //__PCH__ __CCS__  clear wcol 
....................     SPI_INTERRUPT_FLAG = 0; 
....................     SPIBUF = data_out; 
....................     if (SPICON1 & 0x80) 
....................         return -1; 
....................     else 
....................         while (!SPI_INTERRUPT_FLAG); 
....................     return 0; 
.................... #else 
....................     BYTE   clear; 
....................     SPIBUF = data_out;          // write byte to SSP1BUF register 
....................     while( !SPISTAT_RBF ); // wait until bus cycle complete 
....................     clear = SPIBUF; 
....................     return ( 0 );                // return non-negative# 
.................... #endif 
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE MDD_SDSPI_ReadMedia (void) 
....................   Summary: 
....................     Reads a byte of data from the SD card. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     None. 
....................   Return: 
....................     The byte read. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_ReadMedia function will read one byte from the SPI port. 
....................   Remarks: 
....................     This function replaces ReadSPI, since some implementations of that function 
....................     will initialize SSPBUF/SPIBUF to 0x00 when reading.  The card expects 0xFF. 
....................   ***************************************************************************************/ 
.................... BYTE MDD_SDSPI_ReadMedia(void) 
.................... { 
....................  
.................... #ifdef __C32__ 
....................  
....................     putcSPI((BYTE)0xFF); 
....................     return (BYTE)getcSPI(); 
....................  
.................... #elif defined __18CXX 
....................     BYTE clear; 
....................     clear = SPIBUF; 
....................     SPI_INTERRUPT_FLAG = 0; 
....................     SPIBUF = 0xFF; 
....................     while (!SPI_INTERRUPT_FLAG); 
....................     return SPIBUF; 
....................  
.................... #else 
....................     SPIBUF = 0xFF;                              //Data Out - Logic ones 
....................     while(!SPISTAT_RBF);                     //Wait until cycle complete 
....................     return(SPIBUF);                             //Return with byte read 
.................... #endif 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     void OpenSPIM (unsigned int sync_mode) 
....................   Summary: 
....................     Initializes the SPI module 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     sync_mode - Input parameter that sets the SPI mode/speed. 
....................   Return: 
....................     None. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The OpenSPIM function will enable and configure the SPI module. 
....................   Remarks: 
....................     None. 
....................   ***************************************************************************************/ 
....................  
.................... #ifdef __18CXX 
.................... void OpenSPIM (unsigned char sync_mode) 
.................... #else 
.................... void OpenSPIM( unsigned int sync_mode) 
.................... #endif 
.................... { 
....................     SPISTAT = 0x0000;               // power on state  
....................  
....................     //SPI module initilization depends on processor type 
....................     #ifdef __PIC32MX__ 
....................         #if (GetSystemClock() <= 20000000) 
....................             SPIBRG = SPICalutateBRG(GetPeripheralClock(), 10000); 
....................         #else 
....................             SPIBRG = SPICalutateBRG(GetPeripheralClock(), SPI_FREQUENCY); 
....................         #endif 
....................         SPICON1bits.CKP = 1; 
....................         SPICON1bits.CKE = 0; 
....................     #elif defined __C30__ //must be PIC24 or dsPIC device 
....................         SPICON1 = 0x0000;              // power on state 
....................         SPICON1 |= sync_mode;          // select serial mode  
....................         SPICON1bits.CKP = 1; 
....................         SPICON1bits.CKE = 0; 
....................     #else   //must be __18CXX (PIC18 processor) 
....................         SPICON1 = 0x00;          
....................         SPICON1 |= sync_mode;    
....................         SPISTATbits.CKE = 1; 
....................     #endif 
....................  
....................     SPICLOCK = 0; 
....................     SPIOUT = 0;                  // define SDO1 as output (master or slave) 
....................     SPIIN = 1;                  // define SDI1 as input (master or slave) 
....................     SPIENABLE = 1;             // enable synchronous serial port 
.................... } 
....................  
....................  
.................... #ifdef __18CXX 
.................... // Description: Delay value for the manual SPI clock 
.................... #define MANUAL_SPI_CLOCK_VALUE             1 
.................... /***************************************************************************** 
....................   Function: 
....................     unsigned char WriteSPIManual (unsigned char data_out) 
....................   Summary: 
....................     Write a character to the SD card with bit-bang SPI. 
....................   Conditions: 
....................     Make sure the SDI pin is pre-configured as a digital pin, if it is  
....................     multiplexed with analog functionality. 
....................   Input: 
....................     data_out - Data to send. 
....................   Return: 
....................     0. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     Writes a character to the SD card. 
....................   Remarks: 
....................     The WriteSPIManual function is for use on a PIC18 when the clock speed is so 
....................     high that the maximum SPI clock divider cannot reduce the SPI clock speed below 
....................     the maximum SD card initialization speed. 
....................   ***************************************************************************************/ 
.................... unsigned char WriteSPIManual(unsigned char data_out) 
.................... { 
....................     unsigned char i; 
....................     unsigned char clock; 
....................  
....................     SPICLOCKLAT = 0; 
....................     SPIOUTLAT = 1; 
....................     SPICLOCK = OUTPUT; 
....................     SPIOUT = OUTPUT; 
....................  
....................    //Loop to send out 8 bits of SDO data and associated SCK clock. 
....................    for(i = 0; i < 8; i++) 
....................    { 
....................       SPICLOCKLAT = 0; 
....................       if(data_out & 0x80) 
....................          SPIOUTLAT = 1; 
....................       else 
....................          SPIOUTLAT = 0; 
....................       data_out = data_out << 1;            //Bit shift, so next bit to send is in MSb position 
....................        clock = MANUAL_SPI_CLOCK_VALUE; 
....................        while (clock--); 
....................        SPICLOCKLAT = 1; 
....................        clock = MANUAL_SPI_CLOCK_VALUE; 
....................        while (clock--);              
....................    }    
....................     SPICLOCKLAT = 0; 
....................  
....................     return 0;  
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     BYTE ReadMediaManual (void) 
....................   Summary: 
....................     Reads a byte of data from the SD card. 
....................   Conditions: 
....................     None. 
....................   Input: 
....................     None. 
....................   Return: 
....................     The byte read. 
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     The MDD_SDSPI_ReadMedia function will read one byte from the SPI port. 
....................   Remarks: 
....................     This function replaces ReadSPI, since some implementations of that function 
....................     will initialize SSPBUF/SPIBUF to 0x00 when reading.  The card expects 0xFF. 
....................     This function is for use on a PIC18 when the clock speed is so high that the 
....................     maximum SPI clock prescaler cannot reduce the SPI clock below the maximum SD card 
....................     initialization speed. 
....................   ***************************************************************************************/ 
.................... BYTE ReadMediaManual (void) 
.................... { 
....................     unsigned char i; 
....................     unsigned char clock; 
....................     unsigned char result = 0x00; 
....................  
....................     SPIOUTLAT = 1; 
....................     SPIOUT = OUTPUT; 
....................     SPIIN = INPUT; 
....................     SPICLOCKLAT = 0; 
....................     SPICLOCK = OUTPUT; 
....................   
....................     //Loop to send 8 clock pulses and read in the returned bits of data. Data "sent" will be = 0xFF 
....................    for(i = 0; i < 8u; i++) 
....................    { 
....................       SPICLOCKLAT = 0; 
....................        clock = MANUAL_SPI_CLOCK_VALUE; 
....................        while (clock--); 
....................        SPICLOCKLAT = 1; 
....................        clock = MANUAL_SPI_CLOCK_VALUE; 
....................        while (clock--); 
....................       result = result << 1;   //Bit shift the previous result.  We receive the byte MSb first. This operation makes LSb = 0.   
....................        if(SPIINPORT) 
....................           result++;         //Set the LSb if we detected a '1' on the SPIINPORT pin, otherwise leave as 0. 
....................    }    
....................     SPICLOCKLAT = 0; 
....................  
....................     return result; 
.................... }//end ReadMedia 
.................... #endif      // End __18CXX 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     void InitSPISlowMode(void) 
....................   Summary: 
....................     Initializes the SPI module to operate at low SPI frequency <= 400kHz. 
....................   Conditions: 
....................     Processor type and GetSystemClock() macro have to be defined correctly 
....................     to get the correct SPI frequency. 
....................   Input: 
....................     Uses GetSystemClock() macro value.  Should be #define in the hardwareprofile. 
....................   Return Values: 
....................     None.  Initializes the hardware SPI module (except on PIC18).  On PIC18, 
....................     The SPI is bit banged to achieve low frequencies, but this function still 
....................     initializes the I/O pins.  
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     This function initalizes and enables the SPI module, configured for low  
....................     SPI frequency, so as to be compatible with media cards which require <400kHz 
....................     SPI frequency during initialization. 
....................   Remarks: 
....................     None. 
....................   ***************************************************************************************/ 
.................... void InitSPISlowMode(void) 
.................... { 
....................     #if defined __C30__ || defined __C32__ 
....................        #ifdef __PIC32MX__ 
....................           OpenSPI(SPI_START_CFG_1, SPI_START_CFG_2); 
....................            SPIBRG = SPICalutateBRG(GetPeripheralClock(), 400000); 
....................        #else //else C30 = PIC24/dsPIC devices 
....................           WORD spiconvalue = 0x0003; 
....................             WORD timeout; 
....................            // Calculate the prescaler needed for the clock 
....................            timeout = GetSystemClock() / 400000; 
....................            // if timeout is less than 400k and greater than 100k use a 1:1 prescaler 
....................            if (timeout == 0) 
....................            { 
....................                OpenSPIM (MASTER_ENABLE_ON | PRI_PRESCAL_1_1 | SEC_PRESCAL_1_1); 
....................            } 
....................            else 
....................            { 
....................                while (timeout != 0) 
....................                { 
....................                    if (timeout > 8) 
....................                    { 
....................                        spiconvalue--; 
....................                        // round up 
....................                        if ((timeout % 4) != 0) 
....................                            timeout += 4; 
....................                        timeout /= 4; 
....................                    } 
....................                    else 
....................                    { 
....................                        break; 
....................                    } 
....................                } 
....................                 
....................                timeout--; 
....................             
....................                OpenSPIM (MASTER_ENABLE_ON | spiconvalue | ((~(timeout << 2)) & 0x1C)); 
....................            } 
....................        #endif   //#ifdef __PIC32MX__ (and corresponding #else)     
....................     #else //must be PIC18 device 
....................         //Make sure the SPI module doesn't control the bus, will use  
....................         //bit-banged SPI instead, for slow mode initialization operation 
....................         SPICON1 = 0x00; 
....................         SPICLOCKLAT = 0; 
....................         SPIOUTLAT = 1; 
....................         SPICLOCK = OUTPUT; 
....................         SPIOUT = OUTPUT; 
....................     #endif //#if defined __C30__ || defined __C32__ 
.................... }     
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     MEDIA_INFORMATION *  MDD_SDSPI_MediaInitialize (void) 
....................   Summary: 
....................     Initializes the SD card. 
....................   Conditions: 
....................     The MDD_MediaInitialize function pointer must be pointing to this function. 
....................   Input: 
....................     None. 
....................   Return Values: 
....................     The function returns a pointer to the MEDIA_INFORMATION structure.  The 
....................     errorCode member may contain the following values: 
....................         * MEDIA_NO_ERROR - The media initialized successfully 
....................         * MEDIA_CANNOT_INITIALIZE - Cannot initialize the media.   
....................   Side Effects: 
....................     None. 
....................   Description: 
....................     This function will send initialization commands to and SD card. 
....................   Remarks: 
....................     Psuedo code flow for the media initialization process is as follows: 
....................  
.................... ------------------------------------------------------------------------------------------- 
.................... SD Card SPI Initialization Sequence (for physical layer v1.x or v2.0 device) is as follows: 
.................... ------------------------------------------------------------------------------------------- 
.................... 0.  Power up tasks 
....................     a.  Initialize microcontroller SPI module to no more than 400kbps rate so as to support MMC devices. 
....................     b.  Add delay for SD card power up, prior to sending it any commands.  It wants the  
....................         longer of: 1ms, the Vdd ramp time (time from 2.7V to Vdd stable), and 74+ clock pulses. 
.................... 1.  Send CMD0 (GO_IDLE_STATE) with CS = 0.  This puts the media in SPI mode and software resets the SD/MMC card. 
.................... 2.  Send CMD8 (SEND_IF_COND).  This requests what voltage the card wants to run at.  
....................     Note: Some cards will not support this command. 
....................     a.  If illegal command response is received, this implies either a v1.x physical spec device, or not an SD card (ex: MMC). 
....................     b.  If normal response is received, then it must be a v2.0 or later SD memory card. 
....................  
.................... If v1.x device: 
.................... ----------------- 
.................... 3.  Send CMD1 repeatedly, until initialization complete (indicated by R1 response byte/idle bit == 0) 
.................... 4.  Basic initialization is complete.  May now switch to higher SPI frequencies. 
.................... 5.  Send CMD9 to read the CSD structure.  This will tell us the total flash size and other info which will be useful later. 
.................... 6.  Parse CSD structure bits (based on v1.x structure format) and extract useful information about the media. 
.................... 7.  The card is now ready to perform application data transfers. 
....................  
.................... If v2.0+ device: 
.................... ----------------- 
.................... 3.  Verify the voltage range is feasible.  If not, unusable card, should notify user that the card is incompatible with this host. 
.................... 4.  Send CMD58 (Read OCR). 
.................... 5.  Send CMD55, then ACMD41 (SD_SEND_OP_COND, with HCS = 1). 
....................     a.  Loop CMD55/ACMD41 until R1 response byte == 0x00 (indicating the card is no longer busy/no longer in idle state).   
.................... 6.  Send CMD58 (Get CCS). 
....................     a.  If CCS = 1 --> SDHC card. 
....................     b.  If CCS = 0 --> Standard capacity SD card (which is v2.0+). 
.................... 7.  Basic initialization is complete.  May now switch to higher SPI frequencies. 
.................... 8.  Send CMD9 to read the CSD structure.  This will tell us the total flash size and other info which will be useful later. 
.................... 9.  Parse CSD structure bits (based on v2.0 structure format) and extract useful information about the media. 
.................... 10. The card is now ready to perform application data transfers. 
.................... -------------------------------------------------------------------------------- 
.................... ********************************************************************************/ 
....................  
.................... MEDIA_INFORMATION *  MDD_SDSPI_MediaInitialize(void) 
.................... { 
....................     WORD timeout; 
....................     MMC_RESPONSE response; 
....................    BYTE CSDResponse[20]; 
....................    BYTE count, index; 
....................    DWORD c_size; 
....................    BYTE c_size_mult; 
....................    BYTE block_len; 
....................     
....................    #ifdef __DEBUG_UART 
....................    InitUART(); 
....................    #endif 
....................   
....................     //Initialize global variables.  Will get updated later with valid data once 
....................     //the data is known. 
....................     mediaInformation.errorCode = MEDIA_NO_ERROR; 
....................     mediaInformation.validityFlags.value = 0; 
....................     MDD_SDSPI_finalLBA = 0x00000000;   //Will compute a valid size later, from the CSD register values we get from the card 
....................     gSDMode = SD_MODE_NORMAL;           //Will get updated later with real value, once we know based on initialization flow. 
....................  
....................     SD_CS = 1;               //Initialize Chip Select line (1 = card not selected) 
....................  
....................     //MMC media powers up in the open-drain mode and cannot handle a clock faster 
....................     //than 400kHz. Initialize SPI port to <= 400kHz 
....................     InitSPISlowMode();     
....................      
....................     #ifdef __DEBUG_UART   
....................     PrintROMASCIIStringUART("\r\n\r\nInitializing Media\r\n");  
....................     #endif 
....................  
....................     //Media wants the longer of: Vdd ramp time, 1 ms fixed delay, or 74+ clock pulses. 
....................     //According to spec, CS should be high during the 74+ clock pulses. 
....................     //In practice it is preferrable to wait much longer than 1ms, in case of 
....................     //contact bounce, or incomplete mechanical insertion (by the time we start 
....................     //accessing the media).  
....................     Delayms(30); 
....................     SD_CS = 1; 
....................     //Generate 80 clock pulses. 
....................     for(timeout=0; timeout<10u; timeout++) 
....................         WriteSPISlow(0xFF); 
....................  
....................  
....................     // Send CMD0 (with CS = 0) to reset the media and put SD cards into SPI mode. 
....................     timeout = 100; 
....................     do 
....................     { 
....................         //Toggle chip select, to make media abandon whatever it may have been doing 
....................         //before.  This ensures the CMD0 is sent freshly after CS is asserted low, 
....................         //minimizing risk of SPI clock pulse master/slave syncronization problems,  
....................         //due to possible application noise on the SCK line. 
....................         SD_CS = 1; 
....................         WriteSPISlow(0xFF);   //Send some "extraneous" clock pulses.  If a previous 
....................                               //command was terminated before it completed normally, 
....................                               //the card might not have received the required clocking 
....................                               //following the transfer. 
....................         SD_CS = 0; 
....................         timeout--; 
....................  
....................         //Send CMD0 to software reset the device 
....................         response = SendMediaSlowCmd(GO_IDLE_STATE, 0x0); 
....................     }while((response.r1._byte != 0x01) && (timeout != 0)); 
....................     //Check if all attempts failed and we timed out.  Normally, this won't happen, 
....................     //unless maybe the SD card was busy, because it was previously performing a 
....................     //read or write operation, when it was interrupted by the microcontroller getting 
....................     //reset or power cycled, without also resetting or power cycling the SD card. 
....................     //In this case, the SD card may still be busy (ex: trying to respond with the  
....................     //read request data), and may not be ready to process CMD0.  In this case, 
....................     //we can try to recover by issuing CMD12 (STOP_TRANSMISSION). 
....................     if(timeout == 0) 
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("Media failed CMD0 too many times. R1 response byte = "); 
....................         PrintRAMBytesUART(((unsigned char*)&response + 1), 1); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         PrintROMASCIIStringUART("Trying CMD12 to recover.\r\n"); 
....................         #endif 
....................  
....................         SD_CS = 1; 
....................         WriteSPISlow(0xFF);       //Send some "extraneous" clock pulses.  If a previous 
....................                                   //command was terminated before it completed normally, 
....................                                   //the card might not have received the required clocking 
....................                                   //following the transfer. 
....................         SD_CS = 0; 
....................  
....................         //Send CMD12, to stop any read/write transaction that may have been in progress 
....................         response = SendMediaSlowCmd(STOP_TRANSMISSION, 0x0);    //Blocks until SD card signals non-busy 
....................         //Now retry to send send CMD0 to perform software reset on the media 
....................         response = SendMediaSlowCmd(GO_IDLE_STATE, 0x0);         
....................         if(response.r1._byte != 0x01) //Check if card in idle state now. 
....................         { 
....................             //Card failed to process CMD0 yet again.  At this point, the proper thing 
....................             //to do would be to power cycle the card and retry, if the host  
....................             //circuitry supports disconnecting the SD card power.  Since the 
....................             //SD/MMC PICtail+ doesn't support software controlled power removal 
....................             //of the SD card, there is nothing that can be done with this hardware. 
....................             //Therefore, we just give up now.  The user needs to physically  
....................             //power cycle the media and/or the whole board. 
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("Media still failed CMD0. Cannot initialize card, returning.\r\n"); 
....................             #endif    
....................             mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE; 
....................             return &mediaInformation; 
....................         }             
....................         else 
....................         { 
....................             //Card successfully processed CMD0 and is now in the idle state. 
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("Media successfully processed CMD0 after CMD12.\r\n"); 
....................             #endif         
....................         }     
....................     }//if(timeout == 0) [for the CMD0 transmit loop] 
....................     else 
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("Media successfully processed CMD0.\r\n"); 
....................         #endif         
....................     }        
....................      
....................  
....................     //Send CMD8 (SEND_IF_COND) to specify/request the SD card interface condition (ex: indicate what voltage the host runs at). 
....................     //0x000001AA --> VHS = 0001b = 2.7V to 3.6V.  The 0xAA LSB is the check pattern, and is arbitrary, but 0xAA is recommended (good blend of 0's and '1's). 
....................     //The SD card has to echo back the check pattern correctly however, in the R7 response. 
....................     //If the SD card doesn't support the operating voltage range of the host, then it may not respond. 
....................     //If it does support the range, it will respond with a type R7 reponse packet (6 bytes/48 bits).            
....................     //Additionally, if the SD card is MMC or SD card v1.x spec device, then it may respond with 
....................     //invalid command.  If it is a v2.0 spec SD card, then it is mandatory that the card respond 
....................     //to CMD8. 
....................     response = SendMediaSlowCmd(SEND_IF_COND, 0x1AA);   //Note: If changing "0x1AA", CRC value in table must also change. 
....................     if(((response.r7.bytewise.argument._returnVal & 0xFFF) == 0x1AA) && (!response.r7.bitwise.bits.ILLEGAL_CMD)) 
....................       { 
....................         //If we get to here, the device supported the CMD8 command and didn't complain about our host 
....................         //voltage range. 
....................         //Most likely this means it is either a v2.0 spec standard or high capacity SD card (SDHC) 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("Media successfully processed CMD8. Response = "); 
....................         PrintRAMBytesUART(((unsigned char*)&response + 1), 4); 
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................  
....................       //Send CMD58 (Read OCR [operating conditions register]).  Reponse type is R3, which has 5 bytes. 
....................       //Byte 4 = normal R1 response byte, Bytes 3-0 are = OCR register value. 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("Sending CMD58.\r\n"); 
....................         #endif 
....................         response = SendMediaSlowCmd(READ_OCR, 0x0); 
....................         //Now that we have the OCR register value in the reponse packet, we could parse 
....................         //the register contents and learn what voltage the SD card wants to run at. 
....................         //If our host circuitry has variable power supply capability, it could  
....................         //theoretically adjust the SD card Vdd to the minimum of the OCR to save power. 
....................        
....................       //Now send CMD55/ACMD41 in a loop, until the card is finished with its internal initialization. 
....................       //Note: SD card specs recommend >= 1 second timeout while waiting for ACMD41 to signal non-busy. 
....................       for(timeout = 0; timeout < 0xFFFF; timeout++) 
....................       {             
....................          //Send CMD55 (lets SD card know that the next command is application specific (going to be ACMD41)). 
....................          SendMediaSlowCmd(APP_CMD, 0x00000000); 
....................           
....................          //Send ACMD41.  This is to check if the SD card is finished booting up/ready for full frequency and all 
....................          //further commands.  Response is R3 type (6 bytes/48 bits, middle four bytes contain potentially useful data). 
....................             //Note: When sending ACMD41, the HCS bit is bit 30, and must be = 1 to tell SD card the host supports SDHC 
....................          response = SendMediaSlowCmd(SD_SEND_OP_COND,0x40000000); //bit 30 set 
....................           
....................          //The R1 response should be = 0x00, meaning the card is now in the "standby" state, instead of 
....................          //the "idle" state (which is the default initialization state after CMD0 reset is issued).  Once 
....................          //in the "standby" state, the SD card is finished with basic intitialization and is ready  
....................          //for read/write and other commands. 
....................          if(response.r1._byte == 0) 
....................          { 
....................               #ifdef __DEBUG_UART   
....................                 PrintROMASCIIStringUART("Media successfully processed CMD55/ACMD41 and is no longer busy.\r\n"); 
....................             #endif 
....................             break;  //Break out of for() loop.  Card is finished initializing. 
....................             }             
....................       }       
....................       if(timeout >= 0xFFFF) 
....................       { 
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("Media Timeout on CMD55/ACMD41.\r\n"); 
....................             #endif 
....................           mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE; 
....................         }             
....................        
....................        
....................         //Now send CMD58 (Read OCR register).  The OCR register contains important 
....................         //info we will want to know about the card (ex: standard capacity vs. SDHC). 
....................         response = SendMediaSlowCmd(READ_OCR, 0x0);  
....................  
....................       //Now check the CCS bit (OCR bit 30) in the OCR register, which is in our response packet. 
....................       //This will tell us if it is a SD high capacity (SDHC) or standard capacity device. 
....................       if(response.r7.bytewise.argument._returnVal & 0x40000000)    //Note the HCS bit is only valid when the busy bit is also set (indicating device ready). 
....................       { 
....................          gSDMode = SD_MODE_HC; 
....................           
....................           #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("Media successfully processed CMD58: SD card is SDHC v2.0 (or later) physical spec type.\r\n"); 
....................             #endif 
....................         }             
....................         else 
....................         { 
....................             gSDMode = SD_MODE_NORMAL; 
....................  
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("Media successfully processed CMD58: SD card is standard capacity v2.0 (or later) spec.\r\n"); 
....................             #endif 
....................         }  
....................         //SD Card should now be finished with initialization sequence.  Device should be ready 
....................         //for read/write commands. 
....................  
....................    }//if(((response.r7.bytewise._returnVal & 0xFFF) == 0x1AA) && (!response.r7.bitwise.bits.ILLEGAL_CMD)) 
....................     else 
....................    { 
....................         //The CMD8 wasn't supported.  This means the card is not a v2.0 card. 
....................         //Presumably the card is v1.x device, standard capacity (not SDHC). 
....................  
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("CMD8 Unsupported: Media is most likely MMC or SD 1.x device.\r\n"); 
....................         #endif 
....................  
....................  
....................         SD_CS = 1;                              // deselect the devices 
....................         Delayms(1); 
....................         SD_CS = 0;                              // select the device 
....................  
....................         //The CMD8 wasn't supported.  This means the card is definitely not a v2.0 SDHC card. 
....................         gSDMode = SD_MODE_NORMAL; 
....................        // According to the spec CMD1 must be repeated until the card is fully initialized 
....................        timeout = 0x1FFF; 
....................         do 
....................         { 
....................             //Send CMD1 to initialize the media. 
....................             response = SendMediaSlowCmd(SEND_OP_COND, 0x00000000);    //When argument is 0x00000000, this queries MMC cards for operating voltage range 
....................             timeout--; 
....................         }while((response.r1._byte != 0x00) && (timeout != 0)); 
....................         // see if it failed 
....................         if(timeout == 0) 
....................         { 
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("CMD1 failed.\r\n"); 
....................             #endif 
....................  
....................             mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE; 
....................             SD_CS = 1;                              // deselect the devices 
....................         } 
....................         else 
....................         { 
....................             #ifdef __DEBUG_UART   
....................             PrintROMASCIIStringUART("CMD1 Successfully processed, media is no longer busy.\r\n"); 
....................             #endif 
....................              
....................             //Set read/write block length to 512 bytes.  Note: commented out since 
....................             //this theoretically isn't necessary, since all cards v1 and v2 are  
....................             //required to support 512 byte block size, and this is supposed to be 
....................             //the default size selected on cards that support other sizes as well. 
....................             //response = SendMediaSlowCmd(SET_BLOCKLEN, 0x00000200);    //Set read/write block length to 512 bytes 
....................         } 
....................         
....................    } 
....................  
....................  
....................     //Temporarily deselect device 
....................     SD_CS = 1; 
....................      
....................     //Basic initialization of media is now complete.  The card will now use push/pull 
....................     //outputs with fast drivers.  Therefore, we can now increase SPI speed to  
....................     //either the maximum of the microcontroller or maximum of media, whichever  
....................     //is slower.  MMC media is typically good for at least 20Mbps SPI speeds.   
....................     //SD cards would typically operate at up to 25Mbps or higher SPI speeds. 
....................     OpenSPIM(SYNC_MODE_FAST); 
....................  
....................    SD_CS = 0; 
....................  
....................    /* Send the CMD9 to read the CSD register */ 
....................     timeout = NCR_TIMEOUT; 
....................     do 
....................     { 
....................         //Send CMD9: Read CSD data structure. 
....................       response = SendMMCCmd(SEND_CSD, 0x00); 
....................         timeout--; 
....................     }while((response.r1._byte != 0x00) && (timeout != 0)); 
....................     if(timeout != 0x00) 
....................     { 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("CMD9 Successfully processed: Read CSD register.\r\n"); 
....................         PrintROMASCIIStringUART("CMD9 response R1 byte = "); 
....................         PrintRAMBytesUART((unsigned char*)&response, 1);  
....................         UARTSendLineFeedCarriageReturn(); 
....................         #endif 
....................     }     
....................     else 
....................     { 
....................         //Media failed to respond to the read CSD register operation. 
....................         #ifdef __DEBUG_UART   
....................         PrintROMASCIIStringUART("Timeout occurred while processing CMD9 to read CSD register.\r\n"); 
....................         #endif 
....................          
....................         mediaInformation.errorCode = MEDIA_CANNOT_INITIALIZE; 
....................         SD_CS = 1; 
....................         return &mediaInformation; 
....................     }     
....................  
....................    /* According to the simplified spec, section 7.2.6, the card will respond 
....................    with a standard response token, followed by a data block of 16 bytes 
....................    suffixed with a 16-bit CRC.*/ 
....................    index = 0; 
....................    for (count = 0; count < 20u; count ++) 
....................    { 
....................       CSDResponse[index] = MDD_SDSPI_ReadMedia(); 
....................       index++;          
....................       /* Hopefully the first byte is the datatoken, however, some cards do 
....................       not send the response token before the CSD register.*/ 
....................       if((count == 0) && (CSDResponse[0] == DATA_START_TOKEN)) 
....................       { 
....................          /* As the first byte was the datatoken, we can drop it. */ 
....................          index = 0; 
....................       } 
....................    } 
....................  
....................     #ifdef __DEBUG_UART   
....................     PrintROMASCIIStringUART("CSD data structure contains: "); 
....................     PrintRAMBytesUART((unsigned char*)&CSDResponse, 20);  
....................     UARTSendLineFeedCarriageReturn(); 
....................     #endif 
....................      
....................  
....................  
....................    //Extract some fields from the response for computing the card capacity. 
....................    //Note: The structure format depends on if it is a CSD V1 or V2 device. 
....................    //Therefore, need to first determine version of the specs that the card  
....................    //is designed for, before interpreting the individual fields. 
....................  
....................    //------------------------------------------------------------- 
....................    //READ_BL_LEN: CSD Structure v1 cards always support 512 byte 
....................    //read and write block lengths.  Some v1 cards may optionally report 
....................    //READ_BL_LEN = 1024 or 2048 bytes (and therefore WRITE_BL_LEN also  
....................    //1024 or 2048).  However, even on these cards, 512 byte partial reads 
....................    //and 512 byte write are required to be supported. 
....................    //On CSD structure v2 cards, it is always required that READ_BL_LEN  
....................    //(and therefore WRITE_BL_LEN) be 512 bytes, and partial reads and 
....................    //writes are not allowed. 
....................    //Therefore, all cards support 512 byte reads/writes, but only a subset 
....................    //of cards support other sizes.  For best compatibility with all cards, 
....................    //and the simplest firmware design, it is therefore preferrable to  
....................    //simply ignore the READ_BL_LEN and WRITE_BL_LEN values altogether, 
....................    //and simply hardcode the read/write block size as 512 bytes. 
....................    //------------------------------------------------------------- 
....................    gMediaSectorSize = 512u; 
....................    //mediaInformation.sectorSize = gMediaSectorSize; 
....................    mediaInformation.sectorSize = 512u; 
....................    mediaInformation.validityFlags.bits.sectorSize = TRUE; 
....................    //------------------------------------------------------------- 
....................  
....................    //Calculate the MDD_SDSPI_finalLBA (see SD card physical layer simplified spec 2.0, section 5.3.2). 
....................    //In USB mass storage applications, we will need this information to  
....................    //correctly respond to SCSI get capacity requests.  Note: method of computing  
....................    //MDD_SDSPI_finalLBA depends on CSD structure spec version (either v1 or v2). 
....................    if(CSDResponse[0] & 0xC0)   //Check CSD_STRUCTURE field for v2+ struct device 
....................    { 
....................       //Must be a v2 device (or a reserved higher version, that doesn't currently exist) 
....................  
....................       //Extract the C_SIZE field from the response.  It is a 22-bit number in bit position 69:48.  This is different from v1.   
....................       //It spans bytes 7, 8, and 9 of the response. 
....................       c_size = (((DWORD)CSDResponse[7] & 0x3F) << 16) | ((WORD)CSDResponse[8] << 8) | CSDResponse[9]; 
....................        
....................       MDD_SDSPI_finalLBA = ((DWORD)(c_size + 1) * (WORD)(1024u)) - 1; //-1 on end is correction factor, since LBA = 0 is valid. 
....................    } 
....................    else //if(CSDResponse[0] & 0xC0)   //Check CSD_STRUCTURE field for v1 struct device 
....................    { 
....................       //Must be a v1 device. 
....................       //Extract the C_SIZE field from the response.  It is a 12-bit number in bit position 73:62.   
....................       //Although it is only a 12-bit number, it spans bytes 6, 7, and 8, since it isn't byte aligned. 
....................       c_size = ((DWORD)CSDResponse[6] << 16) | ((WORD)CSDResponse[7] << 8) | CSDResponse[8];   //Get the bytes in the correct positions 
....................       c_size &= 0x0003FFC0;   //Clear all bits that aren't part of the C_SIZE 
....................       c_size = c_size >> 6;   //Shift value down, so the 12-bit C_SIZE is properly right justified in the DWORD. 
....................        
....................       //Extract the C_SIZE_MULT field from the response.  It is a 3-bit number in bit position 49:47. 
....................       c_size_mult = ((WORD)((CSDResponse[9] & 0x03) << 1)) | ((WORD)((CSDResponse[10] & 0x80) >> 7)); 
....................  
....................         //Extract the BLOCK_LEN field from the response. It is a 4-bit number in bit position 83:80. 
....................         block_len = CSDResponse[5] & 0x0F; 
....................  
....................         block_len = 1 << (block_len - 9); //-9 because we report the size in sectors of 512 bytes each 
....................        
....................       //Calculate the MDD_SDSPI_finalLBA (see SD card physical layer simplified spec 2.0, section 5.3.2). 
....................       //In USB mass storage applications, we will need this information to  
....................       //correctly respond to SCSI get capacity requests (which will cause MDD_SDSPI_ReadCapacity() to get called). 
....................       MDD_SDSPI_finalLBA = ((DWORD)(c_size + 1) * (WORD)((WORD)1 << (c_size_mult + 2)) * block_len) - 1;   //-1 on end is correction factor, since LBA = 0 is valid.       
....................    }    
....................  
....................     //Turn off CRC7 if we can, might be an invalid cmd on some cards (CMD59) 
....................     //Note: POR default for the media is normally with CRC checking off in SPI  
....................     //mode anyway, so this is typically redundant. 
....................     SendMMCCmd(CRC_ON_OFF,0x0); 
....................  
....................     //Now set the block length to media sector size. It should be already set to this. 
....................     SendMMCCmd(SET_BLOCKLEN,gMediaSectorSize); 
....................  
....................     //Deselect media while not actively accessing the card. 
....................     SD_CS = 1; 
....................  
....................     #ifdef __DEBUG_UART   
....................     PrintROMASCIIStringUART("Returning from MediaInitialize() function.\r\n"); 
....................     #endif 
....................  
....................  
....................     return &mediaInformation; 
.................... }//end MediaInitialize 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "Instrumentation\humidity.c" 
....................  
....................  
.................... #define DATA 	PIN_B1  //This is not common with the CO2 sensor.  When the clock works for the temp/RH, then it receives informatio. 
.................... #define SCK 	PIN_B2 
....................  
.................... float    fRh_lin,fRh_true,fTemp_true,fDew_point; 
.................... //int8     counter; 
.................... long     lValue_rh,lValue_temp; 
.................... long	 lVal1,lVal2; 
....................  
.................... int RESET  = 0x1E; 
.................... int MEASURE_HUMI = 0x05; 
.................... int MEASURE_TEMP = 0x03; 
.................... float C1  = -4.0; 
.................... float T1  = 0.01; 
.................... float C2  = 0.0405; 
.................... float T2  = 0.00008; 
.................... float C3 = -0.0000028; 
....................  
....................  
....................  
....................  
.................... //BYTE buffer[0x20]; 
....................  
.................... //************************************************************************************** 
.................... // Added 12/31/2011 
.................... //  This reads the RH from the SHT11 Humidity & Temperature Sensor 
.................... //  This reads the temperature from the i2c SHT11 . 
.................... // This routine returns the T and RH in global variables. 
.................... //************************************************************************************** 
....................  
....................  
....................  
....................  
.................... //************************************************************************************** 
.................... // The SHT11 is set to 12bit mode.  
.................... // Formula for RH from the  chip. 
.................... // RH_linear = C1 + C2*SORH + C3*SORH^2 
.................... //  C1 = -4, C2 = 0.0405, C3 = -2.8X10^-6 
.................... // Compensation for Temperature 
.................... // RH_True = (T in C - 25)*(t1 + t2*SO_RH) + RH_linear 
.................... // t1 = 0.01, t2 = 0.00008 
.................... // 
.................... // Temperature formula from sensor 
.................... // Temperature = d1 + d2*SO_T 
.................... // d1 = -40.00, d2 = 0.04.  All temps are in degrees C 
.................... // 
.................... // Dewpoint Calculations 
.................... // See Data sheets.  Needs LOG math fucntion. 
.................... //************************************************************************************* 
....................  
....................  
....................  
....................  
.................... /*SHT11 Transmission Start Sequence*/ 
.................... void sht1x_xmission_start() 
.................... { 
.................... 	output_high(DATA); 
.................... 	output_low(SCK); 
.................... 	delay_us(2); 
....................  	output_high(SCK); 
.................... 	delay_us(2); 
.................... 	output_low(DATA); 
.................... 	delay_us(2); 
....................  	output_low(SCK); 
.................... 	delay_us(2); 
.................... 	delay_us(2); 
.................... 	delay_us(2); 
....................  	output_high(SCK); 
.................... 	delay_us(2); 
....................  	output_high(DATA); 
.................... 	delay_us(2); 
....................  	output_low(SCK); 
.................... 	delay_us(2); 
.................... } 
....................  
.................... /*SHT11 Connection Reset Sequence*/ 
.................... void sht11_connection_reset() 
.................... {  int i; 
....................  
....................    output_high(DATA); 
....................    for (i=0; i<9; i++) 
....................    {output_high(SCK); 
....................     delay_us(2); 
....................     output_low(SCK); 
....................     delay_us(2);} 
....................    sht1x_xmission_start();} 
....................  
.................... /*SHT11 Address & Command Mode with address=000*/ 
.................... void sht11_command_mode(int iMode) 
.................... { 
....................    int i; 
....................    for (i=128; i>0; i/=2) 
....................    {if (i & iMode) output_high(DATA); 
....................     else  output_low(DATA); 
....................           delay_us(2); 
....................           output_high(SCK); 
....................           delay_us(2); 
....................           output_low(SCK);} 
....................  
....................    output_float(DATA); 
....................    delay_us(2); 
....................    output_high(SCK); 
....................    delay_us(2); 
....................    output_low(SCK); 
....................     
....................    /*delay >55ms for 12-bit measurement*/ 
....................    /*delay >210ms for 14-bit measurement*/ 
....................    delay_ms(250);  /*250ms is chosen as delay time*/ 
.................... } 
....................  
.................... /*SHT11Soft Reset - resets the interface, clears the status register to default values*/ 
.................... /*wait minimum 11ms before next command*/ 
.................... void sht11_soft_reset() 
.................... { 
....................   sht11_connection_reset(); 
....................   sht11_command_mode(RESET); 
.................... } 
.................... // read data from SHT11 and store 
.................... long sht1x_read_data() 
.................... {  int i; 
....................    long lTmp,lValue; 
.................... 	lVal1=0; 
.................... 	lVal2=0; 
....................  
....................    for (i=0; i<8; i++)          /*get MSB from SHT11*/ 
....................    {lVal1<<=1; 
....................     output_high(SCK); 
....................     lTmp = input(DATA); 
....................     delay_us(2); 
....................     output_low(SCK); 
....................     delay_us(2); 
....................     if (lTmp) lVal1|=1;  
....................    }  
....................    output_low(DATA);   /*acknowledge routine*/ 
....................    delay_us(2); 
....................    output_high(SCK); 
....................    delay_us(2); 
....................    output_low(SCK); 
....................    output_float(DATA); 
....................    delay_us(2); 
....................  
....................    for (i=0; i<8; i++)          /*get LSB from SHT11*/ 
....................    {lVal2<<=1; 
....................     output_high(SCK); 
....................     lTmp = input(DATA); 
....................     delay_us(2); 
....................     output_low(SCK); 
....................     delay_us(2); 
....................     if (lTmp) lVal2|=1; 
....................    } 
....................    lValue = make16(lVal1,lVal2); 
....................    return(lValue); 
....................     } 
....................  
.................... // SHT1x Connection Reset Sequence 
.................... void sht1x_connection_reset() 
.................... {  int i; 
....................  
....................    output_high(DATA); 
....................    for (i=0; i<9; i++) 
....................     { 
.................... 	output_high(SCK); 
.................... 	delay_us(2); 
.................... 	output_low(SCK); 
.................... 	delay_us(2); 
.................... 	} 
....................     sht1x_xmission_start(); 
.................... } 
....................  
.................... // SHT1x Address & Command Mode with address=000 
.................... void sht1x_command_mode(int iMode) 
.................... {  int i; 
....................    for (i=128; i>0; i/=2) 
....................    {  if (i & iMode)  
.................... 		{ 
.................... 		output_high(DATA); 
.................... 		} 
....................       else   
.................... 		{ 
.................... 		output_low(DATA); 
.................... 		} 
....................       	delay_us(2);  
.................... 		output_high(SCK); 
....................       	delay_us(2);  
.................... 		output_low(SCK); 
....................    } 
....................    output_float(DATA);   
.................... 	delay_us(2); 
....................    output_high(SCK);     
.................... 	delay_us(2); 
....................    output_low(SCK);      
.................... 	delay_ms(400); 
.................... } 
....................  
....................  
.................... // read DATA_SHT from SHT1x and store 
.................... long sht1x_read_DATA_SHT() 
.................... {  int i; 
....................    long lTmp; 
....................    long lVal1=0; 
....................    long lVal2=0; 
....................    long lValue; 
....................    // get MSB from SHT1x 
....................    for (i=0; i<8; i++) 
....................    { 
....................       lVal1<<=1; 
....................       output_high(SCK); 
....................       lTmp = input(DATA); 
....................       delay_us(2); 
....................       output_low(SCK); 
....................       delay_us(2); 
....................       if (lTmp) lVal1|=1; 
....................    } 
....................    // acknowledge routine 
.................... output_low(DATA);  
.................... delay_us(2); 
.................... output_high(SCK);  
.................... delay_us(2); 
.................... output_low(SCK); 
.................... output_float(DATA); 
.................... delay_us(2); 
....................    // get LSB from SHT1x 
....................    for (i=0; i<8; i++) 
....................    { 
....................       lVal2<<=1; 
....................       output_high(SCK); 
....................       lTmp = input(DATA); 
....................       delay_us(2); 
....................       output_low(SCK); 
....................       delay_us(2); 
....................       if (lTmp) lVal2|=1; 
....................    } 
....................    lValue = make16(lVal1,lVal2); 
....................    return(lValue); 
.................... } 
....................  
.................... // calculate dewpoint 
.................... float sht1x_calc_dewpoint(float h,float t) 
*
0547E:  MOV     W5,[W15++]
05480:  MOV     W6,[W15++]
.................... { 
.................... float logEx,dew_point; 
05482:  MOV     #0,W4
05484:  MOV     W4,380A
05486:  MOV     #0,W4
05488:  MOV     W4,380C
0548A:  MOV     #0,W4
0548C:  MOV     W4,380E
0548E:  MOV     #0,W4
05490:  MOV     W4,3810
.................... logEx=-2+0.66077+((7.5*t)/(237.3+t))+log10(h); 
05492:  MOV     #0,W0
05494:  MOV     #40F0,W1
05496:  MOV     3806,W2
05498:  MOV     3808,W3
0549A:  CALL    46C6
0549E:  MOV     W0,W5
054A0:  MOV     W1,W6
054A2:  BCLR.B  43.0
054A4:  MOV     #4CCD,W0
054A6:  MOV     #436D,W1
054A8:  MOV     3806,W2
054AA:  MOV     3808,W3
054AC:  CALL    478A
054B0:  MOV     W0,W2
054B2:  MOV     W1,W3
054B4:  MOV     W5,W0
054B6:  MOV     W6,W1
054B8:  CALL    4530
054BC:  BCLR.B  43.0
054BE:  MOV     W0,W2
054C0:  MOV     W1,W3
054C2:  MOV     #6BE3,W0
054C4:  MOV     #BFAB,W1
054C6:  CALL    478A
054CA:  MOV     W0,W5
054CC:  MOV     W1,W6
054CE:  PUSH    3802
054D0:  POP     3820
054D2:  PUSH    3804
054D4:  POP     3822
054D6:  CALL    5458
054DA:  BCLR.B  43.0
054DC:  MOV     W0,W2
054DE:  MOV     W1,W3
054E0:  MOV     W5,W0
054E2:  MOV     W6,W1
054E4:  CALL    478A
054E8:  MOV     W0,380A
054EA:  MOV     W1,380C
.................... dew_point = (logEx - 0.66077)*237.3/(0.66077+7.5-logEx); 
054EC:  BSET.B  43.0
054EE:  MOV     380A,W0
054F0:  MOV     380C,W1
054F2:  MOV     #2839,W2
054F4:  MOV     #3F29,W3
054F6:  CALL    478A
054FA:  MOV     W0,W5
054FC:  MOV     W1,W6
054FE:  MOV     W5,W0
05500:  MOV     W6,W1
05502:  MOV     #4CCD,W2
05504:  MOV     #436D,W3
05506:  CALL    46C6
0550A:  MOV     W0,W5
0550C:  MOV     W1,W6
0550E:  BSET.B  43.0
05510:  MOV     #9284,W0
05512:  MOV     #4102,W1
05514:  MOV     380A,W2
05516:  MOV     380C,W3
05518:  CALL    478A
0551C:  MOV     W0,W2
0551E:  MOV     W1,W3
05520:  MOV     W5,W0
05522:  MOV     W6,W1
05524:  CALL    4530
05528:  MOV     W0,380E
0552A:  MOV     W1,3810
.................... return dew_point; 
0552C:  MOV     380E,W0
0552E:  MOV     3810,W1
05530:  MOV     [--W15],W6
05532:  MOV     [--W15],W5
05534:  RETURN  
.................... } 
....................  
....................  
....................  void read_sht11() 
.................... { 
.................... 	  sht1x_connection_reset(); 
....................       delay_ms(12); 
....................       sht1x_xmission_start(); 
....................       sht1x_command_mode(MEASURE_TEMP); 
....................       lValue_temp = sht1x_read_data(); 
....................  
.................... 	  fTemp_true = ((0.01*lValue_temp) - 40.0);  //This is the formala from the manual 
....................  
....................  
....................       delay_ms(12); 
....................  
....................       sht1x_xmission_start(); 
....................  
....................       sht1x_command_mode(MEASURE_HUMI); 
....................       lValue_rh = sht1x_read_data(); 
....................  
....................  
....................  	  if((lValue_temp==65535)||(lValue_rh==65535)) 
....................        {sht1x_connection_reset();} 
....................        else 
.................... 		{ 
.................... 	  delay_ms(12); 
....................  
.................... 	//  fRh_lin = ((0.0405*lValue_rh) - (0.0000028*lValue_rh*lValue_rh)- 4.0);  //This is the formala from the manual 	 
....................  
....................       fRh_lin = (C1+(C2*lValue_rh)+(C3*lValue_rh*lValue_rh)); 
....................       fRh_true = (((fTemp_true-25)*(T1+(T2*lValue_rh)))+fRh_lin); 
....................       fDew_point = sht1x_calc_dewpoint(fRh_true,fTemp_true); 
....................   
....................   }    
.................... } 
....................  
.................... #include "Instrumentation\TaosLightSensor.c" 
....................  
....................  
....................  
.................... #ifndef byte 
.................... #define byte int8 
.................... #endif 
.................... #define COLOR_SENSOR_ADDR  0x39//the I2C address for the color sensor  
.................... #define REG_CTL 0x80 
.................... #define REG_TIMING 0x81 
.................... #define REG_INT 0x82 
.................... #define REG_INT_SOURCE 0x83 
.................... #define REG_ID 0x84 
.................... #define REG_GAIN 0x87 
.................... #define REG_LOW_THRESH_LOW_BYTE 0x88 
.................... #define REG_LOW_THRESH_HIGH_BYTE 0x89 
.................... #define REG_HIGH_THRESH_LOW_BYTE 0x8A 
.................... #define REG_HIGH_THRESH_HIGH_BYTE 0x8B 
.................... #define REG_BLOCK_READ 0xCF 
.................... #define REG_GREEN_LOW 0xD0 
.................... #define REG_GREEN_HIGH 0xD1 
.................... #define REG_RED_LOW 0xD2 
.................... #define REG_RED_HIGH 0xD3 
.................... #define REG_BLUE_LOW 0xD4 
.................... #define REG_BLUE_HIGH 0xD5 
.................... #define REG_CLEAR_LOW 0xD6 
.................... #define REG_CLEAR_HIGH 0xD7 
.................... #define CTL_DAT_INIITIATE 0x03 
.................... #define CLR_INT 0xE0 
.................... //Timing Register 
.................... #define SYNC_EDGE 0x40 
.................... #define INTEG_MODE_FREE 0x00 
.................... #define INTEG_MODE_MANUAL 0x10 
.................... #define INTEG_MODE_SYN_SINGLE 0x20 
.................... #define INTEG_MODE_SYN_MULTI 0x30 
....................   
.................... #define INTEG_PARAM_PULSE_COUNT1 0x00 
.................... #define INTEG_PARAM_PULSE_COUNT2 0x01 
.................... #define INTEG_PARAM_PULSE_COUNT4 0x02 
.................... #define INTEG_PARAM_PULSE_COUNT8 0x03 
....................  
.................... #define GAIN_1 0x00 
.................... #define GAIN_4 0x10 
.................... #define GAIN_16 0x20 
.................... #define GANI_64 0x30 
.................... #define PRESCALER_1 0x00 
.................... #define PRESCALER_2 0x01 
.................... #define PRESCALER_4 0x02 
.................... #define PRESCALER_8 0x03 
.................... #define PRESCALER_16 0x04 
.................... #define PRESCALER_32 0x05 
.................... #define PRESCALER_64 0x06 
....................  
.................... int colorlow, colorhigh;   // gain, scale;  //This is the pair of bytes used to return the current selected color. 
.................... unsigned int16 red,green,blue,clear; 
.................... //int32 scaledred, scaledgreen, scaledblue;   // Added May 6, 2014  These are large number to hold the gain of the intensity 
....................  
.................... //************************************************************************************* 
.................... //Created March 4, 2015 
.................... // The Exposurescale is used for the preprocessor to scale down the ADC.  Each light sensor has a different scaling. 
.................... // Below is a table showing the values for each exposure scale down for the ADC. 
.................... //  000            Divide by 1 
.................... //  001            Divide by 2 
.................... //  010            Divide by 4 
.................... //  011            Divide by 8 
.................... //  100            Divide by 16 
.................... //  101            Divide by 32 
.................... //  110            Divide by 64 
.................... //  111            Does not exist and is not used. 
.................... //************************************************************************************ 
....................  
.................... byte ExposurescaleDO = 0;   //This is the global variable used for prescaler for the ADC 
.................... byte ExposurescalepH = 3;   //This is the global variable used for prescaler for the ADC  
.................... byte ExposurescaleLight = 2;   //This is the global variable used for prescaler for the ADC   Three is used to divide by 4 
.................... float x,y,z;  //Color chart positions,coored. 
....................  
.................... //************************************************************ 
.................... // Added December 1, 2014 
.................... // These varaibles will keep the last intensity 
.................... unsigned int16 PWMDOIntensity; 
.................... unsigned int16 PWMPHIntensity; 
.................... //************************************************************ 
.................... //Define the 3X4 matrix for solving three unknown equations. 
.................... float matx[3][3];  //This is the global diffinition of solving a 3X3 matrix equation. This is a scrach pad matrix used to pass arrays between functions. Added May 13, 2013 
.................... float matrixequation[3][3]; //  Added May 13, 2013  This is the array used for setting up the eqaution for solving a 3X3 equation. 
.................... float fourbyfourmatrix[4][4]; 
.................... float matrixequals[3];  
.................... // Added April 27, 2014   
.................... // Matrixequals is used for place the results of all three equations. 
.................... // This is used to subsitue into the 3X3 matrix for finding the DET. 
.................... float MatrixSolution[3];  
.................... // Added April 27, 2014  This matrix saves the 
.................... // result for the 3X3 unknown solution. 
.................... float TempCalmatrix[4][3];  //This matrix holds the temperatures and K1, K2 and Iohhh values. 
.................... float pk, slope;  //these are the varaibles used for ph calcualtions 
.................... //************************************************************** 
....................  
....................  
.................... //****************************************************************** 
.................... // Added Dec 8, 2014 
.................... // These varaibles are used for optical offsets for ph and DO. 
.................... //****************************************************************** 
.................... unsigned int32		AmbientOxyRed; 
.................... unsigned int32		AmbientOxyGreen; 
.................... unsigned int32		AmbientOxyBlue; 
.................... unsigned int32		AmbientOxyClear; 
.................... unsigned int32		AmbientPHRed; 
.................... unsigned int32		AmbientPHGreen; 
.................... unsigned int32		AmbientPHBlue;  
.................... unsigned int32		AmbientPHClear;  
....................  
....................  
.................... //************************************************************************ 
.................... //Added December 12, 2014 
.................... // These varaibles are used for each color absolute.  These numbers combined with the gain. 
.................... //  They are 32 bits long 
.................... //************************************************************************ 
.................... unsigned int32 redABS; 
.................... unsigned int32 blueABS; 
.................... unsigned int32 greenABS; 
.................... unsigned int32 clearABS; 
....................  
....................  
.................... //****************************************************************** 
.................... // K1 and K2 are two constans caluclated from calibration constants saved in EEPROM. 
.................... // The rest of the constants are used for calculating K1, K2 and Iohhh against temperature. 
.................... //  Added April 27, 2014 
.................... //****************************************************************** 
.................... float K1, K2; 
.................... float RatioI, RatioII, Iohhh; 
.................... float atwo, btwo, ctwo; 
....................  
.................... //****************************************************************** 
.................... //Created March 17, 2013 
.................... // This routine reads the all four inputs and returns the 16 bit value for that color. 
.................... // The value for color is as follows: 
.................... // 1:red 
.................... // 2:greem 
.................... // 3:blue 
.................... // 4:clear 
.................... // The retuened value is measured value. 
.................... //  This measurement is influnenced by the scalling factor for each ADC. 
.................... //  The two numbers are returned through tow global varibles. 
.................... //  The variables are colorlow and colorhigh. 
.................... // Added Oct 20, 2014 - Multi I2C lines can be used for each light sensor 
.................... // The value for light sensors is as follows: 
.................... // 1:PH 
.................... // 2:DO 
.................... // 3:General Light in the room 
.................... //****************************************************************** 
.................... void ReadColorTAOS(int selectedcolor, int lightsensor) 
.................... 	{ 
....................  
....................  
.................... if (lightsensor==2) 
*
055B4:  MOV     389C,W0
055B6:  CP      W0,#2
055B8:  BRA     NZ,5922
.................... 	{ 
.................... 	switch(selectedcolor) 
055BA:  MOV     389A,W0
055BC:  XOR     #2,W0
055BE:  BRA     Z,55CE
055C0:  XOR     #3,W0
055C2:  BRA     Z,56A2
055C4:  XOR     #2,W0
055C6:  BRA     Z,5776
055C8:  XOR     #7,W0
055CA:  BRA     Z,584A
055CC:  BRA     591E
.................... 		{ 
.................... 		case 2:   //green 
.................... 			i2c_start(PH_LIGHT); 
055CE:  BTSS.B  218.3
055D0:  BRA     55DA
055D2:  BSET.B  216.1
055D4:  BTSC.B  216.1
055D6:  BRA     55D4
055D8:  BRA     55E0
055DA:  BSET.B  216.0
055DC:  BTSC.B  216.0
055DE:  BRA     55DC
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
055E0:  MOV.B   #72,W1L
055E2:  CALL    2398
.................... 			i2c_write(PH_LIGHT,0x90);  //Send the command for reading the version 
055E6:  MOV.B   #90,W1L
055E8:  CALL    2398
.................... 			i2c_stop(PH_LIGHT); 
055EC:  MOV     #1F,W0
055EE:  AND     216,W0
055F0:  BRA     NZ,55EC
055F2:  BSET.B  216.2
055F4:  BTSC.B  216.2
055F6:  BRA     55F4
....................  
....................     		i2c_start(PH_LIGHT); 
055F8:  BTSS.B  218.3
055FA:  BRA     5604
055FC:  BSET.B  216.1
055FE:  BTSC.B  216.1
05600:  BRA     55FE
05602:  BRA     560A
05604:  BSET.B  216.0
05606:  BTSC.B  216.0
05608:  BRA     5606
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
0560A:  MOV.B   #73,W1L
0560C:  CALL    2398
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
05610:  MOV     #0,W1
05612:  MOV     W1,[W15++]
05614:  MOV     [--W15],W1
05616:  CALL    5536
0561A:  PUSH    2F6C
0561C:  MOV.B   W0L,[W15-#2]
0561E:  POP     2F6C
05620:  MOV     W0,[W15++]
05622:  MOV     2F6C,W0
05624:  CLR.B   1
05626:  MOV     W0,2F6C
05628:  MOV     [--W15],W0
.................... 			i2c_stop(PH_LIGHT); 
0562A:  MOV     #1F,W0
0562C:  AND     216,W0
0562E:  BRA     NZ,562A
05630:  BSET.B  216.2
05632:  BTSC.B  216.2
05634:  BRA     5632
....................  
.................... 			i2c_start(PH_LIGHT); 
05636:  BTSS.B  218.3
05638:  BRA     5642
0563A:  BSET.B  216.1
0563C:  BTSC.B  216.1
0563E:  BRA     563C
05640:  BRA     5648
05642:  BSET.B  216.0
05644:  BTSC.B  216.0
05646:  BRA     5644
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
05648:  MOV.B   #72,W1L
0564A:  CALL    2398
.................... 			i2c_write(PH_LIGHT,0x91);  //Send the command for reading the version 
0564E:  MOV.B   #91,W1L
05650:  CALL    2398
.................... 			i2c_stop(PH_LIGHT); 
05654:  MOV     #1F,W0
05656:  AND     216,W0
05658:  BRA     NZ,5654
0565A:  BSET.B  216.2
0565C:  BTSC.B  216.2
0565E:  BRA     565C
....................  
....................     		i2c_start(PH_LIGHT); 
05660:  BTSS.B  218.3
05662:  BRA     566C
05664:  BSET.B  216.1
05666:  BTSC.B  216.1
05668:  BRA     5666
0566A:  BRA     5672
0566C:  BSET.B  216.0
0566E:  BTSC.B  216.0
05670:  BRA     566E
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05672:  MOV.B   #73,W1L
05674:  CALL    2398
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
05678:  MOV     #0,W1
0567A:  MOV     W1,[W15++]
0567C:  MOV     [--W15],W1
0567E:  CALL    5536
05682:  PUSH    2F6E
05684:  MOV.B   W0L,[W15-#2]
05686:  POP     2F6E
05688:  MOV     W0,[W15++]
0568A:  MOV     2F6E,W0
0568C:  CLR.B   1
0568E:  MOV     W0,2F6E
05690:  MOV     [--W15],W0
.................... 			i2c_stop(PH_LIGHT); 
05692:  MOV     #1F,W0
05694:  AND     216,W0
05696:  BRA     NZ,5692
05698:  BSET.B  216.2
0569A:  BTSC.B  216.2
0569C:  BRA     569A
.................... 			break; 
0569E:  GOTO    5922
....................  
....................  
.................... 		case 1:   //red 
.................... 			i2c_start(PH_LIGHT); 
056A2:  BTSS.B  218.3
056A4:  BRA     56AE
056A6:  BSET.B  216.1
056A8:  BTSC.B  216.1
056AA:  BRA     56A8
056AC:  BRA     56B4
056AE:  BSET.B  216.0
056B0:  BTSC.B  216.0
056B2:  BRA     56B0
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
056B4:  MOV.B   #72,W1L
056B6:  CALL    2398
.................... 			i2c_write(PH_LIGHT,0x92);  //Send the command for reading the version 
056BA:  MOV.B   #92,W1L
056BC:  CALL    2398
.................... 			i2c_stop(PH_LIGHT); 
056C0:  MOV     #1F,W0
056C2:  AND     216,W0
056C4:  BRA     NZ,56C0
056C6:  BSET.B  216.2
056C8:  BTSC.B  216.2
056CA:  BRA     56C8
....................  
....................     		i2c_start(PH_LIGHT); 
056CC:  BTSS.B  218.3
056CE:  BRA     56D8
056D0:  BSET.B  216.1
056D2:  BTSC.B  216.1
056D4:  BRA     56D2
056D6:  BRA     56DE
056D8:  BSET.B  216.0
056DA:  BTSC.B  216.0
056DC:  BRA     56DA
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
056DE:  MOV.B   #73,W1L
056E0:  CALL    2398
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
056E4:  MOV     #0,W1
056E6:  MOV     W1,[W15++]
056E8:  MOV     [--W15],W1
056EA:  CALL    5536
056EE:  PUSH    2F6C
056F0:  MOV.B   W0L,[W15-#2]
056F2:  POP     2F6C
056F4:  MOV     W0,[W15++]
056F6:  MOV     2F6C,W0
056F8:  CLR.B   1
056FA:  MOV     W0,2F6C
056FC:  MOV     [--W15],W0
.................... 			i2c_stop(PH_LIGHT); 
056FE:  MOV     #1F,W0
05700:  AND     216,W0
05702:  BRA     NZ,56FE
05704:  BSET.B  216.2
05706:  BTSC.B  216.2
05708:  BRA     5706
....................  
.................... 			i2c_start(PH_LIGHT); 
0570A:  BTSS.B  218.3
0570C:  BRA     5716
0570E:  BSET.B  216.1
05710:  BTSC.B  216.1
05712:  BRA     5710
05714:  BRA     571C
05716:  BSET.B  216.0
05718:  BTSC.B  216.0
0571A:  BRA     5718
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
0571C:  MOV.B   #72,W1L
0571E:  CALL    2398
.................... 			i2c_write(PH_LIGHT,0x93);  //Send the command for reading the version 
05722:  MOV.B   #93,W1L
05724:  CALL    2398
.................... 			i2c_stop(PH_LIGHT); 
05728:  MOV     #1F,W0
0572A:  AND     216,W0
0572C:  BRA     NZ,5728
0572E:  BSET.B  216.2
05730:  BTSC.B  216.2
05732:  BRA     5730
....................  
....................     		i2c_start(PH_LIGHT); 
05734:  BTSS.B  218.3
05736:  BRA     5740
05738:  BSET.B  216.1
0573A:  BTSC.B  216.1
0573C:  BRA     573A
0573E:  BRA     5746
05740:  BSET.B  216.0
05742:  BTSC.B  216.0
05744:  BRA     5742
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05746:  MOV.B   #73,W1L
05748:  CALL    2398
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
0574C:  MOV     #0,W1
0574E:  MOV     W1,[W15++]
05750:  MOV     [--W15],W1
05752:  CALL    5536
05756:  PUSH    2F6E
05758:  MOV.B   W0L,[W15-#2]
0575A:  POP     2F6E
0575C:  MOV     W0,[W15++]
0575E:  MOV     2F6E,W0
05760:  CLR.B   1
05762:  MOV     W0,2F6E
05764:  MOV     [--W15],W0
.................... 			i2c_stop(PH_LIGHT); 
05766:  MOV     #1F,W0
05768:  AND     216,W0
0576A:  BRA     NZ,5766
0576C:  BSET.B  216.2
0576E:  BTSC.B  216.2
05770:  BRA     576E
.................... 			break; 
05772:  GOTO    5922
....................  
.................... 		case 3:   //blue 
.................... 			i2c_start(PH_LIGHT); 
05776:  BTSS.B  218.3
05778:  BRA     5782
0577A:  BSET.B  216.1
0577C:  BTSC.B  216.1
0577E:  BRA     577C
05780:  BRA     5788
05782:  BSET.B  216.0
05784:  BTSC.B  216.0
05786:  BRA     5784
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
05788:  MOV.B   #72,W1L
0578A:  CALL    2398
.................... 			i2c_write(PH_LIGHT,0x94);  //Send the command for reading the version 
0578E:  MOV.B   #94,W1L
05790:  CALL    2398
.................... 			i2c_stop(PH_LIGHT); 
05794:  MOV     #1F,W0
05796:  AND     216,W0
05798:  BRA     NZ,5794
0579A:  BSET.B  216.2
0579C:  BTSC.B  216.2
0579E:  BRA     579C
....................  
....................     		i2c_start(PH_LIGHT); 
057A0:  BTSS.B  218.3
057A2:  BRA     57AC
057A4:  BSET.B  216.1
057A6:  BTSC.B  216.1
057A8:  BRA     57A6
057AA:  BRA     57B2
057AC:  BSET.B  216.0
057AE:  BTSC.B  216.0
057B0:  BRA     57AE
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
057B2:  MOV.B   #73,W1L
057B4:  CALL    2398
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
057B8:  MOV     #0,W1
057BA:  MOV     W1,[W15++]
057BC:  MOV     [--W15],W1
057BE:  CALL    5536
057C2:  PUSH    2F6C
057C4:  MOV.B   W0L,[W15-#2]
057C6:  POP     2F6C
057C8:  MOV     W0,[W15++]
057CA:  MOV     2F6C,W0
057CC:  CLR.B   1
057CE:  MOV     W0,2F6C
057D0:  MOV     [--W15],W0
.................... 			i2c_stop(PH_LIGHT); 
057D2:  MOV     #1F,W0
057D4:  AND     216,W0
057D6:  BRA     NZ,57D2
057D8:  BSET.B  216.2
057DA:  BTSC.B  216.2
057DC:  BRA     57DA
....................  
.................... 			i2c_start(PH_LIGHT); 
057DE:  BTSS.B  218.3
057E0:  BRA     57EA
057E2:  BSET.B  216.1
057E4:  BTSC.B  216.1
057E6:  BRA     57E4
057E8:  BRA     57F0
057EA:  BSET.B  216.0
057EC:  BTSC.B  216.0
057EE:  BRA     57EC
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
057F0:  MOV.B   #72,W1L
057F2:  CALL    2398
.................... 			i2c_write(PH_LIGHT,0x95);  //Send the command for reading the version 
057F6:  MOV.B   #95,W1L
057F8:  CALL    2398
.................... 			i2c_stop(PH_LIGHT); 
057FC:  MOV     #1F,W0
057FE:  AND     216,W0
05800:  BRA     NZ,57FC
05802:  BSET.B  216.2
05804:  BTSC.B  216.2
05806:  BRA     5804
....................  
....................     		i2c_start(PH_LIGHT); 
05808:  BTSS.B  218.3
0580A:  BRA     5814
0580C:  BSET.B  216.1
0580E:  BTSC.B  216.1
05810:  BRA     580E
05812:  BRA     581A
05814:  BSET.B  216.0
05816:  BTSC.B  216.0
05818:  BRA     5816
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
0581A:  MOV.B   #73,W1L
0581C:  CALL    2398
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
05820:  MOV     #0,W1
05822:  MOV     W1,[W15++]
05824:  MOV     [--W15],W1
05826:  CALL    5536
0582A:  PUSH    2F6E
0582C:  MOV.B   W0L,[W15-#2]
0582E:  POP     2F6E
05830:  MOV     W0,[W15++]
05832:  MOV     2F6E,W0
05834:  CLR.B   1
05836:  MOV     W0,2F6E
05838:  MOV     [--W15],W0
.................... 			i2c_stop(PH_LIGHT); 
0583A:  MOV     #1F,W0
0583C:  AND     216,W0
0583E:  BRA     NZ,583A
05840:  BSET.B  216.2
05842:  BTSC.B  216.2
05844:  BRA     5842
.................... 			break; 
05846:  GOTO    5922
....................  
.................... 		case 4:   //clear 
.................... 			i2c_start(PH_LIGHT); 
0584A:  BTSS.B  218.3
0584C:  BRA     5856
0584E:  BSET.B  216.1
05850:  BTSC.B  216.1
05852:  BRA     5850
05854:  BRA     585C
05856:  BSET.B  216.0
05858:  BTSC.B  216.0
0585A:  BRA     5858
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
0585C:  MOV.B   #72,W1L
0585E:  CALL    2398
.................... 			i2c_write(PH_LIGHT,0x96);  //Send the command for reading the version 
05862:  MOV.B   #96,W1L
05864:  CALL    2398
.................... 			i2c_stop(PH_LIGHT); 
05868:  MOV     #1F,W0
0586A:  AND     216,W0
0586C:  BRA     NZ,5868
0586E:  BSET.B  216.2
05870:  BTSC.B  216.2
05872:  BRA     5870
....................  
....................     		i2c_start(PH_LIGHT); 
05874:  BTSS.B  218.3
05876:  BRA     5880
05878:  BSET.B  216.1
0587A:  BTSC.B  216.1
0587C:  BRA     587A
0587E:  BRA     5886
05880:  BSET.B  216.0
05882:  BTSC.B  216.0
05884:  BRA     5882
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05886:  MOV.B   #73,W1L
05888:  CALL    2398
.................... 			colorlow = i2c_read(PH_LIGHT,0); 
0588C:  MOV     #0,W1
0588E:  MOV     W1,[W15++]
05890:  MOV     [--W15],W1
05892:  CALL    5536
05896:  PUSH    2F6C
05898:  MOV.B   W0L,[W15-#2]
0589A:  POP     2F6C
0589C:  MOV     W0,[W15++]
0589E:  MOV     2F6C,W0
058A0:  CLR.B   1
058A2:  MOV     W0,2F6C
058A4:  MOV     [--W15],W0
.................... 			i2c_stop(PH_LIGHT); 
058A6:  MOV     #1F,W0
058A8:  AND     216,W0
058AA:  BRA     NZ,58A6
058AC:  BSET.B  216.2
058AE:  BTSC.B  216.2
058B0:  BRA     58AE
....................  
.................... 			i2c_start(PH_LIGHT); 
058B2:  BTSS.B  218.3
058B4:  BRA     58BE
058B6:  BSET.B  216.1
058B8:  BTSC.B  216.1
058BA:  BRA     58B8
058BC:  BRA     58C4
058BE:  BSET.B  216.0
058C0:  BTSC.B  216.0
058C2:  BRA     58C0
.................... 			i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
058C4:  MOV.B   #72,W1L
058C6:  CALL    2398
.................... 			i2c_write(PH_LIGHT,0x97);  //Send the command for reading the version 
058CA:  MOV.B   #97,W1L
058CC:  CALL    2398
.................... 			i2c_stop(PH_LIGHT); 
058D0:  MOV     #1F,W0
058D2:  AND     216,W0
058D4:  BRA     NZ,58D0
058D6:  BSET.B  216.2
058D8:  BTSC.B  216.2
058DA:  BRA     58D8
....................  
....................     		i2c_start(PH_LIGHT); 
058DC:  BTSS.B  218.3
058DE:  BRA     58E8
058E0:  BSET.B  216.1
058E2:  BTSC.B  216.1
058E4:  BRA     58E2
058E6:  BRA     58EE
058E8:  BSET.B  216.0
058EA:  BTSC.B  216.0
058EC:  BRA     58EA
.................... 			i2c_write(PH_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
058EE:  MOV.B   #73,W1L
058F0:  CALL    2398
.................... 			colorhigh = i2c_read(PH_LIGHT,0); 
058F4:  MOV     #0,W1
058F6:  MOV     W1,[W15++]
058F8:  MOV     [--W15],W1
058FA:  CALL    5536
058FE:  PUSH    2F6E
05900:  MOV.B   W0L,[W15-#2]
05902:  POP     2F6E
05904:  MOV     W0,[W15++]
05906:  MOV     2F6E,W0
05908:  CLR.B   1
0590A:  MOV     W0,2F6E
0590C:  MOV     [--W15],W0
.................... 			i2c_stop(PH_LIGHT); 
0590E:  MOV     #1F,W0
05910:  AND     216,W0
05912:  BRA     NZ,590E
05914:  BSET.B  216.2
05916:  BTSC.B  216.2
05918:  BRA     5916
.................... 			break; 
0591A:  GOTO    5922
....................  
.................... 		default:	 
.................... 			break; 
0591E:  GOTO    5922
.................... 		} 
.................... 	} 
....................  
....................  
.................... if (lightsensor==1) 
05922:  MOV     389C,W0
05924:  CP      W0,#1
05926:  BRA     NZ,5C90
.................... 	{ 
.................... 	switch(selectedcolor) 
05928:  MOV     389A,W0
0592A:  XOR     #2,W0
0592C:  BRA     Z,593C
0592E:  XOR     #3,W0
05930:  BRA     Z,5A10
05932:  XOR     #2,W0
05934:  BRA     Z,5AE4
05936:  XOR     #7,W0
05938:  BRA     Z,5BB8
0593A:  BRA     5C8C
.................... 		{ 
.................... 		case 2:   //green 
.................... 			i2c_start(DO_LIGHT); 
0593C:  BTSS.B  278.3
0593E:  BRA     5948
05940:  BSET.B  276.1
05942:  BTSC.B  276.1
05944:  BRA     5942
05946:  BRA     594E
05948:  BSET.B  276.0
0594A:  BTSC.B  276.0
0594C:  BRA     594A
.................... 			i2c_write(DO_LIGHT,0x72);  //Move the address number left on and add a zero. 
0594E:  MOV.B   #72,W1L
05950:  CALL    23B0
.................... 			i2c_write(DO_LIGHT,0x90);  //Send the command for reading the version 
05954:  MOV.B   #90,W1L
05956:  CALL    23B0
.................... 			i2c_stop(DO_LIGHT); 
0595A:  MOV     #1F,W0
0595C:  AND     276,W0
0595E:  BRA     NZ,595A
05960:  BSET.B  276.2
05962:  BTSC.B  276.2
05964:  BRA     5962
....................  
....................     		i2c_start(DO_LIGHT); 
05966:  BTSS.B  278.3
05968:  BRA     5972
0596A:  BSET.B  276.1
0596C:  BTSC.B  276.1
0596E:  BRA     596C
05970:  BRA     5978
05972:  BSET.B  276.0
05974:  BTSC.B  276.0
05976:  BRA     5974
.................... 			i2c_write(DO_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05978:  MOV.B   #73,W1L
0597A:  CALL    23B0
.................... 			colorlow = i2c_read(DO_LIGHT,0); 
0597E:  MOV     #0,W1
05980:  MOV     W1,[W15++]
05982:  MOV     [--W15],W1
05984:  CALL    5560
05988:  PUSH    2F6C
0598A:  MOV.B   W0L,[W15-#2]
0598C:  POP     2F6C
0598E:  MOV     W0,[W15++]
05990:  MOV     2F6C,W0
05992:  CLR.B   1
05994:  MOV     W0,2F6C
05996:  MOV     [--W15],W0
.................... 			i2c_stop(DO_LIGHT); 
05998:  MOV     #1F,W0
0599A:  AND     276,W0
0599C:  BRA     NZ,5998
0599E:  BSET.B  276.2
059A0:  BTSC.B  276.2
059A2:  BRA     59A0
....................  
.................... 			i2c_start(DO_LIGHT); 
059A4:  BTSS.B  278.3
059A6:  BRA     59B0
059A8:  BSET.B  276.1
059AA:  BTSC.B  276.1
059AC:  BRA     59AA
059AE:  BRA     59B6
059B0:  BSET.B  276.0
059B2:  BTSC.B  276.0
059B4:  BRA     59B2
.................... 			i2c_write(DO_LIGHT,0x72);  //Move the address number left on and add a zero. 
059B6:  MOV.B   #72,W1L
059B8:  CALL    23B0
.................... 			i2c_write(DO_LIGHT,0x91);  //Send the command for reading the version 
059BC:  MOV.B   #91,W1L
059BE:  CALL    23B0
.................... 			i2c_stop(DO_LIGHT); 
059C2:  MOV     #1F,W0
059C4:  AND     276,W0
059C6:  BRA     NZ,59C2
059C8:  BSET.B  276.2
059CA:  BTSC.B  276.2
059CC:  BRA     59CA
....................  
....................     		i2c_start(DO_LIGHT); 
059CE:  BTSS.B  278.3
059D0:  BRA     59DA
059D2:  BSET.B  276.1
059D4:  BTSC.B  276.1
059D6:  BRA     59D4
059D8:  BRA     59E0
059DA:  BSET.B  276.0
059DC:  BTSC.B  276.0
059DE:  BRA     59DC
.................... 			i2c_write(DO_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
059E0:  MOV.B   #73,W1L
059E2:  CALL    23B0
.................... 			colorhigh = i2c_read(DO_LIGHT,0); 
059E6:  MOV     #0,W1
059E8:  MOV     W1,[W15++]
059EA:  MOV     [--W15],W1
059EC:  CALL    5560
059F0:  PUSH    2F6E
059F2:  MOV.B   W0L,[W15-#2]
059F4:  POP     2F6E
059F6:  MOV     W0,[W15++]
059F8:  MOV     2F6E,W0
059FA:  CLR.B   1
059FC:  MOV     W0,2F6E
059FE:  MOV     [--W15],W0
.................... 			i2c_stop(DO_LIGHT); 
05A00:  MOV     #1F,W0
05A02:  AND     276,W0
05A04:  BRA     NZ,5A00
05A06:  BSET.B  276.2
05A08:  BTSC.B  276.2
05A0A:  BRA     5A08
.................... 			break; 
05A0C:  GOTO    5C90
....................  
....................  
.................... 		case 1:   //red 
.................... 			i2c_start(DO_LIGHT); 
05A10:  BTSS.B  278.3
05A12:  BRA     5A1C
05A14:  BSET.B  276.1
05A16:  BTSC.B  276.1
05A18:  BRA     5A16
05A1A:  BRA     5A22
05A1C:  BSET.B  276.0
05A1E:  BTSC.B  276.0
05A20:  BRA     5A1E
.................... 			i2c_write(DO_LIGHT,0x72);  //Move the address number left on and add a zero. 
05A22:  MOV.B   #72,W1L
05A24:  CALL    23B0
.................... 			i2c_write(DO_LIGHT,0x92);  //Send the command for reading the version 
05A28:  MOV.B   #92,W1L
05A2A:  CALL    23B0
.................... 			i2c_stop(DO_LIGHT); 
05A2E:  MOV     #1F,W0
05A30:  AND     276,W0
05A32:  BRA     NZ,5A2E
05A34:  BSET.B  276.2
05A36:  BTSC.B  276.2
05A38:  BRA     5A36
....................  
....................     		i2c_start(DO_LIGHT); 
05A3A:  BTSS.B  278.3
05A3C:  BRA     5A46
05A3E:  BSET.B  276.1
05A40:  BTSC.B  276.1
05A42:  BRA     5A40
05A44:  BRA     5A4C
05A46:  BSET.B  276.0
05A48:  BTSC.B  276.0
05A4A:  BRA     5A48
.................... 			i2c_write(DO_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05A4C:  MOV.B   #73,W1L
05A4E:  CALL    23B0
.................... 			colorlow = i2c_read(DO_LIGHT,0); 
05A52:  MOV     #0,W1
05A54:  MOV     W1,[W15++]
05A56:  MOV     [--W15],W1
05A58:  CALL    5560
05A5C:  PUSH    2F6C
05A5E:  MOV.B   W0L,[W15-#2]
05A60:  POP     2F6C
05A62:  MOV     W0,[W15++]
05A64:  MOV     2F6C,W0
05A66:  CLR.B   1
05A68:  MOV     W0,2F6C
05A6A:  MOV     [--W15],W0
.................... 			i2c_stop(DO_LIGHT); 
05A6C:  MOV     #1F,W0
05A6E:  AND     276,W0
05A70:  BRA     NZ,5A6C
05A72:  BSET.B  276.2
05A74:  BTSC.B  276.2
05A76:  BRA     5A74
....................  
.................... 			i2c_start(DO_LIGHT); 
05A78:  BTSS.B  278.3
05A7A:  BRA     5A84
05A7C:  BSET.B  276.1
05A7E:  BTSC.B  276.1
05A80:  BRA     5A7E
05A82:  BRA     5A8A
05A84:  BSET.B  276.0
05A86:  BTSC.B  276.0
05A88:  BRA     5A86
.................... 			i2c_write(DO_LIGHT,0x72);  //Move the address number left on and add a zero. 
05A8A:  MOV.B   #72,W1L
05A8C:  CALL    23B0
.................... 			i2c_write(DO_LIGHT,0x93);  //Send the command for reading the version 
05A90:  MOV.B   #93,W1L
05A92:  CALL    23B0
.................... 			i2c_stop(DO_LIGHT); 
05A96:  MOV     #1F,W0
05A98:  AND     276,W0
05A9A:  BRA     NZ,5A96
05A9C:  BSET.B  276.2
05A9E:  BTSC.B  276.2
05AA0:  BRA     5A9E
....................  
....................     		i2c_start(DO_LIGHT); 
05AA2:  BTSS.B  278.3
05AA4:  BRA     5AAE
05AA6:  BSET.B  276.1
05AA8:  BTSC.B  276.1
05AAA:  BRA     5AA8
05AAC:  BRA     5AB4
05AAE:  BSET.B  276.0
05AB0:  BTSC.B  276.0
05AB2:  BRA     5AB0
.................... 			i2c_write(DO_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05AB4:  MOV.B   #73,W1L
05AB6:  CALL    23B0
.................... 			colorhigh = i2c_read(DO_LIGHT,0); 
05ABA:  MOV     #0,W1
05ABC:  MOV     W1,[W15++]
05ABE:  MOV     [--W15],W1
05AC0:  CALL    5560
05AC4:  PUSH    2F6E
05AC6:  MOV.B   W0L,[W15-#2]
05AC8:  POP     2F6E
05ACA:  MOV     W0,[W15++]
05ACC:  MOV     2F6E,W0
05ACE:  CLR.B   1
05AD0:  MOV     W0,2F6E
05AD2:  MOV     [--W15],W0
.................... 			i2c_stop(DO_LIGHT); 
05AD4:  MOV     #1F,W0
05AD6:  AND     276,W0
05AD8:  BRA     NZ,5AD4
05ADA:  BSET.B  276.2
05ADC:  BTSC.B  276.2
05ADE:  BRA     5ADC
.................... 			break; 
05AE0:  GOTO    5C90
....................  
.................... 		case 3:   //blue 
.................... 			i2c_start(DO_LIGHT); 
05AE4:  BTSS.B  278.3
05AE6:  BRA     5AF0
05AE8:  BSET.B  276.1
05AEA:  BTSC.B  276.1
05AEC:  BRA     5AEA
05AEE:  BRA     5AF6
05AF0:  BSET.B  276.0
05AF2:  BTSC.B  276.0
05AF4:  BRA     5AF2
.................... 			i2c_write(DO_LIGHT,0x72);  //Move the address number left on and add a zero. 
05AF6:  MOV.B   #72,W1L
05AF8:  CALL    23B0
.................... 			i2c_write(DO_LIGHT,0x94);  //Send the command for reading the version 
05AFC:  MOV.B   #94,W1L
05AFE:  CALL    23B0
.................... 			i2c_stop(DO_LIGHT); 
05B02:  MOV     #1F,W0
05B04:  AND     276,W0
05B06:  BRA     NZ,5B02
05B08:  BSET.B  276.2
05B0A:  BTSC.B  276.2
05B0C:  BRA     5B0A
....................  
....................     		i2c_start(DO_LIGHT); 
05B0E:  BTSS.B  278.3
05B10:  BRA     5B1A
05B12:  BSET.B  276.1
05B14:  BTSC.B  276.1
05B16:  BRA     5B14
05B18:  BRA     5B20
05B1A:  BSET.B  276.0
05B1C:  BTSC.B  276.0
05B1E:  BRA     5B1C
.................... 			i2c_write(DO_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05B20:  MOV.B   #73,W1L
05B22:  CALL    23B0
.................... 			colorlow = i2c_read(DO_LIGHT,0); 
05B26:  MOV     #0,W1
05B28:  MOV     W1,[W15++]
05B2A:  MOV     [--W15],W1
05B2C:  CALL    5560
05B30:  PUSH    2F6C
05B32:  MOV.B   W0L,[W15-#2]
05B34:  POP     2F6C
05B36:  MOV     W0,[W15++]
05B38:  MOV     2F6C,W0
05B3A:  CLR.B   1
05B3C:  MOV     W0,2F6C
05B3E:  MOV     [--W15],W0
.................... 			i2c_stop(DO_LIGHT); 
05B40:  MOV     #1F,W0
05B42:  AND     276,W0
05B44:  BRA     NZ,5B40
05B46:  BSET.B  276.2
05B48:  BTSC.B  276.2
05B4A:  BRA     5B48
....................  
.................... 			i2c_start(DO_LIGHT); 
05B4C:  BTSS.B  278.3
05B4E:  BRA     5B58
05B50:  BSET.B  276.1
05B52:  BTSC.B  276.1
05B54:  BRA     5B52
05B56:  BRA     5B5E
05B58:  BSET.B  276.0
05B5A:  BTSC.B  276.0
05B5C:  BRA     5B5A
.................... 			i2c_write(DO_LIGHT,0x72);  //Move the address number left on and add a zero. 
05B5E:  MOV.B   #72,W1L
05B60:  CALL    23B0
.................... 			i2c_write(DO_LIGHT,0x95);  //Send the command for reading the version 
05B64:  MOV.B   #95,W1L
05B66:  CALL    23B0
.................... 			i2c_stop(DO_LIGHT); 
05B6A:  MOV     #1F,W0
05B6C:  AND     276,W0
05B6E:  BRA     NZ,5B6A
05B70:  BSET.B  276.2
05B72:  BTSC.B  276.2
05B74:  BRA     5B72
....................  
....................     		i2c_start(DO_LIGHT); 
05B76:  BTSS.B  278.3
05B78:  BRA     5B82
05B7A:  BSET.B  276.1
05B7C:  BTSC.B  276.1
05B7E:  BRA     5B7C
05B80:  BRA     5B88
05B82:  BSET.B  276.0
05B84:  BTSC.B  276.0
05B86:  BRA     5B84
.................... 			i2c_write(DO_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05B88:  MOV.B   #73,W1L
05B8A:  CALL    23B0
.................... 			colorhigh = i2c_read(DO_LIGHT,0); 
05B8E:  MOV     #0,W1
05B90:  MOV     W1,[W15++]
05B92:  MOV     [--W15],W1
05B94:  CALL    5560
05B98:  PUSH    2F6E
05B9A:  MOV.B   W0L,[W15-#2]
05B9C:  POP     2F6E
05B9E:  MOV     W0,[W15++]
05BA0:  MOV     2F6E,W0
05BA2:  CLR.B   1
05BA4:  MOV     W0,2F6E
05BA6:  MOV     [--W15],W0
.................... 			i2c_stop(DO_LIGHT); 
05BA8:  MOV     #1F,W0
05BAA:  AND     276,W0
05BAC:  BRA     NZ,5BA8
05BAE:  BSET.B  276.2
05BB0:  BTSC.B  276.2
05BB2:  BRA     5BB0
.................... 			break; 
05BB4:  GOTO    5C90
....................  
.................... 		case 4:   //clear 
.................... 			i2c_start(DO_LIGHT); 
05BB8:  BTSS.B  278.3
05BBA:  BRA     5BC4
05BBC:  BSET.B  276.1
05BBE:  BTSC.B  276.1
05BC0:  BRA     5BBE
05BC2:  BRA     5BCA
05BC4:  BSET.B  276.0
05BC6:  BTSC.B  276.0
05BC8:  BRA     5BC6
.................... 			i2c_write(DO_LIGHT,0x72);  //Move the address number left on and add a zero. 
05BCA:  MOV.B   #72,W1L
05BCC:  CALL    23B0
.................... 			i2c_write(DO_LIGHT,0x96);  //Send the command for reading the version 
05BD0:  MOV.B   #96,W1L
05BD2:  CALL    23B0
.................... 			i2c_stop(DO_LIGHT); 
05BD6:  MOV     #1F,W0
05BD8:  AND     276,W0
05BDA:  BRA     NZ,5BD6
05BDC:  BSET.B  276.2
05BDE:  BTSC.B  276.2
05BE0:  BRA     5BDE
....................  
....................     		i2c_start(DO_LIGHT); 
05BE2:  BTSS.B  278.3
05BE4:  BRA     5BEE
05BE6:  BSET.B  276.1
05BE8:  BTSC.B  276.1
05BEA:  BRA     5BE8
05BEC:  BRA     5BF4
05BEE:  BSET.B  276.0
05BF0:  BTSC.B  276.0
05BF2:  BRA     5BF0
.................... 			i2c_write(DO_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05BF4:  MOV.B   #73,W1L
05BF6:  CALL    23B0
.................... 			colorlow = i2c_read(DO_LIGHT,0); 
05BFA:  MOV     #0,W1
05BFC:  MOV     W1,[W15++]
05BFE:  MOV     [--W15],W1
05C00:  CALL    5560
05C04:  PUSH    2F6C
05C06:  MOV.B   W0L,[W15-#2]
05C08:  POP     2F6C
05C0A:  MOV     W0,[W15++]
05C0C:  MOV     2F6C,W0
05C0E:  CLR.B   1
05C10:  MOV     W0,2F6C
05C12:  MOV     [--W15],W0
.................... 			i2c_stop(DO_LIGHT); 
05C14:  MOV     #1F,W0
05C16:  AND     276,W0
05C18:  BRA     NZ,5C14
05C1A:  BSET.B  276.2
05C1C:  BTSC.B  276.2
05C1E:  BRA     5C1C
....................  
.................... 			i2c_start(DO_LIGHT); 
05C20:  BTSS.B  278.3
05C22:  BRA     5C2C
05C24:  BSET.B  276.1
05C26:  BTSC.B  276.1
05C28:  BRA     5C26
05C2A:  BRA     5C32
05C2C:  BSET.B  276.0
05C2E:  BTSC.B  276.0
05C30:  BRA     5C2E
.................... 			i2c_write(DO_LIGHT,0x72);  //Move the address number left on and add a zero. 
05C32:  MOV.B   #72,W1L
05C34:  CALL    23B0
.................... 			i2c_write(DO_LIGHT,0x97);  //Send the command for reading the version 
05C38:  MOV.B   #97,W1L
05C3A:  CALL    23B0
.................... 			i2c_stop(DO_LIGHT); 
05C3E:  MOV     #1F,W0
05C40:  AND     276,W0
05C42:  BRA     NZ,5C3E
05C44:  BSET.B  276.2
05C46:  BTSC.B  276.2
05C48:  BRA     5C46
....................  
....................     		i2c_start(DO_LIGHT); 
05C4A:  BTSS.B  278.3
05C4C:  BRA     5C56
05C4E:  BSET.B  276.1
05C50:  BTSC.B  276.1
05C52:  BRA     5C50
05C54:  BRA     5C5C
05C56:  BSET.B  276.0
05C58:  BTSC.B  276.0
05C5A:  BRA     5C58
.................... 			i2c_write(DO_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05C5C:  MOV.B   #73,W1L
05C5E:  CALL    23B0
.................... 			colorhigh = i2c_read(DO_LIGHT,0); 
05C62:  MOV     #0,W1
05C64:  MOV     W1,[W15++]
05C66:  MOV     [--W15],W1
05C68:  CALL    5560
05C6C:  PUSH    2F6E
05C6E:  MOV.B   W0L,[W15-#2]
05C70:  POP     2F6E
05C72:  MOV     W0,[W15++]
05C74:  MOV     2F6E,W0
05C76:  CLR.B   1
05C78:  MOV     W0,2F6E
05C7A:  MOV     [--W15],W0
.................... 			i2c_stop(DO_LIGHT); 
05C7C:  MOV     #1F,W0
05C7E:  AND     276,W0
05C80:  BRA     NZ,5C7C
05C82:  BSET.B  276.2
05C84:  BTSC.B  276.2
05C86:  BRA     5C84
.................... 			break; 
05C88:  GOTO    5C90
....................  
.................... 		default:	 
.................... 			break; 
05C8C:  GOTO    5C90
.................... 		} 
.................... 	} 
....................  
....................  
....................  
.................... if (lightsensor==3) 
05C90:  MOV     389C,W0
05C92:  CP      W0,#3
05C94:  BRA     NZ,5FFE
.................... 	{ 
.................... 	switch(selectedcolor) 
05C96:  MOV     389A,W0
05C98:  XOR     #2,W0
05C9A:  BRA     Z,5CAA
05C9C:  XOR     #3,W0
05C9E:  BRA     Z,5D7E
05CA0:  XOR     #2,W0
05CA2:  BRA     Z,5E52
05CA4:  XOR     #7,W0
05CA6:  BRA     Z,5F26
05CA8:  BRA     5FFA
.................... 		{ 
.................... 		case 2:   //green 
.................... 			i2c_start(ROOM_LIGHT); 
05CAA:  BTSS.B  208.3
05CAC:  BRA     5CB6
05CAE:  BSET.B  206.1
05CB0:  BTSC.B  206.1
05CB2:  BRA     5CB0
05CB4:  BRA     5CBC
05CB6:  BSET.B  206.0
05CB8:  BTSC.B  206.0
05CBA:  BRA     5CB8
.................... 			i2c_write(ROOM_LIGHT,0x72);  //Move the address number left on and add a zero. 
05CBC:  MOV.B   #72,W1L
05CBE:  CALL    23C8
.................... 			i2c_write(ROOM_LIGHT,0x90);  //Send the command for reading the version 
05CC2:  MOV.B   #90,W1L
05CC4:  CALL    23C8
.................... 			i2c_stop(ROOM_LIGHT); 
05CC8:  MOV     #1F,W0
05CCA:  AND     206,W0
05CCC:  BRA     NZ,5CC8
05CCE:  BSET.B  206.2
05CD0:  BTSC.B  206.2
05CD2:  BRA     5CD0
....................  
....................     		i2c_start(ROOM_LIGHT); 
05CD4:  BTSS.B  208.3
05CD6:  BRA     5CE0
05CD8:  BSET.B  206.1
05CDA:  BTSC.B  206.1
05CDC:  BRA     5CDA
05CDE:  BRA     5CE6
05CE0:  BSET.B  206.0
05CE2:  BTSC.B  206.0
05CE4:  BRA     5CE2
.................... 			i2c_write(ROOM_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05CE6:  MOV.B   #73,W1L
05CE8:  CALL    23C8
.................... 			colorlow = i2c_read(ROOM_LIGHT,0); 
05CEC:  MOV     #0,W1
05CEE:  MOV     W1,[W15++]
05CF0:  MOV     [--W15],W1
05CF2:  CALL    558A
05CF6:  PUSH    2F6C
05CF8:  MOV.B   W0L,[W15-#2]
05CFA:  POP     2F6C
05CFC:  MOV     W0,[W15++]
05CFE:  MOV     2F6C,W0
05D00:  CLR.B   1
05D02:  MOV     W0,2F6C
05D04:  MOV     [--W15],W0
.................... 			i2c_stop(ROOM_LIGHT); 
05D06:  MOV     #1F,W0
05D08:  AND     206,W0
05D0A:  BRA     NZ,5D06
05D0C:  BSET.B  206.2
05D0E:  BTSC.B  206.2
05D10:  BRA     5D0E
....................  
.................... 			i2c_start(ROOM_LIGHT); 
05D12:  BTSS.B  208.3
05D14:  BRA     5D1E
05D16:  BSET.B  206.1
05D18:  BTSC.B  206.1
05D1A:  BRA     5D18
05D1C:  BRA     5D24
05D1E:  BSET.B  206.0
05D20:  BTSC.B  206.0
05D22:  BRA     5D20
.................... 			i2c_write(ROOM_LIGHT,0x72);  //Move the address number left on and add a zero. 
05D24:  MOV.B   #72,W1L
05D26:  CALL    23C8
.................... 			i2c_write(ROOM_LIGHT,0x91);  //Send the command for reading the version 
05D2A:  MOV.B   #91,W1L
05D2C:  CALL    23C8
.................... 			i2c_stop(ROOM_LIGHT); 
05D30:  MOV     #1F,W0
05D32:  AND     206,W0
05D34:  BRA     NZ,5D30
05D36:  BSET.B  206.2
05D38:  BTSC.B  206.2
05D3A:  BRA     5D38
....................  
....................     		i2c_start(ROOM_LIGHT); 
05D3C:  BTSS.B  208.3
05D3E:  BRA     5D48
05D40:  BSET.B  206.1
05D42:  BTSC.B  206.1
05D44:  BRA     5D42
05D46:  BRA     5D4E
05D48:  BSET.B  206.0
05D4A:  BTSC.B  206.0
05D4C:  BRA     5D4A
.................... 			i2c_write(ROOM_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05D4E:  MOV.B   #73,W1L
05D50:  CALL    23C8
.................... 			colorhigh = i2c_read(ROOM_LIGHT,0); 
05D54:  MOV     #0,W1
05D56:  MOV     W1,[W15++]
05D58:  MOV     [--W15],W1
05D5A:  CALL    558A
05D5E:  PUSH    2F6E
05D60:  MOV.B   W0L,[W15-#2]
05D62:  POP     2F6E
05D64:  MOV     W0,[W15++]
05D66:  MOV     2F6E,W0
05D68:  CLR.B   1
05D6A:  MOV     W0,2F6E
05D6C:  MOV     [--W15],W0
.................... 			i2c_stop(ROOM_LIGHT); 
05D6E:  MOV     #1F,W0
05D70:  AND     206,W0
05D72:  BRA     NZ,5D6E
05D74:  BSET.B  206.2
05D76:  BTSC.B  206.2
05D78:  BRA     5D76
.................... 			break; 
05D7A:  GOTO    5FFE
....................  
....................  
.................... 		case 1:   //red 
.................... 			i2c_start(ROOM_LIGHT); 
05D7E:  BTSS.B  208.3
05D80:  BRA     5D8A
05D82:  BSET.B  206.1
05D84:  BTSC.B  206.1
05D86:  BRA     5D84
05D88:  BRA     5D90
05D8A:  BSET.B  206.0
05D8C:  BTSC.B  206.0
05D8E:  BRA     5D8C
.................... 			i2c_write(ROOM_LIGHT,0x72);  //Move the address number left on and add a zero. 
05D90:  MOV.B   #72,W1L
05D92:  CALL    23C8
.................... 			i2c_write(ROOM_LIGHT,0x92);  //Send the command for reading the version 
05D96:  MOV.B   #92,W1L
05D98:  CALL    23C8
.................... 			i2c_stop(ROOM_LIGHT); 
05D9C:  MOV     #1F,W0
05D9E:  AND     206,W0
05DA0:  BRA     NZ,5D9C
05DA2:  BSET.B  206.2
05DA4:  BTSC.B  206.2
05DA6:  BRA     5DA4
....................  
....................     		i2c_start(ROOM_LIGHT); 
05DA8:  BTSS.B  208.3
05DAA:  BRA     5DB4
05DAC:  BSET.B  206.1
05DAE:  BTSC.B  206.1
05DB0:  BRA     5DAE
05DB2:  BRA     5DBA
05DB4:  BSET.B  206.0
05DB6:  BTSC.B  206.0
05DB8:  BRA     5DB6
.................... 			i2c_write(ROOM_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05DBA:  MOV.B   #73,W1L
05DBC:  CALL    23C8
.................... 			colorlow = i2c_read(ROOM_LIGHT,0); 
05DC0:  MOV     #0,W1
05DC2:  MOV     W1,[W15++]
05DC4:  MOV     [--W15],W1
05DC6:  CALL    558A
05DCA:  PUSH    2F6C
05DCC:  MOV.B   W0L,[W15-#2]
05DCE:  POP     2F6C
05DD0:  MOV     W0,[W15++]
05DD2:  MOV     2F6C,W0
05DD4:  CLR.B   1
05DD6:  MOV     W0,2F6C
05DD8:  MOV     [--W15],W0
.................... 			i2c_stop(ROOM_LIGHT); 
05DDA:  MOV     #1F,W0
05DDC:  AND     206,W0
05DDE:  BRA     NZ,5DDA
05DE0:  BSET.B  206.2
05DE2:  BTSC.B  206.2
05DE4:  BRA     5DE2
....................  
.................... 			i2c_start(ROOM_LIGHT); 
05DE6:  BTSS.B  208.3
05DE8:  BRA     5DF2
05DEA:  BSET.B  206.1
05DEC:  BTSC.B  206.1
05DEE:  BRA     5DEC
05DF0:  BRA     5DF8
05DF2:  BSET.B  206.0
05DF4:  BTSC.B  206.0
05DF6:  BRA     5DF4
.................... 			i2c_write(ROOM_LIGHT,0x72);  //Move the address number left on and add a zero. 
05DF8:  MOV.B   #72,W1L
05DFA:  CALL    23C8
.................... 			i2c_write(ROOM_LIGHT,0x93);  //Send the command for reading the version 
05DFE:  MOV.B   #93,W1L
05E00:  CALL    23C8
.................... 			i2c_stop(ROOM_LIGHT); 
05E04:  MOV     #1F,W0
05E06:  AND     206,W0
05E08:  BRA     NZ,5E04
05E0A:  BSET.B  206.2
05E0C:  BTSC.B  206.2
05E0E:  BRA     5E0C
....................  
....................     		i2c_start(ROOM_LIGHT); 
05E10:  BTSS.B  208.3
05E12:  BRA     5E1C
05E14:  BSET.B  206.1
05E16:  BTSC.B  206.1
05E18:  BRA     5E16
05E1A:  BRA     5E22
05E1C:  BSET.B  206.0
05E1E:  BTSC.B  206.0
05E20:  BRA     5E1E
.................... 			i2c_write(ROOM_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05E22:  MOV.B   #73,W1L
05E24:  CALL    23C8
.................... 			colorhigh = i2c_read(ROOM_LIGHT,0); 
05E28:  MOV     #0,W1
05E2A:  MOV     W1,[W15++]
05E2C:  MOV     [--W15],W1
05E2E:  CALL    558A
05E32:  PUSH    2F6E
05E34:  MOV.B   W0L,[W15-#2]
05E36:  POP     2F6E
05E38:  MOV     W0,[W15++]
05E3A:  MOV     2F6E,W0
05E3C:  CLR.B   1
05E3E:  MOV     W0,2F6E
05E40:  MOV     [--W15],W0
.................... 			i2c_stop(ROOM_LIGHT); 
05E42:  MOV     #1F,W0
05E44:  AND     206,W0
05E46:  BRA     NZ,5E42
05E48:  BSET.B  206.2
05E4A:  BTSC.B  206.2
05E4C:  BRA     5E4A
.................... 			break; 
05E4E:  GOTO    5FFE
....................  
.................... 		case 3:   //blue 
.................... 			i2c_start(ROOM_LIGHT); 
05E52:  BTSS.B  208.3
05E54:  BRA     5E5E
05E56:  BSET.B  206.1
05E58:  BTSC.B  206.1
05E5A:  BRA     5E58
05E5C:  BRA     5E64
05E5E:  BSET.B  206.0
05E60:  BTSC.B  206.0
05E62:  BRA     5E60
.................... 			i2c_write(ROOM_LIGHT,0x72);  //Move the address number left on and add a zero. 
05E64:  MOV.B   #72,W1L
05E66:  CALL    23C8
.................... 			i2c_write(ROOM_LIGHT,0x94);  //Send the command for reading the version 
05E6A:  MOV.B   #94,W1L
05E6C:  CALL    23C8
.................... 			i2c_stop(ROOM_LIGHT); 
05E70:  MOV     #1F,W0
05E72:  AND     206,W0
05E74:  BRA     NZ,5E70
05E76:  BSET.B  206.2
05E78:  BTSC.B  206.2
05E7A:  BRA     5E78
....................  
....................     		i2c_start(ROOM_LIGHT); 
05E7C:  BTSS.B  208.3
05E7E:  BRA     5E88
05E80:  BSET.B  206.1
05E82:  BTSC.B  206.1
05E84:  BRA     5E82
05E86:  BRA     5E8E
05E88:  BSET.B  206.0
05E8A:  BTSC.B  206.0
05E8C:  BRA     5E8A
.................... 			i2c_write(ROOM_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05E8E:  MOV.B   #73,W1L
05E90:  CALL    23C8
.................... 			colorlow = i2c_read(ROOM_LIGHT,0); 
05E94:  MOV     #0,W1
05E96:  MOV     W1,[W15++]
05E98:  MOV     [--W15],W1
05E9A:  CALL    558A
05E9E:  PUSH    2F6C
05EA0:  MOV.B   W0L,[W15-#2]
05EA2:  POP     2F6C
05EA4:  MOV     W0,[W15++]
05EA6:  MOV     2F6C,W0
05EA8:  CLR.B   1
05EAA:  MOV     W0,2F6C
05EAC:  MOV     [--W15],W0
.................... 			i2c_stop(ROOM_LIGHT); 
05EAE:  MOV     #1F,W0
05EB0:  AND     206,W0
05EB2:  BRA     NZ,5EAE
05EB4:  BSET.B  206.2
05EB6:  BTSC.B  206.2
05EB8:  BRA     5EB6
....................  
.................... 			i2c_start(ROOM_LIGHT); 
05EBA:  BTSS.B  208.3
05EBC:  BRA     5EC6
05EBE:  BSET.B  206.1
05EC0:  BTSC.B  206.1
05EC2:  BRA     5EC0
05EC4:  BRA     5ECC
05EC6:  BSET.B  206.0
05EC8:  BTSC.B  206.0
05ECA:  BRA     5EC8
.................... 			i2c_write(ROOM_LIGHT,0x72);  //Move the address number left on and add a zero. 
05ECC:  MOV.B   #72,W1L
05ECE:  CALL    23C8
.................... 			i2c_write(ROOM_LIGHT,0x95);  //Send the command for reading the version 
05ED2:  MOV.B   #95,W1L
05ED4:  CALL    23C8
.................... 			i2c_stop(ROOM_LIGHT); 
05ED8:  MOV     #1F,W0
05EDA:  AND     206,W0
05EDC:  BRA     NZ,5ED8
05EDE:  BSET.B  206.2
05EE0:  BTSC.B  206.2
05EE2:  BRA     5EE0
....................  
....................     		i2c_start(ROOM_LIGHT); 
05EE4:  BTSS.B  208.3
05EE6:  BRA     5EF0
05EE8:  BSET.B  206.1
05EEA:  BTSC.B  206.1
05EEC:  BRA     5EEA
05EEE:  BRA     5EF6
05EF0:  BSET.B  206.0
05EF2:  BTSC.B  206.0
05EF4:  BRA     5EF2
.................... 			i2c_write(ROOM_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05EF6:  MOV.B   #73,W1L
05EF8:  CALL    23C8
.................... 			colorhigh = i2c_read(ROOM_LIGHT,0); 
05EFC:  MOV     #0,W1
05EFE:  MOV     W1,[W15++]
05F00:  MOV     [--W15],W1
05F02:  CALL    558A
05F06:  PUSH    2F6E
05F08:  MOV.B   W0L,[W15-#2]
05F0A:  POP     2F6E
05F0C:  MOV     W0,[W15++]
05F0E:  MOV     2F6E,W0
05F10:  CLR.B   1
05F12:  MOV     W0,2F6E
05F14:  MOV     [--W15],W0
.................... 			i2c_stop(ROOM_LIGHT); 
05F16:  MOV     #1F,W0
05F18:  AND     206,W0
05F1A:  BRA     NZ,5F16
05F1C:  BSET.B  206.2
05F1E:  BTSC.B  206.2
05F20:  BRA     5F1E
.................... 			break; 
05F22:  GOTO    5FFE
....................  
.................... 		case 4:   //clear 
.................... 			i2c_start(ROOM_LIGHT); 
05F26:  BTSS.B  208.3
05F28:  BRA     5F32
05F2A:  BSET.B  206.1
05F2C:  BTSC.B  206.1
05F2E:  BRA     5F2C
05F30:  BRA     5F38
05F32:  BSET.B  206.0
05F34:  BTSC.B  206.0
05F36:  BRA     5F34
.................... 			i2c_write(ROOM_LIGHT,0x72);  //Move the address number left on and add a zero. 
05F38:  MOV.B   #72,W1L
05F3A:  CALL    23C8
.................... 			i2c_write(ROOM_LIGHT,0x96);  //Send the command for reading the version 
05F3E:  MOV.B   #96,W1L
05F40:  CALL    23C8
.................... 			i2c_stop(ROOM_LIGHT); 
05F44:  MOV     #1F,W0
05F46:  AND     206,W0
05F48:  BRA     NZ,5F44
05F4A:  BSET.B  206.2
05F4C:  BTSC.B  206.2
05F4E:  BRA     5F4C
....................  
....................     		i2c_start(ROOM_LIGHT); 
05F50:  BTSS.B  208.3
05F52:  BRA     5F5C
05F54:  BSET.B  206.1
05F56:  BTSC.B  206.1
05F58:  BRA     5F56
05F5A:  BRA     5F62
05F5C:  BSET.B  206.0
05F5E:  BTSC.B  206.0
05F60:  BRA     5F5E
.................... 			i2c_write(ROOM_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05F62:  MOV.B   #73,W1L
05F64:  CALL    23C8
.................... 			colorlow = i2c_read(ROOM_LIGHT,0); 
05F68:  MOV     #0,W1
05F6A:  MOV     W1,[W15++]
05F6C:  MOV     [--W15],W1
05F6E:  CALL    558A
05F72:  PUSH    2F6C
05F74:  MOV.B   W0L,[W15-#2]
05F76:  POP     2F6C
05F78:  MOV     W0,[W15++]
05F7A:  MOV     2F6C,W0
05F7C:  CLR.B   1
05F7E:  MOV     W0,2F6C
05F80:  MOV     [--W15],W0
.................... 			i2c_stop(ROOM_LIGHT); 
05F82:  MOV     #1F,W0
05F84:  AND     206,W0
05F86:  BRA     NZ,5F82
05F88:  BSET.B  206.2
05F8A:  BTSC.B  206.2
05F8C:  BRA     5F8A
....................  
.................... 			i2c_start(ROOM_LIGHT); 
05F8E:  BTSS.B  208.3
05F90:  BRA     5F9A
05F92:  BSET.B  206.1
05F94:  BTSC.B  206.1
05F96:  BRA     5F94
05F98:  BRA     5FA0
05F9A:  BSET.B  206.0
05F9C:  BTSC.B  206.0
05F9E:  BRA     5F9C
.................... 			i2c_write(ROOM_LIGHT,0x72);  //Move the address number left on and add a zero. 
05FA0:  MOV.B   #72,W1L
05FA2:  CALL    23C8
.................... 			i2c_write(ROOM_LIGHT,0x97);  //Send the command for reading the version 
05FA6:  MOV.B   #97,W1L
05FA8:  CALL    23C8
.................... 			i2c_stop(ROOM_LIGHT); 
05FAC:  MOV     #1F,W0
05FAE:  AND     206,W0
05FB0:  BRA     NZ,5FAC
05FB2:  BSET.B  206.2
05FB4:  BTSC.B  206.2
05FB6:  BRA     5FB4
....................  
....................     		i2c_start(ROOM_LIGHT); 
05FB8:  BTSS.B  208.3
05FBA:  BRA     5FC4
05FBC:  BSET.B  206.1
05FBE:  BTSC.B  206.1
05FC0:  BRA     5FBE
05FC2:  BRA     5FCA
05FC4:  BSET.B  206.0
05FC6:  BTSC.B  206.0
05FC8:  BRA     5FC6
.................... 			i2c_write(ROOM_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
05FCA:  MOV.B   #73,W1L
05FCC:  CALL    23C8
.................... 			colorhigh = i2c_read(ROOM_LIGHT,0); 
05FD0:  MOV     #0,W1
05FD2:  MOV     W1,[W15++]
05FD4:  MOV     [--W15],W1
05FD6:  CALL    558A
05FDA:  PUSH    2F6E
05FDC:  MOV.B   W0L,[W15-#2]
05FDE:  POP     2F6E
05FE0:  MOV     W0,[W15++]
05FE2:  MOV     2F6E,W0
05FE4:  CLR.B   1
05FE6:  MOV     W0,2F6E
05FE8:  MOV     [--W15],W0
.................... 			i2c_stop(ROOM_LIGHT); 
05FEA:  MOV     #1F,W0
05FEC:  AND     206,W0
05FEE:  BRA     NZ,5FEA
05FF0:  BSET.B  206.2
05FF2:  BTSC.B  206.2
05FF4:  BRA     5FF2
.................... 			break; 
05FF6:  GOTO    5FFE
....................  
.................... 		default:	 
.................... 			break; 
05FFA:  GOTO    5FFE
.................... 		} 
.................... 	}   
05FFE:  RETURN  
....................  
.................... } 
....................  
....................  
.................... //******************************************************************** 
.................... // Created March 17, 2013 
.................... // This routine changes the gain/scaling routine for each color/ADC. 
.................... // The passed varaible is the gain for the ADC.  All colors get the same gain. 
.................... //  AnalogGain is a value between 0 to 3.   
.................... //  0 is 1X 
.................... //  1 is 4X 
.................... //  2 is 16X 
.................... //  3 is 64X 
.................... //Prescaler are values btween 0 and 6.  0 is div by 1; 6 is divide by 64. 
.................... // Added Oct 20, 2014 
.................... //  The lightsensor is added to select which sensor we want to use 
.................... // The value for light sensors is as follows: 
.................... // 1:PH 
.................... // 2:DO 
.................... // 3:General Light in the ROOM 
.................... //******************************************************************** 
.................... void setTAOSGain(byte AnalogGain, int lightsensor) 
*
023E0:  MOV     W5,[W15++]
.................... 	{ 
.................... byte controlword,PrescalerGain; 
023E2:  MOV     389A,W0
023E4:  CLR.B   1
023E6:  MOV     W0,389A
023E8:  MOV     389E,W0
023EA:  MOV.B   #0,W0L
023EC:  MOV     W0,389E
....................  
.................... controlword = 0; 
023EE:  MOV     389A,W0
023F0:  CLR.B   1
023F2:  MOV     W0,389A
....................  
....................  
.................... if (lightsensor==1) 
023F4:  MOV     389C,W0
023F6:  CP      W0,#1
023F8:  BRA     NZ,2402
.................... 	{ 
.................... 	PrescalerGain = ExposurescaleDO; 
023FA:  MOV     2F78,W0
023FC:  PUSH    389E
023FE:  MOV.B   W0L,[W15-#2]
02400:  POP     389E
.................... 	} 
....................  
.................... if (lightsensor==2) 
02402:  MOV     389C,W0
02404:  CP      W0,#2
02406:  BRA     NZ,2414
.................... 	{ 
.................... 	PrescalerGain = ExposurescalepH; 
02408:  PUSH    2F78
0240A:  MOV     [--W15],W0
0240C:  LSR     W0,#8,W0
0240E:  PUSH    389E
02410:  MOV.B   W0L,[W15-#2]
02412:  POP     389E
.................... 	} 
....................  
.................... if (lightsensor==3) 
02414:  MOV     389C,W0
02416:  CP      W0,#3
02418:  BRA     NZ,2422
.................... 	{ 
.................... 	PrescalerGain = ExposurescaleLight; 
0241A:  MOV     2F7A,W0
0241C:  PUSH    389E
0241E:  MOV.B   W0L,[W15-#2]
02420:  POP     389E
.................... 	} 
....................  
....................  
....................  
.................... if (AnalogGain > 3) 
02422:  MOV     389A,W0
02424:  SE      W0,W0
02426:  CP      W0,#3
02428:  BRA     LE,2430
.................... 	{ 
.................... 	AnalogGain = 3; 
0242A:  MOV     389A,W0
0242C:  MOV.B   #3,W0L
0242E:  MOV     W0,389A
.................... 	} 
....................  
.................... // Concatinate the control byte. 
.................... controlword = AnalogGain*16 + PrescalerGain;  //This is the offset for gain to placeinto the chip.  Added March 4, 2015 
02430:  MOV     389A,W0
02432:  SE      W0,W0
02434:  MOV     W0,W4
02436:  MUL.UU  W4,#10,W0
02438:  MOV     W0,W5
0243A:  MOV     389E,W0
0243C:  SE      W0,W0
0243E:  ADD     W0,W5,W0
02440:  PUSH    389A
02442:  MOV.B   W0L,[W15-#1]
02444:  POP     389A
....................  
.................... if (lightsensor==2) 
02446:  MOV     389C,W0
02448:  CP      W0,#2
0244A:  BRA     NZ,2480
.................... 	{ 
.................... 	i2c_start(PH_LIGHT); 
0244C:  BTSS.B  218.3
0244E:  BRA     2458
02450:  BSET.B  216.1
02452:  BTSC.B  216.1
02454:  BRA     2452
02456:  BRA     245E
02458:  BSET.B  216.0
0245A:  BTSC.B  216.0
0245C:  BRA     245A
.................... 	i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
0245E:  MOV.B   #72,W1L
02460:  CALL    2398
.................... 	i2c_write(PH_LIGHT,0x87);  //The 0x80 is used to tell it's a command.  This is for register 0x07. 
02464:  MOV.B   #87,W1L
02466:  CALL    2398
.................... 	i2c_write(PH_LIGHT,controlword);  //Move the address number left on and add a zero. 
0246A:  PUSH    389A
0246C:  MOV     [--W15],W1
0246E:  LSR     W1,#8,W1
02470:  CALL    2398
.................... 	i2c_stop(PH_LIGHT); 
02474:  MOV     #1F,W0
02476:  AND     216,W0
02478:  BRA     NZ,2474
0247A:  BSET.B  216.2
0247C:  BTSC.B  216.2
0247E:  BRA     247C
.................... 	} 
....................  
.................... if (lightsensor==1) 
02480:  MOV     389C,W0
02482:  CP      W0,#1
02484:  BRA     NZ,24BA
.................... 	{ 
.................... 	i2c_start(DO_LIGHT); 
02486:  BTSS.B  278.3
02488:  BRA     2492
0248A:  BSET.B  276.1
0248C:  BTSC.B  276.1
0248E:  BRA     248C
02490:  BRA     2498
02492:  BSET.B  276.0
02494:  BTSC.B  276.0
02496:  BRA     2494
.................... 	i2c_write(DO_LIGHT,0x72);  //Move the address number left on and add a zero. 
02498:  MOV.B   #72,W1L
0249A:  CALL    23B0
.................... 	i2c_write(DO_LIGHT,0x87);  //The 0x80 is used to tell it's a command.  This is for register 0x07. 
0249E:  MOV.B   #87,W1L
024A0:  CALL    23B0
.................... 	i2c_write(DO_LIGHT,controlword);  //Move the address number left on and add a zero. 
024A4:  PUSH    389A
024A6:  MOV     [--W15],W1
024A8:  LSR     W1,#8,W1
024AA:  CALL    23B0
.................... 	i2c_stop(DO_LIGHT); 
024AE:  MOV     #1F,W0
024B0:  AND     276,W0
024B2:  BRA     NZ,24AE
024B4:  BSET.B  276.2
024B6:  BTSC.B  276.2
024B8:  BRA     24B6
.................... 	} 
....................  
.................... if (lightsensor==3) 
024BA:  MOV     389C,W0
024BC:  CP      W0,#3
024BE:  BRA     NZ,24F4
.................... 	{ 
.................... 	i2c_start(ROOM_LIGHT); 
024C0:  BTSS.B  208.3
024C2:  BRA     24CC
024C4:  BSET.B  206.1
024C6:  BTSC.B  206.1
024C8:  BRA     24C6
024CA:  BRA     24D2
024CC:  BSET.B  206.0
024CE:  BTSC.B  206.0
024D0:  BRA     24CE
.................... 	i2c_write(ROOM_LIGHT,0x72);  //Move the address number left on and add a zero. 
024D2:  MOV.B   #72,W1L
024D4:  CALL    23C8
.................... 	i2c_write(ROOM_LIGHT,0x87);  //The 0x80 is used to tell it's a command.  This is for register 0x07. 
024D8:  MOV.B   #87,W1L
024DA:  CALL    23C8
.................... 	i2c_write(ROOM_LIGHT,controlword);  //Move the address number left on and add a zero. 
024DE:  PUSH    389A
024E0:  MOV     [--W15],W1
024E2:  LSR     W1,#8,W1
024E4:  CALL    23C8
.................... 	i2c_stop(ROOM_LIGHT); 
024E8:  MOV     #1F,W0
024EA:  AND     206,W0
024EC:  BRA     NZ,24E8
024EE:  BSET.B  206.2
024F0:  BTSC.B  206.2
024F2:  BRA     24F0
.................... 	} 
024F4:  MOV     [--W15],W5
024F6:  RETURN  
....................  
.................... // That's it. 
.................... 	} 
....................  
....................  
.................... //******************************************************************** 
.................... // Created March 19, 2013 
.................... // Get the version of the device.  This  routine is used for testing I2C. 
.................... // Command 0x04 
.................... // This routine returns the version of the light chip.  
.................... //********************************************************************* 
.................... int getTAOSVersion(int lightsensor) 
.................... 	{ 
.................... int8 version; 
.................... 	i2c_start(DO_LIGHT); 
.................... 	i2c_write(DO_LIGHT,0x72);  //Move the address number left on and add a zero. 
.................... 	i2c_write(DO_LIGHT,0x84);  //Send the command for reading the version 
.................... 	i2c_stop(DO_LIGHT); 
....................     i2c_start(DO_LIGHT,0); 
.................... 	i2c_write(DO_LIGHT,0x73);  //Move the address number left on and add a one to make is a read command. 
.................... 	version = i2c_read(DO_LIGHT,0); 
.................... 	i2c_stop(DO_LIGHT); 
....................  
.................... 	return(version); 
.................... 	} 
....................  
.................... //********************************************************************** 
.................... // Created March 19, 2013 
.................... // Power up light chip 
.................... // The value for light sensors is as follows: 
.................... // 1:PH 
.................... // 2:DO 
.................... // 3:General Light in the room 
.................... //********************************************************************** 
.................... void StartUpTAOS(int lightsensor) 
.................... 	{ 
....................  
.................... if (lightsensor==2) 
*
025AE:  MOV     389A,W0
025B0:  CP      W0,#2
025B2:  BRA     NZ,25E4
.................... 	{ 
.................... 	i2c_start(PH_LIGHT); 
025B4:  BTSS.B  218.3
025B6:  BRA     25C0
025B8:  BSET.B  216.1
025BA:  BTSC.B  216.1
025BC:  BRA     25BA
025BE:  BRA     25C6
025C0:  BSET.B  216.0
025C2:  BTSC.B  216.0
025C4:  BRA     25C2
.................... 	i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
025C6:  MOV.B   #72,W1L
025C8:  CALL    2398
.................... 	i2c_write(PH_LIGHT,0x80);  //Send the command for reading the version 
025CC:  MOV.B   #80,W1L
025CE:  CALL    2398
.................... 	i2c_write(PH_LIGHT,0x03);  //Send the command for reading the version 
025D2:  MOV.B   #3,W1L
025D4:  CALL    2398
.................... 	i2c_stop(PH_LIGHT); 
025D8:  MOV     #1F,W0
025DA:  AND     216,W0
025DC:  BRA     NZ,25D8
025DE:  BSET.B  216.2
025E0:  BTSC.B  216.2
025E2:  BRA     25E0
.................... 	} 
....................  
.................... if (lightsensor==1) 
025E4:  MOV     389A,W0
025E6:  CP      W0,#1
025E8:  BRA     NZ,261A
.................... 	{ 
.................... 	i2c_start(DO_LIGHT); 
025EA:  BTSS.B  278.3
025EC:  BRA     25F6
025EE:  BSET.B  276.1
025F0:  BTSC.B  276.1
025F2:  BRA     25F0
025F4:  BRA     25FC
025F6:  BSET.B  276.0
025F8:  BTSC.B  276.0
025FA:  BRA     25F8
.................... 	i2c_write(DO_LIGHT,0x72);  //Move the address number left on and add a zero. 
025FC:  MOV.B   #72,W1L
025FE:  CALL    23B0
.................... 	i2c_write(DO_LIGHT,0x80);  //Send the command for reading the version 
02602:  MOV.B   #80,W1L
02604:  CALL    23B0
.................... 	i2c_write(DO_LIGHT,0x03);  //Send the command for reading the version 
02608:  MOV.B   #3,W1L
0260A:  CALL    23B0
.................... 	i2c_stop(DO_LIGHT); 
0260E:  MOV     #1F,W0
02610:  AND     276,W0
02612:  BRA     NZ,260E
02614:  BSET.B  276.2
02616:  BTSC.B  276.2
02618:  BRA     2616
.................... 	} 
....................  
.................... if (lightsensor==3) 
0261A:  MOV     389A,W0
0261C:  CP      W0,#3
0261E:  BRA     NZ,2650
.................... 	{ 
.................... 	i2c_start(ROOM_LIGHT); 
02620:  BTSS.B  208.3
02622:  BRA     262C
02624:  BSET.B  206.1
02626:  BTSC.B  206.1
02628:  BRA     2626
0262A:  BRA     2632
0262C:  BSET.B  206.0
0262E:  BTSC.B  206.0
02630:  BRA     262E
.................... 	i2c_write(ROOM_LIGHT,0x72);  //Move the address number left on and add a zero. 
02632:  MOV.B   #72,W1L
02634:  CALL    23C8
.................... 	i2c_write(ROOM_LIGHT,0x80);  //Send the command for reading the version 
02638:  MOV.B   #80,W1L
0263A:  CALL    23C8
.................... 	i2c_write(ROOM_LIGHT,0x03);  //Send the command for reading the version 
0263E:  MOV.B   #3,W1L
02640:  CALL    23C8
.................... 	i2c_stop(ROOM_LIGHT); 
02644:  MOV     #1F,W0
02646:  AND     206,W0
02648:  BRA     NZ,2644
0264A:  BSET.B  206.2
0264C:  BTSC.B  206.2
0264E:  BRA     264C
.................... 	} 
02650:  RETURN  
....................  
.................... 	} 
....................  
....................  
.................... //*********************************************************************** 
.................... // Created March 20, 2013 
.................... // This routine changes the exposure time for each sample. 
.................... //  There are three modes of intigration or exposure time per sample. 
.................... // 0 for 12ms 
.................... // 1 for 100 ms 
.................... // 2 for 400 ms 
.................... // The value for light sensors is as follows: 
.................... // 1:PH 
.................... // 2:DO 
.................... // 3:General Light in the room 
.................... //*********************************************************************** 
.................... void ExposureTimeTAOS(byte integration, byte lightsensor) 
.................... 	{ 
....................  
....................  
.................... if (lightsensor==1) 
*
024F8:  PUSH    3804
024FA:  MOV     [--W15],W0
024FC:  LSR     W0,#8,W0
024FE:  SE      W0,W0
02500:  CP      W0,#1
02502:  BRA     NZ,2534
.................... 	{ 
.................... 	i2c_start(PH_LIGHT); 
02504:  BTSS.B  218.3
02506:  BRA     2510
02508:  BSET.B  216.1
0250A:  BTSC.B  216.1
0250C:  BRA     250A
0250E:  BRA     2516
02510:  BSET.B  216.0
02512:  BTSC.B  216.0
02514:  BRA     2512
.................... 	i2c_write(PH_LIGHT,0x72);  //Move the address number left on and add a zero. 
02516:  MOV.B   #72,W1L
02518:  CALL    2398
.................... 	i2c_write(PH_LIGHT,0x81);  //Send the command for reading the Timeing Register 
0251C:  MOV.B   #81,W1L
0251E:  CALL    2398
.................... 	i2c_write(PH_LIGHT,integration);  //Send the command for reading the version 
02522:  MOV     3804,W1
02524:  CALL    2398
.................... 	i2c_stop(PH_LIGHT); 
02528:  MOV     #1F,W0
0252A:  AND     216,W0
0252C:  BRA     NZ,2528
0252E:  BSET.B  216.2
02530:  BTSC.B  216.2
02532:  BRA     2530
.................... 	} 
....................  
.................... if (lightsensor==2) 
02534:  PUSH    3804
02536:  MOV     [--W15],W0
02538:  LSR     W0,#8,W0
0253A:  SE      W0,W0
0253C:  CP      W0,#2
0253E:  BRA     NZ,2570
.................... 	{ 
.................... 	i2c_start(DO_LIGHT); 
02540:  BTSS.B  278.3
02542:  BRA     254C
02544:  BSET.B  276.1
02546:  BTSC.B  276.1
02548:  BRA     2546
0254A:  BRA     2552
0254C:  BSET.B  276.0
0254E:  BTSC.B  276.0
02550:  BRA     254E
.................... 	i2c_write(DO_LIGHT,0x72);  //Move the address number left on and add a zero. 
02552:  MOV.B   #72,W1L
02554:  CALL    23B0
.................... 	i2c_write(DO_LIGHT,0x81);  //Send the command for reading the Timeing Register 
02558:  MOV.B   #81,W1L
0255A:  CALL    23B0
.................... 	i2c_write(DO_LIGHT,integration);  //Send the command for reading the version 
0255E:  MOV     3804,W1
02560:  CALL    23B0
.................... 	i2c_stop(DO_LIGHT); 
02564:  MOV     #1F,W0
02566:  AND     276,W0
02568:  BRA     NZ,2564
0256A:  BSET.B  276.2
0256C:  BTSC.B  276.2
0256E:  BRA     256C
.................... 	} 
.................... if (lightsensor==3) 
02570:  PUSH    3804
02572:  MOV     [--W15],W0
02574:  LSR     W0,#8,W0
02576:  SE      W0,W0
02578:  CP      W0,#3
0257A:  BRA     NZ,25AC
.................... 	{ 
.................... 	i2c_start(ROOM_LIGHT); 
0257C:  BTSS.B  208.3
0257E:  BRA     2588
02580:  BSET.B  206.1
02582:  BTSC.B  206.1
02584:  BRA     2582
02586:  BRA     258E
02588:  BSET.B  206.0
0258A:  BTSC.B  206.0
0258C:  BRA     258A
.................... 	i2c_write(ROOM_LIGHT,0x72);  //Move the address number left on and add a zero. 
0258E:  MOV.B   #72,W1L
02590:  CALL    23C8
.................... 	i2c_write(ROOM_LIGHT,0x81);  //Send the command for reading the Timeing Register 
02594:  MOV.B   #81,W1L
02596:  CALL    23C8
.................... 	i2c_write(ROOM_LIGHT,integration);  //Send the command for reading the version 
0259A:  MOV     3804,W1
0259C:  CALL    23C8
.................... 	i2c_stop(ROOM_LIGHT); 
025A0:  MOV     #1F,W0
025A2:  AND     206,W0
025A4:  BRA     NZ,25A0
025A6:  BSET.B  206.2
025A8:  BTSC.B  206.2
025AA:  BRA     25A8
.................... 	} 
025AC:  RETURN  
.................... 	}  
....................  
.................... //************************************************************************ 
.................... // Created March 24, 2013 
.................... // Returns the color of all three colors and points to the color on the chart. 
.................... //************************************************************************ 
.................... void calculateCoordinate(void) 
*
065D2:  MOV     W5,[W15++]
065D4:  MOV     W6,[W15++]
.................... { 
....................  
.................... float redABSfloat,greenABSfloat,blueABSfloat; 
065D6:  MOV     #0,W4
065D8:  MOV     W4,38C2
065DA:  MOV     #0,W4
065DC:  MOV     W4,38C4
065DE:  MOV     #0,W4
065E0:  MOV     W4,38C6
065E2:  MOV     #0,W4
065E4:  MOV     W4,38C8
065E6:  MOV     #0,W4
065E8:  MOV     W4,38CA
065EA:  MOV     #0,W4
065EC:  MOV     W4,38CC
....................  
....................  
.................... redABSfloat = (float) redABS; 
065EE:  MOV     3084,W0
065F0:  MOV     3086,W1
065F2:  CALL    630A
065F6:  MOV     W0,38C2
065F8:  MOV     W1,38C4
.................... greenABSfloat = (float) greenABS; 
065FA:  MOV     308C,W0
065FC:  MOV     308E,W1
065FE:  CALL    630A
06602:  MOV     W0,38C6
06604:  MOV     W1,38C8
.................... blueABSfloat = (float) blueABS; 
06606:  MOV     3088,W0
06608:  MOV     308A,W1
0660A:  CALL    630A
0660E:  MOV     W0,38CA
06610:  MOV     W1,38CC
....................  
....................   x=(-0.14282) * redABSfloat + (1.54924) * greenABSfloat + (-0.95641) * blueABSfloat; 
06612:  MOV     #3F68,W0
06614:  MOV     #BE12,W1
06616:  MOV     38C2,W2
06618:  MOV     38C4,W3
0661A:  CALL    46C6
0661E:  MOV     W0,W5
06620:  MOV     W1,W6
06622:  MOV     #4D7F,W0
06624:  MOV     #3FC6,W1
06626:  MOV     38C6,W2
06628:  MOV     38C8,W3
0662A:  CALL    46C6
0662E:  BCLR.B  43.0
06630:  MOV     W0,W2
06632:  MOV     W1,W3
06634:  MOV     W5,W0
06636:  MOV     W6,W1
06638:  CALL    478A
0663C:  MOV     W0,W5
0663E:  MOV     W1,W6
06640:  MOV     #D749,W0
06642:  MOV     #BF74,W1
06644:  MOV     38CA,W2
06646:  MOV     38CC,W3
06648:  CALL    46C6
0664C:  BCLR.B  43.0
0664E:  MOV     W0,W2
06650:  MOV     W1,W3
06652:  MOV     W5,W0
06654:  MOV     W6,W1
06656:  CALL    478A
0665A:  MOV     W0,2F7C
0665C:  MOV     W1,2F7E
....................   y=(-0.32466) * redABSfloat +(1.57837) * greenABSfloat + (-0.73191) * blueABSfloat; 
0665E:  MOV     #39D6,W0
06660:  MOV     #BEA6,W1
06662:  MOV     38C2,W2
06664:  MOV     38C4,W3
06666:  CALL    46C6
0666A:  MOV     W0,W5
0666C:  MOV     W1,W6
0666E:  MOV     #807,W0
06670:  MOV     #3FCA,W1
06672:  MOV     38C6,W2
06674:  MOV     38C8,W3
06676:  CALL    46C6
0667A:  BCLR.B  43.0
0667C:  MOV     W0,W2
0667E:  MOV     W1,W3
06680:  MOV     W5,W0
06682:  MOV     W6,W1
06684:  CALL    478A
06688:  MOV     W0,W5
0668A:  MOV     W1,W6
0668C:  MOV     #5E74,W0
0668E:  MOV     #BF3B,W1
06690:  MOV     38CA,W2
06692:  MOV     38CC,W3
06694:  CALL    46C6
06698:  BCLR.B  43.0
0669A:  MOV     W0,W2
0669C:  MOV     W1,W3
0669E:  MOV     W5,W0
066A0:  MOV     W6,W1
066A2:  CALL    478A
066A6:  MOV     W0,2F80
066A8:  MOV     W1,2F82
....................   z=(-0.68202) * redABSfloat +(0.77073) * greenABSfloat +(0.56332) * blueABSfloat; 
066AA:  MOV     #98DD,W0
066AC:  MOV     #BF2E,W1
066AE:  MOV     38C2,W2
066B0:  MOV     38C4,W3
066B2:  CALL    46C6
066B6:  MOV     W0,W5
066B8:  MOV     W1,W6
066BA:  MOV     #4E90,W0
066BC:  MOV     #3F45,W1
066BE:  MOV     38C6,W2
066C0:  MOV     38C8,W3
066C2:  CALL    46C6
066C6:  BCLR.B  43.0
066C8:  MOV     W0,W2
066CA:  MOV     W1,W3
066CC:  MOV     W5,W0
066CE:  MOV     W6,W1
066D0:  CALL    478A
066D4:  MOV     W0,W5
066D6:  MOV     W1,W6
066D8:  MOV     #35BD,W0
066DA:  MOV     #3F10,W1
066DC:  MOV     38CA,W2
066DE:  MOV     38CC,W3
066E0:  CALL    46C6
066E4:  BCLR.B  43.0
066E6:  MOV     W0,W2
066E8:  MOV     W1,W3
066EA:  MOV     W5,W0
066EC:  MOV     W6,W1
066EE:  CALL    478A
066F2:  MOV     W0,2F84
066F4:  MOV     W1,2F86
....................   x=x/(x+y+z);   //Calculate the x location 
066F6:  BCLR.B  43.0
066F8:  MOV     2F7C,W0
066FA:  MOV     2F7E,W1
066FC:  MOV     2F80,W2
066FE:  MOV     2F82,W3
06700:  CALL    478A
06704:  MOV     W0,W5
06706:  MOV     W1,W6
06708:  BCLR.B  43.0
0670A:  MOV     W5,W0
0670C:  MOV     W6,W1
0670E:  MOV     2F84,W2
06710:  MOV     2F86,W3
06712:  CALL    478A
06716:  MOV     W0,W2
06718:  MOV     W1,W3
0671A:  MOV     2F7C,W0
0671C:  MOV     2F7E,W1
0671E:  CALL    4530
06722:  MOV     W0,2F7C
06724:  MOV     W1,2F7E
....................   y=y/(x+y+z);   //Calculate the y location 
06726:  BCLR.B  43.0
06728:  MOV     2F7C,W0
0672A:  MOV     2F7E,W1
0672C:  MOV     2F80,W2
0672E:  MOV     2F82,W3
06730:  CALL    478A
06734:  MOV     W0,W5
06736:  MOV     W1,W6
06738:  BCLR.B  43.0
0673A:  MOV     W5,W0
0673C:  MOV     W6,W1
0673E:  MOV     2F84,W2
06740:  MOV     2F86,W3
06742:  CALL    478A
06746:  MOV     W0,W2
06748:  MOV     W1,W3
0674A:  MOV     2F80,W0
0674C:  MOV     2F82,W1
0674E:  CALL    4530
06752:  MOV     W0,2F80
06754:  MOV     W1,2F82
....................   if(!((x>0.0)&&(y>0.0)&&(z>0.0))) 
06756:  MOV     #0,W0
06758:  MOV     #0,W1
0675A:  MOV     2F7C,W2
0675C:  MOV     2F7E,W3
0675E:  CALL    45FA
06762:  BRA     NC,6780
06764:  MOV     #0,W0
06766:  MOV     #0,W1
06768:  MOV     2F80,W2
0676A:  MOV     2F82,W3
0676C:  CALL    45FA
06770:  BRA     NC,6780
06772:  MOV     #0,W0
06774:  MOV     #0,W1
06776:  MOV     2F84,W2
06778:  MOV     2F86,W3
0677A:  CALL    45FA
0677E:  BRA     C,6790
....................   { 
....................    	x=0.0; 
06780:  MOV     #0,W4
06782:  MOV     W4,2F7C
06784:  MOV     #0,W4
06786:  MOV     W4,2F7E
.................... 	y=0.0; 
06788:  MOV     #0,W4
0678A:  MOV     W4,2F80
0678C:  MOV     #0,W4
0678E:  MOV     W4,2F82
....................   } 
06790:  MOV     [--W15],W6
06792:  MOV     [--W15],W5
06794:  RETURN  
....................  
.................... } 
....................  
....................  
....................  
.................... //******************************************************************************* 
.................... //Created Febuary 28, 2015 
.................... // This routine returns the value of the pH from the WA guys patches 
.................... //  The equations takes the x and y values produced from the color.  It then maps it onto the ph.  There three 
.................... // sets of values required for calibrations.  There has to be some sort of equation/curve fitting to make the inputs work. 
.................... //  The x and y values are global variables. 
.................... //  The returned number (float) is the pH calucautaed from the calibration and x and y input. 
.................... float ConvertTopH(void) 
*
07018:  MOV     W5,[W15++]
0701A:  MOV     W6,[W15++]
.................... 	{ 
.................... 	float pHHigh, pHMiddle, pHLower; 
0701C:  MOV     #0,W4
0701E:  MOV     W4,3802
07020:  MOV     #0,W4
07022:  MOV     W4,3804
07024:  MOV     #0,W4
07026:  MOV     W4,3806
07028:  MOV     #0,W4
0702A:  MOV     W4,3808
0702C:  MOV     #0,W4
0702E:  MOV     W4,380A
07030:  MOV     #0,W4
07032:  MOV     W4,380C
....................       float pHHighCalibration,pHMiddleCalibration,pHLowerCalibration; 
07034:  MOV     #0,W4
07036:  MOV     W4,380E
07038:  MOV     #0,W4
0703A:  MOV     W4,3810
0703C:  MOV     #0,W4
0703E:  MOV     W4,3812
07040:  MOV     #0,W4
07042:  MOV     W4,3814
07044:  MOV     #0,W4
07046:  MOV     W4,3816
07048:  MOV     #0,W4
0704A:  MOV     W4,3818
.................... 	float LowerSlope, UpperSlope; 
0704C:  MOV     #0,W4
0704E:  MOV     W4,381A
07050:  MOV     #0,W4
07052:  MOV     W4,381C
07054:  MOV     #0,W4
07056:  MOV     W4,381E
07058:  MOV     #0,W4
0705A:  MOV     W4,3820
.................... 	float pHBLower, pHBUpper;   //This is the calcaulted b for Y = MX + B 
0705C:  MOV     #0,W4
0705E:  MOV     W4,3822
07060:  MOV     #0,W4
07062:  MOV     W4,3824
07064:  MOV     #0,W4
07066:  MOV     W4,3826
07068:  MOV     #0,W4
0706A:  MOV     W4,3828
....................  
.................... 	pHHigh = 9.0; 
0706C:  MOV     #0,W4
0706E:  MOV     W4,3802
07070:  MOV     #4110,W4
07072:  MOV     W4,3804
.................... 	pHMiddle = 7.5; 
07074:  MOV     #0,W4
07076:  MOV     W4,3806
07078:  MOV     #40F0,W4
0707A:  MOV     W4,3808
.................... 	pHLower = 6.5; 
0707C:  MOV     #0,W4
0707E:  MOV     W4,380A
07080:  MOV     #40D0,W4
07082:  MOV     W4,380C
....................  
.................... 	 pHHighCalibration =  0.93; 
07084:  MOV     #147B,W4
07086:  MOV     W4,380E
07088:  MOV     #3F6E,W4
0708A:  MOV     W4,3810
.................... 	pHMiddleCalibration =  0.97; 
0708C:  MOV     #51EC,W4
0708E:  MOV     W4,3812
07090:  MOV     #3F78,W4
07092:  MOV     W4,3814
.................... 	pHLowerCalibration = 0.985; 
07094:  MOV     #28F6,W4
07096:  MOV     W4,3816
07098:  MOV     #3F7C,W4
0709A:  MOV     W4,3818
....................  
.................... 	LowerSlope = (pHMiddle-pHLower)/(pHMiddleCalibration-pHLowerCalibration); 
0709C:  BSET.B  43.0
0709E:  MOV     3806,W0
070A0:  MOV     3808,W1
070A2:  MOV     380A,W2
070A4:  MOV     380C,W3
070A6:  CALL    478A
070AA:  MOV     W0,W5
070AC:  MOV     W1,W6
070AE:  BSET.B  43.0
070B0:  MOV     3812,W0
070B2:  MOV     3814,W1
070B4:  MOV     3816,W2
070B6:  MOV     3818,W3
070B8:  CALL    478A
070BC:  MOV     W0,W2
070BE:  MOV     W1,W3
070C0:  MOV     W5,W0
070C2:  MOV     W6,W1
070C4:  CALL    4530
070C8:  MOV     W0,381A
070CA:  MOV     W1,381C
.................... 	UpperSlope = (pHHigh - pHMiddle)/(pHHighCalibration - pHMiddleCalibration); 
070CC:  BSET.B  43.0
070CE:  MOV     3802,W0
070D0:  MOV     3804,W1
070D2:  MOV     3806,W2
070D4:  MOV     3808,W3
070D6:  CALL    478A
070DA:  MOV     W0,W5
070DC:  MOV     W1,W6
070DE:  BSET.B  43.0
070E0:  MOV     380E,W0
070E2:  MOV     3810,W1
070E4:  MOV     3812,W2
070E6:  MOV     3814,W3
070E8:  CALL    478A
070EC:  MOV     W0,W2
070EE:  MOV     W1,W3
070F0:  MOV     W5,W0
070F2:  MOV     W6,W1
070F4:  CALL    4530
070F8:  MOV     W0,381E
070FA:  MOV     W1,3820
....................  
.................... 	//This section finds b for the upper and lower pHs. 
.................... 	pHBLower = -1.0 *LowerSlope * pHMiddleCalibration + pHMiddle; 
070FC:  MOV     #0,W0
070FE:  MOV     #BF80,W1
07100:  MOV     381A,W2
07102:  MOV     381C,W3
07104:  CALL    46C6
07108:  MOV     W0,W5
0710A:  MOV     W1,W6
0710C:  MOV     W5,W0
0710E:  MOV     W6,W1
07110:  MOV     3812,W2
07112:  MOV     3814,W3
07114:  CALL    46C6
07118:  MOV     W0,W5
0711A:  MOV     W1,W6
0711C:  BCLR.B  43.0
0711E:  MOV     W5,W0
07120:  MOV     W6,W1
07122:  MOV     3806,W2
07124:  MOV     3808,W3
07126:  CALL    478A
0712A:  MOV     W0,3822
0712C:  MOV     W1,3824
....................       pHBUpper = -1.0 * UpperSlope * pHMiddleCalibration + pHMiddle; 
0712E:  MOV     #0,W0
07130:  MOV     #BF80,W1
07132:  MOV     381E,W2
07134:  MOV     3820,W3
07136:  CALL    46C6
0713A:  MOV     W0,W5
0713C:  MOV     W1,W6
0713E:  MOV     W5,W0
07140:  MOV     W6,W1
07142:  MOV     3812,W2
07144:  MOV     3814,W3
07146:  CALL    46C6
0714A:  MOV     W0,W5
0714C:  MOV     W1,W6
0714E:  BCLR.B  43.0
07150:  MOV     W5,W0
07152:  MOV     W6,W1
07154:  MOV     3806,W2
07156:  MOV     3808,W3
07158:  CALL    478A
0715C:  MOV     W0,3826
0715E:  MOV     W1,3828
....................  
.................... 	if (y < pHMiddleCalibration) 
07160:  MOV     2F80,W0
07162:  MOV     2F82,W1
07164:  MOV     3812,W2
07166:  MOV     3814,W3
07168:  CALL    45FA
0716C:  BRA     NC,7190
.................... 		{ 
.................... 		return(pHBUpper+UpperSlope*y);  //This the values for the larger values for pH 
0716E:  MOV     381E,W0
07170:  MOV     3820,W1
07172:  MOV     2F80,W2
07174:  MOV     2F82,W3
07176:  CALL    46C6
0717A:  BCLR.B  43.0
0717C:  MOV     W0,W2
0717E:  MOV     W1,W3
07180:  MOV     3826,W0
07182:  MOV     3828,W1
07184:  CALL    478A
07188:  MOV.D   W0,W0
0718A:  BRA     71AE
.................... 		} 
0718C:  GOTO    71AE
.................... 		else 
.................... 		{ 
.................... 		return(pHBLower+LowerSlope*y);   //This is for the values of the smaller values of pH 
07190:  MOV     381A,W0
07192:  MOV     381C,W1
07194:  MOV     2F80,W2
07196:  MOV     2F82,W3
07198:  CALL    46C6
0719C:  BCLR.B  43.0
0719E:  MOV     W0,W2
071A0:  MOV     W1,W3
071A2:  MOV     3822,W0
071A4:  MOV     3824,W1
071A6:  CALL    478A
071AA:  MOV.D   W0,W0
071AC:  BRA     71AE
.................... 		} 
071AE:  MOV     [--W15],W6
071B0:  MOV     [--W15],W5
071B2:  RETURN  
.................... 	} 
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... // Created May 13, 2013 
.................... // This routine returns the determinent for a given 3X3 mastrix passed through the funtion stack as a pointer to address. 
.................... // The Deteminete is returned at the end of the funtion call. 
.................... // This method for solving equations is called Cramer's rule 
.................... //****************************************************************************** 
.................... float FindTheDetermint(void) 
*
04AF4:  MOV     W5,[W15++]
04AF6:  MOV     W6,[W15++]
04AF8:  MOV     W7,[W15++]
04AFA:  MOV     W8,[W15++]
.................... 	{ 
.................... 	float det,part1,part2;  //Define the determint as float. 
04AFC:  MOV     #0,W4
04AFE:  MOV     W4,383C
04B00:  MOV     #0,W4
04B02:  MOV     W4,383E
04B04:  MOV     #0,W4
04B06:  MOV     W4,3840
04B08:  MOV     #0,W4
04B0A:  MOV     W4,3842
04B0C:  MOV     #0,W4
04B0E:  MOV     W4,3844
04B10:  MOV     #0,W4
04B12:  MOV     W4,3846
....................  
....................     part1=matx[0][0]*matx[1][1]*matx[2][2]; 
04B14:  MOV     2F8C,W0
04B16:  MOV     2F8E,W1
04B18:  MOV     2F9C,W2
04B1A:  MOV     2F9E,W3
04B1C:  CALL    46C6
04B20:  MOV     W0,W5
04B22:  MOV     W1,W6
04B24:  MOV     W5,W0
04B26:  MOV     W6,W1
04B28:  MOV     2FAC,W2
04B2A:  MOV     2FAE,W3
04B2C:  CALL    46C6
04B30:  MOV     W0,3840
04B32:  MOV     W1,3842
....................  
.................... 	det = (part1 + matx[1][0]*matx[2][1]*matx[0][2] + matx[2][0]*matx[0][1]*matx[1][2]);  
04B34:  MOV     2F98,W0
04B36:  MOV     2F9A,W1
04B38:  MOV     2FA8,W2
04B3A:  MOV     2FAA,W3
04B3C:  CALL    46C6
04B40:  MOV     W0,W5
04B42:  MOV     W1,W6
04B44:  MOV     W5,W0
04B46:  MOV     W6,W1
04B48:  MOV     2F94,W2
04B4A:  MOV     2F96,W3
04B4C:  CALL    46C6
04B50:  BCLR.B  43.0
04B52:  MOV     W0,W2
04B54:  MOV     W1,W3
04B56:  MOV     3840,W0
04B58:  MOV     3842,W1
04B5A:  CALL    478A
04B5E:  MOV     W0,W5
04B60:  MOV     W1,W6
04B62:  MOV     2FA4,W0
04B64:  MOV     2FA6,W1
04B66:  MOV     2F90,W2
04B68:  MOV     2F92,W3
04B6A:  CALL    46C6
04B6E:  MOV     W0,W7
04B70:  MOV     W1,W8
04B72:  MOV     W7,W0
04B74:  MOV     W8,W1
04B76:  MOV     2FA0,W2
04B78:  MOV     2FA2,W3
04B7A:  CALL    46C6
04B7E:  BCLR.B  43.0
04B80:  MOV     W0,W2
04B82:  MOV     W1,W3
04B84:  MOV     W5,W0
04B86:  MOV     W6,W1
04B88:  CALL    478A
04B8C:  MOV     W0,383C
04B8E:  MOV     W1,383E
....................     part2 = (matx[0][2]*matx[1][1]*matx[2][0] + matx[1][2]*matx[2][1]*matx[0][0] + matx[2][2]*matx[0][1]*matx[1][0]); 
04B90:  MOV     2F94,W0
04B92:  MOV     2F96,W1
04B94:  MOV     2F9C,W2
04B96:  MOV     2F9E,W3
04B98:  CALL    46C6
04B9C:  MOV     W0,W5
04B9E:  MOV     W1,W6
04BA0:  MOV     W5,W0
04BA2:  MOV     W6,W1
04BA4:  MOV     2FA4,W2
04BA6:  MOV     2FA6,W3
04BA8:  CALL    46C6
04BAC:  MOV     W0,W5
04BAE:  MOV     W1,W6
04BB0:  MOV     2FA0,W0
04BB2:  MOV     2FA2,W1
04BB4:  MOV     2FA8,W2
04BB6:  MOV     2FAA,W3
04BB8:  CALL    46C6
04BBC:  MOV     W0,W7
04BBE:  MOV     W1,W8
04BC0:  MOV     W7,W0
04BC2:  MOV     W8,W1
04BC4:  MOV     2F8C,W2
04BC6:  MOV     2F8E,W3
04BC8:  CALL    46C6
04BCC:  BCLR.B  43.0
04BCE:  MOV     W0,W2
04BD0:  MOV     W1,W3
04BD2:  MOV     W5,W0
04BD4:  MOV     W6,W1
04BD6:  CALL    478A
04BDA:  MOV     W0,W5
04BDC:  MOV     W1,W6
04BDE:  MOV     2FAC,W0
04BE0:  MOV     2FAE,W1
04BE2:  MOV     2F90,W2
04BE4:  MOV     2F92,W3
04BE6:  CALL    46C6
04BEA:  MOV     W0,W7
04BEC:  MOV     W1,W8
04BEE:  MOV     W7,W0
04BF0:  MOV     W8,W1
04BF2:  MOV     2F98,W2
04BF4:  MOV     2F9A,W3
04BF6:  CALL    46C6
04BFA:  BCLR.B  43.0
04BFC:  MOV     W0,W2
04BFE:  MOV     W1,W3
04C00:  MOV     W5,W0
04C02:  MOV     W6,W1
04C04:  CALL    478A
04C08:  MOV     W0,3844
04C0A:  MOV     W1,3846
.................... 	det = det - (matx[0][2]*matx[1][1]*matx[2][0] + matx[1][2]*matx[2][1]*matx[0][0] + matx[2][2]*matx[0][1]*matx[1][0]); 
04C0C:  MOV     2F94,W0
04C0E:  MOV     2F96,W1
04C10:  MOV     2F9C,W2
04C12:  MOV     2F9E,W3
04C14:  CALL    46C6
04C18:  MOV     W0,W5
04C1A:  MOV     W1,W6
04C1C:  MOV     W5,W0
04C1E:  MOV     W6,W1
04C20:  MOV     2FA4,W2
04C22:  MOV     2FA6,W3
04C24:  CALL    46C6
04C28:  MOV     W0,W5
04C2A:  MOV     W1,W6
04C2C:  MOV     2FA0,W0
04C2E:  MOV     2FA2,W1
04C30:  MOV     2FA8,W2
04C32:  MOV     2FAA,W3
04C34:  CALL    46C6
04C38:  MOV     W0,W7
04C3A:  MOV     W1,W8
04C3C:  MOV     W7,W0
04C3E:  MOV     W8,W1
04C40:  MOV     2F8C,W2
04C42:  MOV     2F8E,W3
04C44:  CALL    46C6
04C48:  BCLR.B  43.0
04C4A:  MOV     W0,W2
04C4C:  MOV     W1,W3
04C4E:  MOV     W5,W0
04C50:  MOV     W6,W1
04C52:  CALL    478A
04C56:  MOV     W0,W5
04C58:  MOV     W1,W6
04C5A:  MOV     2FAC,W0
04C5C:  MOV     2FAE,W1
04C5E:  MOV     2F90,W2
04C60:  MOV     2F92,W3
04C62:  CALL    46C6
04C66:  MOV     W0,W7
04C68:  MOV     W1,W8
04C6A:  MOV     W7,W0
04C6C:  MOV     W8,W1
04C6E:  MOV     2F98,W2
04C70:  MOV     2F9A,W3
04C72:  CALL    46C6
04C76:  BCLR.B  43.0
04C78:  MOV     W0,W2
04C7A:  MOV     W1,W3
04C7C:  MOV     W5,W0
04C7E:  MOV     W6,W1
04C80:  CALL    478A
04C84:  BSET.B  43.0
04C86:  MOV     W0,W2
04C88:  MOV     W1,W3
04C8A:  MOV     383C,W0
04C8C:  MOV     383E,W1
04C8E:  CALL    478A
04C92:  MOV     W0,383C
04C94:  MOV     W1,383E
....................  
.................... 	return(det); 
04C96:  MOV     383C,W0
04C98:  MOV     383E,W1
04C9A:  MOV     [--W15],W8
04C9C:  MOV     [--W15],W7
04C9E:  MOV     [--W15],W6
04CA0:  MOV     [--W15],W5
04CA2:  RETURN  
.................... 	} 
....................  
.................... //****************************************************************************** 
.................... // Created May 13, 2013 
.................... // This routine is a general purpose solution for three unknowns given the coefficents of all three equations and what they eqaul. 
.................... // The coefficents are given as a matrix of 3X3 in an 3X3 array of floats starting with 0 to 2.  The results are placed in the last colomum of of the 3X3 matrix. 
.................... // The routines uses a series of deteminets to solve the problems. 
.................... //****************************************************************************** 
.................... void ThreeByThreeSolution(void) 
.................... 	{ 
....................  
.................... 	float det, detx, dety, detz; 
.................... 	int x, y; 
....................  
.................... // this finds the common det for the whole matrix 
.................... //  Move the exisitng array into the scratch pad marix  matx 
.................... 	for (x=0; x < 3; x++) 
.................... 		{ 
.................... 		for (y=0; y < 3; y++) 
.................... 			{ 
.................... 			matx[x][y] = matrixequation[x][y];   //Move this element into the scrach matrix. 
.................... 			} 
.................... 		} 
....................  
.................... 	matx[0][0] = 1.0;  //this for testing the deteminte routine. 
.................... 	matx[1][0] = 0.0;  // remove all of this when completed. 
.................... 	matx[2][0] = 3.0; 
.................... 	matx[0][1] = 2.0; 
.................... 	matx[1][1] = 1.0; 
.................... 	matx[2][1] = 0.0; 
.................... 	matx[0][2] = 4.0; 
.................... 	matx[1][2] = 1.0; 
.................... 	matx[2][2] = 0.0; 
....................  
.................... 	det = FindTheDetermint(); 
....................  
....................  
.................... //  Move the exisitng array into the scratch pad matrix  matrix 
.................... 	for (x=0; x < 3; x++) 
.................... 		{ 
.................... 		for (y=0; y < 3; y++) 
.................... 			{ 
.................... 			matx[x][y] = matrixequation[x][y];   //Move this element into the scrach matrix. 
.................... 			} 
.................... 		} 
.................... 		for (y=0; y < 3; y++) //move the first colunm into the x 
.................... 			{ 
....................                  matx[0][y] = matrixequals[y]; 
.................... 			} 
....................  
.................... 	detx = FindTheDetermint(); //find the detmeinent 
....................       MatrixSolution[0] = detx/det; //Stuff the results in the x location 
....................  
.................... //  Move the exisitng array into the scratch pad matrix  matrix 
.................... 	for (x=0; x < 3; x++) 
.................... 		{ 
.................... 		for (y=0; y < 3; y++) 
.................... 			{ 
.................... 			matx[x][y] = matrixequation[x][y];   //Move this element into the scrach matrix. 
.................... 			} 
.................... 		} 
.................... 		for (y=0; y < 3; y++) //move the first colunm into the x 
.................... 			{ 
....................                  matx[1][y] = matrixequals[y]; 
.................... 			} 
....................  
.................... 	dety = FindTheDetermint(); //find the detmeinent 
....................       MatrixSolution[1] = dety/det; //Stuff the results in the x location 
....................  
....................  
.................... //  Move the exisitng array into the scratch pad matrix  matrix 
.................... 	for (x=0; x < 3; x++) 
.................... 		{ 
.................... 		for (y=0; y < 3; y++) 
.................... 			{ 
.................... 			matx[x][y] = matrixequation[x][y];   //Move this element into the scrach matrix. 
.................... 			} 
.................... 		} 
.................... 		for (y=0; y < 3; y++) //move the first colunm into the x 
.................... 			{ 
....................                  matx[2][y] = matrixequals[y];  // replace the colunm 
.................... 			} 
....................  
.................... 	detz = FindTheDetermint(); //find the detmeinent 
....................       MatrixSolution[2] = detz/det; //Stuff the results in the x location 
....................  
.................... 	} 
....................  
....................  
....................  
....................  
....................  
.................... //************************************************************* 
.................... // Created May 15, 2014 
.................... // This routine finds a 4X4 detemint from a given matrix. 
.................... // The matrix is passed with a global variable 
.................... //************************************************************* 
.................... float FindFourbyFour(void) 
.................... { 
....................  
....................  
.................... float det;   //This is the result deteminent 
.................... float detsub1,detsub2,detsub3,detsub4; 
....................  
....................  
.................... matx[0][0] = fourbyfourmatrix[1][1]; 
.................... matx[1][0] = fourbyfourmatrix[2][1]; 
.................... matx[2][0] = fourbyfourmatrix[3][1]; 
....................  
.................... matx[0][1] = fourbyfourmatrix[1][2]; 
.................... matx[1][1] = fourbyfourmatrix[2][2]; 
.................... matx[2][1] = fourbyfourmatrix[3][2]; 
....................  
.................... matx[0][2] = fourbyfourmatrix[1][3]; 
.................... matx[1][2] = fourbyfourmatrix[2][3]; 
.................... matx[2][2] = fourbyfourmatrix[3][3]; 
....................  
.................... detsub1 = (fourbyfourmatrix[0][0])*FindTheDetermint(); 
....................  
....................  
....................  
.................... matx[0][0] = fourbyfourmatrix[1][0]; 
.................... matx[1][0] = fourbyfourmatrix[2][0]; 
.................... matx[2][0] = fourbyfourmatrix[3][0]; 
....................  
.................... matx[0][1] = fourbyfourmatrix[1][2]; 
.................... matx[1][1] = fourbyfourmatrix[2][2]; 
.................... matx[2][1] = fourbyfourmatrix[3][2]; 
....................  
.................... matx[0][2] = fourbyfourmatrix[1][3]; 
.................... matx[1][2] = fourbyfourmatrix[2][3]; 
.................... matx[2][2] = fourbyfourmatrix[3][3]; 
....................  
.................... detsub2 = (fourbyfourmatrix[0][1])*FindTheDetermint(); 
....................  
....................  
....................  
.................... matx[0][0] = fourbyfourmatrix[1][0]; 
.................... matx[1][0] = fourbyfourmatrix[2][0]; 
.................... matx[2][0] = fourbyfourmatrix[3][0]; 
....................  
.................... matx[0][1] = fourbyfourmatrix[1][1]; 
.................... matx[1][1] = fourbyfourmatrix[2][1]; 
.................... matx[2][1] = fourbyfourmatrix[3][1]; 
....................  
.................... matx[0][2] = fourbyfourmatrix[1][3]; 
.................... matx[1][2] = fourbyfourmatrix[2][3]; 
.................... matx[2][2] = fourbyfourmatrix[3][3]; 
....................  
.................... detsub3 = (fourbyfourmatrix[0][2])*FindTheDetermint(); 
....................  
....................  
.................... matx[0][0] = fourbyfourmatrix[1][0]; 
.................... matx[1][0] = fourbyfourmatrix[2][0]; 
.................... matx[2][0] = fourbyfourmatrix[3][0]; 
....................  
.................... matx[0][1] = fourbyfourmatrix[1][1]; 
.................... matx[1][1] = fourbyfourmatrix[2][1]; 
.................... matx[2][1] = fourbyfourmatrix[3][1]; 
....................  
.................... matx[0][2] = fourbyfourmatrix[1][2]; 
.................... matx[1][2] = fourbyfourmatrix[2][2]; 
.................... matx[2][2] = fourbyfourmatrix[3][2]; 
....................  
.................... detsub4 = (fourbyfourmatrix[0][3])*FindTheDetermint(); 
....................  
....................  
.................... det = detsub1 - detsub2 + detsub3 - detsub4; 
....................  
.................... return(det); 
....................  
.................... } 
....................  
....................  
....................  
.................... //***************************************************************************** 
.................... // Created May 9, 2013 
.................... //  This routine finds the constants K1 and K2 for any four given values of O2 concentration and intensity. 
.................... //  IntensityHighOxy matches up with LowOxyPercentage 
.................... //  IntensityLowOxy matches up with HighOxyPercentage 
.................... //  Updated April 29, 2014 
.................... //  This routine is completed with formula for K1 and K2. 
.................... //  ***************************************************************************** 
.................... void SolveForK1AndK2(void) 
.................... 	{ 
....................  
.................... float disolvedOxygen1,disolvedOxygen2,disolvedOxygen3; 
.................... float reading1,reading2, reading3; 
....................  
.................... disolvedOxygen1 = .200;  //Percent 
.................... disolvedOxygen2 = .050;  //Percent 
.................... disolvedOxygen3 = 0.0;  //Percent 
....................  
....................  
....................  
.................... reading3 = 1096.0;    ///This is the reading close to tru O2 20% O2. 
.................... reading2 = 14000.0;    //This is for 5% of O2  
.................... reading1 = 57243.0;  //This is for the low O2 reading for close to the axis reading.  This is the hight nummber 
....................  
....................  
....................  
.................... //  Find the ratios for all three combinations. 
.................... 	RatioI=(reading1/reading3)-1.0;  // I0/I1 - 1.0 
.................... 	RatioII=(reading1/reading2)-1.0;    //  I0/I2 - 1.0 
....................  
....................  
.................... //*************************************************** 
.................... // Created April 29, 2014 
.................... // This sets up the matrix to solve for K1 and K2 using 
.................... // two O2 points and percentages. 
....................  
.................... //matrixSolve[1][0] = LowOxyPercentage;//  This is for RatioII 
.................... //matrixSolve[1][1] = LowOxyPercentage*LowOxyPercentage;//  This is for RatioII 
....................  
.................... //matrixSolve[0][0] = HighOxyPercentage;//  This is for RatioI 
.................... //matrixSolve[0][1] = HighOxyPercentage*HighOxyPercentage;//  This is for RatioII 
....................  
....................   //  det = matrixSolve[0][0]*matrixSolve[1][1] - matrixSolve[0][1]*matrixSolve[0][1]; 
....................  
....................  
.................... // Find K2  
....................      K2 = ((RatioI/disolvedOxygen1) - (RatioII/disolvedOxygen2))/(disolvedOxygen1 - disolvedOxygen2); 
....................  
.................... // Find K1 
....................  
....................      K1 = (RatioI-(K2*disolvedOxygen1*disolvedOxygen1))/disolvedOxygen1; 
....................  
....................  
.................... // Find Iohhh  
....................  
.................... 	Iohhh = reading1; 
.................... 	} 
....................  
.................... //*************************************************************** 
.................... // Created April 27, 2014 
.................... // This routine finds all of the constants for temperature  
.................... // constants for K2, K1 and Iohhh. 
.................... //  The intput is a matrix of inputs (K2, K1 and Iohhh) at three temperatures. 
.................... // The outputs are as follows: 
.................... // azero, bzero, czero 
.................... // aone, bone, cone 
.................... // atwo, btwo, ctwo 
.................... // TempCalmatrix is as follows: 
.................... //  [Temp1] [K1] [K2] [Iohhh] 
.................... //  [Temp2] [K1] [K2] [Iohhh] 
.................... //  [Temp3] [K1] [K2] [Iohhh] 
.................... //*************************************************************** 
....................  
.................... void FindTemperatureCoef(void) 
....................      { 
....................       // Detemine Coefs for K1 
....................       matrixequals[0] = TempCalmatrix[1][0];  
....................       matrixequation[0][0] = 1; 
....................       matrixequation[1][0] = TempCalmatrix[0][0];  
....................       matrixequation[2][0] = TempCalmatrix[0][0] * TempCalmatrix[0][0];  
....................       matrixequals[0] = TempCalmatrix[1][1];  
....................       matrixequation[0][1] = 1; 
....................       matrixequation[1][1] = TempCalmatrix[0][1];  
....................       matrixequation[2][1] = TempCalmatrix[0][1] * TempCalmatrix[0][1];  
....................       matrixequals[0] = TempCalmatrix[1][2];  
....................       matrixequation[0][2] = 1; 
....................       matrixequation[1][2] = TempCalmatrix[0][2];  
....................       matrixequation[2][2] = TempCalmatrix[0][2] * TempCalmatrix[0][2];       
....................  
.................... ThreeByThreeSolution();  // Call to solve for coefs 
....................       
....................  
....................  
.................... 	atwo = MatrixSolution[0];   //Move the solution into the coefs 
.................... 	btwo = MatrixSolution[1];   //Move the solution into the coefs 
.................... 	ctwo = MatrixSolution[2];   //Move the solution into the coefs 
....................  
....................  
....................  
....................  
.................... 	} 
....................  
....................  
....................  
....................  
....................  
.................... //**************************************************************************** 
.................... // Created May 9, 2013 
.................... // This rouitne uses the current read Intensity, K1 and K2 to determine the currnet percent of O2 
.................... // The calibration calculation routine needs to first be run before this routine works. 
.................... // Later on the temperature is also considered for Do compensation. 
.................... //**************************************************************************** 
.................... float CalcaulateDO(unsigned int32 IntensityReading, float temperature) 
.................... 	{ 
....................  
.................... 	float root1,root2,RatioOfIntensity; 
....................  
.................... //*************************************************************** 
.................... // Created April 27, 2014 
.................... // This routine uses the predetemined values for K1, K2 and Iohhh 
.................... // The values for aone, bone and cone are saved in EEPROM when that 
.................... // is working.  For now, three numbers will be used just for  
.................... // calculations checking. 
.................... //*************************************************************	 
....................  
....................  
....................  
....................  
.................... //*************** 
.................... // May 1, 2014  
.................... // This is commented out to first test the K1 and K2 equations.  Temp comp is added later. 
.................... //*************** 
....................  
.................... //Iohhh = azero + bzero * temperature + czero * temperature * temperature; 
....................  
.................... //K1 = aone + bone * temperature + cone * temperature * temperature; 
.................... //K2 = atwo + btwo * temperature + ctwo * temperature * temperature; 
.................... //SolveForK1AndK2(int16 IntensityLowOxy, int16 IntensityHighOxy, int16 IntensityMiddleOxy, float LowOxyPercentage, float HighOxyPercentage) 
.................... SolveForK1AndK2(); 
....................  
.................... //************************************************************** //Added April 27, 2014 
.................... // Before the DO can be calculated, it needs to be temperature  
.................... // compensated.  The values of K2, K1 and Iohhh need to be  
.................... // calculated through the three X three matrix temperature shift. 
.................... // ************************************************************** 
.................... //IntensityReading = 200.0;   //this is the test input reading.  This is commeneted out for the real data Nov. 14, 2014 
....................  
.................... RatioOfIntensity = 1.0 - Iohhh/IntensityReading; 
.................... 	root1 = sqrt(K1*K1 - 4.0*RatioOfIntensity*K2)- K1; 
.................... 	 
.................... 	root1 = (root1)/(2.0*K2);  //This is the plus version of the equation 
.................... 	root2 = (-1.0 * K1 - (sqrt((K1*K1)-4.0*(RatioOfIntensity)*K2)))/(2.0*K2);  // This is the negative version of the equation.  Most likely not used? 
....................  
.................... 	return(root1);  //If this root is positive, the return it. 
.................... 	} 
....................  
....................  
....................  
....................  
.................... //***************************************************************** 
.................... // Created May 1, 2014 
.................... // Updated June 4, 2014 
.................... // Updated the formulas and made the routine work. 
.................... // This routine detemines the pK and m for ph calcualations. 
.................... // The following inputs need to be present. 
.................... // int16 ASample1 
.................... // int16 ASample2 
.................... // int16 ASampleph11 
.................... // int Sample1pH    This needs to be a whole number only.   
.................... // int Sample2pH  This needs to be a whole number only.   
.................... // returns nothing.  pk and slope = m are global variables saved in EEPROM 
.................... //***************************************************************** 
.................... void FindPkAndSlope(int32 ASample1, int32 ASample2, int32 ASampleph11, int Sample1pH, int Sample2pH) 
.................... 	{ 
.................... 		float pH1, pH2; 
....................         float  Cal1, Cal2;  // Cal1 and Cal2 are caluculated points using LOG 
.................... 		float Sampleph1,Sampleph2,Sampleph11; 
....................  
.................... 		Sampleph1 = (float) ASample1; 
.................... 		Sampleph2 = (float) ASample2; 
.................... 		Sampleph11 = (float) ASampleph11; 
....................  
.................... 		Cal1 = Sampleph1/(Sampleph11 - Sampleph1); 
.................... 		Cal1 = log10(Cal1); 
.................... 		Cal2 = log10(Sampleph2/(Sampleph11 - Sampleph2)); 
....................  
.................... 		pH1 = (float) Sample1pH; 
....................         pH2 = (float) Sample2pH; 
.................... 		slope = (pH1-pH2)/(Cal1 - Cal2); // This finds the slope 
....................  
....................     	pk = pH1 - slope*Cal1;   //This solves for b in the equation y = mx + b 
....................  
....................  
.................... 	} 
....................  
....................  
....................  
.................... //***************************************************************************************** 
.................... // Created June 4, 2014 
.................... // Find the current pH given the input read data. 
.................... // The pH is returned as a float 
.................... //***************************************************************************************** 
.................... float CalcaulatepH(unsigned int32 ASample) 
.................... 	{  
....................  
.................... 	int32 ASample1, ASample2, ASampleph11; 
.................... 	int Sample1pH, Sample2pH; 
.................... static float LastSamplepH = 0.0; 
.................... 	float Calm, Cal1, Caln, tempCal;   //This is the measurement  
.................... //  this is the sample working calculations 
.................... /*	Sample1pH = 4; 
.................... 	Sample2pH = 7; 
.................... 	ASample1 = 100; 
.................... 	ASample2 = 200; 
.................... 	ASampleph11 = 1000; 
....................     ASample = 210; 
....................  
.................... */ 
....................  
.................... 	Sample1pH = 4; 
.................... 	Sample2pH = 8; 
.................... 	ASample1 = 15000;   //  33400 
.................... 	ASample2 = 39900;    //  31200 
.................... 	ASampleph11 = 85802;   //  
....................    // ASample = 200;  // This is the sample taken as a reading.  This is provided through the function 
....................  
.................... 	FindPkAndSlope(ASample1, ASample2, ASampleph11, Sample1pH, Sample2pH); 
....................  
....................     Calm = (float) ASample; 
....................     Caln = (float) ASampleph11; 
.................... 	Cal1 = log10(Calm/(Caln - Calm)); 
.................... 	Cal1 = pk + slope*Cal1;   //This finds the curretn pH.  This is also the y = mx + b 
....................  
.................... 	if (Cal1 < 4.0) 
.................... 		Cal1=4.0; 
....................  
.................... 	if (Cal1 > 10.0) 
.................... 		Cal1=10.0;	 
.................... //*********************************************************************************** 
.................... // Created Nov 22, 2014 
.................... // This section filters off readings where it shows error becauseof bubble or other light readings. 
.................... //*********************************************************************************** 
.................... //   
.................... if (LastSamplepH != 0.0) 
.................... 	{ 
.................... 	if (abs(Cal1 - LastSamplepH) < 0.75) 
.................... 		{ 
.................... 		LastSamplepH = Cal1;  //  let it through 
.................... 		} 
.................... 		else 
.................... 		{ 
.................... 		// if the difference is more than 0.9, then split thediffernece and send it out. 
.................... 		if ((Cal1 - LastSamplepH) > 0.0) 
.................... 			{  //this means the number is going up. 
.................... 			tempCal = abs((Cal1 - LastSamplepH)/2.0); 
.................... 			if (tempCal < 1.0) 
.................... 				{ 
.................... 				Cal1 = LastSamplepH + (Cal1 - LastSamplepH)/2.0; 
.................... 				} 
.................... 				else 
.................... 				{ 
.................... 				Cal1 = LastSamplepH + 0.75; 
.................... 				} 
.................... 			LastSamplepH = Cal1; 
.................... 			} 
.................... 			else 
.................... 			{ //this means the number is going down in value. 
.................... 			tempCal = abs((Cal1 - LastSamplepH)/2.0); 
.................... 			if (tempCal < 1.0) 
.................... 				{ 
.................... 				Cal1 = LastSamplepH - (Cal1 - LastSamplepH)/2.0; 
.................... 				} 
.................... 				else 
.................... 				{ 
.................... 				Cal1 = LastSamplepH - 0.75; 
.................... 				} 
.................... 			LastSamplepH = Cal1; 
.................... 			} 
.................... 		} 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 	LastSamplepH = Cal1;  //If this is the first time through, the set whatever number to the last value 
.................... 	} 
....................  
.................... 	 
.................... 	return(Cal1); 
....................  
.................... 	} 
.................... //****************************************************************************************** 
.................... // Created April 26, 2014 
.................... // This routine finds the color light for any of four spectrum devices.  The inputs for GainIn are as follows: 
.................... //  4:  Determine the gain for what ND to use where all of the colors are not saturated. 
.................... //  0 is 1X 
.................... //  1 is 4X 
.................... //  2 is 16X 
.................... //  3 is 64X 
.................... //  These are the same numbers used by the chip 
.................... //  The returned result of the function is always the gain used.  For instance if a predetemined gain is used, that gain 
.................... // is returned.  If the automatic gain is used, the detemine gain is returned, not the number 4. 
.................... //  All colors are returned as global varaibles for other routines to use. 
.................... // ********************* 
.................... // The inputs for the chip select is as follows: 
.................... // 0: Number 1 
.................... // 1: Number 2 
.................... // 2: Number 3 
.................... // 3: Number 4  - this number does not exist on the Osmobot as is because thing is connected to it. 
.................... // The colors are retuned in the global variables as follows: 
.................... // green, red, blue and clear 
.................... //  When a device is not selected correcly, the number 0xFF is returned as an error on the I2C. 
.................... //****************************************************************************************** 
....................  
.................... int8 GetCurrentColor(int8 GainIn, int8 DeviceSelect) 
*
06030:  MOV     W5,[W15++]
06032:  MOV     W6,[W15++]
06034:  MOV     #1,W4
06036:  MOV     W4,3894
.................... 	{ 
....................  
.................... //  Set the device to be processed 
....................  
.................... int exitit = 1; 
.................... unsigned int gainMultiplyer; 
06038:  MOV     #0,W4
0603A:  MOV     W4,3896
....................  
....................  
.................... // This section splits between returning the currecnt color with the specificed gains, or find the auto gan and return the gain and the colors. 
....................  
.................... 	if (GainIn == 4)   //This is the auto gain routine. 
0603C:  MOV     3892,W0
0603E:  SE      W0,W0
06040:  CP      W0,#4
06042:  BRA     NZ,61DC
.................... 		{ 
.................... 		GainIn = 3;  //This is the hightes gain.  It goes down from there. 
06044:  MOV     3892,W0
06046:  MOV.B   #3,W0L
06048:  MOV     W0,3892
.................... 		setTAOSGain(GainIn,DeviceSelect); //Gain and then scale 
0604A:  MOV     3892,W0
0604C:  PUSH    389A
0604E:  MOV.B   W0L,[W15-#2]
06050:  POP     389A
06052:  PUSH    3892
06054:  MOV     [--W15],W4
06056:  LSR     W4,#8,W4
06058:  SE      W4,W3
0605A:  MOV     W3,389C
0605C:  CALL    23E0
.................... 		StartUpTAOS(DeviceSelect); 
06060:  PUSH    3892
06062:  MOV     [--W15],W4
06064:  LSR     W4,#8,W4
06066:  SE      W4,W3
06068:  MOV     W3,389A
0606A:  CALL    25AE
.................... //  The most senstive is when Gain is set to 11b and scaler is set to 000b 
....................  
.................... 		do  
.................... 		{ 
....................  
.................... 		delay_ms(150); 
0606E:  MOV     #96,W0
06070:  CALL    21F2
....................  
.................... 		ReadColorTAOS(2,DeviceSelect);  //green 
06074:  PUSH    3892
06076:  MOV     [--W15],W4
06078:  LSR     W4,#8,W4
0607A:  SE      W4,W3
0607C:  MOV     W3,389C
0607E:  MOV     #2,W3
06080:  MOV     W3,389A
06082:  CALL    55B4
.................... 		green = colorlow + colorhigh * 256; 
06086:  MOV     2F6E,W0
06088:  MOV     #100,W4
0608A:  MUL.SS  W0,W4,W0
0608C:  MOV     2F6C,W4
0608E:  ADD     W0,W4,W0
06090:  MOV     W0,2F72
....................  
.................... 		ReadColorTAOS(1,DeviceSelect);  //red 
06092:  PUSH    3892
06094:  MOV     [--W15],W4
06096:  LSR     W4,#8,W4
06098:  SE      W4,W3
0609A:  MOV     W3,389C
0609C:  MOV     #1,W3
0609E:  MOV     W3,389A
060A0:  CALL    55B4
.................... 		red = colorlow + colorhigh * 256; 
060A4:  MOV     2F6E,W0
060A6:  MOV     #100,W4
060A8:  MUL.SS  W0,W4,W0
060AA:  MOV     2F6C,W4
060AC:  ADD     W0,W4,W0
060AE:  MOV     W0,2F70
....................  
.................... 		ReadColorTAOS(4,DeviceSelect);  //blue 
060B0:  PUSH    3892
060B2:  MOV     [--W15],W4
060B4:  LSR     W4,#8,W4
060B6:  SE      W4,W3
060B8:  MOV     W3,389C
060BA:  MOV     #4,W3
060BC:  MOV     W3,389A
060BE:  CALL    55B4
.................... 		clear = colorlow + colorhigh * 256; 
060C2:  MOV     2F6E,W0
060C4:  MOV     #100,W4
060C6:  MUL.SS  W0,W4,W0
060C8:  MOV     2F6C,W4
060CA:  ADD     W0,W4,W0
060CC:  MOV     W0,2F76
....................  
.................... 		ReadColorTAOS(3,DeviceSelect);  //blue 
060CE:  PUSH    3892
060D0:  MOV     [--W15],W4
060D2:  LSR     W4,#8,W4
060D4:  SE      W4,W3
060D6:  MOV     W3,389C
060D8:  MOV     #3,W3
060DA:  MOV     W3,389A
060DC:  CALL    55B4
.................... 		blue = colorlow + colorhigh * 256; 
060E0:  MOV     2F6E,W0
060E2:  MOV     #100,W4
060E4:  MUL.SS  W0,W4,W0
060E6:  MOV     2F6C,W4
060E8:  ADD     W0,W4,W0
060EA:  MOV     W0,2F74
....................  
.................... 	 
.................... 		if ((green == 0xFFFF) || (red == 0xFFFF) || (blue == 0xFFFF)) 
060EC:  MOV     2F72,W0
060EE:  MOV     #FFFF,W4
060F0:  CP      W4,W0
060F2:  BRA     Z,6104
060F4:  MOV     2F70,W0
060F6:  MOV     #FFFF,W4
060F8:  CP      W4,W0
060FA:  BRA     Z,6104
060FC:  MOV     2F74,W0
060FE:  MOV     #FFFF,W4
06100:  CP      W4,W0
06102:  BRA     NZ,6138
.................... 			{ 
.................... 			if (GainIn == 0) 
06104:  MOV     3892,W0
06106:  SE      W0,W0
06108:  CP0     W0
0610A:  BRA     NZ,6114
.................... 				{ 
.................... 				exitit = 0;   
0610C:  MOV     #0,W4
0610E:  MOV     W4,3894
.................... 				} 
06110:  GOTO    611E
.................... 				else 
.................... 				{ 
.................... 				GainIn--; 
06114:  MOV     3892,W0
06116:  DEC.B   W0L,W0L
06118:  PUSH    3892
0611A:  MOV.B   W0L,[W15-#2]
0611C:  POP     3892
.................... 				} 
....................  
.................... 			setTAOSGain(GainIn,DeviceSelect); //Gain and then scale 
0611E:  MOV     3892,W0
06120:  PUSH    389A
06122:  MOV.B   W0L,[W15-#2]
06124:  POP     389A
06126:  PUSH    3892
06128:  MOV     [--W15],W4
0612A:  LSR     W4,#8,W4
0612C:  SE      W4,W3
0612E:  MOV     W3,389C
06130:  CALL    23E0
.................... 			} 
06134:  GOTO    613C
.................... 			else 
.................... 			{ 
.................... 			exitit = 0;  //Exit and return the gain that is found. 
06138:  MOV     #0,W4
0613A:  MOV     W4,3894
.................... 			} 
....................  
.................... 		} 
....................  
.................... 		while (exitit == 1); 
0613C:  MOV     3894,W0
0613E:  CP      W0,#1
06140:  BRA     Z,606E
....................  
....................  
.................... //***************************************************************** 
.................... // Created December 12, 2014 
.................... // This section changes each color to an ABS color using the gainIn scales 
.................... //***************************************************************** 
....................  
.................... 		if (GainIn == 3) 
06142:  MOV     3892,W0
06144:  SE      W0,W0
06146:  CP      W0,#3
06148:  BRA     NZ,614E
.................... 			{ 
.................... 			gainMultiplyer =  1; 
0614A:  MOV     #1,W4
0614C:  MOV     W4,3896
.................... 			} 
.................... 		if (GainIn == 2) 
0614E:  MOV     3892,W0
06150:  SE      W0,W0
06152:  CP      W0,#2
06154:  BRA     NZ,615A
.................... 			{ 
.................... 			gainMultiplyer =  4; 
06156:  MOV     #4,W4
06158:  MOV     W4,3896
.................... 			} 
.................... 		if (GainIn == 1) 
0615A:  MOV     3892,W0
0615C:  SE      W0,W0
0615E:  CP      W0,#1
06160:  BRA     NZ,6166
.................... 			{ 
.................... 			gainMultiplyer =  16; 
06162:  MOV     #10,W4
06164:  MOV     W4,3896
.................... 			} 
.................... 		if (GainIn == 0) 
06166:  MOV     3892,W0
06168:  SE      W0,W0
0616A:  CP0     W0
0616C:  BRA     NZ,6172
.................... 			{ 
.................... 			gainMultiplyer =  64; 
0616E:  MOV     #40,W4
06170:  MOV     W4,3896
.................... 			} 
....................  
....................  
.................... 		redABS = (unsigned int32) red * (unsigned int32) gainMultiplyer; 
06172:  MOV     2F70,W5
06174:  MOV     #0,W6
06176:  MOV     3896,W0
06178:  MOV     #0,W1
0617A:  MOV     W0,W2
0617C:  MOV     W1,W3
0617E:  MOV     W5,W0
06180:  MOV     W6,W1
06182:  CALL    6000
06186:  MOV     W0,3084
06188:  MOV     W1,3086
.................... 		greenABS = (unsigned int32) green * (unsigned int32) gainMultiplyer; 
0618A:  MOV     2F72,W5
0618C:  MOV     #0,W6
0618E:  MOV     3896,W0
06190:  MOV     #0,W1
06192:  MOV     W0,W2
06194:  MOV     W1,W3
06196:  MOV     W5,W0
06198:  MOV     W6,W1
0619A:  CALL    6000
0619E:  MOV     W0,308C
061A0:  MOV     W1,308E
.................... 		blueABS = (unsigned int32) blue * (unsigned int32) gainMultiplyer; 
061A2:  MOV     2F74,W5
061A4:  MOV     #0,W6
061A6:  MOV     3896,W0
061A8:  MOV     #0,W1
061AA:  MOV     W0,W2
061AC:  MOV     W1,W3
061AE:  MOV     W5,W0
061B0:  MOV     W6,W1
061B2:  CALL    6000
061B6:  MOV     W0,3088
061B8:  MOV     W1,308A
.................... 		clearABS = (unsigned int32) clear * (unsigned int32) gainMultiplyer; 
061BA:  MOV     2F76,W5
061BC:  MOV     #0,W6
061BE:  MOV     3896,W0
061C0:  MOV     #0,W1
061C2:  MOV     W0,W2
061C4:  MOV     W1,W3
061C6:  MOV     W5,W0
061C8:  MOV     W6,W1
061CA:  CALL    6000
061CE:  MOV     W0,3090
061D0:  MOV     W1,3092
....................  
.................... 		return(GainIn); 
061D2:  MOV     3892,W0
061D4:  MOV.B   W0L,0
061D6:  BRA     6304
....................  
....................  
.................... //******************************************************** 
.................... //Exit the routine but not before giving scaled numbers out. 
.................... // Created May 6, 2014 
.................... // Scalered, scaleblue and scalegreen are 32 bit intergers 
.................... //******************************************************** 
....................  
.................... 		}	 
061D8:  GOTO    6300
.................... 		else   // this returns the measurement of the specificed gains. 
.................... 		{ 
.................... 		setTAOSGain(GainIn,DeviceSelect); //Gain and then scale 
061DC:  MOV     3892,W0
061DE:  PUSH    389A
061E0:  MOV.B   W0L,[W15-#2]
061E2:  POP     389A
061E4:  PUSH    3892
061E6:  MOV     [--W15],W4
061E8:  LSR     W4,#8,W4
061EA:  SE      W4,W3
061EC:  MOV     W3,389C
061EE:  CALL    23E0
.................... 		ReadColorTAOS(2,DeviceSelect);  //green 
061F2:  PUSH    3892
061F4:  MOV     [--W15],W4
061F6:  LSR     W4,#8,W4
061F8:  SE      W4,W3
061FA:  MOV     W3,389C
061FC:  MOV     #2,W3
061FE:  MOV     W3,389A
06200:  CALL    55B4
.................... 		green = colorlow + colorhigh * 256; 
06204:  MOV     2F6E,W0
06206:  MOV     #100,W4
06208:  MUL.SS  W0,W4,W0
0620A:  MOV     2F6C,W4
0620C:  ADD     W0,W4,W0
0620E:  MOV     W0,2F72
....................  
.................... 		ReadColorTAOS(1,DeviceSelect);  //red 
06210:  PUSH    3892
06212:  MOV     [--W15],W4
06214:  LSR     W4,#8,W4
06216:  SE      W4,W3
06218:  MOV     W3,389C
0621A:  MOV     #1,W3
0621C:  MOV     W3,389A
0621E:  CALL    55B4
.................... 		red = colorlow + colorhigh * 256; 
06222:  MOV     2F6E,W0
06224:  MOV     #100,W4
06226:  MUL.SS  W0,W4,W0
06228:  MOV     2F6C,W4
0622A:  ADD     W0,W4,W0
0622C:  MOV     W0,2F70
....................  
.................... 		ReadColorTAOS(4,DeviceSelect);  //clear 
0622E:  PUSH    3892
06230:  MOV     [--W15],W4
06232:  LSR     W4,#8,W4
06234:  SE      W4,W3
06236:  MOV     W3,389C
06238:  MOV     #4,W3
0623A:  MOV     W3,389A
0623C:  CALL    55B4
.................... 		clear = colorlow + colorhigh * 256; 
06240:  MOV     2F6E,W0
06242:  MOV     #100,W4
06244:  MUL.SS  W0,W4,W0
06246:  MOV     2F6C,W4
06248:  ADD     W0,W4,W0
0624A:  MOV     W0,2F76
....................  
.................... 		ReadColorTAOS(3,DeviceSelect);  //blue 
0624C:  PUSH    3892
0624E:  MOV     [--W15],W4
06250:  LSR     W4,#8,W4
06252:  SE      W4,W3
06254:  MOV     W3,389C
06256:  MOV     #3,W3
06258:  MOV     W3,389A
0625A:  CALL    55B4
.................... 		blue = colorlow + colorhigh * 256; 
0625E:  MOV     2F6E,W0
06260:  MOV     #100,W4
06262:  MUL.SS  W0,W4,W0
06264:  MOV     2F6C,W4
06266:  ADD     W0,W4,W0
06268:  MOV     W0,2F74
....................  
.................... //***************************************************************** 
.................... // Created December 12, 2014 
.................... // This section changes each color to an ABS color using the gainIn scales 
.................... //***************************************************************** 
....................  
.................... 		if (GainIn == 0) 
0626A:  MOV     3892,W0
0626C:  SE      W0,W0
0626E:  CP0     W0
06270:  BRA     NZ,6276
.................... 			{ 
.................... 			gainMultiplyer =  1; 
06272:  MOV     #1,W4
06274:  MOV     W4,3896
.................... 			} 
.................... 		if (GainIn == 1) 
06276:  MOV     3892,W0
06278:  SE      W0,W0
0627A:  CP      W0,#1
0627C:  BRA     NZ,6282
.................... 			{ 
.................... 			gainMultiplyer =  4; 
0627E:  MOV     #4,W4
06280:  MOV     W4,3896
.................... 			} 
.................... 		if (GainIn == 2) 
06282:  MOV     3892,W0
06284:  SE      W0,W0
06286:  CP      W0,#2
06288:  BRA     NZ,628E
.................... 			{ 
.................... 			gainMultiplyer =  16; 
0628A:  MOV     #10,W4
0628C:  MOV     W4,3896
.................... 			} 
.................... 		if (GainIn == 3) 
0628E:  MOV     3892,W0
06290:  SE      W0,W0
06292:  CP      W0,#3
06294:  BRA     NZ,629A
.................... 			{ 
.................... 			gainMultiplyer =  64; 
06296:  MOV     #40,W4
06298:  MOV     W4,3896
.................... 			} 
....................  
....................  
.................... 		redABS = (unsigned int32) red * (unsigned int32) gainMultiplyer; 
0629A:  MOV     2F70,W5
0629C:  MOV     #0,W6
0629E:  MOV     3896,W0
062A0:  MOV     #0,W1
062A2:  MOV     W0,W2
062A4:  MOV     W1,W3
062A6:  MOV     W5,W0
062A8:  MOV     W6,W1
062AA:  CALL    6000
062AE:  MOV     W0,3084
062B0:  MOV     W1,3086
.................... 		greenABS = (unsigned int32) green * (unsigned int32) gainMultiplyer; 
062B2:  MOV     2F72,W5
062B4:  MOV     #0,W6
062B6:  MOV     3896,W0
062B8:  MOV     #0,W1
062BA:  MOV     W0,W2
062BC:  MOV     W1,W3
062BE:  MOV     W5,W0
062C0:  MOV     W6,W1
062C2:  CALL    6000
062C6:  MOV     W0,308C
062C8:  MOV     W1,308E
.................... 		blueABS = (unsigned int32) blue * (unsigned int32) gainMultiplyer; 
062CA:  MOV     2F74,W5
062CC:  MOV     #0,W6
062CE:  MOV     3896,W0
062D0:  MOV     #0,W1
062D2:  MOV     W0,W2
062D4:  MOV     W1,W3
062D6:  MOV     W5,W0
062D8:  MOV     W6,W1
062DA:  CALL    6000
062DE:  MOV     W0,3088
062E0:  MOV     W1,308A
.................... 		clearABS = (unsigned int32) clear * (unsigned int32) gainMultiplyer; 
062E2:  MOV     2F76,W5
062E4:  MOV     #0,W6
062E6:  MOV     3896,W0
062E8:  MOV     #0,W1
062EA:  MOV     W0,W2
062EC:  MOV     W1,W3
062EE:  MOV     W5,W0
062F0:  MOV     W6,W1
062F2:  CALL    6000
062F6:  MOV     W0,3090
062F8:  MOV     W1,3092
....................  
.................... 		return(GainIn); 
062FA:  MOV     3892,W0
062FC:  MOV.B   W0L,0
062FE:  BRA     6304
....................  
.................... 		} 
....................  
.................... return(GainIn); 
06300:  MOV     3892,W0
06302:  MOV.B   W0L,0
06304:  MOV     [--W15],W6
06306:  MOV     [--W15],W5
06308:  RETURN  
.................... 	} 
....................  
....................  
....................  
.................... //******************************************************************************************* 
.................... // Created Nov 23, 2014 
.................... //  This takes severla color readings and then averages them together.  This is a direct drop in 
.................... // for the current "int8 GetCurrentColor(int8 GainIn, int8 DeviceSelect)" 
.................... // Retuens the gain and the returned value is in the global varaibles called 
.................... // red, green , blue and clear. 
.................... //******************************************************************************************* 
.................... int8 GetCurrentColorAVG(int8 GainIn, int8 DeviceSelect) 
*
06382:  MOV     W5,[W15++]
06384:  MOV     W6,[W15++]
*
063AE:  MOV     #14,W4
063B0:  MOV     W4,388C
.................... 	{ 
.................... float tempred, tempblue, tempgreen, tempclear;   //These are the averaging varaibles used for internal to the averaging calculations 
*
06386:  MOV     #0,W4
06388:  MOV     W4,3878
0638A:  MOV     #0,W4
0638C:  MOV     W4,387A
0638E:  MOV     #0,W4
06390:  MOV     W4,387C
06392:  MOV     #0,W4
06394:  MOV     W4,387E
06396:  MOV     #0,W4
06398:  MOV     W4,3880
0639A:  MOV     #0,W4
0639C:  MOV     W4,3882
0639E:  MOV     #0,W4
063A0:  MOV     W4,3884
063A2:  MOV     #0,W4
063A4:  MOV     W4,3886
.................... int x,GainOut,averagesamples = 20; 
063A6:  MOV     #0,W4
063A8:  MOV     W4,3888
063AA:  MOV     #0,W4
063AC:  MOV     W4,388A
.................... unsigned int gainMultiplyer; 
*
063B2:  MOV     #0,W4
063B4:  MOV     W4,388E
....................  
.................... 	tempred = 0.0; 
063B6:  MOV     #0,W4
063B8:  MOV     W4,3878
063BA:  MOV     #0,W4
063BC:  MOV     W4,387A
.................... 	tempblue = 0.0; 
063BE:  MOV     #0,W4
063C0:  MOV     W4,387C
063C2:  MOV     #0,W4
063C4:  MOV     W4,387E
.................... 	tempgreen = 0.0; 
063C6:  MOV     #0,W4
063C8:  MOV     W4,3880
063CA:  MOV     #0,W4
063CC:  MOV     W4,3882
.................... 	tempclear = 0.0; 
063CE:  MOV     #0,W4
063D0:  MOV     W4,3884
063D2:  MOV     #0,W4
063D4:  MOV     W4,3886
.................... 	for (x = 0; x <= averagesamples; x++) 
063D6:  MOV     #0,W4
063D8:  MOV     W4,3888
063DA:  MOV     3888,W0
063DC:  MOV     388C,W4
063DE:  CP      W4,W0
063E0:  BRA     LT,64F8
.................... 		{ 
.................... 		GainOut = GetCurrentColor(GainIn, DeviceSelect); 
063E2:  MOV     3876,W0
063E4:  PUSH    3892
063E6:  MOV.B   W0L,[W15-#2]
063E8:  POP     3892
063EA:  PUSH    3876
063EC:  MOV     [--W15],W0
063EE:  LSR     W0,#8,W0
063F0:  PUSH    3892
063F2:  MOV.B   W0L,[W15-#1]
063F4:  POP     3892
063F6:  CALL    6030
063FA:  SE      W0,W0
063FC:  MOV     W0,388A
....................  
....................  
.................... //***************************************************************** 
.................... // Created December 12, 2014 
.................... // This section changes each color to an ABS color using the gainIn scales 
.................... //***************************************************************** 
....................  
.................... 		if (GainOut == 3) 
063FE:  MOV     388A,W0
06400:  CP      W0,#3
06402:  BRA     NZ,6408
.................... 			{ 
.................... 			gainMultiplyer =  1; 
06404:  MOV     #1,W4
06406:  MOV     W4,388E
.................... 			} 
.................... 		if (GainOut == 2) 
06408:  MOV     388A,W0
0640A:  CP      W0,#2
0640C:  BRA     NZ,6412
.................... 			{ 
.................... 			gainMultiplyer =  4; 
0640E:  MOV     #4,W4
06410:  MOV     W4,388E
.................... 			} 
.................... 		if (GainOut == 1) 
06412:  MOV     388A,W0
06414:  CP      W0,#1
06416:  BRA     NZ,641C
.................... 			{ 
.................... 			gainMultiplyer =  16; 
06418:  MOV     #10,W4
0641A:  MOV     W4,388E
.................... 			} 
.................... 		if (GainOut == 0) 
0641C:  MOV     388A,W0
0641E:  CP0     W0
06420:  BRA     NZ,6426
.................... 			{ 
.................... 			gainMultiplyer =  64; 
06422:  MOV     #40,W4
06424:  MOV     W4,388E
.................... 			} 
....................  
....................  
.................... 		redABS = (unsigned int32) red * (unsigned int32) gainMultiplyer; 
06426:  MOV     2F70,W5
06428:  MOV     #0,W6
0642A:  MOV     388E,W0
0642C:  MOV     #0,W1
0642E:  MOV     W0,W2
06430:  MOV     W1,W3
06432:  MOV     W5,W0
06434:  MOV     W6,W1
06436:  CALL    6000
0643A:  MOV     W0,3084
0643C:  MOV     W1,3086
.................... 		greenABS = (unsigned int32) green * (unsigned int32) gainMultiplyer; 
0643E:  MOV     2F72,W5
06440:  MOV     #0,W6
06442:  MOV     388E,W0
06444:  MOV     #0,W1
06446:  MOV     W0,W2
06448:  MOV     W1,W3
0644A:  MOV     W5,W0
0644C:  MOV     W6,W1
0644E:  CALL    6000
06452:  MOV     W0,308C
06454:  MOV     W1,308E
.................... 		blueABS = (unsigned int32) blue * (unsigned int32) gainMultiplyer; 
06456:  MOV     2F74,W5
06458:  MOV     #0,W6
0645A:  MOV     388E,W0
0645C:  MOV     #0,W1
0645E:  MOV     W0,W2
06460:  MOV     W1,W3
06462:  MOV     W5,W0
06464:  MOV     W6,W1
06466:  CALL    6000
0646A:  MOV     W0,3088
0646C:  MOV     W1,308A
.................... 		clearABS = (unsigned int32) clear * (unsigned int32) gainMultiplyer; 
0646E:  MOV     2F76,W5
06470:  MOV     #0,W6
06472:  MOV     388E,W0
06474:  MOV     #0,W1
06476:  MOV     W0,W2
06478:  MOV     W1,W3
0647A:  MOV     W5,W0
0647C:  MOV     W6,W1
0647E:  CALL    6000
06482:  MOV     W0,3090
06484:  MOV     W1,3092
....................  
....................  
.................... 		tempred = tempred + (float) redABS; 
06486:  MOV     3084,W0
06488:  MOV     3086,W1
0648A:  CALL    630A
0648E:  BCLR.B  43.0
06490:  MOV     W0,W2
06492:  MOV     W1,W3
06494:  MOV     3878,W0
06496:  MOV     387A,W1
06498:  CALL    478A
0649C:  MOV     W0,3878
0649E:  MOV     W1,387A
.................... 		tempblue = tempblue + (float) blueABS; 
064A0:  MOV     3088,W0
064A2:  MOV     308A,W1
064A4:  CALL    630A
064A8:  BCLR.B  43.0
064AA:  MOV     W0,W2
064AC:  MOV     W1,W3
064AE:  MOV     387C,W0
064B0:  MOV     387E,W1
064B2:  CALL    478A
064B6:  MOV     W0,387C
064B8:  MOV     W1,387E
.................... 		tempgreen = tempgreen + (float) greenABS; 
064BA:  MOV     308C,W0
064BC:  MOV     308E,W1
064BE:  CALL    630A
064C2:  BCLR.B  43.0
064C4:  MOV     W0,W2
064C6:  MOV     W1,W3
064C8:  MOV     3880,W0
064CA:  MOV     3882,W1
064CC:  CALL    478A
064D0:  MOV     W0,3880
064D2:  MOV     W1,3882
.................... 		tempclear = tempclear + (float) clearABS; 
064D4:  MOV     3090,W0
064D6:  MOV     3092,W1
064D8:  CALL    630A
064DC:  BCLR.B  43.0
064DE:  MOV     W0,W2
064E0:  MOV     W1,W3
064E2:  MOV     3884,W0
064E4:  MOV     3886,W1
064E6:  CALL    478A
064EA:  MOV     W0,3884
064EC:  MOV     W1,3886
064EE:  MOV     3888,W0
064F0:  INC     W0,W0
064F2:  MOV     W0,3888
064F4:  GOTO    63DA
.................... 		} 
.................... 	tempred = tempred/20.0; 
064F8:  MOV     3878,W0
064FA:  MOV     387A,W1
064FC:  MOV     #0,W2
064FE:  MOV     #41A0,W3
06500:  CALL    4530
06504:  MOV     W0,3878
06506:  MOV     W1,387A
.................... 	tempblue = tempblue/20.0; 
06508:  MOV     387C,W0
0650A:  MOV     387E,W1
0650C:  MOV     #0,W2
0650E:  MOV     #41A0,W3
06510:  CALL    4530
06514:  MOV     W0,387C
06516:  MOV     W1,387E
.................... 	tempgreen = tempgreen/20.0; 
06518:  MOV     3880,W0
0651A:  MOV     3882,W1
0651C:  MOV     #0,W2
0651E:  MOV     #41A0,W3
06520:  CALL    4530
06524:  MOV     W0,3880
06526:  MOV     W1,3882
.................... 	tempclear = tempclear/20.0; 
06528:  MOV     3884,W0
0652A:  MOV     3886,W1
0652C:  MOV     #0,W2
0652E:  MOV     #41A0,W3
06530:  CALL    4530
06534:  MOV     W0,3884
06536:  MOV     W1,3886
.................... 	redABS = (unsigned int32) tempred; 
06538:  MOV     3878,W0
0653A:  MOV     387A,W1
0653C:  CALL    6342
06540:  MOV     W0,3084
06542:  MOV     W1,3086
.................... 	blueABS = (unsigned int32) tempblue; 
06544:  MOV     387C,W0
06546:  MOV     387E,W1
06548:  CALL    6342
0654C:  MOV     W0,3088
0654E:  MOV     W1,308A
.................... 	greenABS = (unsigned int32) tempgreen; 
06550:  MOV     3880,W0
06552:  MOV     3882,W1
06554:  CALL    6342
06558:  MOV     W0,308C
0655A:  MOV     W1,308E
.................... 	clearABS = (unsigned int32) tempclear; 
0655C:  MOV     3884,W0
0655E:  MOV     3886,W1
06560:  CALL    6342
06564:  MOV     W0,3090
06566:  MOV     W1,3092
....................  
....................  
.................... 	return(GainOut); 
06568:  MOV     388A,W0
0656A:  MOV.B   W0L,0
0656C:  MOV     [--W15],W6
0656E:  MOV     [--W15],W5
06570:  RETURN  
.................... 	} 
....................  
....................  
....................  
.................... //***************************************************************************************** 
.................... // Created April 27, 2014 
.................... //This routine inits all of the slave I2C where they have a gain of 1 and start with no ND filteration 
.................... //***************************************************************************************** 
.................... void InitTAOS(void) 
*
02652:  MOV     3802,W0
02654:  MOV.B   #0,W0L
02656:  MOV     W0,3802
.................... { 
....................  
.................... int8 gain = 0; 
....................  
....................  
....................  
.................... setTAOSGain(gain,1); //Gain and then scale 
02658:  MOV     3802,W0
0265A:  PUSH    389A
0265C:  MOV.B   W0L,[W15-#2]
0265E:  POP     389A
02660:  MOV     #1,W4
02662:  MOV     W4,389C
02664:  CALL    23E0
.................... setTAOSGain(gain,2); //Gain and then scale 
02668:  MOV     3802,W0
0266A:  PUSH    389A
0266C:  MOV.B   W0L,[W15-#2]
0266E:  POP     389A
02670:  MOV     #2,W4
02672:  MOV     W4,389C
02674:  CALL    23E0
.................... setTAOSGain(gain,3); //Gain and then scale 
02678:  MOV     3802,W0
0267A:  PUSH    389A
0267C:  MOV.B   W0L,[W15-#2]
0267E:  POP     389A
02680:  MOV     #3,W4
02682:  MOV     W4,389C
02684:  CALL    23E0
.................... ExposureTimeTAOS(1,1); 
02688:  MOV     3804,W0
0268A:  MOV.B   #1,W0L
0268C:  MOV     W0,3804
0268E:  MOV     3804,W0
02690:  SWAP    W0
02692:  MOV.B   #1,W0L
02694:  SWAP    W0
02696:  MOV     W0,3804
02698:  CALL    24F8
.................... ExposureTimeTAOS(1,2); 
0269C:  MOV     3804,W0
0269E:  MOV.B   #1,W0L
026A0:  MOV     W0,3804
026A2:  MOV     3804,W0
026A4:  SWAP    W0
026A6:  MOV.B   #2,W0L
026A8:  SWAP    W0
026AA:  MOV     W0,3804
026AC:  CALL    24F8
.................... ExposureTimeTAOS(1,3); 
026B0:  MOV     3804,W0
026B2:  MOV.B   #1,W0L
026B4:  MOV     W0,3804
026B6:  MOV     3804,W0
026B8:  SWAP    W0
026BA:  MOV.B   #3,W0L
026BC:  SWAP    W0
026BE:  MOV     W0,3804
026C0:  CALL    24F8
.................... StartUpTAOS(1); 
026C4:  MOV     #1,W4
026C6:  MOV     W4,389A
026C8:  CALL    25AE
.................... StartUpTAOS(2); 
026CC:  MOV     #2,W4
026CE:  MOV     W4,389A
026D0:  CALL    25AE
.................... StartUpTAOS(3); 
026D4:  MOV     #3,W4
026D6:  MOV     W4,389A
026D8:  CALL    25AE
026DC:  RETURN  
....................  
....................  
....................  
.................... } 
....................  
.................... //***************************************************************************************** 
.................... // Created May 19, 2014 
.................... // This rouine takes the inputs of each light sensor and returns the magic number for PWM in the 
.................... // center of the light readings.  The gain is assumed for 2 and the light intensity has to be  
.................... //  between 32000 and 40000. 
.................... //  The inputs are as follows: 
.................... //  int PWM channel 
.................... //  int Sensor channel  Number 1 is Do and number 2 is pH 
.................... //  The function returns the PWM that works the best. 
.................... // This routine is called during calibration when there is no patch in place.  This may be done 
.................... //  only the first time the system is put together or may gave to be done all the time.  Don't know. 
.................... //**************************************************************************************** 
.................... int16 FindMiddlePWMSensor(int PWMChannel, int SensorChannel) 
.................... { 
.................... int16 PWMCommand, CommandInput;   //This is the PWM command under test.  Just return where is finds the requires sensor numbers. 
.................... int color; 
.................... char uffit[40]; 
.................... //  Just loop through all of the PWM states and find that ones that meet the light sensitivity.  No PID is required. 
....................  
.................... 	pwm_set_duty(DO_PWM,0x0);	//250hz  Turn off light for DO 
.................... 	pwm_set_duty(PH_PWM,0x0);	//250hz 
....................  
.................... if (SensorChannel == 1) 
.................... 	{ 
.................... 	for (PWMCommand=0; PWMCommand <= 0x6638; PWMCommand +=0) 
.................... 			{ 
....................     	CommandInput = 0x6638-PWMCommand; 
.................... 		pwm_set_duty(DO_PWM,CommandInput);  //Change the PWM to the last set reading for the PWM.  This prevent the LED from flashing brightly before stablizing 
....................     	delay_us(100); 
.................... 			sprintf(uffit,"blue PWM %Lu ",CommandInput); 
.................... 			Display_XYString(1, 4, &uffit); 
....................    			color = GetCurrentColor(4, 1);   // //Device 1 is the  
.................... 			sprintf(uffit,"color %Lu %Lu",blueABS,color); 
.................... 			Display_XYString(1, 3, &uffit); 
.................... 			sprintf(uffit,"red color %Lu ",redABS); 
.................... 			Display_XYString(1, 2, &uffit); 
....................  
....................  			if (color == 3 && blue > 27000 && blue < 33000) 
.................... 				{ 
.................... 				sprintf(uffit,"blue  %Lu  %Lu",blueABS,CommandInput); 
.................... 				Display_XYString(0, 1, &uffit); 
.................... 				pwm_set_duty(DO_PWM,0x0);   //this shuts off the light. 
.................... 				return(PWMCommand); 
.................... 				}   
.................... 			} 
.................... 	} 
....................  
.................... if (SensorChannel == 2) 
.................... 	{ 
.................... 	for (PWMCommand=0; PWMCommand <= 0xFF00; PWMCommand +=0) 
.................... 		{ 
....................     	CommandInput = 0x5F00-PWMCommand; 
.................... 		pwm_set_duty(PH_PWM,CommandInput);  //Change the PWM to the last set reading for the PWM.  This prevent the LED from flashing brightly before stablizing 
....................     	delay_us(100); 
.................... 			sprintf(uffit,"white PWM %Lu ",CommandInput); 
.................... 			Display_XYString(1, 4, &uffit); 
....................    			color = GetCurrentColor(4, 2);   // //Device 2 is the pH 
.................... //			sprintf(uffit,"color %Lu",blueABS); 
.................... 			calculateCoordinate(); 
.................... 			sprintf(uffit,"y %e",y); 
.................... 			Display_XYString(1, 3, &uffit); 
.................... 			sprintf(uffit,"x %e",x); 
.................... 			Display_XYString(1, 2, &uffit); 
....................  
.................... 			 
....................    			color = GetCurrentColor(4, 2);   // Number 2 is the blue PWM LED 
....................  			if (clearABS > 700000 && clearABS < 900000) 
.................... 				{ 
.................... 				sprintf(uffit,"clear  %Lu  %Lu",clearABS,CommandInput); 
.................... 				Display_XYString(0, 1, &uffit); 
.................... 				pwm_set_duty(PH_PWM,0x0);   //this shuts off the light. 
.................... 				return(PWMCommand); 
.................... 				}   
.................... 			} 
.................... 	} 
....................  
....................  
....................  
.................... return(PWMCommand); 
.................... } 
....................  
....................  
....................  
.................... //***************************************************************************************************** 
.................... // Created May 19, 2014 
.................... // Completed May 23, 2014 
.................... // This routine reads the data from the DO or pH.  This is includeing the pre-deteremined gains 
.................... // The inputs are as following: 
.................... // PWM input channel 
.................... //  The PWM magic number 
.................... // the channel sensor input channel    
.................... // DO is sensor 1 
....................  
.................... // SensprControl is  a number between 1 to 3 for each I2C 
.................... // PWMIntensity  this is the general starting point for the PWM 
.................... //  RequiredReading  - this is the required light reading needed to make a measurement.  THE PID will converg on this number. 
.................... //  Use the Pgain in the routine below to control the quickness of convergance. 
.................... //  the result is an unsigned 16 bit interger. 
.................... //***************************************************************************************************** 
.................... float TakeLightReading(int SensorChannel, unsigned int16 PWMIntensity, unsigned int16 RequiredReading) 
.................... { 
....................  
.................... int color,attemptcounter, attempts; 
.................... int32 result;  //This is the result of the calculation.  This is returned to the calling function. 
....................  
.................... float DOReading,pgain,tempoffset,PHReading; 
.................... char uffit[60]; 
.................... int32 readingrange = 100; 
.................... unsigned int32 difference; 
....................  
.................... unsigned int32 upperlimit = RequiredReading + readingrange; 
.................... unsigned int32 lowerlimit = RequiredReading - readingrange; 
.................... //***************************************************************************** 
.................... //Created Nov 15, 2014 
.................... //This section sets the PWM for the requied feedback for light driver and sensor dirt measurement drift. 
.................... //***************************************************************************** 
.................... // Set the light with in a specification range 
....................  
.................... attempts =  200;  //This is the number of attemps to get the color correct. 
....................  
.................... if (SensorChannel == 1) 
.................... 	{ 
.................... 	pwm_set_duty(DO_PWM,PWMIntensity);  
.................... 	delay_ms(25); 
.................... 	attemptcounter = 0; 
.................... 	color = GetCurrentColorAVG(4, 1);   // Number 1 is the blue DO PWM LED.  The 4 means it any gain reading 
.................... 	pgain = 0.0125;   //This the propotional gain for the PID loop. 
.................... 	redABS = redABS - AmbientOxyRed; 
.................... 	greenABS = greenABS - AmbientOxyGreen; 
.................... 	blueABS = blueABS - AmbientOxyBlue; 
.................... 	clearABS = clearABS - AmbientOxyClear; 
....................  
.................... while (((blueABS < lowerlimit) || (blueABS > upperlimit)) && (attemptcounter < attempts))   // If it is in range, then exit.  If not in range, adjest and try again. 
.................... 	{ 
....................  
.................... 	if (RequiredReading < blueABS) 
.................... 		{ 
.................... 		difference = blueABS - (unsigned int32) RequiredReading; 
.................... 		tempoffset = pgain * (float) difference; 
.................... 		difference =  (unsigned int32) tempoffset; 
.................... 		PWMIntensity = PWMIntensity + (int16) difference;   //This inverted.  As the PWM number goes down, the light goes up. 
.................... 		} 
.................... 		else 
.................... 		{ 
.................... 		difference = (unsigned int32) RequiredReading - blueABS; 
.................... 		tempoffset = pgain * (float) difference; 
.................... 		difference =  (unsigned int32) tempoffset; 
.................... 		PWMIntensity = PWMIntensity - (int16) difference;   //This inverted.  As the PWM number goes down, the light goes up. 
.................... 		} 
.................... 	pwm_set_duty(DO_PWM,PWMIntensity);  
.................... 	attemptcounter++; 
.................... 	delay_ms(25); 
.................... 	color = GetCurrentColorAVG(4, 1);   // Number 1 is the blue DO PWM LED.  The 4 means it any gain reading 
.................... 	redABS = redABS - AmbientOxyRed; 
.................... 	greenABS = greenABS - AmbientOxyGreen; 
.................... 	blueABS = blueABS - AmbientOxyBlue; 
.................... 	clearABS = clearABS - AmbientOxyClear; 
.................... 				sprintf(uffit,"B %Lu Red %Lu PW %Lu  ", blueABS, redABS,PWMIntensity); 
.................... 				Display_XYString(0, 1, &uffit); 
.................... 	} 
.................... PWMDOIntensity = PWMIntensity;  //Save the last PWM intensirty for the next go a round. 
.................... 	} 
....................  
....................  
.................... //***************************************************************************** 
.................... //Created Nov 17, 2014 
.................... //This section sets the PWM for the requied feedback for light driver and sensor dirt measurement drift for the pH. 
.................... //***************************************************************************** 
.................... // Set the light with in a specification range 
.................... if (SensorChannel == 2) 
.................... 	{ 
.................... 	pwm_set_duty(PH_PWM,PWMIntensity);  
.................... 	delay_ms(25); 
.................... 	attemptcounter = 0; 
.................... 	color = GetCurrentColorAVG(4, 2);   // Number 1 is the blue DO PWM LED.  The 4 means it any gain reading 
.................... 	pgain = 0.125;   //This the propotional gain for the PID loop. 
.................... 	redABS = redABS - AmbientPHRed; 
.................... 	greenABS = greenABS - AmbientPHGreen; 
.................... 	blueABS = blueABS - AmbientPHBlue; 
.................... 	clearABS = clearABS - AmbientPHClear; 
....................  
.................... while (((greenABS < lowerlimit) || (greenABS > upperlimit)) && (attemptcounter < attempts))   // If it is in range, then exit.  If not in range, adjest and try again. 
.................... 	{ 
....................  
.................... 	if (RequiredReading < blueABS) 
.................... 		{ 
.................... 		difference = greenABS - RequiredReading; 
.................... 		tempoffset = pgain * (float) difference; 
.................... 		difference =  (unsigned int32) tempoffset; 
.................... 		PWMIntensity = PWMIntensity + (int16) difference;   //This inverted.  As the PWM number goes down, the light goes up. 
.................... 		} 
.................... 		else 
.................... 		{ 
.................... 		difference = RequiredReading - greenABS; 
.................... 		tempoffset = pgain * (float) difference; 
.................... 		difference =  (unsigned int32) tempoffset; 
.................... 		PWMIntensity = PWMIntensity - (int16) difference;   //This inverted.  As the PWM number goes down, the light goes up. 
.................... 		} 
.................... 	pwm_set_duty(PH_PWM,PWMIntensity);  
.................... 	attemptcounter++; 
.................... 	delay_ms(25); 
.................... 	color = GetCurrentColorAVG(4, 2);   // Number 1 is the blue DO PWM LED.  The 4 means it any gain reading 
.................... 	redABS = redABS - AmbientPHRed; 
.................... 	greenABS = greenABS - AmbientPHGreen; 
.................... 	blueABS = blueABS - AmbientPHBlue; 
.................... 	clearABS = clearABS - AmbientPHClear; 
....................  
.................... 				sprintf(uffit,"B %Lu G %Lu Red %Lu PW %Lu  ", blueABS, greenABS, redABS, PWMIntensity ); 
.................... 				Display_XYString(0, 3, &uffit); 
.................... 	} 
.................... PWMPHIntensity = PWMIntensity; 
....................  }    
....................  
....................  
.................... //Take the reading for real 
....................  
.................... switch (SensorChannel) 
.................... 	{ 
.................... 	case 1:  //This is the DO Sensor 
....................      //   delay_ms(25);  //Delay to stablize PWM 
.................... 		color = GetCurrentColorAVG(4, 1);   // Number 0 is the red PWM LED 
.................... 	    pwm_set_duty(DO_PWM,0x0);	//250hz  Turn off light for DO 
....................   
....................   
.................... 	redABS = redABS - AmbientOxyRed; 
.................... 	greenABS = greenABS - AmbientOxyGreen; 
.................... 	blueABS = blueABS - AmbientOxyBlue; 
.................... 	clearABS = clearABS - AmbientOxyClear; 
....................  
.................... 		DOReading =  CalcaulateDO(redABS,21.0);  //This holds the color intensity variable and the temperature in degrees C. 
....................  
.................... 		delay_ms(1000); 
....................  
.................... 		//		sprintf(uffit,"RED %Lu DO %f  ", red,DOReading); 
.................... 	//			Display_XYString(0, 2, &uffit); 
....................  
.................... 		return(DOReading);  //Return result. 
.................... 		break; 
.................... 	case 2:  //This is the pH Sensor 
....................     //    delay_ms(1000);  //Delay to stablize PWM 
.................... 		color = GetCurrentColorAVG(4, 2);   // Number 0 is the red PWM LED 
.................... 		pwm_set_duty(PH_PWM,0xFFFF);  
....................  
.................... 	redABS = redABS - AmbientPHRed; 
.................... 	greenABS = greenABS - AmbientPHGreen; 
.................... 	blueABS = blueABS - AmbientPHBlue; 
.................... 	clearABS = clearABS - AmbientPHClear; 
....................  
.................... 		PHReading = CalcaulatepH(redABS);  // Take the red reading and calcualte the pH 
....................  
....................  
....................         delay_ms(1000); 
....................  
.................... 		//		sprintf(uffit,"RED  %Lu pH %f  ", red,PHReading); 
.................... 		//		Display_XYString(0, 4, &uffit); 
....................  
.................... 		return(PHReading);  //Return result. 
.................... 		break; 
....................  
.................... 	default: 
.................... 		break; 
.................... 	} 
.................... //result = (int) color * red;   //This is the result in 32 bit form for absolute intensity. 
.................... //result = 200;   // Added June 3, 2014 for temp value before doing a real calibration. 
.................... return(result);  //Return result. 
.................... } 
....................  
.................... //*************************************************************************************** 
.................... // Created Dec. 8, 2014 
.................... // This routine find the ambiant light and saves it as global variables for ph and DO routines to use. 
.................... //  The input is the selected sensor with the LED turned off.  The results are saved. 
.................... // Changed December 12, 2014 
.................... //  Removed the averaging part of the program and used the GetCurrentColorABS program instead 
.................... //  It has twice as many reading for averaging. 
.................... //*************************************************************************************** 
.................... void FindAmbientLight(int DeviceSelect) 
.................... 	{ 
....................  
....................  
....................  
.................... 		GetCurrentColorAVG(4,DeviceSelect); 
*
06572:  MOV     3876,W0
06574:  MOV.B   #4,W0L
06576:  MOV     W0,3876
06578:  MOV     3872,W0
0657A:  PUSH    3876
0657C:  MOV.B   W0L,[W15-#1]
0657E:  POP     3876
06580:  CALL    6382
....................  
.................... 	if (DeviceSelect == 1)   //Setup the OXyegen offsets. 
06584:  MOV     3872,W0
06586:  CP      W0,#1
06588:  BRA     NZ,65AA
.................... 		{ 
.................... 		AmbientOxyRed = redABS; 
0658A:  PUSH    3084
0658C:  POP     3064
0658E:  PUSH    3086
06590:  POP     3066
.................... 		AmbientOxyGreen = greenABS; 
06592:  PUSH    308C
06594:  POP     3068
06596:  PUSH    308E
06598:  POP     306A
.................... 		AmbientOxyBlue = blueABS; 
0659A:  PUSH    3088
0659C:  POP     306C
0659E:  PUSH    308A
065A0:  POP     306E
.................... 		AmbientOxyClear = clearABS; 
065A2:  PUSH    3090
065A4:  POP     3070
065A6:  PUSH    3092
065A8:  POP     3072
.................... 		} 
....................  
.................... 	if (DeviceSelect == 2)  //Setup the PH offsets. 
065AA:  MOV     3872,W0
065AC:  CP      W0,#2
065AE:  BRA     NZ,65D0
.................... 		{ 
.................... 		AmbientPHRed = redABS; 
065B0:  PUSH    3084
065B2:  POP     3074
065B4:  PUSH    3086
065B6:  POP     3076
.................... 		AmbientPHGreen = greenABS; 
065B8:  PUSH    308C
065BA:  POP     3078
065BC:  PUSH    308E
065BE:  POP     307A
.................... 		AmbientPHBlue = blueABS; 
065C0:  PUSH    3088
065C2:  POP     307C
065C4:  PUSH    308A
065C6:  POP     307E
.................... 		AmbientPHClear = clearABS; 
065C8:  PUSH    3090
065CA:  POP     3080
065CC:  PUSH    3092
065CE:  POP     3082
.................... 		} 
065D0:  RETURN  
....................  
.................... 	} 
....................  
....................  
.................... //***************************************************************************************** 
.................... // Created Febuary 11, 2015 
.................... // This routine calculates the pH from the guys in WA.  It takes finds the x and y for the 
.................... // given light reading and returns the pH as a float. 
.................... // A good measurement needs to be taken befor ethis routine is run. 
.................... //  Make sure to kick out all ambient light 
.................... //  Make sure all readings are in ABS.  
.................... //***************************************************************************************** 
.................... float FindWAGuysPH(void) 
.................... 	{ 
.................... 		char uffit[80]; 
*
06B60:  MOV     #0,W4
06B62:  MOV     W4,3872
06B64:  MOV     #0,W4
06B66:  MOV     W4,3874
06B68:  MOV     #0,W4
06B6A:  MOV     W4,3876
06B6C:  MOV     #0,W4
06B6E:  MOV     W4,3878
06B70:  MOV     #0,W4
06B72:  MOV     W4,387A
06B74:  MOV     #0,W4
06B76:  MOV     W4,387C
06B78:  MOV     #0,W4
06B7A:  MOV     W4,387E
06B7C:  MOV     #0,W4
06B7E:  MOV     W4,3880
06B80:  MOV     #0,W4
06B82:  MOV     W4,3882
06B84:  MOV     #0,W4
06B86:  MOV     W4,3884
06B88:  MOV     #0,W4
06B8A:  MOV     W4,3886
06B8C:  MOV     #0,W4
06B8E:  MOV     W4,3888
06B90:  MOV     #0,W4
06B92:  MOV     W4,388A
06B94:  MOV     #0,W4
06B96:  MOV     W4,388C
06B98:  MOV     #0,W4
06B9A:  MOV     W4,388E
06B9C:  MOV     #0,W4
06B9E:  MOV     W4,3890
06BA0:  MOV     #0,W4
06BA2:  MOV     W4,3892
06BA4:  MOV     #0,W4
06BA6:  MOV     W4,3894
06BA8:  MOV     #0,W4
06BAA:  MOV     W4,3896
06BAC:  MOV     #0,W4
06BAE:  MOV     W4,3898
06BB0:  MOV     #0,W4
06BB2:  MOV     W4,389A
06BB4:  MOV     #0,W4
06BB6:  MOV     W4,389C
06BB8:  MOV     #0,W4
06BBA:  MOV     W4,389E
06BBC:  MOV     #0,W4
06BBE:  MOV     W4,38A0
06BC0:  MOV     #0,W4
06BC2:  MOV     W4,38A2
06BC4:  MOV     #0,W4
06BC6:  MOV     W4,38A4
06BC8:  MOV     #0,W4
06BCA:  MOV     W4,38A6
06BCC:  MOV     #0,W4
06BCE:  MOV     W4,38A8
06BD0:  MOV     #0,W4
06BD2:  MOV     W4,38AA
06BD4:  MOV     #0,W4
06BD6:  MOV     W4,38AC
06BD8:  MOV     #0,W4
06BDA:  MOV     W4,38AE
06BDC:  MOV     #0,W4
06BDE:  MOV     W4,38B0
06BE0:  MOV     #0,W4
06BE2:  MOV     W4,38B2
06BE4:  MOV     #0,W4
06BE6:  MOV     W4,38B4
06BE8:  MOV     #0,W4
06BEA:  MOV     W4,38B6
06BEC:  MOV     #0,W4
06BEE:  MOV     W4,38B8
06BF0:  MOV     #0,W4
06BF2:  MOV     W4,38BA
06BF4:  MOV     #0,W4
06BF6:  MOV     W4,38BC
06BF8:  MOV     #0,W4
06BFA:  MOV     W4,38BE
06BFC:  MOV     #0,W4
06BFE:  MOV     W4,38C0
.................... 			calculateCoordinate(); 
06C00:  CALL    65D2
.................... 			sprintf(uffit,"y %e",y); 
06C04:  MOV     #3872,W4
06C06:  MOV     W4,214A
06C08:  MOV.B   #79,W0L
06C0A:  CALL    35EA
06C0E:  MOV.B   #20,W0L
06C10:  CALL    35EA
06C14:  MOV     2F82,W2
06C16:  MOV     2F80,W1
06C18:  MOV     #0,W0
06C1A:  CALL    6796
06C1E:  MOV     #204,W4
06C20:  CALL    67DC
.................... 			Display_XYString(0, 4, &uffit); 
06C24:  MOV     #0,W4
06C26:  MOV     W4,39BA
06C28:  MOV     #4,W4
06C2A:  MOV     W4,39BC
06C2C:  MOV     #3872,W4
06C2E:  MOV     W4,39BE
06C30:  CALL    27B0
.................... 			sprintf(uffit,"x %e",x); 
06C34:  MOV     #3872,W4
06C36:  MOV     W4,214A
06C38:  MOV.B   #78,W0L
06C3A:  CALL    35EA
06C3E:  MOV.B   #20,W0L
06C40:  CALL    35EA
06C44:  MOV     2F7E,W2
06C46:  MOV     2F7C,W1
06C48:  MOV     #0,W0
06C4A:  CALL    6796
06C4E:  MOV     #204,W4
06C50:  CALL    67DC
.................... 			Display_XYString(0, 3, &uffit);	 
06C54:  MOV     #0,W4
06C56:  MOV     W4,39BA
06C58:  MOV     #3,W4
06C5A:  MOV     W4,39BC
06C5C:  MOV     #3872,W4
06C5E:  MOV     W4,39BE
06C60:  CALL    27B0
.................... 	return(0.0); 
06C64:  MOV     #0,W0
06C66:  MOV     #0,W1
06C68:  RETURN  
.................... 	} 
....................  
....................  
....................  
.................... //************************************************************* 
.................... // Created Nov. 6, 2012 
.................... //  This routine reads an ADC and averages 16 samples into one and returns the number. 
.................... // There is no scaling or any signal condition excepct for a low pass averaging filter. 
.................... //  The input selection is for ADC 1, 2, 3 and 5.  The numbers 0, 1, 2 and 4 are used for selecting the ADC. 
.................... //************************************************************* 
....................  
.................... int16 GetADCValue(int selection) 
.................... 	{ 
.................... 	int16 ReturnedADC, Summer;	 
*
04494:  MOV     #0,W4
04496:  MOV     W4,3870
04498:  MOV     #0,W4
0449A:  MOV     W4,3872
.................... 	int f; 
0449C:  MOV     #0,W4
0449E:  MOV     W4,3874
.................... 					//setup_adc(ADC_CLOCK_INTERNAL);  //Setup the ADC to run.. 
.................... 					set_adc_channel(selection);  
044A0:  PUSH    386E
044A2:  POP     328
....................                     		delay_ms(10); 
044A4:  MOV     #A,W0
044A6:  CALL    21F2
.................... 					Summer=0; 
044AA:  MOV     #0,W4
044AC:  MOV     W4,3872
.................... 					for (f=0; f < 32; f++) 
044AE:  MOV     #0,W4
044B0:  MOV     W4,3874
044B2:  MOV     3874,W0
044B4:  MOV     #20,W4
044B6:  CP      W4,W0
044B8:  BRA     LE,44D8
.................... 						{ 
.................... 					delay_us(10); 
044BA:  REPEAT  #9E
044BC:  NOP     
.................... 					Summer = Summer + read_adc(); // Read adc channel 10  
044BE:  BCLR.B  320.0
044C0:  BSET.B  320.1
044C2:  BTSS.B  320.0
044C4:  BRA     44C2
044C6:  MOV     300,W0
044C8:  MOV     3872,W4
044CA:  ADD     W0,W4,W0
044CC:  MOV     W0,3872
044CE:  MOV     3874,W0
044D0:  INC     W0,W0
044D2:  MOV     W0,3874
044D4:  GOTO    44B2
.................... 						} 
.................... 					ReturnedADC = Summer>>5; 
044D8:  MOV     3872,W0
044DA:  LSR     W0,#5,W0
044DC:  MOV     W0,3870
044DE:  MOV     W0,3870
.................... 	return(ReturnedADC);	 
044E0:  PUSH    3870
044E2:  POP     0
044E4:  RETURN  
.................... 	} 
....................  
....................  
....................  
.................... //***************************************************************************************** 
.................... // Created Febuary 11, 2015 
.................... // This routine does the measurement of the WA guys pH patch 
.................... // This routine returns nothing.  It's supposed to get an average, remove ambient light and leave 
.................... // a global colors in ABS. 
.................... // The input to the routine is the white light intensity 
.................... //***************************************************************************************** 
.................... void MeasureWAGuyspH(unsigned int16 PWMIntensity) 
.................... 	{ 
....................  
.................... 		pwm_set_duty(PH_PWM,0x0000);  // Turn off light to get ambient light mearuement 
*
06C6A:  MOV     #0,W4
06C6C:  MOV     W4,3872
06C6E:  CALL    27D2
.................... 		delay_ms(100); 
06C72:  MOV     #64,W0
06C74:  CALL    21F2
.................... 		FindAmbientLight(2);    //Get the ambient light 
06C78:  MOV     #2,W4
06C7A:  MOV     W4,3872
06C7C:  CALL    6572
.................... 		pwm_set_duty(PH_PWM,PWMIntensity);  // Turn off light to get ambient light mearuement 
06C80:  PUSH    386E
06C82:  POP     3872
06C84:  CALL    27D2
....................  
.................... //  Remove the ambent light. 
.................... 	redABS = redABS - AmbientPHRed; 
06C88:  MOV     3084,W0
06C8A:  MOV     3074,W4
06C8C:  SUB     W0,W4,W0
06C8E:  MOV     W0,3084
06C90:  MOV     3086,W0
06C92:  MOV     3076,W4
06C94:  SUBB    W0,W4,W0
06C96:  MOV     W0,3086
.................... 	greenABS = greenABS - AmbientPHGreen; 
06C98:  MOV     308C,W0
06C9A:  MOV     3078,W4
06C9C:  SUB     W0,W4,W0
06C9E:  MOV     W0,308C
06CA0:  MOV     308E,W0
06CA2:  MOV     307A,W4
06CA4:  SUBB    W0,W4,W0
06CA6:  MOV     W0,308E
.................... 	blueABS = blueABS - AmbientPHBlue; 
06CA8:  MOV     3088,W0
06CAA:  MOV     307C,W4
06CAC:  SUB     W0,W4,W0
06CAE:  MOV     W0,3088
06CB0:  MOV     308A,W0
06CB2:  MOV     307E,W4
06CB4:  SUBB    W0,W4,W0
06CB6:  MOV     W0,308A
.................... 	clearABS = clearABS - AmbientPHClear; 
06CB8:  MOV     3090,W0
06CBA:  MOV     3080,W4
06CBC:  SUB     W0,W4,W0
06CBE:  MOV     W0,3090
06CC0:  MOV     3092,W0
06CC2:  MOV     3082,W4
06CC4:  SUBB    W0,W4,W0
06CC6:  MOV     W0,3092
.................... 		delay_ms(100); 
06CC8:  MOV     #64,W0
06CCA:  CALL    21F2
.................... 		GetCurrentColorAVG(4, 2);    //Find the current measurement averaged. 
06CCE:  MOV     3876,W0
06CD0:  MOV.B   #4,W0L
06CD2:  MOV     W0,3876
06CD4:  MOV     3876,W0
06CD6:  SWAP    W0
06CD8:  MOV.B   #2,W0L
06CDA:  SWAP    W0
06CDC:  MOV     W0,3876
06CDE:  CALL    6382
.................... 		FindWAGuysPH(); 
06CE2:  CALL    6B60
06CE6:  RETURN  
....................  
.................... 	} 
....................  
....................  
.................... //***************************************************************************************** 
.................... //Created Feb 24, 2015 
.................... //This routine balances the light for the pH and sets the PWM for the same brightness each time 
.................... // The entered number is the wanted feedback number for the pH.  The function returns that lastest PWM setting. 
.................... //***************************************************************************************** 
....................  
.................... int16 SetPWMWithPhotoTransistor(int16 StartingPWM, int16 DesiredIntensity) 
*
06DE0:  MOV     W5,[W15++]
.................... 	{ 
....................  
.................... //Got through the routine only 50 times to get to the desired number.  This uses a PID loop to holm into the wanted number. 
.................... 	signed int16 CurrentADCReading,CurrentAmbientLight, PIDReading, PIDDifference; 
06DE2:  MOV     #0,W4
06DE4:  MOV     W4,3806
06DE6:  MOV     #0,W4
06DE8:  MOV     W4,3808
06DEA:  MOV     #0,W4
06DEC:  MOV     W4,380A
06DEE:  MOV     #0,W4
06DF0:  MOV     W4,380C
.................... 	int16 x,slop; 
06DF2:  MOV     #0,W4
06DF4:  MOV     W4,380E
06DF6:  MOV     #0,W4
06DF8:  MOV     W4,3810
.................... 	float gain,tempreading; 
06DFA:  MOV     #0,W4
06DFC:  MOV     W4,3812
06DFE:  MOV     #0,W4
06E00:  MOV     W4,3814
06E02:  MOV     #0,W4
06E04:  MOV     W4,3816
06E06:  MOV     #0,W4
06E08:  MOV     W4,3818
.................... 	char uffit[80]; 
06E0A:  MOV     #0,W4
06E0C:  MOV     W4,381A
06E0E:  MOV     #0,W4
06E10:  MOV     W4,381C
06E12:  MOV     #0,W4
06E14:  MOV     W4,381E
06E16:  MOV     #0,W4
06E18:  MOV     W4,3820
06E1A:  MOV     #0,W4
06E1C:  MOV     W4,3822
06E1E:  MOV     #0,W4
06E20:  MOV     W4,3824
06E22:  MOV     #0,W4
06E24:  MOV     W4,3826
06E26:  MOV     #0,W4
06E28:  MOV     W4,3828
06E2A:  MOV     #0,W4
06E2C:  MOV     W4,382A
06E2E:  MOV     #0,W4
06E30:  MOV     W4,382C
06E32:  MOV     #0,W4
06E34:  MOV     W4,382E
06E36:  MOV     #0,W4
06E38:  MOV     W4,3830
06E3A:  MOV     #0,W4
06E3C:  MOV     W4,3832
06E3E:  MOV     #0,W4
06E40:  MOV     W4,3834
06E42:  MOV     #0,W4
06E44:  MOV     W4,3836
06E46:  MOV     #0,W4
06E48:  MOV     W4,3838
06E4A:  MOV     #0,W4
06E4C:  MOV     W4,383A
06E4E:  MOV     #0,W4
06E50:  MOV     W4,383C
06E52:  MOV     #0,W4
06E54:  MOV     W4,383E
06E56:  MOV     #0,W4
06E58:  MOV     W4,3840
06E5A:  MOV     #0,W4
06E5C:  MOV     W4,3842
06E5E:  MOV     #0,W4
06E60:  MOV     W4,3844
06E62:  MOV     #0,W4
06E64:  MOV     W4,3846
06E66:  MOV     #0,W4
06E68:  MOV     W4,3848
06E6A:  MOV     #0,W4
06E6C:  MOV     W4,384A
06E6E:  MOV     #0,W4
06E70:  MOV     W4,384C
06E72:  MOV     #0,W4
06E74:  MOV     W4,384E
06E76:  MOV     #0,W4
06E78:  MOV     W4,3850
06E7A:  MOV     #0,W4
06E7C:  MOV     W4,3852
06E7E:  MOV     #0,W4
06E80:  MOV     W4,3854
06E82:  MOV     #0,W4
06E84:  MOV     W4,3856
06E86:  MOV     #0,W4
06E88:  MOV     W4,3858
06E8A:  MOV     #0,W4
06E8C:  MOV     W4,385A
06E8E:  MOV     #0,W4
06E90:  MOV     W4,385C
06E92:  MOV     #0,W4
06E94:  MOV     W4,385E
06E96:  MOV     #0,W4
06E98:  MOV     W4,3860
06E9A:  MOV     #0,W4
06E9C:  MOV     W4,3862
06E9E:  MOV     #0,W4
06EA0:  MOV     W4,3864
06EA2:  MOV     #0,W4
06EA4:  MOV     W4,3866
06EA6:  MOV     #0,W4
06EA8:  MOV     W4,3868
....................  
.................... //First find the ambent light and subtract it out of the calculated value. 
.................... 	pwm_set_duty(PH_PWM,0x0000);	//250hz 
06EAA:  MOV     #0,W4
06EAC:  MOV     W4,3872
06EAE:  CALL    27D2
.................... 	delay_ms(100);  //Wait for it to settle down 
06EB2:  MOV     #64,W0
06EB4:  CALL    21F2
.................... 	CurrentAmbientLight = GetADCValue(2);   //This finds the ADC value 
06EB8:  MOV     #2,W4
06EBA:  MOV     W4,386E
06EBC:  CALL    4494
06EC0:  MOV     W0,3808
.................... 	gain = .1; 
06EC2:  MOV     #CCCD,W4
06EC4:  MOV     W4,3812
06EC6:  MOV     #3DCC,W4
06EC8:  MOV     W4,3814
.................... 	slop =  4;  //this is the tolerance for the phototransistor 
06ECA:  MOV     #4,W4
06ECC:  MOV     W4,3810
....................  
.................... 	for (x=0; x < 50; x++) 
06ECE:  MOV     #0,W4
06ED0:  MOV     W4,380E
06ED2:  MOV     380E,W0
06ED4:  MOV     #32,W4
06ED6:  CP      W4,W0
06ED8:  BRA     LE,7008
.................... 		{ 
.................... 		pwm_set_duty(PH_PWM,StartingPWM); 
06EDA:  PUSH    3802
06EDC:  POP     3872
06EDE:  CALL    27D2
.................... 		delay_ms(50);  //Wait for it to settle down 
06EE2:  MOV     #32,W0
06EE4:  CALL    21F2
.................... 		CurrentADCReading = GetADCValue(2) - CurrentAmbientLight;   //This finds the ADC value 
06EE8:  MOV     #2,W4
06EEA:  MOV     W4,386E
06EEC:  CALL    4494
06EF0:  MOV     W0,W5
06EF2:  MOV     3808,W0
06EF4:  SUB     W5,W0,W0
06EF6:  MOV     W0,3806
.................... 		if (CurrentADCReading < 0)  
06EF8:  MOV     3806,W0
06EFA:  CP      W0,#0
06EFC:  BRA     GE,6F02
.................... 			{ 
.................... 			CurrentADCReading = 0; 
06EFE:  MOV     #0,W4
06F00:  MOV     W4,3806
.................... 			} 
.................... 		if ((CurrentADCReading < (DesiredIntensity + slop)) && (CurrentADCReading > (DesiredIntensity - slop))) 
06F02:  MOV     3804,W0
06F04:  MOV     3810,W4
06F06:  ADD     W0,W4,W0
06F08:  MOV     3806,W4
06F0A:  CP      W4,W0
06F0C:  BRA     GE,6F2C
06F0E:  MOV     3804,W0
06F10:  MOV     3810,W4
06F12:  SUB     W0,W4,W0
06F14:  MOV     3806,W4
06F16:  CP      W4,W0
06F18:  BRA     LE,6F2C
.................... 				{ 
....................                         MeasureWAGuyspH(StartingPWM); 
06F1A:  PUSH    3802
06F1C:  POP     386E
06F1E:  CALL    6C6A
.................... 				return(StartingPWM); 
06F22:  PUSH    3802
06F24:  POP     0
06F26:  BRA     7014
.................... 				} 
06F28:  GOTO    6FFE
.................... 				else 
.................... 				{ 
.................... 				PIDDifference = CurrentADCReading - DesiredIntensity; 
06F2C:  MOV     3806,W0
06F2E:  MOV     3804,W4
06F30:  SUB     W0,W4,W0
06F32:  MOV     W0,380C
.................... 				if (PIDDifference < 0) 
06F34:  MOV     380C,W0
06F36:  CP      W0,#0
06F38:  BRA     GE,6F42
.................... 					{ 
.................... 					PIDDifference = -PIDDifference; 
06F3A:  MOV     380C,W0
06F3C:  MOV     #0,W4
06F3E:  SUB     W4,W0,W0
06F40:  MOV     W0,380C
.................... 					} 
.................... 				tempreading =  (float) PIDDifference; 
06F42:  MOV     380C,W0
06F44:  CALL    44E6
06F48:  MOV     W0,3816
06F4A:  MOV     W1,3818
.................... 				tempreading = tempreading *gain; 
06F4C:  MOV     3816,W0
06F4E:  MOV     3818,W1
06F50:  MOV     3812,W2
06F52:  MOV     3814,W3
06F54:  CALL    46C6
06F58:  MOV     W0,3816
06F5A:  MOV     W1,3818
.................... 				PIDReading = (int16) tempreading; 
06F5C:  MOV     3816,W0
06F5E:  MOV     3818,W1
06F60:  CALL    6CE8
06F64:  MOV     W0,380A
....................  
....................  
.................... 				if (CurrentADCReading < (DesiredIntensity + slop)) 
06F66:  MOV     3804,W0
06F68:  MOV     3810,W4
06F6A:  ADD     W0,W4,W0
06F6C:  MOV     3806,W4
06F6E:  CP      W4,W0
06F70:  BRA     GE,6F7A
.................... 					{ 
.................... 					StartingPWM = StartingPWM  + PIDReading; 
06F72:  MOV     3802,W0
06F74:  MOV     380A,W4
06F76:  ADD     W0,W4,W0
06F78:  MOV     W0,3802
.................... 					//break; 
.................... 					} 
.................... 				if (CurrentADCReading > (DesiredIntensity - slop)) 
06F7A:  MOV     3804,W0
06F7C:  MOV     3810,W4
06F7E:  SUB     W0,W4,W0
06F80:  MOV     3806,W4
06F82:  CP      W4,W0
06F84:  BRA     LE,6F8E
.................... 					{ 
.................... 					StartingPWM = StartingPWM  - PIDReading; 
06F86:  MOV     3802,W0
06F88:  MOV     380A,W4
06F8A:  SUB     W0,W4,W0
06F8C:  MOV     W0,3802
.................... 					//break; 
.................... 					} 
.................... 		sprintf(uffit," %Lu  PWM %Lu  %Lu ", CurrentADCReading, StartingPWM, x); 
06F8E:  MOV     #381A,W4
06F90:  MOV     W4,214A
06F92:  MOV.B   #20,W0L
06F94:  CALL    35EA
06F98:  MOV     3806,W0
06F9A:  MOV     #0,W4
06F9C:  CALL    6D14
06FA0:  MOV     #4,W1
06FA2:  MOV     W1,W0
06FA4:  CLR.B   1
06FA6:  CALL    1490
06FAA:  INC     W1,W1
06FAC:  MOV     W1,[W15++]
06FAE:  MOV     W0,[W15++]
06FB0:  MOV     [--W15],W0
06FB2:  CALL    35EA
06FB6:  MOV     [--W15],W1
06FB8:  MOV     #9,W0
06FBA:  CPSGT   W1,W0
06FBC:  BRA     6FA2
06FBE:  MOV     3802,W0
06FC0:  MOV     #0,W4
06FC2:  CALL    6D14
06FC6:  MOV.B   #20,W0L
06FC8:  CALL    35EA
06FCC:  MOV.B   #20,W0L
06FCE:  CALL    35EA
06FD2:  MOV     380E,W0
06FD4:  MOV     #0,W4
06FD6:  CALL    6D14
06FDA:  MOV.B   #20,W0L
06FDC:  CALL    35EA
.................... 		Display_XYString(0, 1, &uffit); 
06FE0:  MOV     #0,W4
06FE2:  MOV     W4,39BA
06FE4:  MOV     #1,W4
06FE6:  MOV     W4,39BC
06FE8:  MOV     #381A,W4
06FEA:  MOV     W4,39BE
06FEC:  CALL    27B0
.................... 		pwm_set_duty(PH_PWM,StartingPWM); 
06FF0:  PUSH    3802
06FF2:  POP     3872
06FF4:  CALL    27D2
.................... 		delay_ms(50);  //Wait for it to settle down 
06FF8:  MOV     #32,W0
06FFA:  CALL    21F2
.................... 				} 
06FFE:  MOV     380E,W0
07000:  INC     W0,W0
07002:  MOV     W0,380E
07004:  GOTO    6ED2
.................... 			} 
.................... 	MeasureWAGuyspH(StartingPWM); 
07008:  PUSH    3802
0700A:  POP     386E
0700C:  CALL    6C6A
.................... 	return(StartingPWM);  //Retuen the current PWM for the next go around 
07010:  PUSH    3802
07012:  POP     0
07014:  MOV     [--W15],W5
07016:  RETURN  
.................... 	} 
....................  
....................  
....................  
.................... #include "Instrumentation\ADCWaterLevelAndThermisters.c" 
.................... float tempa1, tempa2, tempa3;   //Addded May 15, 2014 These are the coefecents for thermister calculation 
....................  
.................... //************************************************************* 
.................... // Created May 15, 2015 
.................... // This routine solves for the coefficents for thermisters ai 
.................... // This routine reads the EEPROM (when completed) and calculates the curve and temperature from four thermal points. 
.................... //************************************************************* 
....................  
.................... void DetermineTempCoef(void) 
.................... { 
....................  
.................... float temp1,reading1,temp2,reading2,temp3,reading3; 
*
04CA4:  MOV     #0,W4
04CA6:  MOV     W4,3814
04CA8:  MOV     #0,W4
04CAA:  MOV     W4,3816
04CAC:  MOV     #0,W4
04CAE:  MOV     W4,3818
04CB0:  MOV     #0,W4
04CB2:  MOV     W4,381A
04CB4:  MOV     #0,W4
04CB6:  MOV     W4,381C
04CB8:  MOV     #0,W4
04CBA:  MOV     W4,381E
04CBC:  MOV     #0,W4
04CBE:  MOV     W4,3820
04CC0:  MOV     #0,W4
04CC2:  MOV     W4,3822
04CC4:  MOV     #0,W4
04CC6:  MOV     W4,3824
04CC8:  MOV     #0,W4
04CCA:  MOV     W4,3826
04CCC:  MOV     #0,W4
04CCE:  MOV     W4,3828
04CD0:  MOV     #0,W4
04CD2:  MOV     W4,382A
.................... float det, det1, det2, det3;   //These are the other dets for each solution 
04CD4:  MOV     #0,W4
04CD6:  MOV     W4,382C
04CD8:  MOV     #0,W4
04CDA:  MOV     W4,382E
04CDC:  MOV     #0,W4
04CDE:  MOV     W4,3830
04CE0:  MOV     #0,W4
04CE2:  MOV     W4,3832
04CE4:  MOV     #0,W4
04CE6:  MOV     W4,3834
04CE8:  MOV     #0,W4
04CEA:  MOV     W4,3836
04CEC:  MOV     #0,W4
04CEE:  MOV     W4,3838
04CF0:  MOV     #0,W4
04CF2:  MOV     W4,383A
.................... // This is the raw data.  Added May 15, 2015 
....................  
.................... temp1 = 42; 
04CF4:  MOV     #0,W4
04CF6:  MOV     W4,3814
04CF8:  MOV     #4228,W4
04CFA:  MOV     W4,3816
.................... temp2 = 21; 
04CFC:  MOV     #0,W4
04CFE:  MOV     W4,381C
04D00:  MOV     #41A8,W4
04D02:  MOV     W4,381E
.................... temp3 = 6; 
04D04:  MOV     #0,W4
04D06:  MOV     W4,3824
04D08:  MOV     #40C0,W4
04D0A:  MOV     W4,3826
....................  
.................... //*************************************************************************** 
.................... //Added January 13, 2015 
.................... // These are the values used for the 10K reistor stolen from Animatics 
.................... //*************************************************************************** 
.................... //reading1 = 5140; 
.................... //reading2 = 13037; 
.................... //reading3 = 27594; 
.................... //*************************************************************************** 
.................... //Added January 13, 2015 
.................... // These are the values used for the ?K reistor supplied by Rick 
.................... //*************************************************************************** 
....................  
.................... reading1 = 16000; 
04D0C:  MOV     #0,W4
04D0E:  MOV     W4,3818
04D10:  MOV     #467A,W4
04D12:  MOV     W4,381A
.................... reading2 = 36021;   //this is measured at 21 C 
04D14:  MOV     #B500,W4
04D16:  MOV     W4,3820
04D18:  MOV     #470C,W4
04D1A:  MOV     W4,3822
.................... reading3 = 65000; 
04D1C:  MOV     #E800,W4
04D1E:  MOV     W4,3828
04D20:  MOV     #477D,W4
04D22:  MOV     W4,382A
....................  
....................  
.................... temp1 = 1.0/(temp1 + 273.0); 
04D24:  BCLR.B  43.0
04D26:  MOV     3814,W0
04D28:  MOV     3816,W1
04D2A:  MOV     #8000,W2
04D2C:  MOV     #4388,W3
04D2E:  CALL    478A
04D32:  MOV     W0,W2
04D34:  MOV     W1,W3
04D36:  MOV     #0,W0
04D38:  MOV     #3F80,W1
04D3A:  CALL    4530
04D3E:  MOV     W0,3814
04D40:  MOV     W1,3816
.................... temp2 = 1.0/(temp2 + 273.0); 
04D42:  BCLR.B  43.0
04D44:  MOV     381C,W0
04D46:  MOV     381E,W1
04D48:  MOV     #8000,W2
04D4A:  MOV     #4388,W3
04D4C:  CALL    478A
04D50:  MOV     W0,W2
04D52:  MOV     W1,W3
04D54:  MOV     #0,W0
04D56:  MOV     #3F80,W1
04D58:  CALL    4530
04D5C:  MOV     W0,381C
04D5E:  MOV     W1,381E
.................... temp3 = 1.0/(temp3 + 273.0); 
04D60:  BCLR.B  43.0
04D62:  MOV     3824,W0
04D64:  MOV     3826,W1
04D66:  MOV     #8000,W2
04D68:  MOV     #4388,W3
04D6A:  CALL    478A
04D6E:  MOV     W0,W2
04D70:  MOV     W1,W3
04D72:  MOV     #0,W0
04D74:  MOV     #3F80,W1
04D76:  CALL    4530
04D7A:  MOV     W0,3824
04D7C:  MOV     W1,3826
....................  
....................  
.................... reading1 = log(reading1); 
04D7E:  PUSH    3818
04D80:  POP     383C
04D82:  PUSH    381A
04D84:  POP     383E
04D86:  CALL    4934
04D8A:  MOV     W0,3818
04D8C:  MOV     W1,381A
.................... reading2 = log(reading2); 
04D8E:  PUSH    3820
04D90:  POP     383C
04D92:  PUSH    3822
04D94:  POP     383E
04D96:  CALL    4934
04D9A:  MOV     W0,3820
04D9C:  MOV     W1,3822
.................... reading3 = log(reading3); 
04D9E:  PUSH    3828
04DA0:  POP     383C
04DA2:  PUSH    382A
04DA4:  POP     383E
04DA6:  CALL    4934
04DAA:  MOV     W0,3828
04DAC:  MOV     W1,382A
....................  
....................  
.................... //  This part solves for tempa1, tempa2, tempa3 4 
.................... // Find the divistion determinent 
....................  
.................... matx[0][0] = 1.0; 
04DAE:  MOV     #0,W4
04DB0:  MOV     W4,2F8C
04DB2:  MOV     #3F80,W4
04DB4:  MOV     W4,2F8E
.................... matx[1][0] = 1.0; 
04DB6:  MOV     #0,W4
04DB8:  MOV     W4,2F98
04DBA:  MOV     #3F80,W4
04DBC:  MOV     W4,2F9A
.................... matx[2][0] = 1.0; 
04DBE:  MOV     #0,W4
04DC0:  MOV     W4,2FA4
04DC2:  MOV     #3F80,W4
04DC4:  MOV     W4,2FA6
.................... matx[0][1] = reading1; 
04DC6:  PUSH    3818
04DC8:  POP     2F90
04DCA:  PUSH    381A
04DCC:  POP     2F92
.................... matx[1][1] = reading2; 
04DCE:  PUSH    3820
04DD0:  POP     2F9C
04DD2:  PUSH    3822
04DD4:  POP     2F9E
.................... matx[2][1] = reading3; 
04DD6:  PUSH    3828
04DD8:  POP     2FA8
04DDA:  PUSH    382A
04DDC:  POP     2FAA
.................... matx[0][2] = reading1*reading1; 
04DDE:  MOV     3818,W0
04DE0:  MOV     381A,W1
04DE2:  MOV     3818,W2
04DE4:  MOV     381A,W3
04DE6:  CALL    46C6
04DEA:  MOV     W0,2F94
04DEC:  MOV     W1,2F96
.................... matx[1][2] = reading2*reading2; 
04DEE:  MOV     3820,W0
04DF0:  MOV     3822,W1
04DF2:  MOV     3820,W2
04DF4:  MOV     3822,W3
04DF6:  CALL    46C6
04DFA:  MOV     W0,2FA0
04DFC:  MOV     W1,2FA2
.................... matx[2][2] = reading3*reading3; 
04DFE:  MOV     3828,W0
04E00:  MOV     382A,W1
04E02:  MOV     3828,W2
04E04:  MOV     382A,W3
04E06:  CALL    46C6
04E0A:  MOV     W0,2FAC
04E0C:  MOV     W1,2FAE
....................  
.................... det = FindTheDetermint(); 
04E0E:  CALL    4AF4
04E12:  MOV     W0,382C
04E14:  MOV     W1,382E
....................  
.................... //Find the det for tempa1 
....................  
.................... matx[0][0] = temp1; 
04E16:  PUSH    3814
04E18:  POP     2F8C
04E1A:  PUSH    3816
04E1C:  POP     2F8E
.................... matx[1][0] = temp2; 
04E1E:  PUSH    381C
04E20:  POP     2F98
04E22:  PUSH    381E
04E24:  POP     2F9A
.................... matx[2][0] = temp3; 
04E26:  PUSH    3824
04E28:  POP     2FA4
04E2A:  PUSH    3826
04E2C:  POP     2FA6
.................... matx[0][1] = reading1; 
04E2E:  PUSH    3818
04E30:  POP     2F90
04E32:  PUSH    381A
04E34:  POP     2F92
.................... matx[1][1] = reading2; 
04E36:  PUSH    3820
04E38:  POP     2F9C
04E3A:  PUSH    3822
04E3C:  POP     2F9E
.................... matx[2][1] = reading3; 
04E3E:  PUSH    3828
04E40:  POP     2FA8
04E42:  PUSH    382A
04E44:  POP     2FAA
.................... matx[0][2] = reading1*reading1; 
04E46:  MOV     3818,W0
04E48:  MOV     381A,W1
04E4A:  MOV     3818,W2
04E4C:  MOV     381A,W3
04E4E:  CALL    46C6
04E52:  MOV     W0,2F94
04E54:  MOV     W1,2F96
.................... matx[1][2] = reading2*reading2; 
04E56:  MOV     3820,W0
04E58:  MOV     3822,W1
04E5A:  MOV     3820,W2
04E5C:  MOV     3822,W3
04E5E:  CALL    46C6
04E62:  MOV     W0,2FA0
04E64:  MOV     W1,2FA2
.................... matx[2][2] = reading3*reading3; 
04E66:  MOV     3828,W0
04E68:  MOV     382A,W1
04E6A:  MOV     3828,W2
04E6C:  MOV     382A,W3
04E6E:  CALL    46C6
04E72:  MOV     W0,2FAC
04E74:  MOV     W1,2FAE
....................  
.................... det1 = FindTheDetermint(); 
04E76:  CALL    4AF4
04E7A:  MOV     W0,3830
04E7C:  MOV     W1,3832
.................... tempa1=det1/det;   //  This finds the value for the first a1 
04E7E:  MOV     3830,W0
04E80:  MOV     3832,W1
04E82:  MOV     382C,W2
04E84:  MOV     382E,W3
04E86:  CALL    4530
04E8A:  MOV     W0,30B8
04E8C:  MOV     W1,30BA
....................  
.................... matx[0][0] = 1.0; 
04E8E:  MOV     #0,W4
04E90:  MOV     W4,2F8C
04E92:  MOV     #3F80,W4
04E94:  MOV     W4,2F8E
.................... matx[1][0] = 1.0; 
04E96:  MOV     #0,W4
04E98:  MOV     W4,2F98
04E9A:  MOV     #3F80,W4
04E9C:  MOV     W4,2F9A
.................... matx[2][0] = 1.0; 
04E9E:  MOV     #0,W4
04EA0:  MOV     W4,2FA4
04EA2:  MOV     #3F80,W4
04EA4:  MOV     W4,2FA6
.................... matx[0][1] = temp1; 
04EA6:  PUSH    3814
04EA8:  POP     2F90
04EAA:  PUSH    3816
04EAC:  POP     2F92
.................... matx[1][1] = temp2; 
04EAE:  PUSH    381C
04EB0:  POP     2F9C
04EB2:  PUSH    381E
04EB4:  POP     2F9E
.................... matx[2][1] = temp3; 
04EB6:  PUSH    3824
04EB8:  POP     2FA8
04EBA:  PUSH    3826
04EBC:  POP     2FAA
.................... matx[0][2] = reading1*reading1; 
04EBE:  MOV     3818,W0
04EC0:  MOV     381A,W1
04EC2:  MOV     3818,W2
04EC4:  MOV     381A,W3
04EC6:  CALL    46C6
04ECA:  MOV     W0,2F94
04ECC:  MOV     W1,2F96
.................... matx[1][2] = reading2*reading2; 
04ECE:  MOV     3820,W0
04ED0:  MOV     3822,W1
04ED2:  MOV     3820,W2
04ED4:  MOV     3822,W3
04ED6:  CALL    46C6
04EDA:  MOV     W0,2FA0
04EDC:  MOV     W1,2FA2
.................... matx[2][2] = reading3*reading3; 
04EDE:  MOV     3828,W0
04EE0:  MOV     382A,W1
04EE2:  MOV     3828,W2
04EE4:  MOV     382A,W3
04EE6:  CALL    46C6
04EEA:  MOV     W0,2FAC
04EEC:  MOV     W1,2FAE
....................  
....................  
.................... det2 = FindTheDetermint(); 
04EEE:  CALL    4AF4
04EF2:  MOV     W0,3834
04EF4:  MOV     W1,3836
.................... tempa2=det2/det;   //  This finds the value for the first a2 
04EF6:  MOV     3834,W0
04EF8:  MOV     3836,W1
04EFA:  MOV     382C,W2
04EFC:  MOV     382E,W3
04EFE:  CALL    4530
04F02:  MOV     W0,30BC
04F04:  MOV     W1,30BE
....................  
....................  
....................  
.................... matx[0][0] = 1.0; 
04F06:  MOV     #0,W4
04F08:  MOV     W4,2F8C
04F0A:  MOV     #3F80,W4
04F0C:  MOV     W4,2F8E
.................... matx[1][0] = 1.0; 
04F0E:  MOV     #0,W4
04F10:  MOV     W4,2F98
04F12:  MOV     #3F80,W4
04F14:  MOV     W4,2F9A
.................... matx[2][0] = 1.0; 
04F16:  MOV     #0,W4
04F18:  MOV     W4,2FA4
04F1A:  MOV     #3F80,W4
04F1C:  MOV     W4,2FA6
.................... matx[0][1] = reading1; 
04F1E:  PUSH    3818
04F20:  POP     2F90
04F22:  PUSH    381A
04F24:  POP     2F92
.................... matx[1][1] = reading2; 
04F26:  PUSH    3820
04F28:  POP     2F9C
04F2A:  PUSH    3822
04F2C:  POP     2F9E
.................... matx[2][1] = reading3; 
04F2E:  PUSH    3828
04F30:  POP     2FA8
04F32:  PUSH    382A
04F34:  POP     2FAA
.................... matx[0][2] = temp1; 
04F36:  PUSH    3814
04F38:  POP     2F94
04F3A:  PUSH    3816
04F3C:  POP     2F96
.................... matx[1][2] = temp2; 
04F3E:  PUSH    381C
04F40:  POP     2FA0
04F42:  PUSH    381E
04F44:  POP     2FA2
.................... matx[2][2] = temp3; 
04F46:  PUSH    3824
04F48:  POP     2FAC
04F4A:  PUSH    3826
04F4C:  POP     2FAE
....................  
.................... det3 = FindTheDetermint(); 
04F4E:  CALL    4AF4
04F52:  MOV     W0,3838
04F54:  MOV     W1,383A
.................... tempa3=det3/det;   //  This finds the value for the first a2 
04F56:  MOV     3838,W0
04F58:  MOV     383A,W1
04F5A:  MOV     382C,W2
04F5C:  MOV     382E,W3
04F5E:  CALL    4530
04F62:  MOV     W0,30C0
04F64:  MOV     W1,30C2
04F66:  RETURN  
....................  
....................  
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... //***************************************************************** 
.................... // Created Nov. 6, 2012 
.................... // Converts the ADC number on a scale of 5 volts minus some for Op-amp issues 
.................... // The numerical convertion is conveted into degrees C. 
.................... // The returned value in C degrees. 
.................... //  Ths interm convertion is to Kalvin and will later be switched over to Kalvin scale. 
.................... //***************************************************************** 
....................  
.................... float ConvertADCToKalvin(int ADCInputNumber) 
04F68:  MOV     W5,[W15++]
04F6A:  MOV     W6,[W15++]
04F6C:  MOV     W7,[W15++]
04F6E:  MOV     W8,[W15++]
.................... 	{ 
.................... int16 ReturnedADC; 
04F70:  MOV     #0,W4
04F72:  MOV     W4,3804
.................... float32 ADCVoltageIn,Kelvin, tempfloater; 
04F74:  MOV     #0,W4
04F76:  MOV     W4,3806
04F78:  MOV     #0,W4
04F7A:  MOV     W4,3808
04F7C:  MOV     #0,W4
04F7E:  MOV     W4,380A
04F80:  MOV     #0,W4
04F82:  MOV     W4,380C
04F84:  MOV     #0,W4
04F86:  MOV     W4,380E
04F88:  MOV     #0,W4
04F8A:  MOV     W4,3810
.................... 	ReturnedADC = GetADCValue(ADCInputNumber);  //This gets the current ADC convertion for the channel number. 
04F8C:  PUSH    3802
04F8E:  POP     386E
04F90:  CALL    4494
04F94:  MOV     W0,3804
.................... //    ADCVoltageIn = ReturnedADC * 5.0 / 1024.0;  //Recycled the same float variable. 
....................   tempfloater = (float) ReturnedADC; 
04F96:  MOV     3804,W0
04F98:  CALL    44E6
04F9C:  MOV     W0,380E
04F9E:  MOV     W1,3810
....................   ADCVoltageIn = (float) ReturnedADC * 3.3 / 1024.0;  //Recycled the same float variable. 
04FA0:  MOV     3804,W0
04FA2:  CALL    44E6
04FA6:  MOV     W0,W5
04FA8:  MOV     W1,W6
04FAA:  MOV     W5,W0
04FAC:  MOV     W6,W1
04FAE:  MOV     #3333,W2
04FB0:  MOV     #4053,W3
04FB2:  CALL    46C6
04FB6:  MOV     W0,W5
04FB8:  MOV     W1,W6
04FBA:  MOV     W5,W0
04FBC:  MOV     W6,W1
04FBE:  MOV     #0,W2
04FC0:  MOV     #4480,W3
04FC2:  CALL    4530
04FC6:  MOV     W0,3806
04FC8:  MOV     W1,3808
....................  
....................  
.................... 	ADCVoltageIn = 5100.0*ADCVoltageIn/(3.3 - ADCVoltageIn);  // Calulate the thermister reistance over a voltage divider.  It's at the bottom of a 0 to 5 volts divider.  The resistance is 4.999K 
04FCA:  MOV     #6000,W0
04FCC:  MOV     #459F,W1
04FCE:  MOV     3806,W2
04FD0:  MOV     3808,W3
04FD2:  CALL    46C6
04FD6:  MOV     W0,W5
04FD8:  MOV     W1,W6
04FDA:  BSET.B  43.0
04FDC:  MOV     #3333,W0
04FDE:  MOV     #4053,W1
04FE0:  MOV     3806,W2
04FE2:  MOV     3808,W3
04FE4:  CALL    478A
04FE8:  MOV     W0,W2
04FEA:  MOV     W1,W3
04FEC:  MOV     W5,W0
04FEE:  MOV     W6,W1
04FF0:  CALL    4530
04FF4:  MOV     W0,3806
04FF6:  MOV     W1,3808
....................  
.................... //ADCVoltageIn=12000.0; 
....................  
.................... DetermineTempCoef(); 
04FF8:  CALL    4CA4
....................  
.................... Kelvin = (1/(tempa1 + tempa2*(log(ADCVoltageIn)) + tempa3*(log(ADCVoltageIn)*log(ADCVoltageIn))))-273.15; 
04FFC:  PUSH    3806
04FFE:  POP     383C
05000:  PUSH    3808
05002:  POP     383E
05004:  CALL    4934
05008:  MOV     W0,W2
0500A:  MOV     W1,W3
0500C:  MOV     30BC,W0
0500E:  MOV     30BE,W1
05010:  CALL    46C6
05014:  BCLR.B  43.0
05016:  MOV     W0,W2
05018:  MOV     W1,W3
0501A:  MOV     30B8,W0
0501C:  MOV     30BA,W1
0501E:  CALL    478A
05022:  MOV     W0,W5
05024:  MOV     W1,W6
05026:  PUSH    3806
05028:  POP     383C
0502A:  PUSH    3808
0502C:  POP     383E
0502E:  CALL    4934
05032:  MOV     W0,W7
05034:  MOV     W1,W8
05036:  PUSH    3806
05038:  POP     383C
0503A:  PUSH    3808
0503C:  POP     383E
0503E:  CALL    4934
05042:  MOV     W0,W2
05044:  MOV     W1,W3
05046:  MOV     W7,W0
05048:  MOV     W8,W1
0504A:  CALL    46C6
0504E:  MOV     W0,W2
05050:  MOV     W1,W3
05052:  MOV     30C0,W0
05054:  MOV     30C2,W1
05056:  CALL    46C6
0505A:  BCLR.B  43.0
0505C:  MOV     W0,W2
0505E:  MOV     W1,W3
05060:  MOV     W5,W0
05062:  MOV     W6,W1
05064:  CALL    478A
05068:  MOV     W0,W2
0506A:  MOV     W1,W3
0506C:  MOV     #0,W0
0506E:  MOV     #3F80,W1
05070:  CALL    4530
05074:  MOV     W0,W5
05076:  MOV     W1,W6
05078:  BSET.B  43.0
0507A:  MOV     W5,W0
0507C:  MOV     W6,W1
0507E:  MOV     #9333,W2
05080:  MOV     #4388,W3
05082:  CALL    478A
05086:  MOV     W0,380A
05088:  MOV     W1,380C
....................  
.................... 	return(Kelvin); 
0508A:  MOV     380A,W0
0508C:  MOV     380C,W1
0508E:  MOV     [--W15],W8
05090:  MOV     [--W15],W7
05092:  MOV     [--W15],W6
05094:  MOV     [--W15],W5
05096:  RETURN  
.................... 	} 
....................  
....................  
.................... //******************************************************************** 
.................... // Created June 12, 2013 
.................... // This routine uses AN4 input from the pressure sensor to deteminen the depth of water via. pressure. 
.................... // AN4 is read and scaled between 0 volts and a little less than 5 volts. 
.................... // The retuend result is the measurement in inches.  The input is the ADC 4 converter number. 
.................... // The returned number is a float. 
.................... // The fuill range is 1024 and is 5 volts.  There are 1024 levels 
.................... //******************************************************************** 
.................... float MeasureWaterDepth(void) 
*
04662:  MOV     W5,[W15++]
04664:  MOV     W6,[W15++]
.................... 	{ 
.................... 	signed int16 ADCReading; 
04666:  MOV     #0,W4
04668:  MOV     W4,3802
.................... 	float Measurement; 
0466A:  MOV     #0,W4
0466C:  MOV     W4,3804
0466E:  MOV     #0,W4
04670:  MOV     W4,3806
....................  
.................... 	ADCReading = GetADCValue(9);   //Read current pressure value. 
04672:  MOV     #9,W4
04674:  MOV     W4,386E
04676:  CALL    4494
0467A:  MOV     W0,3802
.................... 	ADCReading = ADCReading - 0x0057;   // Remove the offset for this diff sensor 
0467C:  MOV     3802,W0
0467E:  SUB     #57,W0
04680:  MOV     W0,3802
.................... 	if (ADCReading < 0) 
04682:  MOV     3802,W0
04684:  CP      W0,#0
04686:  BRA     GE,468C
.................... 		{ 
.................... 		ADCReading = 0; 
04688:  MOV     #0,W4
0468A:  MOV     W4,3802
.................... 		} 
.................... 	Measurement = (float) ADCReading / 7.047 ;   //Convert the ADC converstion in to cm. 
0468C:  MOV     3802,W0
0468E:  CALL    44E6
04692:  MOV     W0,W5
04694:  MOV     W1,W6
04696:  MOV     W5,W0
04698:  MOV     W6,W1
0469A:  MOV     #8106,W2
0469C:  MOV     #40E1,W3
0469E:  CALL    4530
046A2:  MOV     W0,3804
046A4:  MOV     W1,3806
.................... 	if (Measurement < 0.5) 
046A6:  MOV     3804,W0
046A8:  MOV     3806,W1
046AA:  MOV     #0,W2
046AC:  MOV     #3F00,W3
046AE:  CALL    45FA
046B2:  BRA     NC,46BC
.................... 		{ 
.................... 		Measurement = 0.0; 
046B4:  MOV     #0,W4
046B6:  MOV     W4,3804
046B8:  MOV     #0,W4
046BA:  MOV     W4,3806
.................... 		} 
.................... 	return(Measurement); 
046BC:  MOV     3804,W0
046BE:  MOV     3806,W1
046C0:  MOV     [--W15],W6
046C2:  MOV     [--W15],W5
046C4:  RETURN  
.................... 	} 
....................  
....................  
....................  
.................... //******************************************************************** 
.................... // Created Nov 6, 2012 
.................... // ReCreated for Osmobot October 3, 2014 
.................... // This inits all of the ADC convereters for input. 
.................... //  There is no output from this funtion.+ 
.................... //******************************************************************** 
.................... void SetupADC(void) 
.................... 	{ 
....................     setup_adc(ADC_CLOCK_INTERNAL); 
*
02388:  MOV     #9F00,W4
0238A:  MOV     W4,324
0238C:  MOV     #80E0,W4
0238E:  MOV     W4,320
....................     setup_adc_ports( sAN9 | sAN5 | sAN2 |VSS_VDD ); 
02390:  MOV     #FDDB,W4
02392:  MOV     W4,32C
02394:  CLR     322
02396:  RETURN  
.................... 	} 
....................  
....................  
.................... #include "Instrumentation\CheapRHAndTemp.c" 
....................  
....................  
.................... float RHData, Temperature; 
....................  
.................... //**************************************************************************** 
.................... // Created Sept 22, 2014 
.................... // Init all of the I/O bits to make the RH/Temp sensor work 
.................... // Returns nothing 
.................... //**************************************************************************** 
.................... void initRHTemp(void) 
.................... 	{ 
.................... 	output_high(PIN_D0);   //This sets the output high. 
*
026DE:  BCLR.B  2D8.0
026E0:  BSET.B  2DC.0
026E2:  RETURN  
.................... 	} 
....................  
....................  
....................  
.................... //**************************************************************************** 
.................... // Created Sept 22, 2014 
.................... // Find the check sum number 
.................... //  0 - all is good, 1 - all is bad 
.................... //**************************************************************************** 
.................... int16 CheckSumRHTemp(long RawRH, long RawTemp) 
*
050E6:  MOV     W5,[W15++]
.................... 	{ 
.................... 	int16 checksum2,checksum3; 
050E8:  MOV     #0,W4
050EA:  MOV     W4,381E
050EC:  MOV     #0,W4
050EE:  MOV     W4,3820
....................  
.................... 	checksum2 = (int16) 0xFF00 & RawRH; 
050F0:  MOV     3818,W0
050F2:  CLR     W1
050F4:  MOV     3816,W0
050F6:  MOV     W0,W4
050F8:  MOV     #FF00,W0
050FA:  AND     W0,W4,W0
050FC:  MOV     W0,381E
....................     checksum2 = checksum2>>8; 
050FE:  PUSH    381E
05100:  MOV     [--W15],W0
05102:  LSR     W0,#8,W0
05104:  PUSH    381E
05106:  MOV.B   W0L,[W15-#2]
05108:  POP     381E
0510A:  MOV     381E,W0
0510C:  CLR.B   1
0510E:  MOV     W0,381E
.................... 	checksum2 = checksum2 + (int16) (0x00FF & RawRH); 
05110:  MOV     3818,W0
05112:  CLR     W1
05114:  MOV     3816,W0
05116:  AND     #FF,W0
05118:  MOV     381E,W4
0511A:  ADD     W0,W4,W0
0511C:  MOV     W0,381E
....................  
.................... 	checksum3 = (int16) (0xFF00 & RawTemp); 
0511E:  MOV     381C,W0
05120:  CLR     W1
05122:  MOV     381A,W0
05124:  MOV     W0,W4
05126:  MOV     #FF00,W0
05128:  AND     W0,W4,W0
0512A:  MOV     W0,3820
....................     checksum3 = checksum3>>8; 
0512C:  PUSH    3820
0512E:  MOV     [--W15],W0
05130:  LSR     W0,#8,W0
05132:  PUSH    3820
05134:  MOV.B   W0L,[W15-#2]
05136:  POP     3820
05138:  MOV     3820,W0
0513A:  CLR.B   1
0513C:  MOV     W0,3820
.................... 	checksum2 = checksum3 + checksum2 + (int16) (0x00FF & RawTemp); 
0513E:  MOV     3820,W0
05140:  MOV     381E,W4
05142:  ADD     W0,W4,W5
05144:  MOV     381C,W0
05146:  CLR     W1
05148:  MOV     381A,W0
0514A:  AND     #FF,W0
0514C:  ADD     W0,W5,W0
0514E:  MOV     W0,381E
....................  
.................... 	return(0x00FF & checksum2); 
05150:  MOV     381E,W0
05152:  AND     #FF,W0
05154:  MOV     W0,0
05156:  MOV     [--W15],W5
05158:  RETURN  
.................... 	} 
....................  
....................  
.................... //*************************************************************************** 
.................... // Created Sept 22, 2014 
.................... // This routine returns the RH and Temps as float through global variables 
.................... // Returns 1 if there is an error.  a zero if there none 
.................... // All calculations for converion and reading the sensor is done here. 
.................... //*************************************************************************** 
.................... int GetTempRH(void) 
0515A:  MOV     W5,[W15++]
0515C:  MOV     W6,[W15++]
.................... 	{ 
.................... 	int x,y,w,counter; 
0515E:  MOV     #0,W4
05160:  MOV     W4,3802
05162:  MOV     #0,W4
05164:  MOV     W4,3804
05166:  MOV     #0,W4
05168:  MOV     W4,3806
0516A:  MOV     #0,W4
0516C:  MOV     W4,3808
....................     long  RawRH, RawTemp, CheckSum;//These are the global varaibles for RH and Temperature 
0516E:  MOV     #0,W4
05170:  MOV     W4,380A
05172:  MOV     #0,W4
05174:  MOV     W4,380C
05176:  MOV     #0,W4
05178:  MOV     W4,380E
0517A:  MOV     #0,W4
0517C:  MOV     W4,3810
0517E:  MOV     #0,W4
05180:  MOV     W4,3812
05182:  MOV     #0,W4
05184:  MOV     W4,3814
....................  
....................  
.................... //  Send command out to the I/O pin 
.................... 	output_high(PIN_D0);   //This sets the output high. 
05186:  BCLR.B  2D8.0
05188:  BSET.B  2DC.0
.................... 	output_low(PIN_D0);   //This sets the output high. 
0518A:  BCLR.B  2D8.0
0518C:  BCLR.B  2DC.0
.................... 	delay_ms(5); 
0518E:  MOV     #5,W0
05190:  CALL    21F2
.................... 	output_high(PIN_D0);   //This sets the output high. 
05194:  BCLR.B  2D8.0
05196:  BSET.B  2DC.0
.................... 	delay_us(40); 
05198:  REPEAT  #27E
0519A:  NOP     
.................... 	output_float(PIN_D0); 
0519C:  BSET.B  2D8.0
.................... 	delay_us(20); 
0519E:  REPEAT  #13E
051A0:  NOP     
....................  
.................... 	for (x=0; x < 5; x++) ///This waits to get out of the MCU command 
051A2:  MOV     #0,W4
051A4:  MOV     W4,3802
051A6:  MOV     3802,W0
051A8:  CP      W0,#5
051AA:  BRA     GE,51CC
.................... 		{ 
.................... 		y=input_state(PIN_D0); 
051AC:  CLR     W4
051AE:  BTSC.B  2DA.0
051B0:  INC     W4,W4
051B2:  MOV     W4,3804
.................... 		if (!y) break; 
051B4:  MOV     3804,W0
051B6:  CP0     W0
051B8:  BRA     NZ,51BE
051BA:  GOTO    51CC
.................... 		delay_us(10); 
051BE:  REPEAT  #9E
051C0:  NOP     
051C2:  MOV     3802,W0
051C4:  INC     W0,W0
051C6:  MOV     W0,3802
051C8:  GOTO    51A6
.................... 		} 
.................... 	for (x=0; x < 20; x++)   //This waits through the zero and finds a 1 
051CC:  MOV     #0,W4
051CE:  MOV     W4,3802
051D0:  MOV     3802,W0
051D2:  CP      W0,#14
051D4:  BRA     GE,51F6
.................... 		{ 
.................... 		y=input_state(PIN_D0); 
051D6:  CLR     W4
051D8:  BTSC.B  2DA.0
051DA:  INC     W4,W4
051DC:  MOV     W4,3804
.................... 		if (y) break; 
051DE:  MOV     3804,W0
051E0:  CP0     W0
051E2:  BRA     Z,51E8
051E4:  GOTO    51F6
.................... 		delay_us(10); 
051E8:  REPEAT  #9E
051EA:  NOP     
051EC:  MOV     3802,W0
051EE:  INC     W0,W0
051F0:  MOV     W0,3802
051F2:  GOTO    51D0
.................... 		} 
....................  
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
051F6:  MOV     #0,W4
051F8:  MOV     W4,3802
051FA:  MOV     3802,W0
051FC:  CP      W0,#F
051FE:  BRA     GE,5220
.................... 		{ 
.................... 		y=input_state(PIN_D0);   //wait for the first bit to pop up  Assuming is less than 200 us 
05200:  CLR     W4
05202:  BTSC.B  2DA.0
05204:  INC     W4,W4
05206:  MOV     W4,3804
.................... 		if (!y) break; 
05208:  MOV     3804,W0
0520A:  CP0     W0
0520C:  BRA     NZ,5212
0520E:  GOTO    5220
.................... 		delay_us(10); 
05212:  REPEAT  #9E
05214:  NOP     
05216:  MOV     3802,W0
05218:  INC     W0,W0
0521A:  MOV     W0,3802
0521C:  GOTO    51FA
.................... 		} 
.................... 	 
.................... //beginning of first bit zero 
.................... //Setup the for loop 
.................... RawRH = 0; /// Clear out the variable 
05220:  MOV     #0,W4
05222:  MOV     W4,380A
05224:  MOV     #0,W4
05226:  MOV     W4,380C
.................... for (counter=0; counter < 16; counter++) 
05228:  MOV     #0,W4
0522A:  MOV     W4,3808
0522C:  MOV     3808,W0
0522E:  CP      W0,#10
05230:  BRA     GE,52B6
.................... 	{ 
.................... //This section collects the bits from the first 16 bits and places it in one varible. 
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
05232:  MOV     #0,W4
05234:  MOV     W4,3802
05236:  MOV     3802,W0
05238:  CP      W0,#F
0523A:  BRA     GE,525C
.................... 		{ 
.................... 		y=input_state(PIN_D0);   //wait for the bit to time out the zero for the next bit 
0523C:  CLR     W4
0523E:  BTSC.B  2DA.0
05240:  INC     W4,W4
05242:  MOV     W4,3804
.................... 		if (y) break; 
05244:  MOV     3804,W0
05246:  CP0     W0
05248:  BRA     Z,524E
0524A:  GOTO    525C
.................... 		delay_us(5); 
0524E:  REPEAT  #4E
05250:  NOP     
05252:  MOV     3802,W0
05254:  INC     W0,W0
05256:  MOV     W0,3802
05258:  GOTO    5236
.................... 		} 
.................... 		w=y; 
0525C:  PUSH    3804
0525E:  POP     3806
.................... 	for (x=0; x < 15; x++)   //This waits through the 1 to see how long it is. 
05260:  MOV     #0,W4
05262:  MOV     W4,3802
05264:  MOV     3802,W0
05266:  CP      W0,#F
05268:  BRA     GE,528A
.................... 		{ 
.................... 		y=input_state(PIN_D0);   //wait for the first bit to pop up  Assuming is less than 200 us 
0526A:  CLR     W4
0526C:  BTSC.B  2DA.0
0526E:  INC     W4,W4
05270:  MOV     W4,3804
.................... 		if (!y) break; 
05272:  MOV     3804,W0
05274:  CP0     W0
05276:  BRA     NZ,527C
05278:  GOTO    528A
.................... 		delay_us(5); 
0527C:  REPEAT  #4E
0527E:  NOP     
05280:  MOV     3802,W0
05282:  INC     W0,W0
05284:  MOV     W0,3802
05286:  GOTO    5264
.................... 		} 
....................  
.................... 	RawRH=RawRH<<1;	// Shift the whole word one bit left. 
0528A:  PUSH    380A
0528C:  POP     6
0528E:  PUSH    380C
05290:  POP     8
05292:  SL      6
05294:  RLC     8
05296:  MOV     W3,380A
05298:  MOV     W4,380C
.................... 	if (x > 6) 
0529A:  MOV     3802,W0
0529C:  CP      W0,#6
0529E:  BRA     LE,52AC
.................... 		{ 
.................... 		RawRH = RawRH + 0x0001; 
052A0:  MOV     380A,W0
052A2:  ADD     W0,#1,W0
052A4:  MOV     W0,380A
052A6:  MOV     380C,W4
052A8:  ADDC    W4,#0,W4
052AA:  MOV     W4,380C
.................... 		} 
052AC:  MOV     3808,W0
052AE:  INC     W0,W0
052B0:  MOV     W0,3808
052B2:  GOTO    522C
.................... 	} 
.................... 	 
....................  
....................  
.................... RawTemp = 0; /// Clear out the variable 
052B6:  MOV     #0,W4
052B8:  MOV     W4,380E
052BA:  MOV     #0,W4
052BC:  MOV     W4,3810
.................... for (counter=0; counter < 16; counter++) 
052BE:  MOV     #0,W4
052C0:  MOV     W4,3808
052C2:  MOV     3808,W0
052C4:  CP      W0,#10
052C6:  BRA     GE,5348
.................... 	{ 
.................... //This section collects the bits from the first 16 bits and places it in one varible. 
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
052C8:  MOV     #0,W4
052CA:  MOV     W4,3802
052CC:  MOV     3802,W0
052CE:  CP      W0,#F
052D0:  BRA     GE,52F2
.................... 		{ 
.................... 		y=input_state(PIN_D0);   //wait for the bit to time out the zero for the next bit 
052D2:  CLR     W4
052D4:  BTSC.B  2DA.0
052D6:  INC     W4,W4
052D8:  MOV     W4,3804
.................... 		if (y) break; 
052DA:  MOV     3804,W0
052DC:  CP0     W0
052DE:  BRA     Z,52E4
052E0:  GOTO    52F2
.................... 		delay_us(5); 
052E4:  REPEAT  #4E
052E6:  NOP     
052E8:  MOV     3802,W0
052EA:  INC     W0,W0
052EC:  MOV     W0,3802
052EE:  GOTO    52CC
.................... 		} 
....................  
.................... 	for (x=0; x < 15; x++)   //This waits through the 1 to see how long it is. 
052F2:  MOV     #0,W4
052F4:  MOV     W4,3802
052F6:  MOV     3802,W0
052F8:  CP      W0,#F
052FA:  BRA     GE,531C
.................... 		{ 
.................... 		y=input_state(PIN_D0);   //wait for the first bit to pop up  Assuming is less than 200 us 
052FC:  CLR     W4
052FE:  BTSC.B  2DA.0
05300:  INC     W4,W4
05302:  MOV     W4,3804
.................... 		if (!y) break; 
05304:  MOV     3804,W0
05306:  CP0     W0
05308:  BRA     NZ,530E
0530A:  GOTO    531C
.................... 		delay_us(5); 
0530E:  REPEAT  #4E
05310:  NOP     
05312:  MOV     3802,W0
05314:  INC     W0,W0
05316:  MOV     W0,3802
05318:  GOTO    52F6
.................... 		} 
.................... 	 
....................  
.................... 	RawTemp=RawTemp<<1;	// Shift the whole word one bit left. 
0531C:  PUSH    380E
0531E:  POP     6
05320:  PUSH    3810
05322:  POP     8
05324:  SL      6
05326:  RLC     8
05328:  MOV     W3,380E
0532A:  MOV     W4,3810
.................... 	if (x > 6) 
0532C:  MOV     3802,W0
0532E:  CP      W0,#6
05330:  BRA     LE,533E
.................... 		{ 
.................... 		RawTemp = RawTemp + 0x0001; 
05332:  MOV     380E,W0
05334:  ADD     W0,#1,W0
05336:  MOV     W0,380E
05338:  MOV     3810,W4
0533A:  ADDC    W4,#0,W4
0533C:  MOV     W4,3810
.................... 		} 
0533E:  MOV     3808,W0
05340:  INC     W0,W0
05342:  MOV     W0,3808
05344:  GOTO    52C2
.................... 	} 
....................  
....................  
....................  
.................... CheckSum = 0; /// Clear out the variable 
05348:  MOV     #0,W4
0534A:  MOV     W4,3812
0534C:  MOV     #0,W4
0534E:  MOV     W4,3814
.................... for (counter=0; counter < 8; counter++) 
05350:  MOV     #0,W4
05352:  MOV     W4,3808
05354:  MOV     3808,W0
05356:  CP      W0,#8
05358:  BRA     GE,53DA
.................... 	{ 
.................... //This section collects the bits from the first 16 bits and places it in one varible. 
.................... 	for (x=0; x < 15; x++)   //This waits through the one and finds a 0 for the beginning of the first bit 
0535A:  MOV     #0,W4
0535C:  MOV     W4,3802
0535E:  MOV     3802,W0
05360:  CP      W0,#F
05362:  BRA     GE,5384
.................... 		{ 
.................... 		y=input_state(PIN_D0);   //wait for the bit to time out the zero for the next bit 
05364:  CLR     W4
05366:  BTSC.B  2DA.0
05368:  INC     W4,W4
0536A:  MOV     W4,3804
.................... 		if (y) break; 
0536C:  MOV     3804,W0
0536E:  CP0     W0
05370:  BRA     Z,5376
05372:  GOTO    5384
.................... 		delay_us(5); 
05376:  REPEAT  #4E
05378:  NOP     
0537A:  MOV     3802,W0
0537C:  INC     W0,W0
0537E:  MOV     W0,3802
05380:  GOTO    535E
.................... 		} 
....................  
.................... 	for (x=0; x < 15; x++)   //This waits through the 1 to see how long it is. 
05384:  MOV     #0,W4
05386:  MOV     W4,3802
05388:  MOV     3802,W0
0538A:  CP      W0,#F
0538C:  BRA     GE,53AE
.................... 		{ 
.................... 		y=input_state(PIN_D0);   //wait for the first bit to pop up  Assuming is less than 200 us 
0538E:  CLR     W4
05390:  BTSC.B  2DA.0
05392:  INC     W4,W4
05394:  MOV     W4,3804
.................... 		if (!y) break; 
05396:  MOV     3804,W0
05398:  CP0     W0
0539A:  BRA     NZ,53A0
0539C:  GOTO    53AE
.................... 		delay_us(5); 
053A0:  REPEAT  #4E
053A2:  NOP     
053A4:  MOV     3802,W0
053A6:  INC     W0,W0
053A8:  MOV     W0,3802
053AA:  GOTO    5388
.................... 		} 
.................... 	 
....................  
.................... 	CheckSum=CheckSum<<1;	// Shift the whole word one bit left. 
053AE:  PUSH    3812
053B0:  POP     6
053B2:  PUSH    3814
053B4:  POP     8
053B6:  SL      6
053B8:  RLC     8
053BA:  MOV     W3,3812
053BC:  MOV     W4,3814
.................... 	if (x > 6) 
053BE:  MOV     3802,W0
053C0:  CP      W0,#6
053C2:  BRA     LE,53D0
.................... 		{ 
.................... 		CheckSum = CheckSum + 0x0001; 
053C4:  MOV     3812,W0
053C6:  ADD     W0,#1,W0
053C8:  MOV     W0,3812
053CA:  MOV     3814,W4
053CC:  ADDC    W4,#0,W4
053CE:  MOV     W4,3814
.................... 		} 
053D0:  MOV     3808,W0
053D2:  INC     W0,W0
053D4:  MOV     W0,3808
053D6:  GOTO    5354
.................... 	} 
....................  
.................... 	RHData = (float)RawRH; 
053DA:  MOV     380A,W0
053DC:  MOV     380C,W1
053DE:  CALL    5098
053E2:  MOV     W0,30C4
053E4:  MOV     W1,30C6
....................  
.................... if (CheckSum == CheckSumRHTemp(RawRH,RawTemp)) 
053E6:  PUSH    380A
053E8:  POP     3816
053EA:  PUSH    380C
053EC:  POP     3818
053EE:  PUSH    380E
053F0:  POP     381A
053F2:  PUSH    3810
053F4:  POP     381C
053F6:  CALL    50E6
053FA:  CLR     W1
053FC:  BTSC    W0.F
053FE:  SETM    W1
05400:  MOV     3812,W4
05402:  CP      W0,W4
05404:  BRA     NZ,544C
05406:  MOV     3814,W3
05408:  CP      W1,W3
0540A:  BRA     NZ,544C
.................... 	{ 
.................... 	RHData = (float)RawRH/10.0; 
0540C:  MOV     380A,W0
0540E:  MOV     380C,W1
05410:  CALL    5098
05414:  MOV     W0,W5
05416:  MOV     W1,W6
05418:  MOV     W5,W0
0541A:  MOV     W6,W1
0541C:  MOV     #0,W2
0541E:  MOV     #4120,W3
05420:  CALL    4530
05424:  MOV     W0,30C4
05426:  MOV     W1,30C6
....................     Temperature = ((float)RawTemp)/10.0; 
05428:  MOV     380E,W0
0542A:  MOV     3810,W1
0542C:  CALL    5098
05430:  MOV     W0,W5
05432:  MOV     W1,W6
05434:  MOV     W5,W0
05436:  MOV     W6,W1
05438:  MOV     #0,W2
0543A:  MOV     #4120,W3
0543C:  CALL    4530
05440:  MOV     W0,30C8
05442:  MOV     W1,30CA
.................... 	return(0); 
05444:  CLR     0
05446:  BRA     5452
.................... 	} 
05448:  GOTO    5452
.................... 	else 
.................... 	{ 
.................... 	return(1); 
0544C:  MOV     #1,W4
0544E:  MOV     W4,0
05450:  BRA     5452
.................... 	} 
05452:  MOV     [--W15],W6
05454:  MOV     [--W15],W5
05456:  RETURN  
.................... 	} 
....................  
....................  
.................... #include "OsmobotSDCard\SDCardRoutines.c" 
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                           fat_ex.c                              //// 
.................... ////                                                                 //// 
.................... ////    This is a neat little shell utility that resembles a DOS or  //// 
.................... //// UNIX type shell in order to manipulate files on the FAT file    //// 
.................... //// system. This is mostly for demonstration purposes on how to use //// 
.................... //// some of the basic functionality of the FAT library.             //// 
.................... ////                                                                 //// 
.................... //// Type 'help' and press enter at the console prompt to get a list //// 
.................... //// of commands.                                                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////  Version History:                                               //// 
.................... ////     FEB 14th 2011                                               //// 
.................... ////        * Updated example to use Microchip's MDD library.        //// 
.................... ////        * Code will not automatically init/mount file system.    //// 
.................... ////           'mount' command must be performed to do this.         //// 
.................... ////        * You cannot use path-names when performing file         //// 
.................... ////           actions (cat, tail, append, make, del).  Instead      //// 
.................... ////           you have to be in the proper directory, and file      //// 
.................... ////           actions happen to files in that directory.            //// 
.................... ////        * 'format' command can now have 'k', 'm' or 'g' postfix  //// 
.................... ////           for size (k = 1024, m=1024*1024, etc).                //// 
.................... ////        * 'info' command added.                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... // define this to make it compatible with the ex_boot_ldr.c bootloader. 
.................... // otherwise don't define this. 
.................... //#define __USE_MDD_BOOTLOADER__ 
.................... #define MEDIA_SOFT_DETECT    //This means it uses talking to the card to see if there is a card present 
.................... //#define __DEBUG_UART 
....................  
.................... #define ALLOW_GET_DISK_PROPERTIES   //used by 'info' command 
....................  
.................... #include "Osmobotsdcard\ex_mdd_common.h" 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// 
.................... //// ex_mdd_common.h 
.................... //// 
.................... //// Common header file for CCS's MDD examples 
.................... //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2007 Custom Computer Services              //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //#define HW_CCS_3V_ETHERNET 
.................... //#define HW_CCS_DSP_AUDIO    //dsPIC33FJ 
.................... //#define HW_CCS_DSP_AUDIO2   //dsPIC33EP 
.................... #define HW_CCS_PIC24USB 
....................  
....................  
....................  
.................... #if defined(HW_CCS_PIC24USB) 
....................  //  #include <24FJ256GA106.h> 
....................  
.................... //   #fuses HS,PR_PLL,NOWDT,ICSP2,PLL5  did noy like 
.................... //   #fuses HS,PR_PLL,NOWDT,ICSP2 
....................    //C30/XC16 compiler to CCS PCH compiler compatability. 
....................    //also includes the filesystem. 
....................    //since this changes some #device settings, this needs to be include 
....................    //fairly soon in the build process. 
....................    #include "filesystem\filesystem.h"  
.................... //see about.txt in filesystem/ for information 
....................  
.................... #ifndef __FILESYSTEM_H__ 
.................... #define __FILESYSTEM_H__ 
....................  
.................... // If you cannot find these files, then change your include path 
.................... // to include the "CCSIncludes" directory.  This directory contains 
.................... // files that help port code from Microchip C to CCS C. 
.................... #if defined(__PCH__) 
....................    #include <p18cxxx.h> //Microchip C18 C Compiler to CCS PCH Conversion 
.................... #elif defined(__PCD__) 
....................    #define __CONST_IS_READONLY__ //work around for a difference between how CCS and C30 treats 'const' pointers 
....................    #include <..\OsmobotSDCard\CCSIncludes\PCDxxxx.h>  //Microchip C30 C Compiler to CCS PCH Conversion 
.................... #else 
....................    #error PIC18 or dsPIC/PIC24 support ONLY 
.................... #endif 
....................  
.................... #include "HardwareProfile.h" 
....................  
.................... #include "FSConfig.h" 
....................  
.................... #include "MDD File System\FSIO.h" 
....................  
.................... #endif 
....................  
....................  
....................  //  #use fast_io(ALL) 
....................  
....................  //  #use delay(clock=32M) 
.................... //#use delay( crystal=8mhz, clock=32mhz ) 
....................  
.................... //   #pin_select U1TX = PIN_D5 
.................... //   #pin_select U1RX = PIN_D4 
....................     
....................    //hardwareprofile.h is using spi2 for sd card, so pin select those 
....................   // #pin_select SDI2 = PIN_F5 
....................   // #pin_select SDO2 = PIN_B15 
....................   // #pin_select SCK2OUT = PIN_F4 
....................  
.................... //   #pin_select SDI1 = PIN_F6 
.................... //   #pin_select SDO1 = PIN_F2 
.................... //   #pin_select SCK1OUT = PIN_F3 
....................  
....................  
....................  
.................... //   #pin_select SDI2 = PIN_F6 
.................... //   #pin_select SDO2 = PIN_F2 
.................... //   #pin_select SCK2OUT = PIN_F3 
....................  
....................    #define AN_HOST_VOLTAGE 2 
....................    #define AN_POT          0 
....................  
.................... //   #define MY_ANALOG_PORTS (sAN2 | sAN0) 
....................     
.................... //   #define MY_ADC_SETUP    (ADC_CLOCK_INTERNAL|ADC_TAD_MUL_2) 
....................     
.................... //  #use rs232(UART1, baud=9600, stream=STREAM_USER_UART) 
....................    #define PIN_SDPOWER  PIN_G9 
.................... //   #define PIN_LED1  PIN_B11 
.................... //   #define PIN_LED2  PIN_B10 
.................... //   #define PIN_LED3  PIN_B9 
....................  
.................... //   #define GREEN_LED    PIN_B11 
.................... //   #define YELLOW_LED   PIN_B10 
.................... //   #define RED_LED      PIN_B9 
....................     
.................... //   #define LED_ON(x)    output_high(x) 
.................... //   #define LED_OFF(x)   output_low(x) 
....................     
.................... //   #define BUTTON_PRESSED()   !input(PIN_F0) 
.................... #endif 
....................  
.................... #if defined(__DEBUG_UART) 
....................    // these are microchip's style debugs 
....................    #define InitUART() 
....................    #define PrintROMASCIIStringUART(s)  fprintf(STREAM_USER_UART, s) 
....................    void PrintRAMBytesUART(char *p, unsigned int16 n)  
....................    { 
....................       while(n--) 
....................       { 
....................          fprintf(STREAM_USER_UART, "%X ", *p++); 
....................       } 
....................    } 
....................    #define UARTSendLineFeedCarriageReturn() fprintf(STREAM_USER_UART, "\r\n") 
.................... #endif 
....................  
.................... #if 0 
....................    #warning CCS Debugs Enabled 
....................     
....................   #if defined(__PCH__)  //uart1 
....................    #bit UART_TBE=getenv("BIT:TX1IF") 
....................    //#define WAIT_FOR_TX()   while(!UART_TBE) 
....................    #define WAIT_FOR_TX() 
....................   #else  //uart2 
....................    #word U2STA=getenv("SFR:U2STA") 
....................    #bit U2STA_TRMT=U2STA.8 
....................    #define UART_TBE  U2STA_TRMT 
....................    #define WAIT_FOR_TX()   while(!UART_TBE) 
....................   #endif 
....................        
....................    // application level debugs 
....................    #define DEBUG_STR(str, x) printf("\r\n"); printf("%s", str); printf(" 0x%LX", x); WAIT_FOR_TX() 
....................    #define DEBUG_STR2(str1, str2) printf("\r\n%s '%s'", str1, str2); WAIT_FOR_TX() 
....................     
....................    // library level debugs 
....................    #define DEBUG_FS_STR(str, x) printf("\r\n"); printf("%s", str); printf(" 0x%LX", x); WAIT_FOR_TX() 
....................    #define DEBUG_FS_STR2(str1, str2) printf("\r\n%s '%s'", str1, str2); WAIT_FOR_TX() 
....................     
....................    void DEBUG_FS_ARRAY(unsigned int8 *p, unsigned int16 len) 
....................    { 
....................       unsigned int16 i=0; 
....................       while(i < len) 
....................       { 
....................          if ((i%32) == 0) 
....................             printf("\r\n0x%LX: ", i); 
....................          printf("%02X", *p++); 
....................          i++; 
....................       } 
....................    } 
.................... #endif 
....................  
.................... #if defined(DEBUG_STR) 
.................... #include <pcd_traps.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          pcd_traps.c                              //// 
.................... ////                                                                   //// 
.................... //// On 16bit PICs (PIC24, dsPIC30, dsPIC33) there are special trap    //// 
.................... //// vectors that are called when a fault has happened.  This library  //// 
.................... //// will place routines on those vectors to display debugging         //// 
.................... //// information on the serial port about the fault.  The PC,          //// 
.................... //// working registers and other important PIC status registers        //// 
.................... //// are displayed on the serial port.                                 //// 
.................... ////                                                                   //// 
.................... //// The last #use_rs232() will be used.  Alternately, if the          //// 
.................... //// STREAM_SERIAL_INPUT is defind it will use that stream.            //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCD__) 
....................  
.................... #ifndef __PCD_TRAPS_C__ 
.................... #define __PCD_TRAPS_C__ 
....................  
.................... #if defined(STREAM_SERIAL_INPUT) 
....................    #inline 
....................    void TrapPutc(char c) 
....................    { 
....................       fputc(c, STREAM_SERIAL_INPUT); 
....................    } 
.................... #else 
....................    #inline 
....................    void TrapPutc(char c) 
....................    { 
....................       putc(c); 
*
017A8:  MOV     39D0,W0
017AA:  BTSC.B  223.1
017AC:  BRA     17AA
017AE:  MOV.B   W0L,224
017B0:  CLR.B   225
*
017F6:  MOV     39D0,W0
017F8:  BTSC.B  223.1
017FA:  BRA     17F8
017FC:  MOV.B   W0L,224
017FE:  CLR.B   225
*
01852:  MOV     39D0,W0
01854:  BTSC.B  223.1
01856:  BRA     1854
01858:  MOV.B   W0L,224
0185A:  CLR.B   225
*
01890:  MOV     39D0,W0
01892:  BTSC.B  223.1
01894:  BRA     1892
01896:  MOV.B   W0L,224
01898:  CLR.B   225
*
018DC:  MOV     39D0,W0
018DE:  BTSC.B  223.1
018E0:  BRA     18DE
018E2:  MOV.B   W0L,224
018E4:  CLR.B   225
*
0193C:  MOV     39D0,W0
0193E:  BTSC.B  223.1
01940:  BRA     193E
01942:  MOV.B   W0L,224
01944:  CLR.B   225
*
0194C:  MOV     39D0,W0
0194E:  BTSC.B  223.1
01950:  BRA     194E
01952:  MOV.B   W0L,224
01954:  CLR.B   225
*
0195C:  MOV     39D0,W0
0195E:  BTSC.B  223.1
01960:  BRA     195E
01962:  MOV.B   W0L,224
01964:  CLR.B   225
*
0197C:  MOV     39D0,W0
0197E:  BTSC.B  223.1
01980:  BRA     197E
01982:  MOV.B   W0L,224
01984:  CLR.B   225
*
019A2:  MOV     39D0,W0
019A4:  BTSC.B  223.1
019A6:  BRA     19A4
019A8:  MOV.B   W0L,224
019AA:  CLR.B   225
*
019C8:  MOV     39D0,W0
019CA:  BTSC.B  223.1
019CC:  BRA     19CA
019CE:  MOV.B   W0L,224
019D0:  CLR.B   225
*
019F2:  MOV     39D0,W0
019F4:  BTSC.B  223.1
019F6:  BRA     19F4
019F8:  MOV.B   W0L,224
019FA:  CLR.B   225
019FC:  MOV     [--W15],W5
*
01A0E:  MOV     39D0,W0
01A10:  BTSC.B  223.1
01A12:  BRA     1A10
01A14:  MOV.B   W0L,224
01A16:  CLR.B   225
01A18:  MOV     [--W15],W5
*
01A2A:  MOV     39D0,W0
01A2C:  BTSC.B  223.1
01A2E:  BRA     1A2C
01A30:  MOV.B   W0L,224
01A32:  CLR.B   225
01A34:  MOV     [--W15],W5
*
01A54:  MOV     39D0,W0
01A56:  BTSC.B  223.1
01A58:  BRA     1A56
01A5A:  MOV.B   W0L,224
01A5C:  CLR.B   225
*
01A74:  MOV     39D0,W0
01A76:  BTSC.B  223.1
01A78:  BRA     1A76
01A7A:  MOV.B   W0L,224
01A7C:  CLR.B   225
*
01A92:  MOV     39D0,W0
01A94:  BTSC.B  223.1
01A96:  BRA     1A94
01A98:  MOV.B   W0L,224
01A9A:  CLR.B   225
*
01AB2:  MOV     39D0,W0
01AB4:  BTSC.B  223.1
01AB6:  BRA     1AB4
01AB8:  MOV.B   W0L,224
01ABA:  CLR.B   225
*
01AD0:  MOV     39D0,W0
01AD2:  BTSC.B  223.1
01AD4:  BRA     1AD2
01AD6:  MOV.B   W0L,224
01AD8:  CLR.B   225
*
01AF0:  MOV     39D0,W0
01AF2:  BTSC.B  223.1
01AF4:  BRA     1AF2
01AF6:  MOV.B   W0L,224
01AF8:  CLR.B   225
*
01B00:  MOV     39D0,W0
01B02:  BTSC.B  223.1
01B04:  BRA     1B02
01B06:  MOV.B   W0L,224
01B08:  CLR.B   225
*
01B10:  MOV     39D0,W0
01B12:  BTSC.B  223.1
01B14:  BRA     1B12
01B16:  MOV.B   W0L,224
01B18:  CLR.B   225
*
01B70:  MOV     39D0,W0
01B72:  BTSC.B  223.1
01B74:  BRA     1B72
01B76:  MOV.B   W0L,224
01B78:  CLR.B   225
*
01B80:  MOV     39D0,W0
01B82:  BTSC.B  223.1
01B84:  BRA     1B82
01B86:  MOV.B   W0L,224
01B88:  CLR.B   225
*
01B90:  MOV     39D0,W0
01B92:  BTSC.B  223.1
01B94:  BRA     1B92
01B96:  MOV.B   W0L,224
01B98:  CLR.B   225
*
01BB0:  MOV     39D0,W0
01BB2:  BTSC.B  223.1
01BB4:  BRA     1BB2
01BB6:  MOV.B   W0L,224
01BB8:  CLR.B   225
*
01BD6:  MOV     39D0,W0
01BD8:  BTSC.B  223.1
01BDA:  BRA     1BD8
01BDC:  MOV.B   W0L,224
01BDE:  CLR.B   225
*
01BFC:  MOV     39D0,W0
01BFE:  BTSC.B  223.1
01C00:  BRA     1BFE
01C02:  MOV.B   W0L,224
01C04:  CLR.B   225
*
01C26:  MOV     39D0,W0
01C28:  BTSC.B  223.1
01C2A:  BRA     1C28
01C2C:  MOV.B   W0L,224
01C2E:  CLR.B   225
01C30:  MOV     [--W15],W5
*
01C42:  MOV     39D0,W0
01C44:  BTSC.B  223.1
01C46:  BRA     1C44
01C48:  MOV.B   W0L,224
01C4A:  CLR.B   225
01C4C:  MOV     [--W15],W5
*
01C5E:  MOV     39D0,W0
01C60:  BTSC.B  223.1
01C62:  BRA     1C60
01C64:  MOV.B   W0L,224
01C66:  CLR.B   225
01C68:  MOV     [--W15],W5
*
01C88:  MOV     39D0,W0
01C8A:  BTSC.B  223.1
01C8C:  BRA     1C8A
01C8E:  MOV.B   W0L,224
01C90:  CLR.B   225
*
01CA8:  MOV     39D0,W0
01CAA:  BTSC.B  223.1
01CAC:  BRA     1CAA
01CAE:  MOV.B   W0L,224
01CB0:  CLR.B   225
*
01CC6:  MOV     39D0,W0
01CC8:  BTSC.B  223.1
01CCA:  BRA     1CC8
01CCC:  MOV.B   W0L,224
01CCE:  CLR.B   225
*
01CE6:  MOV     39D0,W0
01CE8:  BTSC.B  223.1
01CEA:  BRA     1CE8
01CEC:  MOV.B   W0L,224
01CEE:  CLR.B   225
*
01D04:  MOV     39D0,W0
01D06:  BTSC.B  223.1
01D08:  BRA     1D06
01D0A:  MOV.B   W0L,224
01D0C:  CLR.B   225
*
01D24:  MOV     39D0,W0
01D26:  BTSC.B  223.1
01D28:  BRA     1D26
01D2A:  MOV.B   W0L,224
01D2C:  CLR.B   225
*
01D34:  MOV     39D0,W0
01D36:  BTSC.B  223.1
01D38:  BRA     1D36
01D3A:  MOV.B   W0L,224
01D3C:  CLR.B   225
*
01D44:  MOV     39D0,W0
01D46:  BTSC.B  223.1
01D48:  BRA     1D46
01D4A:  MOV.B   W0L,224
01D4C:  CLR.B   225
*
01DA4:  MOV     39D0,W0
01DA6:  BTSC.B  223.1
01DA8:  BRA     1DA6
01DAA:  MOV.B   W0L,224
01DAC:  CLR.B   225
*
01DB4:  MOV     39D0,W0
01DB6:  BTSC.B  223.1
01DB8:  BRA     1DB6
01DBA:  MOV.B   W0L,224
01DBC:  CLR.B   225
*
01DC4:  MOV     39D0,W0
01DC6:  BTSC.B  223.1
01DC8:  BRA     1DC6
01DCA:  MOV.B   W0L,224
01DCC:  CLR.B   225
*
01DE4:  MOV     39D0,W0
01DE6:  BTSC.B  223.1
01DE8:  BRA     1DE6
01DEA:  MOV.B   W0L,224
01DEC:  CLR.B   225
*
01E0A:  MOV     39D0,W0
01E0C:  BTSC.B  223.1
01E0E:  BRA     1E0C
01E10:  MOV.B   W0L,224
01E12:  CLR.B   225
*
01E30:  MOV     39D0,W0
01E32:  BTSC.B  223.1
01E34:  BRA     1E32
01E36:  MOV.B   W0L,224
01E38:  CLR.B   225
*
01E5A:  MOV     39D0,W0
01E5C:  BTSC.B  223.1
01E5E:  BRA     1E5C
01E60:  MOV.B   W0L,224
01E62:  CLR.B   225
01E64:  MOV     [--W15],W5
*
01E76:  MOV     39D0,W0
01E78:  BTSC.B  223.1
01E7A:  BRA     1E78
01E7C:  MOV.B   W0L,224
01E7E:  CLR.B   225
01E80:  MOV     [--W15],W5
*
01E92:  MOV     39D0,W0
01E94:  BTSC.B  223.1
01E96:  BRA     1E94
01E98:  MOV.B   W0L,224
01E9A:  CLR.B   225
01E9C:  MOV     [--W15],W5
*
01EBC:  MOV     39D0,W0
01EBE:  BTSC.B  223.1
01EC0:  BRA     1EBE
01EC2:  MOV.B   W0L,224
01EC4:  CLR.B   225
*
01EDC:  MOV     39D0,W0
01EDE:  BTSC.B  223.1
01EE0:  BRA     1EDE
01EE2:  MOV.B   W0L,224
01EE4:  CLR.B   225
*
01EFA:  MOV     39D0,W0
01EFC:  BTSC.B  223.1
01EFE:  BRA     1EFC
01F00:  MOV.B   W0L,224
01F02:  CLR.B   225
*
01F1A:  MOV     39D0,W0
01F1C:  BTSC.B  223.1
01F1E:  BRA     1F1C
01F20:  MOV.B   W0L,224
01F22:  CLR.B   225
*
01F38:  MOV     39D0,W0
01F3A:  BTSC.B  223.1
01F3C:  BRA     1F3A
01F3E:  MOV.B   W0L,224
01F40:  CLR.B   225
*
01F58:  MOV     39D0,W0
01F5A:  BTSC.B  223.1
01F5C:  BRA     1F5A
01F5E:  MOV.B   W0L,224
01F60:  CLR.B   225
*
01F68:  MOV     39D0,W0
01F6A:  BTSC.B  223.1
01F6C:  BRA     1F6A
01F6E:  MOV.B   W0L,224
01F70:  CLR.B   225
*
01F78:  MOV     39D0,W0
01F7A:  BTSC.B  223.1
01F7C:  BRA     1F7A
01F7E:  MOV.B   W0L,224
01F80:  CLR.B   225
*
01FD8:  MOV     39D0,W0
01FDA:  BTSC.B  223.1
01FDC:  BRA     1FDA
01FDE:  MOV.B   W0L,224
01FE0:  CLR.B   225
*
01FE8:  MOV     39D0,W0
01FEA:  BTSC.B  223.1
01FEC:  BRA     1FEA
01FEE:  MOV.B   W0L,224
01FF0:  CLR.B   225
*
01FF8:  MOV     39D0,W0
01FFA:  BTSC.B  223.1
01FFC:  BRA     1FFA
01FFE:  MOV.B   W0L,224
02000:  CLR.B   225
*
02018:  MOV     39D0,W0
0201A:  BTSC.B  223.1
0201C:  BRA     201A
0201E:  MOV.B   W0L,224
02020:  CLR.B   225
*
0203E:  MOV     39D0,W0
02040:  BTSC.B  223.1
02042:  BRA     2040
02044:  MOV.B   W0L,224
02046:  CLR.B   225
*
02064:  MOV     39D0,W0
02066:  BTSC.B  223.1
02068:  BRA     2066
0206A:  MOV.B   W0L,224
0206C:  CLR.B   225
*
0208E:  MOV     39D0,W0
02090:  BTSC.B  223.1
02092:  BRA     2090
02094:  MOV.B   W0L,224
02096:  CLR.B   225
02098:  MOV     [--W15],W5
*
020AA:  MOV     39D0,W0
020AC:  BTSC.B  223.1
020AE:  BRA     20AC
020B0:  MOV.B   W0L,224
020B2:  CLR.B   225
020B4:  MOV     [--W15],W5
*
020C6:  MOV     39D0,W0
020C8:  BTSC.B  223.1
020CA:  BRA     20C8
020CC:  MOV.B   W0L,224
020CE:  CLR.B   225
020D0:  MOV     [--W15],W5
*
020F0:  MOV     39D0,W0
020F2:  BTSC.B  223.1
020F4:  BRA     20F2
020F6:  MOV.B   W0L,224
020F8:  CLR.B   225
*
02110:  MOV     39D0,W0
02112:  BTSC.B  223.1
02114:  BRA     2112
02116:  MOV.B   W0L,224
02118:  CLR.B   225
*
0212E:  MOV     39D0,W0
02130:  BTSC.B  223.1
02132:  BRA     2130
02134:  MOV.B   W0L,224
02136:  CLR.B   225
*
0214E:  MOV     39D0,W0
02150:  BTSC.B  223.1
02152:  BRA     2150
02154:  MOV.B   W0L,224
02156:  CLR.B   225
*
0216C:  MOV     39D0,W0
0216E:  BTSC.B  223.1
02170:  BRA     216E
02172:  MOV.B   W0L,224
02174:  CLR.B   225
*
0218C:  MOV     39D0,W0
0218E:  BTSC.B  223.1
02190:  BRA     218E
02192:  MOV.B   W0L,224
02194:  CLR.B   225
*
0219C:  MOV     39D0,W0
0219E:  BTSC.B  223.1
021A0:  BRA     219E
021A2:  MOV.B   W0L,224
021A4:  CLR.B   225
*
021AC:  MOV     39D0,W0
021AE:  BTSC.B  223.1
021B0:  BRA     21AE
021B2:  MOV.B   W0L,224
021B4:  CLR.B   225
....................    } 
.................... #endif 
....................  
.................... #word PCD_SFR_W0REG=0 
.................... #word PCD_SFR_W1REG=2 
.................... #word PCD_SFR_W2REG=4 
.................... #word PCD_SFR_W3REG=6 
.................... #word PCD_SFR_W4REG=8 
.................... #word PCD_SFR_W5REG=10 
.................... #word PCD_SFR_W6REG=12 
.................... #word PCD_SFR_W7REG=14 
.................... #word PCD_SFR_W8REG=16 
.................... #word PCD_SFR_W9REG=18 
.................... #word PCD_SFR_W10REG=20 
.................... #word PCD_SFR_W11REG=22 
.................... #word PCD_SFR_W12REG=24 
.................... #word PCD_SFR_W13REG=26 
.................... #word PCD_SFR_W14REG=28 
.................... #word PCD_SFR_W15REG=30 
....................  
.................... #if (getenv("SFR_VALID:PSVPAG")) 
....................    #word PCD_SFR_PSVPAG=getenv("SFR:PSVPAG") 
.................... #endif 
....................  
.................... #if (getenv("SFR_VALID:DSRPAG")) 
....................    #word PCD_SFR_DSRPAG=getenv("SFR:DSRPAG") 
.................... #endif 
....................  
.................... #if (getenv("SFR_VALID:DSWPAG")) 
....................    #word PCD_SFR_DSWPAG=getenv("SFR:DSWPAG") 
.................... #endif 
....................  
.................... #if (getenv("SFR_VALID:TBLPAG")) 
....................    #word PCD_SFR_TBLPAG=getenv("SFR:TBLPAG") 
....................    unsigned int16 g_TrapTBLPAG; 
.................... #endif 
....................  
.................... #word PCD_SFR_CORCON=getenv("SFR:CORCON") 
....................  
.................... struct 
.................... { 
....................    unsigned int16 w[16]; 
....................    unsigned int32 addy; 
.................... } g_Trap; 
....................  
.................... unsigned int16 g_TrapH, g_TrapL; 
....................  
.................... #if (getenv("SFR_VALID:TBLPAG")) 
....................    #define PCD_TRAPS_MEMORY_USED 42 
.................... #else 
....................    #define PCD_TRAPS_MEMORY_USED 40 
.................... #endif 
....................  
.................... #inline  
.................... void TRAP_START(void) 
.................... { 
....................   #asm  
....................    POP g_TrapH; 
*
018F4:  POP     30F2
*
01B28:  POP     30F2
*
01D5C:  POP     30F2
*
01F90:  POP     30F2
....................    POP g_TrapL; 
*
018F6:  POP     30F4
*
01B2A:  POP     30F4
*
01D5E:  POP     30F4
*
01F92:  POP     30F4
....................   #endasm 
....................        
....................    g_Trap.w[0] = PCD_SFR_W0REG; 
*
018F8:  MOV     W0,30CE
*
01B2C:  MOV     W0,30CE
*
01D60:  MOV     W0,30CE
*
01F94:  MOV     W0,30CE
....................    g_Trap.w[1] = PCD_SFR_W1REG; 
*
018FA:  MOV     W1,30D0
*
01B2E:  MOV     W1,30D0
*
01D62:  MOV     W1,30D0
*
01F96:  MOV     W1,30D0
....................    g_Trap.w[2] = PCD_SFR_W2REG; 
*
018FC:  MOV     W2,30D2
*
01B30:  MOV     W2,30D2
*
01D64:  MOV     W2,30D2
*
01F98:  MOV     W2,30D2
....................    g_Trap.w[3] = PCD_SFR_W3REG; 
*
018FE:  MOV     W3,30D4
*
01B32:  MOV     W3,30D4
*
01D66:  MOV     W3,30D4
*
01F9A:  MOV     W3,30D4
....................    g_Trap.w[4] = PCD_SFR_W4REG; 
*
01900:  MOV     W4,30D6
*
01B34:  MOV     W4,30D6
*
01D68:  MOV     W4,30D6
*
01F9C:  MOV     W4,30D6
....................    g_Trap.w[5] = PCD_SFR_W5REG; 
*
01902:  MOV     W5,30D8
*
01B36:  MOV     W5,30D8
*
01D6A:  MOV     W5,30D8
*
01F9E:  MOV     W5,30D8
....................    g_Trap.w[6] = PCD_SFR_W6REG; 
*
01904:  MOV     W6,30DA
*
01B38:  MOV     W6,30DA
*
01D6C:  MOV     W6,30DA
*
01FA0:  MOV     W6,30DA
....................    g_Trap.w[7] = PCD_SFR_W7REG; 
*
01906:  MOV     W7,30DC
*
01B3A:  MOV     W7,30DC
*
01D6E:  MOV     W7,30DC
*
01FA2:  MOV     W7,30DC
....................    g_Trap.w[8] = PCD_SFR_W8REG; 
*
01908:  MOV     W8,30DE
*
01B3C:  MOV     W8,30DE
*
01D70:  MOV     W8,30DE
*
01FA4:  MOV     W8,30DE
....................    g_Trap.w[9] = PCD_SFR_W9REG; 
*
0190A:  MOV     W9,30E0
*
01B3E:  MOV     W9,30E0
*
01D72:  MOV     W9,30E0
*
01FA6:  MOV     W9,30E0
....................    g_Trap.w[10] = PCD_SFR_W10REG; 
*
0190C:  MOV     W10,30E2
*
01B40:  MOV     W10,30E2
*
01D74:  MOV     W10,30E2
*
01FA8:  MOV     W10,30E2
....................    g_Trap.w[11] = PCD_SFR_W11REG; 
*
0190E:  MOV     W11,30E4
*
01B42:  MOV     W11,30E4
*
01D76:  MOV     W11,30E4
*
01FAA:  MOV     W11,30E4
....................    g_Trap.w[12] = PCD_SFR_W12REG; 
*
01910:  MOV     W12,30E6
*
01B44:  MOV     W12,30E6
*
01D78:  MOV     W12,30E6
*
01FAC:  MOV     W12,30E6
....................    g_Trap.w[13] = PCD_SFR_W13REG; 
*
01912:  MOV     W13,30E8
*
01B46:  MOV     W13,30E8
*
01D7A:  MOV     W13,30E8
*
01FAE:  MOV     W13,30E8
....................    g_Trap.w[14] = PCD_SFR_W14REG; 
*
01914:  MOV     W14,30EA
*
01B48:  MOV     W14,30EA
*
01D7C:  MOV     W14,30EA
*
01FB0:  MOV     W14,30EA
....................    g_Trap.w[15] = PCD_SFR_W15REG; 
*
01916:  MOV     W15,30EC
*
01B4A:  MOV     W15,30EC
*
01D7E:  MOV     W15,30EC
*
01FB2:  MOV     W15,30EC
....................  
....................   #if (getenv("SFR_VALID:TBLPAG")) 
....................    g_TrapTBLPAG = PCD_SFR_TBLPAG; 
*
01918:  PUSH    32
0191A:  POP     30CC
*
01B4C:  PUSH    32
01B4E:  POP     30CC
*
01D80:  PUSH    32
01D82:  POP     30CC
*
01FB4:  PUSH    32
01FB6:  POP     30CC
....................   #endif 
....................  
....................    g_TrapH &= 0x00FF; 
*
0191C:  MOV     30F2,W0
0191E:  AND     #FF,W0
01920:  MOV     W0,30F2
*
01B50:  MOV     30F2,W0
01B52:  AND     #FF,W0
01B54:  MOV     W0,30F2
*
01D84:  MOV     30F2,W0
01D86:  AND     #FF,W0
01D88:  MOV     W0,30F2
*
01FB8:  MOV     30F2,W0
01FBA:  AND     #FF,W0
01FBC:  MOV     W0,30F2
....................  
....................    g_Trap.addy = make32(g_TrapH, g_TrapL); 
*
01922:  PUSH    30F2
01924:  POP     30F0
01926:  PUSH    30F4
01928:  POP     30EE
*
01B56:  PUSH    30F2
01B58:  POP     30F0
01B5A:  PUSH    30F4
01B5C:  POP     30EE
*
01D8A:  PUSH    30F2
01D8C:  POP     30F0
01D8E:  PUSH    30F4
01D90:  POP     30EE
*
01FBE:  PUSH    30F2
01FC0:  POP     30F0
01FC2:  PUSH    30F4
01FC4:  POP     30EE
....................    g_Trap.addy -= 2; 
*
0192A:  MOV     30EE,W0
0192C:  SUB     W0,#2,W0
0192E:  MOV     W0,30EE
01930:  MOV     30F0,W0
01932:  SUBB    W0,#0,W0
01934:  MOV     W0,30F0
*
01B5E:  MOV     30EE,W0
01B60:  SUB     W0,#2,W0
01B62:  MOV     W0,30EE
01B64:  MOV     30F0,W0
01B66:  SUBB    W0,#0,W0
01B68:  MOV     W0,30F0
*
01D92:  MOV     30EE,W0
01D94:  SUB     W0,#2,W0
01D96:  MOV     W0,30EE
01D98:  MOV     30F0,W0
01D9A:  SUBB    W0,#0,W0
01D9C:  MOV     W0,30F0
*
01FC6:  MOV     30EE,W0
01FC8:  SUB     W0,#2,W0
01FCA:  MOV     W0,30EE
01FCC:  MOV     30F0,W0
01FCE:  SUBB    W0,#0,W0
01FD0:  MOV     W0,30F0
....................     
....................    printf(TrapPutc, "\r\n\n"); 
*
01936:  MOV     39D0,W0
01938:  MOV.B   #D,W0L
0193A:  MOV     W0,39D0
*
01946:  MOV     39D0,W0
01948:  MOV.B   #A,W0L
0194A:  MOV     W0,39D0
*
01956:  MOV     39D0,W0
01958:  MOV.B   #A,W0L
0195A:  MOV     W0,39D0
*
01966:  NOP     
*
01B6A:  MOV     39D0,W0
01B6C:  MOV.B   #D,W0L
01B6E:  MOV     W0,39D0
*
01B7A:  MOV     39D0,W0
01B7C:  MOV.B   #A,W0L
01B7E:  MOV     W0,39D0
*
01B8A:  MOV     39D0,W0
01B8C:  MOV.B   #A,W0L
01B8E:  MOV     W0,39D0
*
01B9A:  NOP     
*
01D9E:  MOV     39D0,W0
01DA0:  MOV.B   #D,W0L
01DA2:  MOV     W0,39D0
*
01DAE:  MOV     39D0,W0
01DB0:  MOV.B   #A,W0L
01DB2:  MOV     W0,39D0
*
01DBE:  MOV     39D0,W0
01DC0:  MOV.B   #A,W0L
01DC2:  MOV     W0,39D0
*
01DCE:  NOP     
*
01FD2:  MOV     39D0,W0
01FD4:  MOV.B   #D,W0L
01FD6:  MOV     W0,39D0
*
01FE2:  MOV     39D0,W0
01FE4:  MOV.B   #A,W0L
01FE6:  MOV     W0,39D0
*
01FF2:  MOV     39D0,W0
01FF4:  MOV.B   #A,W0L
01FF6:  MOV     W0,39D0
*
02002:  NOP     
.................... } 
....................  
.................... #inline  
.................... void TRAP_DISPLAY(void) 
.................... { 
....................    printf(TrapPutc, " PC:%LX ", g_Trap.addy); 
*
0198E:  MOV     #0,W1
01990:  MOV     W1,W0
01992:  CLR.B   1
01994:  CALL    14B0
01998:  INC     W1,W1
0199A:  MOV     W1,[W15++]
0199C:  PUSH    39D0
0199E:  MOV.B   W0L,[W15-#2]
019A0:  POP     39D0
*
019AC:  MOV     [--W15],W1
019AE:  MOV     #3,W0
019B0:  CPSGT   W1,W0
019B2:  BRA     1990
019B4:  MOV     30EE,W0
019B6:  MOV     30F0,W1
019B8:  MOV     #0,W2
019BA:  MOV     #0,W3
019BC:  MOV     #710,W4
019BE:  CALL    1760
019C2:  MOV     39D0,W0
019C4:  MOV.B   #20,W0L
019C6:  MOV     W0,39D0
*
01BC2:  MOV     #0,W1
01BC4:  MOV     W1,W0
01BC6:  CLR.B   1
01BC8:  CALL    14B0
01BCC:  INC     W1,W1
01BCE:  MOV     W1,[W15++]
01BD0:  PUSH    39D0
01BD2:  MOV.B   W0L,[W15-#2]
01BD4:  POP     39D0
*
01BE0:  MOV     [--W15],W1
01BE2:  MOV     #3,W0
01BE4:  CPSGT   W1,W0
01BE6:  BRA     1BC4
01BE8:  MOV     30EE,W0
01BEA:  MOV     30F0,W1
01BEC:  MOV     #0,W2
01BEE:  MOV     #0,W3
01BF0:  MOV     #710,W4
01BF2:  CALL    1760
01BF6:  MOV     39D0,W0
01BF8:  MOV.B   #20,W0L
01BFA:  MOV     W0,39D0
*
01DF6:  MOV     #0,W1
01DF8:  MOV     W1,W0
01DFA:  CLR.B   1
01DFC:  CALL    14B0
01E00:  INC     W1,W1
01E02:  MOV     W1,[W15++]
01E04:  PUSH    39D0
01E06:  MOV.B   W0L,[W15-#2]
01E08:  POP     39D0
*
01E14:  MOV     [--W15],W1
01E16:  MOV     #3,W0
01E18:  CPSGT   W1,W0
01E1A:  BRA     1DF8
01E1C:  MOV     30EE,W0
01E1E:  MOV     30F0,W1
01E20:  MOV     #0,W2
01E22:  MOV     #0,W3
01E24:  MOV     #710,W4
01E26:  CALL    1760
01E2A:  MOV     39D0,W0
01E2C:  MOV.B   #20,W0L
01E2E:  MOV     W0,39D0
*
0202A:  MOV     #0,W1
0202C:  MOV     W1,W0
0202E:  CLR.B   1
02030:  CALL    14B0
02034:  INC     W1,W1
02036:  MOV     W1,[W15++]
02038:  PUSH    39D0
0203A:  MOV.B   W0L,[W15-#2]
0203C:  POP     39D0
*
02048:  MOV     [--W15],W1
0204A:  MOV     #3,W0
0204C:  CPSGT   W1,W0
0204E:  BRA     202C
02050:  MOV     30EE,W0
02052:  MOV     30F0,W1
02054:  MOV     #0,W2
02056:  MOV     #0,W3
02058:  MOV     #710,W4
0205A:  CALL    1760
0205E:  MOV     39D0,W0
02060:  MOV.B   #20,W0L
02062:  MOV     W0,39D0
....................     
....................    for (g_TrapL=0; g_TrapL<16; g_TrapL++) 
*
019D2:  MOV     #0,W4
019D4:  MOV     W4,30F4
019D6:  MOV     30F4,W0
019D8:  CP      W0,#10
019DA:  BRA     C,1A40
*
01C06:  MOV     #0,W4
01C08:  MOV     W4,30F4
01C0A:  MOV     30F4,W0
01C0C:  CP      W0,#10
01C0E:  BRA     C,1C74
*
01E3A:  MOV     #0,W4
01E3C:  MOV     W4,30F4
01E3E:  MOV     30F4,W0
01E40:  CP      W0,#10
01E42:  BRA     C,1EA8
*
0206E:  MOV     #0,W4
02070:  MOV     W4,30F4
02072:  MOV     30F4,W0
02074:  CP      W0,#10
02076:  BRA     C,20DC
....................    { 
....................       printf(TrapPutc, "W%U:%LX ", g_TrapL, g_Trap.w[g_TrapL]); 
*
019DC:  MOV     30F4,W0
019DE:  SL      W0,#1,W0
019E0:  MOV     #30CE,W4
019E2:  ADD     W0,W4,W0
019E4:  MOV     [W0],W5
019E6:  MOV     W5,[W15++]
019E8:  MOV     W0,[W15++]
019EA:  MOV     39D0,W0
019EC:  MOV.B   #57,W0L
019EE:  MOV     W0,39D0
019F0:  MOV     [--W15],W0
*
019FE:  MOV     30F4,W0
01A00:  MOV     #0,W4
01A02:  CALL    17C4
01A06:  MOV     W5,[W15++]
01A08:  MOV     39D0,W0
01A0A:  MOV.B   #3A,W0L
01A0C:  MOV     W0,39D0
*
01A1A:  MOV     W5,W0
01A1C:  MOV     #704,W1
01A1E:  CALL    18A8
01A22:  MOV     W5,[W15++]
01A24:  MOV     39D0,W0
01A26:  MOV.B   #20,W0L
01A28:  MOV     W0,39D0
*
01C10:  MOV     30F4,W0
01C12:  SL      W0,#1,W0
01C14:  MOV     #30CE,W4
01C16:  ADD     W0,W4,W0
01C18:  MOV     [W0],W5
01C1A:  MOV     W5,[W15++]
01C1C:  MOV     W0,[W15++]
01C1E:  MOV     39D0,W0
01C20:  MOV.B   #57,W0L
01C22:  MOV     W0,39D0
01C24:  MOV     [--W15],W0
*
01C32:  MOV     30F4,W0
01C34:  MOV     #0,W4
01C36:  CALL    17C4
01C3A:  MOV     W5,[W15++]
01C3C:  MOV     39D0,W0
01C3E:  MOV.B   #3A,W0L
01C40:  MOV     W0,39D0
*
01C4E:  MOV     W5,W0
01C50:  MOV     #704,W1
01C52:  CALL    18A8
01C56:  MOV     W5,[W15++]
01C58:  MOV     39D0,W0
01C5A:  MOV.B   #20,W0L
01C5C:  MOV     W0,39D0
*
01E44:  MOV     30F4,W0
01E46:  SL      W0,#1,W0
01E48:  MOV     #30CE,W4
01E4A:  ADD     W0,W4,W0
01E4C:  MOV     [W0],W5
01E4E:  MOV     W5,[W15++]
01E50:  MOV     W0,[W15++]
01E52:  MOV     39D0,W0
01E54:  MOV.B   #57,W0L
01E56:  MOV     W0,39D0
01E58:  MOV     [--W15],W0
*
01E66:  MOV     30F4,W0
01E68:  MOV     #0,W4
01E6A:  CALL    17C4
01E6E:  MOV     W5,[W15++]
01E70:  MOV     39D0,W0
01E72:  MOV.B   #3A,W0L
01E74:  MOV     W0,39D0
*
01E82:  MOV     W5,W0
01E84:  MOV     #704,W1
01E86:  CALL    18A8
01E8A:  MOV     W5,[W15++]
01E8C:  MOV     39D0,W0
01E8E:  MOV.B   #20,W0L
01E90:  MOV     W0,39D0
*
02078:  MOV     30F4,W0
0207A:  SL      W0,#1,W0
0207C:  MOV     #30CE,W4
0207E:  ADD     W0,W4,W0
02080:  MOV     [W0],W5
02082:  MOV     W5,[W15++]
02084:  MOV     W0,[W15++]
02086:  MOV     39D0,W0
02088:  MOV.B   #57,W0L
0208A:  MOV     W0,39D0
0208C:  MOV     [--W15],W0
*
0209A:  MOV     30F4,W0
0209C:  MOV     #0,W4
0209E:  CALL    17C4
020A2:  MOV     W5,[W15++]
020A4:  MOV     39D0,W0
020A6:  MOV.B   #3A,W0L
020A8:  MOV     W0,39D0
*
020B6:  MOV     W5,W0
020B8:  MOV     #704,W1
020BA:  CALL    18A8
020BE:  MOV     W5,[W15++]
020C0:  MOV     39D0,W0
020C2:  MOV.B   #20,W0L
020C4:  MOV     W0,39D0
....................    } 
....................    
....................   #if (getenv("SFR_VALID:PSVPAG")) 
*
01A36:  MOV     30F4,W0
01A38:  INC     W0,W0
01A3A:  MOV     W0,30F4
01A3C:  GOTO    19D6
*
01C6A:  MOV     30F4,W0
01C6C:  INC     W0,W0
01C6E:  MOV     W0,30F4
01C70:  GOTO    1C0A
*
01E9E:  MOV     30F4,W0
01EA0:  INC     W0,W0
01EA2:  MOV     W0,30F4
01EA4:  GOTO    1E3E
*
020D2:  MOV     30F4,W0
020D4:  INC     W0,W0
020D6:  MOV     W0,30F4
020D8:  GOTO    2072
....................    printf(TrapPutc, "PSVPAG:%LX ", PCD_SFR_PSVPAG); 
*
01A40:  MOV     #0,W1
01A42:  MOV     W1,W0
01A44:  CLR.B   1
01A46:  CALL    14C6
01A4A:  INC     W1,W1
01A4C:  MOV     W1,[W15++]
01A4E:  PUSH    39D0
01A50:  MOV.B   W0L,[W15-#2]
01A52:  POP     39D0
*
01A5E:  MOV     [--W15],W1
01A60:  MOV     #6,W0
01A62:  CPSGT   W1,W0
01A64:  BRA     1A42
01A66:  MOV     34,W0
01A68:  MOV     #704,W1
01A6A:  CALL    18A8
01A6E:  MOV     39D0,W0
01A70:  MOV.B   #20,W0L
01A72:  MOV     W0,39D0
*
01C74:  MOV     #0,W1
01C76:  MOV     W1,W0
01C78:  CLR.B   1
01C7A:  CALL    14C6
01C7E:  INC     W1,W1
01C80:  MOV     W1,[W15++]
01C82:  PUSH    39D0
01C84:  MOV.B   W0L,[W15-#2]
01C86:  POP     39D0
*
01C92:  MOV     [--W15],W1
01C94:  MOV     #6,W0
01C96:  CPSGT   W1,W0
01C98:  BRA     1C76
01C9A:  MOV     34,W0
01C9C:  MOV     #704,W1
01C9E:  CALL    18A8
01CA2:  MOV     39D0,W0
01CA4:  MOV.B   #20,W0L
01CA6:  MOV     W0,39D0
*
01EA8:  MOV     #0,W1
01EAA:  MOV     W1,W0
01EAC:  CLR.B   1
01EAE:  CALL    14C6
01EB2:  INC     W1,W1
01EB4:  MOV     W1,[W15++]
01EB6:  PUSH    39D0
01EB8:  MOV.B   W0L,[W15-#2]
01EBA:  POP     39D0
*
01EC6:  MOV     [--W15],W1
01EC8:  MOV     #6,W0
01ECA:  CPSGT   W1,W0
01ECC:  BRA     1EAA
01ECE:  MOV     34,W0
01ED0:  MOV     #704,W1
01ED2:  CALL    18A8
01ED6:  MOV     39D0,W0
01ED8:  MOV.B   #20,W0L
01EDA:  MOV     W0,39D0
*
020DC:  MOV     #0,W1
020DE:  MOV     W1,W0
020E0:  CLR.B   1
020E2:  CALL    14C6
020E6:  INC     W1,W1
020E8:  MOV     W1,[W15++]
020EA:  PUSH    39D0
020EC:  MOV.B   W0L,[W15-#2]
020EE:  POP     39D0
*
020FA:  MOV     [--W15],W1
020FC:  MOV     #6,W0
020FE:  CPSGT   W1,W0
02100:  BRA     20DE
02102:  MOV     34,W0
02104:  MOV     #704,W1
02106:  CALL    18A8
0210A:  MOV     39D0,W0
0210C:  MOV.B   #20,W0L
0210E:  MOV     W0,39D0
....................   #endif 
....................  
....................   #if (getenv("SFR_VALID:DSRPAG")) 
....................    printf(TrapPutc, "DSRPAG:%LX ", PCD_SFR_DSRPAG); 
....................   #endif 
....................  
....................   #if (getenv("SFR_VALID:DSWPAG")) 
....................    printf(TrapPutc, "DSWPAG:%LX ", PCD_SFR_DSWPAG); 
....................   #endif 
....................  
....................   #if (getenv("SFR_VALID:TBLPAG")) 
....................    printf(TrapPutc, "TBLPAG:%LX ", g_TrapTBLPAG); 
*
01A7E:  MOV     #0,W1
01A80:  MOV     W1,W0
01A82:  CLR.B   1
01A84:  CALL    14DE
01A88:  INC     W1,W1
01A8A:  MOV     W1,[W15++]
01A8C:  PUSH    39D0
01A8E:  MOV.B   W0L,[W15-#2]
01A90:  POP     39D0
*
01A9C:  MOV     [--W15],W1
01A9E:  MOV     #6,W0
01AA0:  CPSGT   W1,W0
01AA2:  BRA     1A80
01AA4:  MOV     30CC,W0
01AA6:  MOV     #704,W1
01AA8:  CALL    18A8
01AAC:  MOV     39D0,W0
01AAE:  MOV.B   #20,W0L
01AB0:  MOV     W0,39D0
*
01CB2:  MOV     #0,W1
01CB4:  MOV     W1,W0
01CB6:  CLR.B   1
01CB8:  CALL    14DE
01CBC:  INC     W1,W1
01CBE:  MOV     W1,[W15++]
01CC0:  PUSH    39D0
01CC2:  MOV.B   W0L,[W15-#2]
01CC4:  POP     39D0
*
01CD0:  MOV     [--W15],W1
01CD2:  MOV     #6,W0
01CD4:  CPSGT   W1,W0
01CD6:  BRA     1CB4
01CD8:  MOV     30CC,W0
01CDA:  MOV     #704,W1
01CDC:  CALL    18A8
01CE0:  MOV     39D0,W0
01CE2:  MOV.B   #20,W0L
01CE4:  MOV     W0,39D0
*
01EE6:  MOV     #0,W1
01EE8:  MOV     W1,W0
01EEA:  CLR.B   1
01EEC:  CALL    14DE
01EF0:  INC     W1,W1
01EF2:  MOV     W1,[W15++]
01EF4:  PUSH    39D0
01EF6:  MOV.B   W0L,[W15-#2]
01EF8:  POP     39D0
*
01F04:  MOV     [--W15],W1
01F06:  MOV     #6,W0
01F08:  CPSGT   W1,W0
01F0A:  BRA     1EE8
01F0C:  MOV     30CC,W0
01F0E:  MOV     #704,W1
01F10:  CALL    18A8
01F14:  MOV     39D0,W0
01F16:  MOV.B   #20,W0L
01F18:  MOV     W0,39D0
*
0211A:  MOV     #0,W1
0211C:  MOV     W1,W0
0211E:  CLR.B   1
02120:  CALL    14DE
02124:  INC     W1,W1
02126:  MOV     W1,[W15++]
02128:  PUSH    39D0
0212A:  MOV.B   W0L,[W15-#2]
0212C:  POP     39D0
*
02138:  MOV     [--W15],W1
0213A:  MOV     #6,W0
0213C:  CPSGT   W1,W0
0213E:  BRA     211C
02140:  MOV     30CC,W0
02142:  MOV     #704,W1
02144:  CALL    18A8
02148:  MOV     39D0,W0
0214A:  MOV.B   #20,W0L
0214C:  MOV     W0,39D0
....................   #endif 
....................  
....................    printf(TrapPutc, "CORCON:%LX ", PCD_SFR_CORCON); 
*
01ABC:  MOV     #0,W1
01ABE:  MOV     W1,W0
01AC0:  CLR.B   1
01AC2:  CALL    14F6
01AC6:  INC     W1,W1
01AC8:  MOV     W1,[W15++]
01ACA:  PUSH    39D0
01ACC:  MOV.B   W0L,[W15-#2]
01ACE:  POP     39D0
*
01ADA:  MOV     [--W15],W1
01ADC:  MOV     #6,W0
01ADE:  CPSGT   W1,W0
01AE0:  BRA     1ABE
01AE2:  MOV     44,W0
01AE4:  MOV     #704,W1
01AE6:  CALL    18A8
01AEA:  MOV     39D0,W0
01AEC:  MOV.B   #20,W0L
01AEE:  MOV     W0,39D0
*
01CF0:  MOV     #0,W1
01CF2:  MOV     W1,W0
01CF4:  CLR.B   1
01CF6:  CALL    14F6
01CFA:  INC     W1,W1
01CFC:  MOV     W1,[W15++]
01CFE:  PUSH    39D0
01D00:  MOV.B   W0L,[W15-#2]
01D02:  POP     39D0
*
01D0E:  MOV     [--W15],W1
01D10:  MOV     #6,W0
01D12:  CPSGT   W1,W0
01D14:  BRA     1CF2
01D16:  MOV     44,W0
01D18:  MOV     #704,W1
01D1A:  CALL    18A8
01D1E:  MOV     39D0,W0
01D20:  MOV.B   #20,W0L
01D22:  MOV     W0,39D0
*
01F24:  MOV     #0,W1
01F26:  MOV     W1,W0
01F28:  CLR.B   1
01F2A:  CALL    14F6
01F2E:  INC     W1,W1
01F30:  MOV     W1,[W15++]
01F32:  PUSH    39D0
01F34:  MOV.B   W0L,[W15-#2]
01F36:  POP     39D0
*
01F42:  MOV     [--W15],W1
01F44:  MOV     #6,W0
01F46:  CPSGT   W1,W0
01F48:  BRA     1F26
01F4A:  MOV     44,W0
01F4C:  MOV     #704,W1
01F4E:  CALL    18A8
01F52:  MOV     39D0,W0
01F54:  MOV.B   #20,W0L
01F56:  MOV     W0,39D0
*
02158:  MOV     #0,W1
0215A:  MOV     W1,W0
0215C:  CLR.B   1
0215E:  CALL    14F6
02162:  INC     W1,W1
02164:  MOV     W1,[W15++]
02166:  PUSH    39D0
02168:  MOV.B   W0L,[W15-#2]
0216A:  POP     39D0
*
02176:  MOV     [--W15],W1
02178:  MOV     #6,W0
0217A:  CPSGT   W1,W0
0217C:  BRA     215A
0217E:  MOV     44,W0
02180:  MOV     #704,W1
02182:  CALL    18A8
02186:  MOV     39D0,W0
02188:  MOV.B   #20,W0L
0218A:  MOV     W0,39D0
....................    
....................    printf(TrapPutc, "\r\n"); 
*
01AFA:  MOV     39D0,W0
01AFC:  MOV.B   #D,W0L
01AFE:  MOV     W0,39D0
*
01B0A:  MOV     39D0,W0
01B0C:  MOV.B   #A,W0L
01B0E:  MOV     W0,39D0
*
01B1A:  NOP     
*
01D2E:  MOV     39D0,W0
01D30:  MOV.B   #D,W0L
01D32:  MOV     W0,39D0
*
01D3E:  MOV     39D0,W0
01D40:  MOV.B   #A,W0L
01D42:  MOV     W0,39D0
*
01D4E:  NOP     
*
01F62:  MOV     39D0,W0
01F64:  MOV.B   #D,W0L
01F66:  MOV     W0,39D0
*
01F72:  MOV     39D0,W0
01F74:  MOV.B   #A,W0L
01F76:  MOV     W0,39D0
*
01F82:  NOP     
*
02196:  MOV     39D0,W0
02198:  MOV.B   #D,W0L
0219A:  MOV     W0,39D0
*
021A6:  MOV     39D0,W0
021A8:  MOV.B   #A,W0L
021AA:  MOV     W0,39D0
*
021B6:  NOP     
.................... } 
....................  
.................... #inline 
.................... void TRAP_END(void) 
.................... { 
....................    while(1); 
*
01B1C:  GOTO    1B1C
*
01D50:  GOTO    1D50
*
01F84:  GOTO    1F84
*
021B8:  GOTO    21B8
.................... } 
....................  
.................... #if defined(INT_ADDRERR) 
.................... #INT_ADDRERR FAST 
.................... void handle_addrerr(void) 
*
018F2:  PUSH.S  
.................... { 
....................    TRAP_START(); 
....................    printf(TrapPutc, "ADDRESS FAULT"); 
*
01968:  MOV     #0,W1
0196A:  MOV     W1,W0
0196C:  CLR.B   1
0196E:  CALL    150E
01972:  INC     W1,W1
01974:  MOV     W1,[W15++]
01976:  PUSH    39D0
01978:  MOV.B   W0L,[W15-#2]
0197A:  POP     39D0
*
01986:  MOV     [--W15],W1
01988:  MOV     #C,W0
0198A:  CPSGT   W1,W0
0198C:  BRA     196A
....................    TRAP_DISPLAY(); 
....................    TRAP_END(); 
.................... } 
.................... #endif 
....................  
.................... #if defined(INT_MATHERR) 
*
01B20:  BCLR.B  80.3
01B22:  POP.S   
01B24:  RETFIE  
.................... #INT_MATHERR FAST 
.................... void handle_matherr(void) 
01B26:  PUSH.S  
.................... { 
....................    TRAP_START(); 
....................    printf(TrapPutc, "MATH FAULT"); 
*
01B9C:  MOV     #0,W1
01B9E:  MOV     W1,W0
01BA0:  CLR.B   1
01BA2:  CALL    1528
01BA6:  INC     W1,W1
01BA8:  MOV     W1,[W15++]
01BAA:  PUSH    39D0
01BAC:  MOV.B   W0L,[W15-#2]
01BAE:  POP     39D0
*
01BBA:  MOV     [--W15],W1
01BBC:  MOV     #9,W0
01BBE:  CPSGT   W1,W0
01BC0:  BRA     1B9E
....................    TRAP_DISPLAY(); 
....................    TRAP_END(); 
.................... } 
.................... #endif 
....................  
.................... #if defined(INT_STACKERR) 
*
01D54:  BCLR.B  80.4
01D56:  POP.S   
01D58:  RETFIE  
.................... #INT_STACKERR FAST 
.................... void handle_stackerr(void) 
01D5A:  PUSH.S  
.................... { 
....................    TRAP_START(); 
....................    printf(TrapPutc, "STACK FAULT"); 
*
01DD0:  MOV     #0,W1
01DD2:  MOV     W1,W0
01DD4:  CLR.B   1
01DD6:  CALL    1540
01DDA:  INC     W1,W1
01DDC:  MOV     W1,[W15++]
01DDE:  PUSH    39D0
01DE0:  MOV.B   W0L,[W15-#2]
01DE2:  POP     39D0
*
01DEE:  MOV     [--W15],W1
01DF0:  MOV     #A,W0
01DF2:  CPSGT   W1,W0
01DF4:  BRA     1DD2
....................    TRAP_DISPLAY(); 
....................    TRAP_END(); 
.................... } 
.................... #endif 
....................  
.................... #if defined(INT_OSCFAIL) 
*
01F88:  BCLR.B  80.2
01F8A:  POP.S   
01F8C:  RETFIE  
.................... #INT_OSCFAIL FAST 
.................... void handle_oscfail(void) 
01F8E:  PUSH.S  
.................... { 
....................    TRAP_START(); 
....................    printf(TrapPutc, "OSCILLATOR FAULT"); 
*
02004:  MOV     #0,W1
02006:  MOV     W1,W0
02008:  CLR.B   1
0200A:  CALL    1558
0200E:  INC     W1,W1
02010:  MOV     W1,[W15++]
02012:  PUSH    39D0
02014:  MOV.B   W0L,[W15-#2]
02016:  POP     39D0
*
02022:  MOV     [--W15],W1
02024:  MOV     #F,W0
02026:  CPSGT   W1,W0
02028:  BRA     2006
....................    TRAP_DISPLAY(); 
....................    TRAP_END(); 
.................... } 
.................... #endif 
....................  
.................... #endif   //__PCD_TRAPS_C__ 
....................  
.................... #endif   //defined(__PCD__) 
....................  
.................... #endif 
....................  
.................... #ifndef HW_INIT 
.................... #define HW_INIT() 
.................... #endif 
....................  
.................... //#if defined(__PCD__) 
.................... #if 0 
....................    #define DEBUG_SPI()  printf("\r\n0x260=%LX 0x262=%LX 0x264=%LX\r\n", (unsigned int16*)*0x260, (unsigned int16*)*0x262, (unsigned int16*)*0x264); 
.................... #else 
....................    #define DEBUG_SPI() 
.................... #endif 
....................  
.................... // disable application level debug macros if not defined 
.................... #ifndef DEBUG_STR 
....................  #define DEBUG_STR(str, x) 
....................  #define DEBUG_STR2(str1, str2) 
.................... #endif 
....................  
.................... // disable library level debug macros if not defined 
.................... #ifndef DEBUG_FS_STR 
....................  #define DEBUG_FS_STR(str, x) 
....................  #define DEBUG_FS_STR2(str1, str2) 
....................  #define DEBUG_FS_ARRAY(p, len) 
.................... #endif 
....................  
.................... #if defined(__USE_MDD_BOOTLOADER__) 
.................... #include "ex_mdd_boot.h" 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "filesystem\filesystem.c" 
.................... //see about.txt in filesystem/ for information 
....................  
.................... #ifndef __FILESYSTEM_C__ 
.................... #define __FILESYSTEM_C__ 
....................  
.................... #include "FSConfig.h" 
....................  
.................... #if defined(USE_SST25_INTERFACE) 
.................... #include "sst25vf_mdd.c" 
.................... #endif 
....................  
.................... #if defined(FS_DYNAMIC_MEM) 
....................  #if defined(__PCH__) 
....................   #include "salloc.c" 
....................  #else 
....................   #include <stdlibm.h> 
....................  #endif 
.................... #endif 
....................  
.................... #include "fsio.c" 
....................  
.................... #if defined(USE_SD_INTERFACE_WITH_SPI) 
.................... #include "sd-spi.c" 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... ////////////////////// 
.................... ///                /// 
.................... /// Useful Defines /// 
.................... ///                /// 
.................... ////////////////////// 
....................  
.................... #define COMMAND_SIZE 10 
*
021BC:  BCLR.B  80.1
021BE:  POP.S   
021C0:  RETFIE  
.................... #define NUM_COMMANDS 13 
....................  
.................... //////////////////////// 
.................... ///                  /// 
.................... /// Global Variables /// 
.................... ///                  /// 
.................... //////////////////////// 
....................  
....................    char scr[65]; 
....................  
.................... char commands[NUM_COMMANDS][COMMAND_SIZE]= 
.................... { 
....................    "del",      //option1=filename.  delete file. 
....................    "make",     //option1=filename.  create an empty file, give error if file already exists 
....................    "append",   //option1=filename, option2=string.  append string to end of file 
....................    "cd",    //option1=new cwd.  change working directory.  / is root. 
....................    "dir",    //show files in directory 
....................    "cat",    //option1=filename.  display full contents in ascii 
....................    "tail",  //option1=filename.  display the last 20 lines of file. 
....................    "mkdir", //option1=dir.  create directory.  see 'cd' for rules on dir 
....................    "rmdir",  //option1=dir.  remove directory.  see 'cd' for rules on dir. 
....................    "format",   // option1=media size in bytes. formats the media. 
....................    "help",   // help! 
....................    "mount",  //mount filesystem. 
....................    "info"    //get and display FS_DISK_PROPERTIES 
.................... }; 
....................  
.................... int1 g_IsMounted = FALSE; 
....................  
.................... //////////////////////////////// 
.................... ///                          /// 
.................... /// Function Implementations /// 
.................... ///                          /// 
.................... //////////////////////////////// 
....................  
.................... /* 
.................... Summary: Finds a command from the global list of commands. 
.................... Param: A pointer to the command string. 
.................... Returns: The command number if the command is found in the command list. 
....................          0xFF if the command isn't found 
.................... */ 
.................... int FindCommand(char *cmd) 
.................... { 
....................    char buf[COMMAND_SIZE]; 
....................    int i; 
....................  
....................    for (i=0; i<NUM_COMMANDS; i++) 
....................    { 
....................       strcpy(buf, &commands[i][0]); 
....................       if (stricmp(buf, cmd)==0) 
....................          return(i); 
....................    } 
....................  
....................    return(0xFF); 
.................... } 
....................  
.................... /* 
.................... Summary: Displays the current working directory. 
.................... Param: None. 
.................... Returns: None. 
.................... */ 
.................... void DisplayPrompt(void) 
.................... { 
....................    char scr[65], *p; 
....................  
....................    if (g_IsMounted) 
....................    { 
....................       p = FSgetcwd(scr, sizeof(scr)-1); 
....................       if (!p) 
....................       { 
....................          sprintf(scr, "!!!ERROR!!!"); 
....................       } 
....................    } 
....................    else 
....................    { 
....................       sprintf(scr, "!!!NOT MOUNTED!!!"); 
....................    } 
....................  
....................    printf("\r\n\n%s> ", scr); 
.................... } 
....................  
.................... /* 
.................... Summary: Deletes a file. 
.................... Param: The full path of the file to delete. 
.................... Returns: None. 
.................... */ 
.................... void DeleteFile(char *fileName) 
.................... { 
....................    if (!g_IsMounted) 
....................    { 
....................       printf("\r\nMedia not mounted, not going to delete file!"); 
....................       return; 
....................    } 
....................  
....................    //printf("\r\nDeleting '%s': ", fileName); 
....................    if(FSremove(fileName)) 
....................    { 
....................       printf("Error deleting file"); 
....................       return; 
....................    } 
....................    printf("OK"); 
.................... } 
....................  
.................... /* 
.................... Summary: Creates a file. 
.................... Param: The full path of the file to create. 
.................... Returns: None. 
.................... Example Usage: \> make "Log.txt" 
.................... */ 
.................... void MakeFile(char *fileName) 
.................... { 
....................    FSFILE *f = NULL; 
....................    int ret; 
....................  
....................    if (!g_IsMounted) 
....................    { 
....................       printf("\r\nMedia not mounted, not going to make file!"); 
....................       return; 
....................    } 
....................  
....................  //  printf("\r\nMaking file '%s': ", fileName); 
....................  
....................    f = FSfopen (fileName, "w"); 
....................    if (!f) 
....................    { 
....................       printf("Error (open error %X)", FSerrno); 
....................    } 
....................    else 
....................    { 
....................       ret = FSfclose(f); 
....................       if (ret) 
....................       { 
....................          printf("Error (close error %X %X)", ret, FSerrno); 
....................       } 
....................       else 
....................       { 
....................          printf("OK"); 
....................       } 
....................    } 
.................... } 
....................  
.................... /* 
.................... Summary: Append a string to a file. 
.................... Param: The full path of the file to append to. 
.................... Param: A pointer to a string to append to the file. 
.................... Returns: None. 
.................... Example Usage: \> append "Log.txt" "This will be appended to the end of Log.txt" 
.................... Note: A "\r\n" will be appended after the appendString. 
.................... */ 
.................... void AppendFile(char *fileName, char *appendString) 
.................... { 
....................    FSFILE* f; 
....................    char newLine[]="\r\n"; 
....................    int ret; 
....................  
....................    if (!g_IsMounted) 
....................    { 
....................       printf("\r\nMedia not mounted, not going to append file!"); 
....................       return; 
....................    } 
....................  
....................    printf("\r\nAppending '%s' to '%s': ", appendString, fileName); 
....................    f = FSfopen(fileName, "a"); 
....................    if(!f) 
....................    { 
....................       printf("Error (%X)", FSerrno); 
....................       return; 
....................    } 
....................  
....................    FSfwrite(appendString, sizeof(char), strlen(appendString), f); 
....................    FSfwrite(newLine, sizeof(char), strlen(newLine), f); 
....................  
....................    ret = FSfclose(f); 
....................    if(ret) 
....................    { 
....................       printf("Error (%X %X)", ret, FSerrno); 
....................       return; 
....................    } 
....................    printf("OK"); 
.................... } 
....................  
.................... /* 
.................... Summary: Change the working directory. 
.................... Param: The new working directory to switch to. 
.................... Returns: None. 
.................... Example Usage: \> cd ftp/     -> /ftp/ 
....................                \ftp\> cd files/  -> /ftp/files/ 
....................                \ftp\files> cd..  -> /ftp/ 
....................                \ftp\> cd ..      -> / 
....................                \> cd /ftp/files/ -> /ftp/files/ 
....................  
.................... Note: Changing the directory to .. will go up a directory. 
.................... */ 
.................... void ChangeDirectory(char *newCWD) 
.................... { 
....................    if (!g_IsMounted) 
....................    { 
....................       printf("\r\nMedia not mounted, not going to change directory!"); 
....................       return; 
....................    } 
....................  
....................    if (FSchdir(newCWD)) 
....................    { 
....................       printf("\r\nError changing directory"); 
....................    } 
.................... } 
....................  
.................... /* 
.................... Summary: Display the contents of the working directory. 
.................... Param: The full path of the directory contents to display. 
.................... Returns: None. 
.................... Example Usage: /> dir 
.................... */ 
.................... void DisplayDirectory(void) 
.................... { 
....................    SearchRec s; 
....................    int ret; 
....................    char str[20]; 
....................  
....................    if (!g_IsMounted) 
....................    { 
....................       printf("\r\nMedia not mounted, not going to display directory!"); 
....................       return; 
....................    } 
....................  
....................    memset(&s, 0x00, sizeof(s)); 
....................  
....................    ret = FindFirst("*.*", ATTR_MASK, &s); 
....................  
....................    for(;;) 
....................    { 
....................       if (ret != 0) 
....................       { 
....................          printf("\r\n\nDirectory search completed"); 
....................  
....................          if (FSerrno != CE_FILE_NOT_FOUND) 
....................          { 
....................             printf(" (FSerrno = %u)", FSerrno); 
....................          } 
....................          break; 
....................       } 
....................  
....................       if ((s.attributes & ATTR_VOLUME) != ATTR_VOLUME) 
....................       { 
....................          if ((s.attributes & ATTR_DIRECTORY) == ATTR_DIRECTORY) 
....................             sprintf(str, "<DIR>  "); 
....................          else 
....................             sprintf(str, "       "); 
....................  
....................          printf("\r\n%lu\t\t%s%s", s.filesize, str, s.filename); 
....................       } 
....................  
....................       ret = FindNext(&s); 
....................    } 
.................... } 
....................  
.................... /* 
.................... Summary: Create a directory. 
.................... Param: The full path of the directory to create. 
.................... Returns: None. 
.................... Example Usage: /> mkdir "Backlog" 
.................... */ 
.................... void MakeDirectory(char *dir) 
.................... { 
....................    if (!g_IsMounted) 
....................    { 
....................       printf("\r\nMedia not mounted, not going to make directory!"); 
....................       return; 
....................    } 
....................  
....................    printf("\r\nMaking directory '%s': ", dir); 
....................  
....................    if(FSmkdir(dir)) 
....................    { 
....................       printf("Error creating directory (FSerrno = %u)", FSerrno); 
....................       return; 
....................    } 
....................    printf("OK"); 
.................... } 
....................  
.................... /* 
.................... Summary: Remove a directory. 
.................... Param: The full path of the directory to remove. 
.................... Returns: None. 
.................... Example Usage: /> rmdir "Backlog" 
.................... Note: The directory needs to be empty in order for this command to work. 
.................... */ 
.................... void RemoveDirectory(char *dir) 
.................... { 
....................    if (!g_IsMounted) 
....................    { 
....................       printf("\r\nMedia not mounted, not going to remove directory!"); 
....................       return; 
....................    } 
....................  
....................    printf("\r\nRemoving directory '%s': ", dir); 
....................  
....................    if(FSrmdir(dir, FALSE)) 
....................    { 
....................       printf("Error removing directory"); 
....................       return; 
....................    } 
....................    printf("OK"); 
.................... } 
....................  
.................... #define CAT_FROM_START  FALSE 
.................... #define CAT_FROM_END    TRUE 
.................... /* 
.................... Summary: Prints either all of or the last 80 characters in a file. 
.................... Param: The full path of the file to print off. 
.................... Param: If true, this function will print off the last 80 characters in the file. 
....................        If false, this funciton will print off the entire file. 
.................... Returns: None. 
.................... Example Usage: /> cat "Logs.txt" (this will display the entire file) 
.................... Example Usage: /> tail "Logs.txt" (this will display the last 80 characters in the file) 
.................... */ 
.................... void PrintFile(char *fileName, int1 startFromEnd) 
.................... { 
....................  //  char scr[65]; 
....................    size_t len; 
....................    FSFILE* f; 
....................  
....................    if (!g_IsMounted) 
....................    { 
....................       printf("\r\nMedia not mounted, not going to display file!"); 
....................       return; 
....................    } 
....................  
....................    f = FSfopen(fileName, "r"); 
....................    if (!f) 
....................    { 
....................       printf("\r\nError opening file (Error %X)", FSerrno); 
....................       return; 
....................    } 
....................  
....................    printf("\r\n"); 
....................  
....................    if(startFromEnd) 
....................       FSfseek(f, 80, SEEK_END); 
....................  
....................    do 
....................    { 
....................       len = FSfread(scr, sizeof(char), (sizeof(scr)-1), f); 
....................       if (FSerrno && (FSerrno != CE_EOF)) 
....................       { 
....................          printf("\r\n!!! Error reading file (Error %X)", FSerrno); 
....................          len = 0; 
....................          break; 
....................       } 
....................       if (len) 
....................       { 
....................          scr[len] = 0; 
....................          //DEBUG_STR("PrintFile() got", len); 
....................          printf("%s", scr); 
....................       } 
....................    } while(FSerrno != CE_EOF); 
....................  
....................    FSfclose(f); 
.................... } 
....................  
.................... //***************************************************************************** 
.................... // Created Dacember 30, 2014 
.................... // Turn on power to card. 
.................... // This is done through Pin_RG9 
.................... //  This input into the function is as follows: 
.................... // Put power to the SD Card:  1 
.................... // Take away power to the SD Card: 0 
.................... //***************************************************************************** 
....................  
.................... void PowerSDCard(int8 state) 
.................... 	{ 
....................  
.................... 	if (state == 0) 
.................... 		{ 
.................... 		TRISGbits.TRISG9 = OUTPUT; 
.................... 		PORTGbits.RG9 =  0; 
.................... 		//output_low(PIN_SDPOWER); 
.................... 		}	 
.................... 	if (state == 1) 
.................... 		{ 
.................... 		TRISGbits.TRISG9 = OUTPUT; 
.................... 		PORTGbits.RG9 =  1; 
.................... 		} 
.................... 	} 
....................  
....................  
.................... void MountMedia(void) 
.................... { 
....................    g_IsMounted = FALSE; 
....................  
....................  
.................... PowerSDCard(0);  //Power up the card 
.................... 	 
....................  
....................    MDD_InitIO(); 
....................  
....................    if (!MDD_MediaDetect()) 
....................    { 
....................       printf("\r\nError, Media not found!"); 
....................       return; 
....................    } 
....................  
....................    if (FSInit()) 
....................    { 
....................       g_IsMounted = TRUE; 
....................  
....................       printf("\r\nOK (Sector Size=%LU, Sec Per Clus=%U, Type=%U)", 
....................             gDiskData.sectorSize, 
....................             gDiskData.SecPerClus, 
....................             gDiskData.type 
....................          ); 
....................    } 
....................    else 
....................    { 
....................       printf("\r\nError, file system not mounted (FSerrno=%U)!!!", FSerrno); 
....................    } 
.................... } 
....................  
.................... /* 
.................... Summary: Formats the media to a specified size. 
.................... Param: The size of the media, in kB, in string form. 
.................... Returns: None. 
.................... Example Usage: /> format 524288 (format a 512MB card) 
.................... */ 
.................... void FormatMedia(char *mediaSize) 
.................... { 
....................   #if !defined(ALLOW_FORMATS) 
....................    printf("\r\nError, formatting disabled!!!"); 
....................   #else 
....................    uint32_t size; 
....................    int scr; 
....................    int1 ok = FALSE; 
....................    char c; 
....................    MEDIA_INFORMATION *m; 
....................  
....................    #define MEDIA_SERIAL_NUMBER   "123" 
....................    #define MEDIA_VOLUME_ID       "123" 
....................  
....................    g_IsMounted = FALSE; 
....................  
....................    MDD_InitIO(); 
....................  
....................    if (!MDD_MediaDetect()) 
....................    { 
....................       printf("\r\nError, media not found!"); 
....................       return; 
....................    } 
....................  
....................    m = MDD_MediaInitialize(); 
....................    if (m->errorCode != MEDIA_NO_ERROR) 
....................    { 
....................       printf("\r\nMedia not initialized (ec = %X), media not formatted!", m->errorCode); 
....................       return; 
....................    } 
....................  
....................    size = atoi32(mediaSize); 
....................    scr = strlen(mediaSize); 
....................    if (scr) 
....................    { 
....................       c = toupper(mediaSize[scr-1]); 
....................       if (c == 'K') 
....................          size *= (uint32_t)1024; 
....................       else if (c == 'M') 
....................          size *= (uint32_t)1024*1024; 
....................       else if (c == 'G') 
....................          size *= (uint32_t)1024*1024*1024; 
....................    } 
....................  
....................    printf("\r\nFormatting media (size=%LU, sector size=%LU): ", size, MEDIA_SECTOR_SIZE); 
....................  
....................    if (!FSCreateMBR(1, size/MEDIA_SECTOR_SIZE)) 
....................    { 
....................       if (!FSformat (1, MEDIA_SERIAL_NUMBER, MEDIA_VOLUME_ID)) 
....................       { 
....................          ok = TRUE; 
....................       } 
....................    } 
....................  
....................    if(!ok) 
....................    { 
....................       printf("Error formatting media"); 
....................       return; 
....................    } 
....................  
....................    MountMedia(); 
....................   #endif 
.................... } 
....................  
.................... void MediaInfo(void) 
.................... { 
....................    FS_DISK_PROPERTIES p; 
....................  
....................  
....................  
....................    if (g_IsMounted) 
....................    { 
....................       printf("\r\nGetting media info (this may take seconds to minutes)..."); 
....................       p.new_request = TRUE; 
....................  
....................       do 
....................       { 
....................          FSGetDiskProperties(&p); 
....................       } while(p.properties_status == FS_GET_PROPERTIES_STILL_WORKING); 
....................  
....................       if (p.properties_status == FS_GET_PROPERTIES_DISK_NOT_MOUNTED) 
....................       { 
....................          printf("\r\n\nFile system thinks media isn't mounted, try mounting again!"); 
....................       } 
....................       else if (p.properties_status != FS_GET_PROPERTIES_NO_ERRORS) 
....................       { 
....................          printf("\r\n\nError getting info"); 
....................       } 
....................       else 
....................       { 
....................          printf("\r\n\nBytes per sector: %LU", p.results.sector_size); 
....................          printf("\r\nSectors per cluster: %U", p.results.sectors_per_cluster); 
....................          printf("\r\nTotal size of media: %LU", p.results.total_clusters*p.results.sectors_per_cluster*p.results.sector_size); 
....................          printf("\r\nFree space of media: %LU", p.results.free_clusters*p.results.sectors_per_cluster*p.results.sector_size); 
....................       } 
....................    } 
....................    else 
....................    { 
....................       printf("\r\nMedia not mounted, not getting info!"); 
....................    } 
.................... } 
....................  
.................... /* 
.................... Summary: Shows a help prompt. 
.................... Param: None. 
.................... Returns: None. 
.................... Example Usage: /> help 
.................... */ 
.................... void ShowHelp() 
.................... { 
....................    printf("\r\nFAT Shell Help - Compiled with CCS C Compiler "); 
....................   #if defined(__PCD__) 
....................    printf("PCD "); 
....................    printf(__PCD__); 
....................   #else 
....................    printf("PCH "); 
....................    printf(__PCH__); 
....................   #endif 
....................    printf("\r\n mount --- initialize and mount file system.  required before file access"); 
....................    printf("\r\n del filename --- Deletes the file"); 
....................    printf("\r\n make filename --- Creates an empty file"); 
....................    printf("\r\n append filename string --- Appends string to the end of the file"); 
....................    printf("\r\n cd dir --- Change the working directory"); 
....................    printf("\r\n dir --- Shows the contents of the directory"); 
....................    printf("\r\n cat filename --- Displays content of file"); 
....................    printf("\r\n tail filename --- Displays the last 80 characters of file"); 
....................    printf("\r\n mkdir dir --- Create a directory"); 
....................    printf("\r\n rmdir dir --- Deletes the directory"); 
....................    printf("\r\n format size --- Format card.  (Example: 'format 536870912' -or- 'format 512M' "); 
....................    printf("\r\n                 formats a 512MB card).  Creates MBR and Partition 0.  This is "); 
....................    printf("\r\n                 not recommended on devices which you can use a computer to"); 
....................    printf("\r\n                 format the drive (such as an SD or CF device)."); 
....................    printf("\r\n info --- Show some info about the media/file system.  Can take several seconds!"); 
....................    printf("\r\n help\tYou are here"); 
....................    printf("\r\n\n Put a parameter in quotes if it has spaces"); 
....................  
....................    DEBUG_STR("SPICON1", SPICON1); 
....................    DEBUG_STR("SPISTAT", SPISTAT); 
.................... } 
....................  
.................... char * GetCMD(char *in) 
.................... { 
....................    char tokens[]=" \r\n"; 
....................    return(strtok(in,tokens)); 
.................... } 
....................  
.................... char * GetOption(char *in) 
.................... { 
....................    char tokensSpace[]=" \r\n"; 
....................    char tokensQuote[]="\"\r\n"; 
....................  
....................    //trim leading spaces 
....................    while (*in==' ') 
....................       in++; 
....................  
....................    //if first char is a quote, then end token on a quote.  ELSE end token on a space 
....................    if (*in == '\"') 
....................       return(strtok(in,tokensQuote)); 
....................    else 
....................       return(strtok(in,tokensSpace)); 
.................... } 
....................  
....................  
.................... //**************************************************************************** 
.................... // Created January 27, 2015 
.................... // This routine warms up the SCCard and Mounts the drive for it to be used. 
.................... //  This needs to be run at the beginning when bringing up the chip 
.................... // It returns a 1 if the SDCArd is working. 
.................... //  It returns a 0 if the SDCard is not working or not installed. 
.................... //*************************************************************************** 
.................... int initUpSDCard(void) 
.................... 	{ 
.................... MountMedia(); 
....................  
....................             if (!g_IsMounted) 
....................             { 
.................... 				return(0);  //This means the SDCard is not working or installed. 
....................                //sprintf(buffer, "mount"); 
....................             } 
....................             else 
....................             { 
.................... 				return(1);  // This means the SCCard is installed and working. 
....................                sprintf(buffer, "append log.txt button pressed!!"); 
....................             } 
.................... 	} 
....................  
....................  
....................  
.................... //************************************************************************* 
.................... //Created January 27, 2015 
.................... // This routine splits all of the data from a string into integers with a delimmeiter of a "," 
.................... // Numbers in this splitter are changed to integersa and numbers. 
.................... //************************************************************************* 
....................  
....................  
....................  
....................  
....................  
.................... //************************************************************************* 
.................... //Created January 27, 2015 
.................... // This routine reads the SDCard Calib.txt and sets all of the instrumentation calibration values. 
.................... //  This routine is run at the beginiing when Osmobot is setting up. 
.................... //************************************************************************ 
....................  
.................... void ReadOsmobotCalibration(char *fileName) 
.................... 	{ 
....................  
.................... 	PrintFile(fileName, 0); 
.................... 	Display_XYString(0, 1, &scr); 
....................  
....................  
.................... 	} 
....................  
....................  
....................  
.................... /* 
.................... void main(void) 
.................... { 
....................    char buffer[255]; 
....................    char *cmd, *option1, *option2; 
....................  
....................    int i;   // pointer to the buffer 
....................  
....................  
....................  
....................  
....................  
....................  //  HW_INIT(); 
....................  
....................  
....................    //printf("\r\n\nex_fat.c - MDD Example"); 
.................... MountMedia(); 
....................  
....................             if (!g_IsMounted) 
....................             { 
....................                sprintf(buffer, "mount"); 
....................             } 
....................             else 
....................             { 
....................                sprintf(buffer, "append log.txt button pressed!!"); 
....................             } 
....................  
....................  
....................    // main loop 
....................  
....................  
.................... //option1 = GetOption(cmd + strlen(cmd) + 1); 
.................... //MakeFile("testfile.txt"); 
....................  
.................... AppendFile("testfile.txt", "Hello World"); 
....................  
....................  
....................  
....................  
.................... */ 
....................  
....................  
....................  
.................... #use fast_io(c) 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... //#define MMCSD_PIN_SCL     PIN_F3 //o 
.................... //#define MMCSD_PIN_SDI     PIN_F6 //i 
.................... //#define MMCSD_PIN_SDO     PIN_F2 //o 
.................... //#define MMCSD_PIN_SELECT  PIN_B9 //o 
.................... #define MMCSD_PIN_POWER   PIN_G9 //o 
.................... //#include "mmcsd.c" 
.................... //#include "fat.c" 
....................  
....................  
....................  
.................... char HTTPwString[1000]; 
.................... //char HTTPrString[BUFFERSIZE]; 
.................... char HTTPoutput[BUFFERSIZE-100]; 
.................... //unsigned int8 newChksum=0; 
....................  
.................... //int uio; 
....................  
....................  
....................  
....................  
....................  
....................  
.................... //////////////////////////////////////// 
.................... //Data Structure Initialization 
.................... //////////////////////////////////////// 
....................  
.................... ///////////////////////////////////////// 
.................... //End Data Structures 
.................... ///////////////////////////////////////// 
....................  
....................  
....................  
.................... ////////////////////////////////////////// 
.................... //Osmobot Hardware Initialization 
.................... ////////////////////////////////////////// 
.................... void osmoInit(){ 
....................  
....................  
....................  
....................  
.................... ///////////////////////////////// 
.................... //NOTES: 
.................... //ON R1 of osmobot board DO LED is not hooked up to a PWM capable (RP) pin 
.................... //it is instead on an RPI pin and cannot use the PWM module 
.................... ///////////////////////////////// 
....................  
....................  
.................... //pwm_set_duty(PH_PWM,9900);	//250hz 
.................... } 
.................... ////////////////////////////////////////// 
.................... //End osmobot hardware initialization 
.................... ////////////////////////////////////////// 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////// 
.................... //SSR ROUTINE 
.................... ////////////////////////////////// 
....................  
.................... void writeSSR() 
.................... { 
.................... #if USESENSORS  
.................... //////CHANGE THESE PINS TO SSR PINS 
.................... //output_bit(PIN_F5,sysInput.io1); 
.................... //output_bit(PIN_F6,sysInput.io2); 
.................... //output_bit(PIN_F7,sysInput.io3); 
.................... #endif 
*
0445E:  RETURN  
.................... } 
....................  
....................  
.................... /////////////////////////////////////////// 
.................... //END SSR 
.................... /////////////////////////////////////////// 
....................  
....................  
....................  
.................... /////////////////////////////////// 
.................... //SENSOR READ 
.................... //Created Nov. 3, 2014 
.................... // This routine reads all of the sensors at one time at this moment 
.................... // It needs to be split where it's time sliced to all RS232 interfacing 
.................... // A global variable needs to be set to indicate which sensor needs to be updated. 
.................... //  For now all of them are tested and send as local data. 
.................... /////////////////////////////////// 
.................... int16 gainof;  
....................  
.................... unsigned int8 sensorRead() 
.................... { 
....................  
.................... #if USESENSORS 
*
071B4:  MOV     W5,[W15++]
071B6:  MOV     W6,[W15++]
.................... //char uffit[40]; 
.................... // ********************************************************************************** 
.................... // Created Nov 3, 2014 
.................... //  Find the water depth and set it to the download variable 
.................... // This routine check the ADC and scales the pressure sensor 
.................... // ********************************************************************************** 
.................... sysOutput.wLevel = MeasureWaterDepth();   //This returns the water depth in CM. 
071B8:  CALL    4662
071BC:  MOV     W0,1924
071BE:  MOV     W1,1926
....................  
.................... // ********************************************************************************* 
.................... // Created Nov. 3, 2014 
.................... // Find the current water temperature and send the to the download variable 
.................... // This routine takes the thermister reading to the ADC and scales it to degrees C. 
.................... // ********************************************************************************* 
.................... sysOutput.wTemp = ConvertADCToKalvin(5); 
071C0:  MOV     #5,W4
071C2:  MOV     W4,3802
071C4:  CALL    4F68
071C8:  MOV     W0,191C
071CA:  MOV     W1,191E
....................  
....................  
.................... // ********************************************************************************* 
.................... // Created No2. 3, 2014 
.................... // Find the RH and Temperature for the environment and send it to the server. 
.................... //  This routine talks with the cheap RH and Temperature sensor 
.................... // ******************************************************************************** 
....................  
.................... if (!GetTempRH()) 
071CC:  CALL    515A
071D0:  CP0     W0
071D2:  BRA     NZ,71E6
071D4:  BRA     71D6
.................... 	{ 
.................... 	sysOutput.aTemp = Temperature;  //This is the float temperature 
071D6:  PUSH    30C8
071D8:  POP     1948
071DA:  PUSH    30CA
071DC:  POP     194A
.................... 	sysOutput.rH = RHData;  //This is a float send into ta RH value. 
071DE:  PUSH    30C4
071E0:  POP     1940
071E2:  PUSH    30C6
071E4:  POP     1942
.................... 	} 
....................  
.................... // ******************************************************************************** 
.................... // Created Nov. 3, 2014 
.................... // This routines borrows the calcaulaton from the expensive SHt11 chip to calcaulate DP 
.................... // ******************************************************************************** 
....................  
.................... sysOutput.dPoint=sht1x_calc_dewpoint(RHData,Temperature); 
071E6:  PUSH    30C4
071E8:  POP     3802
071EA:  PUSH    30C6
071EC:  POP     3804
071EE:  PUSH    30C8
071F0:  POP     3806
071F2:  PUSH    30CA
071F4:  POP     3808
071F6:  CALL    547E
071FA:  MOV     W0,1952
071FC:  MOV     W1,1954
....................  
....................  
.................... // ******************************************************************************** 
.................... // Created Nov. 3, 2014 
.................... // This routines find the current ambnt light spectrum and uploads it to the server. 
.................... // ******************************************************************************** 
.................... gainof = GetCurrentColor(4, 3); 
071FE:  MOV     3892,W0
07200:  MOV.B   #4,W0L
07202:  MOV     W0,3892
07204:  MOV     3892,W0
07206:  SWAP    W0
07208:  MOV.B   #3,W0L
0720A:  SWAP    W0
0720C:  MOV     W0,3892
0720E:  CALL    6030
07212:  SE      W0,W0
07214:  MOV     W0,3796
.................... sysOutput.lLevelRed=red; 
07216:  PUSH    2F70
07218:  POP     1930
.................... sysOutput.lLevelGreen=green; 
0721A:  PUSH    2F72
0721C:  POP     1932
.................... sysOutput.lLevelBlue=blue; 
0721E:  PUSH    2F74
07220:  POP     1934
.................... sysOutput.lLevelClear=clear; 
07222:  PUSH    2F76
07224:  POP     1936
.................... sysOutput.lLevelScale=gainof; 
07226:  MOV     3796,W0
07228:  CALL    44E6
0722C:  MOV     W0,193C
0722E:  MOV     W1,193E
....................  
....................  
.................... //sysOutput.dOxy = FindMiddlePWMSensor(1, 1);   //Leave this in for calibration  Created May 21, 2014 
....................  
.................... //FindAmbientLight(1); 
.................... //sysOutput.dOxy = TakeLightReading(1, PWMDOIntensity, 20000);   // This routine takes a reading of DO which channel 1 and knows it's DO.  Channel 2 is pH. 
....................  
.................... //				sprintf(uffit,"RED %Lu DO %f  ", red, sysOutput.dOxy); 
.................... //				Display_XYString(0, 2, &uffit); 
.................... //FindAmbientLight(2); 
....................  
....................  
.................... //******************************************************************************* 
.................... //Created March 1, 2015 
.................... // This routine averages 10 pH readings together before releasing it to the server.. 
.................... //******************************************************************************* 
.................... averagepH = 0.0; 
07230:  CLR     197E
07232:  CLR     1980
.................... for (yy=0; yy < 10; yy++) 
07234:  CLR     197C
07236:  MOV     197C,W4
07238:  CP      W4,#A
0723A:  BRA     GE,726C
0723C:  BRA     723E
.................... 	{ 
.................... 		 
.................... 		xp = SetPWMWithPhotoTransistor(xp, 200); 
0723E:  PUSH    197A
07240:  POP     3802
07242:  MOV     #C8,W4
07244:  MOV     W4,3804
07246:  CALL    6DE0
0724A:  MOV     W0,197A
.................... //		sprintf(uffit,"ADC %Lu  %Lu %f ",  GetADCValue(2), xp, ConvertTopH()); 
.................... //		Display_XYString(0, 2, &uffit); 
.................... 		averagepH = ConvertTopH() + averagepH; 
0724C:  CALL    7018
07250:  MOV     W0,W5
07252:  MOV     W1,W6
07254:  BCLR.B  43.0
07256:  MOV     W5,W0
07258:  MOV     W6,W1
0725A:  MOV     197E,W2
0725C:  MOV     1980,W3
0725E:  CALL    478A
07262:  MOV     W0,197E
07264:  MOV     W1,1980
07266:  INC     197C
07268:  GOTO    7236
.................... 	} 
....................  
.................... sysOutput.pH = averagepH/10.0; 
0726C:  MOV     197E,W0
0726E:  MOV     1980,W1
07270:  MOV     #0,W2
07272:  MOV     #4120,W3
07274:  CALL    4530
07278:  MOV     W0,1920
0727A:  MOV     W1,1922
....................  
.................... delay_ms(1000); 
0727C:  MOV     #3E8,W0
0727E:  CALL    21F2
.................... #endif 
.................... return (1); 
07282:  MOV.B   #1,W0L
07284:  MOV.B   W0L,0
07286:  MOV     [--W15],W6
07288:  MOV     [--W15],W5
0728A:  RETURN  
.................... } 
....................  
.................... //////////////////////////////////////////// 
.................... //End Sensor Read 
.................... //////////////////////////////////////////// 
....................  
.................... void dataInit(void){ 
....................  
.................... sysOutput.deviceID="Eriks_Board:WTS"; 
*
02810:  MOV     #0,W2
02812:  MOV     #18FE,W1
02814:  MOV     W2,W0
02816:  CALL    1576
0281A:  MOV.B   W0L,[W1++]
0281C:  INC     W2,W2
0281E:  CP0.B   W0L
02820:  BTSS.B  42.1
02822:  BRA     2814
....................  
.................... sysOutput.dOxy=.20; 
02824:  MOV     #CCCD,W4
02826:  MOV     W4,1918
02828:  MOV     #3E4C,W4
0282A:  MOV     W4,191A
.................... //sysOutput.time=0; 
.................... sysOutput.nH4=200; 
0282C:  CLR     194E
0282E:  MOV     #4348,W4
02830:  MOV     W4,1950
.................... sysOutput.rH=9001; 
02832:  MOV     #A400,W4
02834:  MOV     W4,1940
02836:  MOV     #460C,W4
02838:  MOV     W4,1942
.................... sysOutput.lLevelX=20; 
0283A:  CLR     1928
0283C:  MOV     #41A0,W4
0283E:  MOV     W4,192A
02840:  RETURN  
.................... //sysInput.uploadinterval=UPDATEINTERVALHARDWIRED; 
.................... //R_Minutes=sysInput.uploadinterval; 
.................... } 
....................  
....................  
....................  
.................... void printTime( unsigned int16 Year, unsigned int8 Month, unsigned int8 Day, unsigned int8 Hour, unsigned int8 Minute, unsigned int8 Second) 
.................... { 
.................... //sprintf(timeString,"%4lu-%2u-%2u$%2u:%2u:%2u",Year,Month,Day,Hour,Minute,Second); 
.................... sprintf(timeString,"%02u:%02u:%02u$%04lu-%02u-%02u",Hour,Minute,Second,Year,Month,Day,); 
*
072A6:  MOV     #195E,W4
072A8:  MOV     W4,214A
072AA:  MOV     3806,W0
072AC:  CLR.B   1
072AE:  MOV     #8002,W4
072B0:  CALL    6D14
072B4:  MOV.B   #3A,W0L
072B6:  CALL    35EA
072BA:  PUSH    3806
072BC:  MOV     [--W15],W0
072BE:  LSR     W0,#8,W0
072C0:  CLR.B   1
072C2:  MOV     #8002,W4
072C4:  CALL    6D14
072C8:  MOV.B   #3A,W0L
072CA:  CALL    35EA
072CE:  MOV     3808,W0
072D0:  CLR.B   1
072D2:  MOV     #8002,W4
072D4:  CALL    6D14
072D8:  MOV.B   #24,W0L
072DA:  CALL    35EA
072DE:  MOV     3802,W0
072E0:  MOV     #8004,W4
072E2:  CALL    6D14
072E6:  MOV.B   #2D,W0L
072E8:  CALL    35EA
072EC:  MOV     3804,W0
072EE:  CLR.B   1
072F0:  MOV     #8002,W4
072F2:  CALL    6D14
072F6:  MOV.B   #2D,W0L
072F8:  CALL    35EA
072FC:  PUSH    3804
072FE:  MOV     [--W15],W0
07300:  LSR     W0,#8,W0
07302:  CLR.B   1
07304:  MOV     #8002,W4
07306:  CALL    6D14
0730A:  RETURN  
.................... } 
....................  
....................  
....................  
....................  
.................... void reloadTime(void){ 
.................... sysOutput.year=sysInput.year; 
*
0728C:  PUSH    1988
0728E:  POP     1914
.................... sysOutput.month=sysInput.month; 
07290:  MOV.B   1987,W0L
07292:  MOV.B   W0L,1912
.................... sysOutput.day=sysInput.day; 
07294:  MOV.B   1986,W0L
07296:  MOV.B   W0L,1911
.................... sysOutput.hour=sysInput.hour; 
07298:  MOV.B   1983,W0L
0729A:  MOV.B   W0L,190E
.................... sysOutput.minute=sysInput.minute; 
0729C:  MOV.B   1984,W0L
0729E:  MOV.B   W0L,190F
.................... sysOutput.second=sysInput.second; 
072A0:  MOV.B   1985,W0L
072A2:  MOV.B   W0L,1910
072A4:  RETURN  
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... // ***************************************************************** 
.................... // Added Nov 12, 2014 
.................... //  This find the string length 
.................... // ***************************************************************** 
....................  
....................  
.................... int16 strlenn(char stri[]) 
*
07694:  MOV     W5,[W15++]
07696:  MOV     #0,W4
07698:  MOV     W4,3804
.................... 	{ 
.................... 	int16 i=0; 
.................... //	char stri[50]; 
.................... 	while(stri[i]!='\0') 
0769A:  MOV     3804,W0
0769C:  MOV     3802,W4
0769E:  ADD     W0,W4,W0
076A0:  CP0.B   [W0]
076A2:  BRA     Z,76B0
076A4:  BRA     76A6
.................... 		{ 
.................... 		i++; 
076A6:  MOV     3804,W0
076A8:  INC     W0,W0
076AA:  MOV     W0,3804
076AC:  GOTO    769A
.................... 		} 
.................... 		return i; 
076B0:  PUSH    3804
076B2:  POP     0
076B4:  MOV     [--W15],W5
076B6:  RETURN  
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... void main(){ 
*
077BE:  MOV     #4780,W15
077C0:  MOV     #47FF,W0
077C2:  MOV     W0,20
077C4:  NOP     
077C6:  MOV     #4444,W0
077C8:  MOV     W0,A8
077CA:  BSET.B  81.7
077CC:  MOV     #46,W0
077CE:  MOV.B   W0L,742
077D0:  MOV     #57,W0
077D2:  MOV.B   W0L,742
077D4:  BCLR.B  742.6
077D6:  MOV     #E3F,W0
077D8:  MOV     W0,6A2
077DA:  MOV     #3F00,W0
077DC:  MOV     W0,6A4
077DE:  MOV     #3F2D,W0
077E0:  MOV     W0,6A8
077E2:  MOV     #300,W0
077E4:  MOV     W0,6C0
077E6:  MOV     #8,W0
077E8:  MOV     W0,6D0
077EA:  MOV     #1300,W0
077EC:  MOV     W0,6D6
077EE:  MOV     #12,W0
077F0:  MOV     W0,6D8
077F2:  MOV     #1C00,W0
077F4:  MOV     W0,6DC
077F6:  MOV     #7,W0
077F8:  MOV     W0,6DE
077FA:  MOV     #46,W0
077FC:  MOV.B   W0L,742
077FE:  MOV     #57,W0
07800:  MOV.B   W0L,742
07802:  BSET.B  742.6
07804:  BSET.B  44.2
07806:  MOV     #4,W0
07808:  MOV     W0,34
0780A:  MOV     #85A,W0
0780C:  MOV     #1FD1,W1
0780E:  REPEAT  W1
07810:  CLR     [W0++]
07812:  CLR     744
07814:  CLR     85A
07816:  BCLR.B  85C.0
07818:  BCLR.B  85C.1
0781A:  BCLR.B  85C.2
0781C:  BCLR.B  85C.3
0781E:  BCLR.B  85C.4
07820:  BCLR.B  85C.5
07822:  BSET.B  85C.6
07824:  BCLR.B  85C.7
07826:  BCLR.B  85D.0
07828:  BCLR.B  85D.1
0782A:  BCLR.B  85D.2
0782C:  BCLR.B  85D.3
0782E:  MOV     #8000,W4
07830:  MOV     W4,220
07832:  MOV     #400,W4
07834:  MOV     W4,222
07836:  BSET.B  220.3
07838:  MOV     #1A0,W4
0783A:  MOV     W4,228
0783C:  CLR     1A8C
0783E:  CLR     1A8E
07840:  MOV     #8000,W4
07842:  MOV     W4,250
07844:  MOV     #400,W4
07846:  MOV     W4,252
07848:  BSET.B  250.3
0784A:  MOV     #44,W4
0784C:  MOV     W4,258
0784E:  MOV     #0,W4
07850:  MOV     W4,2146
07852:  MOV     #0,W4
07854:  MOV     W4,2148
07856:  MOV     #0,W4
07858:  MOV     W4,214A
0785A:  CLR.B   95D
0785C:  BCLR.B  85D.4
0785E:  MOV     #0,W4
07860:  MOV     W4,214C
07862:  CLR.B   1A8B
07864:  BCLR.B  85D.5
07866:  MOV     #0,W4
07868:  MOV     W4,214E
0786A:  MOV     #0,W4
0786C:  MOV     W4,2150
0786E:  MOV     #0,W4
07870:  MOV     W4,2152
07872:  MOV     #0,W4
07874:  MOV     W4,292E
07876:  MOV     #0,W4
07878:  MOV     W4,2930
0787A:  MOV     #FFFF,W4
0787C:  MOV     W4,2932
0787E:  MOV     #0,W4
07880:  MOV     W4,295E
07882:  MOV     2960,W0
07884:  MOV.B   #0,W0L
07886:  MOV     W0,2960
07888:  MOV     #0,W4
0788A:  MOV     W4,2962
0788C:  MOV     #0,W4
0788E:  MOV     W4,2964
07890:  MOV     #0,W4
07892:  MOV     W4,2966
07894:  BCLR.B  85D.6
07896:  MOV     2960,W0
07898:  CLR.B   1
0789A:  MOV     W0,2960
0789C:  MOV     2968,W0
0789E:  MOV.B   #0,W0L
078A0:  MOV     W0,2968
078A2:  MOV     2968,W0
078A4:  CLR.B   1
078A6:  MOV     W0,2968
078A8:  MOV     296A,W0
078AA:  MOV.B   #0,W0L
078AC:  MOV     W0,296A
078AE:  MOV     296A,W0
078B0:  CLR.B   1
078B2:  MOV     W0,296A
078B4:  BCLR.B  85D.7
078B6:  MOV     296C,W0
078B8:  BCLR.B  0.0
078BA:  MOV     W0,296C
078BC:  CLR     110
078BE:  MOV     #7CF,W4
078C0:  MOV     W4,10C
078C2:  MOV     #8000,W4
078C4:  MOV     W4,110
078C6:  MOV     #6,W4
078C8:  MOV     W4,190
078CA:  MOV     #C,W4
078CC:  MOV     W4,192
078CE:  MOV     #3E7,W4
078D0:  MOV     W4,196
078D2:  MOV     #6,W4
078D4:  MOV     W4,19A
078D6:  MOV     #C,W4
078D8:  MOV     W4,19C
078DA:  MOV     #3E7,W4
078DC:  MOV     W4,1A0
078DE:  BCLR.B  2EC.4
078E0:  BSET.B  217.7
078E2:  BSET.B  217.5
078E4:  BSET.B  216.6
078E6:  BCLR.B  217.3
078E8:  BSET.B  216.7
078EA:  BCLR.B  217.0
078EC:  BSET.B  217.1
078EE:  BCLR.B  217.2
078F0:  CLR     21A
078F2:  MOV     #9D,W4
078F4:  MOV     W4,214
078F6:  BCLR.B  2E4.7
078F8:  BSET.B  277.7
078FA:  BSET.B  277.5
078FC:  BSET.B  276.6
078FE:  BCLR.B  277.3
07900:  BSET.B  276.7
07902:  BCLR.B  277.0
07904:  BSET.B  277.1
07906:  BCLR.B  277.2
07908:  CLR     27A
0790A:  MOV     #9D,W4
0790C:  MOV     W4,274
0790E:  BCLR.B  2F4.3
07910:  BSET.B  207.7
07912:  BSET.B  207.5
07914:  BSET.B  206.6
07916:  BCLR.B  207.3
07918:  BSET.B  206.7
0791A:  BCLR.B  207.0
0791C:  BSET.B  207.1
0791E:  BCLR.B  207.2
07920:  CLR     20A
07922:  MOV     #9D,W4
07924:  MOV     W4,204
07926:  MOV     296C,W0
07928:  BCLR.B  0.2
0792A:  MOV     W0,296C
0792C:  MOV     #8000,W4
0792E:  MOV     W4,220
07930:  MOV     #400,W4
07932:  MOV     W4,222
07934:  BSET.B  220.3
07936:  MOV     #1A0,W4
07938:  MOV     W4,228
0793A:  MOV     #FFFF,W4
0793C:  MOV     W4,29B0
0793E:  MOV     #FFFF,W4
07940:  MOV     W4,29B2
07942:  MOV     29A4,W0
07944:  CLR.B   1
07946:  MOV     W0,29A4
07948:  MOV     #0,W4
0794A:  MOV     W4,29B4
0794C:  MOV     #FFFF,W4
0794E:  MOV     W4,29B6
07950:  MOV     #FFFF,W4
07952:  MOV     W4,29B8
07954:  MOV     29BA,W0
07956:  MOV.B   #0,W0L
07958:  MOV     W0,29BA
0795A:  MOV     29BA,W0
0795C:  CLR.B   1
0795E:  MOV     W0,29BA
07960:  MOV     29BC,W0
07962:  MOV.B   #0,W0L
07964:  MOV     W0,29BC
07966:  MOV     29C6,W0
07968:  CLR.B   1
0796A:  MOV     W0,29C6
0796C:  MOV     #2A34,W4
0796E:  MOV     W4,2A6A
07970:  MOV     #1E,W4
07972:  MOV     W4,2F52
07974:  MOV     #5,W4
07976:  MOV     W4,2F54
07978:  MOV     #3,W4
0797A:  MOV     W4,2F56
0797C:  MOV     #0,W4
0797E:  MOV     W4,2F58
07980:  MOV     #C080,W4
07982:  MOV     W4,2F5A
07984:  MOV     #D70A,W4
07986:  MOV     W4,2F5C
07988:  MOV     #3C23,W4
0798A:  MOV     W4,2F5E
0798C:  MOV     #E354,W4
0798E:  MOV     W4,2F60
07990:  MOV     #3D25,W4
07992:  MOV     W4,2F62
07994:  MOV     #C5AC,W4
07996:  MOV     W4,2F64
07998:  MOV     #38A7,W4
0799A:  MOV     W4,2F66
0799C:  MOV     #E7A2,W4
0799E:  MOV     W4,2F68
079A0:  MOV     #B63B,W4
079A2:  MOV     W4,2F6A
079A4:  MOV     2F78,W0
079A6:  MOV.B   #0,W0L
079A8:  MOV     W0,2F78
079AA:  MOV     2F78,W0
079AC:  SWAP    W0
079AE:  MOV.B   #3,W0L
079B0:  SWAP    W0
079B2:  MOV     W0,2F78
079B4:  MOV     2F7A,W0
079B6:  MOV.B   #2,W0L
079B8:  MOV     W0,2F7A
079BA:  MOV     #0,W4
079BC:  MOV     W4,30B4
079BE:  MOV     #0,W4
079C0:  MOV     W4,30B6
079C2:  MOV     296C,W0
079C4:  BCLR.B  0.4
079C6:  MOV     W0,296C
079C8:  SETM    32C
079CA:  BRA     7C74
079CC:  DATA    81,80,1A
079CE:  DATA    90,00,3E
079D0:  DATA    7C,42,F8
079D2:  DATA    C6,84,BA
079D4:  DATA    95,AB,E9
079D6:  DATA    D7,6D,53
079D8:  DATA    11,2F,4F
079DA:  DATA    71,33,0D
079DC:  DATA    B7,89,CB
079DE:  DATA    F5,DA,E4
079E0:  DATA    A6,98,22
079E2:  DATA    1C,5E,60
079E4:  DATA    9E,A0,E2
079E6:  DATA    DC,66,58
079E8:  DATA    1A,24,0B
079EA:  DATA    35,77,49
079EC:  DATA    F3,CD,8F
079EE:  DATA    B1,D1,EF
079F0:  DATA    AD,93,29
079F2:  DATA    17,55,6B
079F4:  DATA    44,7A,38
079F6:  DATA    06,BC,82
079F8:  DATA    C0,FE,59
079FA:  DATA    67,25,1B
079FC:  DATA    A1,9F,DD
079FE:  DATA    E3,CC,F2
07A00:  DATA    B0,8E,34
07A02:  DATA    0A,48,76
07A04:  DATA    16,28,6A
07A06:  DATA    54,EE,D0
07A08:  DATA    92,AC,83
07A0A:  DATA    BD,FF,C1
07A0C:  DATA    7B,45,07
07A0E:  DATA    39,C7,F9
07A10:  DATA    BB,85,3F
07A12:  DATA    01,43,7D
07A14:  DATA    52,6C,2E
07A16:  DATA    10,AA,94
07A18:  DATA    D6,E8,88
07A1A:  DATA    B6,F4,CA
07A1C:  DATA    70,4E,0C
07A1E:  DATA    32,1D,23
07A20:  DATA    61,5F,E5
07A22:  DATA    DB,99,A7
07A24:  DATA    B2,8C,CE
07A26:  DATA    F0,4A,74
07A28:  DATA    36,08,27
07A2A:  DATA    19,5B,65
07A2C:  DATA    DF,E1,A3
07A2E:  DATA    9D,FD,C3
07A30:  DATA    81,BF,05
07A32:  DATA    3B,79,47
07A34:  DATA    68,56,14
07A36:  DATA    2A,90,AE
07A38:  DATA    EC,D2,2C
07A3A:  DATA    12,50,6E
07A3C:  DATA    D4,EA,A8
07A3E:  DATA    96,B9,87
07A40:  DATA    C5,FB,41
07A42:  DATA    7F,3D,03
07A44:  DATA    63,5D,1F
07A46:  DATA    21,9B,A5
07A48:  DATA    E7,D9,F6
07A4A:  DATA    C8,8A,B4
07A4C:  DATA    0E,30,72
07A4E:  DATA    4C,EB,D5
07A50:  DATA    97,A9,13
07A52:  DATA    2D,6F,51
07A54:  DATA    7E,40,02
07A56:  DATA    3C,86,B8
07A58:  DATA    FA,C4,A4
07A5A:  DATA    9A,D8,E6
07A5C:  DATA    5C,62,20
07A5E:  DATA    1E,31,0F
07A60:  DATA    4D,73,C9
07A62:  DATA    F7,B5,8B
07A64:  DATA    75,4B,09
07A66:  DATA    37,8D,B3
07A68:  DATA    F1,CF,E0
07A6A:  DATA    DE,9C,A2
07A6C:  DATA    18,26,64
07A6E:  DATA    5A,3A,04
07A70:  DATA    46,78,C2
07A72:  DATA    FC,BE,80
07A74:  DATA    AF,91,D3
07A76:  DATA    ED,57,69
07A78:  DATA    2B,15,7C
07A7A:  DATA    88,59,39
07A7C:  DATA    E0,97,A6
07A7E:  DATA    3A,C4,1D
07A80:  DATA    1E,3C,5E
07A82:  DATA    50,63,3D
07A84:  DATA    1A,FE,75
07A86:  DATA    3E,18,72
07A88:  DATA    31,3F,0F
07A8A:  DATA    8C,55,A6
07A8C:  DATA    82,95,D9
07A8E:  DATA    3D,E6,D7
07A90:  DATA    FF,E5,C9
07A92:  DATA    90,C7,BD
07A94:  DATA    CE,40,12
07A96:  DATA    47,0C,B7
07A98:  DATA    42,3E,9F
07A9A:  DATA    6D,94,C3
07A9C:  DATA    25,6D,7A
07A9E:  DATA    3E,DA,32
07AA0:  DATA    0E,BE,9F
07AA2:  DATA    3E,B6,3E
07AA4:  DATA    6D,AA,28
07AA6:  DATA    C2,B4,FA
07AA8:  DATA    EF,3E,89
07AAA:  DATA    E0,29,E5
07AAC:  DATA    A4,30,24
07AAE:  DATA    3F,A3,8E
07AB0:  DATA    FA,E3,7E
07AB2:  DATA    D8,55,3F
07AB4:  DATA    C6,04,8A
07AB6:  DATA    78,AB,B2
07AB8:  DATA    83,3F,CD
07ABA:  DATA    ED,A6,D6
07ABC:  DATA    08,6B,AC
07ABE:  DATA    3F,FD,D1
07AC0:  DATA    84,FF,BD
07AC2:  DATA    BF,CE,3F
07AC4:  DATA    A1,35,FA
07AC6:  DATA    FE,42,2E
07AC8:  DATA    E6,3F,99
07ACA:  DATA    47,8A,BF
07ACC:  DATA    00,00,00
07ACE:  DATA    40,40,08
07AD0:  DATA    00,00,08
07AD2:  DATA    4C,F3,BA
07AD4:  DATA    3D,2B,9D
07AD6:  DATA    5F,BF,40
07AD8:  DATA    08,00,00
07ADA:  DATA    18,05,BD
07ADC:  DATA    9A,4A,1A
07ADE:  DATA    A6,C2,BF
07AE0:  DATA    B4,B9,2A
07AE2:  DATA    1D,07,D9
07AE4:  DATA    F5,3F,02
07AE6:  DATA    EB,89,67
07AE8:  DATA    DB,F6,08
07AEA:  DATA    C0,40,07
07AEC:  DATA    00,00,39
07AEE:  DATA    40,2B,F2
07AF0:  DATA    93,8B,43
07AF2:  DATA    C5,78,3F
07AF4:  DATA    4F,E0,5D
07AF6:  DATA    A2,84,A9
07AF8:  DATA    CA,BF,38
07AFA:  DATA    8F,AC,EF
07AFC:  DATA    B5,D2,F1
07AFE:  DATA    3F,D8,3F
07B00:  DATA    DF,BC,30
07B02:  DATA    4C,FE,BF
07B04:  DATA    37,BF,FD
07B06:  DATA    3E,3D,AA
07B08:  DATA    93,C0,EE
07B0A:  DATA    50,B3,40
07B0C:  DATA    00,00,80
07B0E:  DATA    3F,0A,8D
07B10:  DATA    B1,C0,EE
07B12:  DATA    50,B3,40
07B14:  DATA    40,06,00
07B16:  DATA    00,6B,F0
07B18:  DATA    3F,5C,0A
07B1A:  DATA    58,F6,3B
07B1C:  DATA    8F,00,C0
07B1E:  DATA    3C,8B,28
07B20:  DATA    AC,3C,BE
07B22:  DATA    F6,3F,D2
07B24:  DATA    D5,44,16
07B26:  DATA    8C,15,D7
07B28:  DATA    BF,69,00
07B2A:  DATA    5A,2E,1B
07B2C:  DATA    87,99,3F
07B2E:  DATA    9A,5F,AD
07B30:  DATA    4B,91,E4
07B32:  DATA    01,C0,5D
07B34:  DATA    11,2F,92
07B36:  DATA    E4,81,FB
07B38:  DATA    3F,38,DA
07B3A:  DATA    91,80,9D
07B3C:  DATA    C5,E0,BF
07B3E:  DATA    6F,12,C0
07B40:  DATA    B4,C3,09
07B42:  DATA    AB,3F,6B
07B44:  DATA    C1,03,4E
07B46:  DATA    C1,B5,45
07B48:  DATA    BF,0A,89
07B4A:  DATA    34,3E,7C
07B4C:  DATA    79,B5,40
07B4E:  DATA    3F,02,B3
07B50:  DATA    41,33,8C
07B52:  DATA    9E,41,00
07B54:  DATA    00,80,3F
07B56:  DATA    1B,E4,35
07B58:  DATA    41,A4,DB
07B5A:  DATA    E7,41,33
07B5C:  DATA    8C,9E,41
07B5E:  DATA    F7,40,05
07B60:  DATA    FF,00,5C
07B62:  DATA    EF,3F,F3
07B64:  DATA    A3,E2,F7
07B66:  DATA    D7,FF,01
07B68:  DATA    40,C0,B4
07B6A:  DATA    FF,05,3C
07B6C:  DATA    58,FC,3F
07B6E:  DATA    3B,D3,C0
07B70:  DATA    B5,BA,8C
07B72:  DATA    E2,3F,39
07B74:  DATA    D3,C7,3D
07B76:  DATA    41,79,B2
07B78:  DATA    3F,87,0D
07B7A:  DATA    3C,50,D0
07B7C:  DATA    AF,62,3F
07B7E:  DATA    30,4B,8D
07B80:  DATA    A2,82,AA
07B82:  DATA    04,40,09
07B84:  DATA    A0,40,4A
07B86:  DATA    05,76,03
07B88:  DATA    40,EC,9E
07B8A:  DATA    37,88,A6
07B8C:  DATA    44,F0,3F
07B8E:  DATA    8F,12,8D
07B90:  DATA    29,9A,5B
07B92:  DATA    C7,3F,0E
07B94:  DATA    E0,80,7C
07B96:  DATA    A1,D8,86
07B98:  DATA    3F,29,4B
07B9A:  DATA    FB,95,C2
07B9C:  DATA    37,1A,3F
07B9E:  DATA    00,00,80
07BA0:  DATA    0A,1D,56
07BA2:  DATA    4E,45,54
07BA4:  DATA    47,45,41
07BA6:  DATA    52,33,31
07BA8:  DATA    00,80,11
07BAA:  DATA    1D,76,72
07BAC:  DATA    6F,79,61
07BAE:  DATA    6C,75,6D
07BB0:  DATA    62,72,65
07BB2:  DATA    6C,6C,61
07BB4:  DATA    30,35,33
07BB6:  DATA    00,80,0C
07BB8:  DATA    1D,B6,57
07BBA:  DATA    50,41,32
07BBC:  DATA    50,53,4B
07BBE:  DATA    00,41,45
07BC0:  DATA    53,00,C0
07BC2:  DATA    2A,29,34
07BC4:  DATA    00,80,01
07BC6:  DATA    29,6C,00
07BC8:  DATA    80,01,2E
07BCA:  DATA    B3,00,80
07BCC:  DATA    01,2E,B9
07BCE:  DATA    00,80,4E
07BD0:  DATA    2E,C8,00
07BD2:  DATA    95,00,00
07BD4:  DATA    01,F9,00
07BD6:  DATA    00,08,87
07BD8:  DATA    04,00,09
07BDA:  DATA    AF,00,01
07BDC:  DATA    0A,1B,00
07BDE:  DATA    01,0C,C3
07BE0:  DATA    01,00,0D
07BE2:  DATA    AF,02,00
07BE4:  DATA    10,FF,00
07BE6:  DATA    00,11,FF
07BE8:  DATA    00,01,12
07BEA:  DATA    FF,00,01
07BEC:  DATA    18,FF,00
07BEE:  DATA    01,19,FF
07BF0:  DATA    00,01,20
07BF2:  DATA    FF,00,00
07BF4:  DATA    21,FF,00
07BF6:  DATA    00,26,DF
07BF8:  DATA    01,00,37
07BFA:  DATA    73,00,00
07BFC:  DATA    3A,25,04
07BFE:  DATA    00,3B,25
07C00:  DATA    00,00,29
07C02:  DATA    FF,04,00
07C04:  DATA    17,FF,40
07C06:  DATA    1C,00,80
07C08:  DATA    03,31,38
07C0A:  DATA    64,65,6C
07C0C:  DATA    40,07,00
07C0E:  DATA    00,04,6D
07C10:  DATA    61,6B,65
07C12:  DATA    40,06,00
07C14:  DATA    00,06,61
07C16:  DATA    70,70,65
07C18:  DATA    6E,64,40
07C1A:  DATA    04,00,00
07C1C:  DATA    02,63,64
07C1E:  DATA    40,08,00
07C20:  DATA    00,03,64
07C22:  DATA    69,72,40
07C24:  DATA    07,00,00
07C26:  DATA    03,63,61
07C28:  DATA    74,40,07
07C2A:  DATA    00,00,04
07C2C:  DATA    74,61,69
07C2E:  DATA    6C,40,06
07C30:  DATA    00,00,05
07C32:  DATA    6D,6B,64
07C34:  DATA    69,72,40
07C36:  DATA    05,00,00
07C38:  DATA    05,72,6D
07C3A:  DATA    64,69,72
07C3C:  DATA    40,05,00
07C3E:  DATA    00,06,66
07C40:  DATA    6F,72,6D
07C42:  DATA    61,74,40
07C44:  DATA    04,00,00
07C46:  DATA    04,68,65
07C48:  DATA    6C,70,40
07C4A:  DATA    06,00,00
07C4C:  DATA    05,6D,6F
07C4E:  DATA    75,6E,74
07C50:  DATA    40,05,00
07C52:  DATA    00,05,69
07C54:  DATA    6E,66,6F
07C56:  DATA    00,00,00
07C58:  INC     W2,W2
07C5A:  CP      W2,#1
07C5C:  BRA     NZ,7C66
07C5E:  TBLRDL  [W1],W3
07C60:  TBLRDH  [W1++],W4
07C62:  MOV.B   6,W0L
07C64:  RETURN  
07C66:  CP      W2,#2
07C68:  BRA     NZ,7C6E
07C6A:  MOV.B   7,W0L
07C6C:  RETURN  
07C6E:  MOV.B   8,W0L
07C70:  CLR     W2
07C72:  RETURN  
07C74:  MOV     #0,W6
07C76:  MOV     #0,W0
07C78:  MOV     W0,32
07C7A:  MOV     #79CC,W0
07C7C:  MOV     W0,W1
07C7E:  CLR     W2
07C80:  CALL    7C58
07C84:  MOV.B   W0L,B
07C86:  CALL    7C58
07C8A:  MOV.B   W0L,A
07C8C:  CP0     W5
07C8E:  BRA     Z,7CC2
07C90:  BTSS    W5.F
07C92:  BRA     7CA2
07C94:  CALL    7C58
07C98:  MOV.B   W0L,D
07C9A:  CALL    7C58
07C9E:  MOV.B   W0L,C
07CA0:  BCLR    W5.F
07CA2:  BTSS    W5.E
07CA4:  BRA     7CB6
07CA6:  BCLR    W5.E
07CA8:  DEC     W5,W5
07CAA:  CALL    7C58
07CAE:  MOV.B   W0L,W7L
07CB0:  REPEAT  W5
07CB2:  MOV.B   W7L,[W6++]
07CB4:  BRA     7C80
07CB6:  CALL    7C58
07CBA:  MOV.B   W0L,[W6++]
07CBC:  DEC     W5,W5
07CBE:  BRA     NZ,7CB6
07CC0:  BRA     7C80
.................... clearRouters(routerTable);	//Ensures router table is empty 
07CC2:  MOV     #2154,W4
07CC4:  MOV     W4,3802
07CC6:  CALL    21C2
....................  
.................... char uffit[80]; 
07CCA:  MOV     #0,W4
07CCC:  MOV     W4,3798
07CCE:  MOV     #0,W4
07CD0:  MOV     W4,379A
07CD2:  MOV     #0,W4
07CD4:  MOV     W4,379C
07CD6:  MOV     #0,W4
07CD8:  MOV     W4,379E
07CDA:  MOV     #0,W4
07CDC:  MOV     W4,37A0
07CDE:  MOV     #0,W4
07CE0:  MOV     W4,37A2
07CE2:  MOV     #0,W4
07CE4:  MOV     W4,37A4
07CE6:  MOV     #0,W4
07CE8:  MOV     W4,37A6
07CEA:  MOV     #0,W4
07CEC:  MOV     W4,37A8
07CEE:  MOV     #0,W4
07CF0:  MOV     W4,37AA
07CF2:  MOV     #0,W4
07CF4:  MOV     W4,37AC
07CF6:  MOV     #0,W4
07CF8:  MOV     W4,37AE
07CFA:  MOV     #0,W4
07CFC:  MOV     W4,37B0
07CFE:  MOV     #0,W4
07D00:  MOV     W4,37B2
07D02:  MOV     #0,W4
07D04:  MOV     W4,37B4
07D06:  MOV     #0,W4
07D08:  MOV     W4,37B6
07D0A:  MOV     #0,W4
07D0C:  MOV     W4,37B8
07D0E:  MOV     #0,W4
07D10:  MOV     W4,37BA
07D12:  MOV     #0,W4
07D14:  MOV     W4,37BC
07D16:  MOV     #0,W4
07D18:  MOV     W4,37BE
07D1A:  MOV     #0,W4
07D1C:  MOV     W4,37C0
07D1E:  MOV     #0,W4
07D20:  MOV     W4,37C2
07D22:  MOV     #0,W4
07D24:  MOV     W4,37C4
07D26:  MOV     #0,W4
07D28:  MOV     W4,37C6
07D2A:  MOV     #0,W4
07D2C:  MOV     W4,37C8
07D2E:  MOV     #0,W4
07D30:  MOV     W4,37CA
07D32:  MOV     #0,W4
07D34:  MOV     W4,37CC
07D36:  MOV     #0,W4
07D38:  MOV     W4,37CE
07D3A:  MOV     #0,W4
07D3C:  MOV     W4,37D0
07D3E:  MOV     #0,W4
07D40:  MOV     W4,37D2
07D42:  MOV     #0,W4
07D44:  MOV     W4,37D4
07D46:  MOV     #0,W4
07D48:  MOV     W4,37D6
07D4A:  MOV     #0,W4
07D4C:  MOV     W4,37D8
07D4E:  MOV     #0,W4
07D50:  MOV     W4,37DA
07D52:  MOV     #0,W4
07D54:  MOV     W4,37DC
07D56:  MOV     #0,W4
07D58:  MOV     W4,37DE
07D5A:  MOV     #0,W4
07D5C:  MOV     W4,37E0
07D5E:  MOV     #0,W4
07D60:  MOV     W4,37E2
07D62:  MOV     #0,W4
07D64:  MOV     W4,37E4
07D66:  MOV     #0,W4
07D68:  MOV     W4,37E6
....................  
.................... 		VacDisplayinit();   //This sets the VFD into nibble mode and ready to send characters to the display. 
07D6A:  CALL    2324
.................... 		VacDisplayClear(); 
07D6E:  CALL    236E
.................... //		wifiRestore(); 
....................  
....................  
....................  
.................... 		SetupADC();   //Added October 3, 2014.  This inits the water depth and water temperature sensors 
07D72:  CALL    2388
.................... 	       InitTAOS(); 
07D76:  CALL    2652
....................  
.................... //ExposureTimeTAOS(1, 3); 
.................... 		initRHTemp(); 
07D7A:  CALL    26DE
.................... //Light Sensor testing   -  To be removied 
.................... Display_XYString(0,1,"Initialize: "); 
07D7E:  MOV     #D,W3
07D80:  MOV     #0,W2
07D82:  MOV     #37E8,W1
07D84:  MOV     W3,[W15++]
07D86:  MOV     W2,W0
07D88:  CALL    1592
07D8C:  MOV     [--W15],W3
07D8E:  MOV.B   W0L,[W1++]
07D90:  INC     W2,W2
07D92:  DEC     W3,W3
07D94:  BTSS.B  42.1
07D96:  BRA     7D84
07D98:  MOV     #0,W4
07D9A:  MOV     W4,39BA
07D9C:  MOV     #1,W4
07D9E:  MOV     W4,39BC
07DA0:  MOV     #37E8,W4
07DA2:  MOV     W4,39BE
07DA4:  CALL    27B0
....................  
.................... 	pwm_set_duty(DO_PWM,0);	//250hz  Turn off light for DO 
07DA8:  MOV     #0,W4
07DAA:  MOV     W4,3802
07DAC:  CALL    27CC
.................... 	pwm_set_duty(PH_PWM,0);	//250hz 
07DB0:  MOV     #0,W4
07DB2:  MOV     W4,3872
07DB4:  CALL    27D2
....................  
.................... xp=350;         //Starting PWM 
07DB8:  MOV     #15E,W4
07DBA:  MOV     W4,197A
.................... /* 
.................... while(1) 
.................... 	{ 
....................  
....................  
....................  
....................  
.................... gainof = GetCurrentColor(4, 3); 
.................... sysOutput.lLevelRed=red; 
.................... sysOutput.lLevelGreen=green; 
.................... sysOutput.lLevelBlue=blue; 
.................... sysOutput.lLevelClear=clear; 
.................... sysOutput.lLevelScale=gainof; 
....................  
.................... delay_ms(1000); 
.................... //		xp = SetPWMWithPhotoTransistor(xp, 200); 
....................  
.................... //		sprintf(uffit,"ADC %Lu  %Lu %f ",  GetADCValue(2), xp, ConvertTopH()); 
.................... //		Display_XYString(0, 2, &uffit); 
....................  
.................... 	} 
....................  
.................... */ 
.................... //while(1) 
.................... //	{ 
.................... //sysOutput.wTemp = ConvertADCToKalvin(5); 
.................... //	setTAOSGain(0,0, 3); 
....................  
....................  
.................... //PWMPHIntensity = FindMiddlePWMSensor(PWMPHIntensity, 2); 
....................  
.................... 	 
.................... //MeasureWAGuyspH(26250); 
.................... //	sensorRead(); 
....................  
.................... //	sprintf(uffit,"Gain %Lu Temp %f ",GetCurrentColorAVG(4, 1),sysOutput.wTemp); 
.................... //	Display_XYString(0, 2, &uffit); 
.................... //	sprintf(uffit,"ADC %Lu  ",  GetADCValue(2)); 
.................... //	Display_XYString(0, 3, &uffit); 
....................  
.................... //	} 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................    FSFILE* f; 
....................  
....................  
.................... while(1) 
.................... { 
....................    if (!g_IsMounted) 
.................... 	{ 
.................... 	sprintf(uffit,"Not Mounted"); 
.................... 	Display_XYString(0, 2, &uffit); 
.................... 	} 
....................  
.................... 	else 
.................... 	{ 
.................... 	 
.................... 	} 
....................  
....................  
.................... } 
.................... */ 
....................  
....................  
.................... Display_XYString(0,1,"Loading"); 
07DBC:  MOV     #8,W3
07DBE:  MOV     #0,W2
07DC0:  MOV     #37E8,W1
07DC2:  MOV     W3,[W15++]
07DC4:  MOV     W2,W0
07DC6:  CALL    15AC
07DCA:  MOV     [--W15],W3
07DCC:  MOV.B   W0L,[W1++]
07DCE:  INC     W2,W2
07DD0:  DEC     W3,W3
07DD2:  BTSS.B  42.1
07DD4:  BRA     7DC2
07DD6:  MOV     #0,W4
07DD8:  MOV     W4,39BA
07DDA:  MOV     #1,W4
07DDC:  MOV     W4,39BC
07DDE:  MOV     #37E8,W4
07DE0:  MOV     W4,39BE
07DE2:  CALL    27B0
.................... xRST(); 
07DE6:  CALL    27D8
.................... 	//	wifiRestore(); 
.................... Display_XYString(0,1,"Check Link"); 
07DEA:  MOV     #B,W3
07DEC:  MOV     #0,W2
07DEE:  MOV     #37E8,W1
07DF0:  MOV     W3,[W15++]
07DF2:  MOV     W2,W0
07DF4:  CALL    15C0
07DF8:  MOV     [--W15],W3
07DFA:  MOV.B   W0L,[W1++]
07DFC:  INC     W2,W2
07DFE:  DEC     W3,W3
07E00:  BTSS.B  42.1
07E02:  BRA     7DF0
07E04:  MOV     #0,W4
07E06:  MOV     W4,39BA
07E08:  MOV     #1,W4
07E0A:  MOV     W4,39BC
07E0C:  MOV     #37E8,W4
07E0E:  MOV     W4,39BE
07E10:  CALL    27B0
....................  
....................  
....................  
....................  
.................... 		while (xReadyWiFi()) 
07E14:  CALL    27E8
07E18:  CP0.B   W0L
07E1A:  BRA     Z,7E2A
07E1C:  BRA     7E1E
.................... 			{ 
.................... 			delay_ms(2); 
07E1E:  REPEAT  #3CFE
07E20:  NOP     
07E22:  REPEAT  #3FFF
07E24:  NOP     
07E26:  GOTO    7E14
.................... 			} 
.................... 		delay_ms(10000);   //Delay time for WiFi to come up from zero power.  Added Nov. 23, 2014 
07E2A:  MOV     #2710,W0
07E2C:  CALL    21F2
.................... 	 
....................  
....................  
....................  
....................  
....................  
....................  
.................... //InitTAOS();  // Inint all of the light spectrum sensors  Added April 27, 2014 
.................... //FindMiddlePWMSensor(1, 1); 
....................  
....................  
.................... /* 
.................... //SD card test routines\ 
....................  
....................  
.................... while(1) 
.................... { 
....................  
.................... } 
.................... */ 
....................  
....................  
....................  
....................  
.................... WFIsConfig=1;	//Check for wifi link, if linked then you're good 
07E30:  BSET.B  85D.1
.................... delay_ms(2000); 
07E32:  MOV     #7D0,W0
07E34:  CALL    21F2
.................... if(nLinkWiFi()) 
07E38:  CALL    27FC
07E3C:  CP0.B   W0L
07E3E:  BRA     Z,7E72
07E40:  BRA     7E42
.................... 	{ 
.................... 	WFIsConfig=0; 
07E42:  BCLR.B  85D.1
.................... 	Display_XYString(0,1,"Initialize: "); 
07E44:  MOV     #D,W3
07E46:  MOV     #0,W2
07E48:  MOV     #37E8,W1
07E4A:  MOV     W3,[W15++]
07E4C:  MOV     W2,W0
07E4E:  CALL    1592
07E52:  MOV     [--W15],W3
07E54:  MOV.B   W0L,[W1++]
07E56:  INC     W2,W2
07E58:  DEC     W3,W3
07E5A:  BTSS.B  42.1
07E5C:  BRA     7E4A
07E5E:  MOV     #0,W4
07E60:  MOV     W4,39BA
07E62:  MOV     #1,W4
07E64:  MOV     W4,39BC
07E66:  MOV     #37E8,W4
07E68:  MOV     W4,39BE
07E6A:  CALL    27B0
.................... 	} 
07E6E:  GOTO    7E9C
.................... else 
.................... 	{ 
.................... 	Display_XYString(0,1,"Already Linked    "); 
07E72:  MOV     #13,W3
07E74:  MOV     #0,W2
07E76:  MOV     #37E8,W1
07E78:  MOV     W3,[W15++]
07E7A:  MOV     W2,W0
07E7C:  CALL    15D8
07E80:  MOV     [--W15],W3
07E82:  MOV.B   W0L,[W1++]
07E84:  INC     W2,W2
07E86:  DEC     W3,W3
07E88:  BTSS.B  42.1
07E8A:  BRA     7E78
07E8C:  MOV     #0,W4
07E8E:  MOV     W4,39BA
07E90:  MOV     #1,W4
07E92:  MOV     W4,39BC
07E94:  MOV     #37E8,W4
07E96:  MOV     W4,39BE
07E98:  CALL    27B0
.................... 	} 
....................  
.................... 		   enable_interrupts(INT_RDA3); 
07E9C:  BSET.B  9E.2
.................... 		   enable_interrupts(INT_RDA3); 
07E9E:  BSET.B  9E.2
.................... 		   enable_interrupts(GLOBAL); 
07EA0:  BCLR.B  81.7
07EA2:  CLR     42
07EA4:  BSET.B  81.7
....................  
.................... 		dataInit(); 
07EA6:  CALL    2810
.................... 		initRHTemp(); 
07EAA:  CALL    26DE
....................  
.................... 		wifiInit(); 
07EAE:  CALL    2842
....................  
....................  
....................  
....................  
.................... 	#if USESENSORS 
.................... 		InitTAOS();  // Inint all of the light spectrum sensors  Added April 27, 2014 
07EB2:  CALL    2652
.................... 		SetupADC();   //Added October 3, 2014.  This inits the water depth and water temperature sensors 
07EB6:  CALL    2388
.................... 	#endif 
....................  
....................  
....................  
.................... /////////BEGIN INFINITE LOOP 
....................  
....................  
.................... while(1) 
.................... { 
.................... dataSplitter(); 
07EBA:  CALL    41B8
....................  
....................  
....................  
.................... if(WFIsConfig==0) 
07EBE:  BTSS.B  85D.1
07EC0:  BRA     7EC4
07EC2:  BRA     7ED2
.................... //if(0==1) 
.................... { 
.................... WIFI_STA_CCONFIG(0); 
07EC4:  MOV     39B2,W0
07EC6:  MOV.B   #0,W0L
07EC8:  MOV     W0,39B2
07ECA:  CALL    37A6
.................... } 
07ECE:  GOTO    81B4
.................... else 
.................... { 
.................... char testcntrStr[5]; 
07ED2:  MOV     #0,W4
07ED4:  MOV     W4,37FC
07ED6:  MOV     #0,W4
07ED8:  MOV     W4,37FE
07EDA:  MOV     3800,W0
07EDC:  MOV.B   #0,W0L
07EDE:  MOV     W0,3800
.................... #if LCD_EN 
.................... sprintf(testcntrStr,"%5ld",testcntr); 
07EE0:  MOV     #37FC,W4
07EE2:  MOV     W4,214A
07EE4:  MOV     85A,W0
07EE6:  MOV     #5,W4
07EE8:  CALL    35FC
.................... Display_XYString(0,2,testcntrStr); 
07EEC:  MOV     #0,W4
07EEE:  MOV     W4,39BA
07EF0:  MOV     #2,W4
07EF2:  MOV     W4,39BC
07EF4:  MOV     #37FC,W4
07EF6:  MOV     W4,39BE
07EF8:  CALL    27B0
.................... #endif 
....................  
.................... writeSSR(); 
07EFC:  CALL    445E
.................... //if(testcntr>5000000&&startText==0) 
....................  
.................... /* 
.................... ///////CHANGE HERE! 
.................... if(testcntr>600) 
.................... { 
.................... WFIsConfig=0; 
.................... testcntr=0; 
.................... } 
.................... */ 
....................  
....................  
.................... if((clientOrServer==SERVER) && testcntr>(SENDINTERVAL-100)) 
07F00:  BTSC.B  85C.6
07F02:  BRA     7F06
07F04:  BRA     7F14
07F06:  MOV     85A,W4
07F08:  MOV     #2BC,W3
07F0A:  CP      W3,W4
07F0C:  BRA     GE,7F14
07F0E:  BRA     7F10
.................... { 
.................... setClient(); 
07F10:  CALL    4460
.................... } 
....................  
....................  
.................... if(ISWWWPARSE && testcntr>100) 
07F14:  BTSC.B  85C.5
07F16:  BRA     7F1A
07F18:  BRA     7F2A
07F1A:  MOV     85A,W4
07F1C:  MOV     #64,W3
07F1E:  CP      W3,W4
07F20:  BRA     GE,7F2A
07F22:  BRA     7F24
.................... { 
.................... setServer(); 
07F24:  CALL    28C8
.................... resetParsing=1; 
07F28:  BSET.B  85D.3
.................... } 
....................  
....................  
.................... if(testcntr>SENDINTERVAL) 
07F2A:  MOV     85A,W4
07F2C:  MOV     #320,W3
07F2E:  CP      W3,W4
07F30:  BRA     GE,81A6
07F32:  BRA     7F34
.................... //if(1==0) 
.................... { 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #if USESENSORS  
....................  
.................... sensorRead(); 
07F34:  CALL    71B4
....................  
.................... #endif 
.................... { 
.................... testcntr=0; 
07F38:  CLR     85A
....................  
.................... //sysOutput.cO2=sysInput.chksum; 
.................... reloadTime(); 
07F3A:  CALL    728C
.................... sysOutput.rH=sysOutput.rH+0.1; 
07F3E:  BCLR.B  43.0
07F40:  MOV     1940,W0
07F42:  MOV     1942,W1
07F44:  MOV     #CCCD,W2
07F46:  MOV     #3DCC,W3
07F48:  CALL    478A
07F4C:  MOV     W0,1940
07F4E:  MOV     W1,1942
.................... printTime(sysOutput.year,sysOutput.month,sysOutput.day,sysOutput.hour,sysOutput.minute,sysOutput.second); 
07F50:  MOV.B   1912,W0L
07F52:  PUSH    3804
07F54:  MOV.B   W0L,[W15-#2]
07F56:  POP     3804
07F58:  MOV.B   1911,W0L
07F5A:  PUSH    3804
07F5C:  MOV.B   W0L,[W15-#1]
07F5E:  POP     3804
07F60:  MOV.B   190E,W0L
07F62:  PUSH    3806
07F64:  MOV.B   W0L,[W15-#2]
07F66:  POP     3806
07F68:  MOV.B   190F,W0L
07F6A:  PUSH    3806
07F6C:  MOV.B   W0L,[W15-#1]
07F6E:  POP     3806
07F70:  MOV.B   1910,W0L
07F72:  PUSH    3808
07F74:  MOV.B   W0L,[W15-#2]
07F76:  POP     3808
07F78:  PUSH    1914
07F7A:  POP     3802
07F7C:  CALL    72A6
....................  
.................... sprintf(HTTPoutput,"Crab$%s$%s$%5f$%5f$%5f$%5f$%5f$%5f$%5f$%ld$%5f$%lu$%lu$%lu$%lu$%5f$%5f",sysOutput.deviceID,timeString,sysOutput.dOxy,sysOutput.wTemp,sysOutput.pH,sysOutput.wLevel,sysOutput.lLevelX,sysOutput.rH,sysOutput.aTemp,sysOutput.cO2,sysOutput.nH4,sysOutput.lLevelRed,sysOutput.lLevelGreen,sysOutput.lLevelBlue,sysOutput.lLevelClear,sysOutput.lLevelScale,sysOutput.dPoint); 
07F80:  MOV     #35A2,W4
07F82:  MOV     W4,214A
07F84:  MOV     #0,W1
07F86:  MOV     W1,W0
07F88:  CLR.B   1
07F8A:  CALL    15F8
07F8E:  INC     W1,W1
07F90:  MOV     W1,[W15++]
07F92:  MOV     W0,[W15++]
07F94:  MOV     [--W15],W0
07F96:  CALL    35EA
07F9A:  MOV     [--W15],W1
07F9C:  MOV     #4,W0
07F9E:  CPSGT   W1,W0
07FA0:  BRA     7F86
07FA2:  MOV     214A,W0
07FA4:  CLR.B   [W0]
07FA6:  MOV.B   #0,W4L
07FA8:  MOV.B   W4L,[W0+#1]
07FAA:  MOV     #18FE,W1
07FAC:  CP0.B   [W1]
07FAE:  BRA     Z,7FC0
07FB0:  MOV     W1,[W15++]
07FB2:  MOV     W1,W4
07FB4:  MOV.B   [W4],W0L
07FB6:  CALL    35EA
07FBA:  MOV     [--W15],W1
07FBC:  INC     W1,W1
07FBE:  BRA     7FAC
07FC0:  MOV.B   #24,W0L
07FC2:  CALL    35EA
07FC6:  MOV     214A,W0
07FC8:  CLR.B   [W0]
07FCA:  MOV.B   #0,W4L
07FCC:  MOV.B   W4L,[W0+#1]
07FCE:  MOV     #195E,W1
07FD0:  CP0.B   [W1]
07FD2:  BRA     Z,7FE4
07FD4:  MOV     W1,[W15++]
07FD6:  MOV     W1,W4
07FD8:  MOV.B   [W4],W0L
07FDA:  CALL    35EA
07FDE:  MOV     [--W15],W1
07FE0:  INC     W1,W1
07FE2:  BRA     7FD0
07FE4:  MOV.B   #24,W0L
07FE6:  CALL    35EA
07FEA:  MOV     191A,W2
07FEC:  MOV     1918,W1
07FEE:  MOV     #0,W0
07FF0:  CALL    6796
07FF4:  MOV     #6,W9
07FF6:  MOV     #7,W10
07FF8:  CALL    7506
07FFC:  MOV.B   #24,W0L
07FFE:  CALL    35EA
08002:  MOV     191E,W2
08004:  MOV     191C,W1
08006:  MOV     #0,W0
08008:  CALL    6796
0800C:  MOV     #6,W9
0800E:  MOV     #7,W10
08010:  CALL    7506
08014:  MOV.B   #24,W0L
08016:  CALL    35EA
0801A:  MOV     1922,W2
0801C:  MOV     1920,W1
0801E:  MOV     #0,W0
08020:  CALL    6796
08024:  MOV     #6,W9
08026:  MOV     #7,W10
08028:  CALL    7506
0802C:  MOV.B   #24,W0L
0802E:  CALL    35EA
08032:  MOV     1926,W2
08034:  MOV     1924,W1
08036:  MOV     #0,W0
08038:  CALL    6796
0803C:  MOV     #6,W9
0803E:  MOV     #7,W10
08040:  CALL    7506
08044:  MOV.B   #24,W0L
08046:  CALL    35EA
0804A:  MOV     192A,W2
0804C:  MOV     1928,W1
0804E:  MOV     #0,W0
08050:  CALL    6796
08054:  MOV     #6,W9
08056:  MOV     #7,W10
08058:  CALL    7506
0805C:  MOV.B   #24,W0L
0805E:  CALL    35EA
08062:  MOV     1942,W2
08064:  MOV     1940,W1
08066:  MOV     #0,W0
08068:  CALL    6796
0806C:  MOV     #6,W9
0806E:  MOV     #7,W10
08070:  CALL    7506
08074:  MOV.B   #24,W0L
08076:  CALL    35EA
0807A:  MOV     194A,W2
0807C:  MOV     1948,W1
0807E:  MOV     #0,W0
08080:  CALL    6796
08084:  MOV     #6,W9
08086:  MOV     #7,W10
08088:  CALL    7506
0808C:  MOV.B   #24,W0L
0808E:  CALL    35EA
08092:  MOV     194C,W0
08094:  MOV     #0,W4
08096:  CALL    35FC
0809A:  MOV.B   #24,W0L
0809C:  CALL    35EA
080A0:  MOV     1950,W2
080A2:  MOV     194E,W1
080A4:  MOV     #0,W0
080A6:  CALL    6796
080AA:  MOV     #6,W9
080AC:  MOV     #7,W10
080AE:  CALL    7506
080B2:  MOV.B   #24,W0L
080B4:  CALL    35EA
080B8:  MOV     1930,W0
080BA:  MOV     #0,W4
080BC:  CALL    6D14
080C0:  MOV.B   #24,W0L
080C2:  CALL    35EA
080C6:  MOV     1932,W0
080C8:  MOV     #0,W4
080CA:  CALL    6D14
080CE:  MOV.B   #24,W0L
080D0:  CALL    35EA
080D4:  MOV     1934,W0
080D6:  MOV     #0,W4
080D8:  CALL    6D14
080DC:  MOV.B   #24,W0L
080DE:  CALL    35EA
080E2:  MOV     1936,W0
080E4:  MOV     #0,W4
080E6:  CALL    6D14
080EA:  MOV.B   #24,W0L
080EC:  CALL    35EA
080F0:  MOV     193E,W2
080F2:  MOV     193C,W1
080F4:  MOV     #0,W0
080F6:  CALL    6796
080FA:  MOV     #6,W9
080FC:  MOV     #7,W10
080FE:  CALL    7506
08102:  MOV.B   #24,W0L
08104:  CALL    35EA
08108:  MOV     1954,W2
0810A:  MOV     1952,W1
0810C:  MOV     #0,W0
0810E:  CALL    6796
08112:  MOV     #6,W9
08114:  MOV     #7,W10
08116:  CALL    7506
.................... unsigned int8 checksum = Calc_Crc8(HTTPoutput,strlenn(HTTPoutput)); 
0811A:  MOV     #35A2,W4
0811C:  MOV     W4,3802
0811E:  CALL    7694
08122:  MOV     W0,W5
08124:  MOV     #35A2,W4
08126:  MOV     W4,3806
08128:  MOV     W5,3808
0812A:  CALL    76B8
0812E:  PUSH    3800
08130:  MOV.B   W0L,[W15-#1]
08132:  POP     3800
....................  
.................... //sprintf(HTTPwString,"GET /welcomeyou.php?name=%s&chksm=%u HTTP/1.1\r\nHost: osmobot.org\r\n\r\n",HTTPoutput,checksum); 
.................... fprintf(WIFI,"GET /welcomeyou.php?name=%s&chksm=%u HTTP/1.1\r\nHost: osmobot.org\r\n\r\n",HTTPoutput,checksum); 
08134:  MOV     #0,W1
08136:  MOV     W1,W0
08138:  CLR.B   1
0813A:  CALL    1644
0813E:  INC     W1,W1
08140:  BTSC.B  253.1
08142:  BRA     8140
08144:  MOV     W0,254
08146:  MOV     #18,W0
08148:  CPSGT   W1,W0
0814A:  BRA     8136
0814C:  MOV     #35A2,W1
0814E:  CP0.B   [W1]
08150:  BRA     Z,8160
08152:  BTSC.B  253.1
08154:  BRA     8152
08156:  MOV.B   [W1+#0],W0L
08158:  MOV.B   W0L,254
0815A:  CLR.B   255
0815C:  INC     W1,W1
0815E:  BRA     814E
08160:  MOV     #1B,W1
08162:  MOV     W1,W0
08164:  CLR.B   1
08166:  CALL    1644
0816A:  INC     W1,W1
0816C:  BTSC.B  253.1
0816E:  BRA     816C
08170:  MOV     W0,254
08172:  MOV     #21,W0
08174:  CPSGT   W1,W0
08176:  BRA     8162
08178:  PUSH    3800
0817A:  MOV     [--W15],W0
0817C:  LSR     W0,#8,W0
0817E:  CLR.B   1
08180:  MOV     #0,W4
08182:  CALL    770C
08186:  MOV     #24,W1
08188:  MOV     W1,W0
0818A:  CLR.B   1
0818C:  CALL    1644
08190:  INC     W1,W1
08192:  BTSC.B  253.1
08194:  BRA     8192
08196:  MOV     W0,254
08198:  MOV     #43,W0
0819A:  CPSGT   W1,W0
0819C:  BRA     8188
.................... sysOutput.second=sysOutput.second+1; 
0819E:  MOV     1910,W4
081A0:  ADD.B   W4L,#1,W4L
081A2:  MOV.B   W4L,W0L
081A4:  MOV.B   W0L,1910
....................  
.................... //fprintf(WIFI,HTTPwString); 
.................... //Display_XYString(0,3,"Last Post At:"); 
.................... //Display_XYString(0,3,timeString); 
.................... 				}			 
.................... 			} 
.................... 		if(nLinkWiFi()==0) 
081A6:  CALL    27FC
081AA:  SE      W0,W5
081AC:  CP0     W5
081AE:  BRA     NZ,81B4
081B0:  BRA     81B2
.................... 			{ 
.................... 			testcntr++;	//Increment the counter if the device is connected to something	 
081B2:  INC     085A
.................... 			} 
.................... 		}	 
081B4:  GOTO    7EBA
.................... 	} 
.................... } 
081B8:  BRA     81B8

Configuration Fuses:
   Word  1L: 365F   WPOSTS16 WDT128 WINDIS NOWDT ICSP2 DEBUG NOWRT NOPROTECT NOJTAG
          H: FF00  
   Word  2L: 83F9   XT IOL1WAY NOOSCIO PR_PLL IESO
          H: FF00  
   Word  3L: FFFF   WPFP WPDIS NOWPCFG WPEND
          H: FF00  
   Word  4L: 0000  
          H: FF00  

   Some fuses have been forced to be compatible with the ICD debugger.
